<html>
<head>
<title>Understand Temporal Coupling in Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解代码中的时间耦合</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/temporal-coupling-in-code-e74899f7a48f?source=collection_archive---------6-----------------------#2022-02-14">https://betterprogramming.pub/temporal-coupling-in-code-e74899f7a48f?source=collection_archive---------6-----------------------#2022-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dd0f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">我们经常谈论耦合，耦合到底是什么？</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/5c614f0f5445ee2df1ffbefc082723bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UrvZqN0L9uK6XzO4"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Florian Olivo </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8317" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一般来说，有三种类型的组件耦合。</p><ol class=""><li id="ca0c" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls ly lz ma mb bi translated">传入耦合:A组件的任务必须依赖于B、C和d的实现。</li></ol><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/2e0dcf27ad71c62f622a251c1f46f7e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*SSCMX0zM8-8Gws4VXwep5g.png"/></div></figure><p id="3aad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">2.传出耦合:A组件的任务完成后，必须执行B、C、D。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/1bbd0bb2a840e348e96ce9cbf59a7070.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*rLqf9u2kJOHIGL8LcEBgVg.png"/></div></figure><p id="2999" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">3.时间耦合:A组件的任务完成后，必须执行B和C。另外，B比c早。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi md"><img src="../Images/4d31eeb0b1c6c9409cd9f362f978c3d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*tjkqnGevNGSW5zLVn-sJkw.png"/></div></figure><p id="38cd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里提到的组件根据粒度可以是源代码级、模块级甚至服务级。</p><p id="7aad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本文中，我们将特别深入探讨时间耦合，因为这是最常见也是最容易被忽略的陷阱。首先我们在Node.js中描述如下:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div class="gh gi me"><img src="../Images/dbb4fc65d297f847834bbe81b3a56d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/1*toZFte37Li_5D7I_g203bw.png"/></div></figure><p id="338b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这一点上，我们发现这是非常普遍的。几乎我们所有的代码都是这样的。在一个方法中按顺序做三件事是很正常的，不是吗？</p><p id="f014" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们举一个更具体的例子。假设我们有一个电商，有一个功能，<code class="fe mf mg mh mi b">purchase</code>。因此，我们开始用简单的方式编码。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mj"><img src="../Images/9c9b0d83093dea8994a77e142a933a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bq3Btv9FvTOmWN0h4hKuMQ.png"/></div></div></figure><p id="ae97" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先汇总购物车中所有商品的价格。然后调用支付服务来处理信用卡。简单吧？</p><p id="694b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">好的，营销团队想让消费超过1000美元的人获得折扣券，所以我们继续修改我们的<code class="fe mf mg mh mi b">purchase</code>。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mk"><img src="../Images/b25ccd538a1c31f0df80803fba26888c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlZYz55Pw54uoS6Zsy2CaA.png"/></div></div></figure><p id="7389" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这个功能也是相当普遍的，然后销售团队发现优惠券是一个很好的推广方式，于是提出达到5000美金的人可以获得一次抽奖机会。这个<code class="fe mf mg mh mi b">purchase</code>一直在成长。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mk"><img src="../Images/efbe03e69e14c18e144c749106a70095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izql41NdZm2gQhxaFdCGyQ.png"/></div></div></figure><p id="0b4e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一种时间耦合。无论是<code class="fe mf mg mh mi b">giveCoupon</code>还是<code class="fe mf mg mh mi b">lottery</code>，其实都是依赖于<code class="fe mf mg mh mi b">purchase</code>的，必须在<code class="fe mf mg mh mi b">purchase</code>的生命周期内完成。一旦功能需求越来越大，整个<code class="fe mf mg mh mi b">purchase</code>的性能就会被不断拖累。尤其是<code class="fe mf mg mh mi b">lottery</code>通常需要巨大的计算量，<code class="fe mf mg mh mi b">purchase</code>被迫等待<code class="fe mf mg mh mi b">lottery</code>成功才算成功。</p><h1 id="1149" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">通过域事件解耦计时</h1><p id="d5ce" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">从上一节中，我们了解到<code class="fe mf mg mh mi b">purchase</code>应该只需要处理付款，其余的行为是附加的，不应该与<code class="fe mf mg mh mi b">purchase</code>处于同一个生命周期。换句话说，即使<code class="fe mf mg mh mi b">giveCoupon</code>失败了，也不应该影响到<code class="fe mf mg mh mi b">purchase</code>或者<code class="fe mf mg mh mi b">lottery</code>。</p><p id="9a46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">领域驱动开发中有一种方法叫领域事件。当一个任务完成后，它会发出一个事件，关心该事件的处理程序在收到该事件后可以采取相应的动作。顺便说一下，这种方法在设计模式中也被称为<em class="ni">观察者模式</em>。在领域驱动的开发中，“通知”包含了领域中无处不在的语言，因此通知被命名为域事件。</p><p id="347e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，让我们以节点的方式稍微修改一下<code class="fe mf mg mh mi b">purchase</code>。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mk"><img src="../Images/14031aa4836fceef5a1325d520f598c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0lcfBJKz0ywUgRvhfb-kFg.png"/></div></div></figure><p id="d5ca" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过事件，我们可以将<code class="fe mf mg mh mi b">giveCoupon</code>和<code class="fe mf mg mh mi b">lottery</code>与<code class="fe mf mg mh mi b">purchase</code>完全解耦。即使任何一个处理程序失败，也不会影响原始的支付流程。</p><p id="5402" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">而<code class="fe mf mg mh mi b">purchase</code>只需要专注于支付过程。当支付成功时，发出事件，让其他函数接管。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nj"><img src="../Images/5ead3d21c213ab3875f67b98c5be844d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UY2qnE1kDwMGvAvxIij7w.png"/></div></div></figure><p id="2d96" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果以后有更多的需求，不需要改变原来的<code class="fe mf mg mh mi b">purchase</code>，只需要增加一个新的handler即可。这就是脱钩的概念。这里我们去掉了代码级耦合和时序级耦合。</p><h1 id="a1b3" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">如何处理事件损失</h1><p id="ee7b" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">在我之前的文章中，我们提到无论何时失败都可能发生，我们必须预料到它们并优雅地处理它们。这被称为<a class="ae kw" href="https://www.bmc.com/blogs/resilience-engineering/" rel="noopener ugc nofollow" target="_blank">弹性工程</a>。</p><p id="1f2b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们通过域事件将优惠券和彩票解耦时，我们将立即面临一个问题。活动输了怎么办？付款完成了，但是优惠券还没发，这对客户来说肯定是个大问题。</p><p id="d111" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">换句话说，我们如何确保发出的事件将被执行。这正是消息队列被引入系统的原因。</p><p id="8981" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们之前讨论过<a class="ae kw" href="https://selectfrom.dev/message-queue-in-redis-9efe0de2c39c" rel="noopener ugc nofollow" target="_blank">消息队列</a>，在消息传递中有三种不同级别的保证，它们是:</p><ul class=""><li id="e5ce" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls nk lz ma mb bi translated">最多一次</li><li id="07b4" class="lt lu iq kz b la nl ld nm lg nn lk no lo np ls nk lz ma mb bi translated">至少一次</li><li id="8210" class="lt lu iq kz b la nl ld nm lg nn lk no lo np ls nk lz ma mb bi translated">正好一次</li></ul><p id="ba7a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">大多数消息队列有至少一次的保证。也就是说，通过消息队列，我们可以确保所有事件至少可以执行一次。这也确保了消息不会丢失。</p><p id="fc65" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，为了避免事件丢失，我们将使用RabbitMQ或Kafka将<code class="fe mf mg mh mi b">emitter.emit</code>更改为队列提交。在这个阶段，我们已经在系统级引入了解耦，即让事件生产者和消费者属于不同的执行单元。</p><h1 id="1f6d" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">如何处理排放损失</h1><p id="ead1" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">故事还没有结束。我们已经可以确保发出的事件得到执行。如果事件根本没有发送呢？继续以<code class="fe mf mg mh mi b">purchase</code>为例，当<code class="fe mf mg mh mi b">payByCreditCard</code>已经成功，但是由于意外原因导致系统崩溃而没有发送事件。然后，即使有消息队列，我们仍然得到不正确的结果。</p><p id="51bb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了避免这个问题，我们可以利用事件源。在<a class="ae kw" href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" rel="noopener">分布式事务</a>和<a class="ae kw" href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" rel="noopener"> CQRS </a>中，我已经描述了事件源的核心概念。</p><p id="0fbd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在发出事件之前，首先将事件存储到存储中。在处理程序处理完事件后，在存储器中将事件标记为“已处理”。</p><p id="3881" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">有一点应该注意，事件的编写和支付必须在同一个事务下进行。这样，只要支付成功，事件也就写成功了。最后，我们可以定期监控过期事件，以了解哪里出错了。</p><h1 id="cd5e" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">结论</h1><p id="836a" class="pw-post-body-paragraph kx ky iq kz b la nd jr lc ld ne ju lf lg nf li lj lk ng lm ln lo nh lq lr ls ij bi translated">这一次我们仍然在经历系统的一步一步的进化，就像我们在<a class="ae kw" href="https://medium.com/interviewnoodle/shift-from-monolith-to-cqrs-a34bab75617e" rel="noopener">从整体到CQRS </a>的转变中所做的那样，让你知道当系统变得庞大和复杂时如何解耦。一开始，我们首先通过域事件将源代码和执行时序解耦；然后我们引入了消息队列和消息生产者和消费者来实现系统级的解耦。</p><p id="b87f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就像我之前说的，一个系统进化是为了解决一个问题，但是它也会产生新的问题。只能选择最能接受的方案，在复杂度、性能、生产力等因素上寻求妥协。</p><p id="f1bd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">将一个完整的动作分割成不同的执行单元必然会遇到不一致的情况。在解决不一致时，有许多考虑因素，例如:</p><ul class=""><li id="a9d2" class="lt lu iq kz b la lb ld le lg lv lk lw lo lx ls nk lz ma mb bi translated">不管事件是否会丢失，就用最简单的架构，<code class="fe mf mg mh mi b">EventEmitter</code>。这种做法最简单，可能80%的情况下都没有问题，但是如果有问题怎么办？</li><li id="dea9" class="lt lu iq kz b la nl ld nm lg nn lk no lo np ls nk lz ma mb bi translated">试图尽可能可靠，所以引入消息队列，它应该99%确定不会有问题。但还是有1%，这样的风险可承受吗？</li><li id="fb01" class="lt lu iq kz b la nl ld nm lg nn lk no lo np ls nk lz ma mb bi translated">实现事件源是以增加复杂性为代价的，性能可能会受到影响。这可以接受吗？</li></ul><p id="7e6d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就像我常说的，系统设计没有完美的解决方案。每个组织都有不同的风险承受能力。在各种指标中，寻找自己最能接受的解决方案，思考自己随时面临的风险和失败。因此，每个人都应该能够建立一个有弹性的系统。</p></div></div>    
</body>
</html>