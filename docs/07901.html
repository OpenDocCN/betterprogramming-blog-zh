<html>
<head>
<title>How To Set Up a Dependency Injection Framework With Dagger2 in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中用Dagger2建立依赖注入框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-set-up-a-dependency-injection-framework-with-dagger2-in-android-aa23ee9299db?source=collection_archive---------4-----------------------#2021-03-03">https://betterprogramming.pub/how-to-set-up-a-dependency-injection-framework-with-dagger2-in-android-aa23ee9299db?source=collection_archive---------4-----------------------#2021-03-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="98e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">洁净建筑导论</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/719089109ee15eb527e4e9a41771a4a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pJA7pJ2HRqhJpY_O"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卢卡·布拉沃在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="98c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我职业生涯的早期，我认为尽快完成一项任务是让你成为一名高效开发人员的原因。我相信你们很多人也这么想，但是你知道<a class="ae ky" href="https://www.goodreads.com/quotes/87111-good-judgment-comes-from-experience-and-experience-comes-from-bad" rel="noopener ugc nofollow" target="_blank">他们怎么说</a>:</p><blockquote class="lv"><p id="0b48" class="lw lx it bd ly lz ma mb mc md me lu dk translated">"好的判断来自经验，而经验来自坏的判断."</p></blockquote><p id="4d29" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">快进到今天，我是一名有五年经验的Android开发人员。我从自己的经验中学到的最重要的一课是，拥有合适的架构和按时完成工作一样重要。</p><p id="40cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从现在起的一天或一年后，您可能会陷入无法维护代码、模块之间紧密耦合或者重复编写相同代码的境地。</p><p id="332a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决所有这些问题的一个简单方法是在编写代码时保持谨慎。这可能是显而易见的，但肯定不容易。开发人员必须学习很多概念，比如:</p><ul class=""><li id="b23d" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated">依赖注入</li><li id="eb88" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">存储库模式</li><li id="b92a" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">基础组件</li><li id="8b16" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated">状态管理</li></ul><p id="ab46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你开始实现代码时，你会遇到核心问题，并学习新的东西来解决它们。这个系列是关于使用我多年来学到的所有概念来构建一个具有合适的干净架构的Android应用程序。这将是一个漫长的系列，所以系好安全带。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="2a60" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">为什么要清洁建筑？</h1><ol class=""><li id="7411" class="mk ml it lb b lc nx lf ny li nz lm oa lq ob lu oc mq mr ms bi translated">关注点的分离——将代码分离成不同的模块或具有特定职责的部分，使得维护和进一步修改更加容易。</li><li id="8e02" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu oc mq mr ms bi translated">松散耦合—灵活的代码。不改变体制，什么都可以改变。</li><li id="9a61" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu oc mq mr ms bi translated">易于测试——由于模块之间的松散耦合，我们可以轻松地单独测试组件。</li></ol><p id="0c75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是清洁架构的新手，有很多关于这个主题的文章。我推荐读这本书:</p><div class="od oe gp gr of og"><a href="https://medium.com/android-dev-hacks/detailed-guide-on-android-clean-architecture-9eab262a9011" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Android清洁架构详细指南</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">编写Android应用程序的最佳方式</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="20c3" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">我们将学到什么</h1><p id="4989" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">正如我所说，这将是一个冗长的系列，我们将涵盖从DI到状态管理的所有内容。在第一部分中，我将用Dagger2介绍依赖注入设置。</p><p id="d31e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在以后的部分中，我们将介绍带有协程的存储库设置和用例、基本组件、带有密封类的状态管理，以及一些实用程序和扩展，它们将使您的生活变得简单。</p><p id="a60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我错过了以上列表中的任何东西，请留下评论。我将试着把它们作为本系列的连续部分来讨论。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="586e" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">用Dagger2进行依赖注入</h1><p id="b45e" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">依赖注入是一种在需要时提供类的实例的方法，而不是在没有任何样板代码的情况下创建它。DI的主要优势是代码的可重用性和资源的有效利用。<a class="ae ky" href="https://github.com/google/dagger" rel="noopener ugc nofollow" target="_blank"> Dagger2 </a>是Android开发中用来实现DI的著名库。</p><p id="ac5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Dagger2的高级设置。我想你应该熟悉DI和Dagger2。如果没有，请停止阅读并浏览下面的文章:</p><div class="od oe gp gr of og"><a href="https://medium.com/better-programming/dependency-injection-in-android-with-dagger2-d260b8a72bb0" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Android中的依赖注入与Dagger2</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">了解你需要知道的关于Dagger2的一切</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oy l or os ot op ou ks og"/></div></div></a></div><h2 id="03d2" class="oz ng it bd nh pa pb dn nl pc pd dp np li pe pf nr lm pg ph nt lq pi pj nv pk bi translated">综合</h2><p id="5841" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">要将Dagger2集成到您的项目中，请在应用程序级<code class="fe pl pm pn po b">build.gradle</code>文件中的<code class="fe pl pm pn po b">dependencies</code>标签下添加以下库:</p><pre class="kj kk kl km gt pp po pq pr aw ps bi"><span id="8a34" class="oz ng it po b gy pt pu l pv pw">implementation <strong class="po iu">"com.google.dagger:dagger-android:2.17"</strong><br/>implementation <strong class="po iu">"com.google.dagger:dagger-android-support:2.17"</strong><br/>kapt <strong class="po iu">"com.google.dagger:dagger-compiler:2.27"</strong><br/>kapt <strong class="po iu">"com.google.dagger:dagger-android-processor:2.17"</strong></span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="fb33" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">Dagger2模块</h1><p id="2787" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">在创建模块之前，我们需要知道在我们的Android组件中需要哪些依赖对象。比如做一个网络请求，我们需要<code class="fe pl pm pn po b">OkHttp</code>和序列化依赖(<code class="fe pl pm pn po b">Gson</code>、<code class="fe pl pm pn po b">Moshi</code>等)。)对象，这些对象有助于创建一个<code class="fe pl pm pn po b">Retrofit</code>实例。如果您使用Firebase进行分析，我们需要一个<code class="fe pl pm pn po b">FirebaseAnalytics</code>实例来记录事件。</p><p id="2636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于任何Android项目来说，这些都是必需的。您可以拥有特定于项目的依赖关系。例如，如果您的应用程序支持离线，那么您可能希望实现房间数据库，因此我们需要提供Room的抽象类实现作为依赖项。</p><p id="9651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们省略了一些必要的依赖组件，比如首选项助手、存储库、改进的API服务接口等等。我们将在接下来的文章中关注它们的依赖注入。</p><p id="b847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在根包下创建一个<code class="fe pl pm pn po b">di</code>包，然后添加下面的模块。在创建以下模块之前，您需要复习一些概念:</p><ul class=""><li id="9d0e" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><code class="fe pl pm pn po b">@Module</code>:用于创建依赖类对象的类。</li><li id="3cc1" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe pl pm pn po b">@Provides</code>:用于模块类内部的方法，提供依赖关系。</li><li id="05cf" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe pl pm pn po b">@Binds</code>:类似于<code class="fe pl pm pn po b">provides</code>，但是它被表达为一个抽象方法，并且只有一个参数，这个参数应该等于它的返回类型(主要是指它的一个实现)。与<code class="fe pl pm pn po b">provides</code>不同的是，<code class="fe pl pm pn po b">binds</code>不会为每个函数生成工厂类，这将减少40%的代码。</li></ul><h2 id="6911" class="oz ng it bd nh pa pb dn nl pc pd dp np li pe pf nr lm pg ph nt lq pi pj nv pk bi translated">网络模块</h2><p id="981a" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">网络模块包含整个项目中与网络相关的所有依赖项，如<code class="fe pl pm pn po b">OkHttp</code>、<code class="fe pl pm pn po b">Retrofit</code>、<code class="fe pl pm pn po b">Gson</code>、<code class="fe pl pm pn po b">Firebase</code>等。我们需要创建一个名为<code class="fe pl pm pn po b">NetworkModule</code>的Kotlin类，然后用<code class="fe pl pm pn po b">@Module</code>对其进行注释。看一看:</p><pre class="kj kk kl km gt pp po pq pr aw ps bi"><span id="f8be" class="oz ng it po b gy pt pu l pv pw"><strong class="po iu">@Module</strong><br/>class NetworkModule {</span><span id="e416" class="oz ng it po b gy px pu l pv pw">}</span></pre><p id="95a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个类中，我们需要创建前面提到的所有依赖项。首先，尝试创建不依赖他人的依赖关系。然后创建依赖于已创建对象的依赖对象。这样，您就不会错过我们创建任何其他依赖对象(如<code class="fe pl pm pn po b">Retrofit</code>)所需的任何依赖(如<code class="fe pl pm pn po b">OkHttp</code>和<code class="fe pl pm pn po b">Gson</code>)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure><h2 id="807e" class="oz ng it bd nh pa pb dn nl pc pd dp np li pe pf nr lm pg ph nt lq pi pj nv pk bi translated">数据模块</h2><p id="02c8" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">一旦我们完成了网络模块，就该创建数据模块了。数据模块包含体系结构的数据层中存在的依赖关系。因此，在下一部分中，当我们试图创建一个存储库和用例时，我们将处理数据模块。</p><p id="59f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，只需创建一个名为<code class="fe pl pm pn po b">DataModule</code>的Kotlin类，并包含<code class="fe pl pm pn po b">NetworkModule</code>:</p><pre class="kj kk kl km gt pp po pq pr aw ps bi"><span id="14b3" class="oz ng it po b gy pt pu l pv pw"><strong class="po iu">@Module</strong>(<strong class="po iu">includes </strong>= [<strong class="po iu">NetworkModule</strong>::class])<br/>abstract class <strong class="po iu">DataModule </strong>{</span><span id="1078" class="oz ng it po b gy px pu l pv pw">}</span></pre><h2 id="a66b" class="oz ng it bd nh pa pb dn nl pc pd dp np li pe pf nr lm pg ph nt lq pi pj nv pk bi translated">AppModule</h2><p id="f2d4" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">这里，我们必须创建另一个名为<code class="fe pl pm pn po b">AppModule</code>的Kotlin类，并用Dagger的<code class="fe pl pm pn po b">@Module</code>注释对其进行注释。在这里，我们将包括像<code class="fe pl pm pn po b">context</code>这样的依赖关系。如果您正在使用RxJava，我们可以提供调度程序等等。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure><h2 id="23e3" class="oz ng it bd nh pa pb dn nl pc pd dp np li pe pf nr lm pg ph nt lq pi pj nv pk bi translated">AppActivityBindingModule</h2><p id="3a67" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">我们必须创建一个模块，以确保所有的Android组件，如<code class="fe pl pm pn po b">Activities</code>，可以注入我们创建的依赖关系。Dagger提供了开箱即用的<code class="fe pl pm pn po b">ContributesAndroidInjector</code>注释来实现这一点。我们需要创建一个抽象函数，其返回类型是所需的活动，并用<code class="fe pl pm pn po b">ContributesAndroidInjector</code>注释该函数。</p><p id="0acf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe pl pm pn po b">ContributesAndroidInjector</code>为此方法的返回类型生成一个<code class="fe pl pm pn po b">AndroidInjector</code>。注射器由一个<strong class="lb iu"> </strong>匕首<code class="fe pl pm pn po b">subcomponent</code>实现，并将成为匕首模块的子模块。它应该只应用于抽象函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure><p id="1263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，这个和<code class="fe pl pm pn po b">Activities</code>一起工作很好。你可能会对<code class="fe pl pm pn po b">Fragments</code>感到疑惑。这就是事情变得有点棘手的地方。你注意到上面代码中的<code class="fe pl pm pn po b">@ActivityScoped</code>注释了吗？不是匕首图书馆的。我们需要创造这个范围。这里，我们必须创建三个范围:</p><ol class=""><li id="3d34" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu oc mq mr ms bi translated"><code class="fe pl pm pn po b">ActivityScoped</code></li><li id="71fb" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu oc mq mr ms bi translated"><code class="fe pl pm pn po b">FragmentScoped</code></li><li id="c656" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu oc mq mr ms bi translated"><code class="fe pl pm pn po b">NestedFragmentScoped</code></li></ol><p id="9902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在返回各自Android组件的Dagger模块类中的各自函数上使用这些作用域。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure><p id="9e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，问题是如何为<code class="fe pl pm pn po b">Fragments</code>创建Dagger子组件。简单地说，我们需要为您在特定的<code class="fe pl pm pn po b">Activity</code>上展开的每组<code class="fe pl pm pn po b">Fragments</code>创建一个模块类，然后将这个模块包含在那个<code class="fe pl pm pn po b">Activity</code>的抽象方法中。让我们为<code class="fe pl pm pn po b">Intro</code> <code class="fe pl pm pn po b">Activity</code>创建一个简单的模块类，它有两个<code class="fe pl pm pn po b">Fragments</code> ( <code class="fe pl pm pn po b">IntroHomeFragment</code>和<code class="fe pl pm pn po b">OtpVerificationFragment</code>)。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure><p id="b1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要将<code class="fe pl pm pn po b">IntroModule</code>包含在<code class="fe pl pm pn po b">AppActivityBindingModule</code>内其各自的<code class="fe pl pm pn po b">Activity</code>抽象函数中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure><p id="a81f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们完成了Dagger模块的基本实现。创建具有特定名称的不同模块的主要原因是为了保持整洁的结构。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="fa07" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">Dagger2 AppComponent</h1><p id="af79" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">模块类不会直接提供依赖关系。相反，它将创建一个接口，作为<code class="fe pl pm pn po b">@Module</code>和<code class="fe pl pm pn po b">@Inject</code>之间的桥梁。</p><p id="37b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要创建一个名为<code class="fe pl pm pn po b">AppComponent</code>的Kotlin接口类，并用<code class="fe pl pm pn po b">AndroidInjector&lt;ApplicationClass&gt;</code>扩展它。由于它是一个应用程序组件，我们需要确保它只使用<code class="fe pl pm pn po b">@Singleton</code>注释创建了一次。然后我们还需要用<code class="fe pl pm pn po b">@Component</code>进行注释，并包含所有的模块。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="eed9" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">触发代码生成</h1><p id="4886" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">这是最后一步。至此，我们完成了Dagger模块和组件的设置。现在我们必须在应用程序启动时触发Dagger组件生成。为此，我将使用<code class="fe pl pm pn po b">DaggerApplication</code>扩展应用程序类，然后覆盖<code class="fe pl pm pn po b">applicationInjector</code>函数，我们将在其中初始化<code class="fe pl pm pn po b">AppComponent</code>。</p><p id="dd97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，一旦我们完成了模块和组件，我们需要重新构建项目，以便Dagger生成代码。除非你这样做了，否则<code class="fe pl pm pn po b">DaggerAppComponent</code>不会生成。看一下实现情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="py pz l"/></div></figure></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="d880" class="nf ng it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">奖金</h1><h2 id="4368" class="oz ng it bd nh pa pb dn nl pc pd dp np li pe pf nr lm pg ph nt lq pi pj nv pk bi translated">GitHub回购</h2><p id="f157" class="pw-post-body-paragraph kz la it lb b lc nx ju le lf ny jx lh li ov lk ll lm ow lo lp lq ox ls lt lu im bi translated">导入项目，切换到<code class="fe pl pm pn po b">branch articles/dagger_setup</code>可以看到与本文相关的代码:</p><div class="od oe gp gr of og"><a href="https://github.com/SG-K/Clean-Architecture-Sample" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">SG-K/Clean-架构-示例</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">在GitHub上创建一个帐户，为SG-K/Clean-Architecture-Sample开发做贡献。</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="qa l or os ot op ou ks og"/></div></div></a></div><p id="7142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解有关依赖注入的更多信息，请阅读以下文章:</p><ul class=""><li id="ce84" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><a class="ae ky" href="https://medium.com/better-programming/dependency-injection-in-android-with-dagger2-d260b8a72bb0" rel="noopener">“Android中的依赖注入与dagger 2”</a></li><li id="33dc" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" href="https://medium.com/better-programming/hilt-a-new-dependency-injection-library-for-android-e6e00e719aeb" rel="noopener">“Hilt——一个新的Android依赖注入库”</a></li><li id="0eac" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/koin-kotlin-native-dependency-injection-library-f1daddc1ef99" rel="noopener">“Koin—kot Lin原生依赖注入库”</a></li><li id="7268" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><a class="ae ky" href="https://medium.com/better-programming/koin-a-kotlin-native-dependency-injection-library-8e13b81bd48e" rel="noopener">“Koin—一个Kotlin原生依赖注入库(第二部分)”</a></li></ul><p id="e835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>