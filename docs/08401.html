<html>
<head>
<title>Stop Using Primitive Types in Domain Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在域类中使用基本类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-primitive-types-in-domain-classes-c45f5973d640?source=collection_archive---------0-----------------------#2021-04-27">https://betterprogramming.pub/stop-using-primitive-types-in-domain-classes-c45f5973d640?source=collection_archive---------0-----------------------#2021-04-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a58f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免字符串、整型、双精度和其他原始类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2830c5aec730a4b1822f1764f6a160f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3hoqtTD3AJSQa5vlFPCxQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ky kz ep" href="https://medium.com/u/7c7a43b3d9de?source=post_page-----c45f5973d640--------------------------------" rel="noopener" target="_blank">尼克拉斯·米勒德</a>提供</p></figure><p id="fb86" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">原始类型不传达任何有意义的领域知识——所以<em class="lw">不要仅仅用这些类型来构建你的领域类</em>。</p><p id="e8c1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">显然，你不能完全避免字符串(虽然，技术上不是一个基本类型)、整型、双精度型和其他基本类型。它们是任何代码和应用程序的基本构件。但是，你可以在重要的地方做出努力。</p><blockquote class="lx"><p id="791e" class="ly lz it bd ma mb mc md me mf mg lv dk translated">忽略编写适当的域类和值对象是许多代码库反复出现的主题。</p></blockquote><p id="7259" class="pw-post-body-paragraph la lb it lc b ld mh ju lf lg mi jx li lj mj ll lm ln mk lp lq lr ml lt lu lv im bi translated">让我们看看如何编写更好的类，恰当地捕获特定领域的知识和业务规则，从而产生更安全、更灵活的代码。</p><h2 id="c315" class="mm mn it bd mo mp mq dn mr ms mt dp mu lj mv mw mx ln my mz na lr nb nc nd ne bi translated">在我们开始之前…</h2><p id="4352" class="pw-post-body-paragraph la lb it lc b ld nf ju lf lg ng jx li lj nh ll lm ln ni lp lq lr nj lt lu lv im bi translated">我制作了一个关于这个主题的短片。如果你是一个视觉学习者，或者喜欢文字材料和视觉效果的结合，那么请跟随这里。</p><h2 id="7025" class="mm mn it bd mo mp mq dn mr ms mt dp mu lj mv mw mx ln my mz na lr nb nc nd ne bi translated">我们将会研究什么</h2><p id="5a99" class="pw-post-body-paragraph la lb it lc b ld nf ju lf lg ng jx li lj nh ll lm ln ni lp lq lr nj lt lu lv im bi translated">所以，我们会保持简单。我们的演示代码显然是一个虚构的例子，但它确实成功地实现了我的意图:说明如何轻松地将典型的原始类型转化为实际的域对象。</p><p id="b9f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们想把左边变成右边的代码。</p><div class="kj kk kl km gt ab cb"><figure class="nl kn nm nn no np nq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/9cc995781419236f9ba96e25207255b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*EvuSGjA7f92PhwNt-64JyA.png"/></div></figure><figure class="nl kn nr nn no np nq paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ddfee036062996e30232e576b730bd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*Yc7isabKHzQk-6ygNAqkeA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk ns di nt nu translated">典型类(左)变成了适当的域类(左)</p></figure></div><p id="814f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您可以很容易地看到左边的代码片段看起来比右边的要干净得多。这个真的没什么特别的。没有魔法，没有一个“见鬼”的时刻。</p><p id="f3a0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因此，这两个类是一种尝试，来模拟我们希望如何在应用程序中定义我们的用途。</p><p id="a931" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">“两处房产？！就这些？”我听到你哭了！在你的狂热继续之前，让我提醒你——这只是一个例子，我可以使用任何其他东西。</p><p id="dc51" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我在塑造什么并不重要。我在这里所要讲的就是通过专门化的对象获取领域知识的概念。</p><p id="a04a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个第一，<code class="fe nv nw nx ny b">SimpleUser</code>类已经抓住了一个原始痴迷的坏案例。绝对没有任何东西阻碍任何人用一个2GB的大文本串来初始化<code class="fe nv nw nx ny b">Username</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/1abdada86f66ac9d204cbd59728b0273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvuSGjA7f92PhwNt-64JyA.png"/></div></div></figure><p id="47a0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">旁注，想想你在验证一个用户名是否有效时必须做什么:你需要一遍又一遍地写同样的检查。</p><p id="8b00" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个类有太多的错误，所以我只关注一个子集，你可以很容易地马上修复它。</p><p id="2f37" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">第一，构造函数很乱。通过逐行阅读代码，我们会注意到我们有两条管理用户名的规则。</p><p id="37c8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">用户名不能为null或空(显然)，并且不能超过100个字符。</p><p id="4387" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">其次，所有属性都有公共setters。对于我曾经工作过的大多数领域来说，这是不可行的。任何公共setter都在尖叫“我不在乎你用什么值初始化我。你传给我什么我就储存什么。”</p><h2 id="a17c" class="mm mn it bd mo mp mq dn mr ms mt dp mu lj mv mw mx ln my mz na lr nb nc nd ne bi translated">我们如何修复这个写得很差的类？</h2><p id="32af" class="pw-post-body-paragraph la lb it lc b ld nf ju lf lg ng jx li lj nh ll lm ln ni lp lq lr nj lt lu lv im bi translated">这是。超级棒。简单。</p><p id="40ae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">看看下面的代码片段。这没什么大不了的，但是，从概念上来说，它与<code class="fe nv nw nx ny b">SimpleUser</code>有一个重要的区别，我会在你花点时间浏览代码后解释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/d576c164179a6c6fa8a30cb86c90c66b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teHMCWWKylEfuK3Bh7l3Hw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示正确的域类。</p></figure><p id="ec5f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">当然，这比简单的实现要多得多——但是谁说过伟大的代码都是一行代码呢？</p><p id="2276" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本质上，所有关于用户名构成的业务规则都被转移到一个单独的类型中，即<code class="fe nv nw nx ny b">Username</code>类。</p><p id="19d8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">看看倒数第二行代码，隐式操作符。它传达的意思是，你可以隐式地使用字符串来代替这个类，就像最后一行演示的那样。</p><blockquote class="lx"><p id="0bcd" class="ly lz it bd ma mb mc md me mf mg lv dk translated"><em class="ob">向丹麦人Mads Torgersen致敬，他创造了一种令人敬畏的语言！</em></p></blockquote><p id="3794" class="pw-post-body-paragraph la lb it lc b ld mh ju lf lg mi jx li lj mj ll lm ln mk lp lq lr ml lt lu lv im bi translated">将业务逻辑和特定领域的知识转移到单独的类型中的主要好处之一是，您将不再需要重复自己。每当你需要一个用户名时，你现在可以很容易地将<code class="fe nv nw nx ny b">Username</code>类型添加到任何方法或构造函数参数中，所有的检查都会为你完成。</p><p id="b941" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在，试着在您自己的代码库中想一些将从这种方法中受益的例子。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="d8d5" class="oj mn it bd mo ok ol om mr on oo op mu jz oq ka mx kc or kd na kf os kg nd ot bi translated">主要外卖</h1><p id="2f78" class="pw-post-body-paragraph la lb it lc b ld nf ju lf lg ng jx li lj nh ll lm ln ni lp lq lr nj lt lu lv im bi translated">我会尽力为你很好地总结这一点，以防你在匆忙中浏览到最后。</p><p id="5be2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">努力捕获特殊类型的规则——您需要提前编写更多的代码，但是没关系。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="079d" class="oj mn it bd mo ok ol om mr on oo op mu jz oq ka mx kc or kd na kf os kg nd ot bi translated">好奇者的资源</h1><ul class=""><li id="68ce" class="ou ov it lc b ld nf lg ng lj ow ln ox lr oy lv oz pa pb pc bi translated"><a class="ae nk" href="https://github.com/NMillard/BasicSolutionStructure" rel="noopener ugc nofollow" target="_blank">作者Github回购</a></li><li id="d003" class="ou ov it lc b ld pd lg pe lj pf ln pg lr ph lv oz pa pb pc bi translated"><a class="ae nk" href="http://Clean .NET solution structure with separate layers" rel="noopener ugc nofollow" target="_blank">干净。具有分离层的网络解决方案结构</a></li><li id="53cf" class="ou ov it lc b ld pd lg pe lj pf ln pg lr ph lv oz pa pb pc bi translated"><a class="ae nk" href="https://youtu.be/DGHH4m5squo" rel="noopener ugc nofollow" target="_blank">没有原始类型的干净类——如何避免原始困扰</a></li></ul><p id="c69c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">更多这样的内容，查看我的<a class="ae nk" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank"> YouTube频道</a>。</p></div></div>    
</body>
</html>