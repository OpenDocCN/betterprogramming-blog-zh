<html>
<head>
<title>Optimize Your Python Programs With Tuples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用元组优化你的Python程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optimize-your-python-programs-with-tuples-704f176c956d?source=collection_archive---------9-----------------------#2021-11-22">https://betterprogramming.pub/optimize-your-python-programs-with-tuples-704f176c956d?source=collection_archive---------9-----------------------#2021-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76a9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中列表与元组的对比研究。哪个效率更高，什么时候用？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cdaba6d0a0efd7fc55ddc855f3a692f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K8pby-NyKWERHpL_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@spencerdavis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯潘塞·戴维斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Python因其简单而成为最受欢迎的编程语言之一，但它也因相对缓慢和低效而闻名。它灵活的规则允许你轻松地编写出令人印象深刻的软件，但是同样的灵活性也会导致你编写出非常低效的代码。</p><p id="e99b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特别是，Python的语法没有强制任何编码风格，也没有对解决特定问题的方法施加任何限制。此外，Python开发人员通常不会学习底层优化，因为一切都被抽象掉了。</p><p id="8229" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中存储一组数据最常见的方式是使用列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="dde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在构建原型时或者如果那些列表在程序运行时只被访问几次时是可以的。另一方面，如果在关键函数中使用错误的项集合类型，您的代码会变得不必要的慢。</p><h1 id="ee45" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">Python对象大小</h1><p id="9284" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">正如你们大多数人可能知道的，在Python中一切都是作为对象的。这意味着您不能像在c等低级语言中那样处理原始数据类型，正因为如此，Python对象占用的内存比它们保存的值多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="102c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台输出:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e585" class="mz ly it mv b gy na nb l nc nd">0:            24 bytes<br/>1:            28 bytes<br/>1.0:          24 bytes<br/>555555555555: 32 bytes</span></pre><p id="a3e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，它们的大小比它们存储的实际值大得多。这是因为Python对象还包含对提供类型功能的方法和其他属性的引用。</p><p id="459d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到列表，它们还为您提供了与它们交互的方法和操作符。这些属性显然会占用一些空间，但是在大多数情况下，它们中的大多数都不会被访问。例如，如果您不需要在程序中修改列表，就没有必要包含这样做的方法。在这种情况下，您还不如使用不可变的集合类型。</p><h1 id="d34d" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">元组有什么不同？</h1><p id="e411" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">Python元组本质上是列表，但它们是不可变的。这意味着您不能更改元组的元素，添加或删除任何元素。如果您尝试为一个项目分配不同的值，您会得到一个错误:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="153b" class="mz ly it mv b gy na nb l nc nd">&gt;&gt;&gt; t = (1,2,3)<br/>&gt;&gt;&gt; t[0] = 4</span><span id="08a1" class="mz ly it mv b gy ne nb l nc nd">TypeError: 'tuple' object does not support item assignment</span></pre><p id="c816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组对象不实现改变它们的方法，所以它们实际上需要更少的内存来存储。下面是列表和元组在大小方面的快速比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台输出:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="4a85" class="mz ly it mv b gy na nb l nc nd">Empty list:   72 bytes<br/>Filled list: 112 bytes</span><span id="f474" class="mz ly it mv b gy ne nb l nc nd">Empty tuple:  56 bytes<br/>Filled tuple: 96 bytes</span></pre><p id="4341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，元组占用的内存比列表少得多。准确地说，空列表比元组多需要16个字节。此外，如果要向集合中添加任何新元素，Python可能会分配比严格必要的内存更多的内存，以避免调整大小。</p><h1 id="297f" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">速度性能优势</h1><p id="21e6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">与列表相比，元组不仅在内存需求方面更有效，而且还提供了速度优势。事实上，他们的访问时间比他们的对手快得多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="57ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台输出:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="aaf9" class="mz ly it mv b gy na nb l nc nd">Lists average: 0.0020666594509384595 seconds<br/>Tuples average: 0.0014251830289140344 seconds<br/>Tuples are on average 1.4501 (~69%) times faster than lists</span></pre><p id="6646" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，性能提升非常显著。现在，想象一下，如果您必须每秒多次访问您的集合的元素，您将节省多少时间。</p><h1 id="d4fe" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">元组的用例</h1><p id="0dbd" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">现在很清楚，元组比列表更有性能。只要你事先知道集合在程序运行时不会改变，就应该用它们来代替列表。以下是元组的一些真实用例:</p><ul class=""><li id="2af4" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">常数分组表。因为常量永远不会改变，所以将它们存储在不可变的数据结构中是有意义的。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ul class=""><li id="377a" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">不可变的复合对象。如果你不打算改变一个对象的列表属性，你也可以用一个元组来代替它。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ul class=""><li id="0d7e" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">临时只读集合。如果一个集合只被迭代一次，并且没有发生变化，那么最好使用元组。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="b4ba" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="cc72" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">总而言之，Python是一种非常灵活的语言，提供了各种各样的工具。问题是，它没有实施好的实践，导致开发人员在效率方面陷入坏习惯。</p><p id="5011" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要的要点是，尽可能在列表中使用元组，以避免不必要的内存和运行时开销。</p><blockquote class="no"><p id="a373" class="np nq it bd nr ns nt nu nv nw nx lu dk translated">生活中没有放之四海而皆准的方法。归根结底，就是使用正确的工具完成正确的工作。</p></blockquote><p id="c90f" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">我希望你喜欢这篇文章。如果您对程序的进一步优化感兴趣，我强烈建议您查看我关于Python的C扩展的文章:</p><div class="od oe gp gr of og"><a rel="noopener  ugc nofollow" target="_blank" href="/speed-up-your-python-codebases-with-c-extensions-94859875eb70"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">用C扩展加速你的Python代码库</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">给你的Python程序带来C语言的速度</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">better编程. pub</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><p id="ccda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>