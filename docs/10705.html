<html>
<head>
<title>Tree Lists With Indeterminate Checkboxes in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中带有不确定复选框的树列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tree-lists-with-indeterminate-checkboxes-in-react-31445784ac90?source=collection_archive---------0-----------------------#2022-01-24">https://betterprogramming.pub/tree-lists-with-indeterminate-checkboxes-in-react-31445784ac90?source=collection_archive---------0-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1646" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在树形结构的数据列表中创建和更新不确定的复选框(或“半选中的复选框”)可能是一个相当大的挑战。创建解决方案的完整指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/30a8120cf8f18a57d361d263d7d09dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4I3DEyRjPXq8YcJmrIVsIA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们今天将创造什么！</p></figure><blockquote class="ky kz la"><p id="7e48" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">和往常一样，你可以在我的<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-checkboxes/" rel="noopener ugc nofollow" target="_blank"> GitLab资源库</a>中找到所有相关代码。</p></blockquote><p id="33b3" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">也许你在野外遇到过带复选框的多级列表(见上图)。它们可以在很多地方找到，在我20多年的开发生涯中，我已经创建了几个。</p><p id="f5ba" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">每个项目都包含一个复选框，其中一个(或多个)复选框的状态可能会影响其他复选框的状态。这是一个层次结构，在结构中有几个层次(项目的<em class="ld">树</em>),事情会很快变得非常复杂。尤其是如果你希望你的逻辑是动态的，并为未来做好准备。</p><p id="2f34" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">所以让我们直接投入进去吧！我会解释一路上的点点滴滴。我们将讨论以下主题:</p><ul class=""><li id="af75" class="mc md it le b lf lg li lj lz me ma mf mb mg lx mh mi mj mk bi translated">递归</li><li id="a4db" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">复选框组件</li><li id="e9a1" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">列表项目</li><li id="bf7b" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">项目状态</li><li id="47c5" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">树组件</li><li id="aab1" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated"><code class="fe mq mr ms mt b">CheckboxList</code>组件</li><li id="e5be" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated"><code class="fe mq mr ms mt b">updateItemStates</code>功能</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/b295769c311889d51d2afea9020e486d.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/1*J7pLElN9PBbm-436cZIc1A.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><strong class="bd mv">动画</strong>:我们的应用在行动。</p></figure><h1 id="5411" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">递归</h1><p id="d327" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">在我们看第一部分之前，先简单说一下。如果您不熟悉递归地呈现React组件，或者一般来说不熟悉递归，我强烈建议您在继续阅读之前学习一些相关知识。这是非常必要的。我的另一篇文章可能会很有趣:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/recursive-rendering-with-react-components-10fa07c45456"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">使用React组件进行递归渲染</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">呈现嵌套数据结构的快速指南</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">better编程. pub</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div><h1 id="1248" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">复选框组件</h1><p id="4aa2" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">首先:我们需要一个相对简单的复选框组件。抽象地说，它是一个小组件(在我们的例子中是一个正方形)，可以处于三种预定状态之一。要么是:</p><ul class=""><li id="a9d3" class="mc md it le b lf lg li lj lz me ma mf mb mg lx mh mi mj mk bi translated">未加抑制的</li><li id="e23e" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">检查</li><li id="0c5f" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">或者<em class="ld">不确定</em></li></ul><p id="c194" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><strong class="le iu">不确定</strong>只是一个花哨的词，用来表示我们不太确定复选框的当前状态。是<em class="ld">半检</em>，还是<em class="ld">半检</em>。此屏幕截图中的第一个橙色复选框是一个示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/40bf14f271a660cae44633d7669b822e.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/1*WHGNp5_NQi9lj2OGwzNElA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的复选框可以有三种状态:未选中、选中或不确定。</p></figure><p id="582d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mq mr ms mt b">Fruits</code>有三个子节点。其中两个已勾选(<code class="fe mq mr ms mt b">Apple</code>和<code class="fe mq mr ms mt b">Banana</code>，另一个未勾选(<code class="fe mq mr ms mt b">Pear</code>)。因此不可能说出它们的父节点(<code class="fe mq mr ms mt b">fruits)</code>是否被检查。是…既检查了又没检查？</p><p id="9c23" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">这就是我们所说的<em class="ld">不确定</em>状态。</p><p id="2037" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在复选框的<a class="ae ly" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#indeterminate_state_checkboxes" rel="noopener ugc nofollow" target="_blank"> MDN页面上，您可以读到一些关于<code class="fe mq mr ms mt b">&lt;input type="checkbox /&gt;</code>元素的——很少使用——<code class="fe mq mr ms mt b"><strong class="le iu">indeterminate</strong></code>属性的信息。该属性只能用JavaScript设置，如果您将其值设置为<code class="fe mq mr ms mt b">true</code>，大多数浏览器将呈现带有水平条纹的(本地)复选框:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d3916e4c57203b2c6c21cfd988f7d6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:248/format:webp/1*8GC_N_SKx100y3gZz3xO1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">铬渲染本机不确定复选框。</p></figure><p id="b606" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">然而，我认为这有点令人困惑。用户可能会认为这些是<em class="ld">展开-折叠</em>按钮，而不是复选框。这就是为什么我们在本文中选择了一个简单的自定义复选框，用一个点来呈现不确定的复选框。</p><p id="b8d8" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们的<strong class="le iu">复选框</strong>组件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="606a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">出于本文演示的目的，它只是一个简单的span元素，其样式取决于复选框的状态。我们还可以向组件传递一个点击处理程序。</p><p id="2385" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">完整的组件及其样式可以在<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-checkboxes/-/tree/main/components/Checkbox" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="c1a5" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">列表项目</h1><p id="b0bf" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">为了呈现(多级)列表，我们需要一些数据来定义结构。我们需要定义我们的<em class="ld">列表项</em>。每个物品都有一个唯一的<code class="fe mq mr ms mt b">id</code>、一个<code class="fe mq mr ms mt b">name</code>和一个<code class="fe mq mr ms mt b">parent id</code>。</p><p id="286e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">请看定义我们的演示列表的JSON文件的第一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="ky kz la"><p id="3c48" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">注意，第一个项目(水果)有一个值为0(零)的<code class="fe mq mr ms mt b">parentId</code>。这表明该项是顶级项:它没有父项。</p></blockquote><p id="7ab1" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您可以看到我们如何通过使用<code class="fe mq mr ms mt b">parentId</code>属性来定义苹果、梨和香蕉属于第一个项目(水果)。请记住这一点，因为这在本文中非常重要。你可以在这里查看完整的文件<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-checkboxes/-/blob/main/data/items.json" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ab6d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">让我们继续前进！</p><h1 id="0c14" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">项目状态说明</h1><p id="4d0b" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">在我们开始渲染组件之前，我们需要考虑列表项的状态。我们需要一些状态数据来跟踪所有复选框及其各自的状态(未选中、选中或不确定)。</p><p id="4d40" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-checkboxes/-/blob/main/components/Tree/Tree.tsx#L6-L15" rel="noopener ugc nofollow" target="_blank"> Tree.tsx </a>中定义的相关类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="e51a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">然后，我们可以为所有复选框定义默认(初始)状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="591c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们在我们的<code class="fe mq mr ms mt b">Tree</code> <strong class="le iu"> </strong>组件中使用这个状态。我们现在就来看看这个组件。</p><h1 id="01fc" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">树组件</h1><p id="efb4" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">树组件是我们的根组件。它包含所有内容，负责呈现所有列表项及其复选框，并跟踪它们的状态。</p><p id="1ae7" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">首先，我们初始化我们的状态，这样我们可以跟踪所有复选框的状态:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="5434" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">然后，我们定义一个(helper)函数，该函数可用于查找单个列表项的状态。稍后我们呈现复选框时会用到它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="22c0" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">最后，在开始渲染之前，我们定义了一个函数来帮助我们更新状态，我们还定义了一个单击处理程序，当我们单击其中一个复选框时，该处理程序将被执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><blockquote class="ky kz la"><p id="bbb9" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated"><strong class="le iu">注意</strong>:本文最后一章解释了<code class="fe mq mr ms mt b">updateItemStates</code>函数的主体和逻辑，下面会进一步解释。</p></blockquote><p id="825c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们最终的树组件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8fd2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">说到渲染，你可以看到我们只渲染了一个<code class="fe mq mr ms mt b">CheckboxList </code>组件。请注意传递给它的属性。我们现在来看看这个组件。</p><h1 id="98b3" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">复选框列表组件</h1><p id="5edd" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">这个组件可能有点难以理解，因为我们将递归地呈现它。但是和我在一起。首先，我们来介绍一下术语<em class="ld">缩进级别</em>。在我们的演示数据中，我们有三个级别(0、1和2):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/552e02ed3b6cf637824036a1ea48f235.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*2UE2pi4YkN59NPOidTLlJA.png"/></div></figure><p id="8d33" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mq mr ms mt b">CheckboxList</code>组件呈现<em class="ld">属于同一组</em>的复选框。在下列情况下，它们属于同一组:</p><ul class=""><li id="7b00" class="mc md it le b lf lg li lj lz me ma mf mb mg lx mh mi mj mk bi translated">…它们具有相同的缩进级别</li><li id="e2db" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">…它们共享同一个直系父代</li></ul><p id="85b6" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">因此，根据这些规则和我们的虚拟数据，我们可以区分这4组:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/f9abc69906850d6d4934436e93add911.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/1*LjjiNLRZ21RX-7X7neHmwA.png"/></div></figure><p id="1d17" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">在我们回顾渲染逻辑之前，我们可以看一下组件属性，我们可以传递给它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="5e9a" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mq mr ms mt b"><strong class="le iu">items</strong></code>是我们树上的所有项目。当你有一个非常大的树时，你应该考虑重构它。但是对于我们的演示来说，这就够了。</p><p id="11cf" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mq mr ms mt b"><strong class="le iu">idsToRender</strong></code>是一个数组，包含我们要呈现的id(<em class="ld">一个组中所有项目的id—见上文)。</em>该属性是可选的。如果没有给定值，它将从根级别的项目中获取id(例如，没有父级的项目，在我们的例子中是<code class="fe mq mr ms mt b">fruits</code>和<code class="fe mq mr ms mt b">countries</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="5efd" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mq mr ms mt b"><strong class="le iu">indentLevel</strong></code>仅用于造型目的。我们可以使用这个值为我们正在渲染的项目添加额外的边距。</p><p id="b28e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated"><code class="fe mq mr ms mt b"><strong class="le iu">onClick</strong></code>和<code class="fe mq mr ms mt b"><strong class="le iu">getStateForId</strong></code>是不言自明的:一个项目(复选框)的点击处理程序，以及我们前面讨论过的<code class="fe mq mr ms mt b">getStateForId</code>。这是一个返回给定项目id的当前复选框状态的函数。<br/>点击处理程序的逻辑我们将在本文的最后一章单独讨论。</p><p id="be4c" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">当呈现一个<code class="fe mq mr ms mt b">CheckboxList</code>组件时，会发生以下情况:</p><ul class=""><li id="50ce" class="mc md it le b lf lg li lj lz me ma mf mb mg lx mh mi mj mk bi translated">对于<code class="fe mq mr ms mt b">idsToRender</code>中的所有id，我们将其呈现为复选框和标签</li><li id="c874" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">在渲染完每一个条目之后，我们检查它们是否有直接的子节点(例如，在我们的数据中指向当前条目id的条目，在它们的<code class="fe mq mr ms mt b">parentId</code>属性中)。</li></ul><p id="4003" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果我们找到这些子节点中的任何一个，我们获取它们的id并立即将它们呈现为…另一个<code class="fe mq mr ms mt b">CheckboxList</code>。该过程将递归重复，直到我们的完整的树被渲染。</p><p id="fc6d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">如果你感兴趣，我写了一篇关于递归渲染React组件的文章。在那篇文章中，我更详细地解释了这个概念:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/recursive-rendering-with-react-components-10fa07c45456"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">使用React组件进行递归渲染</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">呈现嵌套数据结构的快速指南</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">better编程. pub</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div><p id="e5f4" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您可以在GitLab 的资源库中查看完整的<code class="fe mq mr ms mt b">CheckboxList</code>组件<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-checkboxes/-/blob/main/components/CheckboxList/CheckboxList.tsx" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><h1 id="b1c0" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">updateItemStates(复选框单击处理程序)</h1><p id="4097" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">最后，我们来看看名为<code class="fe mq mr ms mt b">updateItemStates</code>的复选框点击处理程序的逻辑。这个函数在一个单独的文件中定义，因为它包含相当多的逻辑。它需要三个参数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="b540" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">我们接收所有项目的旧(当前)状态、项目本身以及被点击项目的id。它返回所有项目的新状态。事实上，对所有项目而言。因为单击一个复选框会影响多个复选框的状态。</p><p id="cc5e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">那么当用户点击复选框时会发生什么呢？这取决于被点击的复选框的当前状态。</p><p id="c36d" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">该复选框当前是否已选中？在这种情况下:</p><ul class=""><li id="9e23" class="mc md it le b lf lg li lj lz me ma mf mb mg lx mh mi mj mk bi translated">我们为被点击的复选框调用函数<code class="fe mq mr ms mt b">setUnchecked</code></li><li id="24aa" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">我们为被点击的checkbox的所有子节点调用函数<code class="fe mq mr ms mt b">setUnchecked</code>(递归调用，因为这些子节点本身可能有子节点，等等。)</li><li id="0ef3" class="mc md it le b lf ml li mm lz mn ma mo mb mp lx mh mi mj mk bi translated">我们检查被点击的复选框是否有父项，如果有，我们更新它(也是一个递归调用，因为父项本身可能有父项，等等。)</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8ed2" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">复选框目前<strong class="le iu">未选中</strong>还是<strong class="le iu">未确定？</strong>在这种情况下，我们运行相同的逻辑，只是我们用<code class="fe mq mr ms mt b">setChecked</code>调用替换了<code class="fe mq mr ms mt b">setUnchecked</code>调用。</p><blockquote class="ky kz la"><p id="b85d" class="lb lc ld le b lf lg ju lh li lj jx lk ll lm ln lo lp lq lr ls lt lu lv lw lx im bi translated">请注意，我们在这里做出了选择。每当复选框当前具有不确定的状态(意味着它的一些子复选框被选中，一些子复选框未被选中)并且用户单击这个不确定的复选框时，我们可以选择选中或取消选中所有子复选框。在这种情况下，我们选择将它们全部设置为选中状态。</p></blockquote><p id="c3dc" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">您可以在GitLab存储库的文件<a class="ae ly" href="https://gitlab.com/gvanderput/gerard-checkboxes/-/blob/main/components/Tree/updateItemStates.ts" rel="noopener ugc nofollow" target="_blank">中查看所有逻辑。</a></p><p id="9c5e" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">不要被它吓倒。再读一遍这一章，回顾代码，你应该能够理解它的每一部分。</p><h1 id="1877" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">一锤定音</h1><p id="b44e" class="pw-post-body-paragraph lb lc it le b lf no ju lh li np jx lk lz nq ln lo ma nr lr ls mb ns lv lw lx im bi translated">我喜欢创建这样的自定义组件。对我们中的一些人来说，它们有时非常复杂，递归并没有使它变得更简单。</p><p id="2519" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">但是不要让这吓到你！投入进去。努力理解所有的点点滴滴。</p><p id="67cc" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">一旦你做到了，你会为你能创造这样的组件而自豪。也许有一天它会派上用场。</p><p id="f3dc" class="pw-post-body-paragraph lb lc it le b lf lg ju lh li lj jx lk lz lm ln lo ma lq lr ls mb lu lv lw lx im bi translated">感谢您的宝贵时间！</p></div></div>    
</body>
</html>