<html>
<head>
<title>Function Builders in Swift and SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift和SwiftUI中的函数构建器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/function-builders-in-swift-and-swiftui-7a01b88c02ed?source=collection_archive---------13-----------------------#2020-04-21">https://betterprogramming.pub/function-builders-in-swift-and-swiftui-7a01b88c02ed?source=collection_archive---------13-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9046" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解Swift的最新功能之一</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b9d7a0b6d56cfb5e79d24d3b7cef81d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sp2qw10wJKJPThKwOXf-jA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://icons8.com" rel="noopener ugc nofollow" target="_blank">由哎呦插画. pics </a></p></figure><p id="dd43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">函数构建器</em>是Swift 5.1中首次引入的语言功能。它支持SwiftUI声明式DSL，允许我们以可读和简洁的方式构建异构用户界面层次结构。在本文中，我们将学习如何在我们的代码中使用它们，涵盖以下主题:</p><ul class=""><li id="e039" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">什么是函数构造器？</li><li id="24b7" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">函数构建器如何在Swift编译器层面上工作？</li><li id="037b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">如何实施定制的Swift函数生成器</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4d7f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">了解Swift函数构建器</h1><p id="02cf" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">函数生成器是一种实现嵌入式DSL的类型，用于从函数的表达式语句中收集部分结果，并将它们组合成一个返回值<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md" rel="noopener ugc nofollow" target="_blank">【1】</a>。</p><p id="e488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最小的<em class="lv">函数构建器类型</em>实现如下:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5041" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">@_functionBuilder</strong> <strong class="np iu">struct</strong> <strong class="np iu">Builder</strong> {<br/>    <strong class="np iu">static</strong> <strong class="np iu">func</strong> <strong class="np iu">buildBlock</strong>(_ partialResults: <strong class="np iu">String...</strong>) <strong class="np iu">-&gt;</strong> <strong class="np iu">String</strong> {<br/>        partialResults<strong class="np iu">.reduce</strong>("", <strong class="np iu">+</strong>)<br/>    }<br/>}</span></pre><p id="897a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="lv">函数构建器类型</em>必须用<code class="fe ny nz oa np b">@functionBuilder</code>属性进行注释，这允许它单独作为一个定制属性使用。</p><p id="d35e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，function builder属性有一个下划线，表示该特性目前正在开发中。</p><p id="0dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<code class="fe ny nz oa np b">buildBlock()</code>是强制性的。它必须是静态的，并且必须有准确的名称。否则，您会在使用时看到一个编译错误。</p><p id="8a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义的<em class="lv">函数生成器属性</em>可以应用于<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md" rel="noopener ugc nofollow" target="_blank">【1】</a>:</p><ol class=""><li id="0f91" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu ob mc md me bi translated">不属于协议要求的一部分的<code class="fe ny nz oa np b">func</code>、<code class="fe ny nz oa np b">var</code>或<code class="fe ny nz oa np b">subscript</code>声明。它使<em class="lv">函数构建器转换</em>应用于函数体。</li><li id="2d8b" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ob mc md me bi translated">函数的闭包参数，包括协议要求。它导致<em class="lv">函数构建器转换</em>被应用于任何显式闭包的主体，这些闭包作为相应的参数传递，除非闭包包含return语句。</li></ol><p id="f3fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续我们的<code class="fe ny nz oa np b">@Builder</code>例子，回顾一下这两种使用场景。</p><p id="514f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过用属性<code class="fe ny nz oa np b">@Builder</code>标记then，我们可以在声明中使用特殊的语法:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0e4e" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">@Builder</strong> <strong class="np iu">func</strong> <strong class="np iu">abc</strong>() <strong class="np iu">-&gt;</strong> <strong class="np iu">String</strong> {<br/>    "Method: "<br/>    "ABC"<br/>}<br/><br/><strong class="np iu">struct</strong> <strong class="np iu">Foo</strong> {<br/>    <strong class="np iu">@Builder</strong> <strong class="np iu">var</strong> abc: <strong class="np iu">String</strong> {<br/>        "Getter: "<br/>        "ABC"<br/>    }<br/><br/>    <strong class="np iu">subscript</strong>(_ anything: <strong class="np iu">String</strong>) <strong class="np iu">-&gt;</strong> <strong class="np iu">String</strong> {<br/>        <strong class="np iu">@Builder</strong> <strong class="np iu">get</strong> {<br/>            "Subscript: "<br/>            "ABC"<br/>        }<br/>        <strong class="np iu">set</strong> { <em class="lv">/* nothing */</em> }<br/>    }<br/>}</span></pre><p id="d7f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们调用声明:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="704c" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">print</strong>(<strong class="np iu">abc</strong>())<br/><strong class="np iu">print</strong>(<strong class="np iu">Foo</strong>()<strong class="np iu">.</strong>abc)<br/><strong class="np iu">print</strong>(<strong class="np iu">Foo</strong>()[""])</span></pre><p id="8e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将打印:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0430" class="nt ms it np b gy nu nv l nw nx">Method: ABC<br/>Getter: ABC<br/>Subscript: ABC</span></pre><p id="23b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到第二个场景，下面是我们如何将一个函数生成器注释的闭包作为参数传递:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="230b" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">func</strong> <strong class="np iu">acceptBuilder</strong>(<strong class="np iu">@Builder</strong> build: () <strong class="np iu">-&gt;</strong> <strong class="np iu">String</strong>) {<br/>    <strong class="np iu">print</strong>(<strong class="np iu">build</strong>())<br/>}</span></pre><p id="8244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后调用启用DSL语法的<code class="fe ny nz oa np b">acceptBuilder()</code>函数:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6aac" class="nt ms it np b gy nu nv l nw nx">acceptBuilder {<br/>    "Closure argument: "<br/>    "ABC"<br/>}</span></pre><p id="0c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将打印出来:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="33a0" class="nt ms it np b gy nu nv l nw nx">Closure argument: ABC</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="78e9" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Swift函数生成器的目的</h1><blockquote class="oc od oe"><p id="8439" class="kz la lv lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">允许创建优秀的库一直是Swift的核心目标。<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md#function-builder-types" rel="noopener ugc nofollow" target="_blank">【1】</a></p></blockquote><p id="cba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift函数构建器解决的一类问题是分层异构数据结构的构建。一些例子是:</p><ul class=""><li id="0001" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">生成结构化数据，例如XML、JSON。</li><li id="a2b8" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">生成GUI层次结构，例如SwiftUI、HTML。</li></ul><p id="e20f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是它的作用。它是如何工作的？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="aaac" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Swift函数构造器剖析</h1><p id="9579" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果我们转储从<code class="fe ny nz oa np b">abc()</code>方法生成的AST:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="587a" class="nt ms it np b gy nu nv l nw nx">(func_decl range=[builder.swift:10:10 - line:13:1] "abc()" interface type='() -&gt; String' access=internal<br/>...<br/>  (declref_expr implicit type='(Builder.Type) -&gt; (String...) -&gt; String' location=builder.swift:10:31 range=[builder.swift:10:31 - line:10:31] decl=builder.(file).Builder.buildBlock@builder.swift:5:17 function_ref=single)<br/>  ...<br/>    (string_literal_expr type='String' location=builder.swift:11:5 range=[builder.swift:11:5 - line:11:5] encoding=utf8 value="Method: " builtin_initializer=Swift.(file).String extension.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) initializer=**NULL**)<br/>    (string_literal_expr type='String' location=builder.swift:12:5 range=[builder.swift:12:5 - line:12:5] encoding=utf8 value="ABC" builtin_initializer=Swift.(file).String extension.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:) initializer=**NULL**)<br/>...</span></pre><p id="7f8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会发现它转化为对<code class="fe ny nz oa np b">Builder.buildBlock("Method: ", "ABC")</code>的调用。</p><p id="4f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://swift.org/swift-compiler/#compiler-architecture" rel="noopener ugc nofollow" target="_blank">语义分析</a>阶段，Swift编译器<a class="ae ky" href="https://github.com/apple/swift/blob/51267754fc35ca17d6bbb8f9066390925cbb5c02/lib/Sema/CSApply.cpp#L5059" rel="noopener ugc nofollow" target="_blank">将</a><a class="ae ky" href="https://github.com/apple/swift/blob/78880ffc1a6bdbb01610990ba395e2cbef5d14a3/lib/Sema/BuilderTransform.cpp" rel="noopener ugc nofollow" target="_blank">函数生成器将</a>转换为解析后的AST，就好像我们已经编写了<code class="fe ny nz oa np b">Builder.buildBlock(&lt;arguments&gt;)</code><a class="ae ky" href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae ky" href="https://github.com/apple/swift/blob/724f8c23dbd1a52b09e5d4ba97e328d87ac03021/include/swift/AST/KnownIdentifiers.def#L34" rel="noopener ugc nofollow" target="_blank">【2】</a>。</p><p id="2b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个使用案例是将函数生成器应用于闭包参数。在这种情况下，Swift编译器将<a class="ae ky" href="https://github.com/apple/swift/blob/51267754fc35ca17d6bbb8f9066390925cbb5c02/lib/Sema/CSApply.cpp#L7713" rel="noopener ugc nofollow" target="_blank">将闭包</a>重写为带有包含构建器调用的<a class="ae ky" href="https://github.com/apple/swift/blob/78880ffc1a6bdbb01610990ba395e2cbef5d14a3/lib/Sema/BuilderTransform.cpp#L784" rel="noopener ugc nofollow" target="_blank">单个表达式体</a>的闭包。</p><p id="468a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了有所用处，函数构建器必须提供七个构建方法的子集，这些方法实现不同种类的转换<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md#function-building-methods" rel="noopener ugc nofollow" target="_blank">【1】</a>，<a class="ae ky" href="https://github.com/apple/swift/blob/724f8c23dbd1a52b09e5d4ba97e328d87ac03021/include/swift/AST/KnownIdentifiers.def#L34" rel="noopener ugc nofollow" target="_blank">【2】</a>:</p><ul class=""><li id="60ca" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><code class="fe ny nz oa np b">buildBlock(_ parts: PartialResult...) -&gt; PartialResult</code>将多个部分结果合并为一个。</li><li id="0b71" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">buildDo(_ parts: PartialResult...) -&gt; PartialResult</code>与<code class="fe ny nz oa np b">buildBlock()</code>相同，但针对<code class="fe ny nz oa np b">do</code>条款。</li><li id="d395" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">buildIf(_ parts: PartialResult...) -&gt; PartialResult</code>与<code class="fe ny nz oa np b">buildBlock()</code>相同，但用于<code class="fe ny nz oa np b">if</code>语句。</li><li id="f7a6" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">buildEither(first: PartialResult) -&gt; PartialResult</code>和<code class="fe ny nz oa np b">buildEither(second: PartialResult) -&gt; PartialResult</code>从两个可选执行的子块的结果中创建部分结果。您必须实现这两种方法，并且它们必须是彼此相反的。</li><li id="18ce" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">buildExpression(_ expression: Expression) -&gt; PartialResult</code>从单个表达式创建部分结果。</li><li id="4585" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">buildOptional(_ part: PartialResult?) -&gt; PartialResult</code>从可选执行的子块的结果中创建部分结果。</li><li id="1ef0" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><code class="fe ny nz oa np b">buildFinalResult(_ parts: PartialResult...) -&gt; Result</code>从多个部分结果中产生一个最终结果。</li></ul><p id="afb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有方法都支持基于其参数类型的重载。</p><p id="373d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在使用时，Swift编译器将尝试使用提供的方法子集重写DSL语法。在编译器找不到匹配的情况下，它将发出一个编译错误。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="72a7" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">实现自定义函数生成器</h1><p id="85d4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">让我们通过实现一个<code class="fe ny nz oa np b">NSAttributedString</code>函数生成器来提高我们的知识。</p><p id="265f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建器从子字符串中创建一个final <code class="fe ny nz oa np b">NSAttributedString</code>:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="84e3" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">@_functionBuilder</strong><br/><strong class="np iu">struct</strong> <strong class="np iu">AttributedStringBuilder</strong> {<br/>    <strong class="np iu">static</strong> <strong class="np iu">func</strong> <strong class="np iu">buildBlock</strong>(_ components: <strong class="np iu">NSAttributedString...</strong>) <strong class="np iu">-&gt;</strong> <strong class="np iu">NSAttributedString</strong> {<br/>        <strong class="np iu">let</strong> result <strong class="np iu">=</strong> <strong class="np iu">NSMutableAttributedString</strong>(string: "")<br/>        components<strong class="np iu">.forEach</strong>(result<strong class="np iu">.</strong>append)<br/>        <strong class="np iu">return</strong> result<br/>    }<br/>}</span></pre><p id="f6f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要考虑构建器支持什么类型的表达式。在我们的例子中，我们将接受字符串和图像，并将它们提升到属性化的子字符串:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="64e2" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">@_functionBuilder</strong><br/><strong class="np iu">struct</strong> <strong class="np iu">AttributedStringBuilder</strong> {<br/>    <strong class="np iu">...</strong><br/>    <br/>    <strong class="np iu">static</strong> <strong class="np iu">func</strong> <strong class="np iu">buildExpression</strong>(_ text: <strong class="np iu">String</strong>) <strong class="np iu">-&gt;</strong> <strong class="np iu">NSAttributedString</strong> {<br/>        <strong class="np iu">NSAttributedString</strong>(string: text, attributes: [:])<br/>    }<br/>    <br/>    <strong class="np iu">static</strong> <strong class="np iu">func</strong> <strong class="np iu">buildExpression</strong>(_ image: <strong class="np iu">UIImage</strong>) <strong class="np iu">-&gt;</strong> <strong class="np iu">NSAttributedString</strong> {<br/>        <strong class="np iu">let</strong> attachment <strong class="np iu">=</strong> <strong class="np iu">NSTextAttachment</strong>()<br/>        attachment<strong class="np iu">.</strong>image <strong class="np iu">=</strong> image<br/>        <strong class="np iu">return</strong> <strong class="np iu">NSAttributedString</strong>(attachment: attachment)<br/>    }<br/>    <br/>    <strong class="np iu">static</strong> <strong class="np iu">func</strong> <strong class="np iu">buildExpression</strong>(_ attr: <strong class="np iu">NSAttributedString</strong>) <strong class="np iu">-&gt;</strong> <strong class="np iu">NSAttributedString</strong> {<br/>        attr<br/>    }<br/>}</span></pre><p id="1556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们也接受类型为<code class="fe ny nz oa np b">NSAttributedString</code>的表达式，并不加修改地返回它们。</p><p id="085d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要一个助手方法，允许我们添加额外的属性:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="60f5" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">extension</strong> <strong class="np iu">NSAttributedString</strong> {<br/>    <strong class="np iu">func</strong> <strong class="np iu">withAttributes</strong>(_ attrs: [<strong class="np iu">NSAttributedString.Key</strong>: <strong class="np iu">Any</strong>]) <strong class="np iu">-&gt;</strong> <strong class="np iu">NSAttributedString</strong> {<br/>        <strong class="np iu">let</strong> copy <strong class="np iu">=</strong> <strong class="np iu">NSMutableAttributedString</strong>(attributedString: <strong class="np iu">self</strong>)<br/>        copy<strong class="np iu">.addAttributes</strong>(attrs, range: <strong class="np iu">NSRange</strong>(location: 0, length: string<strong class="np iu">.</strong>count))<br/>        <strong class="np iu">return</strong> copy<br/>    }<br/>}</span></pre><p id="878f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后添加一个基于构建器的便利初始化器:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="321c" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">extension</strong> <strong class="np iu">NSAttributedString</strong> {<br/>    convenience <strong class="np iu">init</strong>(<strong class="np iu">@AttributedStringBuilder</strong> builder: () <strong class="np iu">-&gt;</strong> <strong class="np iu">NSAttributedString</strong>) {<br/>        <strong class="np iu">self.init</strong>(attributedString: <strong class="np iu">builder</strong>())<br/>    }<br/>}</span></pre><p id="e56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们测试一下构建器。注意，SwiftUI不直接支持<code class="fe ny nz oa np b">NSAttributedString</code> s，因此我们将求助于传统的UIKit:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0a1f" class="nt ms it np b gy nu nv l nw nx"><strong class="np iu">class</strong> <strong class="np iu">ViewController</strong>: <strong class="np iu">UIViewController</strong> {<br/>    <strong class="np iu">@IBOutlet</strong> <strong class="np iu">weak</strong> <strong class="np iu">var</strong> label: <strong class="np iu">UILabel!</strong><br/>    <br/>    <strong class="np iu">override</strong> <strong class="np iu">func</strong> <strong class="np iu">viewDidLoad</strong>() {<br/>        <strong class="np iu">super.viewDidLoad</strong>()<br/>        <br/>        label<strong class="np iu">.</strong>attributedText <strong class="np iu">=</strong> <strong class="np iu">NSAttributedString</strong> {<br/>            <em class="lv">// 1.</em><br/>            <strong class="np iu">NSAttributedString</strong> {<br/>                <em class="lv">// 2.</em><br/>                "Folder "<br/>                <em class="lv">// 3.</em><br/>                <strong class="np iu">UIImage</strong>(systemName: "folder")<strong class="np iu">!</strong><br/>                <em class="lv">// 4.</em><br/>            }<br/>            "\n"<br/>            <strong class="np iu">NSAttributedString</strong> {<br/>                "Document "<br/>                <strong class="np iu">UIImage</strong>(systemName: "doc")<strong class="np iu">!</strong><br/>                    <strong class="np iu">.withRenderingMode</strong>(<strong class="np iu">.</strong>alwaysTemplate)<br/>            }<br/>            <strong class="np iu">.withAttributes</strong>([<br/>                <strong class="np iu">.</strong>font: <strong class="np iu">UIFont.systemFont</strong>(ofSize: 32),<br/>                <strong class="np iu">.</strong>foregroundColor: <strong class="np iu">UIColor.</strong>red<br/>            ])<br/>        }<br/>    }<br/>}</span></pre><p id="3606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Swift编译器将上述代码翻译成以下<code class="fe ny nz oa np b">AttributedStringBuilder</code>方法调用:</p><ol class=""><li id="1dd8" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu ob mc md me bi translated"><code class="fe ny nz oa np b">buildExpression()</code>同<code class="fe ny nz oa np b">NSAttributedString</code>争论。</li><li id="2490" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ob mc md me bi translated"><code class="fe ny nz oa np b">buildExpression()</code>同<code class="fe ny nz oa np b">String</code>论证。</li><li id="15f3" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ob mc md me bi translated"><code class="fe ny nz oa np b">buildExpression()</code>带<code class="fe ny nz oa np b">Image</code>自变量。</li><li id="313a" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu ob mc md me bi translated">在构建了所有部分结果之后，调用方法<code class="fe ny nz oa np b">buildBlock()</code>，将所有中间子字符串作为参数。</li></ol><p id="7857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/21318b15ed478b7277466891b7f64b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/0*IngBEkpslntvebyb.png"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="4727" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">源代码</h1><p id="0341" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">你可以在这里找到<a class="ae ky" href="https://github.com/V8tr/AttributedStringBuilder" rel="noopener ugc nofollow" target="_blank">的源代码</a>。它是在“未授权”下发布的，这允许你用它做任何你想做的事情。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="975c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">参考</h1><ul class=""><li id="5882" class="lw lx it lb b lc nj lf nk li oj lm ok lq ol lu mb mc md me bi translated"><a class="ae ky" href="https://github.com/apple/swift/pull/25221" rel="noopener ugc nofollow" target="_blank">拉取请求#25221:函数生成器的初步支持</a></li><li id="0086" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md" rel="noopener ugc nofollow" target="_blank">功能构建器提案</a></li><li id="49e5" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://forums.swift.org/t/function-builders/25167" rel="noopener ugc nofollow" target="_blank"> Swift论坛主题</a></li><li id="7b83" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://github.com/carson-katri/awesome-function-builders" rel="noopener ugc nofollow" target="_blank">牛逼的函数构建器</a></li><li id="a44c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/viewbuilder" rel="noopener ugc nofollow" target="_blank">view builder上的苹果文档</a></li></ul></div></div>    
</body>
</html>