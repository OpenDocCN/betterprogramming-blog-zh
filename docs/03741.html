<html>
<head>
<title>A Comprehensive Guide to Building an Event-Driven Application with Kotlin, Kafka, and DynamoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kotlin、Kafka和DynamoDB构建事件驱动应用程序的综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-comprehensive-guide-to-build-an-event-driven-application-with-kotlin-kafka-and-dynamodb-a8d9bfb19e42?source=collection_archive---------10-----------------------#2020-03-02">https://betterprogramming.pub/a-comprehensive-guide-to-build-an-event-driven-application-with-kotlin-kafka-and-dynamodb-a8d9bfb19e42?source=collection_archive---------10-----------------------#2020-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="615d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建您自己的事件驱动应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18dd9883d9440159d731adb9b04b4403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dJWMyylBca4zN0IL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@gwundrig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Manuel n Geli</a>拍摄的照片</p></figure><h1 id="fc23" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="a628" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">事件驱动应用程序是一种监听某种形式的事件或动作并对其做出反应的应用程序。这些事件或动作可以来自用户或其他应用程序。例如，一个事件可能是用户关闭他或她的帐户，一个修改输入数据并输出结果的服务，等等。</p><p id="7846" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">本质上，事件是导致状态变化的任何事情。状态的改变由生产者引起，然后以某种消息形式发布到主题或队列。另一方面，会有一个(或多个)消费者订阅主题或队列，并消费或处理消息。</p><p id="caf5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">简而言之，事件驱动应用程序的组件是:生产者、主题和消费者。</p><p id="bc3f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">作为对此的补充，您可以查看以下教程:</p><ul class=""><li id="fc5a" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><a class="ae ky" href="https://medium.com/better-programming/how-to-set-up-a-local-dynamodb-in-a-docker-container-and-perform-the-basic-putitem-getitem-38958237b968" rel="noopener">旋转本地DynamoDB Docker </a></li><li id="bea6" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://medium.com/better-programming/your-local-event-driven-environment-using-dockerised-kafka-cluster-6e84af09cd95" rel="noopener">旋转本地Kafka Docker </a></li><li id="fbaa" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://medium.com/@billydharmawan/adding-schema-registry-to-kafka-in-your-local-docker-environment-49ada28c8a9b" rel="noopener">将模式注册表添加到本地Kafka Docker </a></li><li id="e29b" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://medium.com/swlh/how-to-build-a-reactive-microservice-api-with-spring-boot-spring-webflux-and-dynamodb-using-kotlin-e1be3e99b15e" rel="noopener">用DynamoDB构建Kotlin应用</a></li></ul><p id="2d0d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的前三个教程向我们展示了如何建立一个本地开发环境，包括DynamoDB和Kafka以及Schema Registry(这样我们就可以使用Avro schema)。</p><p id="ab23" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上一篇教程向我们展示了如何构建一个使用DynamoDB作为持久层的Kotlin应用程序。该应用程序是使用Spring Boot和Spring Webflux框架构建的。这是我们将用作本教程基础的项目，我们将把它转换成一个事件驱动的应用程序。</p><p id="302f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">TLDR:这个教程的Github repo可以在这里<a class="ae ky" href="https://github.com/billydh/kotlin-kafka-dynamo-demo" rel="noopener ugc nofollow" target="_blank">找到</a>。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="a5cf" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">你将学到什么</h1><p id="c1bd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本教程中，我们将看看如何使用Kotlin、Kafka和DynamoDB构建一个事件驱动的应用程序。应用程序公开了一个接受创建用户帐户请求的<code class="fe ns nt nu nv b">POST</code>端点。它将向Kafka主题发布包含用户创建请求的消息。</p><p id="cfdc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">另一方面，会有一个消费者订阅该主题，阅读消息并将新用户的详细信息持久存储在DynamoDB中。成功创建用户帐户后，会有一条消息发布到Kafka主题。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="4a56" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">先决条件</h1><p id="6c9d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将克隆作为本教程一部分构建的Github repo:<a class="ae ky" href="https://medium.com/swlh/how-to-build-a-reactive-microservice-api-with-spring-boot-spring-webflux-and-dynamodb-using-kotlin-e1be3e99b15e" rel="noopener">用DynamoDB构建Kotlin应用程序</a>。它已经有了DynamoDB的结构，所以我们可以继续构建Kafka组件。</p><p id="45f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想从头到尾了解整个过程，包括用DynamoDB构建初始应用程序，我强烈建议你做<a class="ae ky" href="https://medium.com/swlh/how-to-build-a-reactive-microservice-api-with-spring-boot-spring-webflux-and-dynamodb-using-kotlin-e1be3e99b15e" rel="noopener">这个教程</a>。</p><p id="ba6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">克隆之后，将项目模块重命名为<code class="fe ns nt nu nv b">kotlinkafkadynamodemo</code>，并按照本<a class="ae ky" href="https://medium.com/@billydharmawan/how-to-rename-project-module-in-intellij-d78d950314b5" rel="noopener">教程</a>中的步骤重新初始化Git存储库。</p><p id="3666" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们也重命名包含<code class="fe ns nt nu nv b">main</code>方法的类。打开<code class="fe ns nt nu nv b">DynamodemoApplication.kt</code>，然后高亮显示<code class="fe ns nt nu nv b">DynamodemoApplication</code>并按下键盘上的<code class="fe ns nt nu nv b">shift + fn + F6</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/aad964806ec00a7e7b788856d95f01b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4SV5htDakaNX7CHKwsabAQ.png"/></div></div></figure><p id="c6bb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将其重命名为<code class="fe ns nt nu nv b">KafkaDynamoDemoApplication</code>，然后按键盘上的<code class="fe ns nt nu nv b">return</code>或<code class="fe ns nt nu nv b">enter</code>键。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/08f71e59bdd9d175b542fb06238b426a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*658EXQIy-8rVjO1Sps1JDg.png"/></div></div></figure><p id="8ead" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">将会出现一个提示，询问您是否想要重命名相应的测试类。通过点击复选框选择测试。最后，点击右下角的<code class="fe ns nt nu nv b">OK</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/d8700f1ae6516c7f75972da7e86f6fcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7OCrzBuL5jrIchaearEYHw.png"/></div></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0b66" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">启动本地Kafka和DynamoDB环境</h1><p id="7ab8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要设置本地Kafka和DynamoDB环境。为此，将来自<a class="ae ky" href="https://medium.com/better-programming/how-to-set-up-a-local-dynamodb-in-a-docker-container-and-perform-the-basic-putitem-getitem-38958237b968" rel="noopener"> DynamoDB Docker教程</a>的<code class="fe ns nt nu nv b">docker-compose.yaml</code>内容添加到来自<a class="ae ky" href="https://medium.com/@billydharmawan/adding-schema-registry-to-kafka-in-your-local-docker-environment-49ada28c8a9b" rel="noopener"> Kafka Docker教程</a>的<code class="fe ns nt nu nv b">docker-compose.yml</code>中。</p><p id="f678" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以删除我们的<code class="fe ns nt nu nv b">kotlin-kafka-dynamo-demo</code>库中现有的<code class="fe ns nt nu nv b">docker-compose-dynamodb.yaml</code>文件，并用一个名为<code class="fe ns nt nu nv b">docker-compose.yml</code>的新文件替换它。</p><pre class="kj kk kl km gt nz nv oa ob aw oc bi"><span id="3778" class="od la it nv b gy oe of l og oh">~/demo/kotlin-kafka-dynamo-demo ❯ rm docker-compose-dynamodb.yaml</span></pre><p id="86f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将在<code class="fe ns nt nu nv b">kotlin-kafka-dynamodb-demo</code>项目根目录下以下面的<code class="fe ns nt nu nv b">docker-compose.yml</code>文件结束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">docker-compose.yml</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="f597" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用下面的<code class="fe ns nt nu nv b">docker-compose</code>命令旋转Docker容器。</p><pre class="kj kk kl km gt nz nv oa ob aw oc bi"><span id="fef0" class="od la it nv b gy oe of l og oh">~/demo/kotlin-kafka-dynamo-demo ❯ docker-compose up -d<br/>Creating network "demo_default" with the default driver<br/>Creating zookeeper      ... done<br/>Creating kafka-tools    ... done<br/>Creating dynamodb-local ... done<br/>Creating broker         ... done<br/>Creating schema-registry ... done<br/>Creating control-center  ... done</span><span id="6d57" class="od la it nv b gy ok of l og oh">~/demo/kotlin-kafka-dynamo-demo ❯ docker ps<br/>CONTAINER ID        IMAGE                                             COMMAND                  CREATED             STATUS              PORTS                                        NAMES<br/>ee92c29db522        confluentinc/cp-enterprise-control-center:5.4.0   "/etc/confluent/dock…"   5 seconds ago       Up 3 seconds        0.0.0.0:9021-&gt;9021/tcp                       control-center<br/>5303bc4934e3        confluentinc/cp-schema-registry:5.4.0             "/etc/confluent/dock…"   5 seconds ago       Up 4 seconds        0.0.0.0:8081-&gt;8081/tcp                       schema-registry<br/>66f0066c2fcb        confluentinc/cp-server:5.4.0                      "/etc/confluent/dock…"   6 seconds ago       Up 5 seconds        0.0.0.0:9092-&gt;9092/tcp                       broker<br/>d03997801db5        confluentinc/cp-zookeeper:5.4.0                   "/etc/confluent/dock…"   7 seconds ago       Up 6 seconds        2888/tcp, 0.0.0.0:2181-&gt;2181/tcp, 3888/tcp   zookeeper<br/>14993ad15764        amazon/dynamodb-local                             "java -jar DynamoDBL…"   7 seconds ago       Up 5 seconds        0.0.0.0:8042-&gt;8000/tcp                       dynamodb-local<br/>d64c2c2483b4        confluentinc/cp-kafka:5.4.0                       "tail -f /dev/null"      7 seconds ago       Up 6 seconds                                                     kafka-tools</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3bab" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">创建演示客户信息表</h1><p id="d0bd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要按照本<a class="ae ky" href="https://medium.com/swlh/how-to-build-a-reactive-microservice-api-with-spring-boot-spring-webflux-and-dynamodb-using-kotlin-e1be3e99b15e" rel="noopener">教程</a>中的说明创建一个DynamoDB表。该表将保存来自客户端对我们的应用程序端点的<code class="fe ns nt nu nv b">POST</code>请求的用户信息。</p><p id="c71c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是Docker容器启动后创建我们的表的命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建-表格</p></figure><p id="8416" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果一切正常，我们应该会看到以下输出:</p><pre class="kj kk kl km gt nz nv oa ob aw oc bi"><span id="20d2" class="od la it nv b gy oe of l og oh">~/demo/kotlin-kafka-dynamo-demo ❯ aws dynamodb --endpoint-url <a class="ae ky" href="http://localhost:8042" rel="noopener ugc nofollow" target="_blank">http://localhost:8042</a> create-table --table-name demo-customer-info \<br/>--attribute-definitions AttributeName=customerId,AttributeType=S --key-schema AttributeName=customerId,KeyType=HASH \<br/>--provisioned-throughput ReadCapacityUnits=5,WriteCapacityUnits=5</span><span id="cf36" class="od la it nv b gy ok of l og oh">{<br/>    "TableDescription": {<br/>        "AttributeDefinitions": [<br/>            {<br/>                "AttributeName": "customerId",<br/>                "AttributeType": "S"<br/>            }<br/>        ],<br/>        "TableName": "demo-customer-info",<br/>        "KeySchema": [<br/>            {<br/>                "AttributeName": "customerId",<br/>                "KeyType": "HASH"<br/>            }<br/>        ],<br/>        "TableStatus": "ACTIVE",<br/>        "CreationDateTime": 1583123385.099,<br/>        "ProvisionedThroughput": {<br/>            "LastIncreaseDateTime": 0.0,<br/>            "LastDecreaseDateTime": 0.0,<br/>            "NumberOfDecreasesToday": 0,<br/>            "ReadCapacityUnits": 5,<br/>            "WriteCapacityUnits": 5<br/>        },<br/>        "TableSizeBytes": 0,<br/>        "ItemCount": 0,<br/>        "TableArn": "arn:aws:dynamodb:ddblocal:000000000000:table/demo-customer-info",<br/>        "BillingModeSummary": {<br/>            "BillingMode": "PROVISIONED",<br/>            "LastUpdateToPayPerRequestDateTime": 0.0<br/>        }<br/>    }<br/>}</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="ec23" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">创建卡夫卡主题</h1><p id="7a23" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如上所述，我们将有两个主题:</p><ul class=""><li id="f20d" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">一个用于创建用户请求:<code class="fe ns nt nu nv b">create-user-request</code>。</li><li id="ee8e" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated">另一个为用户创建的事件:<code class="fe ns nt nu nv b">user-created-event</code>。</li></ul><p id="3660" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将使用合流控制中心UI来创建这些主题。你可以参考这个<a class="ae ky" href="https://medium.com/@billydharmawan/adding-schema-registry-to-kafka-in-your-local-docker-environment-49ada28c8a9b" rel="noopener">教程</a>来了解如何做。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/539224e77708c559815d8cae3b1d26b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2gOtD0FkB0MR8Bv7Q-JXqw.png"/></div></div></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c91a" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">定义Avro模式</h1><p id="424d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">既然我们已经准备好了主题，我们需要为每个主题定义Avro模式。一般来说，对于那些需要快速复习的人来说，模式的目的是确保维护消息的数据结构的生产者和消费者之间的契约。</p><p id="5c69" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于Avro模式和模式注册表的更多信息，你可以阅读这篇教程。</p><p id="2c17" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于我们的应用程序，我们将使用<a class="ae ky" href="https://github.com/davidmc24/gradle-avro-plugin" rel="noopener ugc nofollow" target="_blank"> gradle-avro-plugin </a>。这个插件允许我们在应用程序项目文件夹中定义Avro模式。它接受JSON模式声明，并将基于模式定义生成Java类。</p><p id="0827" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在构建过程中，插件会寻找<code class="fe ns nt nu nv b">src/main/avro</code>文件夹，并将文件夹中的Avro文件<code class="fe ns nt nu nv b">.avsc</code>编译成相应的Java类。很方便，不是吗？</p><p id="cd71" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所有这些听起来都不错，但是如果你遵循上面提到的模式注册教程<a class="ae ky" href="https://medium.com/@billydharmawan/adding-schema-registry-to-kafka-in-your-local-docker-environment-49ada28c8a9b" rel="noopener">的话，你可能会想——我们不需要在汇合中心注册模式吗？</a></p><p id="f67f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">答案是否定的。</p><p id="c842" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请记住，当生产者向Kafka主题发布一些消息时，它将与Schema Registry对话，以检查任何已注册的模式。如果没有，它将在那里注册，然后将消息发布给卡夫卡。</p><p id="5cbb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这正是这里将要发生的事情，所以请耐心等待并跟随！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="8134" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如上所述，<code class="fe ns nt nu nv b">gradle-avro-plugin</code>在构建期间在<code class="fe ns nt nu nv b">src/main/avro</code>中寻找Avro文件。因此，让我们将<code class="fe ns nt nu nv b">create-user-request</code>和<code class="fe ns nt nu nv b">user-created-event</code>主题的Avro文件添加到该文件夹中。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="6637" class="od la it bd lb om on dn lf oo op dp lj ma oq or ll me os ot ln mi ou ov lp ow bi translated">创建用户请求的Avro模式</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建用户请求</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h2 id="d611" class="od la it bd lb om on dn lf oo op dp lj ma oq or ll me os ot ln mi ou ov lp ow bi translated">用户创建事件的Avro架构</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用户创建的事件. avsc</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="e01a" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">设置Gradle Avro插件</h1><p id="f812" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们需要将一些东西添加到我们的<code class="fe ns nt nu nv b">build.gradle.kts</code>文件中，以使<code class="fe ns nt nu nv b">gradle-avro-plugin</code>按预期工作。</p><p id="9a8e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">遵循他们的Github <a class="ae ky" href="https://github.com/davidmc24/gradle-avro-plugin" rel="noopener ugc nofollow" target="_blank">页面</a>中的步骤。</p><p id="be55" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们完成所有步骤后，我们的<code class="fe ns nt nu nv b">build.gradle.kts</code>文件应该看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">构建</p></figure><p id="4c51" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">从Avro模式生成Java类的任务被命名为<code class="fe ns nt nu nv b">generateAvroJava</code>。因此，如果我们现在转到我们的终端并执行以下命令:</p><pre class="kj kk kl km gt nz nv oa ob aw oc bi"><span id="de66" class="od la it nv b gy oe of l og oh">~/demo/kotlin-kafka-dynamo-demo ❯ ./gradlew generateAvroJava<br/>BUILD SUCCESSFUL in 764ms<br/>1 actionable task: 1 executed</span></pre><p id="07ce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们最终生成了两个Java类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/cdd86b2e4c9dacf7d85a9bf27d72e875.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*SfmCxzbMHhDy1T8aqkAmwQ.png"/></div></figure><p id="a263" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们转到任何Kotlin文件，我们将能够像这样导入这两个类中的任何一个:</p><pre class="kj kk kl km gt nz nv oa ob aw oc bi"><span id="04ed" class="od la it nv b gy oe of l og oh">import io.codebrews.createuserrequest.CreateUserRequest<br/>import io.codebrews.usercreatedevent.UserCreatedEvent</span><span id="423b" class="od la it nv b gy ok of l og oh">val <em class="oy">createUserRequest </em>= CreateUserRequest("email", "firstName", "lastName")</span><span id="dcfd" class="od la it nv b gy ok of l og oh">val <em class="oy">userCreatedEvent </em>= UserCreatedEvent("userId", "email", 1582844531)</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="d075" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">添加Kafka依赖</h1><p id="258e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本教程中，我们将使用<strong class="lt iu">反应器Kafka </strong>。Reactor Kafka在Kafka生产者和消费者API周围有一个很好的包装，它是反应式的和非阻塞的，因为它是建立在Project Reactor之上的。</p><p id="2d4b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，我们还需要将Kafka Avro序列化程序包添加到我们的项目中。这样我们就可以在发布到Kafka主题时将Java Avro类序列化为Avro记录，并在从主题消费时将Avro消息反序列化为Kotlin/Java类。</p><p id="479e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们转到我们的<code class="fe ns nt nu nv b">build.gradle.kts</code>文件并添加以下依赖项:</p><ul class=""><li id="6064" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><code class="fe ns nt nu nv b">io.projectreactor.kafka:reactor-kafka:1.2.2.RELEASE</code></li><li id="7269" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe ns nt nu nv b">io.confluent:kafka-avro-serializer:5.4.0</code></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">build.gradle.kts —最终版本</p></figure><p id="d4f6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，为了拉动<code class="fe ns nt nu nv b">kafka-avro-serializer</code>包，我们需要将<a class="ae ky" href="http://packages.confluent.io/maven/" rel="noopener ugc nofollow" target="_blank">http://packages.confluent.io/maven/</a>添加到<code class="fe ns nt nu nv b">repositories</code>部分。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="ea99" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">将Kafka配置添加到application.yml</h1><p id="9175" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">就像我们的DynamoDB一样，我们的Kafka配置会放在<code class="fe ns nt nu nv b">application.yml</code>。让我们添加以下属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序. yml</p></figure><p id="61f4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们讨论一下刚刚添加的属性:</p><ul class=""><li id="1e35" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><code class="fe ns nt nu nv b">broker</code>:这是Kafka代理的位置，我们的应用程序在从一个主题生成和消费消息时将与它进行交互。该地址与本<a class="ae ky" href="https://medium.com/better-programming/your-local-event-driven-environment-using-dockerised-kafka-cluster-6e84af09cd95" rel="noopener">教程</a>中指定的Kafka Docker对齐。</li><li id="02ff" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe ns nt nu nv b">serializer</code>:这是在发布到Kafka主题或队列之前将用于序列化我们的Kotlin/ Java对象的序列化程序。</li><li id="f0c5" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe ns nt nu nv b">deserializer</code>:这是一个反序列化器，用于将Kafka主题或队列中的消息反序列化为Kotlin/Java对象。</li><li id="aa3a" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe ns nt nu nv b">schema-registry-url</code>:这是我们的Kafka、生产者和消费者将与之交互的模式注册中心的URL。</li><li id="0006" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe ns nt nu nv b">create-user-request-topic</code>:这是我们的应用程序在收到一个<code class="fe ns nt nu nv b">POST</code>请求来创建一个新用户时将发布到的主题的名称。</li><li id="c86a" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><code class="fe ns nt nu nv b">user-created-event-topic</code>:这是我们的应用程序在成功创建新用户后将发布到的主题的名称。</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="7d67" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">创建KafkaConfigProperties数据类</h1><p id="14a1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们将创建一个<code class="fe ns nt nu nv b">data class</code>来保存上面的<code class="fe ns nt nu nv b">application.yml</code>文件中定义的Kafka配置的值。这允许我们在应用程序代码中轻松地访问这些值。</p><p id="9926" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们创建一个新的Kotlin文件并将其命名为<code class="fe ns nt nu nv b">KafkaConfigProperties.kt</code>。该文件的内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KafkaConfigProperties.kt</p></figure><p id="1237" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意<code class="fe ns nt nu nv b">ConstructorBinding</code>注释的用法。如果你想了解更多，看看这个教程。这是Spring Boot提供的有用注释之一。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="52b7" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">创建卡夫卡制作人</h1><p id="f422" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了能够向Kafka主题发布消息，我们需要一个Kafka生产者。在反应器卡夫卡中，它被称为<code class="fe ns nt nu nv b">KafkaSender</code>。</p><p id="b919" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们创建一个新的科特林文件，并将其命名为<code class="fe ns nt nu nv b">KafkaPublisher.kt</code>。它的内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KafkaPublisher.kt</p></figure><p id="6cb6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个班有两个<code class="fe ns nt nu nv b">KafkaSender</code>，其中一个(<code class="fe ns nt nu nv b">createUserRequestKafkaSender</code>)将连载并发布<code class="fe ns nt nu nv b">CreateUserRequest</code>，另一个(<code class="fe ns nt nu nv b">userCreatedEventKafkaSender</code>)将连载并发布<code class="fe ns nt nu nv b">UserCreatedEvent</code>。</p><p id="1956" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还用一个方法定义了一个<code class="fe ns nt nu nv b">companion object</code>，该方法将用于为我们将要发布的消息生成<code class="fe ns nt nu nv b">key</code>。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="3909" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">创建卡夫卡监听器</h1><p id="6518" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">除了生产者之外，我们还需要消费者根据生产者发布的消息执行操作。在《卡夫卡反应堆》中，它被称为<code class="fe ns nt nu nv b">KafkaReceiver</code>。</p><p id="1e61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">记住，我们的消费者需要处理用户创建请求。换句话说，它需要从<code class="fe ns nt nu nv b">create-user-request</code>主题中读取消息，然后在数据库表<code class="fe ns nt nu nv b">demo-customer-info</code>中相应地创建新用户。我们将为此创建一个类，并将其命名为<code class="fe ns nt nu nv b">KafkaListener.kt</code>。</p><p id="9f24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这意味着我们需要一个处理这些请求的类来保持事物的分离和去耦。我们还将在本节中创建handler类，并将其命名为<code class="fe ns nt nu nv b">CreateUserRequestHandler.kt</code>。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="8dbf" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">卡夫卡听众</h1><p id="7f0a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们创建我们的<code class="fe ns nt nu nv b">KafkaListener</code>类，它将监听<code class="fe ns nt nu nv b">create-user-request</code>主题并消费消息。它还将消息传递给处理程序类<code class="fe ns nt nu nv b">CreateUserRequestHandler</code>，后者将在数据库中创建一个新用户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KafkaListener.kt</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="1671" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">创建用户请求处理程序</h1><p id="9620" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们创建处理来自Kafka的<code class="fe ns nt nu nv b">CreateUserRequest</code>消息所需的处理程序。</p><p id="d81f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个类将做我们的<code class="fe ns nt nu nv b">POST</code> route曾经做过的事情——也就是说，在我们的数据库表<code class="fe ns nt nu nv b">demo-customer-info</code>中创建一个新的用户记录。不同的是，它将基于来自Kafka topic <code class="fe ns nt nu nv b">create-user-request</code>的<code class="fe ns nt nu nv b">CreateUserRequest</code>消息来这样做，而不是来自客户端的<code class="fe ns nt nu nv b">POST</code>请求。</p><p id="e799" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，在成功处理了<code class="fe ns nt nu nv b">CreateUserRequest</code>之后，它将向<code class="fe ns nt nu nv b">user-created-event</code>主题发布一条<code class="fe ns nt nu nv b">UserCreatedEvent</code>消息，以便通知其他消费者。</p><p id="56a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><em class="oy">注意:在本教程中，我们不会为这个主题创建一个消费者。这只是为了让您知道，您可以创建其他消费者来将此事件用于其他目的。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">CreateUserRequestHandler.kt</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0c61" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">调整CustomerHandler以发布CreateUserRequest消息</h1><p id="c901" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为我们想让我们的应用程序是事件驱动的，我们需要对我们的<code class="fe ns nt nu nv b">CustomerHandler</code>类做一些改变。目前，当我们的应用程序在<code class="fe ns nt nu nv b">/users</code>收到一个<code class="fe ns nt nu nv b">POST</code>请求时，<code class="fe ns nt nu nv b">CustomerHandler</code>会将请求发送给<code class="fe ns nt nu nv b">CustomerRepo</code>，并立即创建新用户。</p><p id="31b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里，它应该调用我们之前创建的<code class="fe ns nt nu nv b">KafkaPublisher</code>类来发布<code class="fe ns nt nu nv b">CreateUserRequest</code>消息，而不是创建一个新用户。然后，我们将让我们的<code class="fe ns nt nu nv b">KafkaListener</code>类消费消息并处理用户创建，如前一节所讨论的。</p><p id="b2ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们修改一下我们的<code class="fe ns nt nu nv b">CustomerHandler</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户处理者. kt</p></figure><p id="1750" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们添加了<code class="fe ns nt nu nv b">KafkaPublisher</code>,因为我们希望在每次客户端调用我们的<code class="fe ns nt nu nv b">POST</code>端点时发布一条<code class="fe ns nt nu nv b">CreateUserRequest</code>消息，而不是直接在我们的数据库表中创建一条新记录。</p><p id="069d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，<code class="fe ns nt nu nv b">generateCustomerId</code>函数也被移到了<code class="fe ns nt nu nv b">CreateUserRequestHandler</code>类中。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="7d24" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">启动应用程序并调用端点</h1><p id="d28d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们已经完成了事件驱动应用程序的编写——现在是测试它的时候了。让我们从<code class="fe ns nt nu nv b">IntelliJ</code>运行应用程序。</p><p id="bdc2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">打开<code class="fe ns nt nu nv b">KafkaDynamoDemoApplication</code>并点击<code class="fe ns nt nu nv b">main</code>功能左侧的绿色箭头按钮。从列表中选择第一个选项，即<code class="fe ns nt nu nv b">Run “&lt;class name&gt;”</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/e30e1a0a256ca33b21ec930fed7b363b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRDeURtgORA18VXBaO0Vkg.png"/></div></div></figure><p id="3eca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们应该看到这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/7fbc40e31c122cb9f6972b51bfd920ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SB5zqQ7vBYdJNj-etR0ekA.png"/></div></div></figure><p id="a503" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">太好了—我们的应用程序现在已经启动并运行了！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="37aa" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">发送发布请求</h1><p id="bbe5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们转到我们的终端，用下面的<code class="fe ns nt nu nv b">curl</code>命令向<code class="fe ns nt nu nv b">/users</code>端点发送一个<code class="fe ns nt nu nv b">POST</code>请求:</p><pre class="kj kk kl km gt nz nv oa ob aw oc bi"><span id="6866" class="od la it nv b gy oe of l og oh">$ ~/demo/kotlin-kafka-dynamo-demo ❯ curl -X POST -H 'Content-type: application/json' <a class="ae ky" href="http://localhost:8080/users" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/users</a> -d '{"emailAddress": "<a class="ae ky" href="mailto:joe@email.com" rel="noopener ugc nofollow" target="_blank">joe@email.com</a>", "firstName": "Joe", "lastName": "Jones"}'</span></pre><p id="a6ee" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们在发送上述请求后返回IntelliJ，我们会看到下面两行日志。</p><pre class="kj kk kl km gt nz nv oa ob aw oc bi"><span id="ba10" class="od la it nv b gy oe of l og oh">...<br/>...<br/>2020-03-02 20:34:11.847  INFO 36850 --- [       single-1] i.c.k.KafkaPublisher                     : Successfully sent a CreateUserRequest message with id 47e292ef-6e73-4ce3-886c-879846c668b6</span><span id="696d" class="od la it nv b gy ok of l og oh">...<br/>...<br/>2020-03-02 20:34:12.339  INFO 36850 --- [       single-1] i.c.k.KafkaPublisher                     : Successfully sent a UserCreatedEvent message with id 80e7d175-5e5c-4471-a78f-4b21b0e29bc1</span></pre><p id="8b0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些是由我们的<code class="fe ns nt nu nv b">KafkaPublisher</code>类记录的，我们将其定义为<code class="fe ns nt nu nv b">doOnSuccess</code>操作的一部分。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="108a" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">查看控制中心中的消息</h1><p id="83df" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">汇合控制中心还允许我们在UI上查看消息。转到您的浏览器并访问<a class="ae ky" href="http://localhost:9021" rel="noopener ugc nofollow" target="_blank"> http://localhost:9021 </a>。在所有选项卡所在的左侧，选择主题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/5e370992a479a4ba0f7cceeb349adb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BXewEcs1IqWlDc7SL8E1EQ.png"/></div></div></figure><p id="a3b1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们先来查看一下<code class="fe ns nt nu nv b">create-user-request</code>话题中的消息。继续点击<code class="fe ns nt nu nv b">create-user-request</code>。然后，点击<code class="fe ns nt nu nv b">Messages</code>选项卡。用户界面会说没有新消息。不要慌！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/f51e2e27ea1adb4a28a6f967275066bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEwBgzFFym62NkHNbG2w9w.png"/></div></div></figure><p id="9051" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">转到显示<code class="fe ns nt nu nv b">Offset</code>的框，输入<code class="fe ns nt nu nv b">0</code>作为值，然后按回车键。我们应该看到只有一条信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/6f93d12ec1b23946919129084bcb9a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jt27k7bmtB34GkJbszmLuA.png"/></div></div></figure><p id="6d61" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们将显示选项更改为卡片，我们将看到发布的消息的一个很好的表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/5eddd217230672f323458078e1e87f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UV40NgCOHzvwu2Ng2KlL7A.png"/></div></div></figure><p id="9098" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对<code class="fe ns nt nu nv b">user-created-event</code>主题重复相同的过程，我们将看到以下消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/fe721c068e97ec9f777d880b00d49a0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlDy8lZdbnfMziKtgIM2rw.png"/></div></div></figure><p id="fcf2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">太棒了。真的很酷，很满足，不是吗？</p><p id="f7a7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在有了一个事件驱动的应用程序！干得好，各位。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="478d" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">包裹</h1><p id="bda6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这篇全面的教程介绍了如何将我们的应用程序转换成事件驱动的应用程序。这是通过添加Kafka和Schema Registry来维护我们的生产者-消费者契约实现的。</p><p id="7fc0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还了解了如何使用汇合控制中心管理主题创建和查看主题中的消息。这个工具很神奇，它提供的远不止我们在本教程中所介绍的，我强烈建议您去探索它。</p><p id="d145" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我希望这篇教程能帮助你理解如何构建一个事件驱动的应用程序。如果您已经到了这个阶段，您可能会被我们介绍的所有内容弄得不知所措，但是希望充满知识和灵感来构建您自己的应用程序！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="f212" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">参考</h1><ul class=""><li id="7e2b" class="ms mt it lt b lu lv lx ly ma pd me pe mi pf mm mx my mz na bi translated"><a class="ae ky" href="https://docs.confluent.io/current/control-center/userguide.html" rel="noopener ugc nofollow" target="_blank">合流控制中心</a></li><li id="a4b1" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://projectreactor.io/docs/kafka/release/reference/" rel="noopener ugc nofollow" target="_blank">反应器卡夫卡</a></li><li id="dec2" class="ms mt it lt b lu nb lx nc ma nd me ne mi nf mm mx my mz na bi translated"><a class="ae ky" href="https://github.com/billydh/kotlin-kafka-dynamo-demo" rel="noopener ugc nofollow" target="_blank"> Github回购</a></li></ul></div></div>    
</body>
</html>