<html>
<head>
<title>A Deep Dive Into Dispatch Groups in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Swift中的调度组</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-dispatch-groups-8251bbb8b001?source=collection_archive---------1-----------------------#2020-05-10">https://betterprogramming.pub/a-deep-dive-into-dispatch-groups-8251bbb8b001?source=collection_archive---------1-----------------------#2020-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5798" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">iOS中正确的线程处理，包括进入、离开、等待、通知等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/281cded4ae79c805074966b27f097324.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*rPX1Gu74-KgxC-t2LB5Eww.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><a class="ae kr" href="https://unsplash.com/@aleno?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Adomas Aleno </a>在<a class="ae kr" href="https://unsplash.com/collections/9711207/home-office?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="71bd" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">调度组允许我们将一组任务作为一个单元进行监控。它聚集了一组任务并同步组中的行为。我们通过平衡调用<code class="fe lo lp lq lr b">enter()</code>和<code class="fe lo lp lq lr b">leave()</code>来将任务添加到一个组中。当所有任务完成执行时，该组执行其完成处理程序。您还可以同步等待组中的所有任务执行完毕。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9345" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">基础</h1><p id="0552" class="pw-post-body-paragraph ks kt iq ku b kv mr jr kx ky ms ju la lb mt ld le lf mu lh li lj mv ll lm ln ij bi translated">调度组由四种基本方法组成</p><ul class=""><li id="1a3f" class="mw mx iq ku b kv kw ky kz lb my lf mz lj na ln nb nc nd ne bi translated"><code class="fe lo lp lq lr b">enter()</code>:用于表示一段代码已经进入该组</li><li id="7ae4" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe lo lp lq lr b">leave()</code>:用于表示一段代码已经执行完毕，离开了该组</li><li id="bdff" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe lo lp lq lr b">wait()</code>:同步等待提交的工作完成。阻塞调用线程，直到工作完成。</li><li id="92e0" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated"><code class="fe lo lp lq lr b">notify()</code>:通知需要的线程，提交的块已经执行完毕</li></ul><p id="d492" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在下面的例子中，我们将看到如何使用调度组来执行一组操作。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b76f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">调度组:演示</h1><p id="4070" class="pw-post-body-paragraph ks kt iq ku b kv mr jr kx ky ms ju la lb mt ld le lf mu lh li lj mv ll lm ln ij bi translated">在我们的演示中，我们将执行以下步骤:</p><ol class=""><li id="7888" class="mw mx iq ku b kv kw ky kz lb my lf mz lj na ln nk nc nd ne bi translated">调用GitHub trending-users API并获取前三名用户的个人资料图片URL。</li><li id="2a7b" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">使用我们在步骤1中获得的URL加载三个配置文件图像，并缓存它们。</li><li id="0eba" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">以上操作完成后，返回主线程。</li></ol><p id="a5c2" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir">注意:</strong>我举了一个真实世界的例子，来解释当你在应用中包含这个时，你可能会面临的所有细微差别。</p><p id="8178" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">本质上，我们将进行四次API调用:一次获取趋势用户，三次获取图像。</p><p id="492e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">首先，我们将看看如何使用调度组的<code class="fe lo lp lq lr b">wait()</code>方法来执行这些操作，然后我们将看看<code class="fe lo lp lq lr b">notify()</code>变体。</p><h1 id="1b40" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated">代码设置</h1><p id="4a03" class="pw-post-body-paragraph ks kt iq ku b kv mr jr kx ky ms ju la lb mt ld le lf mu lh li lj mv ll lm ln ij bi translated">这是一段我们将用于<code class="fe lo lp lq lr b">wait()</code>和<code class="fe lo lp lq lr b">notify()</code>变体的代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/f9c00e339de0bbf3c902315c89f46c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*27LnwSz1ppLMTIMZf_QezQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图像加载设置</p></figure><ul class=""><li id="7aec" class="mw mx iq ku b kv kw ky kz lb my lf mz lj na ln nb nc nd ne bi translated"><code class="fe lo lp lq lr b">loadImage</code>方法将<code class="fe lo lp lq lr b">imageURL</code>作为输入，获取图像，并缓存在一个简单的图像缓存中。然后它执行完成闭包。</li></ul><h2 id="7949" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lb oa ob ml lf oc od mn lj oe of mp og bi translated">等待()</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oh"><img src="../Images/fbaa224927cdecc88de32f97b25718fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n8IUB-9eoXvPoqVWNO-hCg.png"/></div></div></figure><p id="10b8" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我解释一下这是怎么回事。</p><ol class=""><li id="5a7b" class="mw mx iq ku b kv kw ky kz lb my lf mz lj na ln nk nc nd ne bi translated">在<code class="fe lo lp lq lr b">getUserImages</code>方法中，我们初始化了一个<code class="fe lo lp lq lr b">DispatchGroup</code>对象。</li><li id="e982" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">我们配置<code class="fe lo lp lq lr b">dataTask</code>来获取趋势用户，并在得到趋势用户的响应后调用<code class="fe lo lp lq lr b">loadImages</code>。</li><li id="e841" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">我们在调用趋势用户API之前添加了<code class="fe lo lp lq lr b">group.enter()</code>，并添加了一个延迟语句<code class="fe lo lp lq lr b">group.leave()</code>，它将在我们退出<code class="fe lo lp lq lr b">dataTask</code>的完成闭包时运行。</li><li id="e996" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">一旦我们收到趋势API响应，我们就调用<code class="fe lo lp lq lr b">loadImage</code>方法来获取图像。我们在调用方法之前添加了<code class="fe lo lp lq lr b">group.enter()</code>,在离开闭包之前添加了<code class="fe lo lp lq lr b">group.leave()</code>。总之，我们在这里添加了三个进入和离开调用</li><li id="369d" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated"><code class="fe lo lp lq lr b">.resume()</code>触发数据任务。到目前为止，我们所做的只是配置，但是对服务的实际调用现在发生了。</li><li id="bb0d" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated"><code class="fe lo lp lq lr b">group.wait()</code>将阻塞调用者线程，直到所有操作完成(它将通过使它遇到的<code class="fe lo lp lq lr b">enter()</code>和<code class="fe lo lp lq lr b">leave()</code>调用的数量相等来确定这一点)。</li><li id="a00e" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">一旦所有操作完成，即执行了四个<code class="fe lo lp lq lr b">group.leave()</code>,调用线程将被解锁，并且<code class="fe lo lp lq lr b">work done</code>将被打印在调用线程上。让我们看看它的输出:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oi"><img src="../Images/7adc1a2f8da60b89278d70d8b2089980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofSusvYI2bApwdleqPYT8g.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">执行完所有闭包后，使用调用线程打印出<code class="fe lo lp lq lr b">'work done'</code>。</p></figure><h2 id="62ad" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lb oa ob ml lf oc od mn lj oe of mp og bi translated">常见陷阱</h2><p id="2b2a" class="pw-post-body-paragraph ks kt iq ku b kv mr jr kx ky ms ju la lb mt ld le lf mu lh li lj mv ll lm ln ij bi translated">通常在类似上面例子的场景中，我们不在主API调用(趋势-用户调用)周围添加<code class="fe lo lp lq lr b">group.enter()</code>和<code class="fe lo lp lq lr b">group.leave()</code>，因为添加调度组的全部目的是跟踪发生的获取图像的并发调用。</p><p id="89c1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">然而，在这种情况下，我们必须在趋势API调用周围添加它；否则，<code class="fe lo lp lq lr b">work done</code>块甚至会在图像获取调用之前被执行。</p><p id="bda4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">为什么？由于趋势API调用将被委托给一个后台线程，调用线程的执行将到达<code class="fe lo lp lq lr b">dispatchGroup.wait()</code>，到那时，图像获取<code class="fe lo lp lq lr b">enter()</code>或<code class="fe lo lp lq lr b">leave()</code>调用将不会被执行。所以<code class="fe lo lp lq lr b">dispatchGroup.wait()</code>不会阻塞主线程，而是执行打印语句。</p><h2 id="fb98" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lb oa ob ml lf oc od mn lj oe of mp og bi translated">避免<code class="fe lo lp lq lr b">wait()</code></h2><p id="c207" class="pw-post-body-paragraph ks kt iq ku b kv mr jr kx ky ms ju la lb mt ld le lf mu lh li lj mv ll lm ln ij bi translated">强烈建议尽可能避免使用<code class="fe lo lp lq lr b">wait()</code>,因为它实际上阻塞了调用线程，在我们的例子中，它是主线程。</p><p id="057e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">即使我们将整个<code class="fe lo lp lq lr b">getUserImages</code>函数添加到一个并发队列中，并让它在一个后台线程上工作，当我们执行请求时，我们还是阻塞了一个非常有限的GCD工作线程。这就是我们使用<code class="fe lo lp lq lr b">notify()</code>的原因。</p><h2 id="4b4a" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lb oa ob ml lf oc od mn lj oe of mp og bi translated">通知()</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oj"><img src="../Images/85e5f293cab58b5f794772426b1cea74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDHuFRoScttd-hYLe7gr8Q.png"/></div></div></figure><ol class=""><li id="486f" class="mw mx iq ku b kv kw ky kz lb my lf mz lj na ln nk nc nd ne bi translated">我们在趋势API调用的闭包内初始化调度组。</li><li id="db09" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">我们在调用方法之前添加了<code class="fe lo lp lq lr b">group.enter()</code>，在离开闭包之前添加了<code class="fe lo lp lq lr b">group.leave()</code>。这里总共有三个进入和离开调用。</li><li id="df8b" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">然后我们遇到了<code class="fe lo lp lq lr b">group.notify()</code>方法，它没有阻塞调用线程，而是在所有的<code class="fe lo lp lq lr b">group.leave()</code>方法被执行时通知主线程。</li><li id="1cb9" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nk nc nd ne bi translated">现在<code class="fe lo lp lq lr b">loadImage</code>关闭将被执行，图像将被成功存储。一旦所有的闭包都被执行，主线程就会得到通知，并且<code class="fe lo lp lq lr b">work done</code>会被打印在主线程上。</li></ol><p id="752e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">当使用调度组时，您应该总是考虑使用<code class="fe lo lp lq lr b">notify()</code>，因为它不会阻塞线程。</p><h2 id="fb65" class="nv ma iq bd mb nw nx dn mf ny nz dp mj lb oa ob ml lf oc od mn lj oe of mp og bi translated">奖金</h2><ul class=""><li id="afcf" class="mw mx iq ku b kv mr ky ms lb ok lf ol lj om ln nb nc nd ne bi translated">我们可以在<code class="fe lo lp lq lr b">wait()</code>方法上设置一个超时，这将使我们能够设置阻塞调用线程的时间。即使没有执行完所有的<code class="fe lo lp lq lr b">leave()</code>方法，我们也会解除对线程的阻塞并开始执行其他任务。</li><li id="a716" class="mw mx iq ku b kv nf ky ng lb nh lf ni lj nj ln nb nc nd ne bi translated">我们可以将<code class="fe lo lp lq lr b">DispatchWorkItem</code>与<code class="fe lo lp lq lr b">notify()</code>方法一起使用，这将帮助我们有效地实现取消处理程序和事件处理程序。</li></ul><h1 id="a71a" class="lz ma iq bd mb mc nl me mf mg nm mi mj jw nn jx ml jz no ka mn kc np kd mp mq bi translated">尾注</h1><p id="6fbf" class="pw-post-body-paragraph ks kt iq ku b kv mr jr kx ky ms ju la lb mt ld le lf mu lh li lj mv ll lm ln ij bi translated">这就是我这篇文章的全部内容，感谢阅读。<strong class="ku ir">关注我的</strong> <a class="ae kr" href="https://twitter.com/_kiran_44" rel="noopener ugc nofollow" target="_blank"> <strong class="ku ir">推特</strong> </a> <strong class="ku ir"> </strong>了解更多更新。<strong class="ku ir">如果你喜欢这个帖子，请提供一些掌声，因为这将鼓励我写更多(<strong class="ku ir">你可以放弃多达50个</strong>)。P.s .完全不用担心迂腐。如果你认为我可以在文章中做些改进，请告诉我。</strong></p></div></div>    
</body>
</html>