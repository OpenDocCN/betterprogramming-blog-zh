<html>
<head>
<title>Build a Real-time Chat Application Using Socket.io and NextJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Socket.io和NextJS构建一个实时聊天应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/socket-io-and-nextjs-build-real-time-chat-application-part-1-976555ecba?source=collection_archive---------0-----------------------#2022-07-14">https://betterprogramming.pub/socket-io-and-nextjs-build-real-time-chat-application-part-1-976555ecba?source=collection_archive---------0-----------------------#2022-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6e04" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">套接字如何工作，可以用它们做什么，以及如何用NextJS实现这些功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2222ed820c7d5ada3985449ca4eb5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uRDO3_5j7Bt6XgKdUgfow.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">socket.io 101</p></figure><p id="4b4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总有更多的东西可以添加到您的应用程序中。也许你已经创建了一个漂亮的仪表板，但是你不希望你的用户每次有新的东西时都刷新站点。</p><p id="5b96" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也许您想在新邮件出现时发送通知。也许你一直想创建一个像agar.io这样的多人实时游戏。</p><p id="aba1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可能性是无穷的。但是对于不同类型的努力，你需要不同的工具。在本文中，我将带您完成构建这样一个实时聊天应用程序的必要步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/55fb1fceb07b0a736e1b0cbfe44b5e70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-mrhP2lT9JmdbKA-Y-agg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们今天要建造什么</p></figure><p id="bb3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你更喜欢使用代码，这里有一个Github项目。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7e23" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">什么是插座？</strong></h1><p id="32f6" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">除非您是Linux程序员，否则了解套接字下的所有理论并没有太大的价值，所以我们不要一头扎进兔子洞。我在这里给你你需要的一切，这样你就可以开始创建很酷的应用程序。Sooooo..什么是插座？</p><p id="abd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">套接字是两个设备之间的通信端点。这是一个定义。在我看来，理解套接字真正带给我们什么的最简单的方法是将其与非套接字通信进行比较。</p><h2 id="80d9" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated"><strong class="ak">客户端-服务器(单向)通信</strong></h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac723fc8311a6427b7a87b9019fd43f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*too5oeCNzP89xCb5F7v8pA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户端-服务器通信表示</p></figure><p id="1fb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在现代网络中，互联网上的大多数通信都是客户端-服务器类型的——大多数API和网站都是以这种方式工作的。客户机-服务器通信的真正含义是客户机必须询问服务器才能得到答案。服务器无法初始化通信，因此服务器无法真正通知用户任何事件。</p><h2 id="66ca" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">套接字(双向)通信</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e837cfd2fa7691ff92a44db35f6ba7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*axqNacJOzT4QRb9mEC7guQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">套接字通信表示</p></figure><p id="0535" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在套接字通信中，一旦建立了通信，双方就可以自由地互相发送消息。建立通信后，无需初始化通信。现在，服务器可以通知用户例如新消息，并且用户可以对其做出反应。这种情况下的通信是基于事件的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="8016" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated">Socket.io架构</h2><p id="f191" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">为了建立双向通信，我们需要一个服务器和一个客户端。因为我们使用NextJS，所以我们的服务器端将被放在NextJS API文件夹中，而客户端将被编码到需要它的每个页面中。所以总的来说，我们将有一个服务器(如果流量很大，有可能有多个服务器)和每个客户端一个连接。让我们从服务器端开始。</p><h2 id="7258" class="na me it bd mf nb nc dn mj nd ne dp mn lh nf ng mp ll nh ni mr lp nj nk mt nl bi translated"><strong class="ak">套接字服务器代码</strong></h2><p id="d192" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在API文件夹中创建一个<code class="fe nm nn no np b">socket.tsx</code>文件。因为NextJS API文件夹充当服务器，所以我们需要在这里设置一个。我们通过检查<code class="fe nm nn no np b">res</code>套接字属性来检查套接字连接是否已经建立。基本上，我们希望为整个应用程序创建一个服务器实例。如您所见，我们首先检查server.io属性是否存在，如果存在，这意味着我们已经有了一个服务器。如果没有，我们创建一个新的，然后，我们分配emit处理程序，我将在下一步向您展示。</p><p id="4884" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得注意的是，虽然我们可以用几乎任何名字创建事件，但也有一些特殊的。“联系”就是其中之一。其他的例如:“连接错误”、“断开”等。您可以在文档中查看完整列表<a class="ae lv" href="https://socket.io/docs/v4/emit-cheatsheet/#reserved-events" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d8b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在connection上设置不同的事件处理程序是正确的做法，因为我们必须确保套接字存在，并且回调函数仅在套接字创建后被调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="73bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然您可以在<code class="fe nm nn no np b">onConnection</code>函数中创建所有的事件处理程序，但是我们会考虑到干净的架构来做这件事。因为我们只有一个不会改变太多的事件，但是如果你有很多这样的事件，这将允许你很好地组织它们，并按不同的功能对它们进行分组。消息处理程序如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="dcdd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，惯例是首先在顶部定义处理程序，然后将它们分配给正确的事件。这段代码意味着，如果客户端发送<code class="fe nm nn no np b">createdMessage</code>事件，它将由一个名字类似的functio️n.处理</p><p id="9ed7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">说到服务器端就这些了。现在让我们关注客户端。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4334" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">客户端App代码</strong></h1><p id="8af7" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">所有的客户端代码都放在一个文件中:<code class="fe nm nn no np b">index.tsx</code>。我们创建一个全局套接字变量，这样它就不会每次都被重写，然后我们创建一个消息类型并设置一些<code class="fe nm nn no np b">useState</code>值。到目前为止一切顺利。在<code class="fe nm nn no np b">useEffect</code>中，我们运行一个<code class="fe nm nn no np b">socketInitializer</code>函数。因为我们使用NextJS API作为服务器，所以我们必须获取(<code class="fe nm nn no np b">/api/socket</code>)端点，该端点将触发我们在上一步中创建的逻辑。这是必要的，因为为了从客户端连接到服务器，我们首先需要确保服务器存在。</p><p id="40b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们分配一个io实例，将其分配给一个套接字，并创建一个事件监听器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="f7fa" class="md me it bd mf mg ns mi mj mk nt mm mn jz nu ka mp kc nv kd mr kf nw kg mt mu bi translated"><strong class="ak">发射事件</strong></h1><p id="dd7b" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">因为我们已经创建了一个套接字服务器、客户端以及事件处理程序，所以让我们在用户想要发送消息时发出一个事件。如果您想要通知通信管道的第二端，您需要调用emit方法，其中第一个参数是事件的名称，所有后面的参数都是回调函数的参数。您可以拥有任意多个这样的函数，只要记住在函数声明中指定它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="425e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个特定的场景中，我们还将消息添加到我们在聊天中显示的消息数组中。这样做的原因是，当我们可以立即保存它时，首先将它发送到服务器，然后再将其发送回客户端是没有多大意义的。这就把我们带到了下一个话题:</p><h1 id="029d" class="md me it bd mf mg ns mi mj mk nt mm mn jz nu ka mp kc nv kd mr kf nw kg mt mu bi translated"><strong class="ak">不同类型的发射</strong></h1><p id="ce97" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">因为使用socket.io有很多不同的可能性，所以发送事件也有很多不同的方式。您可以<code class="fe nm nn no np b">emit</code>将它发送给除发送它的客户之外的所有客户(就像上面的例子一样)，您可以<code class="fe nm nn no np b">broadcast</code> <strong class="la iu"> </strong>将它包括发送它的客户，或者您可以只发送给一个房间(是的，您可以在那里有房间)。你肯定知道你能使用什么，socket.io在他们的文档中有一个极好的备忘单。</p><h1 id="c6c7" class="md me it bd mf mg ns mi mj mk nt mm mn jz nu ka mp kc nv kd mr kf nw kg mt mu bi translated"><strong class="ak">前端</strong></h1><p id="9431" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">本教程的最后一部分是定义前端，这非常简单。我们只需遍历messages数组，显示所有消息，如果用户按下send按钮或enter键，就会发送一条消息，顺便说一下，您可以通过这样做来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d1ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总的来说，前端代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="d1a3" class="md me it bd mf mg ns mi mj mk nt mm mn jz nu ka mp kc nv kd mr kf nw kg mt mu bi translated">摘要</h1><p id="bdfc" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">如你所见<code class="fe nm nn no np b">socket.io</code>并不可怕，而且超级强大。它允许你建立交互式实时仪表盘，多人游戏，等等。简而言之，它允许你建立更有活力的网站。</p><p id="bd2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想深入了解，你可以订阅我的时事通讯，阅读本系列的下一部分，或者直接阅读<a class="ae lv" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="bfaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随时在<a class="ae lv" href="https://twitter.com/szymon_kolber" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我。</p><p id="d0e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而这里有一个<a class="ae lv" href="https://github.com/kolberszymon/socket-chat-app" rel="noopener ugc nofollow" target="_blank"> Github回购</a>。</p><p id="300a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">祝你有愉快的一天。</p></div></div>    
</body>
</html>