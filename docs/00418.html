<html>
<head>
<title>How to Parse JSON from a GraphQL Response</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从GraphQL响应中解析JSON</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/parsing-json-from-a-graphql-response-854e8a29afef?source=collection_archive---------5-----------------------#2019-05-16">https://betterprogramming.pub/parsing-json-from-a-graphql-response-854e8a29afef?source=collection_archive---------5-----------------------#2019-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="257e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">查询、变异的剖析，以及如何得到你所需要的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dabf852eef5ff5c00f52184d65de6b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XJC2bedGv0MAsHMBc3_72g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@dekubaum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼斯·库默</a>在<a class="ae ky" href="https://unsplash.com/s/photos/data?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL是一个令人惊奇和激动的新数据服务协议。</p><p id="e1d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近很喜欢阅读Apollo团队的一篇文章，这篇文章剖析了GraphQL请求的结构。围绕GraphQL有一个术语是进一步讨论的一个很好的促进因素。</p><p id="d14c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于GraphQL查询的结构具有解剖学，我们可以预期JSON会以定义的方式从请求中返回。本文将围绕返回的JSON列出一些易于记忆的规则。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1821" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak"> GraphQL解剖复习器</strong></h1><p id="5930" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们回顾一下GraphQL请求的各个部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/d45c12aeb6e7e4b8f0b175f2187e91fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rc-U3bPPHekUeXPM9VkT4w.png"/></div></div></figure><p id="6f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个重要的定义在上面没有显现出来。选择集:GraphQL上花括号之间的东西<code class="fe na nb nc nd b">{ }</code>。选择集存在于每个嵌套级别中。</p><h2 id="a861" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated">规则</h2><ul class=""><li id="0056" class="nq nr it lb b lc mu lf mv li ns lm nt lq nu lu nv nw nx ny bi translated">所有GraphQL请求都返回一个关键字为<code class="fe na nb nc nd b">data</code>的字典。关键数据的值是另一个字典。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="0704" class="nq nr it lb b lc ld lf lg li ob lm oc lq od lu nv nw nx ny bi translated">GraphQL请求中的每个顶级字段都由字典中的一个键表示。</li><li id="6dc4" class="nq nr it lb b lc oe lf of li og lm oh lq oi lu nv nw nx ny bi translated">顶层关键字的值取决于请求。如果请求是寻找一个唯一的或者主键，那么这个值就是一个字典。如果请求不是针对某个独特的东西，那么它就是一个数组。</li></ul><p id="c21b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个GraphQL请求，它以两种不同的方式请求相同的信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="d9a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是结果。请注意，使用筛选器的查询返回一个数组，使用唯一键的查询返回一个字典:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><ul class=""><li id="1ef6" class="nq nr it lb b lc ld lf lg li ob lm oc lq od lu nv nw nx ny bi translated">在顶级请求被解析之后，字段可以包含标量以及符合规则三的JSON对象。</li><li id="6da5" class="nq nr it lb b lc oe lf of li og lm oh lq oi lu nv nw nx ny bi translated">变异返回表示该变异元信息的字段。</li></ul><p id="14e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是突变的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="35ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，突变选择集中的字段是关于该突变的元信息。在这种情况下，一些元信息(返回字段)表示您刚刚创建的记录的值。这是对这种突变的反应。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c77" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8dc1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最终，确切的JSON形式取决于GraphQL API开发人员。这些例子是从PostgreSQL产品上的令人惊叹和生产力提升的<a class="ae ky" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"> Hasura实时GraphQL API中获得的。</a></p><p id="f201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这篇文章有错误，请留下反馈！</p></div></div>    
</body>
</html>