<html>
<head>
<title>Design the Base Components in Android With a Clean Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用简洁的架构设计Android中的基础组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-the-base-components-in-android-with-a-clean-architecture-ff803fad5895?source=collection_archive---------2-----------------------#2021-04-19">https://betterprogramming.pub/design-the-base-components-in-android-with-a-clean-architecture-ff803fad5895?source=collection_archive---------2-----------------------#2021-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e433" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Android的干净架构教程的第4部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d15a67ea24f312b53f3f8f53ca35b22c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sy5R57mZkXpAbsc2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@fedechanw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Federica Galli </a>拍摄的照片。</p></figure><p id="48f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们关于使用合适的干净架构构建Android应用程序的系列文章的第四部分。在这一期中，我们将关注Android组件的基类和集中公共工作的<code class="fe lv lw lx ly b">ViewModel</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1c04" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">快速回顾</h1><p id="a113" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在继续之前，我强烈推荐阅读本系列的前几部分，在那里您将了解为什么我们应该使用干净的架构，如何使用Dagger2实现依赖注入，等等。</p><ul class=""><li id="7795" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-set-up-a-dependency-injection-framework-with-dagger2-in-android-aa23ee9299db">Android清洁架构教程(第1部分):如何用Dagger2建立复杂的DI结构</a></li><li id="65a3" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/creating-a-repository-data-layer-with-kotlin-coroutines-in-android-1375ab79b6f0">Android的干净架构教程(第2部分):使用协程创建存储库和用例</a></li><li id="0557" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/injecting-android-viewmodels-with-dagger2-in-clean-architecture-744c1fe81530">安卓清洁架构教程(三)</a> <code class="fe lv lw lx ly b"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/injecting-android-viewmodels-with-dagger2-in-clean-architecture-744c1fe81530">ViewModels</a></code> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/injecting-android-viewmodels-with-dagger2-in-clean-architecture-744c1fe81530">与匕首2:天作之合</a></li><li id="3bb2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">Android的干净架构教程(第4部分):你在这里。</li></ul><p id="4c7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一部分，我们将关注于创建基类，在那里我们将保留所有的常见任务，比如创建一个<code class="fe lv lw lx ly b">ViewModel</code>实例，膨胀一个布局，等等。</p><p id="cd7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须为每个Android组件和其他组件(如<code class="fe lv lw lx ly b">ViewModels</code>和<code class="fe lv lw lx ly b">ReyclerView</code>适配器)创建一个单独的基类。</p><p id="5e3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要再耽搁了，让我们开始吧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ddc0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">基础活动</h1><p id="a925" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Android应用程序中，<code class="fe lv lw lx ly b">Activities</code>是一些最重要的组件。Android <code class="fe lv lw lx ly b">Activity</code>是当用户点击应用图标或者任何第三方应用想要访问或触发你的应用UI时启动应用的入口点。</p><p id="b508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像任何其他Android组件一样，<code class="fe lv lw lx ly b">Activity</code>也有生命周期。在<code class="fe lv lw lx ly b">onCreate</code>函数中，我们需要使用<code class="fe lv lw lx ly b">setContentview</code>函数来扩展<code class="fe lv lw lx ly b">Activity</code>布局。像这样的常见功能应该转移到基本组件中。为了更好地理解它，让我们看看完整的基类代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="27bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你观察代码，你会发现<code class="fe lv lw lx ly b">BaseActivity</code>是一个抽象类，因为我们需要包含可以在实际活动中被覆盖的抽象函数，在实际活动中，我们将使用它们实现各自的功能。</p><p id="87fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个课程中，你会看到三个抽象函数。<code class="fe lv lw lx ly b">getInjectViewModel</code>、<code class="fe lv lw lx ly b">setupViews</code>和<code class="fe lv lw lx ly b">getLayoutResId</code>分别用于创建<code class="fe lv lw lx ly b">ViewModel</code>实例、触发特性级功能和展开布局。</p><p id="4d38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在类的底部，你会看到三个普通的函数:<code class="fe lv lw lx ly b">takeToPlaystore</code>、<code class="fe lv lw lx ly b">openUrl</code>和<code class="fe lv lw lx ly b">showAlert</code>。这些是用于执行一些常见任务的功能，如导航到playstore以对应用程序进行评级或显示简单的警告对话框。</p><p id="b463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们还维护了一个与活动的生命周期相关联的<code class="fe lv lw lx ly b">coroutinescope</code>。当你在做一些需要花费时间的事情时，我们可以很容易地使用这个范围。当<code class="fe lv lw lx ly b">onDestroy</code>函数被触发时，协程内执行的所有任务都将被取消。</p><h2 id="a424" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">使用</h2><p id="14e7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们看看如何使用<code class="fe lv lw lx ly b">BaseActivity</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们使用<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/koin-a-kotlin-native-dependency-injection-library-8e13b81bd48e"> Koin </a>或<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-in-android-with-dagger2-d260b8a72bb0"> Dagger2 </a>依赖注入库将<code class="fe lv lw lx ly b">HomeActivity</code>扩展为<code class="fe lv lw lx ly b">ViewModel</code>的类型。然后我们必须覆盖基类的抽象函数，并传递各自的布局和<code class="fe lv lw lx ly b">ViewModel</code>。一旦一切都配置好了，就会调用<code class="fe lv lw lx ly b">setupViews</code>函数，我们就可以开始实际的编码了，比如设置监听器或执行网络请求。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3420" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">碱基片段</h1><p id="f716" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在现代Android开发中至关重要。随着单个<code class="fe lv lw lx ly b">Activity</code>应用的增长，<code class="fe lv lw lx ly b">Fragments</code>的重要性也迅速增加。基本上，在现代Android开发中，我们只使用<code class="fe lv lw lx ly b">Activities</code>来启动应用。剩下的工作是使用<code class="fe lv lw lx ly b">Fragments</code>完成的。</p><p id="7e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">Activity</code>类似，<code class="fe lv lw lx ly b">Fragment</code>也有生命周期。在<code class="fe lv lw lx ly b">onCreateView</code>函数中，我们需要展开视图，并开始执行<code class="fe lv lw lx ly b">onViewCreated</code>函数中特定于特性的代码。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c8d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">BaseActivity</code>非常相似，<code class="fe lv lw lx ly b">BaseFragment</code>也是一个抽象类，它有一个抽象函数来创建<code class="fe lv lw lx ly b">ViewModel</code>实例，展开布局，并触发特定于功能的代码。</p><p id="eeeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，我们还有一些实用功能，如<code class="fe lv lw lx ly b">rateUs</code>、<code class="fe lv lw lx ly b">moreApps</code>、<code class="fe lv lw lx ly b">openURL</code>等等。如果应用程序主要依赖于<code class="fe lv lw lx ly b">Fragments</code>，那么在基础<code class="fe lv lw lx ly b">Fragment</code>中使用公共函数是有意义的。与<code class="fe lv lw lx ly b">BaseActivity</code>类似，我们维护一个协程范围，并在片段分离时取消它的所有子任务。</p><h2 id="e386" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">使用</h2><p id="4a5f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们看看如何使用<code class="fe lv lw lx ly b">BaseFragment</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="93e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">HomeActivity</code>一样，我们必须用<code class="fe lv lw lx ly b">BaseFragment</code>扩展<code class="fe lv lw lx ly b">Homefragment</code>，使<code class="fe lv lw lx ly b">ViewModel</code>的类型能够注入。然后我们必须覆盖基类的抽象函数，并传递各自的布局和<code class="fe lv lw lx ly b">ViewModel</code>。一旦一切都配置好了，就会调用<code class="fe lv lw lx ly b">initViews</code>函数，我们就可以开始实际的代码了。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ce76" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">BaseViewModel</h1><p id="318b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">与其他类相比，这是最简单的基类。这里，我们将像在上面的类中一样创建一个协程作用域，但是调度程序将是<code class="fe lv lw lx ly b">Dispatcher.IO</code>而不是<code class="fe lv lw lx ly b">main</code>或<code class="fe lv lw lx ly b">default</code>。</p><p id="0c43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">ViewModel</code>中，我们主要执行与后台相关或长期运行的任务，比如发出网络请求、文件相关操作、数据库事务等等。所有这些操作都应该在后台完成，所以我们使用的是<code class="fe lv lw lx ly b">Dispatchers.IO</code>。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="df9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们没有任何抽象函数需求，所以我们没有将<code class="fe lv lw lx ly b">BaseVoewmodel</code>声明为抽象的。但是我们需要使用一个open关键字。在Kotlin中，默认情况下类是final，这意味着它们是不可扩展的。我们需要使用如上图所示的<code class="fe lv lw lx ly b">open</code>。</p><h2 id="5b8a" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">使用</h2><p id="ab40" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们看看如何使用<code class="fe lv lw lx ly b">BaseViewModel</code>。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和上面的两个基类一样，我们用<code class="fe lv lw lx ly b">BaseViewModel</code>扩展了<code class="fe lv lw lx ly b">HomeViewModel</code>。然后，如果您想要进行网络请求或数据库事务，我们使用来自<code class="fe lv lw lx ly b">BaseViewModel</code>的<code class="fe lv lw lx ly b">coroutineScope</code>来完成，这将任务的范围限制在<code class="fe lv lw lx ly b">ViewModel</code>的生命周期内。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="01f1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">奖金</h1><h2 id="e347" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">GitHub回购</h2><p id="f157" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">导入项目并切换到<code class="fe lv lw lx ly b">articles/viewmodels</code>分支，查看与本文相关的代码:</p><div class="of og gp gr oh oi"><a href="https://github.com/SG-K/Clean-Architecture-Sample" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">SG-K/Clean-架构-示例</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在GitHub上创建一个帐户，为SG-K/Clean-Architecture-Sample开发做贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ks oi"/></div></div></a></div><p id="7142" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解有关高级Android开发和架构组件的更多信息，请阅读以下文章:</p><ul class=""><li id="9f4a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/best-practices-for-using-viewmodels-in-android-e986b25dc78f">在Android中使用视图模型的最佳实践</a></li><li id="e1cc" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/no-more-livedata-in-repositories-in-kotlin-85f5a234a8fe">科特林的存储库中不再有实时数据</a></li><li id="f187" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/advanced-android-programming-with-kotlin-5e40b1be22bb">使用Kotlin进行高级编程</a></li><li id="af57" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/detailed-guide-on-android-clean-architecture-9eab262a9011" rel="noopener">Android Clean架构详细指南</a></li></ul><p id="8bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>