<html>
<head>
<title>Rethinking Testing Through Declarative Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过声明式编程重新思考测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rethinking-testing-through-declarative-programming-335897703bdd?source=collection_archive---------2-----------------------#2020-11-15">https://betterprogramming.pub/rethinking-testing-through-declarative-programming-335897703bdd?source=collection_archive---------2-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6554" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写可读和可维护的测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3cdc4d5031cce6a9a3902c6a47b6573b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Chrn7vJGknQ7dOgb"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯特尔·海斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是关于编写声明性的可读和可维护的测试。我希望它可以成为一个开始提问的起点:我们是否应该有更先进的测试框架来鼓励并使编写声明性测试变得更容易，而不是我们目前基于步骤的通用和命令式测试？</p><p id="b5e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现当前的框架抽象如<code class="fe ls lt lu lv b">describe</code>、<code class="fe ls lt lu lv b">it</code>和<code class="fe ls lt lu lv b">asserts</code>只是表面上处理测试结构，但是仍然有足够的空间来探索我们在测试时实际做了什么。Arrange，Act，Assert <em class="lw"> </em> (AAA)模型是有效的隐喻，但它也有同样的问题。结果是维护需求增加。以一种空白的心态开始每一次考试，意味着未来的问题。</p><p id="ac66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我将具体展示我在过去几年中在JS中使用的几个测试模式的例子。</p><p id="8308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在几乎用这些模式编写了所有的测试。在大型代码库中，它变得非常重要！</p><p id="7345" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些模式在测试中有非常积极的影响:提高可读性和可维护性，并允许代码评审中更好的协作。它们允许从测试中提取更多的价值。</p><p id="b321" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望看到这些想法发展成为测试框架的最佳实践。</p><p id="a0fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来我们会看到:</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="b928" class="mb mc iq lv b gy md me l mf mg">#1.1 <a class="ae kv" href="#d238" rel="noopener ugc nofollow">Tablelike Declarative Tests</a><br/>#1.2 <a class="ae kv" href="#fb6d" rel="noopener ugc nofollow">Custom Describes</a><br/>#1.3 <a class="ae kv" href="#d2d9" rel="noopener ugc nofollow">The </a><a class="ae kv" href="#d2d9" rel="noopener ugc nofollow">'</a><a class="ae kv" href="#d2d9" rel="noopener ugc nofollow">doTest</a><a class="ae kv" href="#d2d9" rel="noopener ugc nofollow">'</a><a class="ae kv" href="#d2d9" rel="noopener ugc nofollow"> Declarative Method</a><br/>#1.4 <a class="ae kv" href="#f011" rel="noopener ugc nofollow">Expressing Tests With DSLs</a><br/>#2. <a class="ae kv" href="#2114" rel="noopener ugc nofollow">Special Note About Code Reusage</a><br/>#3. <a class="ae kv" href="#6995" rel="noopener ugc nofollow">Benefits of the Declarative Approach</a><br/>#4. <a class="ae kv" href="#f01d" rel="noopener ugc nofollow">Summary and Conclusion</a></span></pre></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="d238" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">类似表格的声明性测试</h1><p id="0974" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让测试只是普通的函数调用，比如<code class="fe ls lt lu lv b">describe</code>和<code class="fe ls lt lu lv b">it</code>，通过动态调用<code class="fe ls lt lu lv b">it()</code>可以非常容易地重构有重复部分的测试。</p><p id="8e1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面举个例子:<code class="fe ls lt lu lv b">isWholeBlockSelected(content, selection):Boolean</code>函数给出<code class="fe ls lt lu lv b">true</code>如果选择了一个块的全文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="11c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">createState</code>已经有一些魔法，使用符号<code class="fe ls lt lu lv b">[&gt; ... &gt;]</code>来声明选择在哪里，但是我们将在后面讨论(在用DSL表达测试中)。</p><p id="a6b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的要点是，一旦我们理解了第一个<code class="fe ls lt lu lv b">it</code>，那么所有其他的都差不多了。很多内容只是垃圾重复代码。这里有一个过滤器来显示大脑是如何阅读的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/1658a20bd40464ef7ecd413bfa48e1f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W2ltVNE3F660wJasslQ7Gg.jpeg"/></div></div></figure><p id="b11f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">甚至连<code class="fe ls lt lu lv b">it</code>的描述都被眼睛忽略了。但是如果<code class="fe ls lt lu lv b">it</code>只是一个普通的电话，我们可以做得更好。那么我们可以做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8abf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以忽略复杂的<code class="fe ls lt lu lv b">forEach</code>部分，只专注于根据场景/输入+预期输出来分析所有情况。测试<code class="fe ls lt lu lv b">title</code>变得毫无用处，实际上比仅仅阅读<code class="fe ls lt lu lv b">case</code>更难读懂。运行它们会产生以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/71d958bf62390477e0b0c1281589c4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAROqaWhDrztVDoSjeG9RA.png"/></div></div></figure><p id="03dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们甚至可以创建一个通用的<code class="fe ls lt lu lv b">testFunction</code>高阶函数来测试这样的函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9523" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样的测试变成了一组案例和期望。这并不新鲜— <a class="ae kv" href="http://fitnesse.org/FitNesse.UserGuide.WritingAcceptanceTests" rel="noopener ugc nofollow" target="_blank"> FitNess </a> e提出了一个类似的方法，尽管是在一个特定的工具和环境中，并且是在验收测试的思想中，将焦点放在不同的利益相关者和更高的业务视角上。我认为这种思想可以应用于任何单元测试，不需要任何特殊的工具。即使目标只是开发者。</p><p id="7f20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们刚刚做的是<em class="lw">声明式编程。</em>我们已经将测试的信息部分(什么)从创建和运行测试所需的机制和行为(如何)中分离出来。这是整篇文章的基本思想。我们将进一步探索它。</p><p id="4be4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我称它们为<em class="lw">类似表格的测试</em>，因为给定一个显式建模的框架，我们可以以表格的形式显示和编辑测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/d0b804c77e62820454b9b512a53b1b8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGaZ9J5qd9Tovvk7sNbUXA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重新思考多重命令这是一个基于案例的测试</p></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="fb6d" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">自定义描述</h1><p id="6927" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">重用代码(尤其是安装代码)的另一种方法是创建自己的描述块。我通常这样做来创建不同类型的测试，大部分与架构部分相关。例如，我们有<code class="fe ls lt lu lv b">describeMongoDB</code>来编写需要Mongo模拟设置的后端测试。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="95cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种类型的<code class="fe ls lt lu lv b">describe</code>为使用它来访问上下文的主体提供了有用的函数，在本例中是已配置的<code class="fe ls lt lu lv b">db</code>实例和<code class="fe ls lt lu lv b">mongoServer</code>。这里有一个使用<code class="fe ls lt lu lv b">describeMongoDB</code> <em class="lw">的示例测试。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a0ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我目前的项目中，我们有一些这样的定制<code class="fe ls lt lu lv b">describe</code>用于前端和后端。我们特别将它用于以某种方式集成架构的不同部分的测试，比如进行服务器调用的前端或需要DB的后端端点，等等。</p><p id="4ede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们有<code class="fe ls lt lu lv b">describeDB</code>用于DB模型测试，<code class="fe ls lt lu lv b">describeGQL</code>用于测试GraphQL查询/变异，<code class="fe ls lt lu lv b">describeAction</code>用于前端redux动作，等等。封装设置代码有利于测试维护。下面是创建自定义<code class="fe ls lt lu lv b">describe</code>的高阶函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们使用这段代码创建自定义的<code class="fe ls lt lu lv b">'</code>描述<code class="fe ls lt lu lv b">'</code>来保持<code class="fe ls lt lu lv b">'.only'</code>和<code class="fe ls lt lu lv b">'.skip'</code>的功能。</p></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="d2d9" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><code class="fe ls lt lu lv b">'</code> doTest <code class="fe ls lt lu lv b">'</code>声明方法</h1><p id="f1e4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这是我们最近每次测试的目标。这是一种类似于使用表格的方法，但是控制方式相反。</p><p id="d2e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们测试的任何一段代码总是涉及至少&gt; 1个案例，那么我们为什么要把每一个<code class="fe ls lt lu lv b">it</code>都看作是从头开始的一段代码呢？这听起来很自然，但这与我们在测试时(尤其是事后)遵循的心理流程有关:</p><ul class=""><li id="8c97" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">为一个初始的案例做一个测试:我们把步骤AAA想成一个过程:<em class="lw">首先，我将创建一个时钟。那么，我会设置一个闹钟。然后，等等，等等。哦，我需要上下文中的另一个东西。让我们加上那个步骤，等等。</em></li><li id="8292" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">然后，考虑新的情况:我们忘记之前的<code class="fe ls lt lu lv b">it</code>并从头开始第二次测试，因为<em class="lw">这次不同。更糟糕的是，我们开始复制和粘贴第一个测试的部分。</em></li></ul><p id="9f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不应该只是判断那种复制粘贴。即使我们知道复制和粘贴是不好的，这样做也有一个潜在的原因。</p><p id="7f27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所发生的是，我们试图快速地将我们的注意力集中在差异上，以便表达这些新的案例。我们不想在公共部分浪费时间——因为这就是测试的目的:考虑输入变化和预期输出。为这些步骤编写太多的程序代码会分散我们的注意力，很多时候我们会错过一些案例。</p><p id="b51a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以用另一个流程:</p><ol class=""><li id="1b9e" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr od nv nw nx bi translated">先做个测试。</li><li id="27ba" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">当要开始第二个测试时，回到第一个测试，想想不同之处。他们共享哪些部分？他们在每一部分都分享了哪些特定的app概念(分解每个AAA阶段的app语义)。</li><li id="6a90" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">记住这一点，将第一个测试体提取到一个<code class="fe ls lt lu lv b">doTest</code>函数中，这个函数现在将用于第一个函数。将其建模为给定的输入和预期的输出。把它变成绿色。</li><li id="d124" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr od nv nw nx bi translated">然后，回到您将要构建的第二个案例，使用<code class="fe ls lt lu lv b">doTest</code>编写它。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/0c08e6e6444b5c17eb24a3b181900b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oM44LqE9cT_3j-0aI1Ubig.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在左边，一些测试在混淆特定于测试的信息时复制命令性代码(黑色)。在右边，测试使用了一个<code class="fe ls lt lu lv b">'</code> doTest <code class="fe ls lt lu lv b">'</code>函数来重用代码和清理每个案例。</p></figure><p id="5c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个重构的例子。我们对一个纯函数和一个叫做<code class="fe ls lt lu lv b">project</code>的redux reducer进行了一系列测试。我们正在测试它对特定动作的行为，<code class="fe ls lt lu lv b">receiveChangeSet</code>。</p><p id="3736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe ls lt lu lv b">ChangeSet</code>就像是对数据对象的一个<code class="fe ls lt lu lv b">commit</code>操作。这是分布式体系结构的一部分—前端接收另一个用户所做的更改，并更新这些对象的本地副本。所以我们有了包含新对象、对象和对象的。</p><p id="4cc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们一个接一个地按程序编写测试，我们将会得到许多这样的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="461b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们通过有用的信息过滤内容，我们会看到…这是眼睛最终需要努力去做的，当这样做时，有时它会错过一些小的差异。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/b74a184865c885ca562a3da7f8981cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FX-WHvfAiLIqpdlXAm6tsw.jpeg"/></div></div></figure><p id="edc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>我会在最后一节讲类似下面这样的断言。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7fbaffc93d09a3cd29ecced4429909b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*feMe1L062rZ3fr27bb1kmg.png"/></div></figure><p id="6368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，每次测试的变化是:</p><ul class=""><li id="c36d" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">存储中的初始对象是什么(上下文)</li><li id="f9d0" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">我们正在处理哪些变化(输入)</li><li id="df46" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">在应用那些改变(输出)之后，系统中对象的期望输出状态是什么</li></ul><p id="f3ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以为这些特殊情况考虑一个<code class="fe ls lt lu lv b">doTest</code>函数。这是重构后的版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7ebc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个小截屏，展示了如何使用<code class="fe ls lt lu lv b">doTest</code>重构其中一个。相当简单！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/175f1481884dd27c26c7ed2d2dcc0bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*W1ntQTYiqLKkteLygSd2_w.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">重构一个测试用例来使用一个<code class="fe ls lt lu lv b">'</code> doTest <code class="fe ls lt lu lv b">'</code>函数</p></figure></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f011" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">用DSL表达测试</h1><p id="f955" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">假设到目前为止，主要思想是通过用数据而不是过程代码来表达测试，从而使测试具有声明性。我们将上下文、输入和预期输出声明为数据。这适用于表样测试和<code class="fe ls lt lu lv b">doTest</code>样式。</p><p id="2275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于此，我们发现在某些领域，表达这些输入或输出可能非常困难。它可能包含大量代码，这会损害测试的可读性。(声明性的全部意义在于尽可能提高测试的可读性，正如<a class="ae kv" href="https://infovis-wiki.net/wiki/Data-Ink_Ratio" rel="noopener ugc nofollow" target="_blank">爱德华·塔夫特的数据-墨水比率</a>应用于编码时一样。)</p><p id="7aea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看一些真实的例子。</p><h2 id="6f71" class="mb mc iq bd mp oi oj dn mt ok ol dp mx lf om on mz lj oo op nb ln oq or nd os bi translated"><strong class="ak">例1:一个富文本编辑器选择和实体DSL </strong></h2><p id="f51f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">第一个例子测试了<code class="fe ls lt lu lv b">isWithinEntityMatch</code>函数，它给出了DraftJS文本编辑器的内容，告诉我们当前的选择是否在给定的实体内。</p><p id="6e9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://draftjs.org/" rel="noopener ugc nofollow" target="_blank"> DraftJS </a>是一个在React中构建富文本编辑器的框架。我们用它来做游戏对话。在这种情况下，<em class="lw">实体</em>就是我们所说的<em class="lw">标记，</em>就像对话中的内联注释，由花括号<code class="fe ls lt lu lv b">{MOVE_CAMERA ... }</code>分隔。这是它在用户界面上的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/3b50de0660b1dfff6c7f7a18a05c049c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QUhlX9C_VL04kSY6JVowQ.png"/></div></div></figure><p id="62e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是这个文本实际上是一个非常复杂的DraftJS模型对象，涉及到特定于ImmutableJS和DraftJS的模型。因此，我们需要改进创建这些输入或上下文的方式，使它们具有声明性和可读性。我们可以使用util函数、工厂、构建器，最后，创建一种特定于领域的语言(DSL)来满足我们的特定需求。</p><p id="d5f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们想出了这个类似表格的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="954f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该文本实际上是一个非常小的内部DSL，仅使用常规字符串和符号约定:</p><ul class=""><li id="4b85" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">... {something} …</code>:实体的花括号(与用户类型相同)</li><li id="6fb3" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[|]</code>:表示用户光标位于该特定位置(折叠选择)</li><li id="1b87" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[&gt;</code>...<code class="fe ls lt lu lv b">&gt;]</code>:声明一个<em class="lw">扩展的</em>选择。也就是说，其中的内容当前是从左到右选择的。根据定义，光标位于右侧。</li><li id="5825" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><code class="fe ls lt lu lv b">[&lt;</code> … <code class="fe ls lt lu lv b">&lt;]</code>:同上，但选择是从右向左，光标在左侧。(选择方向在文本编辑器中相当重要。)</li></ul><p id="d304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用DSL解析器可以在这里找到<code class="fe ls lt lu lv b">expectIsWithin</code>的impl。我没有内联它，因为它只是一个impl就有很多代码。但是看一看，想象一下如果每个测试用例都需要那么多代码来创建输入。这真的很难阅读和维护！</p><h2 id="9339" class="mb mc iq bd mp oi oj dn mt ok ol dp mx lf om on mz lj oo op nb ln oq or nd os bi translated"><strong class="ak">例子2:撤销/重做逻辑</strong></h2><p id="b0f3" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">另一个真实的例子:计算应用程序的撤销-重做堆栈的函数。这是一个纯粹的函数，一个<em class="lw">重选选择器。</em>这是一个函数，在给定(redux)应用程序状态的情况下，它导出一些数据。</p><p id="6d07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，状态有一个已完成更改的列表。变化可能是:</p><ul class=""><li id="9e87" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated"><strong class="ky ir">有规律的变化</strong>:例如<code class="fe ls lt lu lv b">A</code>(我们为了测试可读性而指定名称)</li><li id="c8fa" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><strong class="ky ir">撤销</strong>:恢复变更。我们使用符号<code class="fe ls lt lu lv b">U(A)</code>。</li><li id="8de7" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated"><strong class="ky ir">重做</strong>:重做变更。我们用<code class="fe ls lt lu lv b">R(A)</code>。</li></ul><p id="7df4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与DraftJS示例相同，当考虑测试时，这些概念之间有很大的距离——比如<em class="lw">让我们测试变更A、B、C；撤消C和B；看看光标在哪里— </em>我们实际上需要编码什么来创建这个场景。</p><p id="3a44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">表达输入/上下文将涉及大量代码。因此，我们再次创建了一个小型的、内部的、基于字符串的DSL，以便能够用非常紧凑的语法来表达案例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/ff9a8cb51746ebd8682c4cd22f87aa3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdZ7VdepOBPocrMgrFjHxw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于构建复杂输入对象的测试表和DSL。数组中的每个字符串都是一个测试用例，用一个小而简单的DSL符号来表示。</p></figure><p id="89d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，我们最后只是抄写了我们在白板上使用的相同符号来调查问题并提出解决方案。</p><p id="f8af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是这样写的:</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="34eb" class="mb mc iq lv b gy md me l mf mg">// [latest_change    ←   first_change]   =&gt; expected_stack</span><span id="09e4" class="mb mc iq lv b gy ov me l mf mg">[ R(B), U(B), U(C), C, B, A ]            =&gt; [C, (B), A]</span></pre><p id="cdbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户做了一个变更，<code class="fe ls lt lu lv b">A</code>，接着是变更<code class="fe ls lt lu lv b">B</code>和<code class="fe ls lt lu lv b">C</code>。然后他们解开了<code class="fe ls lt lu lv b">C</code>和<code class="fe ls lt lu lv b">B</code>，但紧接着，他们又重做了<code class="fe ls lt lu lv b">B</code>。那么我们在哪里？</p><pre class="kg kh ki kj gt lx lv ly lz aw ma bi"><span id="c6c0" class="mb mc iq lv b gy md me l mf mg">[C, (B), A]</span></pre><p id="958e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着<code class="fe ls lt lu lv b">A</code>被应用，C没有(已经撤销)，我们目前在<code class="fe ls lt lu lv b">B</code>(也应用)。从这一点，我们可以撤销<code class="fe ls lt lu lv b">A</code>或重做<code class="fe ls lt lu lv b">C</code></p><p id="38b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个输入以及预期的输出都被表示为一个字符串DSL，但是底层模型包含复杂的数据结构，这使得测试难以阅读。</p><p id="37d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://gist.github.com/javierfernandes/34186422ba8a444d1bee4f4deba092f8" rel="noopener ugc nofollow" target="_blank">这里的</a>是<code class="fe ls lt lu lv b">parseInput</code>的impl，而后者又有自己的测试。因此，为了进行更好的测试，我们必须创建一种语言，一个解析器(尽管这很简单)，并为该解析器进行测试。想象一下，如果使用测试工具就能更容易地做到这一点，那该有多好？</p><p id="cc9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DSL允许我们去掉许多样板代码，只提取对测试有意义的部分。这样更容易思考漏例、冗余例等。尤其是其他人。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="2114" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">关于代码重用的特别说明</h1><p id="d349" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们可以认为我们在所有这些例子中所做的是在测试之间重用代码。但是<em class="lw">单独重用代码</em>并不是一个好的经验法则——它应该受到测试体验如何结束的约束。</p><p id="f6b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时重用代码有降低测试代码可读性的缺点。我们不想在测试中出现这种情况。</p><p id="02c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现有两种情况会发生这种情况:</p><h2 id="03b1" class="mb mc iq bd mp oi oj dn mt ok ol dp mx lf om on mz lj oo op nb ln oq or nd os bi translated"><strong class="ak">断言</strong></h2><p id="af9d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">正如我们在<code class="fe ls lt lu lv b">receiveChangeSet</code>示例中看到的，断言试图通过重用来自上下文和输入的数据来避免代码重复。</p><p id="fa24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是例子——已经用<code class="fe ls lt lu lv b">doTest</code>缩短了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f239" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常好，而且避免了重复代码。但是它仍然牺牲了测试的可读性。最后，我发现牺牲重复更好。它让作者以外的人更容易阅读。如果我们真的想避免重复，我们可以通过使重用众所周知的输入而不是测试本身变得更容易来做到这一点。像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="72a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们在从测试中提取信息时要小心，以避免下一个问题。</p><h2 id="4a56" class="mb mc iq bd mp oi oj dn mt ok ol dp mx lf om on mz lj oo op nb ln oq or nd os bi translated"><strong class="ak">重复使用输入和输出</strong></h2><p id="6140" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我发现的另一个反模式是以这样一种方式重用测试输入和域对象，使得以后阅读代码变得非常困难。</p><p id="d0bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以这个例子为例，一个测试首先声明了许多在测试用例之间重用的对象。域名并不重要。也是选择者的考验。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/deb945527324e6d8a22ffb8d0ed45c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA-k2Sb2AGQu9E8oA36bTw.png"/></div></div></figure><p id="0f48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我只看了<code class="fe ls lt lu lv b">it</code>，我真的无法理解它应该测试什么。</p><p id="0835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解它，眼睛需要频繁地在<code class="fe ls lt lu lv b">it</code>和文件顶部的对象之间跳跃。此外，如果一些对象只被一些测试使用而不被其他测试使用，那么一次读取所有对象可能没有任何意义。测试遗漏了最重要的信息片段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/e28f19f8a1a255b462699cc813204743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*bDoTxkYsyrKDLdvfZMMglQ.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在失去测试语义的情况下重用代码增加了读者的认知负荷。眼睛需要在测试代码和重用代码之间来回跳跃。</p></figure><p id="9078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与我们在前面章节中看到的相反。测试复制了命令性代码，同时提取了声明性数据。</p><p id="5021" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的结论是，我们应该在测试之间重用的最重要的部分是那些必要的部分(测试的<em class="lw"> how </em>)，而不是输入/输出定义(测试的<em class="lw"> what </em>)。否则，它们就失去了明确的意义。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="6995" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">声明式方法的好处</h1><p id="c26b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">设计声明性表达测试:</p><ul class=""><li id="87ad" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">可读性更高</li><li id="1b80" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">改善维护</li><li id="ba0b" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">提供一个更好的过程来整理你的思维。(先做祈使句测试。然后，根据输入、它们的作用和你的期望，概括出第二种情况的函数。)还要花点时间思考不同的场景，以及如何用这个测试的语言表达出来。</li><li id="a976" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">充分利用代码审查的价值:审查一大组有许多命令性和/或重复代码的测试需要额外的脑力劳动，而不仅仅是考虑测试覆盖范围(就LOC中可能没有的场景而言)。这种方法完全减少了这种工作，允许评审者关注缺失的案例，以及当前的场景和期望从领域的角度来看是否有意义。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f01d" class="mo mc iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">总结和结论</h1><p id="b368" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这并不新鲜:好的测试需要努力——和我们花在核心逻辑上的努力一样。仅仅使用AAA测试模型不足以写出好的测试。我们应该探索，作为开发人员，我们在这些阶段中做什么，在测试和我们的整个软件开发过程中识别模式和它们的结果。</p><p id="bac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和许多其他问题一样，声明性是我们处理这类编程问题的最强大的元模式。</p><p id="92b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在编写测试时，测试维护依赖于两种实践。你可以跟着他们:</p><ul class=""><li id="28e2" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">编写声明性测试</li><li id="72de" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">不要通过将声明排除在测试之外来省略它们(或者在其他文件中，或者在同一个文件中，但是向上/向下——避免阅读时眼睛跳跃的需要)。而是寻找最短最具表现力的方式来表达它们。不多不少。这几乎是爱德华·塔夫特应用于测试的数据-墨水比率。</li><li id="7689" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">为每组测试创建一种语言(广义上的)。它可以是一个表，一个<code class="fe ls lt lu lv b">doTest</code>函数，甚至是一个DSL。将“什么”和“如何”分开。</li></ul><p id="6dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你写测试时，你不是在为代码写测试——你现在正在测试！你应该为读者编写测试。测试必须有同理心。</p><p id="f0f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我期待着新的工具和框架，将这些和许多其他想法纳入其核心。测试不应该这么难——我们可以做得更好。有很多值得探索的地方！</p></div></div>    
</body>
</html>