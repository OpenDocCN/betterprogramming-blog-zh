<html>
<head>
<title>Effortless Render Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松的渲染优化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/effortless-render-optimization-9b765ea78113?source=collection_archive---------6-----------------------#2019-07-21">https://betterprogramming.pub/effortless-render-optimization-9b765ea78113?source=collection_archive---------6-----------------------#2019-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a0ec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">尝试react-tracked和reactive-react-redux，用react挂钩跟踪状态使用情况</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f11a7c2a244cb7a71f85c7efe8fb9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ADYUoaaeFTbIECb_cJ6Org.png"/></div></div></figure><h1 id="f0da" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="fb0c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">React <code class="fe mi mj mk ml b">useContext</code>可以非常方便地避免支柱钻孔。它可用于定义树中多个组件可以访问的全局或共享状态。</p><p id="d3cd" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">然而，<code class="fe mi mj mk ml b">useContext</code>并不是专门为全局状态设计的，这里有一个警告:对上下文值的任何更改都会传播所有的<code class="fe mi mj mk ml b">useContext</code>来重新呈现组件。</p><p id="042b" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这篇文章展示了一些关于状态使用跟踪的问题和解决方案的示例代码。</p><h1 id="4280" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">问题</h1><p id="8a63" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们假设一个人对象是一个状态:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="4c8d" class="mv kv it ml b gy mw mx l my mz">const initialState = {<br/>  firstName: 'Harry',<br/>  familyName: 'Potter',<br/>};</span></pre><p id="1cfe" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">我们使用上下文和本地状态:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="ee0c" class="mv kv it ml b gy mw mx l my mz">const PersonContext = createContext(null);</span><span id="4103" class="mv kv it ml b gy na mx l my mz">const PersonProvider = ({ children }) =&gt; {<br/>  const [person, setPerson] = useState(initialState);<br/>  return (<br/>    &lt;PersonContext.Provider value={[person, setPerson]}&gt;<br/>      {children}<br/>    &lt;/PersonContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="7ba7" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">最后，这里有一个组件显示这个人的名字:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="22c6" class="mv kv it ml b gy mw mx l my mz">const DisplayFirstName = () =&gt; {<br/>  const [person] = useContext(PersonContext);<br/>  return (<br/>    &lt;div&gt;First Name: {person.firstName}&lt;/div&gt;<br/>  );<br/>};</span></pre><p id="ca88" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">到目前为止，一切顺利。但是，当您更新此人的姓氏并保持其名字不变时，问题就出现了。会触发<code class="fe mi mj mk ml b">DisplayFirstName</code>重新渲染，即使渲染结果是一样的。</p><p id="69dd" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">请注意，这并不是真正的问题，直到<em class="nb">变成</em>问题。通常情况下，大多数较小的应用程序都可以工作，但一些较大的应用程序可能会有性能问题。</p><h1 id="6b4a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">解决方案:状态使用跟踪</h1><p id="a62c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们看看状态使用跟踪是如何解决这个问题的。</p><p id="62da" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">提供商看起来只是略有不同:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="b7b5" class="mv kv it ml b gy mw mx l my mz">const usePerson = () =&gt; useState(initialState);<br/>const { Provider, useTracked } = createContainer(usePerson);</span><span id="9ace" class="mv kv it ml b gy na mx l my mz">const PersonProvider = ({ children }) =&gt; (<br/>  &lt;Provider&gt;<br/>    {children}<br/>  &lt;/Provider&gt;<br/>);</span></pre><p id="91ed" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated"><code class="fe mi mj mk ml b">DisplayFirstName</code>组件将被更改如下:</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="f2b9" class="mv kv it ml b gy mw mx l my mz">const DisplayFirstName = () =&gt; {<br/>  const [person] = useTracked();<br/>  return (<br/>    &lt;div&gt;First Name: {person.firstName}&lt;/div&gt;<br/>  );<br/>};</span></pre><p id="25e9" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">注意到变化了吗？唯一不同的是<code class="fe mi mj mk ml b">useTracked()</code>而不是<code class="fe mi mj mk ml b">useContext(...)</code>。</p><p id="8306" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">通过这个小小的改变，可以跟踪<code class="fe mi mj mk ml b">DisplayFirstName</code>中的状态使用。即使更新了姓氏，只要名字没有更新，该组件也不会重新呈现。</p><p id="878f" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这是毫不费力的渲染优化。</p><h1 id="6296" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">高级示例</h1><p id="f8ff" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">一些读者可能认为这也可以通过类似于T8的钩子来实现。</p><p id="48ba" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这里还有一个例子，其中<code class="fe mi mj mk ml b">useTracked</code>要简单得多。</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="a79b" class="mv kv it ml b gy mw mx l my mz">const initialState = {<br/>  firstName: 'Harry',<br/>  familyName: 'Potter',<br/>  showFullName: false,<br/>};</span></pre><p id="f555" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">假设我们有一个像上面这样的状态。让我们创建一个带有条件的组件。</p><pre class="kj kk kl km gt mr ml ms mt aw mu bi"><span id="b380" class="mv kv it ml b gy mw mx l my mz">const DisplayPersonName = () =&gt; {<br/>  const [person] = useTracked();<br/>  return (<br/>    &lt;div&gt;<br/>      {person.showFullName ? (<br/>        &lt;span&gt;<br/>          Full Name: {person.firstName}<br/>          &lt;Divider /&gt;<br/>          {person.familyName}<br/>        &lt;/span&gt;<br/>      ) : (<br/>        &lt;span&gt;First Name: {person.firstName}&lt;/span&gt;<br/>      )}<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="0d00" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">该组件将在两种情况下重新呈现。</p><ul class=""><li id="d977" class="nc nd it lo b lp mm ls mn lv ne lz nf md ng mh nh ni nj nk bi translated">a)当<code class="fe mi mj mk ml b">firstName</code>或<code class="fe mi mj mk ml b">familyName</code>更新时，如果显示全名</li><li id="c133" class="nc nd it lo b lp nl ls nm lv nn lz no md np mh nh ni nj nk bi translated">b)当<code class="fe mi mj mk ml b">firstName</code>更新时，如果没有显示全名</li></ul><p id="4c82" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">用<code class="fe mi mj mk ml b">useSelector</code>重现同样的行为并不容易，很可能以分离组件而告终。</p><h1 id="f9c3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用状态使用跟踪的项目</h1><p id="0973" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有两个项目使用状态使用跟踪。</p><h2 id="76db" class="mv kv it bd kw nq nr dn la ns nt dp le lv nu nv lg lz nw nx li md ny nz lk oa bi translated"><strong class="ak">反应-反应-还原</strong></h2><div class="ob oc gp gr od oe"><a href="https://github.com/dai-shi/reactive-react-redux" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">代时/反应-反应-还原</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">用React钩子和代理绑定React Redux。通过创造一个新的环境，为dai-shi/reactive-react-redux的发展做出贡献</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="oo l op oq or on os ks oe"/></div></div></a></div><p id="6ba4" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这是react-redux的替代库。它有相同的钩子API和<code class="fe mi mj mk ml b">useTrackedState</code>钩子。</p><h2 id="d4fd" class="mv kv it bd kw nq nr dn la ns nt dp le lv nu nv lg lz nw nx li md ny nz lk oa bi translated"><strong class="ak">反应追踪</strong></h2><div class="ob oc gp gr od oe"><a href="https://github.com/dai-shi/react-tracked" rel="noopener  ugc nofollow" target="_blank"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd iu gy z fp oj fr fs ok fu fw is bi translated">戴式/反应跟踪式</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">超快速反应全局/共享状态与上下文和钩子-戴-施/反应-跟踪</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">github.com</p></div></div><div class="on l"><div class="ot l op oq or on os ks oe"/></div></div></a></div><p id="f83a" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">这是一个没有Redux依赖的库。本帖中的例子就是基于此。它有一个与reactive-react-redux兼容的hooks API。</p><h1 id="b302" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结束语</h1><p id="f2e0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这篇文章关注的是如何轻松使用状态使用跟踪。我们没有讨论这些库的实现。</p><p id="7f0e" class="pw-post-body-paragraph lm ln it lo b lp mm ju lr ls mn jx lu lv mo lx ly lz mp mb mc md mq mf mg mh im bi translated">从技术上讲，有两个障碍。简而言之，我们使用代理API来跟踪状态使用情况，并在上下文API中使用一个未记录的特性来停止传播。如果您对这些内部内容感兴趣，请查看GitHub资源库。</p></div></div>    
</body>
</html>