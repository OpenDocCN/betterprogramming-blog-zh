<html>
<head>
<title>Mastering Remix Forms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握混音形式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mastering-remix-forms-615cab9a274d?source=collection_archive---------9-----------------------#2022-04-19">https://betterprogramming.pub/mastering-remix-forms-615cab9a274d?source=collection_archive---------9-----------------------#2022-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="25b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看关键的混音功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84e09ce2fcfcded024f16fb9d08af525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6vwulKOjED2pS00Mu1moYQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a71e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Remix已经迅速成为我最喜欢的React JavaScript框架之一。为什么？它包含了众所周知的已建立的web APIs及其渐进增强方法。</p><p id="2a6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开箱即用，Remix确实执行服务器端渲染。因此，当JavaScript不可用时，我们的用户不会看到空白页面。他们将获得相同的HTML页面，但与原始的HTML体验。页面不会被水合，因为没有JavaScript将被执行。</p><p id="acee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最大的问题是。那么Remix如何处理表单呢？通过使用支持良好的浏览器HTML表单功能作为基础。只有用户启用了JavaScript，它才会进一步增强用户体验。</p><p id="53f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这在实践中是如何运作的？在这篇文章中，我们将看看这个可怕的和聪明的功能。我们不仅向客户交付更少的代码，还支持更广泛的设备。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7ed3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">基础知识</h1><p id="902a" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">如前所述，Remix包含了默认的HTML表单特性。规范很简单，它只是一个发送到服务器的包含用户表单数据的<code class="fe my mz na nb b">post</code>请求。</p><p id="53d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它有两种味道:</p><ul class=""><li id="a5f9" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><strong class="la iu">启用JavaScript时— </strong>通信将通过<code class="fe my mz na nb b">AJAX</code>进行。表单提交通过<code class="fe my mz na nb b">event.preventDefault()</code>方法被禁用。然后对表单进行序列化并提交。然后将结果数据返回给客户端。仍然可以执行类似<code class="fe my mz na nb b">redirect</code>的操作。</li><li id="8e55" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><strong class="la iu">当JavaScript被禁用时— </strong>它将执行传统的<code class="fe my mz na nb b">POST</code>请求。响应将是React服务器呈现的HTML。</li></ul><p id="cc42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">混音将如何处理表单提交？我们需要在表单<code class="fe my mz na nb b">root</code>页面上公开一个<code class="fe my mz na nb b">action</code>函数。</p><p id="606f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么这个函数需要调用<code class="fe my mz na nb b">action</code>？进一步包含HTML表单特性，并匹配它的<code class="fe my mz na nb b">action</code>参数。</p><pre class="kj kk kl km gt nq nb nr ns aw nt bi"><span id="a44a" class="nu mc it nb b gy nv nw l nx ny">&lt;form <strong class="nb iu">action="/books"</strong>&gt;</span></pre><p id="525c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在哪里举办这个？我们可以在边缘上托管它，并根据需要将操作委派到任何地方。我们如何获得用户提交的信息？通过包含在<code class="fe my mz na nb b"><a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/API/Request" rel="noopener ugc nofollow" target="_blank">request</a></code>对象中的<code class="fe my mz na nb b"><a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/formData" rel="noopener ugc nofollow" target="_blank">formData</a></code>对象。这些也符合网络规范🚀。</p><p id="a2d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个微不足道的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="42bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，<code class="fe my mz na nb b">action</code>命名函数是从<code class="fe my mz na nb b">Book.js</code>页面导出的。表单处理程序需要总是放在页面根文件中。表单需要始终与页面相关联，否则，它将无法访问。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="184e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">表单组件</h1><p id="433d" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">Remix团队确实提供了他们自己的声明性<code class="fe my mz na nb b">Form</code>抽象。</p><h2 id="3967" class="nu mc it bd md oc od dn mh oe of dp ml lh og oh mn ll oi oj mp lp ok ol mr om bi translated">关于它的行为:</h2><ul class=""><li id="01a8" class="nc nd it la b lb mt le mu lh on ll oo lp op lt nh ni nj nk bi translated">提交<code class="fe my mz na nb b">&lt;Form &gt;</code>后，所有加载器将被重新加载。</li><li id="50d3" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">它序列化表单元素。</li><li id="0a74" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">它通过<code class="fe my mz na nb b">useTransition</code>钩子提供一些状态反馈。</li></ul><h2 id="a00f" class="nu mc it bd md oc od dn mh oe of dp ml lh og oh mn ll oi oj mp lp ok ol mr om bi translated">属性</h2><ul class=""><li id="d920" class="nc nd it la b lb mt le mu lh on ll oo lp op lt nh ni nj nk bi translated"><strong class="la iu">动作:</strong>表单将被提交到的位置。这在大多数情况下可以省略，因为我们将使用相同的渲染页面作为目标。当匹配多个路由时，将只使用最深的匹配路由。我们可以使用<code class="fe my mz na nb b">index</code>参数发布到索引路径。</li></ul><pre class="kj kk kl km gt nq nb nr ns aw nt bi"><span id="fcb7" class="nu mc it nb b gy nv nw l nx ny"><strong class="nb iu">url -&gt; route action<br/>                <br/></strong>/accounts?index  -&gt; routes/accounts/index.js<br/>/accounts -&gt; <!-- -->routes/accounts.js</span></pre><ul class=""><li id="3959" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe my mz na nb b"><strong class="la iu">method</strong></code> <strong class="la iu"> : </strong>它决定了要使用的HTTP动词:<code class="fe my mz na nb b">get</code>、<code class="fe my mz na nb b">post</code>、<code class="fe my mz na nb b">put</code>、<code class="fe my mz na nb b">patch</code>、<code class="fe my mz na nb b">delete</code>。默认值为<code class="fe my mz na nb b">get</code>。本地HTML表单仅支持⚠️的<code class="fe my mz na nb b">get</code>和<code class="fe my mz na nb b">post</code>。其他动词将打破非JavaScript方法。</li><li id="953f" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b"><strong class="la iu">encType</strong></code> <strong class="la iu"> : </strong>默认为<code class="fe my mz na nb b">application/x-www-form-urlencoded</code>。使用<code class="fe my mz na nb b">multipart/form-data</code>上传文件。</li><li id="577f" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b"><strong class="la iu">replace</strong></code> <strong class="la iu"> : </strong>告知浏览器替换历史堆栈中的当前条目。</li><li id="06a0" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated"><code class="fe my mz na nb b"><strong class="la iu">reloadDocument</strong></code> <strong class="la iu"> : </strong>即使启用了JavaScript，也会执行非JavaScript方法。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b104" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">错误处理</h1><p id="c668" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们之前已经讨论过一个简单的例子。它没有经过任何验证。表单验证将在哪里以及如何进行？</p><p id="8544" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于Remix确实支持<code class="fe my mz na nb b">AJAX</code>和<code class="fe my mz na nb b">Traditional Form Requests</code>，我们不能依赖客户端来执行这些验证。当JavaScript被禁用时，这是不可能的。无论如何，只依赖客户端验证是一种不好的做法。</p><p id="e0ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">混音拥抱愚蠢的前端风格。所有的处理和验证都将在服务器上进行。</p><p id="ef5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">客户端如何知道一个错误？作为一个好的实践，我们可以返回一个带有键<code class="fe my mz na nb b">errors</code>和所有错误细节的对象。</p><p id="05b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d387" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">React组件是如何知道的呢？使用<code class="fe my mz na nb b">useActionData</code>挂钩。这个钩子包含了由<code class="fe my mz na nb b">action</code>表单返回的信息。如果确实发生了任何错误，我们应该能够访问<code class="fe my mz na nb b">errors</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="46bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如基础部分所述，在非JavaScript方法中，返回的HTML页面会打印出错误。它将由服务器呈现。</p><p id="5d29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">验证工具呢？Remix团队通过开放扩展简化了这个过程。<code class="fe my mz na nb b">zod</code>和<code class="fe my mz na nb b">up</code>都有官方适配器。这是两个最著名的验证库。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="78e1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">表单挂钩API</h1><p id="4b52" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在上一节中，我们已经看到了如何使用<code class="fe my mz na nb b">useActionData</code>钩子从服务器获得响应。还有更多值得了解的hooks API。</p><ul class=""><li id="8712" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe my mz na nb b">useSubmit</code> —返回以编程方式提交表单的函数。该函数采用一个具有<code class="fe my mz na nb b">method</code>、<code class="fe my mz na nb b">action</code>、<code class="fe my mz na nb b">encType</code>或<code class="fe my mz na nb b">replace</code>属性的选项对象。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><ul class=""><li id="9a0e" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe my mz na nb b">useTransition</code> —它告诉我们需要了解的关于表单提交状态的所有信息。我们可以显示加载状态，禁用表单提交，乐观更新…等等。⚠️:重要的是不要把这个和<code class="fe my mz na nb b">React.useTransition</code>混淆。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><ul class=""><li id="341c" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated"><code class="fe my mz na nb b">useFormAction</code> —使用React路由器的相对路径解析<code class="fe my mz na nb b">&lt;form action&gt;</code>的名称。那什么时候有用？当按钮改变<code class="fe my mz na nb b">action</code>和<code class="fe my mz na nb b">method</code>的行为时。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="492f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">包裹</h1><p id="1a05" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在这篇文章中，我们已经看到了混音形式是多么强大和功能齐全。他们帮助我们快速起步。它们的API变得很直观，因为它们非常接近HTML web规范。这真的让人放心，因为他们没有试图提出自己的规格，而是拥抱现有的规格。</p><p id="fdd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们的渐进增强方法确实需要一点时间来适应。然而，我越用它，我就越喜欢它。</p><p id="3f9d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也不受节点工具的限制或约束。我们所需要的是一个支持<code class="fe my mz na nb b">fetch</code> API的边缘。这样更容易找到合适的地方举办。</p><p id="69e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯</p><div class="oq or gp gr os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/next-js-vs-remix-analyzing-key-aspects-and-differences-8674beaba695"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">Next.js vs. Remix:分析关键方面和差异</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">通过比较Remix和Next.js的最新版本，知道哪一个适合你</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">betterprogramming.pub</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>