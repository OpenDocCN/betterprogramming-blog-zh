<html>
<head>
<title>Understanding TypeScript Type Inference</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解TypeScript类型推理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-typescript-type-inference-4c25f9777e9e?source=collection_archive---------3-----------------------#2019-09-03">https://betterprogramming.pub/understanding-typescript-type-inference-4c25f9777e9e?source=collection_archive---------3-----------------------#2019-09-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="95d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过嵌套泛型和接口的恐怖的意想不到的旅程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea561030b9a13035dadd2d09b3bbcff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1LCqGS9vIzEUEilVF38aA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@evan__bray?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃文·丹尼斯</a>在<a class="ae ky" href="https://unsplash.com/search/photos/horror?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="b7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，Redux团队决定将项目转换成TypeScript。在Unlock的职位上使用了大量的打字稿后，我决定一头扎进去。</p><p id="d5a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于项目已经在它的<code class="fe lv lw lx ly b">index.d.ts</code>中有了重要的类型，大部分工作是配置和寻找聪明的方法来处理足够短的可审查的拉请求。</p><p id="df96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入野兽。<a class="ae ky" href="https://github.com/reduxjs/redux/issues/3482" rel="noopener ugc nofollow" target="_blank">问题#3482 </a>是一个开放的问题，有点像带有Redux存储增强器和<code class="fe lv lw lx ly b">replaceReducer</code>的edge-casey情况。</p><p id="d2b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长话短说，没有人看过它，所以我决定看看我是否能找到答案。很快，这让我掉进了兔子洞。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="32e1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">基本类型推理</h1><p id="dcc3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">TypeScript文档很好地介绍了基本类型推理，并提供了一些简单的边缘案例。阅读这篇文章，简单了解一下类型推断的基础知识。</p><p id="c173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将着眼于推理，因为它与函数参数和返回值有关。</p><p id="4890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有两个函数推理的基本例子。第一个推理出函数的返回值，第二个推理出接口定义的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这非常简单明了并且有意义。让我们更进一步！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e58d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">泛型推理</h1><p id="4aa3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">同样，<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">TypeScript文档</a>提供了对泛型的不错的介绍。他们提供了许多泛型的定义，并展示了它们的强大功能和灵活性。</p><p id="1ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，即使在多次读取之后，我还是错过了最强大的用法，那就是它们在不显式传入类型的情况下推断类型的能力。在通用约束中使用类型参数的<a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html#using-type-parameters-in-generic-constraints" rel="noopener ugc nofollow" target="_blank">一节中有一个这种用法的明确示例。</a></p><p id="cdee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一下这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c03d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种设计的绝妙之处在于，TypeScript编译器允许我们定义<code class="fe lv lw lx ly b">getProperty</code>,然后用任何类型的变量调用<code class="fe lv lw lx ly b">getProperty</code>,而无需显式传入类型。</p><p id="2844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我理解这一点之前，我一直认为只有一种方法可以使用泛型，那就是要么在调用时显式地传递类型，要么在定义中提供默认值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6ff8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">现实世界的例子</h1><p id="0787" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">那么，我们如何在现实世界的例子中使用它呢？</p><p id="953d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再说说<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。Redux定义了一个同步事件循环，用于以单向方式传播状态变化。这是一种很奇特的说法，当我们想要改变什么的时候，只有一个管道可以让东西进入。</p><p id="6adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它是同步的，所以我们需要一种方法来挂接像从远程API加载信息这样的事情。通常，那些使用Redux的人使用一种叫做<code class="fe lv lw lx ly b">middleware</code>的东西来做这件事，但是中间件是如何被修补到事件循环中的呢？</p><p id="3fe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，Redux提供了一种称为<code class="fe lv lw lx ly b">store enhancer</code>的机制。存储增强器非常强大，因为它可以操纵存储的任何方面并对其进行修改。</p><p id="bfe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从类型脚本的角度来看，我们需要考虑两种状态形状。存储本身的形状和由Redux事件循环修改的状态的形状。</p><p id="eab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redux存储有两个控制事件循环的函数:<code class="fe lv lw lx ly b">getState</code>和<code class="fe lv lw lx ly b">dispatch</code>。</p><p id="3f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态的实际修改由终端用户提供的<code class="fe lv lw lx ly b">reducer</code>函数处理。任何商店都允许用<code class="fe lv lw lx ly b">replaceReducer</code>在运行时改变缩减器，它只接受新的缩减器作为参数。</p><p id="d9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">dispatch</code>接受一个参数，称为<code class="fe lv lw lx ly b">action</code>，它是某种具有<code class="fe lv lw lx ly b">type</code>成员的对象，由<code class="fe lv lw lx ly b">reducer</code>用来决定如何路由动作和更新状态。</p><p id="be91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是上面所有以打字稿表示的散文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来分解一下:</p><ul class=""><li id="a857" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">一个<code class="fe lv lw lx ly b">Action</code>有一个<code class="fe lv lw lx ly b">type</code>和可能任意数量的其他属性。</li><li id="ec61" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">一个<code class="fe lv lw lx ly b">Reducer</code>接受预先存在的状态或<code class="fe lv lw lx ly b">undefined</code>和一个动作，并总是返回该状态。</li><li id="0085" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">Store</code>(在我们的简化视图中)有三个函数，<code class="fe lv lw lx ly b">getState</code>、<code class="fe lv lw lx ly b">dispatch</code>和<code class="fe lv lw lx ly b">replaceReducer</code>，它们作用于通用接口<code class="fe lv lw lx ly b">Store</code>中定义的状态和动作<code class="fe lv lw lx ly b">S</code>和<code class="fe lv lw lx ly b">A</code>。</li><li id="2fdd" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">StoreEnhancer</code>是接受存储创建函数作为参数并返回存储创建函数的函数。</li><li id="3d6c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">StoreEnhancerStoreCreator</code>函数接受一个<code class="fe lv lw lx ly b">reducer</code>和任何预定义的状态，并传递给该缩减器，然后创建一个<code class="fe lv lw lx ly b">Store</code>。</li></ul><p id="b521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跟我到目前为止？如果没有，不要烦恼，让我们继续，你可以随时回到上面的描述。此外…</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fff4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我刚才告诉你的那些东西里面都有虫子</h1><p id="8b4b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Magnus Helmersson指出的问题在你的商店增强器扩展它创建的商店时开始起作用。</p><p id="89a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，如果您创建一个修改存储或修改状态的存储增强器，这种变化不会传播到新的存储。</p><p id="e346" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">雪上加霜的是，打字稿给我们的错误是这首抽象的现代主义诗歌:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="4c10" class="nx mh it ly b gy ny nz l oa ob">Type '&lt;S, A extends Action&lt;any&gt; = AnyAction&gt;(reducer: Reducer&lt;S, A&gt;, preloadedState?: DeepPartial&lt;S&gt; | undefined) =&gt; { replaceReducer: (nextReducer: Reducer&lt;S, A&gt;) =&gt; void; dispatch: Dispatch&lt;A&gt;; getState(): S &amp; ExtraState; subscribe(listener: () =&gt; void): Unsubscribe; [Symbol.observable](): Observable&lt;...&gt;; }' is not assignable to type 'StoreEnhancerStoreCreator&lt;{}, ExtraState&gt;'.<br/>      Type '{ replaceReducer: (nextReducer: Reducer&lt;S, A&gt;) =&gt; void; dispatch: Dispatch&lt;A&gt;; getState(): S &amp; ExtraState; subscribe(listener: () =&gt; void): Unsubscribe; [Symbol.observable](): Observable&lt;S &amp; ExtraState&gt;; }' is not assignable to type 'Store&lt;S &amp; ExtraState, A&gt;'.<br/>        Types of property 'replaceReducer' are incompatible.<br/>          Type '(nextReducer: Reducer&lt;S, A&gt;) =&gt; void' is not assignable to type '(nextReducer: Reducer&lt;S &amp; ExtraState, A&gt;) =&gt; void'.<br/>            Types of parameters 'nextReducer' and 'nextReducer' are incompatible.<br/>              Types of parameters 'state' and 'state' are incompatible.<br/>                Type 'S | undefined' is not assignable to type '(S &amp; ExtraState) | undefined'.<br/>                  Type 'S' is not assignable to type '(S &amp; ExtraState) | undefined'.<br/>                    Type 'S' is not assignable to type 'S &amp; ExtraState'.<br/>                      Type 'S' is not assignable to type 'ExtraState'.</span></pre><p id="9581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢打字稿！</p><p id="1dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还好我是写诗的，所以知道怎么解析上面的艺术品，关键时刻是<code class="fe lv lw lx ly b">Type '(nextReducer: Reducer&lt;S, A&gt;) =&gt; void' is not assignable to type '(nextReducer: Reducer&lt;S &amp; ExtraState, A&gt;) =&gt; void'</code>。</p><p id="4022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是怎么回事？</p><p id="6643" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用存储增强器时，它增加了状态(<code class="fe lv lw lx ly b">S</code>)的定义，以包括存储增强器添加到状态(<code class="fe lv lw lx ly b">ExtraState</code>)的额外状态。</p><p id="2183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这工作很好，直到我们更换减速器。<code class="fe lv lw lx ly b">replaceReducer</code>的定义有两个问题。</p><p id="0862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，返回的<code class="fe lv lw lx ly b">Store</code>不知道任何关于从<code class="fe lv lw lx ly b">getState()</code>返回的状态的扩展或者存储增强器添加的存储的扩展。</p><p id="494c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很容易解决，我们只需要将这些值传递给所有创建的<code class="fe lv lw lx ly b">Store</code>类型，这样我们就可以在<code class="fe lv lw lx ly b">replaceReducer</code>中使用它们。另一个错误更微妙，但同样重要。</p><p id="88fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看到了吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="cba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">replaceReducer</code>通用模板类型<code class="fe lv lw lx ly b">NewState</code>和<code class="fe lv lw lx ly b">NewActions</code>的定义具有现有类型的默认值。</p><p id="112d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在热重装的正常情况下，我们用来替换现有减速器的减速器很可能与现有减速器具有相同的类型。然而，传递默认值有另一个副作用:它不再从传入的reducer中推断值。</p><p id="54fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题很微妙，因为在您实际编写存储增强器之前，不会出现任何类型错误，正如这个问题的注释所示:</p><div class="oc od gp gr oe of"><a href="https://github.com/reduxjs/redux/issues/3482#issuecomment-525302027" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">StoreEnhancer的TypeScript定义不允许使用replaceReducer问题进行状态扩展…</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">你想请求一个特性还是报告一个错误？StoreEnhancer类型脚本接口似乎没有…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div></div></a></div><p id="4a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，TypeScript给我们的错误是:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="7657" class="nx mh it ly b gy ny nz l oa ob">src/redux/store-enhancers/ext-enhancer.ts:25:66 - error TS2322: Type '&lt;S, A extends Action&lt;any&gt; = AnyAction&gt;(reducer: Reducer&lt;S, A&gt;, preloadedState?: PreloadedState&lt;S&gt;) =&gt; { replaceReducer: (nextReducer: Reducer&lt;S, A&gt;) =&gt; Store&lt;S &amp; ExtraState, A, ExtraState, {}&gt;; dispatch: Dispatch&lt;...&gt;; getState(): S &amp; ExtraState; subscribe(listener: () =&gt; void): Unsubscribe; [Symbol.observable](): O...' is not assignable to type 'StoreEnhancerStoreCreator&lt;{}, ExtraState&gt;'.<br/>  Type '{ replaceReducer: (nextReducer: Reducer&lt;S, A&gt;) =&gt; Store&lt;S &amp; ExtraState, A, ExtraState, {}&gt;; dispatch: Dispatch&lt;A&gt;; getState(): S &amp; ExtraState; subscribe(listener: () =&gt; void): Unsubscribe; [Symbol.observable](): Observable&lt;...&gt;; }' is not assignable to type 'Store&lt;S &amp; ExtraState, A, ExtraState, {}&gt;'.<br/>    Types of property 'replaceReducer' are incompatible.<br/>      Type '(nextReducer: Reducer&lt;S, A&gt;) =&gt; Store&lt;S &amp; ExtraState, A, ExtraState, {}&gt;' is not assignable to type '&lt;NewState = S &amp; ExtraState, NewActions extends A = A&gt;(nextReducer: Reducer&lt;NewState, NewActions&gt;) =&gt; Store&lt;NewState &amp; ExtraState, NewActions, ExtraState, {}&gt;'.<br/>        Types of parameters 'nextReducer' and 'nextReducer' are incompatible.<br/>          Types of parameters 'state' and 'state' are incompatible.<br/>            Type 'S' is not assignable to type 'NewState'.<br/>              'S' is assignable to the constraint of type 'NewState', but 'NewState' could be instantiated with a different subtype of constraint '{}'.</span></pre><p id="1338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说<code class="fe lv lw lx ly b">Type 'S' is not assignable to type 'NewState'</code>是什么意思？</p><p id="62cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，这意味着<code class="fe lv lw lx ly b">NewState</code>有可能与<code class="fe lv lw lx ly b">S</code>有完全不同的形状，尽管它可能是好的。</p><p id="9ffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为对这两种类型的唯一约束是它们扩展了<code class="fe lv lw lx ly b">{}</code>。</p><p id="5814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，<code class="fe lv lw lx ly b">S</code>可能是一个接口<code class="fe lv lw lx ly b">{ thing: 'this' }</code>，而<code class="fe lv lw lx ly b">NewState</code>可能是一个接口<code class="fe lv lw lx ly b">{ other: number }</code>，两者都满足<code class="fe lv lw lx ly b">{}</code>定义的收紧，但是任何一个<code class="fe lv lw lx ly b">S</code>的东西显然与<code class="fe lv lw lx ly b">NewState</code>不是同一个类型，就像<code class="fe lv lw lx ly b">const a: S = { thing: 'this' }</code>不同于<code class="fe lv lw lx ly b">const b: NewState = { other: 5 }</code>一样。</p><p id="fe5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的问题是假设<code class="fe lv lw lx ly b">NewState</code>应该有一个默认值。相反，我们需要删除缺省值，这样类型推理就开始起作用了，我们从传入的实际缩减器中提取出正确的值<code class="fe lv lw lx ly b">NewState</code>。</p><p id="768c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这些变化，我们得到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，存储增强器的扩展被传播到存储中，并且可以在传入新的缩减器时正确地重新应用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="64a3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包扎</h1><p id="35c7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">TypeScript的类型推断是最强大的功能，也是最难理解的功能之一。</p><p id="6443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们甚至还没有开始讨论关键字，你可以在官方文件中读到。然而，在大多数情况下，我发现基本的推理是我们所需要的。</p><p id="4579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我在心理上使用的小备忘单:</p><ol class=""><li id="8644" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu oo nl nm nn bi translated">常量直接推断它们的类型(<code class="fe lv lw lx ly b">const a = 1</code>有一个<code class="fe lv lw lx ly b">number</code>的类型)。</li><li id="8926" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oo nl nm nn bi translated">如果使用接口，函数的声明不需要声明它的类型，大概也不应该(允许类型推断生效)。</li><li id="6a08" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oo nl nm nn bi translated">可调用的东西(函数)可以通过多层泛型来推断类型。</li><li id="73fc" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu oo nl nm nn bi translated">接口不能进行类型推断，所有泛型模板变量必须有显式传入的值，或者设置默认值。</li></ol><p id="776c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="723b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参考</h1><ul class=""><li id="a2b9" class="nf ng it lb b lc my lf mz li op lm oq lq or lu nk nl nm nn bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/type-inference.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/type-inference . html</a></li><li id="aa97" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://www.typescriptlang.org/docs/handbook/generics.html#using-type-parameters-in-generic-constraints" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/generics . html # using-type-parameters-in-generic-constraint</a></li><li id="71fc" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">【https://github.com/reduxjs/redux/issues/3482 T4】</li><li id="5732" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">https://redux.js.org/</a></li></ul></div></div>    
</body>
</html>