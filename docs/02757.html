<html>
<head>
<title>Design Patterns: Null Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:空对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-patterns-null-object-5ee839e37892?source=collection_archive---------0-----------------------#2019-12-26">https://betterprogramming.pub/design-patterns-null-object-5ee839e37892?source=collection_archive---------0-----------------------#2019-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d128" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这种模式避免条件复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/84acf69d52ac9338d4e92fb5d4d3ee7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ge2Rif-VrVura-KnJsWwyA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托尔·阿尔维斯在<a class="ae ky" href="https://unsplash.com/s/photos/object?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="db24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有23种经典的设计模式，在原书《设计模式:可重用面向对象软件的元素》中有描述。这些模式为软件开发中经常重复出现的特定问题提供解决方案。</p><p id="4c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将描述什么是空对象模式，以及如何和何时应用它。这种模式并没有包含在经典的模式书中，但是它首次发表在“程序的模式语言”中，<em class="lv"> </em>和它的<em class="lv"> </em>被广泛使用以避免复杂性。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="cbad" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">基本想法</h1><blockquote class="mv mw mx"><p id="1dc5" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated"><em class="it">在面向对象的计算机编程中，</em> <strong class="lb iu"> <em class="it">空对象</em> </strong> <em class="it">是一个没有引用值或定义了中性(“空”)行为的对象。空对象设计模式描述了此类对象的用途及其行为(或缺乏行为)。</em>—维基百科</p></blockquote><p id="7957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式的主要特点是，它允许我们避免代码的复杂性。在大多数语言中，如Java、C#或JavaScript，引用可能为空。根据我们的业务逻辑，可能有必要在调用任何方法之前检查代码以确保它们不为空，因为方法通常不能在空引用上调用。</p><p id="5980" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，空对象模式允许我们通过使用对象而不是原始类型来避免条件复杂性。这种模式的UML图如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/7783f921e59f2780e8362052d3be4bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*yfylpRX0O2q4k0PP.png"/></div></figure><p id="4986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">AbstractObject</code>类是一个抽象类，它定义了必须在<code class="fe nc nd ne nf b">RealObject</code>和“空”或“默认”对象(<code class="fe nc nd ne nf b">NullObject</code>)中实现的不同操作。<code class="fe nc nd ne nf b">RealObject</code>将对每个真实对象进行操作，而<code class="fe nc nd ne nf b">NullObject</code>什么也不做，或者你可能想在这个对象中进行默认操作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="760a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">何时使用</h1><ol class=""><li id="12f4" class="ng nh it lb b lc ni lf nj li nk lm nl lq nm lu nn no np nq bi translated">您需要动态地、透明地向单个对象添加职责，也就是说，不影响其他对象。</li><li id="afd0" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">你需要加上随时可以收回的责任。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4743" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">优势</h1><p id="1e20" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">空对象模式有几个优点，总结如下:</p><ul class=""><li id="3a8e" class="ng nh it lb b lc ld lf lg li nz lm oa lq ob lu oc no np nq bi translated">它定义了由真实对象和空对象组成的类层次结构。</li><li id="1114" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu oc no np nq bi translated">当预期对象不做任何事情时，可以使用空对象来代替真实对象。</li><li id="23e5" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu oc no np nq bi translated">客户端代码更加简单，因为避免了条件复杂性。客户统一使用真实的和无效的合作者。</li></ul></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dacb" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">例子:赛亚人的世界(问题)</h1><p id="7190" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我现在将向您展示如何使用JavaScript/TypeScript实现这种模式。在应用该模式之前，意识到您试图解决的问题是很有趣的。接下来，我们将给出例子的上下文。</p><p id="51ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个名为<code class="fe nc nd ne nf b">Saiyan</code>的类，它将允许我们对我们亲爱的<code class="fe nc nd ne nf b">Saiyan</code>的属性和方法进行建模。这个类实现了一个<code class="fe nc nd ne nf b">ISaiyan</code>接口，该接口清楚地确定了每个对象成为真正的赛亚人所必须满足的特征。名为<code class="fe nc nd ne nf b">SaiyanFactory</code>的工厂用于创建赛亚人对象。这个类将我们从<code class="fe nc nd ne nf b">Saiyan</code>的来源中抽象出来，可以从RAM、数据库中的查询或制造新对象的复杂算法中生成。</p><p id="6ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，我们的问题出现在充当客户端并使用我们工厂的类中。在下面的客户端代码中，我们调用了<code class="fe nc nd ne nf b">getSaiyan</code>方法来获取几个<code class="fe nc nd ne nf b">Saiyan</code>。具体来说，我们创建了<code class="fe nc nd ne nf b">Vegeta</code>、<code class="fe nc nd ne nf b">Bob</code>、<code class="fe nc nd ne nf b">Son Goku</code>和<code class="fe nc nd ne nf b">Laura</code>。我理解读者都知道之前名单中唯一的赛亚人是<code class="fe nc nd ne nf b">Vegeta</code>和<code class="fe nc nd ne nf b">Son Goku</code>；因此<code class="fe nc nd ne nf b">Bob</code>和<code class="fe nc nd ne nf b">Laura</code>都不能制造为赛亚人类型的物体。</p><p id="1d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们总是必须检查工厂返回的对象不是空对象，因为我们不确定工厂是否总是返回<code class="fe nc nd ne nf b">Saiyan</code>类型的对象。</p><p id="0744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终代码具有不必要的条件复杂性，因为在找到的每个对象上都有重复的代码片段<code class="fe nc nd ne nf b">if-else</code>。我知道这个代码片段可以用一个函数抽象出来，但是它仍然在代码中。</p><p id="a292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们得到了下面的UML图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/358dbd080936010e9930ae4f5e5c15fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jP5UVnorQib13lnp.jpg"/></div></div></figure><p id="e508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我们将通过使用空对象模式来解决这个问题。</p><p id="cdb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关联的<code class="fe nc nd ne nf b">ISayian</code>和<code class="fe nc nd ne nf b">Saiyan</code>代码如下:</p><pre class="kj kk kl km gt oe nf of og aw oh bi"><span id="6561" class="oi me it nf b gy oj ok l ol om">export <strong class="nf iu">interface</strong> <strong class="nf iu">ISaiyan</strong> {<br/>  name: <strong class="nf iu">string</strong>;<br/>  power: number;<br/>}<br/>/****/</span><span id="6310" class="oi me it nf b gy on ok l ol om">import { ISaiyan } <strong class="nf iu">from</strong> './saiyan.interface';</span><span id="9c8f" class="oi me it nf b gy on ok l ol om">export <strong class="nf iu">class</strong> <strong class="nf iu">Saiyan</strong> {<br/>  <strong class="nf iu">protected</strong> name: <strong class="nf iu">string</strong>;<br/>  <strong class="nf iu">protected</strong> power: number;</span><span id="a1a3" class="oi me it nf b gy on ok l ol om">  constructor({ name, power }: ISaiyan) {<br/>    <strong class="nf iu">this</strong>.name = name;<br/>    <strong class="nf iu">this</strong>.power = power;<br/>  }<br/>  getName(): <strong class="nf iu">string</strong> {<br/>    <strong class="nf iu">return</strong> <strong class="nf iu">this</strong>.name;<br/>  }</span><span id="f664" class="oi me it nf b gy on ok l ol om">  <strong class="nf iu">public</strong> <strong class="nf iu">toString</strong>(): <strong class="nf iu">string</strong> {<br/>    <strong class="nf iu">return</strong> `${<strong class="nf iu">this</strong>.name} - ${<strong class="nf iu">this</strong>.power}`;<br/>  }<br/>}</span></pre><p id="7856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与作为数据库查找模拟的工厂相关联的代码如下:</p><pre class="kj kk kl km gt oe nf of og aw oh bi"><span id="1613" class="oi me it nf b gy oj ok l ol om">import { Saiyan } <strong class="nf iu">from</strong> './saiyan.class';</span><span id="6d5d" class="oi me it nf b gy on ok l ol om">export <strong class="nf iu">class</strong> <strong class="nf iu">SaiyanFactory</strong> {<br/>  <strong class="nf iu">public</strong> saiyans = [<br/>    { name: 'Son Goku', power: 1000 },<br/>    { name: 'Son Gohan', power: 800 },<br/>    { name: 'Vegeta', power: 950 },<br/>  ];</span><span id="9181" class="oi me it nf b gy on ok l ol om">  <strong class="nf iu">public</strong> <strong class="nf iu">getSaiyan</strong>(name: <strong class="nf iu">string</strong>): Saiyan | null {<br/>    // Mock Database find<br/>    <strong class="nf iu">for</strong> (<strong class="nf iu">const</strong> saiyan of <strong class="nf iu">this</strong>.saiyans) {<br/>      <strong class="nf iu">if</strong> (saiyan.name === name) {<br/>        <strong class="nf iu">return</strong> <strong class="nf iu">new</strong> Saiyan(saiyan);<br/>      }<br/>    }<br/>    <strong class="nf iu">return</strong> null;<br/>  }<br/>}</span></pre><p id="268e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，与客户端相关联的代码，其中由于来自工厂的空对象，条件复杂度是指数级的:</p><pre class="kj kk kl km gt oe nf of og aw oh bi"><span id="8951" class="oi me it nf b gy oj ok l ol om"><strong class="nf iu">import</strong> { SaiyanFactory } <strong class="nf iu">from</strong> './saiyan-factory.class';</span><span id="30e4" class="oi me it nf b gy on ok l ol om"><strong class="nf iu">const</strong> saiyanFactory = <strong class="nf iu">new</strong> SaiyanFactory();<br/><strong class="nf iu">const</strong> saiyan1 = saiyanFactory.getSaiyan('Vegeta');<br/><strong class="nf iu">const</strong> saiyan2 = saiyanFactory.getSaiyan('Bob');<br/><strong class="nf iu">const</strong> saiyan3 = saiyanFactory.getSaiyan('Son Goku');<br/><strong class="nf iu">const</strong> saiyan4 = saiyanFactory.getSaiyan('Laura');</span><span id="9981" class="oi me it nf b gy on ok l ol om"><strong class="nf iu">console</strong>.log('Saiyan');<br/><strong class="nf iu">if</strong> (saiyan1 !== null) {<br/>  <strong class="nf iu">console</strong>.log(saiyan1.toString());<br/>} <strong class="nf iu">else</strong> {<br/>  <strong class="nf iu">console</strong>.log('Not Available in Customer Database');<br/>}<br/><strong class="nf iu">if</strong> (saiyan2 !== null) {<br/>  <strong class="nf iu">console</strong>.log(saiyan2.toString());<br/>} <strong class="nf iu">else</strong> {<br/>  <strong class="nf iu">console</strong>.log('Not Available in Customer Database');<br/>}<br/><strong class="nf iu">if</strong> (saiyan3 !== null) {<br/>  <strong class="nf iu">console</strong>.log(saiyan3.toString());<br/>} <strong class="nf iu">else</strong> {<br/>  <strong class="nf iu">console</strong>.log('Not Available in Customer Database');<br/>}<br/><strong class="nf iu">if</strong> (saiyan4 !== null) {<br/>  <strong class="nf iu">console</strong>.log(saiyan4.toString());<br/>} <strong class="nf iu">else</strong> {<br/>  <strong class="nf iu">console</strong>.log('Not Available in Customer Database');<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="00e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">例子:赛亚人的世界(解)</h1><p id="b83b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">解决方案是使用空对象模式。使用这种模式的新UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/65428381c7a23d76f07fb68905ec3288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*auv763DGmL0NhCJG.jpg"/></div></div></figure><p id="25b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从应用模式后我们希望获得的结果开始。如果您遵守客户端代码，我们的赛亚人的四个请求所来自的工厂被保留。它们存储在变量中，所以这有助于我们避免在对每个Saiyan执行之前验证对象是否为空。在我们的例子中，我们使用<code class="fe nc nd ne nf b">toString</code>方法只是为了说明一个返回字符串的方法将要被排列。</p><p id="ac17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，由于我们内部类结构的一个小变化，我们已经消除了客户端的复杂性。该工厂不是只使用生成新赛亚人的赛亚人类，而是从这个赛亚人类创建一个简单的继承(刚性组合)，产生两个新类，<code class="fe nc nd ne nf b">RealSaiyan</code>和<code class="fe nc nd ne nf b">NullSaiyan</code>，将赛亚人类转换成一个抽象类。</p><p id="481e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Saiyan类现在定义了所有派生的Saiyan类必须实现的方法。知识库中找到的赛亚人的逻辑将在<code class="fe nc nd ne nf b">RealSaiyan</code>类中实现，而没有找到的对象的逻辑(空)或者甚至是默认行为(如果我们想要的话)将在<code class="fe nc nd ne nf b">NullSaiyan</code>类中实现。</p><p id="5185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，总会有一种行为，即使他们没有把客户从不适用的复杂性中解放出来。</p><p id="f408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在来看看实现这种模式所生成的代码:</p><pre class="kj kk kl km gt oe nf of og aw oh bi"><span id="75c0" class="oi me it nf b gy oj ok l ol om"><strong class="nf iu">import</strong> { SaiyanFactory } <strong class="nf iu">from</strong> './saiyan-factory.class';</span><span id="03c5" class="oi me it nf b gy on ok l ol om"><strong class="nf iu">const</strong> saiyanFactory = <strong class="nf iu">new</strong> SaiyanFactory();<br/><strong class="nf iu">const</strong> saiyan1 = saiyanFactory.getSaiyan('Vegeta');<br/><strong class="nf iu">const</strong> saiyan2 = saiyanFactory.getSaiyan('Bob');<br/><strong class="nf iu">const</strong> saiyan3 = saiyanFactory.getSaiyan('Son Goku');<br/><strong class="nf iu">const</strong> saiyan4 = saiyanFactory.getSaiyan('Laura');</span><span id="afd6" class="oi me it nf b gy on ok l ol om"><strong class="nf iu">console</strong>.log('Saiyan');<br/><strong class="nf iu">console</strong>.log(saiyan1.toString());<br/><strong class="nf iu">console</strong>.log(saiyan2.toString());<br/><strong class="nf iu">console</strong>.log(saiyan3.toString());<br/><strong class="nf iu">console</strong>.log(saiyan4.toString());</span></pre><p id="9650" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与工厂相关联的代码返回两种对象，如下所示:</p><pre class="kj kk kl km gt oe nf of og aw oh bi"><span id="f909" class="oi me it nf b gy oj ok l ol om"><strong class="nf iu">import</strong> { AbstractSaiyan } <strong class="nf iu">from</strong> './saiyan.class';<br/><strong class="nf iu">import</strong> { NullSaiyan } <strong class="nf iu">from</strong> './null-saiyan.class';<br/><strong class="nf iu">import</strong> { RealSaiyan } <strong class="nf iu">from</strong> './real-saiyan.class';</span><span id="58f7" class="oi me it nf b gy on ok l ol om"><strong class="nf iu">export</strong> <strong class="nf iu">class</strong> <strong class="nf iu">SaiyanFactory</strong> {<br/>  public saiyans = [<br/>    { name: 'Son Goku', power: 1000 },<br/>    { name: 'Son Gohan', power: 800 },<br/>    { name: 'Vegeta', power: 950 },<br/>  ];</span><span id="2598" class="oi me it nf b gy on ok l ol om">  public getSaiyan(name: string): AbstractSaiyan {<br/>    <strong class="nf iu">for</strong> (<strong class="nf iu">const</strong> saiyan <strong class="nf iu">of</strong> <strong class="nf iu">this</strong>.saiyans) {<br/>      <strong class="nf iu">if</strong> (saiyan.name === name) {<br/>        <strong class="nf iu">return</strong> <strong class="nf iu">new</strong> RealSaiyan(saiyan);<br/>      }<br/>    }<br/>    <strong class="nf iu">return</strong> <strong class="nf iu">new</strong> NullSaiyan();<br/>  }<br/>}</span></pre><p id="86e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe nc nd ne nf b">AbstractSaiyan</code>相关的代码如下:</p><pre class="kj kk kl km gt oe nf of og aw oh bi"><span id="0e52" class="oi me it nf b gy oj ok l ol om">export <strong class="nf iu">abstract</strong> <strong class="nf iu">class</strong> <strong class="nf iu">AbstractSaiyan</strong> {<br/>  <strong class="nf iu">protected</strong> name: <strong class="nf iu">string</strong>;<br/>  <strong class="nf iu">protected</strong> power: number;<br/>  <strong class="nf iu">public</strong> <strong class="nf iu">abstract</strong> <strong class="nf iu">getName</strong>(): <strong class="nf iu">string</strong>;<br/>  <strong class="nf iu">public</strong> <strong class="nf iu">abstract</strong> <strong class="nf iu">toString</strong>(): <strong class="nf iu">string</strong>;<br/>}</span></pre><p id="3347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，与每个具体类相关的代码如下:</p><pre class="kj kk kl km gt oe nf of og aw oh bi"><span id="50b6" class="oi me it nf b gy oj ok l ol om"><strong class="nf iu">import</strong> { AbstractSaiyan } <strong class="nf iu">from</strong> './saiyan.class';<br/><strong class="nf iu">import</strong> { Saiyan } <strong class="nf iu">from</strong> './saiyan.interface';</span><span id="5826" class="oi me it nf b gy on ok l ol om"><strong class="nf iu">export</strong> <strong class="nf iu">class</strong> <strong class="nf iu">RealSaiyan</strong> <strong class="nf iu">extends</strong> <strong class="nf iu">AbstractSaiyan</strong> {<br/>  <strong class="nf iu">constructor</strong>({ name, power }: Saiyan) {<br/>    <strong class="nf iu">super</strong>();<br/>    <strong class="nf iu">this</strong>.name = name;<br/>    <strong class="nf iu">this</strong>.power = power;<br/>  }</span><span id="5952" class="oi me it nf b gy on ok l ol om">  getName(): string {<br/>    <strong class="nf iu">return</strong> <strong class="nf iu">this</strong>.name;<br/>  }<br/>  toString(): string {<br/>    <strong class="nf iu">return</strong> `${<strong class="nf iu">this</strong>.name} - ${<strong class="nf iu">this</strong>.power}`;<br/>  }<br/>}</span><span id="1059" class="oi me it nf b gy on ok l ol om">import { AbstractSaiyan } <strong class="nf iu">from</strong> './saiyan.class';</span><span id="c834" class="oi me it nf b gy on ok l ol om">export <strong class="nf iu">class</strong> <strong class="nf iu">NullSaiyan</strong> <strong class="nf iu">extends</strong> <strong class="nf iu">AbstractSaiyan</strong> {<br/>  <strong class="nf iu">public</strong> <strong class="nf iu">getName</strong>(): <strong class="nf iu">string</strong> {<br/>    <strong class="nf iu">return</strong> 'Not Available in Saiyan Database';<br/>  }<br/>  toString(): <strong class="nf iu">string</strong> {<br/>    <strong class="nf iu">return</strong> 'Not Available in Saiyan Database';<br/>  }<br/>}</span></pre><p id="4ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了几个npm脚本，在应用了null-ojbect模式后，这些脚本运行这里显示的代码示例。</p><p id="22e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne nf b">npm run example1-problem</code> <br/> <code class="fe nc nd ne nf b">npm run example1-solution-1</code></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0289" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="ceee" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">空对象模式可以避免项目中的条件复杂性。这个模式允许你在没有对象的情况下配置默认的行为，这样就不必坚持检查一个对象是否为空。</p><p id="3f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式使用简单的继承来解决出现的问题。然而，这种模式被归类为本文所研究的另一种模式的特例:<a class="ae ky" href="https://medium.com/better-programming/design-patterns-using-the-strategy-pattern-in-javascript-3c12af58fd8a" rel="noopener">策略模式</a>。</p><p id="e8b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，可以说这种模式使用刚性组合(继承)来解决一个问题，这个问题可以用组合来解决，但是会导致比它所解决的问题更复杂的问题。这是一个很好的例子，说明我们作为开发人员的每一个“工具”都必须在正确的时间使用，而在我们的行业中最重要的事情是了解所有的工具以及我们应该何时使用它们。</p><p id="2a8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的事情不是实现我所展示的模式，而是能够识别这个特定模式可以解决的问题，以及何时可以或不可以实现所述模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ff5a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">更多更多…</h1><ul class=""><li id="af33" class="ng nh it lb b lc ni lf nj li nk lm nl lq nm lu oc no np nq bi translated">设计模式:可重用的面向对象软件的元素</li><li id="1451" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu oc no np nq bi translated">Sourcemaking.com<a class="ae ky" href="https://sourcemaking.com/design_patterns/null_object" rel="noopener ugc nofollow" target="_blank"/></li><li id="7da1" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu oc no np nq bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Null_object_pattern" rel="noopener ugc nofollow" target="_blank">空对象模式——维基百科</a>。</li><li id="bf74" class="ng nh it lb b lc nr lf ns li nt lm nu lq nv lu oc no np nq bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/null-object-design-pattern/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/null-object-design-pattern/</a></li></ul></div></div>    
</body>
</html>