# 在 Swift 中定制酒店包装

> 原文：<https://betterprogramming.pub/customizing-property-wrappers-in-swift-abe0952fc504>

## 第一次看 NotificationCenterPublisher 属性包装器

![](img/4ff232bcd143dd9e4f42c60e8cd5b3a1.png)

伊利亚·巴甫洛夫在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

顾名思义，属性包装器是一个包装通常的属性以提供附加功能的层。这一层充当你和实际财产之间的中间人。因此，无论何时想要设置或获取属性值，都必须通过属性包装器进行通信。现在，你可能会问“为什么要在这种互动中引入一个中间人？”。继续读下去，你会找到你的答案。

假设您是 Twitter 应用程序的开发人员，您想在一个属性中存储一条新的 tweet。你可能知道，一条推文被限制在 280 个字符以内。理想情况下，您已经有了一个限制用户输入超过 280 个字符的 UI。

但是，这并不意味着我们必须将这种字符检查仅限于 UI。如果用户界面坏了，突然有人在 Twitter 上发布文章怎么办？你不想被解雇，对吗？让我们看看属性包装器如何保存您的工作。

示例实现

在上面的例子中，我们使用一个名为`tweet`的属性来存储实际的 tweet。如果你注意到，就在我们的变量声明之前，我们有`@RestrictedCharacterCount(maxCharacterCount: 33)`。那是我们的属性包装器。

要使用属性包装器，从`@`符号开始，后跟属性包装器名称。我们还传入 33 作为我们的`maxCharacterCount`值，因为这将是我们在这个例子中存储的最大字符数。

> 从输出中，您可以观察到，只有我们发布的句子的前 33 个字符实际上存储在我们的属性中。其余的被忽略了。如果您还记得的话，这是因为我们之前明确地将“maxCharacterCount”设置为 33。现在，您可以将这个数字设置为 280 个字符，并在 twitter *上保留您的工作。*
> 
> 您可能还注意到，我们在属性名前使用$(美元)符号来访问属性包装器对象。这就是所谓的投影值。

在我们庆祝胜利之前，让我们先了解一下这是如何工作的。

要编写属性包装，

1.  您可以使用结构或类
2.  用`@propertyWrapper`语法注释你的对象。
3.  声明一个名为`wrappedValue`的属性。它必须是非静态的。这是我们将要包装的实际财产。该属性的数据类型由您决定。
4.  你可以给你的`wrappedValue`，一个默认值，或者让用户提供它。要做到后者，确保将`wrappedValue`作为对象初始化器的一部分。
5.  除了在初始化器中接收你的`wrappedValue`的值之外，你还可以指定你认为属性包装器所需要的其他参数。
6.  现在就像一个中间人，每当属性为“set”或“get”时，你都可以按照你的逻辑自由地改变值。您决定的内容将成为存储或返回给用户的最终值。
7.  当用户在属性名称前加上$(美元符号)时，就可以访问预计值。你作为项目价值的回报完全取决于你。
8.  例如，您的属性包装中可能有一些方法或属性为用户提供额外的功能。若要公开这一点，可以将属性包装本身作为投影值返回。

现在您已经对事情的工作原理有了基本的了解，让我们看看前面的属性包装器`@RestrictedCharacterCount`的实现。

> "兄弟，为什么你要把事情变得复杂，把它变得普通"

请耐心听我说几分钟。让我来给你解释一下，你会意识到这有多强大。这是核心思想。

> 创建一个属性包装器，将最大字符数作为参数，当存储在属性中的数据的字符数超过最大字符数时，从末尾截断多余的字符。属性包装还应该兼容多种数据类型，以实现最大的灵活性

现在，让我们分解我们的属性包装器，

1.  为了使它兼容广泛的数据类型，我们将我们的`wrappedValue`的数据类型通用化，并将其命名为 **T** 。
2.  我们还确保 T 是符合`LosslessStringConvertible` 协议的东西。这允许 T ←→ String 之间的自由转换。
3.  现在，我们将数据类型 T 的`wrappedValue`转换为 String 来计算字符数。如果我们超过了`maxCharacterCount`，我们会在末尾删除多余的字符。最后，我们将这个修整过的字符串转换回它的原始数据类型 T，并将其存储在`wrappedValue`变量中。
4.  因此，每当用户为我们的属性设置一个值时，我们检查数据，计算字符数，修剪任何多余的字符，然后最终存储它。

以下是一些例子，说明为什么使它通用化会使它真正强大:

我再举几个例子来巩固你的理解。

`@RestrictedRange`是一个属性包装器，它帮助你将你的属性值限制在一个特定的范围内。每当任何用户试图设置一个不在有效范围内的值时，就会调用闭包来用有效值替换它。

`@NotificationCenterPublisher`是一个通用的属性包装器，它使用通知中心发布属性的每个新值。

您必须传递通知名，也可以选择设置一个名为`getUserInfo`的闭包，它将允许您在通知发布之前传递`userInfo`字典。

> 总之，属性包装器帮助您在每次用户读取或写入属性值时操作属性值。这种访问逻辑一旦以属性包装的形式编写，就可以重用并应用于代码库中的任何属性。
> 
> 您可以有选择地将一个`projectedValue`添加到您的属性包装器中，然后可以通过奇特的$(美元)语法访问它。这对于在属性包装中公开任何附加功能非常有用。

属性包装器是 SwiftUI 世界的重要组成部分，理解它们至关重要。