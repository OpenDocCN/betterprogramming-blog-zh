<html>
<head>
<title>From Functions to Python Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从函数到Python包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-functions-to-python-package-f8a3bba8bb6b?source=collection_archive---------8-----------------------#2022-04-08">https://betterprogramming.pub/from-functions-to-python-package-f8a3bba8bb6b?source=collection_archive---------8-----------------------#2022-04-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5575" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从头开始学习如何将函数转换成包并分发</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b6304fef4a87518d445f96cbc9daecd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5BIAXAO345EMy5Fy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@fempreneurstyledstock?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Leone Venter </a>拍摄的照片</p></figure><p id="2419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用Python编码很有趣，但更有趣的是适用于不同目的的<em class="ls">包</em>的可用性。例如，科学计算和机器学习包的可用性使Python成为数据科学和分析领域最受欢迎的语言。在这篇文章中，我们将介绍Python包的世界，并看看我们如何构建自己的包。</p><p id="988f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我上一篇关于Python模块的文章中，<a class="ae kv" href="https://levelup.gitconnected.com/use-modules-to-better-organize-your-python-code-75690ba6b6e" rel="noopener ugc nofollow" target="_blank">使用模块更好地组织你的Python代码</a>，我讨论了我们如何使用Python <em class="ls">模块</em>更好地组织我们的代码。在这篇文章中，我们将采取下一步，学习如何使用<em class="ls">包</em>更好地组织我们的Python模块。</p><h1 id="1bb8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">什么和为什么？</h1><p id="1a00" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Python包是模块的集合。如果Python模块被认为是函数和变量的家，那么包就是模块的家。</p><h2 id="ae5e" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">❓:但是如果我们可以用模块来组织我们的代码，那为什么还要用包呢？</h2><p id="8179" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">正如我们已经知道的，代码库倾向于增长。随着代码库的不断增长，您很可能会根据功能执行的任务类型将它们分成多个模块。随着模块数量的增长，一个自然的过程是找到一种方法，根据它们所属的公共组来组织模块。以目录形式组织的一组模块可以很容易地转换成Python包，以简化模块的使用和维护。</p><blockquote class="nc nd ne"><p id="cdf7" class="kw kx ls ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">包是通过使用“带点的模块名”来构造Python的模块名称空间的一种方式。—来源:<a class="ae kv" href="https://docs.python.org/3/tutorial/modules.html" rel="noopener ugc nofollow" target="_blank"> Python教程</a></p></blockquote><p id="e906" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦安装了一个包，我们就可以使用点符号轻松地访问存储在不同目录级别的模块。</p><h1 id="3f6c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">一个示例场景</h1><p id="fee1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在开始讨论包之前，让我们考虑一个场景，以便更容易地将我们的学习放入上下文中。让我们假设我们正在进行一个项目，在这个项目中，我们得到由一个长字符串中存储的特定字符分隔的用户名。我们需要将它们分解，并为它们分配唯一的数字id，以便将来可以将它们存储在数据库中。因此，我们的任务是:</p><ol class=""><li id="eefe" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">将输入字符串分成一组名称列表，</li><li id="e98a" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">然后为这些名称分配唯一的id。</li></ol><p id="73ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了执行这些任务，我们将构建几个函数，将它们存储在几个模块中，并最终将它们封装在一个Python包中。为这样一个微不足道的项目构建一个包无疑是大材小用，但出于我们的学习目的，让我们假设这是一个好主意。</p><h1 id="19e1" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">两个模块</h1><p id="4f70" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们创建几个模块:<code class="fe nw nx ny nz b">stringProcess</code>、<code class="fe nw nx ny nz b">idfier</code>。</p><ul class=""><li id="baab" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oa no np nq bi translated"><code class="fe nw nx ny nz b">stringProcess</code>:一个帮助我们处理字符串的模块。目前，它只包含一个名为<code class="fe nw nx ny nz b">stringSplit()</code>的函数，该函数接受一个字符串，然后根据选择的分隔符将其拆分。</li><li id="4011" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oa no np nq bi translated"><code class="fe nw nx ny nz b">idfier</code>:帮助我们创建唯一id的模块。目前，它只包含一个名为<code class="fe nw nx ny nz b">randomIdfier()</code>的函数，该函数获取一个名称列表，为它们分配随机生成的惟一id，并将它们保存为一个字典。</li></ul><p id="9dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用下面的代码创建两个单独的<code class="fe nw nx ny nz b">.py</code>文件，并用模块名命名这些文件。此外，确保将它们保存在运行脚本或笔记本的同一目录中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h1 id="94b8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">对包构建有用的模块属性</h1><p id="9be9" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们已经在上一篇文章中讨论了通用模块属性。在这里，我们将讨论一些附加属性，这些属性在我们讨论包开发时会很方便。</p><h2 id="7504" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">模块初始化</h2><p id="6092" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一旦导入了一个模块，Python就会隐式地执行该模块，并让它初始化它的某些方面。需要注意的一个重要方面是:</p><blockquote class="od"><p id="9aee" class="oe of iq bd og oh oi oj ok ol om lr dk translated"><em class="on">模块初始化在一个项目中只发生一次。</em></p></blockquote><p id="a70e" class="pw-post-body-paragraph kw kx iq ky b kz oo jr lb lc op ju le lf oq lh li lj or ll lm ln os lp lq lr ij bi translated">如果一个模块被多次导入，这是不必要的，但即使它发生在一个模块内部，对于后续的导入，Python会记住前一次的导入，并忽略后面的初始化。在下面的例子中，您可以看到这个特性的实际应用。我们看到，当我们两次导入<code class="fe nw nx ny nz b">idfier</code>和<code class="fe nw nx ny nz b">stringProcess</code>模块时，它们只在第一次初始化时打印出一次消息，并且在随后的导入中不产生任何消息。</p><pre class="kg kh ki kj gt ot nz ou ov aw ow bi"><span id="fdee" class="mq lu iq nz b gy ox oy l oz pa">import idfier</span><span id="3662" class="mq lu iq nz b gy pb oy l oz pa">import idfier</span><span id="ec50" class="mq lu iq nz b gy pb oy l oz pa">import stringProcess</span><span id="dbdb" class="mq lu iq nz b gy pb oy l oz pa">import stringProcess</span><span id="753b" class="mq lu iq nz b gy pb oy l oz pa">idfier is used as a module<br/>stringProcess is used as a module</span></pre><h2 id="3bbd" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">模块中的私有属性</h2><p id="0e2d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">您可能希望在模块中包含仅供内部使用的变量。本质上，这些被认为是<code class="fe nw nx ny nz b">private</code>属性。您可以通过一个或两个下划线(<code class="fe nw nx ny nz b">__</code>)来声明这样的属性，即变量或函数。</p><blockquote class="od"><p id="3925" class="oe of iq bd og oh oi oj ok ol om lr dk translated">但是添加下划线仅仅是一种约定，本身并不强加任何保护。</p></blockquote><p id="3921" class="pw-post-body-paragraph kw kx iq ky b kz oo jr lb lc op ju le lf oq lh li lj or ll lm ln os lp lq lr ij bi translated">⚠️与Java等其他语言不同，Python对访问这种私有属性没有任何严格的限制。添加下划线可以让其他开发人员注意到这些属性仅供内部使用。</p><h2 id="ff15" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><code class="fe nw nx ny nz b">__name__</code>变量</h2><p id="8ab8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">模块本质上是Python脚本。当Python脚本作为模块导入时，Python会创建一个名为<code class="fe nw nx ny nz b">__name__</code>的变量，并在其中存储模块的名称，例如，当我们导入我们的<code class="fe nw nx ny nz b">idfier</code>模块时，<code class="fe nw nx ny nz b">__name__</code>变量中包含值- <code class="fe nw nx ny nz b">idfier</code>。相反，当脚本被直接执行时，<code class="fe nw nx ny nz b">__name__</code>变量包含<code class="fe nw nx ny nz b">__main__</code>作为值。</p><p id="510b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了演示，让我们在<code class="fe nw nx ny nz b">stringProcess.py</code>文件中添加以下简单的<code class="fe nw nx ny nz b">if-else</code>条件，并检查我们如何使用<code class="fe nw nx ny nz b">__name__</code>属性。</p><pre class="kg kh ki kj gt ot nz ou ov aw ow bi"><span id="361d" class="mq lu iq nz b gy ox oy l oz pa">name = "stringProcess"</span><span id="d7df" class="mq lu iq nz b gy pb oy l oz pa">if __name__ == "__main__":</span><span id="4157" class="mq lu iq nz b gy pb oy l oz pa">print(name, "is used as a script")</span><span id="7e6b" class="mq lu iq nz b gy pb oy l oz pa">else:</span><span id="23a0" class="mq lu iq nz b gy pb oy l oz pa">print(name, "is used as a module")</span></pre><p id="33b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码单元中，我们将<code class="fe nw nx ny nz b">stringProcess</code>模块作为脚本和模块来调用。看看两种方法如何产生两种不同的消息。</p><p id="5e20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑记住，在运行下面的代码块之前，要重启你的Jupyter笔记本或者重新运行你的脚本，否则你不会看到正确的结果。还记得Python只初始化一个模块一次的规则吗？</p><pre class="kg kh ki kj gt ot nz ou ov aw ow bi"><span id="7751" class="mq lu iq nz b gy ox oy l oz pa">%run -i stringProcess.py</span><span id="f2ac" class="mq lu iq nz b gy pb oy l oz pa">import stringProcess</span><span id="246e" class="mq lu iq nz b gy pb oy l oz pa">stringProcess is used as a script<br/>stringProcess is used as a module</span></pre></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><h2 id="937d" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak">💡那么这个</strong> <code class="fe nw nx ny nz b"><strong class="ak">__name__</strong></code> <strong class="ak">变量会有什么帮助呢？</strong></h2><p id="880b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe nw nx ny nz b">__name__</code>变量是一个非常有用的特性，可以对模块脚本中的代码进行一些基本测试。使用此变量的存储值，您可以在开发模式下主动使用脚本时要求Python运行一些测试，并在项目中将它们用作模块时忽略它们。稍后我们将看到这个功能的演示。</p></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><h1 id="29c3" class="lt lu iq bd lv lw pj ly lz ma pk mc md jw pl jx mf jz pm ka mh kc pn kd mj mk bi translated">改进<code class="fe nw nx ny nz b">idfier</code></h1><p id="6050" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在基于我们新知道的模块的性质，让我们改进模块— <code class="fe nw nx ny nz b">idfier</code>。</p><ul class=""><li id="5f98" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oa no np nq bi translated"><strong class="ky ir">改进</strong> <code class="fe nw nx ny nz b"><strong class="ky ir">randomIdfier()</strong></code>:目前这个函数生成一个1000到9999之间的随机整数并赋值。但是因为这个数字是随机产生的，所以不能保证这个数字是唯一的。但是出于我们的目的，我们需要它来创建唯一的数字作为id。为了确保唯一性，我们添加一个<code class="fe nw nx ny nz b">while</code>循环来检查重复项，并重新生成随机数，除非它找到一个唯一的随机数。</li><li id="26f5" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oa no np nq bi translated"><strong class="ky ir">使用</strong> <code class="fe nw nx ny nz b"><strong class="ky ir">__name__</strong></code> <strong class="ky ir">进行自动化测试</strong>:我们将添加一个测试代码块，并将其包装在一个<code class="fe nw nx ny nz b">if-else</code>条件中，这样它将只在<code class="fe nw nx ny nz b"><strong class="ky ir">__name__ == "__main__"</strong></code> <strong class="ky ir"> </strong>的值时运行测试，换句话说就是直接运行模块脚本。这个简单的测试将检查当我们使用包含两个名字的字符串输入运行<code class="fe nw nx ny nz b">randomIdfier()</code>时，唯一ID值的长度是否等于2。</li><li id="0115" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oa no np nq bi translated"><strong class="ky ir">添加简短描述</strong>:我们已经使用<code class="fe nw nx ny nz b">""" """</code> (docstring)为代码块添加简短描述。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ob oc l"/></div></figure><pre class="kg kh ki kj gt ot nz ou ov aw ow bi"><span id="f970" class="mq lu iq nz b gy ox oy l oz pa">import idfier as idf</span><span id="646b" class="mq lu iq nz b gy pb oy l oz pa">idf.randomIdfier(['name1', 'name2'])</span><span id="7411" class="mq lu iq nz b gy pb oy l oz pa">idfier is used as a module</span><span id="dc36" class="mq lu iq nz b gy pb oy l oz pa">{'name1': 6571, 'name2': 7469}</span></pre><ul class=""><li id="dcac" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oa no np nq bi translated">作为脚本执行<code class="fe nw nx ny nz b">idfier.py</code>。你能猜出产量吗？</li><li id="02bd" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oa no np nq bi translated">尝试更改内部代码，以便测试失败。他们再次执行。</li></ul><h1 id="0595" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Python的搜索模块</h1><p id="8619" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">到目前为止，我们将模块与项目脚本放在同一个目录中。但是在实际的项目中，我们希望将我们的模块和包保存在一个单独的位置。因此，为了模拟这种情况，让我们将两个模块复制到一个不同的文件夹中，并将该文件夹命名为<code class="fe nw nx ny nz b">Silly_Anonymizer</code>。</p><h2 id="b9ec" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">❓ <strong class="ak">那么我们如何将这个位置添加到我们的Python项目中呢？</strong></h2><blockquote class="nc nd ne"><p id="4d4a" class="kw kx ls ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">Python在<code class="fe nw nx ny nz b">sys</code>模块的<code class="fe nw nx ny nz b">path</code>变量中维护一个位置或文件夹列表，Python在其中搜索模块。</p></blockquote><p id="ca81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它按照存储在列表中的顺序搜索<code class="fe nw nx ny nz b">sys.path</code>中的位置，从脚本执行的位置开始。</p><pre class="kg kh ki kj gt ot nz ou ov aw ow bi"><span id="f508" class="mq lu iq nz b gy ox oy l oz pa">import sys</span><span id="4ce9" class="mq lu iq nz b gy pb oy l oz pa">sys.path</span><span id="64ff" class="mq lu iq nz b gy pb oy l oz pa">['C:\\Users\\ahfah\\Desktop\\Curious-Joe\\content\\post\\2202-04-02-oop-python-package',<br/> 'C:\\Users\\ahfah\\AppData\\Local\\Programs\\Python\\Python39\\python39.zip',<br/> 'C:\\Users\\ahfah\\AppData\\Local\\Programs\\Python\\Python39\\DLLs',<br/> 'C:\\Users\\ahfah\\AppData\\Local\\Programs\\Python\\Python39\\lib',<br/> 'C:\\Users\\ahfah\\AppData\\Local\\Programs\\Python\\Python39',<br/> 'c:\\Python_Envs\\pcap02',<br/> '',<br/> 'c:\\Python_Envs\\pcap02\\lib\\site-packages',<br/> 'c:\\Python_Envs\\pcap02\\lib\\site-packages\\win32',<br/> 'c:\\Python_Envs\\pcap02\\lib\\site-packages\\win32\\lib',<br/> 'c:\\Python_Envs\\pcap02\\lib\\site-packages\\Pythonwin']</span></pre><p id="7081" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将自定义模块位置添加到这个列表中，并确保Python知道在哪里可以找到该模块。<code class="fe nw nx ny nz b">Silly_Anonymizer</code>模块目录位于我的工作站上:<code class="fe nw nx ny nz b">C:\Users\ahfah\Desktop\Anonymizer\Silly_Anonymizer</code>。让我们添加并检查一下。</p><pre class="kg kh ki kj gt ot nz ou ov aw ow bi"><span id="51e5" class="mq lu iq nz b gy ox oy l oz pa">sys.path.append('C:\\Users\\ahfah\\Desktop\\Anonymizer\\Silly_Anonymizer\\')</span><span id="acc2" class="mq lu iq nz b gy pb oy l oz pa">sys.path[len(sys.path)-1]</span><span id="72ba" class="mq lu iq nz b gy pb oy l oz pa">'C:\\Users\\ahfah\\Desktop\\Anonymizer\\Silly_Anonymizer\\'</span></pre><p id="af72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑注意双反斜杠。反斜杠是用来转义其他字符的，所以我们需要使用双反斜杠来让Python明白我们在寻找一个字面上的反斜杠。</p><h1 id="d277" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">构建包</h1><p id="4450" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将我们的模块放入傻瓜式匿名器是制作包的第一步。让我们在<code class="fe nw nx ny nz b">Silly_Anonymizer</code> — <code class="fe nw nx ny nz b">NonStringOperation</code>和<code class="fe nw nx ny nz b">StringOperation</code>中创建两个子目录，这样将来如果我们有更多的模块，我们就可以根据它们的任务类型来存储它们——操纵字符串，或者操纵非字符串操作。现在，让我们将两个模块移到这两个子目录中:<code class="fe nw nx ny nz b">NonStringOperation</code>中的<code class="fe nw nx ny nz b">idfier.py</code>和<code class="fe nw nx ny nz b">stringProcess.py</code>中的<code class="fe nw nx ny nz b">StringOperation</code>。因此，文件夹结构应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/09da373eb9a575e5498128d73afa6b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*3_zpZ6T49a-A06SWnNjzWQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者形象</p></figure><p id="96d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的包中查看傻瓜式匿名器目录，可以看到Python包的目录结构！</p><p id="e123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的傻_匿名器包的功能、模块和包关系的具体视图如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/02fcf690559be185cf08edf3ad2e2e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EQ9nYijkuCWH3oz15Mf43A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者形象</p></figure><h2 id="4944" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">初始化包</h2><p id="5f57" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">像模块一样，Python包也需要初始值设定项。为此，我们需要在<code class="fe nw nx ny nz b">Silly_Anonymizer</code>的根目录中包含一个名为<code class="fe nw nx ny nz b">__init__.py</code>的文件。但是由于包不是一个文件，我们不能将它作为函数的一部分，因此这个单独的文件用于初始化。它可以保留为空，但它需要出现在要视为包的模块目录的根目录下。</p><p id="7337" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以添加<code class="fe nw nx ny nz b">__init__.py</code>后，匿名文件夹应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/5e07e17b5528682c7138765e1c8e5004.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*8vUg6GUnn-zVGkm1ofE5pA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者形象</p></figure><p id="1f0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑注意，你也可以把<code class="fe nw nx ny nz b">__init__.py</code>放在其他子文件夹中，这取决于你是否需要对它们进行任何特殊的初始化，或者只是想把它们当作一个子包。这也是我们以后要做的。</p><h2 id="e704" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">从包导入模块</h2><p id="fd92" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一旦我们的模块主目录中有了<code class="fe nw nx ny nz b">__init__.py</code>文件，我们就可以将它作为一个包使用。要从Python包中导入模块，我们需要使用从包根开始的完全限定路径。在我们的案例中，对于模块- <code class="fe nw nx ny nz b">stringProcess</code>导入将如下所示:</p><pre class="kg kh ki kj gt ot nz ou ov aw ow bi"><span id="02f0" class="mq lu iq nz b gy ox oy l oz pa">import Anonymizer.StringOperation.stringProcess as sp</span><span id="0b02" class="mq lu iq nz b gy pb oy l oz pa">&gt; stringProcess is used as a module<br/></span><span id="c80f" class="mq lu iq nz b gy pb oy l oz pa">sp.stringSplit(string="Arafath, Samuel, Tiara, Nathan, Moez", separator=",")</span><span id="f2d3" class="mq lu iq nz b gy pb oy l oz pa">&gt; ['Arafath', ' Samuel', ' Tiara', ' Nathan', ' Moez']</span></pre></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><p id="1db1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">💡Python也可以从压缩的位置读取包。</strong></p><p id="280b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python包也可以从zip文件夹导入。如果您注意到<code class="fe nw nx ny nz b">sys.path</code>的输出，您可能已经在列表中找到了一些zip文件夹。这是因为Python将压缩文件夹视为常规文件夹。</p><p id="d66b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑尝试将<code class="fe nw nx ny nz b">Simmy_Anonymizer</code>压缩到一个压缩文件夹<code class="fe nw nx ny nz b">Silly_Anonymizer.zip</code>中，并尝试导入它。</p></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><h1 id="f019" class="lt lu iq bd lv lw pj ly lz ma pk mc md jw pl jx mf jz pm ka mh kc pn kd mj mk bi translated">发布包</h1><p id="2b23" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们已经构建了自己的包，可以在本地使用了。现在让我们简单地谈谈如何让其他人也能使用它。为此，我们将使用PyPi。Python打包索引(PyPi)是托管Python包最常用的存储库。</p></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><h2 id="a6c7" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak"> ⚠️提醒一句</strong></h2><p id="1d11" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这里解释的包发布步骤是发布包的最低要求。使用它作为踏脚石，然后研究官方文档以理解包发布的本质。我将添加一些参考资料。</p></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><h2 id="1a35" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">准备</h2><p id="76a5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了使我们的包准备好上传，让我们将以下文件添加到我们的模块目录所在的目录中:</p><p id="3df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">为</strong> <code class="fe nw nx ny nz b"><strong class="ky ir">Silly_Anonymizer</strong></code>添加一个Git库</p><p id="ff00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在GitHub或任何其他分布式版本控制解决方案中创建一个远程存储库，并将<code class="fe nw nx ny nz b">Silly_Anonymizer</code>包添加到存储库中。你可以在这里查看我的<a class="ae kv" href="https://github.com/Curious-Joe/Anonymizer" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="6a4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">添加一个</strong> <code class="fe nw nx ny nz b"><strong class="ky ir">readme.md</strong></code> <strong class="ky ir">文件</strong></p><p id="ee96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自述文件为用户提供了项目的描述。在我们的例子中，它将描述用户、<code class="fe nw nx ny nz b">Silly_Anonymizer</code>包是关于什么的、如何使用等等。查看GitHub repo获取一个示例自述文件。</p><p id="9f94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">添加一个</strong> <code class="fe nw nx ny nz b"><strong class="ky ir">setup.py</strong></code> <strong class="ky ir">文件</strong></p><p id="7b8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是成功准备PyPi上传包所需的主要文件。这个文件包含一些基本的说明，确保这个本地目录为上传到PyPI做好了适当的准备。查看GitHub repo中的示例文件。</p><p id="062d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装文件中的信息有助于包的开发、托管和维护。三个绝对最少的必需属性是名称、版本和包。有关这些和所有参数的详细信息，请查阅官方文档。</p><p id="8682" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">包含这些文件后，文件目录应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/d8ca2301dee1d3b92acddee146bac3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*T8MHxcYmBb3WpgQAudIabA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><h2 id="4898" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak">构建分发包</strong></h2><p id="5e61" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">PyPi分发包装在分发包中的Python包源代码。两个常用的分发包是源文档和Python wheels。为了创建源文件和我们的包，我们将使用一个名为<code class="fe nw nx ny nz b">twine</code>的包并运行<code class="fe nw nx ny nz b">python setup.py sdist bdist_wheel</code>。</p><p id="026a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在新创建的名为<code class="fe nw nx ny nz b">dist</code>的目录中创建两个文件——一个源归档文件(<code class="fe nw nx ny nz b">.tar.gz</code>文件)和一个车轮文件(<code class="fe nw nx ny nz b">.whl</code>文件)。签出源归档文件，以确保所有源代码都填充在其中。</p><h2 id="8c01" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">快速检查</h2><p id="a7be" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们准备向PyPi推出我们的产品包。在将它推送到PyPi之前，让我们运行<code class="fe nw nx ny nz b">twine check dist/*</code>来快速检查这个包是否能在PyPi中正确呈现。如果一切正常，你应该在运行检查后看到屏幕上打印的<code class="fe nw nx ny nz b">PASSED</code>。</p><h2 id="852d" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">上传</h2><p id="17ca" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">PyPi有一个测试版本，我们可以用它来学习和测试。我们将使用PyPi测试来托管我们的包。在此之前，请确保您在<a class="ae kv" href="https://test.pypi.org/" rel="noopener ugc nofollow" target="_blank"> PyPi测试</a>中注册。</p><p id="5203" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注册后，运行<code class="fe nw nx ny nz b">twine upload --repository-url https://test.pypi.org/legacy/ dist/*</code>。出现提示时，输入您的用户名和密码。</p><p id="3cf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑:如果你一直关注这篇文章，你可能无法上传与我已经上传的包同名的包。给它一个不同的名称并重新构建包。</p><p id="29a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">🛑使用测试PyPi搜索来找出您的软件包名称是否可用。</p></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><p id="d3eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！您应该在控制台上看到新创建的Python包的位置。结账地雷<a class="ae kv" href="https://test.pypi.org/project/Silly-Anonymizer/1.0.0/#history" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="e87d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">下一步是什么？</h1><p id="14e3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在这篇文章中，我试图让一个对编写Python函数有函数理解的人来构建他/她的第一个Python包。在结束之前，重申一下前面的内容，这篇文章绝不是一篇关于如何构建生产包的详细教程。在产品代码中，必须添加严格的测试。此外，不太可能构建一个没有任何依赖关系的包！这两个我都没有涉及到，所以一定要了解它们。</p><p id="633a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，这里有一些资源可以用来补充你的理解:</p><ul class=""><li id="6cc4" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr oa no np nq bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=GIF3LaRqgXo" rel="noopener ugc nofollow" target="_blank">马克·史密斯在EuroPython 2019的演讲</a></li><li id="8a0d" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr oa no np nq bi translated"><a class="ae kv" href="https://realpython.com/pypi-publish-python-package/" rel="noopener ugc nofollow" target="_blank">来自RealPython的教程</a></li></ul></div><div class="ab cl pc pd hu pe" role="separator"><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph pi"/><span class="pf bw bk pg ph"/></div><div class="ij ik il im in"><p id="18b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢写数据科学和DS中使用的工具。这里有几个你可能会喜欢的故事:</p><div class="ps pt gp gr pu pv"><a href="https://towardsdatascience.com/python-exceptions-what-why-and-how-44661cad3cd4" rel="noopener follow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd ir gy z fp qa fr fs qb fu fw ip bi translated">Python异常——什么、为什么和如何？</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">理解Python中异常的工作方式以及如何正确使用它们。</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">towardsdatascience.com</p></div></div><div class="qe l"><div class="qf l qg qh qi qe qj kp pv"/></div></div></a></div><div class="ps pt gp gr pu pv"><a href="https://towardsdatascience.com/object-oriented-programming-in-python-what-and-why-d966e9e0fd03" rel="noopener follow" target="_blank"><div class="pw ab fo"><div class="px ab py cl cj pz"><h2 class="bd ir gy z fp qa fr fs qb fu fw ip bi translated">Python中的面向对象编程——什么和为什么？</h2><div class="qc l"><h3 class="bd b gy z fp qa fr fs qb fu fw dk translated">学习Python中的面向对象编程。</h3></div><div class="qd l"><p class="bd b dl z fp qa fr fs qb fu fw dk translated">towardsdatascience.com</p></div></div><div class="qe l"><div class="qk l qg qh qi qe qj kp pv"/></div></div></a></div></div></div>    
</body>
</html>