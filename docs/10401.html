<html>
<head>
<title>How to Use Root C++ Interpreter Shell to Write C++ Programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用根C++解释器外壳编写C++程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-root-c-interpreter-shell-to-write-c-code-ebfd52d2642d?source=collection_archive---------13-----------------------#2022-01-04">https://betterprogramming.pub/how-to-use-root-c-interpreter-shell-to-write-c-code-ebfd52d2642d?source=collection_archive---------13-----------------------#2022-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c7d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用根C++解释器编写基本的C++构造</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8377fb368d98a3f18d407d372a0cf650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tY8--yJx4g30U27N"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·伊德里在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="aa37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在20世纪70年代末上大学时学习了计算机编程。这意味着我学习的前几门编程课程使用了基于大型机的编程语言:Fortran、PL/I和Cobol，仅举三个例子。</p><p id="b382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直到我大学毕业并开始在It行业工作后，我才开始使用基于PC的语言，比如BASIC，有趣的是，还有Logo。这些语言是基于翻译的，让我感受到了和翻译一起工作的乐趣。</p><p id="fa26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在过去的23年里，我一直在教初级计算机科学学生C++，并且使用过各种不同的编译器，从基于DOS的Borland编译器到各种开源编译器和不同的Microsoft C++编译器。</p><p id="7746" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个月前，我偶然发现了一些关于CERN正在运行的<a class="ae ky" href="https://root.cern/" rel="noopener ugc nofollow" target="_blank">根数据分析项目</a>的信息。这组计算机科学家和物理学家已经围绕C++构建了他们的数据分析框架项目(同时也提供了对Python的支持，并且很快会提供对JavaScript的支持)，并且，为了帮助他们的用户的计算创造力，该组已经实现了一个C++解释器。</p><p id="c49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论这个解释器的特性，并演示如何使用这些特性来编写重要的C++程序。在以后的文章中，我将使用这个解释器向不熟悉C++的程序员介绍这种语言，我希望这种方式能与我学习一种基于解释器的新编程语言时的兴奋感相匹配。</p><h1 id="498b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">关于根C++解释器</h1><p id="b61a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">根C++解释器是LLVM项目的一部分。LLVM是一个低级编译器基础设施，可以与许多编程语言的前端编译器进行交互。Clang是LLVM的C++前端编译器。</p><p id="af09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该解释器有一个REPL(读取-求值-打印-循环)外壳，允许您单独输入C++语句，并在输入时对它们进行求值。您也可以编写可以是独立程序或函数的宏。独立程序以void函数的形式输入，并在装入shell时执行。您还可以直接从shell中执行宏，而无需加载它们。我将在本文的后面演示这一切。</p><h1 id="1986" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装根和首次使用</h1><p id="bd46" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我已经在我的Ubuntu Virtual Box和Windows笔记本电脑上安装了ROOT。这两种安装都很容易做到。只需遵循您的环境的说明<a class="ae ky" href="https://root.cern/install/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="3d29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在命令提示符下键入root或单击其图标来启动ROOT。根shell启动时会显示一个通知，然后是命令行提示符:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/fb127c3ceb4d2677821e43586ca1b0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GSS6wGFjeZPfIM0DMjflw.jpeg"/></div></div></figure><p id="6ea4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您键入一个数字，就会返回该数字。在这里，解释器读取输入，对其进行评估(数字总是自己评估)，并打印出来:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="25c2" class="my lw it mu b gy mz na l nb nc">root [0] 1<br/>(int) 1<br/>root [1]</span></pre><p id="ccc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，shell还会告诉您输出的数据类型(这对学习数据类型的学生很有帮助)。</p><p id="371e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经看到了如何安装和启动ROOT，让我们更深入地了解如何使用shell进行计算。</p><h1 id="0f99" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">将ROOT用作计算器</h1><p id="0e64" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从将shell用作计算器开始。以下是我做的一些计算:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c903" class="my lw it mu b gy mz na l nb nc">root [0] 1+1<br/>(int) 2<br/>root [1] 2.2 * 3.1<br/>(double) 6.8200000<br/>root [2] TMath::Pi() * (5 * 5)<br/>(double) 78.539816<br/>root [4] TMath::Factorial(5)<br/>(double) 120.00000</span></pre><p id="70d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TMath库有大量的数学和三角函数可供您使用。这里不胜枚举，所以我将为这个库写一篇完整文章。</p><h1 id="8985" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在Shell中编写C++语句</h1><p id="aecd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从声明和定义几个变量开始:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2579" class="my lw it mu b gy mz na l nb nc">root [0] int x = 100<br/>(int) 100<br/>root [1] double y = 2.345<br/>(double) 2.3450000<br/>root [2] string s = "Hello, world!"<br/>(std::string &amp;) "Hello, world!"<br/>root [3] bool flag = true<br/>(bool) true</span></pre><p id="4968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，您不必在使用根shell的语句末尾使用分号，但是如果您愿意，您可以这样做。还要注意，shell让您知道在评估语句时使用的数据类型。我们在前面的部分也看到了这一点，我在那里进行了一些计算。</p><p id="bbe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有常见的算术和关系运算符都可以通过shell获得。</p><p id="7cd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些例子:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2ef0" class="my lw it mu b gy mz na l nb nc">root [0] int x = 25<br/>(int) 25<br/>root [1] x++<br/>(int) 25<br/>root [2] std::cout &lt;&lt; x<br/>26(std::basic_ostream &amp;) @0x64ad5a40<br/>root [3] x += 2<br/>(int) 28<br/>root [4] --x<br/>(int) 27<br/>root [5] x &gt; 30<br/>(bool) false<br/>root [6] x &lt;= 30<br/>(bool) true<br/>root [7]</span></pre><p id="7d16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也可以编写更复杂的语句，例如an <code class="fe nd ne nf mu b">if-else</code>:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="268a" class="my lw it mu b gy mz na l nb nc">root [8] if (x &lt; 30) { std::cout &lt;&lt; x &lt;&lt; " is less than 30."; }<br/>else { std::cout &lt;&lt; x &lt;&lt; " is not less than 30."; }</span></pre><p id="ff9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于像这样的语句，必须在需要分号的地方包含分号，否则shell将抛出一条错误消息:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="88c7" class="my lw it mu b gy mz na l nb nc">root [7] if (x &lt; 30) { std::cout &lt;&lt; x &lt;&lt; " is less than 30."; } else { std::cout &lt;&lt; x &lt;&lt; " is not less than 30." }<br/>ROOT_prompt_7:1:104: error: expected ';' after expression<br/>if (x &lt; 30) { std::cout &lt;&lt; x &lt;&lt; " is less than 30."; } else { std::cout &lt;&lt; x &lt;&lt; " is not less than 30." }</span></pre><p id="cd1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看一些<code class="fe nd ne nf mu b">for</code>和<code class="fe nd ne nf mu b">whil</code> e语句的例子:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2991" class="my lw it mu b gy mz na l nb nc">root [0] int fact = 1;<br/>root [1] for (int i = 5; i &gt;= 1; i--) { fact *= i; } std::cout &lt;&lt; fact &lt;&lt; endl;<br/>120<br/>root [2] fact = 1;<br/>root [3] int num = 5;<br/>root [4] while (num &gt;= 1) { fact *= num; num--; } std::cout &lt;&lt; fact &lt;&lt; endl;<br/>120<br/>root [5]</span></pre><p id="1fa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在这个例子中看到的，您可以使用<code class="fe nd ne nf mu b">cout</code>对象来执行输出。您也可以使用<code class="fe nd ne nf mu b">cin</code>接收输入:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4ba8" class="my lw it mu b gy mz na l nb nc">root [0] int fact = 1<br/>(int) 1<br/>root [1] std::cout &lt;&lt; "Compute factorial for: "<br/>Compute factorial for: (std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt; &amp;) @0x77090b68<br/>root [2] int num<br/>(int) 0<br/>root [3] cin &gt;&gt; num<br/>5<br/>(std::basic_istream &amp;) @0x77090d20<br/>root [4] for (int i = num; i &gt;= 1; i--) { fact *= i; } std::cout &lt;&lt; fact &lt;&lt; endl<br/>120</span></pre><h1 id="00e9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在根中定义函数</h1><p id="60d3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您可以在shell中定义函数。你可以用传统的方法或者创建一个lambda函数。以下是使用标准技术定义的阶乘函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="0c66" class="my lw it mu b gy mz na l nb nc">root [0] double factorial(int n) { int f = 1; for (int i = n; i &gt;= 1; i--) { f *= i; } return f; }<br/>root [1] factorial(5)<br/>(double) 120.00000<br/>root [2] int num<br/>(int) 0<br/>root [3] std::cout &lt;&lt; "Compute factorial of? "<br/>Compute factorial of? (std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt; &amp;) @0x64ad5a40<br/>root [4] cin &gt;&gt; num<br/>4<br/>(std::basic_istream &amp;) @0x64ad5928<br/>root [5] factorial(num)<br/>(double) 24.000000<br/>root [6]</span></pre><p id="726a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是用λ定义的同一个函数:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="50c7" class="my lw it mu b gy mz na l nb nc">root [0] auto factorial = [] (int n) { int f = 1; for (int i = n; i &gt;= 1; i--) { f *= i; } return f; }<br/>((lambda) &amp;) @0x3d80020<br/>root [1] std::cout &lt;&lt; factorial(5) &lt;&lt; endl;<br/>120<br/>root [2] factorial(4)<br/>(int) 24<br/>root [3]</span></pre><h1 id="2958" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">定义和使用数组</h1><p id="650e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以在根shell中定义和使用数组。这里有一个例子:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c463" class="my lw it mu b gy mz na l nb nc">root [0] const int NUM_GRADES = 5;<br/>root [1] int grades[] = {81, 77, 85, 91, 72};<br/>root [2] int total = 0;<br/>root [3] for (int i = 0; i &lt; NUM_GRADES; i++) { total += grades[i]; }<br/>root [4] double average = static_cast&lt;double&gt;(total) / NUM_GRADES;<br/>root [5] std::cout &lt;&lt; "The average grade: " &lt;&lt; average &lt;&lt; endl;<br/>The average grade: 81.2<br/>root [6]</span></pre><p id="92d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过创建一个返回数组平均值的函数来改进这个程序:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ea52" class="my lw it mu b gy mz na l nb nc">root [0] double array_avg(int arr[], int num_elements) {<br/>root (cont'ed, cancel with .@) [1]int total = 0;<br/>root (cont'ed, cancel with .@) [2]for (int i = 0; i &lt; num_elements; i++) { total += arr[i]; }<br/>root (cont'ed, cancel with .@) [3]return static_cast&lt;double&gt;(total) / num_elements;<br/>root (cont'ed, cancel with .@) [4]}<br/>root [5] const int NUM_GRADES = 5;<br/>root [6] int grades[] = {91, 88, 77, 88, 71};<br/>root [7] double average = array_avg(grades, NUM_GRADES);<br/>root [8] std::cout &lt;&lt; "The average grade: " &lt;&lt; average &lt;&lt; endl;<br/>The average grade: 83<br/>root [9]</span></pre><h1 id="5c88" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的想法</h1><p id="7415" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在本文中，我向您介绍了如何使用根C++解释器外壳编写一些基本的C++结构。在我的下一篇文章中，我将扩展shell的使用，包括定义和使用类，以及使用标准模板库的各种元素。</p><p id="b6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>