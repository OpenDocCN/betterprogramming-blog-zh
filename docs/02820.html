<html>
<head>
<title>Asynchronous Data Loading With New Kotlin Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用新的Kotlin流进行异步数据加载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b?source=collection_archive---------3-----------------------#2020-01-03">https://betterprogramming.pub/asynchronous-data-loading-with-new-kotlin-flow-233f85ae1d8b?source=collection_archive---------3-----------------------#2020-01-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4823" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">然而另一个惊人的操作者，<strong class="ak">流·福</strong>罗·柯特林</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c3b16729b6a6780ffe2bb501a57d672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIbTWA96QnqAWyTu86uEeg.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="f086" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">协同程序</h1><p id="cd58" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">当我们调用一个异步函数时，比如服务调用、从数据库中检索数据、读取文件或其他任何东西，我们需要一个回调，这样我们就知道操作已经完成，我们可以继续实际的工作，比如手机在从服务器接收数据后更新用户界面。</p><p id="9817" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">是的，这很好，但在实时，它不会那么容易。</p><p id="ba00" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">例如，从服务器接收到数据后，如果您需要根据一些指标过滤数据，您需要对这些指标执行一些本地数据库操作，并且您还需要另一个回调，因此对于复杂的项目，该列表会继续下去，这会导致回调的激增。</p><p id="98aa" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">这就是协程真正强大的地方，有了协程，您不再需要为异步函数编写回调。</p><p id="1f8f" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">协程中有一个惊人的概念叫做<em class="mu"> suspend functions </em>，它可以完成你需要的所有工作，并以预期的数据类型返回数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">简单协程样本</p></figure><p id="7ead" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">这将把开发人员从回调地狱中解救出来，并以他们正在工作的正常格式专注于他们的业务逻辑。是不是很棒，这只是协程的概述。</p><p id="f423" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">使用协程，您可以异步执行，但也可以顺序执行。</p><p id="4792" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">在本文开始之前，请参考下面的链接来了解<a class="ae nb" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>中的协程。</p><div class="nc nd gp gr ne nf"><a href="https://medium.com/androiddevelopers/coroutines-on-android-part-i-getting-the-background-3e0e54d20bb" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">Android上的协同程序(第一部分):了解背景</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">协程解决什么问题？</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ks nf"/></div></div></a></div><div class="nc nd gp gr ne nf"><a href="https://medium.com/mindorks/synchronous-and-asynchronous-execution-in-kotlin-coroutines-with-error-and-exception-handling-1dd03b87f732" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">带错误和异常处理的Kotlin协同例程中的同步和异步执行</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">本文不是关于如何在kotlin中使用协程(尽管我将简要地涉及协程的概念，我们…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ks nf"/></div></div></a></div></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="9d5c" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">暂停功能</h1><p id="d960" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated"><em class="mu">暂停功能</em>只是一个可以暂停并在以后恢复的功能。他们可以执行长时间运行的操作，并等待它完成，而不会阻塞服务调用、数据库操作或读取长文件。</p><p id="7931" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">除了在开头添加了关键字<code class="fe nv nw nx ny b">suspend</code>之外，暂停函数的语法与常规函数的语法相似。</p><p id="bdf4" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">暂停函数的奇妙之处在于它可以返回任意数量的响应。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="ee88" class="od lc it ny b gy oe of l og oh"><strong class="ny iu">suspend </strong>fun getItem() : <strong class="ny iu">Response</strong><br/><strong class="ny iu">suspend </strong>fun getItems() : <strong class="ny iu">List&lt;Response&gt;</strong></span></pre><p id="7678" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">让我们看看这是如何工作的。</p><p id="6705" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">例如，我们有一个暂停函数<code class="fe nv nw nx ny b">foo</code> <strong class="lv iu"> </strong>，它返回一组响应，如下所示。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="0ccb" class="od lc it ny b gy oe of l og oh"><strong class="ny iu">suspend </strong>fun foo() : <strong class="ny iu">List&lt;Responses&gt;</strong> = buildlist{<br/>      add(Execute("A"))<br/>      add(Execute("B"))<br/>      add(Execute("C"))<br/>}</span></pre><p id="ce80" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">然后，您从您的流程中调用它，如下所示。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="bbbd" class="od lc it ny b gy oe of l og oh">fun getData() {<br/>    val list = withContext(Dispatchers.IO) <strong class="ny iu">{ foo() }<br/>    </strong>for (x in list) println(x)<br/>}</span></pre><p id="079b" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">这里发生的是，当你调用暂停函数<code class="fe nv nw nx ny b">foo</code>，<strong class="lv iu"> </strong>时，它开始一个接一个地执行，在完成所有的执行后，它将返回响应列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b6edb502097aec6e6dd8efd519f92c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u9ZYY3fip1_PhfqKHrC5eg.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">使用挂起功能执行请求列表</p></figure><p id="f1ab" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">因此，我们必须等到所有请求的执行都完成，这不是一个优化的解决方案。</p><p id="1682" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">我们可以做得更好，所以科特林团队找到的下一个解决方案是<em class="mu">频道</em>。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="c983" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">频道</h1><p id="463f" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">通道是结构化的管道，您在一端发送数据，在另一端接收数据，如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/e97368e893e708ca1c2ed79a1bcbd9b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yd84VhftIBEoeKKqTuB0lQ.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">频道工作方式概述</p></figure><p id="c4d1" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">要使用channels，需要修改一点代码，不用<code class="fe nv nw nx ny b">List&lt;Response&gt;</code> <strong class="lv iu"> </strong>作为返回类型，我们用<code class="fe nv nw nx ny b">ReceiveChannel&lt;Response&gt;</code>，不用<code class="fe nv nw nx ny b">buildlist</code> <strong class="lv iu"> </strong>，用<code class="fe nv nw nx ny b">produce</code> <strong class="lv iu">、</strong>代替<code class="fe nv nw nx ny b">addTo</code>，用<code class="fe nv nw nx ny b">send</code>代替。</p><p id="eb62" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">看一看:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="dfdb" class="od lc it ny b gy oe of l og oh"><strong class="ny iu">suspend </strong>fun foo() : <strong class="ny iu">ReceiveChannel&lt;Response&gt;</strong> = produce{<br/>      send(execute("A"))<br/>      send(xecute("B"))<br/>      send(Execute("C"))<br/>}</span></pre><p id="b3d5" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">然后，当在我们的流中使用它时，我们将接收通道而不是响应列表。然后，你迭代打印，看看:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="74a2" class="od lc it ny b gy oe of l og oh">fun getData() {<br/>    val chaannel = withContext(Dispatchers.IO) <strong class="ny iu">{ foo() }<br/>    </strong>for (x in channel) println(x)<br/>}</span></pre><p id="16e7" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">有什么区别吗？让我们看看。</p><p id="c6fa" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">当您调用<code class="fe nv nw nx ny b">foo</code> <strong class="lv iu"> </strong>函数时，它将创建一个通道并立即返回，但不会开始执行。现在我们有两个正在运行的协程。一个发射数据，另一个观察数据。</p><p id="7f68" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">当你在迭代过程中调用通道时，执行开始，它将执行第一个并返回响应，然后是第二个和其他类似的，看看有没有更好的主意:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/d964aa6f8c7ae2e313c0c16c51b91b1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCQu_rhJbzd8kiySMMSY7A.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">渠道工作流程</p></figure><p id="7a60" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">因此，通过使用通道，您不再需要等待完成所有的执行。但是这里有个问题，渠道热。</p><p id="df1d" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">还记得我之前说过有两个协程在运行，一个用来观察，另一个用来发出。如果没有观察者，无论是由于错误还是任何异常，该怎么办？</p><p id="ab94" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">你知道，通道就像打开一个网络连接或读取一个文件，使用昂贵的资源，如果没有观察者，连接将保持打开，寻找观察者。</p><p id="c122" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">我们可以解决这种事情，但从长远来看，情况并不乐观。从长远来看，它会在调试和测试中引起严重的问题。</p><p id="46ee" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">我们可以做得更好，对吧，这就是Kotlin概念流程的由来。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="111c" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">科特林流</h1><p id="3b1c" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">几天前发布了Flow的稳定版本。Flow不仅解决了渠道的痛点，还提供了许多新特性，您将在本文中看到。</p><p id="a728" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">要在上面的例子中使用Flow，我们只需要将返回类型改为<code class="fe nv nw nx ny b">Flow</code> <strong class="lv iu"> </strong>和用户<code class="fe nv nw nx ny b">flow</code> <strong class="lv iu"> </strong>而不是<code class="fe nv nw nx ny b">produce</code>。还有里面的流程，你得用<code class="fe nv nw nx ny b">emit</code>，看看:</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="0e9a" class="od lc it ny b gy oe of l og oh">fun foo() : <strong class="ny iu">Flow&lt;Response&gt;</strong> = flow{<br/>      emit(execute("A"))<br/>      emit(execute("B"))<br/>      emit(execute("C"))<br/>}</span></pre><p id="da0a" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">另一方面，在你的通用函数中，你必须对<code class="fe nv nw nx ny b">foo</code>的结果使用collect。<strong class="lv iu"> </strong>我们正在通过流收集<code class="fe nv nw nx ny b">foo</code>发出的所有元素。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="7c4f" class="od lc it ny b gy oe of l og oh">fun getData() {<br/>    val flowData = <strong class="ny iu">foo()<br/>    </strong>withContext(Dispatchers.IO) <strong class="ny iu">{ </strong>flowdata<strong class="ny iu">.collect</strong>{ println(x)<strong class="ny iu"> }<br/>}</strong></span></pre><p id="4d8e" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">这里发生的是当你调用<code class="fe nv nw nx ny b">foo</code>，<strong class="lv iu"> </strong>时，它立即返回流对象，但不会开始执行。</p><p id="7f77" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">当您开始收集流时，它开始执行，并执行一个请求。它返回结果，然后开始下一个，直到没有了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c3b16729b6a6780ffe2bb501a57d672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIbTWA96QnqAWyTu86uEeg.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">流程执行</p></figure><p id="d31e" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">它类似于通道，发射数据，接收到没有为止，但很大的区别是流量是冷的。即使没有观察者，不管是错误的还是有意的，协程也不会抓住它不放，因为它没有启动任何东西。</p><p id="481c" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">与等待完成整个请求列表不同，Flow通过在完成当前执行后发出结果，为您的功能提供了一种反应行为。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="4050" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">流程是声明性的</h1><p id="1712" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">当我们调用<code class="fe nv nw nx ny b">flow</code> <strong class="lv iu"> </strong>示例中的<code class="fe nv nw nx ny b">foo</code>函数时，所发生的是它创建一个流并返回它，所以我们可以使用一些类似<code class="fe nv nw nx ny b">map</code> <strong class="lv iu"> </strong>的操作符来使流更具声明性，如下所示。</p><pre class="kj kk kl km gt nz ny oa ob aw oc bi"><span id="37ca" class="od lc it ny b gy oe of l og oh">fun foo() : <strong class="ny iu">Flow&lt;Response&gt;</strong> = <br/>    flowOf("A","B","C").map{ name-&gt;<br/>      execute(name)<br/>    }<br/>}</span></pre><p id="bddb" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">在这里，如果你观察一下，函数<code class="fe nv nw nx ny b">foo</code> <strong class="lv iu"> </strong>并不是一个暂停函数。为什么？</p><p id="59f1" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">正如我前面说过的，它只定义流对象，然后立即发出它，并且只在它开始收集时才计算或运行。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="46be" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">流动是反应性的</h1><p id="3417" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">通过阅读这个标题，许多开发人员会想到<a class="ae nb" href="https://github.com/ReactiveX/RxJava" rel="noopener ugc nofollow" target="_blank"> RxJava </a>。是的，RxJava是JVM中一种反应式程序的开端，Kotlin主要在其中运行。</p><h2 id="3c53" class="od lc it bd ld ol om dn lh on oo dp ll mc op oq ln mg or os lp mk ot ou lr ov bi translated">为什么流动？</h2><p id="c9c7" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">我们仔细看看，比如你想在RxJava中把任何一个A类型的对象转换成B类型，我们有一个操作符叫做<code class="fe nv nw nx ny b">map</code>。</p><p id="4d3e" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">是的，它工作得很好，但是如果转换应该异步完成，那么我们必须使用另一个叫做<code class="fe nv nw nx ny b">flatmapSingle</code>的操作符。</p><p id="2189" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">但是在Kotlin中，我们有一个操作符叫做<code class="fe nv nw nx ny b">map</code>，<strong class="lv iu"> </strong>这个操作符的转换lambda是suspend修饰符，它使得<code class="fe nv nw nx ny b">map</code>在同步和异步作业中都可用。</p><p id="b515" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">我们可以通过使用Kotlin来避免数百个这样的操作符，因为Kotlin有RxJava和其他人没有的suspend函数，因为它们不是在Kotlin中开发的。</p><p id="43a2" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">在我们总结之前，本文中提到和解释的每个概念都来自于2019年<strong class="lv iu"> KotlinConfig </strong>的<strong class="lv iu"> Roman Elizarov </strong>的一次演讲。如果您感兴趣，请点击下面的链接观看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow mw l"/></div></figure><p id="34ad" class="pw-post-body-paragraph lt lu it lv b lw mp ju ly lz mq jx mb mc mr me mf mg ms mi mj mk mt mm mn mo im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>