<html>
<head>
<title>Validate Zero Enum Value in Protocol Buffer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">验证协议缓冲区中的零枚举值</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/validate-zero-enum-value-in-protocol-buffer-dbed0d9ecac4?source=collection_archive---------10-----------------------#2022-03-02">https://betterprogramming.pub/validate-zero-enum-value-in-protocol-buffer-dbed0d9ecac4?source=collection_archive---------10-----------------------#2022-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7038" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">如何验证Protobuf消息不包含零值枚举字段？原来Protobuf并不直接支持这个功能！我们需要研究如何实现包</em> <code class="fe kg kh ki kj b"><em class="kf">protojson </em></code> <em class="kf">。</em></h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/ec3ea68bdbfbdd69699f5d9ffb910b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YFbivYHNDrR16jZT"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@goran_ivos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Goran Ivos </a>在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2b7f" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">越来越多的公司采用带有<a class="ae la" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> Protobuf </a>的gRPC进行内部服务之间的通信。它的好处是高性能，支持多种编程语言，并得到谷歌的支持，周围有一个巨大的生态系统。</p><p id="0306" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">为了与前端和外部服务通信，Protobuf可以被封送到JSON格式。浏览器只理解JSON格式，我们不能指望其他公司直接从我们这里消费Protobuf。<em class="lx">(当然可以，如果你够大</em><a class="ae la" href="https://github.com/googleapis/googleapis" rel="noopener ugc nofollow" target="_blank"><em class="lx"/></a><em class="lx">！)</em></p><h1 id="2922" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">让我们谈谈enum以及我们最近在使用它时遇到的一些问题。</h1><p id="5237" class="pw-post-body-paragraph lb lc iq ld b le mq jr lg lh mr ju lj lk ms lm ln lo mt lq lr ls mu lu lv lw ij bi translated"><em class="lx">样本代码写在Go中。</em></p><p id="2e75" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">从Protobuf <a class="ae la" href="https://developers.google.com/protocol-buffers/docs/style#enums" rel="noopener ugc nofollow" target="_blank">样式指南</a>中，零值枚举应该有后缀<code class="fe kg kh ki kj b">UNSPECIFIED</code>。这是因为enum被实现为一个<code class="fe kg kh ki kj b">uint32</code>，并且值<code class="fe kg kh ki kj b">0</code>也被认为是未指定的。对于消息或空字符串，它类似于<code class="fe kg kh ki kj b">nil</code>。将Protobuf编码为JSON时，会忽略<code class="fe kg kh ki kj b">nil</code>消息、<code class="fe kg kh ki kj b">UNSPECIFIED</code>枚举或空字符串。</p><p id="3803" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">我们一直在遵循这个惯例，直到有一天，我们没有。</p><p id="32b7" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">当发送外部webhook消息时，我们决定不使用<code class="fe kg kh ki kj b">0</code>作为<code class="fe kg kh ki kj b">UNSPECIFIED</code>。一个原因是，我们使用<code class="fe kg kh ki kj b">EmitUnpopulated: true</code>来确保在向外部发送webhook消息时，所有字段都包含在JSON表示中。如果我们忘记将enum字段设置为0，我们不希望<code class="fe kg kh ki kj b">UNSPECIFIED</code>值出现在webhook消息中。单元测试不能捕捉所有的错误；我们工程师知道这一点。</p><p id="5a47" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">这导致了很多麻烦，所以我们不得不恢复并再次将值<code class="fe kg kh ki kj b">0</code>设为<code class="fe kg kh ki kj b">UNSPECIFIED</code>。一个问题是，它迫使到处使用<code class="fe kg kh ki kj b">EmitUnpopulated: true</code>！有些地方，我们不想发射所有未填充的场。比如调用一些第三方API。一些消息混杂在<code class="fe kg kh ki kj b">UNSPECIFIED</code>枚举和非<code class="fe kg kh ki kj b">UNSPECIFIED</code>枚举之间；没有办法发送正确的格式。用<code class="fe kg kh ki kj b">EmitUnpopulated: true</code>，第三方API不懂<code class="fe kg kh ki kj b">UNSPECIFIED</code>；使用<code class="fe kg kh ki kj b">EmitUnpopulated: false</code>并省略一些非<code class="fe kg kh ki kj b">UNSPECIFIED</code>枚举的必填字段。当然，它们都可以被重构掉，但在开始时强制使用<code class="fe kg kh ki kj b">UNSPECIFIED</code>应该更简单。</p><h1 id="623d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">那么，为什么不验证webhook消息中的所有enum字段都没有设置为0呢？你可能会问。</h1><p id="3a49" class="pw-post-body-paragraph lb lc iq ld b le mq jr lg lh mr ju lj lk ms lm ln lo mt lq lr ls mu lu lv lw ij bi translated">原来在Protobuf 3中没有简单方法可以做到这一点！</p><p id="8939" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">在Protobuf 2中，有一个<code class="fe kg kh ki kj b"><a class="ae la" href="https://developers.google.com/protocol-buffers/docs/proto#specifying-rules" rel="noopener ugc nofollow" target="_blank">required</a></code> <a class="ae la" href="https://developers.google.com/protocol-buffers/docs/proto#specifying-rules" rel="noopener ugc nofollow" target="_blank">选项</a>来防止一个字段被取消设置。这个选项在Protobuf 3中被移除了，因为它阻止了移除字段的重构。如果我们忘记更新每个服务来删除不再使用的<code class="fe kg kh ki kj b">required</code>字段，特别是在一个有多个团队一起工作的公司中，消息会被无意地丢弃。最好不要提前要求。(<a class="ae la" href="https://developers.google.com/protocol-buffers/docs/proto#specifying-rules" rel="noopener ugc nofollow" target="_blank"> <em class="lx">更有</em> </a>)</p><p id="c1e9" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">Protobuf 3中有<code class="fe kg kh ki kj b"><a class="ae la" href="https://pkg.go.dev/github.com/golang/protobuf/jsonpb#JSONPBMarshaler" rel="noopener ugc nofollow" target="_blank">jsonpb.JSONPBMarshaler</a></code> <a class="ae la" href="https://pkg.go.dev/github.com/golang/protobuf/jsonpb#JSONPBMarshaler" rel="noopener ugc nofollow" target="_blank">接口</a>。我们可以简单地为所有枚举实现接口，以便在看到零值时返回错误。不过还是那句话，被撤了！作为一个协议，我们应该尽可能地减少定制。否则，定制将不得不在不同的团队中以不同的语言实现和维护！</p><h1 id="41db" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">那么，如何验证枚举字段中的零值呢？</h1><p id="481e" class="pw-post-body-paragraph lb lc iq ld b le mq jr lg lh mr ju lj lk ms lm ln lo mt lq lr ls mu lu lv lw ij bi translated">我们必须到达反射包。<code class="fe kg kh ki kj b"><a class="ae la" href="https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect#Message" rel="noopener ugc nofollow" target="_blank">protoreflect.Message</a></code>接口有<code class="fe kg kh ki kj b">Range()</code>方法来迭代每个填充的字段。我们可以使用该方法来验证没有带有零的枚举字段…哦，等等。它只迭代<em class="lx">填充的字段</em>。所以它不会检测enum中的零值！</p><p id="2266" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">但是函数<code class="fe kg kh ki kj b"><a class="ae la" href="https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson#Marshal" rel="noopener ugc nofollow" target="_blank">protojson.Marshal()</a></code>仍然可以通过<code class="fe kg kh ki kj b"><a class="ae la" href="https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson#MarshalOptions" rel="noopener ugc nofollow" target="_blank">EmitUnpopulated</a></code> <a class="ae la" href="https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson#MarshalOptions" rel="noopener ugc nofollow" target="_blank">选项</a>发出未填充的字段。它是如何实现的？深入到<code class="fe kg kh ki kj b"><a class="ae la" href="https://pkg.go.dev/encoding/json" rel="noopener ugc nofollow" target="_blank">encoding/protojson</a></code>，有一段代码片段用于迭代<em class="lx">未填充的字段</em> ( <a class="ae la" href="https://github.com/protocolbuffers/protobuf-go/blob/master/encoding/protojson/encode.go#L174-L197" rel="noopener ugc nofollow" target="_blank"> <em class="lx">来源</em> </a>)。我们去偷吧:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="89bf" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">上面的代码所做的是通过循环遍历<code class="fe kg kh ki kj b">protoreflect.Message.Descriptor().Fields()</code>来迭代额外的字段。跳过<code class="fe kg kh ki kj b">oneof</code>字段内的字段。未填充的单数<code class="fe kg kh ki kj b">message</code>字段在被发送到输入函数之前被设置为<code class="fe kg kh ki kj b">invalid</code>(在生成的JSON中将它视为<code class="fe kg kh ki kj b">null</code>)。</p><p id="6264" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">尽管如此，还有一些代码要写，比如实现一个遍历所有不同Protobuf类型的方法:消息、数组(重复)、动态<a class="ae la" href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Struct" rel="noopener ugc nofollow" target="_blank">结构</a>，当然还有枚举。但是是可以解决的。我现在可以休息了。</p><p id="ba4a" class="pw-post-body-paragraph lb lc iq ld b le lf jr lg lh li ju lj lk ll lm ln lo lp lq lr ls lt lu lv lw ij bi translated">感谢阅读！</p><pre class="kl km kn ko gt mx kj my mz aw na bi"><span id="e844" class="nb lz iq kj b gy nc nd l ne nf"><strong class="kj ir">Want to Connect?</strong></span><span id="4704" class="nb lz iq kj b gy ng nd l ne nf">Also published at <a class="ae la" href="https://olvrng.github.io/w/proto.enum/" rel="noopener ugc nofollow" target="_blank">my blog</a>. Follow me on <a class="ae la" href="https://twitter.com/olvrng" rel="noopener ugc nofollow" target="_blank">Twitter</a> for more.</span></pre></div></div>    
</body>
</html>