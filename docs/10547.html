<html>
<head>
<title>Memory Leaks 101: The Essential Guide to Detecting and Fixing Them in Your Web App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内存泄漏101:检测和修复Web应用程序中内存泄漏的基本指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-memory-leaks-390957523a9e?source=collection_archive---------2-----------------------#2022-01-14">https://betterprogramming.pub/javascript-memory-leaks-390957523a9e?source=collection_archive---------2-----------------------#2022-01-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="818d" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">通过编写优化的代码和使用Chrome DevTools来提升你的web应用程序的性能</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/66e6aa9c4095e6b8acee871cc1e1be6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9mOORxAoUeL6SpRnbh2YNQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">来自<a class="ae kz" href="https://www.pexels.com/photo/photo-of-gray-faucet-2339722/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>的<a class="ae kz" href="https://www.pexels.com/@jibarofoto?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">路易斯·金特罗</a>的照片</p></figure><p id="9cb9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">如果你喜欢观看，你可以在这里查看</em> <a class="ae kz" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks" rel="noopener ugc nofollow" target="_blank"> <em class="lw">我的视频课程</em> </a> <em class="lw">其中包含了更多关于JavaScript内存泄漏的细节。</em></p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="5dae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它无辜地坐在那里。</p><p id="1e39" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，它继续吞噬你越来越多的宝贵资源。</p><p id="38c6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它开始慢下来，让你沮丧不已。你只想尽快完成你的任务。因此，你不是按你面前的按钮一次，而是“按100次，因为，当然，这样会让它走得更快<em class="lw">。</em></p><p id="5361" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你的Chrome表现不一样。它的耐心耗尽了，它只是崩溃标签，并向你展示著名的"<em class="lw">啊，啪！</em>”页。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj me"><img src="../Images/e9df3610b5369355858edeec9a3583c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*crsUudD8DTDiAZblhVrVrQ.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Chrome浏览器“哇，啪！”页面(作者截图)</p></figure><p id="f70e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你不能相信你的眼睛。你在表格中输入的所有数据都永远消失了。</p><p id="8ab0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你哭泣，因为你不明白为什么你的会议以这种方式结束。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><p id="2509" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果这种情况发生在你身上，那是因为你在浏览器上打开了一个不整洁的网页。这个应用程序编码很差，最终会占用你有限的内存。换句话说，它遇到了内存泄漏。</p><p id="6a67" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们来解决这个问题，好吗？</p><p id="700f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章中，我们将看到如何有效地跟踪内存泄漏，并了解导致它们的原因。您将深入了解如何更加尊重最终用户设备的资源。你也可以避免这样的情况:你揪着自己的头发，试图了解自己的表现。</p><blockquote class="mf"><p id="4677" class="mg mh iu bd mi mj mk ml mm mn mo lv dk translated">"一盎司的预防抵得上一磅的治疗."</p></blockquote><pre class="mp mq mr ms mt mu mv mw mx aw my bi"><span id="4c5f" class="mz na iu mv b gz nb nc l nd ne"><strong class="mv iv">Table of Contents</strong></span><span id="0142" class="mz na iu mv b gz nf nc l nd ne"><a class="ae kz" href="#ee7c" rel="noopener ugc nofollow">What's a Memory Leak?</a><strong class="mv iv"><br/></strong><a class="ae kz" href="#4125" rel="noopener ugc nofollow">A Brief History</a><br/>   ∘ <a class="ae kz" href="#4513" rel="noopener ugc nofollow">The beginning of the web performance story</a><br/>   ∘ <a class="ae kz" href="#cea3" rel="noopener ugc nofollow">The rise of JavaScript memory leaks issue</a><strong class="mv iv"><br/></strong><a class="ae kz" href="#2fb0" rel="noopener ugc nofollow">2 Types of Web Performance Problems</a><br/>   ∘ <a class="ae kz" href="#f8ae" rel="noopener ugc nofollow">Type 1: Directly after calling a web app on the browser</a><strong class="mv iv"> </strong><br/>   ∘ <a class="ae kz" href="#afe9" rel="noopener ugc nofollow">Type 2: After a long session — Runtime performance</a><strong class="mv iv"><br/></strong><a class="ae kz" href="#9eb1" rel="noopener ugc nofollow">Signs that Your App Is Leaking Memory</a><br/><a class="ae kz" href="#3516" rel="noopener ugc nofollow">Identifying Memory Leaks with Chrome DevTools</a><br/>   ∘ <a class="ae kz" href="#1609" rel="noopener ugc nofollow">Performance Timeline Record</a><br/>   ∘ <a class="ae kz" href="#7bd0" rel="noopener ugc nofollow">Heap Snapshots</a><br/>   ∘ <a class="ae kz" href="#42f1" rel="noopener ugc nofollow">Heap Profile</a><strong class="mv iv"><br/></strong><a class="ae kz" href="#8d06" rel="noopener ugc nofollow">7 Coding Patterns that Leak JS Memory</a><br/>   ∘ <a class="ae kz" href="#4c72" rel="noopener ugc nofollow">Global Variables</a><br/>   ∘ <a class="ae kz" href="#164e" rel="noopener ugc nofollow">Cache</a><br/>   ∘ <a class="ae kz" href="#f56f" rel="noopener ugc nofollow">Collections</a><br/>   ∘ <a class="ae kz" href="#0ac3" rel="noopener ugc nofollow">Event Listeners</a><br/>   ∘ <a class="ae kz" href="#3574" rel="noopener ugc nofollow">Timers</a><br/>   ∘ <a class="ae kz" href="#fb3d" rel="noopener ugc nofollow">Closures</a><br/>   ∘ <a class="ae kz" href="#98df" rel="noopener ugc nofollow">Infinite and Detached DOM</a><br/><a class="ae kz" href="#8f27" rel="noopener ugc nofollow">Final Thought</a></span></pre><h1 id="ee7c" class="ng na iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">什么是内存泄漏？</h1><p id="7ab1" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">内存泄漏是指不正确的资源分配管理，它会导致性能下降，因为计算机程序不会释放它不再需要的内存。相反，它在运行时会不断消耗越来越多的内存。</p><p id="adb5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">几乎每种编程语言的内存生命周期都是这样工作的:<strong class="lc iv">分配内存</strong>，<strong class="lc iv">使用内存</strong>，<strong class="lc iv">释放内存</strong>。</p><p id="c8bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">JavaScript内存泄漏是偷偷摸摸的，很难定位，因为它们可能在一段时间内不被注意到。即使您的性能越来越差，在运行泄漏的应用程序时，您也不会在浏览器上看到抛出的错误，因为导致内存泄漏的不是无效代码，而是其中的逻辑缺陷。</p><h1 id="4125" class="ng na iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">简史</h1><h2 id="4513" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">web性能故事的开始</h2><blockquote class="on oo op"><p id="e2f7" class="la lb lw lc b ld le jv lf lg lh jy li oq lk ll lm or lo lp lq os ls lt lu lv in bi translated">“直到2004年，随着高速互联网连接和电子商务网站(通常带有精心制作的过度Flash动画介绍)开始主导数字市场，高速网站和商业收入<em class="iu"> </em>之间的关系变得足够明显，以至于一些绩效工程师，如谷歌的<a class="ae kz" href="http://www.igvita.com/" rel="noopener ugc nofollow" target="_blank">伊利亚·格里戈利克</a>和雅虎的<a class="ae kz" href="http://stevesouders.com/" rel="noopener ugc nofollow" target="_blank">史蒂夫·索德斯</a>，开始积极宣传这个话题的重要性。</p><p id="3313" class="la lb lw lc b ld le jv lf lg lh jy li oq lk ll lm or lo lp lq os ls lt lu lv in bi translated">到2007年初iPhone年——Souders开始谈论和写博客，他称之为“网络性能”,在那年晚些时候出版了一本名为<em class="iu">高性能网站</em>的书，并在2008年共同创立了Velocity，这是一个致力于该主题的流行会议系列。"</p><p id="362a" class="la lb lw lc b ld le jv lf lg lh jy li oq lk ll lm or lo lp lq os ls lt lu lv in bi translated">— <a class="ae kz" href="https://smartbear.com/learn/performance-monitoring/what-is-website-monitoring/" rel="noopener ugc nofollow" target="_blank">智能熊</a></p></blockquote><h2 id="cea3" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">JS内存泄漏问题的兴起</h2><p id="f74e" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">在智能手机发布和移动应用普及之后，网络开发者受到了启发，开始改变他们设计和构建网页的方式。</p><p id="c9bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很久以前，web开发领域被使用诸如Java/JSP、PHP、ASP和Ruby等服务器端技术的<em class="lw">多页面应用(MPAs) </em>所主宰。因此，我们称它们为服务器渲染应用<strong class="lc iv">。</strong></p><p id="9804" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当时一个正常的网站，实际上是一个MPA。它通过在客户端和服务器之间发出多个请求来工作:网站的每个页面都向服务器发送一个请求，并完全<em class="lw">更新所有数据</em>。</p><ul class=""><li id="71e1" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv oy oz pa pb bi translated">2004年，web开发人员对AJAX <strong class="lc iv"> </strong>(异步JavaScript和XML)越来越感兴趣，它允许更新网页而无需重新加载。这种方法为<em class="lw"> SPA(单页面应用)</em>铺平了道路。</li><li id="1214" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">2009年发布的Backbone.js 提供了一个轻量级的客户端框架。</li><li id="bf7e" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">大约在2010年，<a class="ae kz" href="https://angularjs.org/" rel="noopener ugc nofollow" target="_blank"> AngularJS </a>提出了客户端模型-视图-控制器(MVC)架构、双向数据绑定、模板和依赖注入等特性，成为第一个真正的SPA框架。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ph"><img src="../Images/9a3ed32bf96cf4a150a396aed2f36d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pSkTz2iDfztC9fdj_XxXA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">单页应用(SPA) vs多页应用(MPA) ( <a class="ae kz" href="https://asperbrothers.com/blog/spa-vs-mpa/" rel="noopener ugc nofollow" target="_blank">图片来源</a>:作者编辑)</p></figure><p id="4336" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">单页应用程序不是加载整个新页面，而是通过用新数据更新当前网页来与用户交互的web应用程序。这使得网站感觉更像一个本地应用程序，并提供更好的交互性。</p><p id="1540" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在SPA中，页面永远不会刷新，因为架构的安排方式是，当您转到一个新页面时，只有一部分内容被更新。所有必要的HTML、JavaScript、CSS代码和资源要么由浏览器在<a class="ae kz" href="https://levelup.gitconnected.com/load-time-performance-metrics-5a105b190665" rel="noopener ugc nofollow" target="_blank">初始加载</a>时检索，要么动态添加到页面以响应用户动作。</p><p id="ae03" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这提供了更流畅的用户体验，因为内容似乎可以立即加载，几乎不需要等待时间。</p><p id="fdd3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，从构建服务器呈现的网站到客户端呈现的spa和类似应用程序的行为的转变需要更多地关注用户设备上的资源，这为新一类问题打开了大门，这些问题在以前的模式中并不存在，例如:</p><ul class=""><li id="1310" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv oy oz pa pb bi translated">耗尽手机电池。</li><li id="156e" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">让笔记本电脑的风扇旋转。</li><li id="ca41" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">阻塞用户界面线程。</li></ul><p id="22fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于老式的网页(MPAs)，我们可能不会看到内存管理不足的严重后果，因为每次在页面之间导航时，都会加载新的页面，浏览器会清除内存。</p><p id="6edb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是自从SPA兴起以来，我们需要更加关注与内存相关的JS编码实践，因为它们会严重影响性能，甚至导致浏览器的tab崩溃。</p><h1 id="2fb0" class="ng na iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">Web性能问题的类型</h1><p id="3f86" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">网络表演有很多种。为了简化事情，让我们考虑两种类型。</p><h2 id="f8ae" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">类型1:直接在调用网页后</h2><p id="60ee" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果您的web应用程序需要很长时间才能加载，或者在完成加载后性能很差，就像下面的例子显示了Chrome Lighthouse上的一些结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pi"><img src="../Images/df9ea5c7d1f65353249cfc9560337cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WAd2f7rDv8Ly0co0.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Lighthouse在Chrome DevTools中测量的糟糕性能示例(图片由<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/angular-onpush-change-detection-f629cbce0bfa">作者</a>提供)</p></figure><p id="c408" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这并不意味着您有内存泄漏。这表明您应该采取以下一项或多项措施来优化性能:</p><ul class=""><li id="695c" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv oy oz pa pb bi translated">将大的组件和JS/TS文件拆分成较小的组件。</li><li id="8381" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">删除不用的文件和死代码。</li><li id="901b" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">通过使用记忆和缓存等技术来减少HTTP请求的数量。</li><li id="4c0c" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">使用<code class="fe pj pk pl mv b">webpack-bundle-analyzer</code>来分析你的捆绑包，确定一些庞大的第三方库是否值得使用。</li></ul><h2 id="afe9" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">类型2:长时间会话后—运行时性能</h2><p id="62d6" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果您注意到在很长一段时间没有重新加载(使用F5)的情况下玩网页后性能下降，这可能是内存泄漏的迹象。</p><p id="c395" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">识别内存泄漏的来源并修复它将通过减少最终用户花费的时间来优化运行时性能。它允许他们完成一些场景，同时减少会话期间消耗的资源数量。</p><h1 id="9eb1" class="ng na iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">您的应用程序正在泄漏内存的迹象</h1><p id="ea24" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">您可能不知道是您导致了内存泄漏，直到它们在生产中出现并最终造成严重破坏。</p><p id="75df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是识别它的常见模式:</p><ol class=""><li id="407f" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv pm oz pa pb bi translated">速度变慢:在长时间(可能是几个小时，甚至一天)使用应用程序后，UI变得更慢，反应迟钝。</li><li id="387b" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">网页崩溃。</li><li id="2eab" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">应用程序经常暂停。</li><li id="efb4" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">JS堆结束时比开始时高。</li><li id="03d0" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">您会看到节点大小和/或侦听器大小不断增加。</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pn"><img src="../Images/2f18a4eec63b725d9a097e16f241127e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQ1zXk4IC0JhqrGXgejiLA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">JS堆和节点大小结束时比开始时高(<a class="ae kz" href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</p></figure><h1 id="3516" class="ng na iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">使用Chrome DevTools识别内存泄漏</h1><p id="a67a" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">要检查上述最后两个内存泄漏的迹象，可以使用Chrome DevTools。</p><h2 id="1609" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">绩效时间表记录</h2><p id="e585" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">性能时间线记录帮助您找到影响页面性能的内存问题，例如频繁的垃圾收集、内存膨胀和内存泄漏。</p><p id="791d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要制作这张唱片:</p><ol class=""><li id="fe9c" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv pm oz pa pb bi translated">打开DevTools上的性能面板，</li><li id="1229" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">然后启用内存复选框，</li><li id="45c6" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">并做记录。</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj po"><img src="../Images/8cdb0b5e632db7a22d751170bc2cf0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*VWYtpGoJAGcwZakhEB0hMg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">chrome DevTools上的性能时间线记录(截图来自<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/build-me-an-angular-app-with-memory-leaks-please-36302184e658">作者</a></p></figure><p id="b2f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">单击开始按钮后，您需要使用应用程序:多次打开一些视图或对话框，创建新项目，删除或更新一些项目，在一些表单中输入数据，多次单击按钮。</p><p id="ef9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">停止记录，等待直到您看到结果，结果可能类似于下面的结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pp"><img src="../Images/49b71424bf81d4e45962c0d1f2e9d30a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPypRPXytEKX8oaewOcEBA.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">演出时间线记录(截图由<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/build-me-an-angular-app-with-memory-leaks-please-36302184e658">作者</a>)</p></figure><p id="8151" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以通过以下方式细分该性能时间线记录中的内存使用情况:</p><ul class=""><li id="6604" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv oy oz pa pb bi translated">JS堆(蓝线):代表JavaScript需要的内存。在这个例子中，它结束时比开始时高(表示内存泄漏)。</li><li id="33ce" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">文件(红线)</li><li id="ee69" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">DOM节点(绿线):结束时比开始时高(表示内存泄漏)。</li><li id="118f" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">Listeners(黄线):结束时比开始时高(表示内存泄漏)。</li></ul><p id="fad8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">垂直的蓝色线条是<em class="lw">频繁上升和下降的</em> JS堆，这意味着频繁的垃圾收集，对于性能来说也不是一个好兆头。</p><h2 id="7bd0" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">堆快照</h2><p id="1efb" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">Chrome DevTools的另一个特性是内存面板。它让您可以拍摄连续的堆快照，并对它们进行比较，以了解您的网页已经分配和消耗了多少内存，以及它是如何在JavaScript对象、原语、字符串、函数、DOM节点等之间分配的。</p><ol class=""><li id="0ebf" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv pm oz pa pb bi translated">打开DevTools上的内存面板。</li><li id="9a84" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">启用堆快照复选框。</li><li id="b110" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">点击“拍摄快照”按钮。等待几秒钟，直到“快照1”准备就绪。</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="ab gv cl pq"><img src="../Images/ab76cb349d1b60a3ba6bfedd18f9116b.png" data-original-src="https://miro.medium.com/v2/format:webp/1*JRqQIkI3zOGf68newjQ6Lg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Chrome DevTools:堆快照(截图由<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/build-me-an-angular-app-with-memory-leaks-please-36302184e658">作者</a>提供)</p></figure><p id="2f20" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">4.玩你的网络应用。</p><p id="f050" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">5.然后单击“拍摄堆快照”图标拍摄第二张快照。如果第二个记录的快照比第一个大，并且接下来的记录继续具有增加的模式，这可能是由内存泄漏引起的。</p><p id="d6cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">6.点击“总结”，然后点击“比较”以查看不同之处。</p><ul class=""><li id="11a9" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv oy oz pa pb bi translated">列“# New”显示了第二个快照中分配的对象:新数组、闭包、事件发射器、主题等等。</li><li id="701e" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">列“# Deleted”显示已删除的对象。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pr"><img src="../Images/cf749ef9a889d74760a66a7f2e93ab5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbHMWR1hIPAN82DmJUSeKw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">比较两个堆快照(截图来自<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/build-me-an-angular-app-with-memory-leaks-please-36302184e658">作者</a></p></figure><h2 id="42f1" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">堆配置文件</h2><p id="aa3d" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果我没有提到您也可以从DevTools内存面板中的堆配置文件中受益来跟踪内存分配，那我就失职了。</p><ol class=""><li id="1187" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv pm oz pa pb bi translated">打开DevTools。</li><li id="ec74" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">转到内存面板。</li><li id="1cdb" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">选择单选按钮“时间线上的分配工具”</li><li id="5740" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv pm oz pa pb bi translated">按下按钮“开始记录堆配置文件”</li></ol><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ps"><img src="../Images/e191b8f2368c3222dec1286ce67e8fdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*77bs6fG7tLaJfGBgC0kzPw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Chrome DevTools:记录堆配置文件(作者截图)</p></figure><p id="b97e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">5.使用您的应用程序，执行您怀疑导致内存泄漏的场景或操作。</p><p id="a08f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">6.然后按下红色圆圈按钮“停止录制”</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pp"><img src="../Images/1b8b8b00c27819709af07c0b729e0bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PBfYT75G6dAJXbCTmMSokQ.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在chrome DevTools的内存面板上使用“时间线上的分配工具”(截图来自<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/build-me-an-angular-app-with-memory-leaks-please-36302184e658">作者</a>)</p></figure><p id="8804" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">垂直的蓝色线条代表一些JS对象的内存分配。蓝色线<em class="lw">过一会儿</em>不消失，变成灰色线，代表已经分配但没有释放的内存。</p><p id="b30c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以用鼠标选择这样一行，以查看有关它的更多详细信息。</p><h1 id="8d06" class="ng na iu bd nh ni nj nk nl nm nn no np ka nq kb nr kd ns ke nt kg nu kh nv nw bi translated">JavaScript中泄漏内存的7种编码模式</h1><p id="20c4" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果你让我用一个词来总结泄漏的主要原因，那就是<em class="lw">不需要的引用</em>。</p><p id="5342" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您有一些不需要的对象、元素或变量，但是它们仍然可以从您的应用程序的某些部分访问到，JS垃圾收集器将无法清除它们，因为它不会触及被引用的内存。</p><p id="3695" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好消息是，如果您知道要寻找什么，甚至在部署之前，您就可以在源代码中捕获产生这种场景的模式。以下是七种可能导致泄漏的常见编码模式:</p><h2 id="4c72" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">1.全局变量</h2><p id="2aae" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">全局变量可以从根访问，不会被垃圾收集。</p><p id="d470" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你没有使用<code class="fe pj pk pl mv b">strict</code>模式，你给一个未声明的变量赋值，你会使它成为全局变量。但是不要担心，如果你使用的是<a class="ae kz" href="https://javascript.plainenglish.io/node-js-esm-npm-yarn-deep-dive-adda15dabce#99c0" rel="noopener ugc nofollow" target="_blank"> EcmaScript </a> 5或更高版本，你不需要像以前那样自己在源代码中写<code class="fe pj pk pl mv b">use strict</code>。ES5会帮你做，防止你这种意外泄露。</p><p id="fa6d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">像<a class="ae kz" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>这样的全球商店是全球变量的一个很好的例子。如果你不小心的话，你可以处理大量的信息，并不断地向你的存储器中添加内存，而它永远不会被清理掉。</p><p id="fdec" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你的全局变量存储了大量的数据，当不需要的时候，考虑将它们清空或者重新分配。</p><h2 id="164e" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">2.隐藏物</h2><p id="70fc" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">增加内存消耗的另一个常见原因是在缓存中存储重复使用的数据。</p><p id="017e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当从细节导航到列表视图时，我们更喜欢从缓存中获取数据，而不是每次都请求服务器。底层数据会每10秒更新一次。</p><p id="4c77" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一种快得多的方法，<strong class="lc iv"> </strong>节省了整个网络的往返行程。它改善了用户体验，尤其是当最终用户使用慢速网络或带宽受限的设备时。</p><p id="27b7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，和金钱一样，我们需要节约。</p><p id="4f65" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们继续将对象追加到缓存中，而不清除未使用的对象，并且没有一些限制大小的逻辑，缓存将无限制地增长，导致高内存消耗。这是警钟应该响起的地方。缓存大小必须有一个上限。</p><h2 id="f56f" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">3.收集</h2><p id="827a" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果您使用DevTools为几个web应用程序拍摄堆快照，并检查它们的内存是如何分配的，您可能会注意到数组和字符串的大小非常小。</p><p id="81cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与保留大小不同，保留大小指的是删除对象及其依赖对象后释放的内存，浅大小指的是仅由对象本身持有的内存大小。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pt"><img src="../Images/7ad4a02d76a07e79dc11158fb9026e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*FwULTO6E9qwKku0p"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从内存图的根不可到达的所有对象都被垃圾收集。(<a class="ae kz" href="https://developer.chrome.com/docs/devtools/memory-problems/memory-101/" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</p></figure><p id="747f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在下面的示例中，您可以看到堆快照的大小增加了大约100MB，这主要是由类型化数组(超过90MB)和JS数组(大约3MB)引起的。</p><p id="5fab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv"> <em class="lw">注意:</em> </strong> <em class="lw"> JavaScript的类型化数组是类似数组的对象，允许你在内存缓冲区中读写原始的二进制数据。</em></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj pu"><img src="../Images/6560cdabb5a3ebb7ac914dc44042c335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*X0oaGUR7pTQP8hiPze3gCg.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在堆快照中保存超过90MB的类型数组(<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/web-performance-and-tensorflow-js-3db05b1de958">作者截图</a></p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="pv pw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用Chrome DevTools内存分析器拍摄并比较两个堆快照</p></figure><p id="aa51" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数组、映射和集合允许您存储数据，但是如果您没有明智地实现代码，它们可能会永远保留引用，您最终会发生泄漏。</p><p id="9ba9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一个非常简单的跟踪用户行为的电子商务应用程序。它将每个访问过的视图、每个选中的产品和每个从搜索中返回的产品添加到<code class="fe pj pk pl mv b">checkedItems</code>集合中，然后定期将数据发送到服务器:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div></figure><p id="9fd0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您在将数据发送到后端后忘记清除<code class="fe pj pk pl mv b">checkedItems</code>数组，这将导致泄漏。原因是，只要用户没有关闭选项卡，您就可以继续保留对该数据结构中的对象的引用，并继续添加新的对象。</p><h2 id="b1a6" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">取消引用数组的两种方法</h2><p id="06f9" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><strong class="lc iv">例1: </strong></p><p id="aa43" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将数组设置为<code class="fe pj pk pl mv b">[]</code>将取消对其中所有元素的引用，只要没有其他对该数组或其元素的引用:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div></figure><p id="39e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这段代码中，<code class="fe pj pk pl mv b">i</code>、<code class="fe pj pk pl mv b">j</code>和<code class="fe pj pk pl mv b">n</code>保留在内存中，因为它们仍然被<code class="fe pj pk pl mv b">list2</code>引用。</p><p id="313b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">例2: </strong></p><p id="e831" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您也可以通过将数组的长度设置为0来清除数组，这样它的所有引用都将被清除。这里，我直接修改了<code class="fe pj pk pl mv b">list1</code>属性，而不是将其重新分配给<code class="fe pj pk pl mv b">[]</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div></figure><p id="81dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">结果是<code class="fe pj pk pl mv b">list1</code>和<code class="fe pj pk pl mv b">list2</code>都被清除，并且<code class="fe pj pk pl mv b">i</code>、<code class="fe pj pk pl mv b">j</code>和<code class="fe pj pk pl mv b">n</code>将从存储器中删除。</p><p id="c5cc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，对<code class="fe pj pk pl mv b">list1</code>中对象的任何外部引用都会将这些元素保存在内存中。在下一段代码中，<code class="fe pj pk pl mv b">i</code>和<code class="fe pj pk pl mv b">j</code>将保留在内存中，因为<code class="fe pj pk pl mv b">list2</code>仍在引用它们:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div></figure><h2 id="0ac3" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">4.事件监听器</h2><p id="1b89" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">如果您的web应用程序必须侦听键盘事件、鼠标事件和滚动事件，那么您应该记住，所有这些都是很容易通过错误代码泄漏内存的模式。</p><p id="22e6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">事件侦听器防止在其范围内捕获的对象和变量被垃圾收集。因此，如果你<a class="ae kz" href="https://levelup.gitconnected.com/angular-most-common-pitfalls-78a2baf860f5#e9f5" rel="noopener ugc nofollow" target="_blank">忘记停止监听</a>，你可以预期内存泄漏。</p><p id="6966" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe pj pk pl mv b">addEventListener</code>是JavaScript中添加事件侦听器的最常见方式，它将保持活动状态，直到:</p><ul class=""><li id="ac58" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv oy oz pa pb bi translated">你用<code class="fe pj pk pl mv b">removeEventListener()</code>显式删除它，或者</li><li id="fe9b" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">关联的DOM元素将被删除。</li></ul><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在JavaScript中添加/删除事件监听器</p></figure><p id="08fd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的例子中，你不能删除<code class="fe pj pk pl mv b">document</code>。这意味着如果你不通过调用<code class="fe pj pk pl mv b">removeEventListener()</code>来清理的话，你将被<code class="fe pj pk pl mv b">doSomething()</code>监听器和它范围内的任何东西卡住。</p><p id="faba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您只需要触发一次事件监听器，您可以向<code class="fe pj pk pl mv b">addEventListener()</code>添加第三个参数<code class="fe pj pk pl mv b">{once: true}</code>，这样监听器功能将在执行其工作后自动移除:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div></figure><h2 id="3574" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">5.定时器</h2><p id="6923" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">永远运行的计时器保持分配的对象，这可能会泄漏内存。JavaScript中处理计时事件的两个关键方法是<code class="fe pj pk pl mv b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">setTimeout</strong></a>(function, milliseconds)</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">JavaScript中的setTimeout</p></figure><p id="5da9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有<code class="fe pj pk pl mv b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">setInterva</strong></a><strong class="lc iv">l</strong>(function, milliseconds)</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在JavaScript中使用setIntervall</p></figure><p id="9fd7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你创建了一个每<code class="fe pj pk pl mv b">40</code>秒运行一次的循环定时器，那么你需要用<code class="fe pj pk pl mv b">clearTimeout</code>或<code class="fe pj pk pl mv b">clearInterval</code>来清理它。</p><h2 id="fb3d" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">6.关闭</h2><blockquote class="on oo op"><p id="7940" class="la lb lw lc b ld le jv lf lg lh jy li oq lk ll lm or lo lp lq os ls lt lu lv in bi translated">“一个<strong class="lc iv">闭包</strong>是一个函数的组合，该函数被捆绑在一起(被封闭)并引用其周围的状态(即<strong class="lc iv">词法环境</strong>)。换句话说，闭包让您可以从内部函数访问外部函数的范围。”<br/> — <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> Mozilla </a></p></blockquote><p id="6439" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为闭包可以保存对外部函数变量的引用，所以它可以防止垃圾收集器释放这些变量所保存的内存。让我们看一个例子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">JavaScript函数</p></figure><ul class=""><li id="fbaf" class="ot ou iu lc b ld le lg lh lj ov ln ow lr ox lv oy oz pa pb bi translated">这里，<code class="fe pj pk pl mv b">displayName</code>是对运行<code class="fe pj pk pl mv b">outerFunc</code>时创建的函数<code class="fe pj pk pl mv b">innerFunc</code>实例的引用。</li><li id="4cd0" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">闭包<code class="fe pj pk pl mv b">innerFunc</code>可以访问父作用域中的<code class="fe pj pk pl mv b">name</code>。</li><li id="ee29" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">因为<code class="fe pj pk pl mv b">innerFunc</code>维护了对其词法环境的引用，所以变量<code class="fe pj pk pl mv b">name</code>仍然可用，即使外部函数在调用<code class="fe pj pk pl mv b">displayName</code>后已经完成了它的执行。</li></ul><h2 id="98df" class="mz na iu bd nh oc od dn nl oe of dp np lj og oh nr ln oi oj nt lr ok ol nv om bi translated">7.无限和超然的世界</h2><p id="2558" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated"><strong class="lc iv">无限DOM: <br/> </strong>如果您的应用程序中有一个无限滚动特性，类似于脸书上的“<em class="lw">显示更多帖子</em>或YouTube上的“<em class="lw">加载更多视频</em>”，那么文档对象模型(DOM)节点的数量将会无限增长。您可以通过使用<a class="ae kz" href="https://github.com/WICG/virtual-scroller#readme" rel="noopener ugc nofollow" target="_blank">虚拟化</a>来解决这个问题。</p><p id="fec1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">被引用的分离的DOM:<br/></strong>如果一个DOM元素不再被使用，那么就不应该从JavaScript中引用它，否则它不会被垃圾回收，即使是在从DOM树中移除它之后。</p><p id="4f60" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下一个示例中的代码创建了一个<code class="fe pj pk pl mv b">div</code>元素，并将其附加到<code class="fe pj pk pl mv b">document.body</code>中。然后在<code class="fe pj pk pl mv b">deleteDivElement()</code>内部调用<code class="fe pj pk pl mv b">removeChild()</code>。这个逻辑不会像预期的那样工作，因为有一个变量<code class="fe pj pk pl mv b">detachedDiv</code>仍然指向<code class="fe pj pk pl mv b">div </code>并且堆快照将显示分离的HTMLDivElement:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">创建一个分离的DOM元素</p></figure><p id="60cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，如果我们将指向DOM元素的变量<code class="fe pj pk pl mv b">detachedDiv</code>移动到函数<code class="fe pj pk pl mv b">appendDivElement()</code>的局部作用域，我们可以修复这种情况，并且在调用<code class="fe pj pk pl mv b">deleteDivElement()</code>之后将没有被引用的分离的DOM元素:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="px pw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">避免分离的DOM元素</p></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="8f27" class="ng na iu bd nh ni py nk nl nm pz no np ka qa kb nr kd qb ke nt kg qc kh nv nw bi translated">最终想法</h1><p id="5224" class="pw-post-body-paragraph la lb iu lc b ld nx jv lf lg ny jy li lj nz ll lm ln oa lp lq lr ob lt lu lv in bi translated">在极端情况下，寻找内存泄漏问题是一个复杂的问题，调试它们可能是一项艰巨的任务。为了避免在你的应用中出现这样的问题，你需要意识到这一点并保持警惕。</p><p id="85c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请记住，您设计和编写代码的方式决定了一块内存是否会返回给操作系统。</p><p id="f2b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">希望这篇文章中的见解能对你优化代码设计和修复应用有所帮助。你不必一次做所有的事情。选择适合您的情况的技巧，并不时地应用，直到您驯服了内存泄漏这头野兽。</p><pre class="kk kl km kn gu mu mv mw mx aw my bi"><span id="4a15" class="mz na iu mv b gz nb nc l nd ne"><strong class="mv iv">Want to Connect?</strong></span><span id="0976" class="mz na iu mv b gz nf nc l nd ne">If you liked what you read, here’s a <a class="ae kz" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">list of similar articles</a> that you might enjoy.</span><span id="ace2" class="mz na iu mv b gz nf nc l nd ne">I write about engineering, technology, and leadership for a community of smart, curious people. <a class="ae kz" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank">Join my free email newsletter for exclusive access</a>.</span></pre><p id="1f64" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="lw">多多感谢</em> <a class="qd qe ep" href="https://medium.com/u/7e6956110712?source=post_page-----390957523a9e--------------------------------" rel="noopener" target="_blank"> <em class="lw">纳比尔</em> </a> <em class="lw">为同行评审。</em></p></div></div>    
</body>
</html>