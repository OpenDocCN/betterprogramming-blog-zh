<html>
<head>
<title>I Mastered Golang Basics by Solving These 15 Project Euler Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过解决这15个项目欧拉问题，我掌握了Golang基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-mastered-golang-basics-by-solving-these-15-project-euler-problems-1254a3897cf8?source=collection_archive---------2-----------------------#2021-01-20">https://betterprogramming.pub/i-mastered-golang-basics-by-solving-these-15-project-euler-problems-1254a3897cf8?source=collection_archive---------2-----------------------#2021-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="37cd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">特殊的毕达哥拉斯，最大的回文，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/18c8585bc17fe1ee9a27f0ecc056f136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*vmFSpk9xtpxAHkH7cmt-3Q.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:谷歌</p></figure><p id="e60c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你好。在这篇文章中，我想向你展示我在Golang中解决前15个欧拉问题时所学到的东西。这些问题的解决方案都可以在以下网址找到:</p><div class="lq lr gp gr ls lt"><a href="https://github.com/leogtzr/15_projecteuler_solutions_Golang" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">leogtzr/15 _ project Euler _ solutions _ Golang</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">在GitHub上创建一个帐户，为leogtzr/15 _ project Euler _ solutions _ Golang开发做出贡献。</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">github.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh ko lt"/></div></div></a></div></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e2c0" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">欧拉项目</h1><p id="e07d" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">首先，什么是欧拉项目？简单来说就是一个有数学和计算机科学问题的网站。基本上，它为您提供了一个问题描述，您需要输入正确的答案，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/159fefd2c32d228cb9286644523d9ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*M6LsmropSOJz7FJ6I4bz9Q.png"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="9d8d" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">我为什么喜欢欧拉项目</h1><p id="c157" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">当我在学习一门编程语言，并且我想在学习的时候获得一些乐趣时，我做的第一件事是:去Project Euler网站，尝试解决一些问题。这些问题将会给你一个完美的基础来实践如下的概念:</p><ul class=""><li id="16d5" class="nn no it kw b kx ky la lb ld np lh nq ll nr lp ns nt nu nv bi translated"><em class="nw">循环结构</em> (for-loops，switch，continue，break)</li><li id="d0a8" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">基本数据结构</em>(数组/链表)。</li><li id="6688" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">算术运算符。</em></li><li id="d08a" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">原始类型及其范围。</em></li><li id="3f28" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">文件处理</em>(读/写)。</li><li id="4757" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">类型转换。</em></li><li id="90c7" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">从标准输入中读取。</em></li><li id="1357" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">通过</em> <em class="nw">值/参考值。</em></li><li id="7fec" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated"><em class="nw">任意精度算术。</em></li><li id="4efc" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated">等等。</li></ul><p id="f735" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有这些概念对大多数编程语言来说都是通用的；不管你学的是哪一个，通过尝试解决它们，你会学到很多。</p><p id="2967" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们中的一些人甚至走得更远，在实践测试驱动开发(<a class="ae oc" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank"> TDD </a>)时试图解决它们。还有，不需要数学背景！您可以随时随地学习。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e1fd" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">解决前15个问题</h1><p id="080c" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">让我们试着解决前15个问题。我需要警告你:我仍在学习，我的解决方案可能远非完美。在某些情况下，我对优化不够重视，因为我的目的是找点乐子。</p><p id="abfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在下面的GitHub资源库中找到完整的解决方案。请随时发送拉取请求🙂。</p><h2 id="c621" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated">问题1—3和5的倍数</h2><blockquote class="op oq or"><p id="573f" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“如果我们列出所有在<strong class="kw iu"> 10 </strong>以下的是<strong class="kw iu"> 3 </strong>或<strong class="kw iu"> 5 </strong>的倍数的自然数，我们得到<strong class="kw iu"> 3 </strong>、<strong class="kw iu"> 5、6 </strong>和<strong class="kw iu"> 9 </strong>。这些倍数之和就是<strong class="kw iu"> 23 </strong>。</p><p id="834c" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">求<strong class="kw iu"> 3 </strong>或<strong class="kw iu"> 5 </strong>低于<strong class="kw iu"> 1000 </strong>的所有倍数之和。"</p></blockquote><p id="4b12" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，这似乎是某种<a class="ae oc" href="https://en.wikipedia.org/wiki/Fizz_buzz" rel="noopener ugc nofollow" target="_blank">嘶嘶作响的问题。</a>作为第一个问题，应该没那么难吧？解决方案如下:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="c4fc" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="119b" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="95fc" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    sum := 0<br/>    for i := 1; i &lt; 1_000; i++ {<br/>        if i%3 == 0 || i%5 == 0 {<br/>            sum += i<br/>        }<br/>    }<br/>    fmt.Printf("Sum: %d\n", sum)<br/>}</span></pre><p id="63ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="d63e" class="od mq it ow b gy pa pb l pc pd">Sum: 233168</span></pre><p id="0c6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没那么难。有趣的是，<a class="ae oc" href="https://golang.org/ref/spec#Integer_literals" rel="noopener ugc nofollow" target="_blank">数字前缀</a> <code class="fe pf pg ph ow b">_</code>的用法有助于提高可读性。这里有一些重构的机会，我们将在本文后面重新讨论。让我们转到下一个问题🙂。</p><h2 id="d6a7" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题2 — </strong>偶数斐波纳契数</h2><blockquote class="op oq or"><p id="f69d" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“斐波纳契数列中的每一个新项都是通过将前两项相加而生成的。从1和2开始，前10项将是:</p><p id="0c9d" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi">1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p id="bd42" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">考虑斐波纳契数列中值不超过四百万的项，找出偶数项的总和。"</p></blockquote><p id="5b65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个越来越有趣了。如何在围棋中生成斐波那契数列？这边走:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="b867" class="od mq it ow b gy pa pb l pc pd">func main() {<br/>    a := 0<br/>    b := 1</span><span id="c7f6" class="od mq it ow b gy pe pb l pc pd">    for i := 0; i &lt; 10; i++ {<br/>        fmt.Println(a)<br/>        copy := a + b<br/>        a = b<br/>        b = copy<br/>    }<br/>}</span></pre><p id="5bff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，我们可以这样避免赋值语句交换这两个变量:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="905c" class="od mq it ow b gy pa pb l pc pd">func main() {<br/>    a := 0<br/>    b := 1</span><span id="1545" class="od mq it ow b gy pe pb l pc pd">    for i := 0; i &lt; 10; i++ {<br/>        ret := a<br/>        a, b = b, a+ret<br/>        fmt.Println(ret)<br/>    }<br/>}</span></pre><p id="d6fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很酷，不是吗？🙂这给了我们序列，但并没有真正解决问题。我们需要对偶数<em class="nw"> &lt; 4000000 </em>求和。这是我的解决方案:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="13b0" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="6406" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="1886" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    a := 0<br/>    b := 1<br/>    sum := 0<br/>    const max = 4_000_000</span><span id="1e85" class="od mq it ow b gy pe pb l pc pd">    for b &lt; max {<br/>        buff := a + b<br/>        if b%2 == 0 {<br/>            sum += b<br/>        }<br/>        a = b<br/>        b = buff<br/>    }</span><span id="960d" class="od mq it ow b gy pe pb l pc pd">    fmt.Printf("The sum is: [%d]\n", sum)<br/>}</span></pre><p id="2ab1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这次我用<strong class="kw iu"> <em class="nw"> const </em> </strong>来明确变量和常量的区别。我认为使用以下内容可能是一样的:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="b310" class="od mq it ow b gy pa pb l pc pd">for <strong class="ow iu"><em class="nw">b</em></strong> &lt; <strong class="ow iu">4_000_000</strong> {</span></pre><p id="3add" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如我所说，目的是找点乐子，把一些概念付诸实践。我们还可以看到，这次数字文字前缀<code class="fe pf pg ph ow b">_</code>有助于提高可读性。</p><p id="675e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="52d3" class="od mq it ow b gy pa pb l pc pd">The sum is: [<strong class="ow iu">4613732</strong>]</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/7c0fc423ac56cbc45df9aa8e695e0c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:846/format:webp/1*ueO2EF0qW6RB1jnNt-luGA.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">问题2 —解决方案</p></figure><p id="3210" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它跑得很快。让我们转到下一个问题。</p><h2 id="69cf" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题3 — </strong>最大质因数</h2><blockquote class="op oq or"><p id="d08e" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated"><strong class="kw iu"> 13195 </strong>的质因数是<strong class="kw iu"> 5 </strong>、<strong class="kw iu"> 7 </strong>、<strong class="kw iu"> 13 </strong>和<strong class="kw iu"> 29 </strong>。</p><p id="6452" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">600851475143这个数的最大质因数是多少？"</p></blockquote><p id="8b33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">酷！这个涉及到<strong class="kw iu">质因数分解。寻找质因数分解的编程解决方案不会有任何问题。最常见的解决方案之一是<a class="ae oc" href="https://en.wikipedia.org/wiki/Trial_division" rel="noopener ugc nofollow" target="_blank">试除法算法。首先，让我们看看如何分解质数中的数字，然后我们将负责检查什么是最大的。</a></strong></p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="4910" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="60bd" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "math"<br/>)</span><span id="15fa" class="od mq it ow b gy pe pb l pc pd">func <strong class="ow iu">printPrimes</strong>(n int) {<br/>    for i := 2; i &lt;= int(math.Sqrt(float64(n))); i++ {<br/>        if n%i == 0 {<br/>            fmt.Println(i)<br/>            n /= i<br/>            i--<br/>        }<br/>    }<br/>    if n &gt; 0 {<br/>        fmt.Println(n)<br/>    }<br/>}</span><span id="8a56" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    n := <strong class="ow iu">600851475143</strong><br/>    <strong class="ow iu">printPrimes</strong>(n)<br/>}</span></pre><p id="928c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="b027" class="od mq it ow b gy pa pb l pc pd">71<br/>839<br/>1471<br/>6857</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/031d369b73adbb3d549b11ec8beb4c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*I6YLccDLj0FiNAZbCYgGAQ.png"/></div></figure><p id="b278" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它可以工作，但是我很确定我们可以优化它。我们还可以看到最大的数字是<strong class="kw iu">6857</strong>，所以我们解决完这个问题了！让我们看看如何使用前面的代码计算最大值。首先，我们需要修改我们的<code class="fe pf pg ph ow b">printPrimes()</code>函数来返回一部分质因数。代码已更改为以下内容:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="636b" class="od mq it ow b gy pa pb l pc pd">func <strong class="ow iu">primeFactors</strong>(n int) []int {<br/>    factors := make([]int, 0)<br/>    for i := 2; i &lt;= int(math.Sqrt(float64(n))); i++ {<br/>        if n%i == 0 {<br/>            factors = append(factors, i)<br/>            n /= i<br/>            i--<br/>        }<br/>    }<br/>    if n &gt; 0 {<br/>        factors = append(factors, n)<br/>    }</span><span id="637f" class="od mq it ow b gy pe pb l pc pd">    return factors<br/>}</span></pre><p id="5e02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好，现在让我们创建一个函数来计算最大值，如下所示:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="1f21" class="od mq it ow b gy pa pb l pc pd">func largest(factors []int) int {<br/>    max := factors[0]</span><span id="e13c" class="od mq it ow b gy pe pb l pc pd">    for _, factor := range factors {<br/>        if factor &gt; max {<br/>            max = factor<br/>        }<br/>    }</span><span id="cc47" class="od mq it ow b gy pe pb l pc pd">    return max<br/>}</span></pre><p id="70df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完整的程序如下:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="cf16" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="e284" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "math"<br/>)</span><span id="e8e6" class="od mq it ow b gy pe pb l pc pd">func largest(factors []int) int {<br/>    max := factors[0]</span><span id="0667" class="od mq it ow b gy pe pb l pc pd">    for _, factor := range factors {<br/>        if factor &gt; max {<br/>            max = factor<br/>        }<br/>    }</span><span id="a1d6" class="od mq it ow b gy pe pb l pc pd">    return max<br/>}</span><span id="b32c" class="od mq it ow b gy pe pb l pc pd">func primeFactors(n int) []int {<br/>    factors := make([]int, 0)<br/>    for i := 2; i &lt;= int(math.Sqrt(float64(n))); i++ {<br/>        if n%i == 0 {<br/>            factors = append(factors, i)<br/>            n /= i<br/>            i--<br/>        }<br/>    }<br/>    if n &gt; 0 {<br/>        factors = append(factors, n)<br/>    }</span><span id="70a6" class="od mq it ow b gy pe pb l pc pd">    return factors<br/>}</span><span id="318b" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    n := 600851475143<br/>    largestPrimeFactor := largest(primeFactors(n))<br/>    fmt.Println(largestPrimeFactor)<br/>}</span></pre><p id="c7fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="f630" class="od mq it ow b gy pa pb l pc pd">6857</span></pre><p id="c8df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实际上，在撰写本文的这一部分时，我们也可以使用如下所示的<a class="ae oc" href="https://man7.org/linux/man-pages/man1/factor.1.html" rel="noopener ugc nofollow" target="_blank"> factor linux命令</a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/3d28637b20778ed32acbb6391e90128c.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*qXv_KMuA1qi4udqI5b-yXw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">因子命令</p></figure><h2 id="872e" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题4 — </strong>最大回文乘积</h2><blockquote class="op oq or"><p id="a1dd" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“一个回文数的两种读法是一样的。由两个<strong class="kw iu"> 2位数的乘积构成的最大回文是9009 = 91 × 99 </strong>。</p><p id="6b1a" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">找出由两个三位数的乘积构成的最大回文。"</p></blockquote><p id="cdf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好，我们怎么知道一个数是不是回文？第一种方法是将数字转换为<code class="fe pf pg ph ow b">string</code>，反转<code class="fe pf pg ph ow b">string </code>，然后检查反转的<code class="fe pf pg ph ow b">string </code>是否与数字相同。但这听起来很复杂。所以，我们来试一个函数。以下函数在不使用<code class="fe pf pg ph ow b">string</code>相关操作的情况下反转一个数字:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="9141" class="od mq it ow b gy pa pb l pc pd">func isPalindrome(n int) bool {<br/>    reverse := 0<br/>    original := n<br/>    for n != 0 {<br/>        reverse = (reverse * 10) + (n % 10)<br/>        n /= 10<br/>    }<br/>    return original == reverse<br/>}</span></pre><p id="10d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要找到由两个三位数的乘积构成的最大回文。我们可能需要从100开始检查…该解决方案如下:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="8ded" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="3a80" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="d42e" class="od mq it ow b gy pe pb l pc pd">func isPalindrome(n int) bool {<br/>    reverse := 0<br/>    original := n<br/>    for n != 0 {<br/>        reverse = (reverse * 10) + (n % 10)<br/>        n /= 10<br/>    }<br/>    return original == reverse<br/>}</span><span id="79e6" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    max := 999<br/>    for i := 100; i &lt;= 999; i++ {<br/>        for j := 100; j &lt;= 999; j++ {<br/>            product := i * j<br/>            if isPalindrome(product) &amp;&amp; product &gt; max {<br/>                max = product<br/>            }<br/>        }<br/>    }</span><span id="8402" class="od mq it ow b gy pe pb l pc pd">    fmt.Println(max)<br/>}</span></pre><p id="9c51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="1c48" class="od mq it ow b gy pa pb l pc pd">906609</span></pre><p id="2451" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我很确定我们可以优化它，但是即使没有优化(如下所示)，它也运行得非常快:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="3627" class="od mq it ow b gy pa pb l pc pd">$ time ./problem4 <br/>906609</span><span id="bdb4" class="od mq it ow b gy pe pb l pc pd">real    0m0.045s<br/>user    0m0.042s<br/>sys 0m0.005s</span></pre><p id="bb16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">&lt; 0.05 seconds!</p><h2 id="444c" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题5 — </strong>最小倍数</h2><blockquote class="op oq or"><p id="cefe" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">"<strong class="kw iu"> 2520 </strong>是能被从<strong class="kw iu"> 1 </strong>到<strong class="kw iu"> 10 </strong>的每一个数整除且没有余数的最小数。</p><p id="13cf" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">能被从<strong class="kw iu"> 1 </strong>到<strong class="kw iu"> 20 </strong>的所有数字整除的最小正数是多少？"</p></blockquote><p id="e8cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">似乎对于这个问题，我们需要记录可以在1-10-1-20范围内被分割的数字。我写了下面的代码来解决它:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="0817" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="4993" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="a59f" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    max := <strong class="ow iu">2520</strong><br/>    for i := <strong class="ow iu">max</strong>; ; i++ {<br/>        can := true<br/>        for j := 1; j &lt;= 20; j++ {<br/>            if i % j != 0 {<br/>                can = false<br/>                break<br/>            }<br/>        }<br/>        if can {<br/>            max = i<br/>            break<br/>        }<br/>    }</span><span id="bc41" class="od mq it ow b gy pe pb l pc pd">    fmt.Println(max)<br/>}</span></pre><p id="1103" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，这个程序没有其他程序运行得快。结果如下所示:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="988f" class="od mq it ow b gy pa pb l pc pd">$ time ./problem5 <br/><strong class="ow iu">232792560</strong></span><span id="b15f" class="od mq it ow b gy pe pb l pc pd">real    0m7.032s<br/>user    0m7.029s<br/>sys 0m0.012s</span></pre><h2 id="a3a4" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated">问题6 —平方差和</h2><blockquote class="op oq or"><p id="13f4" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“前十个自然数的平方和是，</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/b439a5be24a9f6cf9ec75fab9daa8714.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*geJwuFKylv6QTWOnOXpUkg.png"/></div></figure><blockquote class="op oq or"><p id="81bd" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">前十个自然数之和的平方是，</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/5d5756806e9b76ac5ff4e35feee9aa64.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*wPDHZN8YZN0Vmyo_QDbnNA.png"/></div></figure><blockquote class="op oq or"><p id="b2bb" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">因此，前十个自然数的平方和与和的平方之差为。</p><p id="a2a9" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">求前一百个自然数的平方和与和的平方之差。"</p></blockquote><p id="cf67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能是最简单的😃。以下是我的回答:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="1a21" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="4048" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="2953" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    sumSquares := 0<br/>    squaresOfTheSum := 0<br/>    for i := 1; i &lt;= 100; i++ {<br/>        sumSquares += i * i<br/>        squaresOfTheSum += i<br/>    }<br/>    <strong class="ow iu">diffSums</strong> := (<strong class="ow iu">squaresOfTheSum</strong> * <strong class="ow iu">squaresOfTheSum</strong>) - <strong class="ow iu">sumSquares</strong><br/>    fmt.Println(<strong class="ow iu">diffSums</strong>)<br/>}</span></pre><p id="3e15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="d45f" class="od mq it ow b gy pa pb l pc pd">$ time ./problem6 <br/>25164150</span><span id="020f" class="od mq it ow b gy pe pb l pc pd">real    0m0.004s<br/>user    0m0.000s<br/>sys 0m0.005s</span></pre><h2 id="fe6c" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated">问题7–10001质数</h2><blockquote class="op oq or"><p id="c39d" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“通过列出前六个素数:<strong class="kw iu"> 2、3、5、7、11 </strong>和<strong class="kw iu"> 13 </strong>，我们可以看到<strong class="kw iu">第六个素数</strong>就是<strong class="kw iu"> 13 </strong>。</p><p id="b8fe" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">什么是<strong class="kw iu">10 001</strong>质数？"</p></blockquote><p id="6ace" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在前面的问题中，我们已经看到了如何知道一个数是否是质数。对于这个问题，我们需要得到<code class="fe pf pg ph ow b">nth </code>数。</p><p id="dd87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案:</strong></p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="bdaf" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="5156" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "math"<br/>)</span><span id="3483" class="od mq it ow b gy pe pb l pc pd">func nThPrimeNumber(n int) int {<br/>    if n == 0 {<br/>        return 0<br/>    }<br/>    count := 0<br/>    i := 2<br/>    for ; ; i++ {<br/>        if isPrime(i) {<br/>            count++<br/>        }<br/>        if count == n {<br/>            break<br/>        }<br/>    }</span><span id="08ba" class="od mq it ow b gy pe pb l pc pd">    return i<br/>}</span><span id="023e" class="od mq it ow b gy pe pb l pc pd">func isPrime(n int) bool {<br/>    if n &lt; 2 {<br/>        return false<br/>    }</span><span id="b305" class="od mq it ow b gy pe pb l pc pd">    is := true</span><span id="1c14" class="od mq it ow b gy pe pb l pc pd">    max := math.Sqrt(float64(n))<br/>    for i := 2; i &lt;= int(max); i++ {<br/>        if n % i == 0 {<br/>            is = false<br/>            break<br/>        }<br/>    }</span><span id="bceb" class="od mq it ow b gy pe pb l pc pd">    return is<br/>}</span><span id="50cd" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    fmt.Println(nThPrimeNumber(10_001))<br/>}</span></pre><p id="58e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以优化它，但是，正如您在下面看到的，它运行得非常快:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="ebdd" class="od mq it ow b gy pa pb l pc pd">$ time ./problem7 <br/>104743</span><span id="f0bb" class="od mq it ow b gy pe pb l pc pd">real    0m0.093s<br/>user    0m0.094s<br/>sys 0m0.001s</span></pre><p id="4621" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的电脑上大约需要1.2秒😮</p><h2 id="003e" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题8 — </strong>系列中最大的产品</h2><blockquote class="op oq or"><p id="2090" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“在<strong class="kw iu"> 1000位数字</strong>中具有最大乘积的四个相邻数字是<strong class="kw iu">9</strong>×<strong class="kw iu">9</strong>×<strong class="kw iu">8</strong>×<strong class="kw iu">9</strong>=<strong class="kw iu">5832</strong>。</p><p id="5860" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">73167176531330624919225119674426574742355349194934<br/>96983520312774506326239578318016984801869478851843<br/>5615607911294949。</p><p id="35f3" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">在<strong class="kw iu"> 1000位数字</strong>中找出具有最大乘积的13个相邻数字。这个产品的价值是什么？"</p></blockquote><p id="58fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这张真的很有意思！我们需要做的第一件事是<em class="nw">将这个1000位数的数字</em>展平在一个<code class="fe pf pg ph ow b">string</code>中以便于操作，然后从位置<code class="fe pf pg ph ow b">0</code>转到<code class="fe pf pg ph ow b"><strong class="kw iu"><em class="nw">string.length - 13</em></strong></code>并计算最大的乘积。我的答案如下图:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="a504" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="ceef" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "strings"<br/>)</span><span id="218a" class="od mq it ow b gy pe pb l pc pd">const (<br/>    grid = `73167176531330624919225119674426574742355349194934<br/>96983520312774506326239578318016984801869478851843<br/>85861560789112949495459501737958331952853208805511<br/>12540698747158523863050715693290963295227443043557<br/>66896648950445244523161731856403098711121722383113<br/>62229893423380308135336276614282806444486645238749<br/>30358907296290491560440772390713810515859307960866<br/>70172427121883998797908792274921901699720888093776<br/>65727333001053367881220235421809751254540594752243<br/>52584907711670556013604839586446706324415722155397<br/>53697817977846174064955149290862569321978468622482<br/>83972241375657056057490261407972968652414535100474<br/>82166370484403199890008895243450658541227588666881<br/>16427171479924442928230863465674813919123162824586<br/>17866458359124566529476545682848912883142607690042<br/>24219022671055626321111109370544217506941658960408<br/>07198403850962455444362981230987879927244284909188<br/>84580156166097919133875499200524063689912560717606<br/>05886116467109405077541002256983155200055935729725<br/>71636269561882670428252483600823257530420752963450`<br/>    numberOfAdjacent = 13<br/>)</span><span id="6b12" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    number := strings.ReplaceAll(grid, "\n", "")<br/>    max := 0<br/>    for i := 0; i &lt; len(number) - numberOfAdjacent; i++ {<br/>        product := 1<br/>        for j := i; j &lt; (i + numberOfAdjacent); j++ {<br/>            product *= int(number[j] - '0')<br/>        }<br/>        if product &gt; max {<br/>            max = product<br/>        }<br/>    }</span><span id="4b51" class="od mq it ow b gy pe pb l pc pd">    fmt.Println(max)<br/>}</span></pre><p id="3f98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将一个<code class="fe pf pg ph ow b">digit-char</code>转换成一个<code class="fe pf pg ph ow b">int</code>的代码非常常见。你用<code class="fe pf pg ph ow b">char </code>减去<code class="fe pf pg ph ow b"><em class="nw">0</em></code>。这将把<code class="fe pf pg ph ow b">char </code>转换成<code class="fe pf pg ph ow b">int</code>。</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="a473" class="od mq it ow b gy pa pb l pc pd">$ time ./problem8 <br/>23514624000</span><span id="4b78" class="od mq it ow b gy pe pb l pc pd">real    0m0.006s<br/>user    0m0.005s<br/>sys 0m0.003s</span></pre><h2 id="e881" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题9 — </strong>特殊的毕达哥拉斯三联体</h2><blockquote class="op oq or"><p id="7f34" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“毕达哥拉斯三联体是三个自然数的集合，<strong class="kw iu"> a &lt; b &lt; c </strong>，其中，</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/cedc584e0e2a81e0479d6e7ff107a1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/1*ozgJs5P_VTgzvEyIPMuhZQ.png"/></div></figure><blockquote class="op oq or"><p id="36ce" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">比如32 + 42 = 9 + 16 = 25 = 52。</p><p id="d6a9" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">恰好存在一个毕达哥拉斯三元组<strong class="kw iu"> a + b + c = 1000 </strong>。"</p></blockquote><p id="cefb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这似乎是一个蛮力解决方案的很好的候选。我的答案如下图:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="a927" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="574e" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="92ff" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    out:<br/>    for a := 1; a &lt; 1_000; a++ {<br/>        for b := 1; b &lt; 1_000; b++ {<br/>            for c := 1; c &lt; 1_000; c++ {<br/>                if ((a * a) + (b * b) == (c * c)) &amp;&amp; (a + b + c == 1_000) &amp;&amp; ((a &lt; b) &amp;&amp; (b &lt; c)) {<br/>                    product := a * b * c<br/>                    fmt.Printf("%d + %d + %d = 1000, product = %d\n", a, b, c, product)<br/>                    break out<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="3d5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="dfea" class="od mq it ow b gy pa pb l pc pd">$ time ./problem9 <br/>200 + 375 + 425 = 1000, product = 31875000</span><span id="eb8c" class="od mq it ow b gy pe pb l pc pd">real    0m0.320s<br/>user    0m0.317s<br/>sys 0m0.005s</span></pre><h2 id="3fe1" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题10 — </strong>素数求和</h2><blockquote class="op oq or"><p id="7d0c" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“10以下的素数之和是2 + 3 + 5 + 7 = 17。</p><p id="4a27" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">求所有低于<strong class="kw iu">两百万</strong>的质数之和。"</p></blockquote><p id="f71e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这一个，我们将需要重用我们的<code class="fe pf pg ph ow b"><em class="nw">isPrime()</em></code>函数。基本上，我们需要从<strong class="kw iu"> 2 </strong>到<strong class="kw iu"> 2000000 </strong>并检查每个数字。如果是质数，那就把它加到一个变量上。</p><p id="b6bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我的解决方案:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="e28d" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="8dac" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "math"<br/>)</span><span id="8f45" class="od mq it ow b gy pe pb l pc pd">func isPrime(n int) bool {<br/>    if n &lt; 2 {<br/>        return false<br/>    }</span><span id="6cd3" class="od mq it ow b gy pe pb l pc pd">    is := true</span><span id="d987" class="od mq it ow b gy pe pb l pc pd">    max := int(math.Sqrt(float64(n)))<br/>    for i := 2; i &lt;= max; i++ {<br/>        if n % i == 0 {<br/>            is = false<br/>            break<br/>        }<br/>    }</span><span id="e014" class="od mq it ow b gy pe pb l pc pd">    return is<br/>}</span><span id="026d" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    sum := 0<br/>    for i := 2; i &lt;= 2_000_000; i++ {<br/>        if <strong class="ow iu">isPrime</strong>(i) {<br/>            <strong class="ow iu">sum</strong> += i<br/>        }<br/>    }<br/>    fmt.Println(<strong class="ow iu">sum</strong>)<br/>}</span></pre><p id="1c15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe pf pg ph ow b"><em class="nw">isPrime()</em></code>函数并没有完全优化，但是起作用，整个解决方案运行速度足够快(<strong class="kw iu"><em class="nw">&lt;1.5秒</em> </strong>)。结果如下所示:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="7168" class="od mq it ow b gy pa pb l pc pd">$ time ./problem10 <br/>142913828922</span><span id="a2ac" class="od mq it ow b gy pe pb l pc pd">real    0m1.266s<br/>user    0m1.263s<br/>sys 0m0.005s</span></pre><h2 id="acfc" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题11 — </strong>网格中最大的产品</h2><blockquote class="op oq or"><p id="61fe" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“在下面的20×20网格中，沿着对角线的四个数字已经用红色标出。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/68c49179b3f4d18e1c58a0417476700f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*7_PhtxbE5VDa-QK3gucFig.png"/></div></figure><blockquote class="op oq or"><p id="f02b" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">这些数的乘积是26 × 63 × 78 × 14 = 1788696。</p><p id="3099" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated"><strong class="kw iu"> <em class="it"> 20×20网格</em> </strong>中同方向(上、下、左、右、对角)四个相邻数字的最大乘积是多少？</p></blockquote><p id="a144" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可能是最费力的工作之一。问题很简单，在一个特定的位置(行，列)，但我们如何才能在一个特定的方向移动，并获得四个相邻数字的乘积？任何方向和位置的条件都不一样。我最喜欢这个问题的一点是，我们可以练习几个主题，例如:</p><ul class=""><li id="25fd" class="nn no it kw b kx ky la lb ld np lh nq ll nr lp ns nt nu nv bi translated">常数有<a class="ae oc" href="https://golang.org/ref/spec#Iota" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu"><em class="nw"/></strong></a></li><li id="23cf" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated">多态性</li><li id="545b" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated">字符串转换(我们需要转换20x20网格中的数字)</li><li id="7d08" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated">转换条款</li><li id="b5f9" class="nn no it kw b kx nx la ny ld nz lh oa ll ob lp ns nt nu nv bi translated">指针和更多</li></ul><p id="cb66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我针对这个问题做的第一件事就是把网格放在一个<code class="fe pf pg ph ow b">string</code>里，写一个函数把网格文本转换成切片的切片。我的答案如下图:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="5ea9" class="od mq it ow b gy pa pb l pc pd">const (<br/>    <strong class="ow iu">grid</strong> = `08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08<br/>49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00<br/>81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65<br/>52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91<br/>22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80<br/>24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50<br/>32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70<br/>67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21<br/>24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72<br/>21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95<br/>78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92<br/>16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57<br/>86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58<br/>19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40<br/>04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66<br/>88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69<br/>04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36<br/>20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16<br/>20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54<br/>01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48`</span><span id="871c" class="od mq it ow b gy pe pb l pc pd"><strong class="ow iu">    gridRowLen</strong> = 20<br/>    <strong class="ow iu">adjacent</strong> = 4<br/>)</span><span id="5613" class="od mq it ow b gy pe pb l pc pd">func gridTextToMatrix2(grid string, matrixSize int) [][]int {<br/>    matrix := make([][]int, matrixSize)</span><span id="ab42" class="od mq it ow b gy pe pb l pc pd">    for i := 0; i &lt; matrixSize; i++ {<br/>        matrix[i] = make([]int, matrixSize)<br/>    }</span><span id="1db1" class="od mq it ow b gy pe pb l pc pd">    textRows := strings.Split(grid, "\n")<br/>    for i := 0; i &lt; len(textRows); i++ {<br/>        row := textRows[i]<br/>        cols := strings.Split(row, " ")<br/>        for c := 0; c &lt; len(cols); c++ {<br/>            x, _ := strconv.ParseInt(cols[c], 10, 64)<br/>            matrix[i][c] = int(x)<br/>        }<br/>    }</span><span id="d510" class="od mq it ow b gy pe pb l pc pd">    return matrix<br/>}</span></pre><p id="b404" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这应该行得通。现在，我们如何处理不同类型的运动？上、下、左、右或对角线。我已经用一个<code class="fe pf pg ph ow b">iota</code>类型处理过了，如下所示:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="9837" class="od mq it ow b gy pa pb l pc pd">type Direction int</span><span id="7854" class="od mq it ow b gy pe pb l pc pd">const (<br/>    Down Direction = iota<br/>    Up<br/>    Left<br/>    Right<br/>    DiagonalUpLeft<br/>    DiagonalUpRight<br/>    DiagonalDownLeft<br/>    DiagonalDownRight<br/>)</span></pre><p id="e7e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个类型，现在我们可以在我的函数中使用多态性的<code class="fe pf pg ph ow b">Direction</code>类型。我的答案如下图:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="3e2d" class="od mq it ow b gy pa pb l pc pd">func canMove(row, col, adjacent int, direction Direction, grid *[][]int) bool {<br/>    switch direction {<br/>    case Right:<br/>        if ((col + adjacent) &gt; len(*grid)) || (row &gt;= len(*grid)) {<br/>            return false<br/>        }<br/>        return true<br/>    case Left:<br/>        if (((col + 1) - adjacent) &lt; 0) || (row &gt;= len(*grid)) {<br/>            return false<br/>        }<br/>        return true<br/>    case Up:<br/>        if ((col &lt; 0) || (col &gt;= len(*grid))) || (((row + 1) - adjacent) &lt; 0) {<br/>            return false<br/>        }<br/>        if (row + 1) &gt; len(*grid) {<br/>            return false<br/>        }<br/>        return true<br/>    case Down:<br/>        if ((col &lt; 0) || (col &gt;= len(*grid))) || ((row + adjacent) &gt; len(*grid)) {<br/>            return false<br/>        }<br/>        return true<br/>    case DiagonalUpLeft:<br/>        if ((col + 1) - adjacent) &lt; 0 {<br/>            return false<br/>        }<br/>        if ((row + 1) - adjacent) &lt; 0 {<br/>            return false<br/>        }<br/>        if (row + 1) &gt; len(*grid) {<br/>            return false<br/>        }<br/>        return true<br/>    case DiagonalUpRight:<br/>        if ((row + 1) - adjacent) &lt; 0 {<br/>            return false<br/>        }<br/>        if (col + adjacent) &gt; len(*grid) {<br/>            return false<br/>        }<br/>        if row &gt;= len(*grid) {<br/>            return false<br/>        }<br/>        return true<br/>    case DiagonalDownLeft:<br/>        if (col &lt; 0) || (col &gt;= len(*grid)) {<br/>            return false<br/>        }<br/>        if (row + adjacent) &gt; len(*grid) {<br/>            return false<br/>        }<br/>        if ((col + 1) - adjacent) &lt; 0 {<br/>            return false<br/>        }<br/>        return true;<br/>    case DiagonalDownRight:<br/>        if (col + adjacent) &gt; len(*grid) {<br/>            return false<br/>        }<br/>        if row &gt;= len(*grid) {<br/>            return false<br/>        }<br/>        if (col &lt; 0) || (col &gt;= len(*grid)) {<br/>            return false<br/>        }<br/>        if (row + adjacent) &gt; len(*grid) {<br/>            return false<br/>        }<br/>        return true<br/>    default:<br/>        return false<br/>    }<br/>}</span><span id="757c" class="od mq it ow b gy pe pb l pc pd">func availableMoves(row, col int, grid *[][]int) []Direction {<br/>    directions := []Direction{<br/>        Down,<br/>        Up,<br/>        Left,<br/>        Right,<br/>        DiagonalUpLeft,<br/>        DiagonalUpRight,<br/>        DiagonalDownLeft,<br/>        DiagonalDownRight,<br/>    }</span><span id="7d92" class="od mq it ow b gy pe pb l pc pd">    available := make([]Direction, 0)</span><span id="0884" class="od mq it ow b gy pe pb l pc pd">    for _, direction := range directions {<br/>        if canMove(row, col, adjacent, direction, grid) {<br/>            available = append(available, direction)<br/>        }<br/>    }</span><span id="ea54" class="od mq it ow b gy pe pb l pc pd">    return available<br/>}</span></pre><p id="256a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">遗憾的是，没有办法摆脱这些冗长的函数。我们必须考虑所有的情况。以下函数将计算特定[行，列]上的<code class="fe pf pg ph ow b">direction</code>的相邻的乘积:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="e733" class="od mq it ow b gy pa pb l pc pd">func calculate(direction Direction, row, col, adjacent int, grid *[][]int) int {<br/>    switch direction {<br/>    case Right:<br/>        p := 1<br/>        for c := col; c &lt; (col + adjacent); c++ {<br/>            p *= (*grid)[row][c]<br/>        }<br/>        return p<br/>    case Left:<br/>        p := 1<br/>        for c := col; c &gt; (col - adjacent); c-- {<br/>            p *= (*grid)[row][c]<br/>        }<br/>        return p<br/>    case Up:<br/>        p := 1<br/>        for r := row; r &gt; (row - adjacent); r-- {<br/>            p *= (*grid)[r][col]<br/>        }<br/>        return p;<br/>    case Down:<br/>        p := 1<br/>        for r := row; r &lt; (row + adjacent); r++ {<br/>            p *= (*grid)[r][col]<br/>        }<br/>        return p<br/>    case DiagonalUpLeft:<br/>        p := 1<br/>        c := col<br/>        for r := row; (r &gt; (row - adjacent)) &amp;&amp; (c &gt; (c - adjacent));  {<br/>            p *= (*grid)[r][c]<br/>            r--<br/>            c--<br/>        }<br/>        return p<br/>    case DiagonalUpRight:<br/>        p := 1<br/>        r := row<br/>        c := col<br/>        for ; (r &gt; (row - adjacent)) &amp;&amp; (c &lt; (col + adjacent)); {<br/>            p *= (*grid)[r][c]<br/>            r--<br/>            c++<br/>        }<br/>        return p<br/>    case DiagonalDownLeft:<br/>        p := 1<br/>        r := row<br/>        c := col<br/>        for ; r &lt; (row + adjacent) &amp;&amp; (c &gt; (col - adjacent));  {<br/>        p *= (*grid)[r][c]<br/>            r++<br/>            c--<br/>        }<br/>        return p<br/>    case DiagonalDownRight:<br/>        p := 1<br/>        r := row<br/>        c := col<br/>        for ; (r &lt; (row + adjacent)) &amp;&amp; (c &lt; (col + adjacent));  {<br/>        p *= (*grid)[r][c]<br/>            r++<br/>            c++<br/>        }<br/>        return p<br/>    default:<br/>        return 0<br/>    }<br/>}</span></pre><p id="088c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oc" href="https://github.com/leogtzr/15_projecteuler_solutions_Golang/blob/main/problem11/main.go" rel="noopener ugc nofollow" target="_blank">解决方案</a>运行时间不到1.5秒，您可以从下面的结果中看到:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="18e9" class="od mq it ow b gy pa pb l pc pd">$ time <strong class="ow iu">./problem11 </strong><br/>Max product is: 70600674</span><span id="410f" class="od mq it ow b gy pe pb l pc pd">real    0m0.006s<br/>user    0m0.006s<br/>sys 0m0.001s</span></pre><h2 id="73d1" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated">问题12——高度可分的三角形数</h2><blockquote class="op oq or"><p id="dc00" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“三角形数列是通过自然数相加生成的。所以第七个三角形的数字是1 + 2 + 3 + 4 + 5 + 6 + 7 = 28。前十项是:</p><p id="1c34" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi">1, 3, 6, 10, 15, 21, 28, 36, 45, 55, …</p><p id="a414" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">让我们列出前七个三角形数字的因数:</p><p id="e07b" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated"><strong class="kw iu">1</strong>:1<br/>T8】3:1，3<br/>T11】6:1，2，3，6<br/>T14】10:1，2，5，10<br/>15:1，3，5，15<br/>T20】21:1，3，7，21<br/>T23】28:1，2</p><p id="cf60" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">我们可以看到28是第一个有五个以上除数的三角形数。</p><p id="3a4f" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">超过五百个约数的第一个三角形的值是多少？"</p></blockquote><p id="2fbc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">先看看怎么蛮力吧。第一种简单的方法如下:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="cb89" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="d6e5" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="0877" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    n := 1<br/>    triangle := 0<br/>    for ;; {<br/>        triangle += n<br/>        numberOfDivisors := 0<br/>        for i := 1; i &lt;= triangle; i++ {<br/>            if triangle % i == 0 {<br/>                numberOfDivisors++<br/>            }<br/>        }<br/>        if numberOfDivisors &gt;= 300 {<br/>            fmt.Printf("triangle: %d has %d divisors\n", triangle, numberOfDivisors)<br/>            break<br/>        }<br/>        n++<br/>    }<br/>}</span></pre><p id="d0ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该解决方案能够在大约13秒内找到第一个超过300个除数的数字，如以下结果所示:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="acf8" class="od mq it ow b gy pa pb l pc pd">$ time ./problem12 <br/>triangle: <strong class="ow iu">2162160</strong> has 320 divisors</span><span id="aa3f" class="od mq it ow b gy pe pb l pc pd">real    0m12.920s<br/>user    0m12.917s<br/>sys 0m0.016s</span></pre><p id="d6a2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当试图找到第一个超过<strong class="kw iu"> <em class="nw"> 500个约数</em> </strong>的数时，上面的算法真的真的很慢。</p><p id="e395" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">高度合成的三角数</strong></p><p id="0f65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过一番研究和挫折，我发现这些数被称为“高复合三角数”。该列表可以在<a class="ae oc" href="https://oeis.org/A076711" rel="noopener ugc nofollow" target="_blank">在线整数序列百科全书</a>中找到。我们有我们的解决方案，我们要找的号码是<strong class="kw iu"> <em class="nw"> 76576500 </em> </strong>。</p><p id="7b21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">概述问题解决方案为我们提供了以下帮助:</p><blockquote class="op oq or"><p id="2933" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">当除数超过三角形数的平方根时，可以通过停止除法来改进。对于每一个精确到平方根的除数，平方根以上都有相应的除数。”</p></blockquote><p id="ff15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个帮助下改变了我的算法后，我得出了以下结论:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="5435" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="412a" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "math"<br/>)</span><span id="52bf" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    n := 1<br/>    triangle := 0<br/>    for {<br/>        triangle += n<br/>        numberOfDivisors := 0<br/>        to := int(math.Sqrt(float64(triangle)))<br/>        for i := 1; i &lt;= to; i++ {<br/>            if triangle%i == 0 {<br/>                numberOfDivisors += 2<br/>            }<br/>        }<br/>        if numberOfDivisors &gt;= 500 {<br/>            fmt.Printf("triangle: %d has %d divisors\n", triangle, numberOfDivisors)<br/>            break<br/>        }<br/>        n++<br/>    }<br/>}</span></pre><p id="54c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如下图，不到一秒就找到解了！</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="4515" class="od mq it ow b gy pa pb l pc pd">time ./problem12-improved2 <br/>triangle: 76576500 has 576 divisors</span><span id="7e30" class="od mq it ow b gy pe pb l pc pd">real    0m0.407s<br/>user    0m0.409s<br/>sys 0m0.000s</span></pre><h2 id="0623" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题13 — </strong>大额</h2><blockquote class="op oq or"><p id="1b1c" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“算出下面100个50位数之和的前十位数字:</p></blockquote><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="ad3a" class="od mq it ow b gy pa pb l pc pd">37107287533902102798797998220837590246510135740250<br/>46376937677490009712648124896970078050417018260538<br/>74324986199524741059474233309513058123726617309629<br/>91942213363574161572522430563301811072406154908250<br/>23067588207539346171171980310421047513778063246676<br/>89261670696623633820136378418383684178734361726757<br/>28112879812849979408065481931592621691275889832738<br/>44274228917432520321923589422876796487670272189318<br/>47451445736001306439091167216856844588711603153276<br/>70386486105843025439939619828917593665686757934951<br/>62176457141856560629502157223196586755079324193331<br/>64906352462741904929101432445813822663347944758178<br/>92575867718337217661963751590579239728245598838407<br/>58203565325359399008402633568948830189458628227828<br/>80181199384826282014278194139940567587151170094390<br/>35398664372827112653829987240784473053190104293586<br/>86515506006295864861532075273371959191420517255829<br/>71693888707715466499115593487603532921714970056938<br/>54370070576826684624621495650076471787294438377604<br/>53282654108756828443191190634694037855217779295145<br/>36123272525000296071075082563815656710885258350721<br/>45876576172410976447339110607218265236877223636045<br/>17423706905851860660448207621209813287860733969412<br/>81142660418086830619328460811191061556940512689692<br/>51934325451728388641918047049293215058642563049483<br/>62467221648435076201727918039944693004732956340691<br/>15732444386908125794514089057706229429197107928209<br/>55037687525678773091862540744969844508330393682126<br/>18336384825330154686196124348767681297534375946515<br/>80386287592878490201521685554828717201219257766954<br/>78182833757993103614740356856449095527097864797581<br/>16726320100436897842553539920931837441497806860984<br/>48403098129077791799088218795327364475675590848030<br/>87086987551392711854517078544161852424320693150332<br/>59959406895756536782107074926966537676326235447210<br/>69793950679652694742597709739166693763042633987085<br/>41052684708299085211399427365734116182760315001271<br/>65378607361501080857009149939512557028198746004375<br/>35829035317434717326932123578154982629742552737307<br/>94953759765105305946966067683156574377167401875275<br/>88902802571733229619176668713819931811048770190271<br/>25267680276078003013678680992525463401061632866526<br/>36270218540497705585629946580636237993140746255962<br/>24074486908231174977792365466257246923322810917141<br/>91430288197103288597806669760892938638285025333403<br/>34413065578016127815921815005561868836468420090470<br/>23053081172816430487623791969842487255036638784583<br/>11487696932154902810424020138335124462181441773470<br/>63783299490636259666498587618221225225512486764533<br/>67720186971698544312419572409913959008952310058822<br/>95548255300263520781532296796249481641953868218774<br/>76085327132285723110424803456124867697064507995236<br/>37774242535411291684276865538926205024910326572967<br/>23701913275725675285653248258265463092207058596522<br/>29798860272258331913126375147341994889534765745501<br/>18495701454879288984856827726077713721403798879715<br/>38298203783031473527721580348144513491373226651381<br/>34829543829199918180278916522431027392251122869539<br/>40957953066405232632538044100059654939159879593635<br/>29746152185502371307642255121183693803580388584903<br/>41698116222072977186158236678424689157993532961922<br/>62467957194401269043877107275048102390895523597457<br/>23189706772547915061505504953922979530901129967519<br/>86188088225875314529584099251203829009407770775672<br/>11306739708304724483816533873502340845647058077308<br/>82959174767140363198008187129011875491310547126581<br/>97623331044818386269515456334926366572897563400500<br/>42846280183517070527831839425882145521227251250327<br/>55121603546981200581762165212827652751691296897789<br/>32238195734329339946437501907836945765883352399886<br/>75506164965184775180738168837861091527357929701337<br/>62177842752192623401942399639168044983993173312731<br/>32924185707147349566916674687634660915035914677504<br/>99518671430235219628894890102423325116913619626622<br/>73267460800591547471830798392868535206946944540724<br/>76841822524674417161514036427982273348055556214818<br/>97142617910342598647204516893989422179826088076852<br/>87783646182799346313767754307809363333018982642090<br/>10848802521674670883215120185883543223812876952786<br/>71329612474782464538636993009049310363619763878039<br/>62184073572399794223406235393808339651327408011116<br/>66627891981488087797941876876144230030984490851411<br/>60661826293682836764744779239180335110989069790714<br/>85786944089552990653640447425576083659976645795096<br/>66024396409905389607120198219976047599490197230297<br/>64913982680032973156037120041377903785566085089252<br/>16730939319872750275468906903707539413042652315011<br/>94809377245048795150954100921645863754710598436791<br/>78639167021187492431995700641917969777599028300699<br/>15368713711936614952811305876380278410754449733078<br/>40789923115535562561142322423255033685442488917353<br/>44889911501440648020369068063960672322193204149535<br/>41503128880339536053299340368006977710650566631954<br/>81234880673210146739058568557934581403627822703280<br/>82616570773948327592232845941706525094512325230608<br/>22918802058777319719839450180888072429661980811197<br/>77158542502016545090413245809786882778948721859617<br/>72107838435069186155435662884062257473692284509516<br/>20849603980134001723930671666823555245252804609722<br/>53503534226472524250874054075591789781264330331690</span></pre><p id="2186" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个也很有趣。很明显，一个原始数字无法容纳所有这些数字的总和，所以我们将需要使用<a class="ae oc" href="https://golang.org/pkg/math/big/" rel="noopener ugc nofollow" target="_blank"> <em class="nw">大数字</em> </a> <em class="nw">。</em>解决方案非常简单，如下所示:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="ce7d" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="508b" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "math/big"<br/>    "strings"<br/>)</span><span id="3ea0" class="od mq it ow b gy pe pb l pc pd">const numText = `37107287533902102798797998220837590246510135740250<br/>... more numbers<br/>...<br/>`</span><span id="d8be" class="od mq it ow b gy pe pb l pc pd">func main() {</span><span id="7c7a" class="od mq it ow b gy pe pb l pc pd">    sum := big.NewInt(0)</span><span id="4864" class="od mq it ow b gy pe pb l pc pd">    for _, line := range strings.Split(numText, "\n") {<br/>        n := new(big.Int)<br/>        bn, _ := n.SetString(line, 10)<br/>        sum.Add(sum, bn)<br/>    }</span><span id="291b" class="od mq it ow b gy pe pb l pc pd">    sumStr := sum.String()<br/>    fmt.Println(sumStr[:10])</span><span id="c3e6" class="od mq it ow b gy pe pb l pc pd">}</span></pre><p id="35d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="8440" class="od mq it ow b gy pa pb l pc pd">$ time ./problem13 <br/>5537376230</span><span id="385e" class="od mq it ow b gy pe pb l pc pd">real    0m0.006s<br/>user    0m0.003s<br/>sys 0m0.004s</span></pre><h2 id="fbd4" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题14 — </strong>最长排序序列</h2><blockquote class="op oq or"><p id="bb43" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">为正整数集合定义了以下迭代序列:</p><p id="b59a" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated"><code class="fe pf pg ph ow b">n → n/2 (n is even)<br/>n → 3n + 1 (n is odd)</code></p><p id="037b" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">使用上述规则，从13开始，我们生成以下序列:</p><p id="ee7d" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated"><em class="it">13→40→20→10→5→16→8→4→2→1</em></p><p id="0cae" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">可以看出，这个序列(从13开始，到1结束)包含10个术语。虽然还没有证明(Collatz问题)，但是认为所有的起始数都以1结尾。</p><p id="b41d" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">哪一个小于一百万的起始数字产生了最长的链？</p><p id="a783" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">注意:一旦连锁开始，条款允许超过一百万。"</p></blockquote><p id="ea6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的解决方案是:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="a1d0" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="b3b4" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="5f13" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    numberThatGeneratesTheLongestChain := 1<br/>    chainLen := 1</span><span id="93b5" class="od mq it ow b gy pe pb l pc pd">    for i := 2; i &lt;= 1_000_000; i++ {<br/>        count := 1<br/>        start := i<br/>        for start != 1 {<br/>            if start % 2 == 0 {<br/>                start /= 2<br/>            } else {<br/>                start = start * 3 + 1<br/>            }<br/>            count++<br/>        }<br/>        if count &gt; chainLen {<br/>            chainLen = count<br/>            numberThatGeneratesTheLongestChain = i<br/>        }<br/>    }<br/>    fmt.Printf("%d generates %d\n", numberThatGeneratesTheLongestChain, chainLen)<br/>    <br/>}</span></pre><p id="5a51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面显示的解决方案也是蛮力的，但它有效(<em class="nw"> &lt; 0.2秒</em>):</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="efe8" class="od mq it ow b gy pa pb l pc pd">$ time ./problem14 <br/>837799 generates 525</span><span id="df29" class="od mq it ow b gy pe pb l pc pd">real    0m0.243s<br/>user    0m0.240s<br/>sys 0m0.004s</span></pre><h2 id="e194" class="od mq it bd mr oe of dn mv og oh dp mz ld oi oj nb lh ok ol nd ll om on nf oo bi translated"><strong class="ak">问题15 — </strong>点阵路径</h2><blockquote class="op oq or"><p id="dd1c" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">“从一个<strong class="kw iu"> 2×2网格</strong>的左上角开始，只能向右下移动，到右下角正好有6条路线。</p></blockquote><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/a92f5d2387797accda8cf28c2d64511e.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*SWEPk2t_jZV1riF1MeKhGw.png"/></div></figure><blockquote class="op oq or"><p id="7515" class="ku kv nw kw b kx ky ju kz la lb jx lc os le lf lg ot li lj lk ou lm ln lo lp im bi translated">通过一个<strong class="kw iu"> 20×20的网格</strong>有多少条这样的路线？"</p></blockquote><p id="2034" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题叫做<a class="ae oc" href="https://www.robertdickau.com/lattices.html" rel="noopener ugc nofollow" target="_blank">【格子路径】</a>。这些路径可以使用<a class="ae oc" href="https://www.robertdickau.com/manhattan.html" rel="noopener ugc nofollow" target="_blank">中心二项式系数</a>来计算，例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/e02585ff4ddc75829249981704075c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:66/1*tYoGWNWxCJG4dX3wMAJRkw.gif"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/23296ec199665dd722375e28fdf39696.png" data-original-src="https://miro.medium.com/v2/resize:fit:74/1*70oB7mKEv-kd7lVZXXPCgw.gif"/></div></figure><p id="b26e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">n = 20</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/262c70e5a5d9ad14f16dfa3a6fa0f8bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/1*qiZROcMs9hT96PyzjV41DA.png"/></div></figure><p id="ffb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该解决方案可通过Wolfram Alpha进行检查，链接如下:</p><div class="lq lr gp gr ls lt"><a href="https://www.wolframalpha.com/input/?i=n+%3D+20%3B+%282+*+n%29%21+%2F+%28n%21%29%5E2" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">n = 20(2 * n)！/ (n！)^2 -沃尔夫拉姆|阿尔法</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">啊哦！Wolfram|Alpha没有JavaScript就无法运行。请启用JavaScript。如果你不知道怎么做，你可以找…</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">www.wolframalpha.com</p></div></div><div class="mc l"><div class="pt l me mf mg mc mh ko lt"/></div></div></a></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/3e221c835cc9322bce6fcf5af85d205b.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*eMPgpRcZd1dnBbol5Ns9og.png"/></div></figure><p id="851e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，该解决方案涉及到使用阶乘函数。问题是，我们需要计算40这个数字的阶乘，这会溢出类型。我们将需要再次使用大数字。让我们用大数写一个阶乘函数，帮助我们计算<code class="fe pf pg ph ow b">(2 * n)! / (n!)²</code>:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="eadc" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="aafb" class="od mq it ow b gy pe pb l pc pd">import (<br/>    "fmt"<br/>    "math/big"<br/>)</span><span id="9dd9" class="od mq it ow b gy pe pb l pc pd">func factorial(n int) *big.Int {<br/>    f := big.NewInt(1)</span><span id="368c" class="od mq it ow b gy pe pb l pc pd">    for i := 1; i &lt;= n; i++ {<br/>        f.Mul(f, big.NewInt(int64(i)))<br/>    }</span><span id="8858" class="od mq it ow b gy pe pb l pc pd">    return f<br/>}</span><span id="d3eb" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    // n = 20; (2 * n)! / (n!)^2</span><span id="78cb" class="od mq it ow b gy pe pb l pc pd">    n := 20<br/>    a := factorial(2  * n)<br/>    b := factorial(n)<br/>    b.Mul(b, b)</span><span id="440a" class="od mq it ow b gy pe pb l pc pd">    result := new(big.Int)</span><span id="86d8" class="od mq it ow b gy pe pb l pc pd">    result.Div(a, b)</span><span id="7fa3" class="od mq it ow b gy pe pb l pc pd">    fmt.Println(result)<br/>}</span></pre><p id="e1dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="e690" class="od mq it ow b gy pa pb l pc pd">$ time ./problem15 <br/>137846528820</span><span id="e06b" class="od mq it ow b gy pe pb l pc pd">real    0m0.005s<br/>user    0m0.001s<br/>sys 0m0.005s</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="6100" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">我学习编程语言基础的策略</h1><p id="d5f1" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">假设我想学习Ruby、Nim、Clojure或Haskell，我会在Project Euler上创建一个帐户并尝试解决前15个问题。</p><p id="e2a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我完成了，我就回到第一个问题，并尝试基于我从其他编程语言中了解到的重构技术来更改代码。</p><p id="cd24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，对于第一个问题，我使用了以下条件:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="83bc" class="od mq it ow b gy pa pb l pc pd">if i % 3 == 0 || i % 5 == 0 {<br/>    sum += i<br/>}</span></pre><p id="9b9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我可以把它改成如下:</p><pre class="kj kk kl km gt ov ow ox oy aw oz bi"><span id="1278" class="od mq it ow b gy pa pb l pc pd">package main</span><span id="7311" class="od mq it ow b gy pe pb l pc pd">import "fmt"</span><span id="89c3" class="od mq it ow b gy pe pb l pc pd">func isDivisibleBy3Or5(n int) bool {<br/>    return n % 3 == 0 || n % 5 == 0<br/>}</span><span id="9242" class="od mq it ow b gy pe pb l pc pd">func main() {<br/>    sum := 0<br/>    for i := 1; i &lt; 1_000; i++ {<br/>        if isDivisibleBy3Or5(i) {<br/>            sum += i<br/>        }<br/>    }<br/>    fmt.Printf("Sum: %d\n", sum)<br/>}</span></pre><p id="4795" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后问自己，“这是惯用的吗？”。然后，挖掘它，继续前进。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b5bd" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="8b82" class="pw-post-body-paragraph ku kv it kw b kx nh ju kz la ni jx lc ld nj lf lg lh nk lj lk ll nl ln lo lp im bi translated">我鼓励您尝试用自己选择的编程语言来解决其中的一些问题。目标是在学习的同时找点乐子！</p><p id="dc01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请在评论中让我知道你的想法。谢谢大家！</p><p id="36c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae oc" href="https://github.com/leogtzr/15_projecteuler_solutions_Golang" rel="noopener ugc nofollow" target="_blank">https://github.com/leogtzr/15_projecteuler_solutions_Golang</a></p></div></div>    
</body>
</html>