# Point-Free 的快速组合架构

> 原文：<https://betterprogramming.pub/swift-composable-architecture-an-introductory-view-on-my-first-experiences-a55c6cf32d9e>

## 对我第一次经历的初步看法

![](img/1586ab1ab1783e62211a85db0c6b476f.png)

由 [Przemyslaw Marczynski](https://unsplash.com/@pemmax?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

(注意:这是很长的东西，而且不是完整的代码。这更像是一个概念和用法的旅程，所以会花你一些时间。)

似乎有一个新的炒作来源正在增长。虽然到目前为止，iOS/macOS 架构主要由 MVC、MVVM 或 Clean Swift(或其他)驱动，但两年前推出的 SwiftUI 建立了一个不同的范式，其中许多架构并不完全适合。

多年来，我们尝试了各种方法，以便为我们的应用找到正确的方法，由于架构和维护问题，这需要大量的返工。然而，没有一个经典的方法真正有用，主要是因为它是一个相当大的业务应用程序，具有大量的存储实体，其中许多功能应在不同的上下文中重用——随着使用 SwiftUI 的应用程序的返工越来越多，在保持一切整洁和分离方面出现了越来越多的问题。

偶然的，也是纯粹的运气，我注意到了由 [Point-Free](https://www.pointfree.co/) 创建的叫做 Swift Composable Architecture(SCA)的东西。我看了一些文章和帖子，看了他们的网站，买了他们的节目，看了视频，越来越有热情。

虽然我仍然没有真正理解框架的所有内容，并且仍然专注于简单的用例，但我同时成功地构建了几个视图，感受到了它对我们的应用程序的好处。

因为我想要一个简短的入门部分，包含一些之前/之后的代码片段(实际上，为了进入 SCA，我不得不观看和阅读了大量的*，但是可能我错过了一些东西)，我将尝试与您分享我的一些经验，希望它可以帮助您更容易地进入这个架构。*

# *入门指南*

*在我们的应用程序中，我们有一个向用户公开所有可用数据项的地方。*

*所以首先我们需要一个数据类型的列表(比如`companies`、`persons`、`industries`等)。).当用户选择其中一个时，他们将得到该类型所有可用项目的列表(所有公司、所有人、所有行业等。).最后，当选择其中一个项目时，他们将获得编辑该项目的详细视图(公司 *X* ，人员 *Y* ，行业 *Z* 等)。).您可以称之为经典的主视图/详细视图序列。*

*我们需要一些对存储的灵活访问(我不会在这里介绍)，我们需要所有数据类型的相同概览列表，即使细节视图不同—我们需要使用类似的构建块来获得这些(我也不会在这里介绍)。但对我来说，第一个也是最基本的问题是找出整体结构应该如何设置。*

# *设置整体结构*

*所以我拿了点免提供的样本代码库和他们的视频做了实验。(为了便于处理，我在这里只使用简单的数据结构——没有核心数据等等。)*

*让我们从最顶端往下钻。起点是某种类型的`TabView` ，它将引导我们进入数据类型概述页面。目前只有一页。*

*这都是经典的 swift ui——到目前为止没什么特别的。现在让我们来看看`MaintainAllDataView`。*

*这看起来还是像 SwiftUI。但是等等:那个奇怪的`industries`设置是什么，那个`NavigationLink` 又是什么东西？*

*SCA 有几个您必须理解的基本概念。让我们开始解释它们(至少就我的理解而言)。*

# *SCA 基本概念*

*最简单的概念是国家。SwiftUI 处理状态，当状态发生变化时，视图被刷新。到目前为止，一切顺利。*

*通常，你会用一些`@ObservableObject` 或者`@StateObject`变量来表达这个。根据我的经验，这些对象往往会变得越来越大，越来越复杂。但是我们如何系统地避免这种情况呢？*

*因此，SCA 将状态从所有其他事物中分离出来。通常，它只不过是一个简单的结构，带有一些数据属性，理想情况下是`Identifiable`和`Equatable`(出于列表处理和更新的原因)。出于我们的目的，我们只希望一个`Industry`有一个`ID`和一个`name`:*

*所以视图中的`industries`变量声明只是将一些数据放入整个游戏中——并不复杂。*

*但是数据集如何流入通过`NavigationLink`应该到达的视图呢？*

# *介绍商店*

*这就是商店发挥作用的时刻。实际上，商店只不过是一个(初始)状态、一个缩减器和一个环境的组合。*

*但是商店是交给视图的中心元素。让我们看看另一边的`IndustriesView`:*

*正如你所看到的，有一个财产持有我们注入的商店。我们暂时不会在这里深入探讨，所以让我们跳回`NavigationLink` *。**

*我们现在了解了状态，那么让我们看看现在的环境。虽然状态提供了控制视图的一切，但是环境被用来注入它工作所需的其他东西——典型的例子是核心数据的托管对象上下文。*

*在我们的例子中，`IndustriesEnvironment`只是一个空结构:*

*我们现在理解了状态和环境，但是那个不祥的缩减器呢？*

# *介绍减速器*

*为了回答这个问题，我们一步一步地检查它:*

*首先，我们注意到 reducer 不仅仅需要状态和环境，还需要一些动作。这到底是什么？我们走着瞧。*

*然后，我们注意到它结合了另外两个减速器。*

*最后，我们看到第一个子减压器对那个动作起作用，而第二个子减压器做了一些我们还不理解的魔术。*

*那么这里发生了什么——是反应式编程的迷雾吗？*

# *介绍行动*

*从我的角度来看，SCA 的主要优势和好处之一是分离所有维度的关注点。从那里看，一个视图应该只是获取并显示它们，它应该检测用户的动作并对它们做出反应。然而，观众对*事情如何发生*和*反应如何*不感兴趣。*

*在经典的 SwiftUI 中，您会将这些方面放入被观察的对象中，将它们混合起来。*

*在 SCA 中，状态是如何将事物提供给视图的，而 reducer 是对动作做出反应的地方。它分离了关注点，因此带来了更多的清晰性、可理解性、可维护性和可测试性。*

*为此，您需要由视图发送并由 reducer 接收的动作(通过存储——这是 SCA 背后的抽象魔法)。*

*我们的操作看起来像这样，您马上就能理解视图提供了什么功能(嗯，*应该在最后提供*——我们不会在本文中讨论这一点)。删除索引中的一个项目，将项目从这里移到那里，添加一个项目，然后…嗯，什么？我们一会儿会谈到这一点。*

*这就是 SCA 对我如此有吸引力的原因:当你搜索某个东西时，你总是有一个确切的地方可以看。您想在视图中再处理一个属性吗？将其添加到状态中。你想在视图中有另一个动作吗？将它添加到 action 枚举中，从视图中触发它，并在 reducer 中对它做出反应。想用不同的方式呈现某样东西？修改视图。而且一切都是明确分开的，所以没有任何东西会以不希望的方式影响其他东西。*

*但是现在，减速器到底是做什么的呢？*

# *' ForEachStore '*

*它目前支持的唯一动作是`.industry`动作。该动作在`ForEachStore`调用中触发。*

*这里发生了什么事？因为一个`NavigationLink`将打开视图来编辑所选择的行业，我们需要将该行业传输到被调用的`IndustryView`的东西。*

*因此，我们需要的是一家`IndustryView`商店，它正好拥有一个行业:*

*`NavigationLink(destination: IndustryView(store: industryStore)…)`*

*我们怎么去这家店？(记得我们将`IndustryState`定义为`Identifiable`和`Equatable`。)看一下`ForEachStore`。*

*`ForEachStore`语句是一个 SCA 元素，它允许您轻松地遍历视图存储提供的内容，同时可以轻松地集成到 SwiftUI 视图层次结构中。*

*在我们的例子中，那个*东西*是通过在商店的`industries`属性上设置范围来定义的:*

*`… ForEachStore(store.scope(state: \.industries, …))`*

*这意味着:交付到 trailing closure 中的是一个商店，一个接一个地专注于这个属性的项目。*

*我们此刻接受了魔法，所以我们现在可以把那个`industryStore`交给`IndustryView`。*

*我们完了。至少对于视图序列来说是这样。*

# *谜语的最后一部分*

*那么`ForEachStore`的第二部分`action: parameter`呢？*

*`ForEachStore(store.scope(state: \.industries, **action: IndustriesAction.industry(id:action:))**)`*

*这就是触发选择列表中的项目的原因。SCA 封装了一切，所以只提供动作本身(`.industry`)和参数交给 reducer 就足够了。*

*让我们回到减速器，因为我们仍然需要解决一个谜题。*

*我们现在知道第一个减速器处理由`IndustriesView`发出的动作。当`.industry`动作到达时，减速器只做一件事:什么也不做。这意味着它将返回`.none`。*

*但是我们有第二个减速器，即`industryReducer`。那是什么？*

# *'工业减速器'*

*让我们切换到一个专用行业的上下文，看看它的 reducer 是如何定义的:*

*显然，这些都是那里可能发生的行动。实际上，没有太多——只是改变了一个行业的名称。(您是否注意到，仅通过查看减速器，这是多么容易理解？)*

*因此，从列表的角度来看，事情很简单:*

*   *将`industryReducer`应用于每个给定的状态项(即`.industries`)*
*   *如果一个动作`.industry`发生，执行列表中给定行业的动作*

*因为我们在列表级别不做任何事情，所以只执行视图的`NavigationLink`目的地——仅此而已。*

*但是我们不能省去第二个减速器吗？*

# *为什么我们不能省去第二个减速器呢？*

*当尝试这样做时，你会注意到该应用程序没有按预期执行。首先，让我们再看看`IndustryView`:*

*如果我们注释掉第二个 reducer 会怎么样？应用程序仍然会构建，仍然会工作。但是如果您更改了一个行业的名称，这将不会被持久化—更改会立即丢失。*

*为什么会这样？*

*嗯，`IndustriesView`的减速器将这两个子减速器结合起来，并将结果(作为一个新状态)传递给`IndustryView`的存储器。*

*如果没有第二个缩减器，返回的状态将与我们已经拥有的状态相同——因此将显示之前的列表状态(并传递给视图层次结构)。*

*对于第二个缩减器，我们为`IndustryView`创建了一个新的状态，并因此获得了那个变化。不仅`IndustryView`更新其显示，而且`IndustriesView`显示的列表也将被更新。(顺便说一句，如果有人能解释这到底是如何发生在我身上的，我很乐意完全理解这一点。对我来说还是有些魔力的。)*

# *结论*

*我很高兴你跟踪我到这一步。我知道这是很多东西，但是我希望它可以帮助您了解这种用例的 SCA 基础。我还在摸 SCA 的皮毛，但我真的对它充满热情。自由点的两个家伙真的做得很好！*

*还有很多东西需要探索，尤其是如何使用 effects 在一些持久存储上执行 CRUD 操作。如果你愿意，一旦我成功地挖掘了那个主题，还会有一些后续文章。*