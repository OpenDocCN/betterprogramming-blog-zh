<html>
<head>
<title>The Magic of the Rust Borrow Checker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生锈借检查器的魔力</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-magic-of-borrow-checkers-in-rust-238a2a97bff2?source=collection_archive---------4-----------------------#2022-11-09">https://betterprogramming.pub/the-magic-of-borrow-checkers-in-rust-238a2a97bff2?source=collection_archive---------4-----------------------#2022-11-09</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="f836" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">了解Rust编程语言的独特之处</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/894fc0921791fdbafdc0cf63240cec81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6i93fF841B1nCfnF"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">由<a class="ae kw" href="https://unsplash.com/@jantined?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c68b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当我第一次偶然发现Rust时，是通过一篇文章，这篇文章吹捧Rust在Stack Overflow的年度最受欢迎编程语言调查中连续几年被选为“最受欢迎的编程语言”。</p><p id="5146" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">高级语言描述很有趣——编译、无虚拟机、高效、快速、安全。我承认对编译语言和类型安全语言的偏爱。我在C上长大，教过C、C++和Java，职业生涯的大部分时间都在使用Java。在我研究的早期，我碰到了一堆类似“为什么Rust比<insert programming="" language="" here="">更好”和“为什么你应该学习Rust”的文章。</insert></p><p id="ec40" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">它们似乎都来自同一个根源——并且大部分涵盖了任何不在虚拟机运行时上运行的静态类型语言所拥有的要点。“快得惊人”“在编译时发现变量类型不匹配”就是例子。</p><p id="04b7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">缺少的是对Rust的独特之处的解释，这是其他语言所没有的。我想解决本文中的第一个原因Rust借用检查器。</p><p id="76c6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Rust的发明者受益于其他编程语言的多年实践经验。他们在语言和相关工具中设计了一组特性，解决了应用程序开发人员面临的许多棘手问题。首先是内存管理。从一开始，程序就处理如何安全地使用内存，而Rust借用检查器是解决这个问题的一种新方法。</p><h1 id="57f9" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">一些历史</h1><p id="7525" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">首先，让我回顾一下编程语言试图解决这个问题的历史。一开始有C，还有低级的、经常被诅咒的“<code class="fe mq mr ms mt b">malloc()</code>”和“<code class="fe mq mr ms mt b">free()</code>”c是一种编程语言，它让开发人员能够完全控制他们的环境——它是汇编语言的一小步。</p><p id="c2ee" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">开发人员可以完全管理应用程序的内存访问，以及如何将分配的内存交还给操作系统。这种低层次的控制需要大量仔细的计划。但是，它是许多运行时错误的来源，通过内存泄漏(不释放内存)或崩溃(释放同一个指针两次或在释放后使用内存是常见的问题)。这也是安全问题的一个来源——读取先前释放的内存中不应该有的数据可能会被利用。</p><p id="d7e9" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面是一个示例程序，它演示了编译器允许但不正确的内容:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">c代码示例</p></figure><p id="37d5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">C++能够更好地控制内存分配。类有构造函数为它们的对象分配内存，析构函数释放内存。还创建了智能指针，在变量超出范围时帮助自动释放内存。但是低级指针和引用的“脚枪”使得错误难以消除。如果你遵循这些规则，你是没问题的，但是如果你不知道这些规则，编译器是没有任何帮助的。对象内部隐藏的复杂性也使得遵循规则和预测应用程序的性能变得困难。</p><h1 id="403e" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">碎片帐集</h1><p id="d1f1" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">编程语言转向垃圾收集作为解决这些问题的手段。基于垃圾收集的程序可以从运行时环境中获取它们需要的任何内存。在后台，一旦程序不再使用内存，垃圾收集进程就会将内存释放回操作系统。依赖于在运行时解释源代码的脚本语言，包括Basic、Python和JavaScript，在其解释器的运行时环境中使用这种方法。</p><p id="ea1c" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Java是第一种以在执行垃圾收集的运行时(JVM)中运行为目标的编译语言。新的编程语言，包括Golang (Go)和Dart，利用了垃圾收集。这些环境对于开发人员来说是高效的——它使得管理内存变得更加简单。垃圾收集器已经变得非常复杂，许多应用程序类型在这种环境下都能很好地工作。</p><p id="0309" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是垃圾收集有其局限性。垃圾收集器带来的开销会影响应用程序的运行时行为。应用程序中的暂停必须被调度，这使得垃圾收集语言不适合实时编程。伴随环境的运行时通常也是重量级的，这在嵌入式和物联网设备(或容器化微服务)的小环境中运行时会造成阻碍。</p><p id="f48e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里有一个与我们的C版本类似的Java应用程序的简单例子。它展示了垃圾收集是如何有用的:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">Java代码示例</p></figure><p id="f60a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">一切都可以编译，但是我们在运行时得到的是一致的崩溃，而不是未定义的运行时行为；这有好有坏。可预测的行为是好的，但是Java " <code class="fe mq mr ms mt b">NullPointerException</code>"运行时错误已经使生产中的应用程序崩溃了很多次，这是任何人都不愿意承认的。</p><p id="a52d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">当我们注释掉错误的行时，我们现在会看到一个副作用——新变量没有接收到数组的全新版本；它只是“指向”原文。当我们修改新变量时，原来的变量的内容被修改掉了。在这个简单的例子中，我们可以跟踪这里发生的事情，但是如果修改发生在嵌套库函数的深处，我们很容易感到惊讶。</p><p id="0155" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但是，我们的内存管理更加简单。我们可以在运行时请求我们需要的内存空间，而不必处理放弃它的问题。易用性是垃圾收集广泛存在的原因，像JavaScript、Python、Go和Dart这样的主流语言今天都在使用它。</p><h1 id="a9e4" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">铁锈有什么不同</h1><p id="e75b" class="pw-post-body-paragraph kx ky ir kz b la ml js lc ld mm jv lf lg mn li lj lk mo lm ln lo mp lq lr ls ik bi translated">Rust的内存管理方法简化了垃圾收集环境的内存管理，而没有运行时环境开销或相关的性能损失。它还解决了我们在Java示例中看到的意外副作用问题。</p><p id="913e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">智能指针风格的机制是一个关键，但是编译器强制执行访问规则，而不是依赖程序员来遵循使用规则(如C++)。“对抗借用检查器”是Rust新开发人员首先要解决的问题之一，但是一旦掌握了，它就能让开发人员自动管理他们的内存使用。</p><p id="d5ef" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">除了高效的开发环境，Rust的借用检查器还消除了一整类与内存管理相关的编程错误。调查表明，应用程序中的许多安全漏洞是由于程序无法保护对已分配内存的访问。Rust程序运行速度快，使开发人员更高效，更安全，并减少运行时崩溃。</p><p id="5228" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">让我们看一个Rust应用程序，它模拟了我们的例子:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">最后—一些生锈的代码！</p></figure><p id="4d58" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们再次使用Rust的Vector类型在堆上分配一块内存。<code class="fe mq mr ms mt b">Vector</code>是动态调整大小的连续内存块，像数组一样被访问，并存储在堆上。相比之下，第8行分配一个数组，它在编译时大小固定，在堆栈上分配。因为我们知道编译时的数组大小，所以我们在第11行得到一个编译器警告。Rust知道我们已经过了数组的末尾。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">Rust的编译器让我们安全。</p></figure><p id="663e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Rust编译器非常擅长给我们提供有意义的错误信息。在第15行，向量被“移动”到一个新家——它在<code class="fe mq mr ms mt b">my_vector</code>不再存在。Rust跟踪分配的内存，但确保只有一个变量“拥有”内存并可以进行更改。</p><p id="ffd6" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">如果我们声明一个变量是不可变的，我们可以把它赋给我们的向量。我们只能通过这个新变量“读取”值，而不能写入它们。Rust强制执行一条规则，即一次只能有一个“作者”/“所有者”——这样，它可以防止所有“谁保存最后谁就赢”的错误，这是我们在Java示例中看到的意外副作用问题。它还可以跟踪使用已分配内存的变量，以确保当使用内存的所有变量都超出范围时，它会被释放。</p><p id="0a21" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面是我们的示例程序，其中一个不可变变量指向我们的向量:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="mu mv l"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">相同的代码，显示借用一个不可变变量。</p></figure><h1 id="f462" class="lt lu ir bd lv lw lx ly lz ma mb mc md jx me jy mf ka mg kb mh kd mi ke mj mk bi translated">Rust的借用检查器的神奇之处在于…</h1><ol class=""><li id="c65e" class="mw mx ir kz b la ml ld mm lg my lk mz lo na ls nb nc nd ne bi translated">Rust确保任何内存(堆或栈)的所有权都在一个地方。只有数据的所有者才能操作它。允许多次只读访问。</li><li id="dfee" class="mw mx ir kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">Rust跟踪使用的内存变量，并在所有使用内存的变量都超出范围时自动释放内存——无论是在堆栈上(我们的数组示例)还是在堆上(我们的Vector示例)。</li><li id="8647" class="mw mx ir kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">边界检查在编译时(对于数组，其大小在编译时确定)或运行时(向量，其大小在运行时设置)强制执行。</li><li id="cace" class="mw mx ir kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">这些规则消除了一整类错误和安全漏洞。我们不能在<code class="fe mq mr ms mt b">free()</code>之后写入内存——只要有任何东西可以访问，Rust就会自动为我们保留内存。这些规则都是在编译时检查的。我们不必担心释放内存——Rust会处理好这一点。边界检查还防止我们在分配给我们的内存空间之外进行写操作。</li><li id="f427" class="mw mx ir kz b la nf ld ng lg nh lk ni lo nj ls nb nc nd ne bi translated">这大部分发生在编译时——我们没有运行时垃圾收集器必须与我们一起运行，并且没有中断程序执行以允许垃圾收集器询问内存使用情况。一个常见的Rust说法是:“如果它编译，它将工作。”</li></ol><p id="531e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">更好的是，借用检查器的工作方式使多个线程能够安全地使用分配的内存。当程序进入多线程执行时，出错的机会会成倍增加。“无所畏惧的并发性”——自动跨多个线程安全地使用数据——是Rust的借用检查器的一个显著优势。</p><p id="956b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">Rust的内存管理和借用检查器是Rust与众不同的两个主要原因。您可以完全控制地访问低级别内存，没有垃圾收集器运行时，也没有运行时错误意外破坏程序的风险。</p><p id="2e20" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这个特性使得Rust非常适合低级别系统、嵌入式或实时应用程序，这些应用程序都需要效率。它还使Rust能够用于更高级别的应用程序，如web服务发布，因为“内存自动释放”环境对开发人员来说是高效的。</p><p id="6a9a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">但这还不是全部。</p><p id="104d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">请继续关注Rust的另一个伟大特性！</p></div></div>    
</body>
</html>