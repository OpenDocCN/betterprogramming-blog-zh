<html>
<head>
<title>Why Don’t React State Updates Reflect Immediately?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React状态更新为什么不立即反映？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-dont-react-state-updates-reflect-immediately-9041c4377385?source=collection_archive---------2-----------------------#2021-04-23">https://betterprogramming.pub/why-dont-react-state-updates-reflect-immediately-9041c4377385?source=collection_archive---------2-----------------------#2021-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cfa5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果您认为状态更新是异步的，那么您只对了一部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1917b30a61d087542743b08ff8c7045c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4r3I72k5Ca_jmx1H"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sixteenmilesout?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">拍摄于<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</a>16英里外</p></figure><p id="519d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用React时，许多人希望状态的变化能够立即反映在带有React钩子的类和功能组件中。</p><p id="d283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">然而，事实并非如此。</em></p><p id="03eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lw lx ly lz b">this.setState</code>或<code class="fe lw lx ly lz b">useState</code>的状态更新不会立即改变状态，而是创建一个挂起的状态转换。在调用updater方法后立即访问状态可能会返回旧值。</p><p id="44f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">不能保证状态更新调用的同步操作，并且出于性能原因，可以批量处理多个状态更新。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e7e3" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">为什么状态更新是异步的？</h1><p id="4dc5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">状态更新会改变虚拟DOM并导致重新呈现，这可能是一个开销很大的操作。使状态更新同步可能会使浏览器因大量更新而无响应。</p><p id="f384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这些问题，我们谨慎地选择了异步状态更新，以及批量更新。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="adf7" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated"><strong class="ak">我可以使用async-await等待setState完成吗？</strong></h1><p id="14bf" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在我们已经确定了<code class="fe lw lx ly lz b">setState</code>是异步的，下一个想到的问题是，如果我们希望在调用<code class="fe lw lx ly lz b">setState</code>后立即访问更新后的状态，那么使用<code class="fe lw lx ly lz b">async-await</code>和<code class="fe lw lx ly lz b">setState</code>是否可行。</p><p id="bcb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们得出任何结论之前，让我们先在一个片段中尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/d8bbd2796697dcac86b3f3d0c5e618df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tmfUwOfd0BCujTLgB9gdPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数和类组件中计数递增时的控制台输出</p></figure><p id="8c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们在运行上述代码片段的控制台中看到的，在类组件中调用setState之后，可以立即访问更新的状态，但是对于功能组件，即使在使用async-await之后，我们仍然会收到旧的状态。</p><p id="484f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">那么，为什么我们在上述场景中会有截然不同的行为呢？</strong></p><p id="f6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于类和功能组件有不同的答案。让我们先试着理解类组件的行为。</p><p id="ec37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lw lx ly lz b">setState</code>的当前实现，更新器回调在<code class="fe lw lx ly lz b">await</code>的解析之前排队，这基本上是用返回值做一个<code class="fe lw lx ly lz b">Promise.resolve </code>。所以，即使<code class="fe lw lx ly lz b">setState</code>不回一个承诺，它也能工作只是巧合。此外，即使它能工作，也不能保证将来React对<code class="fe lw lx ly lz b">setState</code>的实现的改变会保持同样的行为。</p><p id="2f62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在解释为什么async-await不能与功能组件一起工作之前，让我们先探索另一个解决方案。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6b06" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">将setTimeout视为一种可能的解决方案</h1><p id="f0ff" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们知道状态更新是异步的，所以它们一定会在未来的某个时间完成。现在，我们可能认为添加一个具有足够延迟的<code class="fe lw lx ly lz b">setTimeout</code>可以帮助我们获得更新后的值。</p><p id="1c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，在得出任何结论之前，让我们先尝试一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/71fa3646fac1a77438caf4d1ab698078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sgay4N113ya3Q_0XDgNSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用setTimeout在函数和类组件中增加计数时的控制台输出</p></figure><p id="8008" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到，对于一个类组件来说，<code class="fe lw lx ly lz b">setTimeout</code>回调中的状态有了更新的值，但是功能组件仍然没有反映更新的值。</p><p id="f61b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在功能组件中发生了一件有趣的事情。直接放在组件内部的<code class="fe lw lx ly lz b">console.log(count)</code>显示一个更新的值，即使<code class="fe lw lx ly lz b">setTimeout</code>回调在render中的<code class="fe lw lx ly lz b">console.log()</code>之后运行，它仍然显示旧值。</p><p id="5a89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们得出一个有趣的结论。虽然我们认为状态更新是异步的，<em class="lv">我们只是部分正确</em>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f9ef" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">了解问题</h1><p id="8091" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><em class="lv">这都是关于闭包的。</em></p><p id="a5fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于功能组件，状态值在来自其当前闭包的函数内使用，并且尽管状态可能已经在后台更新，但是当前闭包不能引用更新的值。更新后的值将反映在下一个渲染周期中，并为这些值创建新的闭包，而当前的闭包则不受影响。</p><p id="e920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，即使您在<code class="fe lw lx ly lz b">setTimeout</code>中等待很长时间，更新的值也不会在它的回调中可用，同样的原因也适用于为什么<code class="fe lw lx ly lz b">async-await</code>对功能组件中的状态更新器不起作用。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1885" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">如果我们想在调用Setstate后访问更新后的值，我们该怎么做？</h1><p id="938d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对于<code class="fe lw lx ly lz b">Class</code>和<code class="fe lw lx ly lz b">Functional</code>组件，解决方案各不相同。</p><h2 id="1071" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">对于类组件</h2><p id="8d18" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">即使<code class="fe lw lx ly lz b">async-await</code>和<code class="fe lw lx ly lz b">setTimeout</code>都工作，在调用<code class="fe lw lx ly lz b">setState</code>之后访问更新状态的正确方法是下面的一种。</p><ul class=""><li id="9055" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><strong class="lb iu">如果您只想记录或检查更新的值，请直接在render </strong>中访问状态。</li><li id="4401" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><strong class="lb iu">使用</strong> <code class="fe lw lx ly lz b"><strong class="lb iu">setState</strong></code> <strong class="lb iu">回调。</strong> <code class="fe lw lx ly lz b">setState</code>将回调作为状态更新完成时调用的第二个参数。使用它来记录或调用具有更新状态的函数。<code class="fe lw lx ly lz b">setState(() =&gt; {}, callback)</code></li><li id="8d17" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><strong class="lb iu">使用</strong> <code class="fe lw lx ly lz b"><strong class="lb iu">componentDidUpdate</strong></code> <strong class="lb iu">。</strong>在比较当前状态和先前状态后，也可以在<code class="fe lw lx ly lz b">componentDidUpdate</code>中执行副作用(动作)。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用类组件的更新状态的方法</p></figure><h2 id="a9c7" class="ni mi it bd mj nj nk dn mn nl nm dp mr li nn no mt lm np nq mv lq nr ns mx nt bi translated">对于功能组件</h2><p id="1302" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">功能组件严重依赖闭包，为了访问更新的值，我们必须突破那些闭包。访问更新状态的一些推荐方法是:</p><ul class=""><li id="d7c4" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated"><strong class="lb iu">直接访问功能组件内部的状态。</strong>当调用下一个渲染周期时，更新的值将被记录。如果您只想记录或检查更新后的状态，这很有用</li><li id="e4d9" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><strong class="lb iu">利用</strong> <code class="fe lw lx ly lz b"><strong class="lb iu">useEffec</strong></code> <strong class="lb iu"> t钩。</strong>您可以将您的状态作为依赖项添加到<code class="fe lw lx ly lz b">useEffect</code>中，并访问更新后的状态，以记录或使用更新后的状态值执行副作用。</li><li id="b7f6" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><strong class="lb iu">用变异参。这个解决方案包括在ref中保存一个状态值的克隆，并定期更新它。因为引用是变异的，所以它们不受闭包的影响，可以保存更新的值。虽然这与更新状态后访问状态没有直接关系，但当您想要访问事件侦听器或订阅回调(仅在初始呈现时创建)中的更新状态时，这非常有用</strong></li></ul><p id="15db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">查看代码片段，了解关于所提供解决方案的更多信息:</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在功能组件中接收更新状态的方法</p></figure><p id="0729" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们遇到更新状态在更新后不立即可用的情况时，这就是我们需要知道的全部内容。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="50a5" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">关键要点</h1><ul class=""><li id="4902" class="nu nv it lb b lc mz lf na li oi lm oj lq ok lu nz oa ob oc bi translated">React中的状态更新是异步的，因为渲染是一项开销很大的操作，同步状态更新可能会导致浏览器无响应。</li><li id="305b" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated"><code class="fe lw lx ly lz b">this.setState</code>提供了一个回调函数，当状态被更新时调用该函数，并且可以用来访问更新后的状态值。</li><li id="fc7d" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">功能组件中的状态更新会受到闭包的影响，您只能在下一个渲染周期中收到更新后的值。</li><li id="b8c0" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">对于带有react钩子的功能组件，您可以利用<code class="fe lw lx ly lz b">useEffect</code>或<code class="fe lw lx ly lz b">mutationRefs</code>来访问更新的值。</li><li id="8582" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">如果可能，尝试将用于更新状态的值作为参数直接传递给在更新状态后立即调用的函数。</li></ul></div></div>    
</body>
</html>