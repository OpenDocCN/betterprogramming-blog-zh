<html>
<head>
<title>Pragmatic Testing With Pytest-Locker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Pytest-Locker进行语用测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pragmatic-testing-with-pytest-locker-e4d2588223f4?source=collection_archive---------16-----------------------#2020-08-10">https://betterprogramming.pub/pragmatic-testing-with-pytest-locker-e4d2588223f4?source=collection_archive---------16-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a86" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">锁定测试数据输出，提高测试效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20e46a7e98392abe04a0449bf87f9b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7hfMI92ytpdzlto9fwTUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="4d9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我将介绍“锁定”输出的想法，本质上是断言自上次测试运行以来数据没有改变。这是在<a class="ae lu" href="https://github.com/Luttik/pytest-locker" rel="noopener ugc nofollow" target="_blank"> Pytest-Locker </a>中实现的，这是一个“锁定”数据并与<a class="ae lu" href="https://docs.pytest.org/en/stable/" rel="noopener ugc nofollow" target="_blank"> pytest </a>集成的包。虽然这违背了TTD的最佳实践，但它是省时的，提供了清晰性，并且在大量文本或数据的场景中非常有效——尤其是对于易变的界面。</p><p id="3add" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开发代码时，人们总是在编写测试和编写代码之间寻找合适的平衡。此外，仅仅提高代码覆盖率并不是全部。同样重要的是，如果出现任何意外行为，测试就会失败。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="10bb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">斗争:当测试很乏味的时候</h1><p id="fdff" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">多年来，我一直在两个领域努力寻找正确的测试深度:</p><ol class=""><li id="64fe" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">包含大量文本的系统(例如聊天机器人)。</li><li id="e0fe" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">具有在嵌套基础设施中共享数据的接口的系统。</li></ol><p id="1eee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果出现以下一种或两种情况，情况会变得更糟:</p><ol class=""><li id="8024" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">更有可能的是，需求发生了变化，而不是代码由于开发人员的错误而中断，这使得投入到测试中的时间更难证明是合理的。</li><li id="9008" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">您正在与您不希望在测试期间遇到的外部服务进行交互(例如，因为您需要付费使用)。</li></ol><p id="4515" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这些场景中，主要的问题是您需要大量的测试和大量的断言来覆盖所有的行为。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09bc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">灵感:走向解决方案</h1><p id="ed26" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当Bryan Okken(来自Python Bytes和Test&amp;Code)说他的测试经验通常包括简单地运行代码并将代码的输出复制到断言语句中，然后对新代码进行测试时，我想到了一个解决方案。使用此工作流程，您可以有效地锁定行为。</p><p id="2568" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这违背了TTD的红绿重构口号。但这实际上是许多软件工程师在做的事情。此外，虽然当您必须实现一个定义良好的契约时，这是没有意义的，但是当您正在尝试直到“它工作”时，这是有意义的在“它工作”的场景中，您只是想防止它不再工作。</p><p id="97c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，这种try-copy-assert方法仍有一些改进的空间:</p><ol class=""><li id="3b70" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">如果任何阅读测试的人都清楚地知道使用了这种模式，这就太好了，这意味着它不是基于契约本身，而是断言错误可以被解释为行为改变的通知。</li><li id="b646" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">它仍然需要运行、复制和将输出插入到测试中的手工步骤。</li><li id="3b43" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">在上面提到的场景中，您突然结束了大量的测试或者一个嵌套的字典弄乱了您的测试代码。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc2b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决方案:Pytest-Locker</h1><p id="a510" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我的解决方案是Pytest-Locker，它自动化并减轻了try-copy-assert方法的一些缺点。这个包相当简单。它公开了一个名为<code class="fe nn no np nq b">locker</code>的<a class="ae lu" href="https://docs.pytest.org/en/stable/fixture.html" rel="noopener ugc nofollow" target="_blank"> fixture </a>，该fixture又公开了一个名为<code class="fe nn no np nq b">lock</code>的方法。</p><h2 id="5ba6" class="nr md it bd me ns nt dn mi nu nv dp mm lh nw nx mo ll ny nz mq lp oa ob ms oc bi translated">使用</h2><ol class=""><li id="ab1e" class="mz na it la b lb mu le mv lh od ll oe lp of lt ne nf ng nh bi translated">将<code class="fe nn no np nq b">from pytest_locker import locker</code>添加到您的<code class="fe nn no np nq b"><a class="ae lu" href="https://docs.pytest.org/en/2.7.3/plugins.html?highlight=re" rel="noopener ugc nofollow" target="_blank">conftest.py</a></code>文件中。这确保了<code class="fe nn no np nq b">locker</code>夹具在你的测试代码中随处可见。您也可以在您使用它的地方导入它。</li><li id="6b81" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">您在想要断言的数据上调用<code class="fe nn no np nq b">locker.lock</code>。</li><li id="a76a" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">用<code class="fe nn no np nq b">-s</code>或<code class="fe nn no np nq b">--capute no</code>运行<code class="fe nn no np nq b">pytest</code>。如果要锁定的对象还没有被锁定，那么仅仅运行pytest将会导致失败。<code class="fe nn no np nq b">-s</code>允许Pytest-Locker提示用户允许或拒绝测试断言。当允许时，该结果被存储，并且在行为改变之前不需要<code class="fe nn no np nq b">-s</code>。</li><li id="f383" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">提交锁定的文件(存储在<code class="fe nn no np nq b">.pytest-locker/</code>)。这不仅是CI/CD中测试成功的必要条件，也是在代码评审期间检查代码行为变化的影响的强大方法。</li></ol><p id="1b73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pytest-Locker的一个优点是，如果给定的字符串与存储的字符串不匹配，它不会失败。它显示一个diff，如果可能的话，询问用户是否应该接受新的字符串。</p><h2 id="c4c7" class="nr md it bd me ns nt dn mi nu nv dp mm lh nw nx mo ll ny nz mq lp oa ob ms oc bi translated">一个例子</h2><p id="a7e5" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">在下面的场景中，我们有一个想要填充的模板和一些填充它的测试代码。我们想要检查给定输入的模板。在本例中，<code class="fe nn no np nq b">locker.lock(result)</code>行导致pytest断言<code class="fe nn no np nq b">result</code>和<code class="fe nn no np nq b">test.unit.test_template.1.txt</code>内容之间的变化。如果该文件尚不存在，它将提示用户接受或拒绝<code class="fe nn no np nq b">result</code>并根据反应创建该文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="a051" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的例子非常简单，但是Pytest-Locker对于编写更复杂的模板选择和填充逻辑(例如聊天机器人)来说非常有价值。</p><p id="f43b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oi">注:更详细的例子可以在GitHub </em>  <em class="oi">上找到</em> <a class="ae lu" href="https://gist.github.com/Luttik/2ae284069aa88dde5f3e7340f03dd021" rel="noopener ugc nofollow" target="_blank"> <em class="oi">。</em></a></p><h2 id="1420" class="nr md it bd me ns nt dn mi nu nv dp mm lh nw nx mo ll ny nz mq lp oa ob ms oc bi translated">另一个场景</h2><p id="3596" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">我发现Pytest-Locker非常有用的另一个场景是当我必须使用API调用外部系统时，其中必须同时设置各种字段。当然，您不希望在测试时调用这些API，但是您希望测试使用它的代码。我做的是用<a class="ae lu" href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch" rel="noopener ugc nofollow" target="_blank">修补</a>调用API的方法，使用<a class="ae lu" href="https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock" rel="noopener ugc nofollow" target="_blank"> MagicMock </a>并锁定将被发送给API的参数。</p><p id="2a54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，我可能无法确保API调用会产生预期的行为，但我可以确保API以预期的方式被调用。</p><h2 id="2152" class="nr md it bd me ns nt dn mi nu nv dp mm lh nw nx mo ll ny nz mq lp oa ob ms oc bi translated">额外好处</h2><p id="8fe2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">Pytest-Locker在使用Given-When-Then风格的测试(也称为Arrange-Act-Assert)时带来了很多清晰性。根据我的经验，测试的“When”部分通常是一行，而使用Pytest-Locker，测试的“Then”部分通常也是一行。这意味着你的大部分测试只是建立初始状态(GWT模型中的“给定”)。</p><p id="d384" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着测试中最重要的部分,“何时”不再隐藏在两个长代码块之间。它可以很容易地作为测试的倒数第二行找到。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1449" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缺点</h1><ol class=""><li id="8739" class="mz na it la b lb mu le mv lh od ll oe lp of lt ne nf ng nh bi translated">代码需要确定性:虽然在许多场景中可以通过设置种子来减轻这种情况，但这并不总是可能的，而且可能比编写标准断言更麻烦。</li><li id="8c07" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">您必须将想要存储的对象序列化为一个字符串。这在Python中通常很简单。更好的是，如果您经常这样做，您甚至可以创建另一个继承自<code class="fe nn no np nq b">Locker</code>的类，并使用相应的fixture自动进行序列化。然而，这仍然是一个问题，我将在下一节中进一步解决它。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4df" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我想补充的事情</h1><p id="c65a" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">仍有改进的余地。大部分都归结于与pytest的更好集成。</p><p id="be3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果您不必手动序列化对象，那就太好了。然而，自动序列化只是问题的一半。对象序列化后，您仍然希望给定对象和存储对象之间有一个清晰、可读的差异。这是pytest在断言失败时做得很好的事情。然而，我们希望在测试失败之前看到差异，以便用户可以接受更改。到目前为止，我还没有找到做那件事的任何方法。</p><p id="3ce4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，在检查更改之前，最好先看看哪些测试失败了，哪些成功了，哪些仍然需要注意(通过接受或拒绝对锁的更改)。我确实认为这在pytest中是可能的，但这似乎是一个庞大的、不平凡的任务(欢迎投稿)。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f796" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">相关链接</h1><div class="oj ok gp gr ol om"><a href="https://pypi.org/project/pytest-locker/" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">pytest-locker</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">测试锁可用于在测试期间“锁定”数据。这意味着不必手动指定…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">pypi.org</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a href="https://github.com/Luttik/pytest-locker" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">Luttik/pytest-locker</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">测试锁可用于在测试期间“锁定”数据。这意味着不必手动指定…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">github.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>