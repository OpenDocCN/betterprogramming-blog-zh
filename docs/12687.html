<html>
<head>
<title>Building Serverless Applications That Scale The Perfect Amount</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建可完美扩展的无服务器应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-serverless-applications-that-scale-the-perfect-amount-ca6f75ae94a5?source=collection_archive---------8-----------------------#2022-06-22">https://betterprogramming.pub/building-serverless-applications-that-scale-the-perfect-amount-ca6f75ae94a5?source=collection_archive---------8-----------------------#2022-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6605" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设计合适的规模是一项巨大的建筑任务。在无服务器的情况下，一部分是为你处理的，但是一部分是你自己处理的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3433eb7f8f9b6af1c9edc4e37ed41880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oCmbGvOrpFYGQt3_b7ZPLg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2180330" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/kschneider2991-4936815/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2180330" rel="noopener ugc nofollow" target="_blank">凯文·施耐德</a>拍摄</p></figure><p id="3c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当人们向你推销无服务器时，你会听到的一个好处是<em class="lv">“它为你处理扩展，你永远不用担心它。”</em></p><p id="26ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">伙计，我希望那是真的。</p><p id="079f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是的。</p><p id="abe1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实是，你的云供应商<em class="lv">会为你处理扩展事件。也很好。它的处理无需您的任何干预，并且几乎可以扩展到任何级别(<a class="ae ky" href="https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html" rel="noopener ugc nofollow" target="_blank">假设您已经增加了服务配额</a>)。</em></p><p id="3e10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不真实的是你不必为此担心的事实。在设计无服务器应用程序时，你必须考虑规模。</p><p id="0c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在设计应用程序时，您需要大致了解请求进入的程度。是每秒1个请求吗？10?1,000?100,000?</p><p id="8e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个数量级，您需要考虑如何处理系统中增加的负载。规模不仅仅指API网关处理流量的方式。这是您的数据库、后端进程和API处理流量的方式。如果这些组件中的一个或多个不能像其他组件一样扩展到容量，您将遇到瓶颈并降低应用程序性能。</p><p id="4c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我们将讨论基于预期的规模(为了安全起见，还要额外增加一点)来构建您的应用程序的不同方法。</p><p id="0f5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">免责声明—各种秤级别没有行业标准名称或定义。我将使用的名称是编造的，并不打算反映软件的质量或意义。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e977" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">小规模(每秒1-999个请求)</h1><p id="c4bd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当在小范围内操作一个系统时，你是幸运的。您可以在没有太多特殊设计考虑的情况下构建。从理论上来说，<em class="lv">事情应该只是工作</em>。这并不意味着将您看到的第一个示例项目交付使用(<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/4-reasons-you-should-never-use-proof-of-concepts-in-production-ca54432e52b9">无论如何，您都不应该在生产中使用POCs</a>)。</p><p id="d8d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这确实意味着在大多数情况下，你可以设计你的应用程序来遵循无服务器架构的标准模式。</p><p id="6a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在小范围内，基本的无服务器构建模块是您最好的朋友，将带您走得更远。但是无论你计划什么样的规模，你都必须记住<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/solutions-architect-tips-how-to-design-around-serverless-service-limits-15e12b5c4235">检查你将消费的服务的服务配额</a>。考虑以下小规模API的模式。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/d60c13c8b05b397e8f3ad09d2d4f4028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JHOKEql_nf2jWoNp.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">小规模API结构</em></p></figure><p id="4a70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于此体系结构，您关心的服务配额是:</p><ul class=""><li id="0b54" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">Lambda函数并发执行—默认为1，000</li><li id="062e" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">DynamoDB的容量单位大小</li><li id="835a" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">标准工作流状态机的开始执行限制—默认情况下，某些区域为每秒1，300次，其他区域为每秒800次</li></ul><p id="c8de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此架构使用的服务还有其他服务配额，但在这个规模上，我们不会达到这些配额。</p><p id="06ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们达到了规模的顶端和/或我们的平均Lambda函数执行时间超过一秒，那么请求增加并发执行的服务配额将是一个很好的练习。如果您的平均执行时间非常短，大约在<em class="lv">&lt;200毫秒</em>左右，那么您可能也是清白的。</p><blockquote class="nq nr ns"><p id="6296" class="kz la lv lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><em class="it">如果您开始经常达到服务配额的70–80 %,您应该请求增加。</em></p></blockquote><p id="7ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于DynamoDB，您有几个选择。您可以<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.ProvisionedThroughput.Manual" rel="noopener ugc nofollow" target="_blank">提供容量</a>，为您的服务设置每秒的读写次数，或者您可以使用<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.ReadWriteCapacityMode.html#HowItWorks.OnDemand" rel="noopener ugc nofollow" target="_blank">按需</a>模式，如果您有可变或未知的工作负载，该模式可以为您扩展。</p><p id="47b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用按需容量，就不必担心扩展问题。DynamoDB将为您自动缩放。但是，如果您正在使用调配的容量，您需要确保您已经了解了您真正需要的吞吐量。</p><p id="e33c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Step函数，您需要注意通过API启动的标准工作流的数量。您可以启动的标准工作流的默认数量为每秒1300个，在<code class="fe nw nx ny nz b">us-east-1</code>、<code class="fe nw nx ny nz b">us-west-1</code>和<code class="fe nw nx ny nz b">eu-west-1</code>中还有500个突发。如果您的应用程序在该地区之外运行，那么默认情况下，您被限制为800。</p><p id="1c7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这个服务配额是针对<em class="lv">开始新的执行</em>。在受到限制之前，您可以同时运行多达100万个执行。但是在这种规模下，我们可能不用担心这个。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1fcc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">中等规模(每秒1，000–9，999个请求)</h1><p id="ec4c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">下一级规模肯定需要一些设计考虑。如果您期望每秒1K 10K请求的持续负载，您需要考虑相当大的容错能力。在这种规模下，如果99.9%的请求成功，这意味着每天会有86，400到864，000次失败。因此，容错和冗余在这个级别的规模中占有特殊的位置。</p><p id="b754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然你应该<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/3-ways-to-retry-failures-in-your-serverless-application-84b5102f620">总是为重试</a>而设计，但当你谈论规模时，这变得尤其重要。管理这种规模的重试和容错对于人类来说很快就变成了一项不可能完成的任务，因此自动化流程是您成功的关键。</p><p id="e250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看当我们转移到中等规模时，我们的架构图是如何更新的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/e5d980a5cd1f8033dff10e58bdb28534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8pptEa6-tU73Tv2x.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">中等规模的API结构</em></p></figure><p id="ca4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">架构略有改动。我们仍然有连接到Lambda和DynamoDB的端点，但我们不再直接连接到Step函数。相反，我们在它前面放了一个SQS队列作为缓冲。这无意中使端点异步。</p><p id="a191" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Lambda函数从队列中取出批次，验证阶跃函数吞吐量可用，然后开始执行。如果它不可用，它将把它放回队列中，以便后退并重试。</p><p id="3882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当状态机完成时，它触发一个EventBridge事件来通知调用者操作已经完成。</p><p id="82f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这种体系结构和规模级别，您应该关心的服务配额是:</p><ul class=""><li id="b927" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">Lambda函数并发执行——您<em class="lv">必须</em>请求增加处理量</li><li id="b372" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">EventBridge PutEvents限制—在某些地区默认为每秒10K，但在其他地区则低至每秒600</li></ul><p id="b799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据文档中的<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html" rel="noopener ugc nofollow" target="_blank">，Lambda函数的并发性可以增加到数万个，所以我们在这里讨论，我们不必担心我们在SQS和阶跃函数之间添加的额外的“Lambda函数胶”。</a></p><p id="3301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着这个设计中Lambda函数的新涌入，我们需要在较低优先级的函数上实现<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html" rel="noopener ugc nofollow" target="_blank">保留并发</a>。保留并发占你的帐户中Lambda函数总并发的一部分，并将其专用于该函数。该功能只允许放大到您设置的值。这可以防止低优先级函数不必要地占用您的所有并发性。使用保留并发仍然允许函数在不使用时扩展到0。</p><p id="f43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在保留并发的另一面，<a class="ae ky" href="https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html" rel="noopener ugc nofollow" target="_blank">提供的并发</a>保持N个功能容器热，因此您不必等待冷启动时间。这对于尽可能缩短响应时间尤为重要。</p><p id="d3e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也是谈论<a class="ae ky" href="https://www.alexdebrie.com/posts/dynamodb-single-table/" rel="noopener ugc nofollow" target="_blank"> DynamoDB单表设计</a>以及您的数据模型在这种规模下如何特别重要的好时机。在单表设计中，所有的数据实体都存在于同一个表中，并通过不同的分区键在逻辑上分隔开来。这允许在您的服务中以最小的延迟快速方便地访问数据。</p><p id="4dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是DynamoDB的每个分区有3000个读容量单位(RCU)和1000个写容量单位(WCU)的限制。</p><p id="069a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的数据模型没有平均分配请求，您将创建一个<a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-uniform-load.html" rel="noopener ugc nofollow" target="_blank">热分区</a>并抑制您的数据库调用。在中等规模或更大规模的情况下，数据的保存方式对可伸缩性至关重要。因此，一定要设计数据模型，使<em class="lv">支持简单的</em> <a class="ae ky" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-partition-key-sharding.html" rel="noopener ugc nofollow" target="_blank"> <em class="lv">写分片</em> </a>，这样你的数据分区就多样化了。</p><p id="d1c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们达到第二级规模时，需要考虑很多问题。但是，当我们达到最终的规模水平时，还有更多的因素需要考虑。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5935" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">大规模(每秒10，000多个请求)</h1><p id="751f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://twitter.com/justinpirtle" rel="noopener ugc nofollow" target="_blank"> Justin Pirtle </a>在AWS re:Invent 2021上发表了关于<a class="ae ky" href="https://www.youtube.com/watch?v=GNUSdekIaMw" rel="noopener ugc nofollow" target="_blank">为超大规模</a>构建无服务器应用的演讲。在视频中，他谈到了大规模应用的最佳实践。最重要的因素？缓存、批处理和排队。</p><p id="985b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这些因素，让我们看看我们的架构是如何从小规模模型变化而来的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/2f92f467b614c3eb48751621dd08e674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0byMReRkzfBJGYO2.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nb">大规模API结构</em></p></figure><p id="ccce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这样的架构，我们非常依赖于<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/and-the-2022-word-of-the-year-for-programmers-is-3605dc1bd698">异步处理</a>。因为几乎所有的API调用都会导致排队，这意味着大多数调用将依赖后台批处理。API网关<a class="ae ky" href="https://serverlessland.com/patterns/apigw-sqs" rel="noopener ugc nofollow" target="_blank">直接连接到SQS </a>，这导致一个Lambda函数拉取成批的请求进行处理。</p><p id="052f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理完成时，它触发一个事件来通知调用者处理已经完成。或者，您可以遵循<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-better-serverless-apis-by-going-storage-first-597784f8f399">作业模型方法</a>让调用者自己查询状态更新。</p><p id="0ff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在处理批处理中的一个或多个项目时出现错误，您可以在事件源映射上设置<a class="ae ky" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-eventsourcemapping.html#cfn-lambda-eventsourcemapping-bisectbatchonfunctionerror" rel="noopener ugc nofollow" target="_blank">二等分BatchOnFunctionError </a>属性，以拆分批处理并重试。这可以让你获得尽可能多的成功项目。</p><p id="ca0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还在表前面引入了<a class="ae ky" href="https://aws.amazon.com/dynamodb/dax/" rel="noopener ugc nofollow" target="_blank"> DynamoDB加速器(DAX) </a>作为缓存。这有助于将rcu保持在我们的桌面上，并为缓存命中提供微秒级的延迟。</p><p id="edd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前级别中的所有服务配额仍然适用于该级别，此外还有一些额外的服务配额:</p><ul class=""><li id="33a2" class="nc nd it lb b lc ld lf lg li ne lm nf lq ng lu nh ni nj nk bi translated">每秒API网关请求数—默认为每个地区所有API的每秒10K数</li><li id="db35" class="nc nd it lb b lc nl lf nm li nn lm no lq np lu nh ni nj nk bi translated">阶跃函数标准工作流状态转换—在某些地区为每秒5K，在其他地区为每秒800</li></ul><p id="2400" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大范围内，您的架构问题也开始变得更高。由于有如此多的服务配额必须管理和增加，因此将您的微服务分离到它们自己的AWS帐户中是一个好主意。将服务隔离到它们自己的帐户将防止不必要的资源争用。您将有更多的客户需要管理，但是您的服务配额变得更容易达到。</p><p id="a927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API Gateway对其每秒可以消耗的请求数有一个软限制服务配额。默认为10，000，这个限制是您的帐户在特定地区的所有REST、HTTP和WebSocket APIs的总和。这就是为什么将您的服务和API隔离到它们自己的帐户是好的。<em class="lv">这个限制必须大幅度提高</em>。</p><p id="49b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有标准执行工作流中，Step函数有一个有趣的服务限制，即每秒5，000次状态转换。因此，如果您同时运行5，000多个标准工作流，如果每个工作流每秒转换一种状态，您将会受到限制。</p><p id="ce44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可以，将执行切换到<a class="ae ky" href="https://docs.aws.amazon.com/step-functions/latest/dg/concepts-standard-vs-express.html" rel="noopener ugc nofollow" target="_blank">快速工作流</a>。它们适用于高容量的事件处理工作负载，规模比标准工作流高几个数量级。快速工作流没有状态转换限制。</p><p id="6b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不能更改工作流类型，那么您必须在状态机的每个状态下显式捕获并重试限制异常。</p><p id="0013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，一个扩展到如此规模的应用程序将会花费大量的资金来运行。这意味着你应该抓住一切机会<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/quick-optimizations-you-should-make-to-your-serverless-applications-9cc73ec464b9">优化你的应用程序的性能</a>。</p><p id="6276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可能的话，直接连接服务，而不是使用Lambda。切换您的功能以使用<a class="ae ky" href="https://aws.amazon.com/blogs/aws/aws-lambda-functions-powered-by-aws-graviton2-processor-run-your-functions-on-arm-and-get-up-to-34-better-price-performance/" rel="noopener ugc nofollow" target="_blank"> arm64架构</a>。尽可能批处理您的SDK调用。</p><p id="4d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些零零碎碎的东西很快累积起来，为你每月的账单省下一大笔钱。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9eb7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="26ff" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">数字很重要。</p><p id="aff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的应用程序获得的流量直接影响您如何设计架构。为你不久的将来的规模而设计，而不是为你10年后的规模而设计。</p><p id="fd50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无服务器不是银弹。仅仅通过在Lambda函数中编写我们的业务逻辑并不能解决我们所有的问题。</p><blockquote class="oa"><p id="8178" class="ob oc it bd od oe of og oh oi oj lu dk translated"><em class="nb">无服务器服务</em>可以<em class="nb">扩展并不意味着它们</em>也会<em class="nb">扩展。</em></p></blockquote><p id="820b" class="pw-post-body-paragraph kz la it lb b lc ok ju le lf ol jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">作为一名解决方案架构师，您的工作是确保您的应用程序的所有部分都能够一起伸缩。您不希望接收组件的规模明显高于处理组件。这将建立一个不断增长的请求积压，你将永远无法消费。<em class="lv">找到平衡</em>。</p><p id="be4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意你的服务极限。为重试设计您的应用程序。自动化一切。像鹰一样看着它。无论规模如何，您都需要掌握您的应用程序，并准确了解它在任何时间点的运行情况。这将有助于您进行相应的调整(如有必要)，并构建既能提高性能又能降低成本的优化。</p><p id="a198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你觉得你已经构建了一个可扩展到你预期数量的应用程序时，<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-load-test-your-apps-for-free-by-going-serverless-66524d904d09">对它进行一次负载测试</a>。确保它做它应该做的事。</p><p id="7057" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你好运。为高规模设计应用程序是一项有趣而独特的挑战。在某些情况下，基础设施和业务逻辑同样重要。</p><p id="2780" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>