# Python 中何时不使用列表

> 原文：<https://betterprogramming.pub/when-not-to-use-lists-in-python-5-alternatives-to-consider-11121a6ec33>

## 让我们探索五种选择

![](img/34d6b86a7c2eaa5eeb2326d224ab881e.png)

照片由[穆罕默德·诺哈西](https://unsplash.com/@coopery?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在 Python 中，最流行的容器数据类型可能是`list`。它非常灵活，可以在我们项目的任何地方使用，保存各种类型的数据:整数、字符串和自定义类实例。此外，它是可变的，这允许我们根据需要添加或删除项目。由于这些原因，一些程序员倾向于过度使用列表，而不考虑可行的替代方案。

在这篇文章中，我想强调五个场景，在这些场景中，有比列表更好的选项值得考虑。

# 1.数据不变性和哈希——元组

我们并不总是需要我们的数据容器来改变。有时候，我们实际上根本不希望我们的数据容器发生变化。在这种情况下，我们需要一个不可变的数据容器来保存我们的数据。假设用户为我们构建的应用程序选择了四位数字作为他/她的安全代码。理论上，我们可以使用 list 对象来存储这些数字。然而，不希望的事情可能会发生——代码可能会被意外更改。考虑下面的代码。

列表的可变性

最初，这两个列表被认为是相同的，因此用户可以解锁受保护的信息。然而，如果我们只改变保存的代码中的一个数字，两个列表就变得不相等，用户就失去了对安全信息的访问。所以，我们希望保存的代码是不可变的。

在这种情况下，我们应该考虑使用元组。众所周知，元组在 Python 中是不可变的对象，这意味着它们的值在被创建后就不能被更改。下面通过使用元组显示了替代实现。

元组的不变性

如上面的代码所示，保存的代码现在使用一个元组存储。试图更改其中一个数字导致了`TypeError`，这阻止了代码的任何意外更改。此外，作为数据安全的一种简单实现，tuple 对象可以在 Python 中直接散列。通过将代码存储在一个元组对象中，我们可以有一个哈希值来表示代码，这使得黑客更难破解应用程序。看一看简化的实现:

散列能力:列表与元组

# 2.成员检查—集合

根据特定应用程序的业务需求，您经常需要检查数据容器是否有您正在寻找的特定项。当然，列表具有所需的内置方法，允许您评估成员资格。如下所示，我们可以简单地使用`in`关键字来执行检查，这将返回一个布尔值:

成员资格检查

但是，如果您的应用程序需要频繁的成员检查，您应该考虑使用集合而不是列表。集合是 Python 中另一种重要的内置容器数据类型。集合的独特之处在于*集合*中的所有元素都必须是唯一且可散列的。之所以强制执行哈希能力要求，是因为在内部，Python 将集合实现为哈希表。使用散列表作为实现机制的最大好处之一是，对于特定的项目，有一个分摊的或恒定的查找时间。

让我们做一个简单的比较，展示当容器有数百万条记录时，集合的表现如何优于列表:

成员资格检查:列表与集合

正如您所看到的，随着`list`中元素数量的增加，成员资格检查的时间线性增加。相比之下，使用`set`进行会员资格检查的时间几乎保持不变，更重要的是，所需时间比使用`list`短得多。

# 3.价值检索—词典

与上面讨论的`set`类似，另一个导入内置数据类型`dict`要求它的键是可散列的。

键的可散列性意味着存储在`dict`中的数据涉及哈希表的实现——事实就是如此。像其他主流语言(如 Java、Swift、Kotlin)一样，Python 使用哈希表来操作字典。然而，与集合不同，字典存储键-值对，可散列键的需求是构建哈希表的基础。

使用哈希机制，检索特定键值对所需的时间是常数，时间复杂度为`O(1)` ——使用 [Big-O 符号](https://medium.com/swlh/time-complexity-of-algorithms-big-o-notation-explained-in-plain-english-e12a11dc4a4f)。这个`O(1)`时间复杂度意味着无论`dict`有多少个元素，检索一个特定项目的时间总是保持在相同的数量级。我们可以在下面看到一个快速对比:

值检索:列表与字典

假设我们需要存储一组学生的分数。使用列表，我们将有一个列表存储学生 ID 号，另一个列表存储相应位置的分数。为了找出一个特定学生的分数，我将首先找出该学生的指数，并使用该指数来获得分数。相比之下，使用字典，我们将只存储所有这些以学生 ID 号作为键的`student_id-score`对。如上所示，在这两种方法中，当记录数较高时，字典比列表方法表现得更好。

但是，有一点需要注意，因为字典存储键值对，所以您的数据模型应该有有意义的信息来标识值。此外，字典中的键必须是唯一的，尽管值可以相同。

# 4.先进先出—德克

有时，我们需要频繁地在序列的末尾添加和删除项目。这就要求物品的操作遵循先进先出的顺序。换句话说，将首先处理添加的第一个项目。使用列表，我们可以通过使用`pop(0)`函数来实现这个需求。然而，这个动作的执行是耗时的，因为列表的项目必须移位，这是一个`O(n)`操作。

相比之下，`deque`数据类型是一个双端队列，设计用于从两端快速插入和移除。为了执行 FIFO 操作，Python 将能够直接删除队列开头的项，而不需要移动所有的项。意味着这个 FIFO 操作很快。我们来看看下面的对比:

先进先出:列表与德克

# 5.大量列表数据—数组

Python 已经逐渐广泛用于数据科学领域的数据处理、分析和建模。这种日益流行的一个主要原因是各种开源软件包的发展。重要的是，他们已经开发了用于大规模数据集的定制类。因此，我们应该考虑专门为这些计算相关的工作设计的替代方案，而不是使用列表。

例如，如果您需要处理大量的数字数据，您应该考虑使用`NumPy`数组，这是在`NumPy`包中实现的核心数据类型。如果您需要处理具有混合数据类型(例如字符串、日期、数字)的结构化数据，您应该考虑使用`Pandas DataFrame`，这是在`Pandas`包中实现的核心数据类型之一。如果你做机器学习，你肯定需要查一下`tensors`，这是各大机器学习框架中最重要的数据类型，比如`TensorFlow`和`PyTorch`。

互联网上有许多教程，对这些数据结构的详细讨论超出了本文的范围。我的观点是，如果你处理大量的数据记录，你肯定应该研究这些替代方案——它们在较低的级别有特殊的实现，这些实现是为了优化大量的操作。

# 结论

我们回顾了 Python 中列表的五种替代方案。

我们不应该将自己局限于使用列表，因为 Python 及其相关包已经为我们提供了其他数据结构，这些数据结构为我们的特定业务需求提供了最佳解决方案。

我的建议是保持开放的心态，确保你完全了解你的选择。