<html>
<head>
<title>Dockerizing Rails Applications Part 1: Writing the Dockerfile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dockerizing Rails应用程序第1部分:编写Dockerfile</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerizing-rails-applications-part-1-writing-the-dockerfile-dc32aa25a0da?source=collection_archive---------2-----------------------#2019-12-28">https://betterprogramming.pub/dockerizing-rails-applications-part-1-writing-the-dockerfile-dc32aa25a0da?source=collection_archive---------2-----------------------#2019-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c3d5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们开始编写一个Rails应用程序并编写一个优化的Dockerfile</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5510218f1f5f4f54e5ed6a3556283a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBgJ8TRd4_qm9RU0bPlY5A.png"/></div></div></figure><p id="074e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为服务和应用程序构建Docker映像可以通过从运行的容器提交新的Docker映像，或者通过在相应服务的<code class="fe lq lr ls lt b">Dockerfile</code>中定义Docker映像来完成。在本文中，我将介绍一些为Ruby/Rails应用程序编写<code class="fe lq lr ls lt b">Dockerfiles</code>的最佳实践。这也是描述Ruby/Rails应用程序dockerizing的最佳实践的三篇文章中的第一篇。</p><p id="6344" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了能够在Docker容器中运行应用程序/服务，有必要构建一个包含应用程序源代码或二进制文件及其所有依赖项的Docker映像。这项任务可以通过执行以下步骤来完成:</p><ul class=""><li id="7879" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated"><strong class="kw iu">为服务</strong>创建一个<code class="fe lq lr ls lt b">Dockerfile</code><strong class="kw iu">:<code class="fe lq lr ls lt b">Dockerfile</code>描述了如何构建Docker镜像，设置Docker镜像的默认配置，以及安装应用程序的所有依赖项</strong></li><li id="ae01" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">使用Docker命令<code class="fe lq lr ls lt b">docker build</code>构建Docker镜像</li></ul><p id="ce1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从第一步开始，这个<a class="ae mi" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" rel="noopener ugc nofollow" target="_blank">链接</a>展示了支持的<code class="fe lq lr ls lt b">Dockerfile </code>指令，以及一些最佳实践。我想强调以下几点:</p><p id="d315" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">仔细选择基础图像</strong>:任何<code class="fe lq lr ls lt b">Dockerfile</code>的第一条指令都是<code class="fe lq lr ls lt b">FROM</code>指令。此指令为您的Docker映像指定基础映像。文件中的下一个指令将负责准备源代码和安装软件依赖项。选择基础映像时需要考虑的事项有:</p><ul class=""><li id="0330" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">仅使用官方图像作为您的图像的基础，以降低将漏洞引入Docker图像的风险</li><li id="5c19" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">使用类似<a class="ae mi" href="https://hub.docker.com/_/alpine/" rel="noopener ugc nofollow" target="_blank"> Alpine image </a>的小尺寸图像:这将减少部署/展示和回滚所需的时间。应用程序Docker映像需要在从该映像创建新容器之前下载到Docker主机上。</li><li id="a6c4" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">创建您自己的基本映像，以减少应用程序Docker映像的构建时间。如果您在Docker构建期间安装Linux应用程序依赖项和库，这一点非常重要。这些包和库的安装可能需要一段时间，这可能会增加部署时间(如果构建docker映像是部署的一部分)，或者会影响CI/CD管道的执行时间，因为依赖项需要安装在每个Docker构建上。作为一个解决方案，建议构建包含所有依赖项的基础映像，比如Ruby版本，然后将这些映像用作应用程序的基础映像。这篇文章描述了如何为Ruby应用程序构建基础Docker映像。</li></ul><p id="37a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">始终使用</strong> <code class="fe lq lr ls lt b">entrypoint</code> : <code class="fe lq lr ls lt b">entrypoint</code>通过将复杂的应用程序命令或脚本隐藏在一个关键字/命令之后，帮助我们为Docker图像创建一个简单的界面。这对于需要在运行实际服务之前执行某种逻辑的应用程序也很有帮助——例如，如果您想基于环境变量从模板中生成一些文件，然后启动您的服务。</p><p id="0805" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">entrypoint</code>可以是一个简单的shell脚本，可以处理Docker镜像支持的命令或服务。Docker <code class="fe lq lr ls lt b">entrypoint</code>文件的唯一要求是它应该是一个可执行文件。例如，要为提供两种服务的Rails应用程序添加一个Docker <code class="fe lq lr ls lt b">entrypoint</code>,可以遵循以下指令:</p><ul class=""><li id="dce5" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">用以下内容创建Docker <code class="fe lq lr ls lt b">entrypoint</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="c22e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，上面的<code class="fe lq lr ls lt b">entrypoint</code>也允许通过使用<code class="fe lq lr ls lt b">*)</code>命令来执行其他命令。如果您想将Docker映像限制为仅支持的命令，您可以删除最后一种情况。只有当Docker <code class="fe lq lr ls lt b">entrypoint</code>被覆盖时，执行其他命令才是可行的。</p><ul class=""><li id="3ecf" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">使文件可执行:<code class="fe lq lr ls lt b">chmod a+x docker-entrypoint.sh</code>。</li><li id="2aa8" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">将文件复制到Docker镜像并设置<code class="fe lq lr ls lt b">ENTRYPOINT</code>。</li></ul><pre class="kj kk kl km gt ml lt mm mn aw mo bi"><span id="9c94" class="mp mq it lt b gy mr ms l mt mu">COPY ./docker-entrypoint.sh /<br/>ENTRYPOINT ["/docker-entrypoint.sh"]</span></pre><p id="9f7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">最小化docker图像的大小:</strong>幸运的是<strong class="kw iu"> </strong>在Docker的最新版本中，只有以下指令— <code class="fe lq lr ls lt b">RUN</code>、<code class="fe lq lr ls lt b">COPY</code>和<code class="fe lq lr ls lt b">ADD </code> —会产生新的Docker图像层，因此，Docker图像的大小会增加。为了使Docker图像尽可能小，您可以考虑以下几点</p><ul class=""><li id="b279" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">仅将需要的文件添加到Docker映像中</li><li id="efac" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">仅将所需的包和库安装到Docker映像中</li><li id="f768" class="lu lv it kw b kx md la me ld mf lh mg ll mh lp lz ma mb mc bi translated">如有可能，将多个<code class="fe lq lr ls lt b">RUN</code>命令组合在一起(在一个<code class="fe lq lr ls lt b">RUN</code>命令中)。这将减少Docker层的数量。例如，不要添加五个单独的<code class="fe lq lr ls lt b">RUN</code>指令来安装<code class="fe lq lr ls lt b">Dockerfile</code>中的包(这将在生成的Docker映像中引入五个Docker层)，而是尝试将这个指令合并到一个指令中，以将Docker层减少到只有一个。</li></ul><pre class="kj kk kl km gt ml lt mm mn aw mo bi"><span id="39ab" class="mp mq it lt b gy mr ms l mt mu"># Instead of</span><span id="73db" class="mp mq it lt b gy mv ms l mt mu">RUN <!-- -->addgroup -g 1000 rails<br/>RUN <!-- -->adduser -S -G rails -u 1000 -h /application rails<strong class="lt iu"><br/></strong>RUN <!-- -->apk update<br/>RUN apk add linux-headers build-base curl zlib-dev libxml2-dev libxslt-dev tzdata yaml-dev git nodejs file zip unzip<br/>RUN rm -rf /var/cache/apk/*</span><span id="fd2b" class="mp mq it lt b gy mv ms l mt mu"># It should be one RUN instruction<br/>RUN addgroup -g 1000 rails &amp;&amp; \<br/>    adduser -S -G rails -u 1000 -h /application rails &amp;&amp; \<br/>    chown -R rails /usr/local/bundle &amp;&amp; \<br/>    apk update &amp;&amp; \<br/>    apk add linux-headers build-base curl zlib-dev libxml2-dev libxslt-dev tzdata yaml-dev git nodejs file zip unzip &amp;&amp; \<br/>    rm -rf /var/cache/apk/*</span></pre><ul class=""><li id="6f3f" class="lu lv it kw b kx ky la lb ld lw lh lx ll ly lp lz ma mb mc bi translated">安装完依赖项后，删除不需要的软件包，例如安装软件所需的编译器或其他软件包。</li></ul><p id="b838" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意指令的顺序:</strong>为了提高构建Docker映像的效率和性能，对<code class="fe lq lr ls lt b">Dockerfile</code>中的指令进行排序，将不太可能改变的指令放在文件的顶部，而将更可能改变的指令放在底部。这个顺序将允许Docker更有效地构建图像缓存。例如，以下说明应放在<code class="fe lq lr ls lt b">Dockerfile</code>的顶部。</p><pre class="kj kk kl km gt ml lt mm mn aw mo bi"><span id="ddb8" class="mp mq it lt b gy mr ms l mt mu">ENV PORT 8080<br/>ENV RACK_ENV=production RAILS_ENV=production<br/>ENV RAILS_LOG_TO_STDOUT=true<br/>ENV SECRET_KEY_BASE changeme<br/>EXPOSE 8080</span><span id="f1c9" class="mp mq it lt b gy mv ms l mt mu">COPY ./docker-entrypoint.sh /<br/>ENTRYPOINT ["/docker-entrypoint.sh"]</span></pre><p id="c3dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">综合以上做法，会产生以下<code class="fe lq lr ls lt b">Dockerfile</code>。在这个文件中，我将运行Ruby 2.6.3和MySQL的Rails应用程序之间的所有共享指令都移到了Docker基本映像<code class="fe lq lr ls lt b">wshihadeh/rails-base-image:2.6.3-mysql</code>中。</p><p id="bfbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何依赖于Ruby 2.6.3和MySQL的Rails/Ruby应用程序都可以重用这个映像。这一步大大减少了应用程序Docker映像的构建时间。接下来，我在文件的顶部添加了不太可能更改的命令，在底部添加了每次都需要执行的命令。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="de05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为应用程序构建Docker映像只需执行下面的Docker命令。</p><pre class="kj kk kl km gt ml lt mm mn aw mo bi"><span id="a317" class="mp mq it lt b gy mr ms l mt mu">docker build -t ${IMG}:${IMG_TAG} <!-- -->Dockerfile<br/>docker push <!-- -->${IMG}:${IMG_TAG}</span></pre><p id="23d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一篇<a class="ae mi" href="https://medium.com/@wshihadeh/dockerizing-rails-applications-part-2-automation-3092975fa4bb" rel="noopener">文章</a>中，我将介绍我们如何引入一个简单的接口来构建、推送、测试和处理Docker图像。</p></div></div>    
</body>
</html>