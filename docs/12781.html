<html>
<head>
<title>How to Sequentially Resolve an Array of Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中顺序解析一组承诺</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-sequentially-resolve-an-array-of-promises-in-javascript-19bcd42417e8?source=collection_archive---------2-----------------------#2022-07-01">https://betterprogramming.pub/how-to-sequentially-resolve-an-array-of-promises-in-javascript-19bcd42417e8?source=collection_archive---------2-----------------------#2022-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6fbf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">编写可重用的函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fe2c025473e4c543f220d6ddd524081c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZYRU9A9jdbxuaVeeBbb3Q.jpeg"/></div></div></figure><p id="dde1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您使用JavaScript，无论是在浏览器React中使用普通的JS，还是在Node.js中使用，您可能都熟悉<a class="ae ln" href="https://web.dev/promises/" rel="noopener ugc nofollow" target="_blank">承诺</a>。此外，您可能还遇到过用Promise.all()函数解析承诺数组的<a class="ae ln" href="https://www.ayrshare.com/the-power-of-javascript-promise-all/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="8679" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个<code class="fe lo lp lq lr b">Promise.all</code>的例子:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="9af5" class="lw lx iq lr b gy ly lz l ma mb">const getSquare = async (x) =&gt; Math.pow(x, 2);<br/>const printSquares = async () =&gt; {<br/>     const nums = [1, 2, 3, 4, 5];<br/>     const promiseArray = nums.map(x =&gt; getSquare(x));</span><span id="ce34" class="lw lx iq lr b gy mc lz l ma mb">     const resolvedPromises = await Promise.all(promiseArray);<br/>     console.log(resolvedPromises);<br/>};</span><span id="796f" class="lw lx iq lr b gy mc lz l ma mb">printSquares();</span></pre><p id="b6a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">getSquare</code>返回一个承诺，顾名思义<code class="fe lo lp lq lr b">promiseArray</code>包含一个承诺数组。所有这些承诺都需要在得到平方之前解决。如果不这样做，将会打印到控制台的内容如下:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="eeca" class="lw lx iq lr b gy ly lz l ma mb">[<br/>  Promise {<br/>    1,<br/>    [Symbol(async_id_symbol)]: 36,<br/>    [Symbol(trigger_async_id_symbol)]: 5,<br/>    [Symbol(destroyed)]: { destroyed: false }<br/>  },<br/>  Promise {<br/>    4,<br/>    [Symbol(async_id_symbol)]: 37,<br/>    [Symbol(trigger_async_id_symbol)]: 5,<br/>    [Symbol(destroyed)]: { destroyed: false }<br/>  },<br/>  Promise {<br/>    9,<br/>    [Symbol(async_id_symbol)]: 38,<br/>    [Symbol(trigger_async_id_symbol)]: 5,<br/>    [Symbol(destroyed)]: { destroyed: false }<br/>  },<br/>  Promise {<br/>    16,<br/>    [Symbol(async_id_symbol)]: 39,<br/>    [Symbol(trigger_async_id_symbol)]: 5,<br/>    [Symbol(destroyed)]: { destroyed: false }<br/>  },<br/>  Promise {<br/>    25,<br/>    [Symbol(async_id_symbol)]: 40,<br/>    [Symbol(trigger_async_id_symbol)]: 5,<br/>    [Symbol(destroyed)]: { destroyed: false }<br/>  }<br/>]</span></pre><p id="7010" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而不是期望的输出:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="0543" class="lw lx iq lr b gy ly lz l ma mb">[ 1, 4, 9, 16, 25 ]</span></pre><h1 id="05ae" class="md lx iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">顺序解决承诺</h1><p id="2a95" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在上面的例子中,<code class="fe lo lp lq lr b">getSquare</code>被解析的顺序并不重要……注意返回的数组的元素将总是对应于承诺的数组。</p><p id="b28f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，假设顺序很重要，或者进行并行处理会产生系统问题。例如，我最近遇到一个问题，并行调用Firebase <code class="fe lo lp lq lr b">getUser</code>函数几百次。有时会因为数据库过载而出现Firestore错误。</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="aada" class="lw lx iq lr b gy ly lz l ma mb">const uids = ["id1", "id2",...];<br/>const userPromises = uids.map(uid =&gt; admin<br/>   .auth()<br/>   .getUser(uid)<br/>   .then((userRecord) =&gt; {<br/>      return userRecord.toJSON();<br/>   })<br/>   .catch(console.error)<br/>);</span><span id="a15e" class="lw lx iq lr b gy mc lz l ma mb">const users = await Promise.all(userPromises); // The problem!</span></pre><p id="da60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，该处理对时间不敏感，也不密集，所以按顺序处理是可以接受的。</p><p id="64d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">补充说明:</strong>JavaScript运行时实际上并不并行处理，也不是多线程的，而是有一个<a class="ae ln" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#:~:text=The%20event%20loop%20is%20what,operations%20executing%20in%20the%20background." rel="noopener ugc nofollow" target="_blank">事件循环</a>来执行非阻塞I/O操作。例如，如果Promise调用外部URL，运行时将处理事件循环中的下一个任务，同时等待来自被调用URL的响应。这使得处理看起来是多线程和快速的。出于这个原因，顺序处理通常要慢得多，因为您会一直阻塞到承诺完全完成。</p><p id="3bbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">起初，你可能会想使用<code class="fe lo lp lq lr b">forEach</code> …不要！<code class="fe lo lp lq lr b">forEach</code> <a class="ae ln" href="https://javascript.plainenglish.io/async-await-foreach-81d4859f2b8c" rel="noopener ugc nofollow" target="_blank">和<code class="fe lo lp lq lr b">aysnc</code>配合不好</a>会出问题。</p><p id="150d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，ES 2018版本的<code class="fe lo lp lq lr b">for</code>非常适合与<code class="fe lo lp lq lr b">await</code> *进行顺序处理:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="ac19" class="lw lx iq lr b gy ly lz l ma mb">const resolvePromisesSeq = async (tasks) =&gt; {<br/>  const results = [];<br/>  for (const task of tasks) {<br/>    results.push(await task);<br/>  }</span><span id="6954" class="lw lx iq lr b gy mc lz l ma mb">  return results;<br/>};</span></pre><p id="f5b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe lo lp lq lr b">resolvePromisesSeq</code>将接受一组任务，然后按顺序处理每个任务。</p><p id="5861" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将Firebase代码更新为顺序代码:</p><pre class="kg kh ki kj gt ls lr lt lu aw lv bi"><span id="8cfb" class="lw lx iq lr b gy ly lz l ma mb">const uids = ["id1", "id2",...];<br/>const userPromises = uids.map(uid =&gt; admin<br/>   .auth()<br/>   .getUser(uid)<br/>   .then((userRecord) =&gt; {<br/>      return userRecord.toJSON();<br/>   })<br/>   .catch(console.error)<br/>);</span><span id="253f" class="lw lx iq lr b gy mc lz l ma mb">const users = await resolvePromisesSeq(userPromises); // No longer a problem!</span></pre><p id="3f84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">漂亮！</p><p id="5003" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您需要按顺序处理承诺时，这个新函数是可重用的。</p><p id="596e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">*感谢<a class="ae ln" href="https://www.reddit.com/user/getify/" rel="noopener ugc nofollow" target="_blank"> getify </a>推荐在for中使用await，而不是在顶层。</p></div></div>    
</body>
</html>