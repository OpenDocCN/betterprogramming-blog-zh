<html>
<head>
<title>SwiftUI NavigationStack — How to Deep Link and What’s New</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI NavigationStack —深度链接之旅和新功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-navigation-stack-how-to-deeplink-and-whats-new-64b1401cb9af?source=collection_archive---------5-----------------------#2022-08-30">https://betterprogramming.pub/swiftui-navigation-stack-how-to-deeplink-and-whats-new-64b1401cb9af?source=collection_archive---------5-----------------------#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c97f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深层链接和导航变得更加容易</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c36a37d71117d0b5a34aed580166af35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H5fynpK3aqu56Pja"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Julien Kettmann 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><blockquote class="kw kx ky"><p id="1ba2" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">本文是iOS 16和Mac OS 13中SwiftUI4新功能系列文章的一部分。其余的你可以直接在我的个人资料页面找到🚀。现在让我们继续阅读。</p></blockquote><p id="cb6d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi lz translated">你好！这正是我在今年的WWDC上看到新的导航堆栈时所说的，我对此非常高兴。我快乐的基础是我确切地知道我要用它做什么！</p><p id="40f2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">就在我的脑海里，我有一个想法:终于有了深度链接导航！从那天起，因为我没有时间去做它，但时间来了，这将是我在媒体上的第一篇文章，并开始了iOS 16中所有新的SwiftUI功能的系列。让我们开始派对吧！</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="683e" class="mp mq iq bd mr ms mt mu mv mw mx my mz jw na jx nb jz nc ka nd kc ne kd nf ng bi translated"><strong class="ak">好吧，但是什么变了？</strong></h1><p id="8c0e" class="pw-post-body-paragraph kz la iq lc b ld nh jr lf lg ni ju li lw nj ll lm lx nk lp lq ly nl lt lu lv ij bi translated">对于那些不熟悉这个主题的人，我将快速介绍一下SwiftUI以前版本中导航和深度链接的外观。因此，之前我们作为开发人员只能使用<code class="fe nm nn no np b">NavigationView</code>和<code class="fe nm nn no np b">NavigationLink</code>，这将使我们能够在应用程序中导航用户，它看起来像这样:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="b4f3" class="nu mq iq np b gy nv nw l nx ny">struct Feature: Identifiable, Hashable, Decodable {<br/>    var id: String = UUID().uuidString<br/>    let title: String<br/>    let description: String<br/>    let type: FeatureType<br/>}</span><span id="c413" class="nu mq iq np b gy nz nw l nx ny">enum FeatureType: String, Decodable {<br/>    case charts<br/>    case gauge<br/>}</span><span id="68bb" class="nu mq iq np b gy nz nw l nx ny">final class ContentViewModel: ObservableObject {<br/><br/>    @Published var selectedFeature: Feature?<br/>    @Published var showFeatureScreen: Bool = false<br/>    <br/>    @ViewBuilder func showFeature() -&gt; some View {<br/>        if let feature = selectedFeature {<br/>            switch feature.type {<br/>            case .charts:<br/>                ChartsScreen(feature: feature)<br/>            case .gauge:<br/>                GaugeScreen(feature: feature)<br/>            }<br/>        }<br/>    }<br/>}</span><span id="8e0a" class="nu mq iq np b gy nz nw l nx ny">struct ContentView: View {<br/>    @StateObject var viewModel = ContentViewModel()<br/><br/>    var body: some View {<br/>        NavigationView {<br/>            ZStack {<br/>                NavigationLink(isActive: $viewModel.showFeatureScreen) {<br/>                    viewModel.showFeature()<br/>                } label: {}<br/>                <br/>                ScrollView {<br/>                    LazyVStack(spacing: 8) {<br/>                        ForEach(viewModel.features) { feature in<br/>                            FeatureCell(feature: feature) {<br/>                                viewModel.selectedFeature = feature<br/>                                viewModel.showFeatureScreen = true<br/>                            }<br/>                        }<br/>                    }<br/>                }<br/>                .navigationTitle("iOS16 Features 🚀")<br/>                .onOpenURL { url in<br/>                    print("🚀 \(url)")<br/>                    <br/>                    guard let components = URLComponents(url: url, resolvingAgainstBaseURL: true) else { return }<br/>                    let query = components.queryItems ?? []<br/>                    let host = components.host<br/>                    let scheme = components.scheme<br/>                    <br/>                    if scheme == "showdownRouting" &amp;&amp; host == "feature" {<br/>                        var jsonQuery = query.map { "\"\($0.name)\":\"\($0.value ?? "")\"" }.joined(separator: ",")<br/>                        jsonQuery = "{\(jsonQuery)}"<br/>                        <br/>                        guard let jsonData = jsonQuery.data(using: .utf8) else {<br/>                            return<br/>                        }<br/>                        <br/>                        do {<br/>                            let feature = try JSONDecoder.shared.decode(Feature.self, from: jsonData)<br/>                            viewModel.selectedFeature = feature<br/>                            viewModel.showFeatureScreen = true<br/>                        } catch {<br/>                            print(error)<br/>                        }<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/37e79680c438d2a756ab98063c3e8842.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/1*OJ34eI-hQYanyZX0hwGstQ.gif"/></div></figure><p id="94cf" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这是你处理简单深层链接的老方法，你可以看到这种方法的问题是每次只能打开一个屏幕，从长远来看这很麻烦。然后当你打开树中的一些导航时，你会面临缺少弹出到根方法的问题。并且您需要使与导航树连接的所有绑定无效。</p><p id="358a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">好吧，这是有问题的，但是我们能做什么呢？<code class="fe nm nn no np b">NavigationStack</code>！</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="672d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">新的<code class="fe nm nn no np b">NavigationStack</code>和<code class="fe nm nn no np b">NavigationPath</code>对于UIKit开发者来说会非常熟悉，他们会喜欢这个:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="5509" class="nu mq iq np b gy nv nw l nx ny">enum FeatureType: String, Decodable {<br/>    case charts<br/>    case gauge<br/>}<br/><br/>struct Feature: Identifiable, Hashable, Decodable {<br/>    var id: String = UUID().uuidString<br/>    let title: String<br/>    let description: String<br/>    let type: FeatureType<br/>}<br/><br/>final class ContentViewModel: ObservableObject {<br/>    @Published var navigationPath = NavigationPath()<br/><br/>    var features: [Feature] = [<br/>        Feature(title: "Charts 📊",<br/>                      description: "Use a chart to build expressive and dynamic data visualizations inside a SwiftUI view.",<br/>                      type: .charts),<br/>        Feature(title: "Gauge 🔜",<br/>                description: "SwiftUI introduces a new view called Gauge for displaying progress. In the most basic form, a gauge has a default range from 0 to 1.",<br/>                type: .gauge)<br/>    ]<br/><br/>   <strong class="np ir"> func showFeature(_ feature: Feature) {<br/>        navigationPath.append(feature)<br/>    }</strong><br/>}<br/><br/>struct ContentView: View {<br/>    @StateObject var viewModel = ContentViewModel()<br/><br/>    var body: some View {<br/>        NavigationStack(path: $viewModel.navigationPath) {<br/>            ScrollView {<br/>                LazyVStack(spacing: 8) {<br/>                    ForEach(viewModel.features) { feature in<br/>                        FeatureCell(feature: feature) {<br/>                            viewModel.showFeature(feature)<br/>                        }<br/>                    }<br/>                    <strong class="np ir">.navigationDestination(for: Feature.self) { feature in<br/>                        switch feature.type {<br/>                        case .charts:<br/>                            ChartsScreen(feature: feature)<br/>                        case .gauge:<br/>                            GaugeScreen(feature: feature)<br/>                        }<br/>                    }</strong><br/>                    .navigationTitle("iOS16 Features 🚀")<br/>                }<br/>                .onOpenURL { url in<br/>                    print("🚀 \(url)")<br/>                    <br/>                    guard let components = URLComponents(url: url, resolvingAgainstBaseURL: true) else { return }<br/>                    let query = components.queryItems ?? []<br/>                    let host = components.host<br/>                    let scheme = components.scheme<br/>                    <br/>                    if scheme == "showdownRouting" &amp;&amp; host == "feature" {<br/>                        var jsonQuery = query.map { "\"\($0.name)\":\"\($0.value ?? "")\"" }.joined(separator: ",")<br/>                        jsonQuery = "{\(jsonQuery)}"<br/>                        <br/>                        guard let jsonData = jsonQuery.data(using: .utf8) else {<br/>                           return<br/>                        }<br/>                        <br/>                        do {<br/>                            let feature = try JSONDecoder.shared.decode(Feature.self, from: jsonData)<br/>                            viewModel.showFeature(feature)<br/>                        } catch {<br/>                            print(error)<br/>                        }<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/96a2adc102cbe9f3f08423c6498a06f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/1*MHCluXKxS2-JuFhbmTy2xg.gif"/></div></figure><p id="4e6c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如你所见，我们将<code class="fe nm nn no np b">NavigatonPath</code>对象保存在<code class="fe nm nn no np b">ViewModel</code>中，我们可以将各种数据推送到它上面，例如特征，然后对它做出反应，在这种情况下，为了简单起见，我只检查它是什么类型。这种方法非常适合SwiftUI，同时专注于建模数据和状态。</p><p id="d427" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这使我们能够向堆栈添加更多内容，并像这样通过向下传递我们在NavigationPath上推送的视图<code class="fe nm nn no np b">navigationPath</code>,轻松弹出到堆栈的根:</p><pre class="kg kh ki kj gt nq np nr ns aw nt bi"><span id="c490" class="nu mq iq np b gy nv nw l nx ny">.navigationDestination(for: Feature.self) { feature in<br/>                        switch feature.type {<br/>                        case .charts:<br/>                           <strong class="np ir"> ChartsScreen(feature: feature, navigationPath: $viewModel.navigationPath)</strong><br/>                        case .gauge:<br/>                            GaugeScreen(feature: feature)<br/>                        }<br/>                    }</span><span id="9ed9" class="nu mq iq np b gy nz nw l nx ny">// Charts Screen implementation:<br/>struct ChartsScreen: View {<br/>    var feature: Feature<br/>    @Binding var navigationPath: NavigationPath<br/>    @StateObject var viewModel = ChartsViewModel()<br/><br/>    var body: some View {<br/>        VStack {<br/>            Text(feature.description)<br/>                .font(.footnote)<br/>                .padding()<br/>                .multilineTextAlignment(.center)<br/>                .onTapGesture {<br/>                 <strong class="np ir">   navigationPath.removeLast(navigationPath.count)</strong><br/>                }<br/>            <br/>            Spacer()<br/><br/>            HStack {<br/>                Button {<br/>                    withAnimation {<br/>                        viewModel.team = viewModel.team.sorted { $0.seniority &lt; $1.seniority }<br/>                    }<br/>                } label: {<br/>                    Text("Sort")<br/>                        .foregroundColor(.white)<br/>                        .padding()<br/>                        .background(.green)<br/>                        .cornerRadius(10)<br/>                }<br/><br/>                Button {<br/>                    withAnimation {<br/>                        viewModel.team = viewModel.team.shuffled()<br/>                    }<br/>                } label: {<br/>                    Text("Shuffle")<br/>                        .foregroundColor(.white)<br/>                        .padding()<br/>                        .background(.red)<br/>                        .cornerRadius(10)<br/>                }<br/>            }<br/><br/>            ScrollView {<br/>                barChart<br/>                lineChart<br/>                areaChart<br/>            }<br/>        }<br/>        .navigationTitle(feature.title)<br/>        .navigationBarTitleDisplayMode(.inline)<br/>    }</span></pre><p id="2cb3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">效果是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/aa34ebfc895830aa09481f8bbb4546b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/1*IyP8_wzK8P00342ZrexQ4A.gif"/></div></figure></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/cb3c1b6c4cfcaad0851170a91dedce4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q6NwU_8TnSPE7RkyoDD7gQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克雷格·费德里吉——修复导航</p></figure><p id="c885" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">正如你所看到的，实现非常简单，这让我非常高兴，我们将能够在不久的将来使用它，而新的iPhones现在就要出来了！</p><p id="fc08" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">所有的源代码都是公开的，将会在下一集的新特性中更新。</p><div class="oc od gp gr oe of"><a href="https://github.com/LSWarss/iOS-16-MacOS-13-SwiftUI-Showdown" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">GitHub-lsw arss/iOS-16-MAC OS-13-swift ui-摊牌:新的SwiftUI 4为iOS16+提供了示例应用程序</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">新的SwiftUI 4提供了一个适用于iOS16+的示例应用程序。通过以下方式为LSWarss/iOS-16-MAC OS-13-swift ui-摊牌开发做出贡献…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">github.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><p id="4a24" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果你想知道接下来会发生什么等等。在GitHub上跟着看就行了。感谢阅读。</p></div></div>    
</body>
</html>