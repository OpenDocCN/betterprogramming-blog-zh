<html>
<head>
<title>Angular Performance: 5 OnPush Change Detection Case Studies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度性能:5个脉冲变化检测案例研究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-onpush-change-detection-f629cbce0bfa?source=collection_archive---------6-----------------------#2020-12-29">https://betterprogramming.pub/angular-onpush-change-detection-f629cbce0bfa?source=collection_archive---------6-----------------------#2020-12-29</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="0b31" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网页性能</a></h2><div class=""/><div class=""><h2 id="cac1" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">从默认更改检测切换到OnPush更改检测的提示</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/133776b00f2ab0647640bdb17e48941c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uJa2wQ1dQM5YHxz-"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@siora18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Siora摄影</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="f93a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你搜索“角度变化检测”，你会发现很多文章有很多共同点。在本文中，我们不打算解释<em class="mf"> zone </em>库是如何工作的，或者角度变化检测机制是如何实现的。我们将看到的是Angular应用程序中从默认切换到<code class="fe mg mh mi mj b">OnPush</code>变化检测策略以优化其性能的五个真实案例。</p><p id="fec4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您可能已经知道，<code class="fe mg mh mi mj b">OnPush</code>变更检测不能开箱即用。您必须考虑数据结构的不变性，并调整代码设计和组件之间的交互。为了更清楚地理解<strong class="ll je">，</strong>，我们将在今天的文章中通过分析和调整以不同方式设计的五个角度组件来应用这一点。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="18ce" class="mr ms iu bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">案例研究1:容器组件</h1><p id="a4d8" class="pw-post-body-paragraph lj lk iu ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me in bi translated">容器组件是智能组件。它们与服务、路由器和商店通信。他们知道要调用哪些服务，并负责从这些服务中检索数据。这里有一个例子:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/bd5d43e415524270afdf73516d4b89b4#file-invoice-container-component-ts" rel="noopener ugc nofollow" target="_blank">发票-容器.组件. ts </a></p></figure><p id="d4e6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe mg mh mi mj b">InvoicesContainerComponent</code>从<code class="fe mg mh mi mj b">InvoiceStoreService</code>中读取三个属性(两个观察值和一个数组)，然后通过模板中的数据绑定将它们传递给子表示组件(<code class="fe mg mh mi mj b">invoices-ui</code>):</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/fb2c2edb37ad1f6ec474129fd328782a#file-invoices-container-component-html" rel="noopener ugc nofollow" target="_blank">invoices-container.component.html</a></p></figure><ul class=""><li id="ef35" class="nq nr iu ll b lm ln lp lq ls ns lw nt ma nu me nv nw nx ny bi translated"><code class="fe mg mh mi mj b">displayColumnDefs</code>是商店服务中定义的<code class="fe mg mh mi mj b">readonly</code>属性。我们不需要担心从中检测到新的值，因为一旦我们初始化它，它就不会改变。</li><li id="7a51" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated"><code class="fe mg mh mi mj b">notification$</code>和<code class="fe mg mh mi mj b">dataList$</code>是根据用户与应用程序的交互发出新值的可观察值。我们使用<code class="fe mg mh mi mj b">async</code>管道订阅模板中的这两个属性，这确保了自动取消订阅observables，并将新值(作为带有<strong class="ll je"> <em class="mf"> </em> </strong> <em class="mf">新引用</em> <strong class="ll je"> <em class="mf"> </em> </strong>的对象)发送到<code class="fe mg mh mi mj b">invoices-ui</code>的输入属性中。这便于在表示组件中使用<code class="fe mg mh mi mj b">OnPush</code>变化检测。</li></ul><p id="30bd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果我们不使用<code class="fe mg mh mi mj b">invoices-container.component.html</code>中的<code class="fe mg mh mi mj b">async</code>管道，而是订阅如下的<code class="fe mg mh mi mj b">dataList$</code> observables:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">可观测的角度订阅</p></figure><p id="4e9b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后在模板中传递新值:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><em class="oe">invoices-container.component.html</em></p></figure><p id="02c8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe mg mh mi mj b">OnPush</code>变更检测不起作用，我们将面临一个问题。解决的方法是在<code class="fe mg mh mi mj b">InvoicesContainerComponent</code>的构造函数中注入<code class="fe mg mh mi mj b">ChangeDetectorRef</code>，在得到新的发票清单后调用<code class="fe mg mh mi mj b">markForCheck()</code>方法:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">angular change detectorref:markForCheck()</p></figure><blockquote class="of og oh"><p id="9cf4" class="lj lk mf ll b lm ln ke lo lp lq kh lr oi lt lu lv oj lx ly lz ok mb mc md me in bi translated">“……<code class="fe mg mh mi mj b"><em class="iu">AsyncPipe</em></code>使用OnPush变化检测策略自动工作。...没有<code class="fe mg mh mi mj b"><em class="iu">AsyncPipe</em></code>的实现不会触发变化检测，所以我们需要为每个从可观察对象发出的新事件手动调用<code class="fe mg mh mi mj b"><em class="iu">detectChanges()</em></code>。迈克尔·霍夫曼</p></blockquote><p id="7136" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不过，要小心。呼叫<code class="fe mg mh mi mj b">markForCheck()</code>被认为是最后的手段。</p><p id="e7f1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">应用容器/呈现器模式(或智能和转储组件)的好处不仅在于指示Angular使用<code class="fe mg mh mi mj b">async</code>管道为我们管理订阅/取消订阅，还在于为<code class="fe mg mh mi mj b">OnPush</code>变更检测提供了更好的基础设施。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="1a44" class="mr ms iu bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">案例研究2:演示者组件</h1><p id="729b" class="pw-post-body-paragraph lj lk iu ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me in bi translated">现在让我们检查转储表示组件<code class="fe mg mh mi mj b">invoices-ui</code>:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/2f7e8b5959ad29dff945dbca87c96396#file-invoices-presenter-component-ts" rel="noopener ugc nofollow" target="_blank">发票-presenter.component.ts </a></p></figure><p id="f94d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我们已经使用输入属性和事件将这个组件连接到它的父容器<code class="fe mg mh mi mj b">invoices</code>。在这种情况下，我们可以很容易地将<code class="fe mg mh mi mj b">changeDetection: ChangeDetection.OnPush</code>添加到<code class="fe mg mh mi mj b">InvoicePresenterComponent</code>的元数据中，而不会有任何问题，因为<code class="fe mg mh mi mj b">notification</code>和<code class="fe mg mh mi mj b">dataList</code>将在它们的值改变时获得新的引用。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="9665" class="mr ms iu bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">案例研究3:自定义自动完成</h1><p id="b285" class="pw-post-body-paragraph lj lk iu ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me in bi translated">我们的第三个例子是我在这篇文章中实现的自定义自动完成。它是一个表示性组件，具有以下输入属性:</p><ul class=""><li id="4da8" class="nq nr iu ll b lm ln lp lq ls ns lw nt ma nu me nv nw nx ny bi translated">数组<code class="fe mg mh mi mj b">optionsList</code>:运行时会改变。</li><li id="4787" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated">两个<code class="fe mg mh mi mj b">FormControls</code> ( <code class="fe mg mh mi mj b">valueFormControl</code>和<code class="fe mg mh mi mj b">textFormControl</code>):它们会在运行时改变。</li><li id="0736" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated"><code class="fe mg mh mi mj b">optionSearchConfig</code>:初始化后不会改变的静态对象。</li><li id="750e" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated">其他的输入是原语，这意味着它们不会对变更检测问题提出任何挑战。</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/e88db1d512e475ac61273edd4449bc60#file-use-of-custom-autocomplete-html" rel="noopener ugc nofollow" target="_blank">use-of-custom-autocomplete.html</a></p></figure><p id="09a7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们看看打字稿代码:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://gist.github.com/rakia/56ae55a9d860513c2fbdfb2f93fe6245#file-custom-autocomplete-component-ts" rel="noopener ugc nofollow" target="_blank">自定义-自动完成.组件. ts </a></p></figure><p id="a905" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是模板:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">角度材料自定义自动完成(HTML部件)</p></figure><p id="b8fd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在切换到<code class="fe mg mh mi mj b">OnPush</code>变更检测之前，您能猜到我们是否需要任何重构吗？</p><p id="2ba1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们来分解一下:</p><ul class=""><li id="88eb" class="nq nr iu ll b lm ln lp lq ls ns lw nt ma nu me nv nw nx ny bi translated"><code class="fe mg mh mi mj b">valueFormControl</code>和<code class="fe mg mh mi mj b">textFormControl</code>输入属性的类型为<code class="fe mg mh mi mj b">FormControl</code>(来自<code class="fe mg mh mi mj b">@angular/forms</code>)。Angular的反应形式通过提供不可变的数据结构来保持数据模型的纯净。每次表单发生变化时，<code class="fe mg mh mi mj b">FormControl</code>实例不会更新现有的数据模型。它会返回一个新的。这意味着我们可以轻松切换到<code class="fe mg mh mi mj b">OnPush</code>变化检测。</li><li id="b75b" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated"><code class="fe mg mh mi mj b">optionsList</code>在自定义自动完成模板中获取其值，如下所示:</li></ul><pre class="kt ku kv kw gu ol mj om on aw oo bi"><span id="2602" class="op ms iu mj b gz oq or l os ot">[optionsList]="dataList$ | async"</span></pre><p id="7306" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每当可观察对象<code class="fe mg mh mi mj b">dataList$</code>发出一个新值时，<code class="fe mg mh mi mj b">custom-autocomplete</code>接收一个带有新引用的新对象作为<code class="fe mg mh mi mj b">optionsList</code>的值。因此，更改将被成功检测并呈现给用户。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="d167" class="mr ms iu bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">案例研究4:材料网格</h1><p id="0e45" class="pw-post-body-paragraph lj lk iu ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me in bi translated">您是否注意到在之前的模板<code class="fe mg mh mi mj b">custom-autocomplete.component.html</code>中的覆盖图中呈现的子组件(材料表)？</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">调用有角度的材质网格</p></figure><p id="ae6a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">它是一个在多个组件中重用的动态演示器。在用户开始输入搜索查询后，我们向REST API发送一个请求。然后，我们将结果呈现在表格中，您可以在下面两张截图中看到:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ou"><img src="../Images/a1c47a1350686985e057e47d981f028b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iDmgmlF_1ssAFb9Y4dQ-Aw.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">在表单中使用的角形材料自定义自动完成</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ov"><img src="../Images/bca45eff166d920fa511f4c70c4ed413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A2umVgLkQvmkCVEQbwVjFg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">可编辑网格中使用的角度材料自定义自动完成</p></figure><p id="fb25" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">现在让我们试着深入研究这个问题。</p><p id="bf25" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe mg mh mi mj b">mat-grid</code>的三个输入参数中的两个接收静态值，在组件初始化后没有变化:</p><pre class="kt ku kv kw gu ol mj om on aw oo bi"><span id="ea7e" class="op ms iu mj b gz oq or l os ot">[<strong class="mj je">displayedColumns</strong>]="optionSearchConfig.displayedColumns"<br/>[<strong class="mj je">displayColumnDefs</strong>]="optionSearchConfig.displayColumnDefs"</span></pre><p id="b22d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">但是第一个输入(<code class="fe mg mh mi mj b">dataSource</code>)，其类型为<code class="fe mg mh mi mj b">MatTableDataSource</code> &lt; T &gt;，在每个新的<code class="fe mg mh mi mj b">searchQuery</code>之后更新。每当<code class="fe mg mh mi mj b">optionsList</code>改变时，<code class="fe mg mh mi mj b">dataSource.data</code>在<code class="fe mg mh mi mj b">custom-autocomplete</code>组件的<code class="fe mg mh mi mj b">ngOnChanges()</code>钩子中获得一个新值:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">角形钩</p></figure><p id="adbc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">使用<code class="fe mg mh mi mj b">ChangeDetectionStrategy.OnPush</code>、T21，我们将执行参照检查。因此，<code class="fe mg mh mi mj b">mat-grid</code>组件不会检测到新值。对<code class="fe mg mh mi mj b">dataSource</code>对象的引用仍然相同，因此不需要采取行动。为了解决这个问题，我们将实例化<code class="fe mg mh mi mj b">MatTableDataSource</code>来创建一个新对象，而不是更新旧对象的<code class="fe mg mh mi mj b">data</code>属性:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">适于OnPush变化检测的角度ngOnChanges挂钩</p></figure></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="4c48" class="mr ms iu bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">案例研究5:剑道网格的上下文菜单</h1><p id="eab8" class="pw-post-body-paragraph lj lk iu ll b lm nj ke lo lp nk kh lr ls nl lu lv lw nm ly lz ma nn mc md me in bi translated">下面是一个组件，每当用户右键单击剑道网格的一行时，它都会显示一个上下文菜单。在第21行，我们订阅了调用<code class="fe mg mh mi mj b">onCellClick()</code>的<code class="fe mg mh mi mj b">grid.cellClick</code>。最后一个方法负责提取和传达应该显示<code class="fe mg mh mi mj b">kendo-popup</code>的位置，并在<code class="fe mg mh mi mj b">dataItem</code>属性中设置用户单击的行的值:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">剑道角度网格上下文菜单</p></figure><p id="6bbd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">乍一看，一切正常。但是当我们切换到<code class="fe mg mh mi mj b">OnPush</code>变更检测时，我们注意到在一行上单击右键后没有出现上下文菜单。</p><p id="9545" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在前面的四个例子中，我们的组件在输入改变后需要重新呈现。现在<code class="fe mg mh mi mj b">GridContextMenuComponent</code>需要在视图中触发一个事件后重新呈现。</p><p id="f545" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">让我们在<code class="fe mg mh mi mj b">onCellClick()</code>和<code class="fe mg mh mi mj b">document.click</code>事件的回调中做一点调整，通过调用<code class="fe mg mh mi mj b">markForCheck()</code>在用户右击后显式地将视图标记为已更改:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="no np l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">具有OnPush变化检测的剑道角度网格上下文菜单</p></figure><p id="f2a8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">酷！我们现在又像预期的那样有了上下文菜单。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><h1 id="6edc" class="mr ms iu bd mt mu mv mw mx my mz na nb kj nc kk nd km ne kn nf kp ng kq nh ni bi translated">外卖食品</h1><blockquote class="of og oh"><p id="d315" class="lj lk mf ll b lm ln ke lo lp lq kh lr oi lt lu lv oj lx ly lz ok mb mc md me in bi translated">“毫无疑问，在Angular应用程序中，您应该坚持使用不可变的数据结构。它不仅允许您通过使用OnPush更改检测策略来提高运行时性能，还可以防止您陷入视图中呈现陈旧数据的麻烦中。”——<a class="ae li" href="https://indepth.dev/posts/1381/immutability-importance-in-angular-applications" rel="noopener ugc nofollow" target="_blank">沃伊切赫·特拉维斯基</a></p></blockquote><p id="b4b9" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，如果您在加载完应用程序后性能很差——如下图所示——不要指望<code class="fe mg mh mi mj b">OnPush</code>变更检测会修复它，因为它不会:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ow"><img src="../Images/ebac7706aa5d2192d3b834f097a89385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kwkv367AdIPaBwb7wDsSIg.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Chrome DevTools中Lighthouse测量的性能不佳示例</p></figure><p id="6e51" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">由Chrome Lighthouse衡量的这一结果表明，我们应该采取以下一项或多项措施:</p><ul class=""><li id="9099" class="nq nr iu ll b lm ln lp lq ls ns lw nt ma nu me nv nw nx ny bi translated">将大组件和JavaScript/TypeScript文件拆分成较小的组件。</li><li id="43e6" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated">删除不用的文件和死代码。</li><li id="047f" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated">通过使用内存化、缓存等减少HTTP请求的数量。</li><li id="ecb1" class="nq nr iu ll b lm nz lp oa ls ob lw oc ma od me nv nw nx ny bi translated">用<em class="mf"> webpack-bundle-analyzer </em>分析捆绑包，检查庞大的第三方库是否值得使用。</li></ul><p id="c87d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您现在可能想知道为什么您应该关心变更检测策略呢？</p><p id="2d32" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">不要混淆。网络表演有不同的类型。为了简单起见，让我们考虑两种类型:一种是在浏览器上直接调用您的web应用程序，另一种是在长时间使用它之后(运行时性能)。</p><p id="e53e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">有一件事你可以非常确定，那就是<code class="fe mg mh mi mj b">OnPush</code>变更检测(以及取消订阅可观察值)将减少执行所花费的时间和消耗的资源数量，从而优化运行时性能。要了解这一改进，您需要<a class="ae li" href="https://medium.com/better-programming/build-me-an-angular-app-with-memory-leaks-please-36302184e658" rel="noopener">比较与</a>交互后的性能，并在相当长的时间内不使用F5重新加载页面的情况下使用您的web应用。</p><p id="9171" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在长时间会话中保持最佳性能在生产中至关重要。</p><p id="04ea" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">感谢阅读。如果你有一些问题，请在评论中告诉我，我会回复你。</p></div><div class="ab cl mk ml hy mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="in io ip iq ir"><p id="6c65" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯独家访问</strong> </a> <strong class="ll je"> </strong>或在此注册媒体<a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener"/>。</p><p id="711c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mf">你可以在Udemy上查看我的</em> <strong class="ll je"> <em class="mf">视频课程</em></strong><em class="mf">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="mf">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="mf">。</em></p></div></div>    
</body>
</html>