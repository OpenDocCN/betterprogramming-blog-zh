<html>
<head>
<title>Going From Python to Kotlin: 10 Language Features to Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Python到Kotlin:需要了解的10个语言特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/going-from-python-to-kotlin-10-language-features-to-know-8982b9d921e4?source=collection_archive---------7-----------------------#2022-02-16">https://betterprogramming.pub/going-from-python-to-kotlin-10-language-features-to-know-8982b9d921e4?source=collection_archive---------7-----------------------#2022-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ade7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">科特林很有趣</h2></div><p id="7e2e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">变更日志:【2022年12月30日——使用Medium的新代码块进行语法高亮显示</em></p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/9399a06b86708c9b7391f4736356367e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5cWr0AyU4mT_CD9s"/></div></div><p class="lr ls gj gh gi lt lu bd b be z dk translated">照片由<a class="ae lv" href="https://unsplash.com/@thaliatran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">塔利亚·特兰</a>在<a class="ae lv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="00f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可变性？零安全？<code class="fe lw lx ly lz b">val</code>和<code class="fe lw lx ly lz b">var</code>？这些是我刚开始接触时对Kotlin有些陌生的特征。</p><p id="8c4c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一年前接触Kotlin(和JavaScript)之前，我是用Python编程的。从Python过渡到Kotlin(和JavaScript)并不容易，因为Python中不存在一些特性(你需要时间来认识到这一点)。</p><p id="8832" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以在这篇文章中，我将与你分享我学到的10大语言特征(因为这是一个很好的数字)。</p><p id="820b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你正在学习Kotlin，这篇文章将是一个很好的总结。</p><p id="8139" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你对Kotlin不感兴趣，但对其他语言感兴趣，就浏览一下这篇文章。大多数现代编程语言都有我在这里列出的相同特性。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a033" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">内容</h1><ol class=""><li id="c58f" class="mz na it kk b kl nb ko nc kr nd kv ne kz nf ld ng nh ni nj bi translated"><a class="ae lv" href="#3bca" rel="noopener ugc nofollow">静态类型检查</a></li><li id="2252" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#24aa" rel="noopener ugc nofollow">只读保护</a></li><li id="9ce8" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#ba7f" rel="noopener ugc nofollow">集合中的可变性</a></li><li id="466b" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#565b" rel="noopener ugc nofollow">无效安全</a></li><li id="515e" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#7b3c" rel="noopener ugc nofollow">作为一等公民的职能</a></li><li id="f7ac" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#54aa" rel="noopener ugc nofollow">采集方法流畅界面</a></li><li id="2351" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#ab17" rel="noopener ugc nofollow">扩展功能</a></li><li id="ac93" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#abaf" rel="noopener ugc nofollow">特定领域语言</a></li><li id="bdf4" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#9492" rel="noopener ugc nofollow">可读函数名</a></li><li id="8074" class="mz na it kk b kl nk ko nl kr nm kv nn kz no ld ng nh ni nj bi translated"><a class="ae lv" href="#3b16" rel="noopener ugc nofollow">开关语句</a></li></ol></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="3bca" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">1.静态类型检查</h1><p id="2335" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">计算机编程语言</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="c721" class="nw mi it lz b be nx ny l nz oa">def greet(name):<br/>    print(f"Hello, {name}")</span></pre><p id="7a8b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">科特林</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="2ffd" class="nw mi it lz b be nx ny l nz oa">fun greet(name: String) {<br/>    println("Hello, $name")<br/>}</span></pre><p id="7457" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你知道那些有属性错误的错误吗？我们认为变量是一个特定的类型，但它不是。进入静态类型检查。</p><p id="0e54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">静态类型检查通过<em class="le">类型注释</em>——程序员指定变量的正确类型——和<em class="le">类型推断</em>来实现。下面的程序是一个反例:</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="820f" class="nw mi it lz b be nx ny l nz oa">name: str = 123</span></pre><p id="7e39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意Python允许<em class="le">逐步类型化</em>，也就是说你可以注释类型，但是在你运行程序的时候不会影响到你。</p><p id="b3ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python采用动态类型检查——只有在程序运行时才检查类型。像Kotlin这样的语言实现了静态类型检查，在程序运行之前验证语言结构的兼容性。</p><p id="8de9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这增加了一层安全性，以确保您的程序是正确的。</p><p id="2b7c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想在你的程序中包含静态类型检查，可以看看Google的<a class="ae lv" href="https://mypy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> mypy </a>(来自Python)或<a class="ae lv" href="https://github.com/google/pytype" rel="noopener ugc nofollow" target="_blank"> pytype </a>。</p><blockquote class="ob oc od"><p id="bf04" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁<strong class="kk iu"> <em class="it">这个语言特性提供了什么？<br/> </em> </strong> <em class="it">安全</em></p><p id="8069" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">它是如何实现的？<br/> </em> </strong> <em class="it">编译时检查和类型注释</em></p></blockquote><h1 id="24aa" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">2.只读保护</h1><p id="6dae" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在Python中，变量可以被重新分配(<strong class="kk iu">“变量隐藏”</strong>)。如果我们无意中将一个值重新赋给了代码中其他地方的一个变量，这是有潜在危险的。</p><p id="28c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Kotlin中，变量可以被重新分配<em class="le">，如果你明确地打算这样做的话。这种保护由变量<code class="fe lw lx ly lz b">val</code> ue前的<code class="fe lw lx ly lz b">val</code>或<code class="fe lw lx ly lz b">var</code>关键字声明<strong class="kk iu">为只读</strong>。否则，这是一个<code class="fe lw lx ly lz b">var</code>可行。</em></p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="ec46" class="nw mi it lz b be nx ny l nz oa">number = 5<br/>number = 999  # okay</span></pre><p id="ab88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">科特林(瓦尔)</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="ddc9" class="nw mi it lz b be nx ny l nz oa">val number = 5<br/>number = 999 // compile-time error</span></pre><p id="cc67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">科特林(var)</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="8cfd" class="nw mi it lz b be nx ny l nz oa">var number = 5<br/>number = 999 // okay</span></pre><blockquote class="ob oc od"><p id="1eed" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁这个语言特性提供了什么？<br/>   <em class="it">安全</em></p><p id="2cec" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">它是如何实现的？<br/></em></strong><code class="fe lw lx ly lz b"><strong class="kk iu"><em class="it">val</em></strong></code><strong class="kk iu"><em class="it"/></strong><em class="it">和</em><strong class="kk iu"/><code class="fe lw lx ly lz b"><strong class="kk iu"><em class="it">var</em></strong></code><strong class="kk iu"><em class="it"/></strong><em class="it">关键词</em></p></blockquote><h1 id="ba7f" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">3.集合中的可变性</h1><p id="9fe0" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">Python中很少讨论可变性(不过在官方文档<a class="ae lv" href="https://docs.python.org/3/reference/datamodel.html" rel="noopener ugc nofollow" target="_blank">中有</a>)。</p><p id="13a4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个容器对象(或者一个值的集合)是<strong class="kk iu">可变的</strong> <em class="le"> </em>，如果它的值可以改变。</p><p id="d070" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下面的Python字典为例:</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="38b4" class="nw mi it lz b be nx ny l nz oa">data = {<br/>    "name": "Ali"<br/>}</span></pre><p id="b7ca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过添加另一个键值对<code class="fe lw lx ly lz b">data1["name"] = "Singapore"</code>来更改这个对象，这意味着<code class="fe lw lx ly lz b">dict</code>数据结构是可变的。但是，如果我们想保护数据不被(无意地)修改呢？用Python的标准库是做不到的。</p><p id="b63b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Kotlin中，上面的例子与此类似，使用了<em class="le">可变映射</em>数据结构(类似于Python的字典)</p><p id="01a3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">科特林</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="56ed" class="nw mi it lz b be nx ny l nz oa">val data2 = mutableMapOf(<br/>    "name" to "Ali"<br/>)</span></pre><p id="949d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这导致了<code class="fe lw lx ly lz b">MutableMap</code>类型。在这里，你可以分配<code class="fe lw lx ly lz b">data2["name"] = "Singapore"</code>。但是如果我们想保护数据不发生突变，我们需要使用只读数据类型，<code class="fe lw lx ly lz b">Map</code>。</p><p id="c885" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">科特林</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="f6cc" class="nw mi it lz b be nx ny l nz oa">val data3 = mapOf(<br/>    "name" to "Ali"<br/>)</span></pre><p id="ea58" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您尝试运行<code class="fe lw lx ly lz b">data3["name"] = "Singapore"</code>，将会遇到编译时错误。</p><blockquote class="ob oc od"><p id="8a83" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁<strong class="kk iu"> <em class="it">这个语言特性提供了什么？<br/></em></strong>T22】安全</p><p id="5ff2" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">是如何实现的？<br/> </em> </strong> <em class="it">数据结构</em></p></blockquote><h1 id="565b" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">4.零安全</h1><p id="5bfd" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">计算机编程语言</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="f515" class="nw mi it lz b be nx ny l nz oa">def greet(name: Optional[str]) -&gt; str:<br/>    ...</span></pre><p id="c842" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">科特林</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="8172" class="nw mi it lz b be nx ny l nz oa">fun greet(name: String?) -&gt; String {<br/>    ...<br/>}</span></pre><p id="49dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有时我们希望一个变量能够包含<code class="fe lw lx ly lz b">None</code>。这些被称为<em class="le">可空类型</em>。在Python中，它们被称为<code class="fe lw lx ly lz b">Optional</code>类型。</p><p id="a616" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Kotlin中，这种类型更简洁地表示为变量类型的后缀<code class="fe lw lx ly lz b">?</code>。(Swift和TypeScript也使用这种语法。)</p><p id="9602" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">表达可空类型有助于程序员跟踪可能为空的变量，并安全地访问或“解开”(Swift术语)这些变量。静态类型检查检查空安全。</p><p id="e01d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们有一个带有<code class="fe lw lx ly lz b">name</code>属性的<code class="fe lw lx ly lz b">Person</code>对象:</p><p id="2899" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算机编程语言</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="33d7" class="nw mi it lz b be nx ny l nz oa">if person is None:<br/>    return ""<br/>else:<br/>    return f"hello, {person.name}"</span></pre><p id="1611" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">科特林</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="0536" class="nw mi it lz b be nx ny l nz oa">return person?.let { "hello, ${it.name}" }: ""</span></pre><p id="a66f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意<code class="fe lw lx ly lz b">person</code>是如何被小心访问的(通过<em class="le">安全调用</em>操作器<code class="fe lw lx ly lz b">?.</code>)。</p><blockquote class="ob oc od"><p id="0f6a" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁这个语言特性提供了什么？<br/>   <em class="it">安全、简洁</em></p><p id="4005" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">是如何实现的？<br/> </em> </strong> <em class="it">可空类型，安全调用</em> <code class="fe lw lx ly lz b"><em class="it">?.</em></code> <em class="it">，非空断言</em> <code class="fe lw lx ly lz b"><em class="it">!!</em></code> <em class="it">，猫王运算符</em> <code class="fe lw lx ly lz b"><em class="it">?:</em></code> <em class="it">等等，作用域函数类似</em> <code class="fe lw lx ly lz b"><em class="it">let</em></code> <em class="it">。</em></p></blockquote><h1 id="7b3c" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">5.作为一等公民的职能</h1><p id="48c6" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在Python中，传递函数通常是不习惯的(“一等公民”)，尽管我在Keras中看到过一些类似的情况，您可以为想要打印出来的度量定义一个函数。</p><p id="92d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为不地道，所以在这里用Kotlin为例和大家分享一下。</p><p id="6f53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个人为的例子(如果你能想出一个更好的例子，请告诉我！)在这里我们打印一个统计摘要(定义为<code class="fe lw lx ly lz b">metric</code>)，给出一个数字列表(<code class="fe lw lx ly lz b">data</code>)。</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="9c17" class="nw mi it lz b be nx ny l nz oa">fun printSummary(data: List&lt;Float&gt;,<br/>                 metric: (List&lt;Float&gt;) -&gt; Float) {<br/>    val summary = metric(data)<br/>    println(summary)<br/>}</span></pre><p id="62cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看到它的实际应用:</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="208b" class="nw mi it lz b be nx ny l nz oa">printSummary(myList) { x -&gt;<br/>    x.sum() / x.size<br/>}</span></pre><p id="088b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意后面的lambda语法(为了区别)和匿名函数。</p><blockquote class="ob oc od"><p id="0d7a" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁<strong class="kk iu"> <em class="it">这个语言特性提供了什么？<br/> </em> </strong> <em class="it">灵活性、可读性、简洁性</em></p><p id="0e0e" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">在科特林是如何实现的？<br/> </em> </strong> <em class="it">匿名函数、高阶函数、尾随lambda语法</em></p></blockquote><h1 id="54aa" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">6.收集方法的流畅界面</h1><p id="8734" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">在Python中，我们很少使用函数式编程动词，如集合的map、reduce和filter(“<strong class="kk iu">集合方法</strong>”)，将它们链接在一起(“<strong class="kk iu"> fluent接口</strong>”)。这是因为列表理解(和字典理解)和数组编程语法更习惯。</p><p id="250d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们没有接触到这种语言特征。</p><p id="7922" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您想通过给每个元素加3来转换一个列表<code class="fe lw lx ly lz b">[1,2,3]</code>，并且只取偶数结果。</p><p id="7249" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在假设的Python中，它看起来像这样:</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="a7f1" class="nw mi it lz b be nx ny l nz oa">my_list.map(lambda x: x+3).filter(lambda x: x%2==0)</span></pre><p id="6e30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在科特林，它看起来像这样</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="6b2c" class="nw mi it lz b be nx ny l nz oa">myList.map { x -&gt; x+3 }.filter { x -&gt; x%2==0 }</span></pre><p id="c897" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我看来从左到右读起来不错。</p><p id="ac4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，下面是您在Python中如何做的，尽管不习惯(也不可读):</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="4674" class="nw mi it lz b be nx ny l nz oa">list(filter(lambda x: x%2==0, map(lambda x: x+3, my_list)))</span></pre><p id="4ec7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，下面是您在Python中如何做的，尽管不习惯(也不可读):</p><blockquote class="ob oc od"><p id="1f76" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁这个语言特性提供了什么？<br/>   <em class="it">可读性</em></p><p id="5516" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">在科特林是如何实现的？<br/> </em> </strong> <em class="it">通过集合类的方法实现的动词。</em></p></blockquote><h1 id="ab17" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">7.扩展功能</h1><p id="5337" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">您是否知道可以从标准库或导入库中向现有类添加函数？</p><p id="2172" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您想获得自纪元以来的时间(Unix时间)。这是它在假设的Python中的样子。我准备把<code class="fe lw lx ly lz b">datetime</code>类改名为<code class="fe lw lx ly lz b">Datetime</code>(没错，<code class="fe lw lx ly lz b">datetime</code>就是一个类！):</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="f7ce" class="nw mi it lz b be nx ny l nz oa">from datetime import Datetime<br/><br/>def Datetime.get_epoch_now():<br/>    return this.strtime("%s").toInt()</span></pre><p id="473c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意我是如何不经意地“扩展”了<code class="fe lw lx ly lz b">Datetime</code>类来包含一个名为<code class="fe lw lx ly lz b">get_epoch_now</code>的新方法的。</p><p id="94ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Kotlin中，扩展函数是一个很好的特性，因为它允许你把相关的方法放在一起。</p><blockquote class="ob oc od"><p id="a9b9" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁<strong class="kk iu"> <em class="it">这个语言功能提供了什么？<br/> </em> </strong> <em class="it">可读性</em></p><p id="fd57" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">在科特林是如何实现的？<br/> </em> </strong> <em class="it">通过类扩展</em>实现</p></blockquote><h1 id="abaf" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">8.特定领域语言</h1><p id="774a" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">特定领域语言(DSL)是一种由程序员定义的语言，以便其他程序员可以使用它来实现他们的目标。</p><p id="2615" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python没有这个。</p><p id="28fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的例子显示了一个看起来与通常的Kotlin不同的语法(看起来更像JSON-ish)。但是这个语法是<em class="le">有效的</em>。摘自https://github.com/zsmb13/VillageDSL<a class="ae lv" href="https://github.com/zsmb13/VillageDSL" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="0df8" class="nw mi it lz b be nx ny l nz oa">val newVillage = village {<br/>    house {<br/>        person {<br/>            name = "Emily"<br/>            age = 31<br/>        }<br/>        person(name = "Hannah") {<br/>            age = 27<br/>        }<br/>        person("Alex", 21)<br/>    }<br/>}</span></pre><p id="69c0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为这个语言特性是令人兴奋的，因为你可以在思考客户代码或使用它的人的同时，发挥创造力。</p><blockquote class="ob oc od"><p id="398e" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁<strong class="kk iu"> <em class="it">这个语言特性提供了什么？<br/> </em> </strong> <em class="it">灵活性、可读性</em></p><p id="9ec7" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">在科特林是如何实现的？<br/> </em> </strong> <em class="it">类型安全生成器通过</em> <code class="fe lw lx ly lz b"><em class="it">infix</em></code> <em class="it"> es方法命名一个类</em></p></blockquote><h1 id="9492" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">9.可读的函数名</h1><p id="fbf7" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">您知道可以用空格定义函数或方法名<em class="le">吗😱？！</em></p><p id="5880" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Kotlin允许这样做(用反勾括起来):</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="a986" class="nw mi it lz b be nx ny l nz oa">fun `do something`() {<br/>    <br/>   ...<br/>}</span></pre><p id="6524" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你这样称呼它:</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="fded" class="nw mi it lz b be nx ny l nz oa">`do something`()</span></pre><p id="a4de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这通常只是为了编写测试函数，但是这个特性是有益的，主要是因为测试名可能会很长。</p><p id="f1cb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">谢谢你，机灵鬼，你想得真周到。</p><blockquote class="ob oc od"><p id="5541" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁这个语言特性提供了什么？<br/>   <em class="it">可读性</em></p><p id="22d0" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">在科特林是如何实现的？<br/> </em> </strong> <em class="it">测试函数名的反斜杠语法</em></p></blockquote><h1 id="3b16" class="mh mi it bd mj mk oh mm mn mo oi mq mr jz oj ka mt kc ok kd mv kf ol kg mx my bi translated">10.交换语句</h1><p id="1d6f" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">switch语句在类C语言中很常见。这就像多个if-else语句，但用词更少。</p><p id="95a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看在Kotlin中使用<em class="le"> when表达式</em>是如何做到这一点的:</p><pre class="lg lh li lj gt ns lz nt bn nu nv bi"><span id="8e88" class="nw mi it lz b be nx ny l nz oa">when x {<br/>    1 -&gt; print("x == 1")<br/>    2 -&gt; print("x == 2")     <br/>    else -&gt; print("x is neither 1 nor 2")<br/>}</span></pre><p id="429c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意Python 3.10有更强大的东西——结构模式匹配(见这里的<a class="ae lv" href="https://docs.python.org/3/whatsnew/3.10.html#pep-634-structural-pattern-matching" rel="noopener ugc nofollow" target="_blank">和</a>)，它类似于switch语句，但也分析对象的类型(“模式”)。</p><blockquote class="ob oc od"><p id="7826" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated">🎁<strong class="kk iu"> <em class="it">这个语言特性提供了什么？<br/> </em> </strong> <em class="it">简洁，可读性</em></p><p id="6021" class="ki kj le kk b kl km ju kn ko kp jx kq oe ks kt ku of kw kx ky og la lb lc ld im bi translated"><em class="it">💡</em> <strong class="kk iu"> <em class="it">在科特林是如何实现的？<br/> </em> </strong> <em class="it">通过</em> <code class="fe lw lx ly lz b"><em class="it">when</em></code>实现</p></blockquote></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="058d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">参考</h1><p id="e1fe" class="pw-post-body-paragraph ki kj it kk b kl nb ju kn ko nc jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated"><a class="ae lv" href="https://kotlinlang.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">科特林官方文档</a></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="8a10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">伙计们，现在就到这里吧！我希望你学到了一些东西。学习一门新的编程语言很有趣，因为你会接触到可能对你想要的有帮助的新模式。</p></div></div>    
</body>
</html>