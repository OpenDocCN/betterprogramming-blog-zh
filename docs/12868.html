<html>
<head>
<title>How to Handle Full-page Reloads With Django and HTMX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Django和HTMX处理整页重载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-handle-full-page-reloads-with-django-and-htmx-a9a7ef2e4b1c?source=collection_archive---------7-----------------------#2022-07-07">https://betterprogramming.pub/how-to-handle-full-page-reloads-with-django-and-htmx-a9a7ef2e4b1c?source=collection_archive---------7-----------------------#2022-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1bcd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索用例场景。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c9854c0ddba7b8fa61a39bf078ca8754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8odNSEl6_NwsE7KXT5431w.png"/></div></div></figure><p id="54b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将HTMX与Django一起使用时，您可能会遇到的一个常见问题是在使用<code class="fe ln lo lp lq b">hx-target</code>属性和<code class="fe ln lo lp lq b">hx-push-url</code>属性时处理整页重载。在处理这个问题时，我们可以使用几个选项。</p><ul class=""><li id="5b5e" class="lr ls iq kt b ku kv kx ky la lt le lu li lv lm lw lx ly lz bi translated"><strong class="kt ir">选项一</strong>是给每个模板添加一个定制的事件监听器，用<code class="fe ln lo lp lq b">hx-push-url</code>把它的URL推送到浏览器的历史中。</li><li id="3f9d" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><strong class="kt ir">选项二</strong>是扩展Django的默认<code class="fe ln lo lp lq b">TemplateResponseMixin</code>来处理HTMX请求。</li><li id="1045" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated"><strong class="kt ir">选项三</strong>包括创建一个定制的中间件类并使用<code class="fe ln lo lp lq b">process_template_request</code>方法。</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="ac4a" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">先决条件</h1><p id="70f8" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">本文假设您已经开始了一个新的Django项目，在静态文件中包含了HTMX，并安装了<a class="ae nj" href="https://github.com/adamchainz/django-htmx" rel="noopener ugc nofollow" target="_blank"> django-htmx </a>应用程序。</p><h1 id="d68a" class="mm mn iq bd mo mp nk mr ms mt nl mv mw jw nm jx my jz nn ka na kc no kd nc nd bi translated">选项一</h1><p id="e566" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">如果您只需要处理整个项目中一个或两个视图的整页重新加载，选项一是理想的，因为它不遵循DRY原则。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="480a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个选项非常简单。当加载模板时，它将获得属于所提供的URL的视图，并在所提供的目标内呈现响应。</p><p id="994a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意:</strong>这可能不是你所习惯的传统事件监听器。来自<a class="ae nj" href="https://htmx.org/attributes/hx-trigger/" rel="noopener ugc nofollow" target="_blank">的htmx文档</a>:</p><blockquote class="nr ns nt"><p id="1aaa" class="kr ks nu kt b ku kv jr kw kx ky ju kz nv lb lc ld nw lf lg lh nx lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">hx-trigger</code>属性允许您指定什么触发AJAX请求。</p></blockquote><p id="9072" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而“加载”被描述为htmx支持的非标准事件。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="25fa" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated"><strong class="ak">选项二</strong></h1><p id="f431" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">当您想在大多数视图中处理htmx请求，但不一定是所有视图时，这个选项是最好的。我们从创建自定义mixin类<code class="fe ln lo lp lq b">HtmxResponseMixin</code>并继承Django的<code class="fe ln lo lp lq b"><a class="ae nj" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/mixins-simple/#templateresponsemixin" rel="noopener ugc nofollow" target="_blank">TemplateResponseMixin</a></code>和<code class="fe ln lo lp lq b"><a class="ae nj" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/mixins-simple/#contextmixin" rel="noopener ugc nofollow" target="_blank">ContextMixin</a></code>开始。从这里开始，我们将重写<code class="fe ln lo lp lq b">get_template_names</code>和<code class="fe ln lo lp lq b">get_context_data</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="36c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">get_template_names</code>中，我们需要获得请求所属的应用程序的名称。为此，我们需要在项目的URL中包含一个app名称空间。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="4c1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们检查对htmx实例的请求，并将正确的基本模板返回给响应的上下文。</p><h2 id="f735" class="ny mn iq bd mo nz oa dn ms ob oc dp mw la od oe my le of og na li oh oi nc oj bi translated">模板设置</h2><p id="d071" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">现在，当我们将mixin添加到视图中时，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8af7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果请求是由htmx发出的，它将呈现我们的部分模板，如果不是一个完整的页面模板将被返回。为了避免为每个页面重写内容，我们可以用一种适合Django的方式来设置模板。</p><p id="af11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们在模板目录中设置<strong class="kt ir">base.html</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6692" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们在模板目录中设置<strong class="kt ir">partial.html</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="268f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们在templates/app_namespace目录中设置<strong class="kt ir"> template_name.html </strong>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="6599" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在那里我们可以更新页面标题，添加面包屑，甚至用Django的消息框架包含消息。下面我们添加画布内容。</p><p id="b181" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在你可以看到我们如何使用htmx与我们的应用程序交互，创建一个类似SPA的界面。选项三通过使用定制中间件将这一概念向前推进了一步。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="31c8" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">选项三</h1><p id="8a5e" class="pw-post-body-paragraph kr ks iq kt b ku ne jr kw kx nf ju kz la ng lc ld le nh lg lh li ni lk ll lm ij bi translated">最后一个选项的工作方式与第二个相似，但是更加含蓄。我们从定义中间件类开始，默认情况下，它要求<code class="fe ln lo lp lq b">__init__</code>方法接受一个<code class="fe ln lo lp lq b">get_response</code>参数。</p><p id="009d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来是__call__方法，每次发出请求时都会调用它。目前，它只需要返回一个响应对象供<code class="fe ln lo lp lq b"><a class="ae nj" href="https://docs.djangoproject.com/en/4.0/topics/http/middleware/#process-template-response" rel="noopener ugc nofollow" target="_blank">process_template_response</a></code>方法处理。这个特殊的方法是一个中间件钩子，它在一个视图完成执行后被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="98ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">process_template_response</code>里面，我们开始看到与选项二的相似之处。我们的应用程序仍然需要一个名称空间，但是之后，我们需要在settings.py文件中创建一个名为<code class="fe ln lo lp lq b">HTMX_APPS</code>的新列表，并检查请求是否属于这个列表中的一个应用程序。在设置中，我们可以将我们的类添加到<code class="fe ln lo lp lq b">MIDDLEWARE</code>列表中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8f93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们的定制中间件类只影响我们明确定义的应用程序，防止其他第三方应用程序出错，比如默认的Django管理应用程序。</p><p id="22b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们为responses <code class="fe ln lo lp lq b">template_name</code>属性提供适当的模板，检查对htmx实例的请求，并将适当的基础模板传递给<code class="fe ln lo lp lq b">context_data</code>。然后返回响应对象，该对象必须实现一个<code class="fe ln lo lp lq b">render</code>方法。这意味着Django的任何默认的基于类的视图都可以很好地与这个中间件类一起工作。</p><p id="f9a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模板设置遵循与选项2相同的方法。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="be57" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">资源</h1><ul class=""><li id="6b20" class="lr ls iq kt b ku ne kx nf la ok le ol li om lm lw lx ly lz bi translated">Github <a class="ae nj" href="https://github.com/adamchainz/django-htmx" rel="noopener ugc nofollow" target="_blank"> django-htmx </a></li><li id="e4ef" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">Htmx <a class="ae nj" href="https://htmx.org/attributes/hx-trigger/" rel="noopener ugc nofollow" target="_blank"> hx触发器</a></li><li id="189e" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">django<a class="ae nj" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/mixins-simple/#templateresponsemixin" rel="noopener ugc nofollow" target="_blank">TemplateReponseMixin</a></li><li id="a3fb" class="lr ls iq kt b ku ma kx mb la mc le md li me lm lw lx ly lz bi translated">Django <a class="ae nj" href="https://docs.djangoproject.com/en/4.0/ref/class-based-views/mixins-simple/#contextmixin" rel="noopener ugc nofollow" target="_blank"> ContextMixin </a></li></ul><pre class="kg kh ki kj gt on lq oo op aw oq bi"><span id="6e95" class="ny mn iq lq b gy or os l ot ou">In the next post I’ll be showing how we can build a highly dynamic SPA-like application using these practices.</span></pre></div></div>    
</body>
</html>