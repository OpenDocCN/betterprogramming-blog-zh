# 界面死亡

> 原文：<https://betterprogramming.pub/death-by-interfaces-ec7b35e634c1>

## 这可能是一个不受欢迎的观点，但是对于面向对象编程语言中的接口，我们可能弊大于利

![](img/22e647cd3a0b8db184ff202f267a5bba.png)

由[克林特·帕特森](https://unsplash.com/@cbpsc1?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/plug?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

让我解释一下。

# 界面 101

首先，消歧时间:当我在这里谈论接口时，我指的是代码中的接口定义，而不是用户界面、用户体验或任何图形性质的东西。

简单地说，接口是一个*契约*，它表示一个类将具有某些特征——主要是公共方法和属性——其他组件可以与之交互。

接口的目的是为编程语言提供某种程度的解耦。

例如，如果您有一个需要读取一些外部数据的类，您可以让它接受一个`IDomainObjectDataProvider`而不是一个`SqlServerDomainObjectDataProvider`。

这样，您的类就不需要关心它是在与内存中的数据、数据库中的数据还是由一些外部 API 调用提供的数据进行对话。

这是有意义的，也是拥有接口的经典理由。

另一个原因可能是一个层中的类没有对另一个层中定义的类的引用。从这个意义上说，接口可以提供一定程度的间接性。我不太喜欢这种推理，但它在某些情况下是有效的。

# 接口有什么问题？

接口本身并不坏，但它们确实有一些重要的权衡，我不相信开发人员会充分考虑使用它们的权衡。

## 导航灾难

首先，使用接口很难浏览代码。

如果我在我选择的开发环境中，大多数将支持 ctrl-clicking 或一些键盘快捷键来导航到类型的定义。

对于具体类型，导航将直接带您到您最感兴趣的方法的实现。使用接口，您将导航到该方法的接口定义。

这听起来可能不多，但是如果你“在流动中”并且思考一个过程，这类似于在拐角处发现一堵坚固的墙，你期望那里有一扇门。

你必须弄清楚你所看到的，然后找出你实际上在处理的具体类型，找到它们，并找到相关的定义。

这对我们工作效率的影响很小，但是很重要，这种情况在接口丰富的环境中经常发生。

## 通过接口混淆

让我们回到作为契约的接口的定义，以及针对特定类型的数据提供者的接口的早期示例。

的确，让我们的代码灵活并且与特定的实现分离是非常好的。但是如果我在看一个类，看到一个接口，我有时会忘记运行时的细节。

比方说，我们在一个应用程序中只有一种类型的`IEmalSender`。如果我在浏览代码时看到的只是一个`IEmailSender`引用，我可能会忘记我们在产品中实际使用的是什么发送者，以及它的一些实现细节。

有些人可能会认为这是一件*好*的事情，我不应该关心，他们在某种程度上是对的，但是当我们从抽象的角度考虑太多，以至于看到具体的部署场景变得困难时，问题就来了。

## 建筑水泥

我喜欢把接口看作软件开发中的一种“建筑水泥”。

我的意思是，如果我正在进行一些重构(清理代码的形式而不改变其行为)，并且我发现我不再需要传递某个参数，或者我想要将一个异步的方法变成同步的(反之亦然)，或者任何数量的小调整，接口会使这变得更困难。

我不需要在一个地方改变什么，我必须导航到界面并在那里改变它。如果该接口有任何其他实现，我需要找出它们并确保它们也被更改。

这意味着一个在过去可能微不足道的手术现在会让我脱离自然状态，需要额外的努力和思考来完成。这可能不是很多，但足以让我三思。

此外，如果一个接口的成员从来没有被使用过，那么用代码分析工具发现这一点比一个不符合接口的方法要困难得多。这意味着作为接口定义一部分的死代码会存在更长时间。

我在这里的观点是*我们在软件维护期间以小麻烦的形式为接口付费。*

不是很多，但是比你想象的多，用的接口越多，问题就越明显。

# 界面分离原理

我看到的接口的另一个主要问题是违反接口隔离原则(ISP)。ISP 是[可靠编程原则](https://en.wikipedia.org/wiki/SOLID)的一部分，这是随着时间的推移产生可维护软件的五个原则。

具体来说，ISP 谈到更喜欢围绕专门任务的许多较小的接口，而不是为做许多一般事情的类设计的一个较大的接口。

当开发人员向现有系统添加接口时，这一原则经常被违反。通常，他们会进入一个类，为所有公共成员提取一个接口，然后用接口的用法替换类的用法。

这有点简单易行，因此阻力最小的路径导致了像`IUserRepository`这样的大接口，而不是像`IUserValidator`和`IUserCreator`这样的小接口。

这些较大的接口存在许多问题，包括:

*   它们经常表现出前面章节中列出的问题。
*   由于作为接口一部分的成员的数量，它们使得新的实现变得困难。
*   它们往往是该接口的唯一具体实现。
*   它倾向于提升不遵守单一责任原则的类(另一个 [SOLID](https://en.wikipedia.org/wiki/SOLID) 的租户)。

总的来说，大界面不是一个好主意，从长远来看，会导致维护问题。

# 继承与接口

所以，如果我对接口提出警告，我建议什么可能是更好的选择呢？

通常，当系统在实现中需要一定程度的灵活性时，它们不需要接口提供的完全灵活性。通常，他们只需要一个基类，该基类可以作为一个小型契约，用于依赖注入或测试。

正因为如此，我主张任何时候你考虑添加一个接口时，你应该考虑引入或使用一个现有的基类是否更合适。

基类可以提供的一些优势:

*   导航到基类实际上可以导航到相关方法的具体或默认实现。
*   基类提供了一定程度的代码重用/共享，这是通过接口无法实现的。
*   基类比接口更容易重构。

当然，需要考虑缺点和权衡:

*   基类中的代码将出现在任何派生类中，除非被重写，这可能会对实现造成太大的限制。
*   您并不总是能够控制足够多的代码来使基类成为一个可行的选项，或者层依赖使得这是不可能的。
*   如果在你的类层次结构中已经有了继承，这会导致太多的“继承深度”。

所以，就使用基类还是接口而言，这是一个折衷的问题。

总的来说，我喜欢为非常小的功能使用接口，并且倾向于为像配置[反转控制](https://en.wikipedia.org/wiki/Inversion_of_control)容器这样的事情使用基类。

# 结束语

你的偏好会符合你的需求。我所要求的是，你不要只是自动假设:“这应该是一个接口”，或者“这应该是一个基类”，甚至“我不应该把一个具体的类传入这个方法。”

您是否为灵活性、维护、快速开发或其他方面进行优化完全取决于您。

任何事物都有优点和缺点，软件工程就是为你的代码库找到合适的组合。