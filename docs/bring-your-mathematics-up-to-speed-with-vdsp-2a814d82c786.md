# 使用 vDSP 加快您的数学运算速度

> 原文：<https://betterprogramming.pub/bring-your-mathematics-up-to-speed-with-vdsp-2a814d82c786>

## Swift 中更快的数学运算

![](img/1a585e47671d96fcf946e6ec9bd964f7.png)

阿什拉夫·阿里在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 介绍

应用程序速度超快，响应速度真的很快……除非它们不是这样。每当你在代码中处理大规模计算时，总会有一个点让你的函数变慢，你会发现自己盯着代码想知道为什么这个简单的加法、乘法或除法会让一切都停止。我们的口袋里不是应该有超级计算机吗？

幸运的是，现代 CPU 实际上相当快。但是你，编码者，也需要知道如何以一种可以非常有效地执行的方式来呈现你的数学代码。为此，我们将利用(部分)自 2003 年就存在的[加速](https://developer.apple.com/documentation/accelerate)框架。

# 一点历史

当然，早在 2003 年 Swift 还不存在，但存在的是 Power Mac G4 和 G5。OG 奶酪磨碎机和古老的风洞 G4 带来的东西之一是 [AltiVec](https://en.wikipedia.org/wiki/AltiVec) (也被苹果称为*速度引擎*)。开发人员对此的支持包含在 Mac OS X 10.3 (Panther)中，因此每个人都可以通过使用 Accelerate 框架来利用它。每个人都在玩数学游戏，一片欢腾！

然后在 2005 年，苹果宣布他们将从 IBM (PowerPC)转向英特尔(x86)。幸运的是，英特尔也有一些这些 [SIMD](https://en.wikipedia.org/wiki/SIMD) 扩展，被称为 [SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions) (2、3 和后来的 4)，所以已经有一个支持库(Accelerate)来处理这些繁重的工作是一件好事。使用这个库的开发人员可以在新的体系结构上相当容易地运行他们的代码，而不必担心必须重写他们的代码来匹配新的指令集或体系结构。

几年后，在 2007 年，苹果推出了 iPhone，同样采用了不同的 CPU 架构(ARM)。直到 iOS 4 才为这个平台提供了 Accelerate，但是，在那个时候有一个抽象框架是很好的，我们作为开发人员，不必针对 CPU 细节。

所有这些导致了一个跨多个 CPU 架构使用的单一框架，并提供了一个可靠而快速的抽象层，因此我们不必为特定的架构编写特定的代码。耶！

# 加速前进

所以你的代码运行缓慢，但是我们想修复它，让它更快。许多开发人员立即开始将东西转移到后台队列，因为这就是我们所学的，对吗？永远不要阻塞主队列，在后台队列中执行开销很大的操作。这是明智的建议，但是后台队列中的慢速代码仍然会很慢。

大多数时候，计算速度慢的代码启动速度并不快(至少不明显)。有人会说，“嗯，对于这个 50 个数的数组，我们要执行这个和那个运算。”你要给它编程序。它似乎在合理的时间内运行。你非常自豪，因为你使用了像`map`或`zip`或`reduce`这样花哨快捷的东西，所有东西都适合一个简洁(功能性)的一行程序或超级紧凑的`for`循环。

然后，有人决定不应该是 50 个数字，而实际上是 50，000 个数字。你更新了号码，但是现在，哎呀，应用程序完全没有反应。不用担心——您只需将计算转移到后台队列中。问题解决了！但是在结果出来之前不得不等待五秒钟，感觉不是很令人满意。

公平地说，算法的复杂性并不总是罪魁祸首。在 Swift 中，即使是对大量数字进行最基本的运算，似乎也要花费很长时间。Swift 一定很慢吧？嗯，没有。但是 Swift 做了非常彻底的工作来保护您免受与无效内存访问相关的运行时错误。不幸的是，Swift 中对整个数据结构的`map`的下标访问和函数方法很慢。安全(有点)…但是很慢。

输入 vDSP。

# 为什么选择 vDSP？

> “vDSP 框架包含一组高度优化的函数，用于大型阵列上的数字信号处理和通用运算。”
> 
> — [苹果文档](https://developer.apple.com/documentation/accelerate/vdsp)

vDSP 是构成整个 Accelerate 框架的组件之一。这也是对该领域的一个相对温和的介绍，因为有许多方便的功能可以从 Swift 直接访问，而不必求助于手动内存管理和不安全的访问。

让我们来看一个例子。假设我们有一个包含 50，000 个类型为`Double`的项目的数组，我们想要计算平均值。一个简单直接的解决方案是对数组求和，然后除以项目数:

```
let array = Array(stride(from: 0.0, to: 50000.0, by: 1))
let mean = array.reduce(0.0, +) / Double(array.count)
```

很公平，如果你在操场上测量，你会得到大约 0.014 秒(14 毫秒)的平均计算时间，这取决于你的机器。不错——绝对不慢。但是，如果我们将其与 vDSP 替代方案进行对比，我们会得到不同的结果:

```
import Acceleratelet array = Array(stride(from: 0.0, to: 50000.0, by: 1))
let mean = vDSP.mean(array)
```

这一过程的平均计算时间比 T2 少一毫秒。您可能会认为这不公平，因为 vDSP 有一个专用的`mean`函数，所以我们将改用两个数组的简单乘法:

```
let array = Array(stride(from: 0.0, to: 50000.0, by: 1))
let result = array.map { $0 * $0 }
```

对抗

```
let array = Array(stride(from: 0.0, to: 50000.0, by: 1))
let result = vDSP.multiply(array, array)
```

这里的速度差异变得更加明显，Swifty 代码需要大约 350 毫秒，vDSP 代码需要*不到一毫秒*。供参考:所有基准测试都是在我的 MacBook Pro (2018)上使用 Xcode Playground 运行的。

你可能会插话说，这些都是非常基本的功能，没有人会在他们的应用程序中使用那种计算。但是，如果您从事信号处理(例如，音频处理)或在大型数据集上执行数据分析，那么您很可能会在非常大的数字数组上执行非常基本的重复操作。尤其是如果你在一个(接近)实时的领域工作，比如音频处理，每一毫秒都会有很大的不同。

[苹果文档](https://developer.apple.com/documentation/accelerate/using_vdsp_for_vector-based_arithmetic)有一个非常好的最简单的函数列表，处理加法/减法/乘法/除法，甚至包括经常使用的组合，例如，[将两个向量相加，然后乘以第三个](https://developer.apple.com/documentation/accelerate/vdsp/3241049-multiply)。这又导致了速度的提高，Swifty 实施需要 390 毫秒，而 vDSP 代码平均需要不到一毫秒。

# 包扎

一旦你对 vDSP 可以执行的操作有了感觉，你就会更好地理解如何重写你的算法，并将其分解成可以在所有苹果平台上快速运行的组件。

[这个列表](https://developer.apple.com/documentation/accelerate/vdsp/arithmetic_operations)提供了 vDSP 为您提供的所有方便的类函数的详尽概述，这些类函数使您可以非常轻松地抛出一个或多个(大型)数字数组并获得一个(快速！)结果回来了。

这里需要注意的是，引用的静态函数仅在最新的 iOS/macOS 版本中可用(iOS 13+和 macOS 10.15+)。如果你需要支持旧版本，仍然可以使用 vDSP，但是你必须自己解决内存管理问题。例如，我们的乘法示例如下所示:

这肯定没有新的静态函数好，但是同样快。此外，这些较旧的函数为您提供了更多的参数来调整，例如，实际处理的步距或项目数(如果您希望只对数据集的一部分执行计算，或者只对奇数/偶数元素执行计算)。

为了方便起见，我还添加了基准测试的操场代码。您可以简单地将它复制/粘贴到一个新的空操场上，并运行它来查看结果(平均运行时间将记录在控制台输出中)。

感谢您的阅读，希望这将鼓励您开始以不同的方式思考 Swift 中的计算，这样您就可以将它们分解为面向向量的操作，并帮助您极大地加快速度。