<html>
<head>
<title>Functional Programming: What’s a Functor?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:什么是函子？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-whats-a-functor-4f5f10a20509?source=collection_archive---------6-----------------------#2020-03-04">https://betterprogramming.pub/functional-programming-whats-a-functor-4f5f10a20509?source=collection_archive---------6-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="65c4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不需要以前的Haskell知识</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/761b134ce83173c128115f7042da05b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SF0xwy7N2LmBGXny"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@craiggarner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克雷格·加纳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e4c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们生产产品的时候，仿函数就已经伴随我们很久了。他们就像空气一样。它们是JavaScript的一个非常重要的特性，但是你并不知道它是否存在，或者不容易意识到它有多重要，尽管你知道它的存在。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6f75" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">阅读前</h1><p id="c05f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你已经知道Haskell或者其他有类型的编程语言，这篇文章对你来说不会太难。不过不用担心，不用从头学Haskell。请记住，这篇文章提到的任何类型都是抽象概念。</p><p id="9cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果您知道什么是TypeScript会更好，因为这个概念在TypeScript中广泛使用——尤其是在monads家族中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4d4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是类型？</h1><p id="3f90" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript生来就没有类型。这种语言被称为动态类型语言或动态编程语言，因为变量的类型是在运行时确定的。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="07d4" class="ne md it na b gy nf ng l nh ni">var name = 'foo';<br/>name = 1;</span></pre><p id="6787" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe nj nk nl na b">name</code>的类型将是一个数字，而不是一个字符串。</p><p id="01f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe nj nk nl na b">name</code>被划入了<code class="fe nj nk nl na b">foo</code>，但是<code class="fe nj nk nl na b">1</code>后来被划入了<code class="fe nj nk nl na b">name</code>。JavaScript允许开发人员自由地改变变量值，并且它在运行时评估变量的类型。</p><p id="6052" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ES6开始，新的变量关键词<code class="fe nj nk nl na b">const</code>出来了。一旦用<code class="fe nj nk nl na b">const</code>声明了变量，就不能更改值。然而，当没有<code class="fe nj nk nl na b">const</code>时，JavaScript仍然和以前一样执行。</p><p id="ba9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，你还可以用这种方式欺骗JavaScript。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7509" class="ne md it na b gy nf ng l nh ni">const numbers = [1, 2, 3];<br/>numbers.push('4');</span></pre><p id="b83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使<code class="fe nj nk nl na b">numbers</code>是用<code class="fe nj nk nl na b">const</code>声明的，您也可以将一个字符串值推入其中，因为JavaScript对<code class="fe nj nk nl na b">numbers</code>的限制是存储在<code class="fe nj nk nl na b">numbers</code>的内存空间中的内容，它是一个数组，而不是每个索引的值。</p><p id="c762" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，这意味着JavaScript不关心什么值存储在<code class="fe nj nk nl na b">numbers</code>中，只要<code class="fe nj nk nl na b">numbers</code>是一个数组。</p><p id="ffba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着时间的推移，一种新的编程语言出现了，TypeScript。TypeScript允许您使用许多有用的类型来开发和维护应用程序。</p><p id="08b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript和TypeScript的一个很大的区别是，TypeScript从不关心运行时处理。它总是在编译时告诉你一些东西。</p><p id="f060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以是的，它实际上没有解决运行时的动态类型问题。然而，现在您可以获得一种更安全的方法来声明和维护变量。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ec2b" class="ne md it na b gy nf ng l nh ni">let name: string = 'John';</span><span id="5624" class="ne md it na b gy nm ng l nh ni">name = 1;<br/>~~~~~~~~~<br/>// Cannot assign to 'yourName' because it is a constant.</span></pre><p id="90f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript帮助您避免错误的类型转换。这在运行时仍然很好，但在编译时是错误的，编译时是TypeScript工作的时期。</p><p id="3eb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，现在让我们考虑一下表达函数类型的方法。在JavaScript中，任何函数都可以接受任何输入值，并可以返回任何值作为输出。</p><p id="5f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，如果没有返回值，函数将返回<code class="fe nj nk nl na b">undefined</code>。然后，我可以把函数的类型写成如下。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="15c8" class="ne md it na b gy nf ng l nh ni">type Function = (...args: any[]) =&gt; any</span></pre><p id="10a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们假设有一个函数接受<code class="fe nj nk nl na b">a</code>，它是一个<code class="fe nj nk nl na b">A</code>类型，返回<code class="fe nj nk nl na b">b</code>，它是一个<code class="fe nj nk nl na b">B</code>类型。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a688" class="ne md it na b gy nf ng l nh ni">type Function = (a: A) =&gt; B</span></pre><p id="8228" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将用一种稍微不同的方式来表达。函数<code class="fe nj nk nl na b">f</code>代表it的类型，它接受<code class="fe nj nk nl na b">a</code>类型值并返回<code class="fe nj nk nl na b">b</code>类型值。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="24a1" class="ne md it na b gy nf ng l nh ni">f =&gt; (a -&gt; b)<br/>// fat arrow (=&gt;) means (=)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7262" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">仿函数——想象比萨饼盒子</h1><p id="a8af" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们试着用一个更现实的例子来接近这个无聊的概念。</p><p id="e5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一天，在一个饥饿的夜晚，你想吃比萨饼。你开车去了一家披萨店，点了一份意大利香肠披萨。30分钟后，你就能拿到你点的东西。</p><p id="ec95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哎呀，你意识到你要在上面点额外的配料。你问工人:“对不起，我能在这上面加额外的配料吗？”工作人员说:“对不起，我是收银员，帮不了你。”</p><p id="0939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时候，有人从厨房出来，问你:“需要帮忙吗？”你向他们解释了你想要什么。</p><p id="eaa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们说:“你找对人了。我能为你做那件事，”并且在你的比萨饼上放一些额外的配料，并且再次把它放在比萨饼盒子里。他们给了你带盒子的披萨。</p><p id="2a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“只要你把装披萨的盒子带来，我可以把披萨换成你想要的任何一种披萨。”</p><p id="50c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，来自厨房的人所做的是把比萨饼从盒子里拿出来，放上配料，然后再放回盒子里。即使你想再买一个披萨，你只需要告诉他们换盒子里的披萨。他们是一个<em class="nn">函子</em>。</p><p id="7754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，它们是一个接受输入并返回输出的函数——一个比萨饼。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="f1ff" class="ne md it na b gy nf ng l nh ni">KitchenGuy =&gt; (pizza A -&gt; pizza B)</span></pre><p id="8161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以这个人给一个<code class="fe nj nk nl na b">pizza A</code>，给你一个<code class="fe nj nk nl na b">pizza B</code>。但是，如果要把<code class="fe nj nk nl na b">pizza B</code>改成<code class="fe nj nk nl na b">pizza C</code>呢？记得他们说什么吗？</p><p id="4853" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“只要你把盒子带来，我就给你换。”</p><p id="c07e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把<code class="fe nj nk nl na b">KitchenGuy</code>的格式写成如下。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9fd3" class="ne md it na b gy nf ng l nh ni">KitchenGuy w/ Box =&gt; (pizza A w/ Box -&gt; pizza B w/ Box);</span></pre><p id="2f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来说一个函子。首先，我会记下它的表达。即使你不明白它的意思也没关系，我会一步一步地解释一切，通过与厨房人的故事进行比较。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="87a7" class="ne md it na b gy nf ng l nh ni">fmap:: (Functor f) =&gt; (a -&gt; b) -&gt; (fa -&gt; fb)</span></pre><p id="61d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种格式看起来很像<code class="fe nj nk nl na b">KitchenGuy</code>。一个仿函数<code class="fe nj nk nl na b">Functor f</code>以一个函数作为参数，再次返回该函数，但是看看返回值的类型。在每个输入和输出的最左边有一个<code class="fe nj nk nl na b">f</code>。</p><p id="1204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种格式中，就像<code class="fe nj nk nl na b">KitchenGuy</code>总是返回带有盒子的比萨饼一样，函子也总是返回带有容器类型的新函数<code class="fe nj nk nl na b">f</code>。</p><p id="b9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">KitchenGuy</code>接受比萨饼作为输入，因子接受函数作为输入。很简单，对吧？然后，你可能想知道最左边的<code class="fe nj nk nl na b">fmap</code>是什么。</p><p id="5b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仿函数从容器(披萨盒)中取出输入，并通过循环将输出放入容器中来处理它。Haskell中也使用了函子，他们有一定的方法<code class="fe nj nk nl na b">fmap</code>，叫做<em class="nn">函子</em>。</p><p id="faf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个数组的<code class="fe nj nk nl na b">map</code>方法的简单例子。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="c39d" class="ne md it na b gy nf ng l nh ni">const array = [1, 2, 3];<br/>const newArray = array.map(x =&gt; x * 2);</span><span id="8367" class="ne md it na b gy nm ng l nh ni">console.log(array) // [1, 2, 3]<br/>console.log(newArray) // [2, 4, 6]</span></pre><p id="fece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">map</code>接受一个在数组中循环的函数，并返回一个新数组。现在听起来是不是挺耳熟的？</p><p id="4750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，你是对的。数组是一个函子。为什么？因为你可以不断地链接<code class="fe nj nk nl na b">map</code> s。就像<code class="fe nj nk nl na b">KitchenGuy</code>可以一遍又一遍地处理披萨盒子里的披萨，只要他们收到盒子里的披萨，一个函子就会返回另一个函子。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="acee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="8583" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函子是函数式编程的一个基本概念，有兴趣的应该知道。</p><p id="37f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多人认为这很复杂，很难理解，但事实并非如此。它让你困惑的唯一原因是它总是带有类型，这对于像我这样的新手来说就像是一种外星语言。</p><p id="388e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该记住的最重要的一点是，函子只是一个包含一些值的容器，它返回另一个函子。函子在将值从容器中取出后在里面循环，所以无论你想成为什么样的函子，它都应该是可迭代的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fcbf" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">此外</h1><p id="5680" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我准备了一个函子的简短例子<code class="fe nj nk nl na b">class</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="992c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个类<code class="fe nj nk nl na b">Functor</code>。它有<code class="fe nj nk nl na b">map</code>，它接受一个带值的函数。在这个例子中,<code class="fe nj nk nl na b">map</code>所做的是通过将<code class="fe nj nk nl na b">this.value</code>传递给它并创建一个新的<code class="fe nj nk nl na b">Functor</code>类来执行<code class="fe nj nk nl na b">fn</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="948c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样，你可以继续用这个<code class="fe nj nk nl na b">Functor</code>类链接<code class="fe nj nk nl na b">map</code> s。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="08b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="ff7f" class="nq nr it lb b lc mu lf mv li ns lm nt lq nu lu nv nw nx ny bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Type_system#DYNAMIC" rel="noopener ugc nofollow" target="_blank">动态类型检查和运行时类型信息</a></li><li id="d2e6" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated"><a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿文档</a></li></ul></div></div>    
</body>
</html>