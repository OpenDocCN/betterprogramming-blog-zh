<html>
<head>
<title>Functional Programming: Using the Monad Type Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:使用Monad类型类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-using-the-monad-type-class-45e99d0992d7?source=collection_archive---------19-----------------------#2020-07-15">https://betterprogramming.pub/functional-programming-using-the-monad-type-class-45e99d0992d7?source=collection_archive---------19-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="11b6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索Monad类型类及其用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1886242366e69dd94f78afa15e27b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfQen58fJp_9Tl3-o7l1pA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@fatosi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Fatos Bytyqi </a>在<a class="ae kv" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="87be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将是一个包含几篇文章的系列，在这里我试图解释和展示一些函数式编程模式的用例。</p><p id="7d98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用TypeScript并使用函数式编程库<a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>。这些例子和解释受到了来自<code class="fe ls lt lu lv b">fp-ts</code>作者的<a class="ae kv" href="https://dev.to/gcanti/getting-started-with-fp-ts-ord-5f1e" rel="noopener ugc nofollow" target="_blank">伟大文章系列</a>的启发。</p><p id="0a92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们系列的第7部分，这篇文章是关于<code class="fe ls lt lu lv b">Monad type class</code>。我们将探索什么是<code class="fe ls lt lu lv b">Monads</code>以及我们可以用它们做什么。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="5976" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">嵌套上下文的问题是</h1><p id="6b93" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">到目前为止，我们已经看到了如何使用来自<code class="fe ls lt lu lv b">Functor type class</code>的<code class="fe ls lt lu lv b">map()</code>将<code class="fe ls lt lu lv b">pure unary</code>函数提升到<code class="fe ls lt lu lv b">Functor</code>“世界”,以及如何使用来自<code class="fe ls lt lu lv b">Apply type class</code>的<code class="fe ls lt lu lv b">ap()</code>来提升<code class="fe ls lt lu lv b">pure n-ary</code>函数。</p><p id="cb1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Functors</code>允许我们像<code class="fe ls lt lu lv b">(a: A) =&gt; B</code>一样提升功能。<br/> <code class="fe ls lt lu lv b">Apply</code>允许我们像<code class="fe ls lt lu lv b">(a: A) =&gt; (b: B) =&gt; C</code>一样提升功能。</p><p id="a03f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们有一个类似于<code class="fe ls lt lu lv b">(a: A) =&gt; M&lt;B&gt;</code>的函数呢(<code class="fe ls lt lu lv b">M</code>是<code class="fe ls lt lu lv b">effect</code>的占位符，例如<code class="fe ls lt lu lv b">Option</code>或<code class="fe ls lt lu lv b">Array</code>)？如果我们将这个函数与<code class="fe ls lt lu lv b">map()</code>一起使用，我们将得到一个嵌套的上下文:<code class="fe ls lt lu lv b">M&lt;M&lt;B&gt;&gt;</code>。</p><p id="8301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个简单的例子来说明这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d98c" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">解决嵌套上下文问题</h1><p id="b582" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了修复我们的嵌套上下文问题，我们需要某种东西能够以某种方式<code class="fe ls lt lu lv b">flatten</code>或<code class="fe ls lt lu lv b">unwrap</code>内部值，这样我们就可以将<code class="fe ls lt lu lv b">M&lt;M&lt;B&gt;&gt;</code>转换为<code class="fe ls lt lu lv b">M&lt;B&gt;</code>。</p><p id="a72d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要一个<code class="fe ls lt lu lv b">flatten()</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6aab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ls lt lu lv b">flatten()</code>函数正是我们想要的。它打开/展平嵌套的上下文。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="c6d7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">进入单子类型类</h1><p id="20f3" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">嵌套上下文是一个如此常见的问题，以至于有一个特殊的类型类用一个<code class="fe ls lt lu lv b">flatMap()</code>方法扩展了我们的<code class="fe ls lt lu lv b">Applicative type class</code>，顾名思义，这个方法在<code class="fe ls lt lu lv b">effect</code>上<code class="fe ls lt lu lv b">maps</code>，然后<code class="fe ls lt lu lv b">flattens</code>结果。它结合了<code class="fe ls lt lu lv b">map()</code>和<code class="fe ls lt lu lv b">flatten()</code>的功能。</p><p id="36ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们说的类型类就是<code class="fe ls lt lu lv b">Monad type class</code>。</p><p id="3352" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe ls lt lu lv b">Option effect</code>的<code class="fe ls lt lu lv b">Monad type class</code>实现示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e3f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在能够<code class="fe ls lt lu lv b">map</code>覆盖<code class="fe ls lt lu lv b">effect</code>和<code class="fe ls lt lu lv b">flatten</code>结果，所以我们不会以嵌套的上下文结束。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="18f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，我们现在可以使用<code class="fe ls lt lu lv b">Monad type class</code>来提升和使用类似<code class="fe ls lt lu lv b">(a: A) =&gt; M&lt;B&gt;</code>的功能。</p><p id="f262" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Monad</code>总是被描绘成复杂的事物，但是如果你从<code class="fe ls lt lu lv b">Fucntors</code>到<code class="fe ls lt lu lv b">Apply</code>再到<code class="fe ls lt lu lv b">Applicatives</code>，它就不再那么神秘了。它基本上只是对<code class="fe ls lt lu lv b">Functors</code>的一点扩展，可以从嵌套的上下文中取出内部值。</p><p id="10b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们已经有了一个丰富的工具包来处理和处理各种效果。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0d7b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">参考</h1><p id="bd6b" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">fp-ts库:<a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank">https://github.com/gcanti/fp-ts</a></p></div></div>    
</body>
</html>