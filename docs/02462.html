<html>
<head>
<title>An Introduction to Buffer Overflow Vulnerability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓冲区溢出漏洞简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-buffer-overflow-vulnerability-760f23c21ebb?source=collection_archive---------5-----------------------#2019-12-02">https://betterprogramming.pub/an-introduction-to-buffer-overflow-vulnerability-760f23c21ebb?source=collection_archive---------5-----------------------#2019-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa33" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">记忆开发的艺术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/eb86d7b2a2965720f7231743af59e0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*aUAed7YBstQkMPsT.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated"><em class="kr">来源:</em><a class="ae ks" href="https://retohercules.com/images600_/buffer-overflow-png-7.png" rel="noopener ugc nofollow" target="_blank"><em class="kr">https://reto Hercules . com/images 600 _/buffer-overflow-png-7 . png</em></a></p></figure></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="d633" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">缓冲器</h1><p id="3168" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">缓冲区是一种临时存储，通常存在于用于保存数据的物理内存中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/b6c8b0329c0ec2b32ae9fcb1030636f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:60/0*hX3qxQhdfPf8kimC"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/8f096f3bf5397f41d062adb8982911c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3OZEVjxa79lrLE65.png"/></div></div></figure><p id="faaa" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">考虑左图所示的程序，其中定义了长度为5的字符缓冲区。在一个大的内存集群中，一个5字节的小内存将被分配给缓冲区，如右图所示。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="7a86" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">缓冲区溢出</h1><p id="e0b2" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">当更多的数据被写入特定长度的内存，导致相邻的内存地址被覆盖时，就会发生缓冲区溢出。</p><h2 id="c642" class="mz lb iq bd lc na nb dn lg nc nd dp lk mb ne nf lm mf ng nh lo mj ni nj lq nk bi translated">演示(控制局部变量)</h2><p id="d63e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">让我们以一个基本认证应用程序为例，它要求输入密码，如果密码正确，则返回<code class="fe nl nm nn no b">Authenticated!</code>。</p><p id="f8d4" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">在不真正了解应用程序如何工作的情况下，让我们输入一个随机密码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi np"><img src="../Images/8ca207edfb1fa797352e814b7183ab9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zl_jjS7U_08WjG9y.png"/></div></div></figure><p id="6cf6" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">它显示<code class="fe nl nm nn no b">Authentication Declined!</code>，因为密码不正确。为了测试，我们需要输入大量随机数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi np"><img src="../Images/2b122f87b25196be30fa5eb9a88b292a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*w02pfh1A3W1K5kqR.png"/></div></div></figure><p id="5944" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">你一定想知道为什么它得到了认证，为什么有一个<code class="fe nl nm nn no b">Segmentation fault</code>。让我们看看更详细的应用程序版本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nq"><img src="../Images/b0bb5839e32a6db7ac1513fe179f3c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hL1ur87XGy-A7_Be.png"/></div></div></figure><p id="4eb1" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">如您所见，有三个变量:<code class="fe nl nm nn no b">auth</code>、<code class="fe nl nm nn no b">sys_pass</code>和<code class="fe nl nm nn no b">usr_pass</code>。</p><p id="1016" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated"><code class="fe nl nm nn no b">auth</code>变量根据值(最初为0)决定用户是否通过验证。<code class="fe nl nm nn no b">usr_pass</code>存储用户输入的密码，而<code class="fe nl nm nn no b">sys_pass</code>变量是正确的密码。</p><p id="ccac" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">app的工作原理是，如果<code class="fe nl nm nn no b">usr_pass</code>变量等于<code class="fe nl nm nn no b">sys_pass</code>，那么<code class="fe nl nm nn no b">auth</code>变量就变成了<code class="fe nl nm nn no b">1</code>。如果<code class="fe nl nm nn no b">auth</code>变量不是<code class="fe nl nm nn no b">0</code>，则用户通过验证。</p><p id="6059" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">您还可以看到变量是如何存储在内存中的。由于地址是十六进制的，并且相差1，因此，<code class="fe nl nm nn no b">usr_pass</code>和<code class="fe nl nm nn no b">sys_pass</code>变量是长度为16的缓冲区。</p><p id="ad40" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">要测试缓冲区溢出，请输入如下所示的长密码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nq"><img src="../Images/7231c22533d3a0da9a0e798c16daadd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B2Zjv4OCfkGmvr7q.png"/></div></div></figure><p id="0296" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">可以看到，在<code class="fe nl nm nn no b">usr_pass</code>变量中输入的密码溢出了<code class="fe nl nm nn no b">sys_pass</code>变量，然后溢出了<code class="fe nl nm nn no b">auth</code>变量。</p><p id="3fd1" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">注意:像<code class="fe nl nm nn no b">strcpy()</code>、<code class="fe nl nm nn no b">strcmp()</code>、<code class="fe nl nm nn no b">strcat()</code>这样的C函数不检查变量的长度，可以覆盖后面的内存地址，这正是缓冲区溢出的含义。</p><p id="786f" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">为了更好地理解，请参考下面的代码。</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="c092" class="mz lb iq no b gy nv nw l nx ny">#include &lt;stdio.h&gt;</span><span id="f693" class="mz lb iq no b gy nz nw l nx ny">int main(void) {    <br/>    int auth = 0;<br/>    char sys_pass[16] = "Secret";<br/>    char usr_pass[16];    printf("Enter password: ");<br/>    scanf("%s", usr_pass);    if (strcmp(sys_pass, usr_pass) == 0) {<br/>        authorized = 1;<br/>    }    printf("usr_pass: %s\n", usr_pass);<br/>    printf("sys_pass: %s\n", sys_pass);<br/>    printf("auth: %d\n", authorized);<br/>    printf("sys_pass   addr: %p\n", (void *)sys_pass);<br/>    printf("auth       addr: %p\n", (void *)&amp;authorized);    if (auth) {<br/>        printf("Authenticated!\n");<br/>    }<br/>    else{<br/>        printf("Authentication declined!\n");<br/>        }<br/>}</span></pre><p id="117d" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">注意:这可能是一个不切实际的例子，只是为了便于理解。现实生活中你可能看不到这样的情况。</p><p id="39c5" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">现在让我们稍微深入一下这些概念。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="0675" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">正在运行的进程的内存划分</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oa"><img src="../Images/9e52897877a8275c77c56b85a55e7910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SKamx0AryyHIHfET.png"/></div></div></figure><p id="a418" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">来源:<a class="ae ks" href="https://kotharitechnotrick.wordpress.com/2013/12/26/memory-mapping-in-c/" rel="noopener ugc nofollow" target="_blank">技术诀窍</a>。</p><p id="d923" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">这就是分配给进程的内存的样子。有<code class="fe nl nm nn no b">stack</code>、<code class="fe nl nm nn no b">heap</code>、<code class="fe nl nm nn no b">Uninitialized data</code>等各种区间。用于不同的目的。</p><p id="958c" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">你可以在这里读到更多关于内存布局的内容:<a class="ae ks" href="https://www.thegeekstuff.com/2012/03/linux-processes-memory-layout/" rel="noopener ugc nofollow" target="_blank">一个进程的内存布局。</a></p><p id="7b5c" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">这篇博客主要关注堆栈中的缓冲区溢出，所以让我们来看看。</p><ol class=""><li id="5e22" class="ob oc iq lu b lv mu ly mv mb od mf oe mj of mn og oh oi oj bi translated">堆栈:一种后进先出的数据结构，被计算机广泛用于内存管理等。</li><li id="9017" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn og oh oi oj bi translated">内存中有一堆寄存器，但我们只关心EIP、EBP和ESP。</li><li id="14e1" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn og oh oi oj bi translated">EBP:这是一个堆栈指针，指向堆栈的底部。</li><li id="50b4" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn og oh oi oj bi translated">ESP:是一个指向栈顶的栈指针。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi op"><img src="../Images/68c5a9a24e72da2eeab296d5e1be39ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WfmGnO0PuJ_CORb6.png"/></div></div></figure><p id="c439" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">5.EIP:它包含下一条要执行的指令的地址。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi oq"><img src="../Images/a9f2cd4ce519c9bc3bce06c668f1f6e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X-8MX75FoaWe27E6.png"/></div></div></figure></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="23f9" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">堆栈布局</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/7d017d0eb28e19a2c5cffd40788ee6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/0*DNLXAlzhi4VtvBZ9.png"/></div></figure><p id="07b8" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">上图显示的是一辆<code class="fe nl nm nn no b">stack</code>的样子。这看起来可能有点吓人，但是相信我，一点也不。</p><p id="16cf" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">让我们看看与堆栈相关的一些要点:</p><ul class=""><li id="f74e" class="ob oc iq lu b lv mu ly mv mb od mf oe mj of mn os oh oi oj bi translated">堆栈从较高的内存填充到较低的内存。</li><li id="1b37" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">在堆栈中，所有的变量都是相对于EBP来访问的。</li><li id="dbd1" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">在程序中，每个函数都有自己的堆栈。</li><li id="e984" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">一切都参考了EBP登记册。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ot"><img src="../Images/96d648c3478e8b9154c3d39c5b894825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oRoLANPK2oamyWCh.png"/></div></div></figure><p id="6af1" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">来源:<a class="ae ks" href="https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/" rel="noopener ugc nofollow" target="_blank"> IT &amp;安全素材</a>。</p><p id="3101" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">在EBP之上，存储功能参数。</p><p id="03a6" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">例如:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="b03e" class="mz lb iq no b gy nv nw l nx ny">void foo(int a, int b, int c){<br/>      //Function body<br/>   }</span></pre><p id="5afc" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">这里，<code class="fe nl nm nn no b">a</code>、<code class="fe nl nm nn no b">b</code>和<code class="fe nl nm nn no b">c</code>是存储在EBP上方的功能参数。</p><ul class=""><li id="ed45" class="ob oc iq lu b lv mu ly mv mb od mf oe mj of mn os oh oi oj bi translated">函数的所有局部变量都存储在EBP下面。</li><li id="1fd0" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated"><code class="fe nl nm nn no b">Old %ebp</code>是前一个函数的EBP的值。因为，在一个函数被执行后，它必须返回到一个更老的函数，我们需要存储老EBP和EIP的值。</li><li id="9334" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">ESP寄存器存储堆栈底部的地址。</li></ul><p id="1365" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">例如:</p><pre class="kg kh ki kj gt nr no ns nt aw nu bi"><span id="0933" class="mz lb iq no b gy nv nw l nx ny">void foo(int a, int b, int c){<br/>       int x;<br/>       int y;<br/>       int z;<br/>   }</span></pre><p id="0e92" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">这里，<code class="fe nl nm nn no b">x</code>、<code class="fe nl nm nn no b">y</code>、<code class="fe nl nm nn no b">z</code>是函数的局部变量，存储在EBP以下。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="3f41" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">利用缓冲区溢出</h1><p id="8f52" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">是时候使用堆栈来研究缓冲区溢出利用了。</p><p id="6b65" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">在此之前，让我们试着理解一个栈是如何为任何函数构建的。</p><p id="e3c9" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">下面我们来看一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ou"><img src="../Images/442f6eb814d71d5d42b448593a96d848.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Eg6eX5ychECDR_-3.png"/></div></div></figure><p id="e6a4" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">如左图所示，右边的堆栈是功能<code class="fe nl nm nn no b">foo</code>的堆栈。</p><ul class=""><li id="1bc3" class="ob oc iq lu b lv mu ly mv mb od mf oe mj of mn os oh oi oj bi translated">由于<code class="fe nl nm nn no b">a</code>、<code class="fe nl nm nn no b">b</code>和<code class="fe nl nm nn no b">c</code>是传递给函数的参数，因此它们存储在EBP之上。此外，因为堆栈是从高到低的内存填充的，并且参数是从右到左读取的，所以<code class="fe nl nm nn no b">c</code>首先写入内存，然后是<code class="fe nl nm nn no b">b</code>和<code class="fe nl nm nn no b">a</code>。</li><li id="d3a6" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated"><code class="fe nl nm nn no b">x</code>、<code class="fe nl nm nn no b">y</code>和<code class="fe nl nm nn no b">z</code>是存储在EBP下的局部变量。</li><li id="93e2" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">还需要将函数<code class="fe nl nm nn no b">main</code>的<code class="fe nl nm nn no b">Old EIP</code>和<code class="fe nl nm nn no b">Old EBP</code>存储在堆栈中，以便知道函数执行后返回到哪里。</li></ul><p id="6835" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">现在，如前面的演示所示，您可以使用局部变量看到缓冲区溢出是如何发生的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ov"><img src="../Images/f5e90c55aa98ee24774ba146374bfee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IkNxMkCn8pGQI1oW.png"/></div></div></figure><p id="974f" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">来源:<a class="ae ks" href="https://www.securitysift.com/windows-exploit-development-part-2-intro-stack-overflow/" rel="noopener ugc nofollow" target="_blank">安检筛</a>。</p><p id="27af" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">想象这样一种情况，您溢出了变量<code class="fe nl nm nn no b">x</code>、<code class="fe nl nm nn no b">y</code>和<code class="fe nl nm nn no b">z</code>，使得旧的EIP被修改并存储了放置恶意代码的内存地址。</p><p id="98bf" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">为了更好的理解，请参考下图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi ow"><img src="../Images/a80ed61d007fab22b5ca743dec12a88e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_GA2ZI7udm7_8HuZ.png"/></div></div></figure><p id="40b7" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">假设在函数中定义了一个长度为500的缓冲区。现在它以这样一种方式溢出，它有一些随机数据，后跟外壳代码(恶意代码)，然后是指向外壳代码的返回地址。</p><p id="92ef" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">因此，在函数被执行后，返回地址指向的指令被执行，这就是我们的外壳代码被执行的方式。</p><p id="9197" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">缓冲区溢出就是这样发生的。</p><p id="074b" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">你一定要看这个视频:<a class="ae ks" href="https://www.youtube.com/watch?v=1S0aBV-Waeo" rel="noopener ugc nofollow" target="_blank"> <em class="ox">缓冲区溢出攻击——computer phile</em></a>更真实的了解缓冲区溢出。以上视频中使用的代码在<a class="ae ks" href="https://gist.github.com/apolloclark/6cffb33f179cc9162d0a" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="65ca" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">安全措施</h1><ul class=""><li id="a4d3" class="ob oc iq lu b lv lw ly lz mb oy mf oz mj pa mn os oh oi oj bi translated">使用Python、Java或Ruby之类的编程语言，在这些语言中会发生动态内存分配，并且语言本身会为您管理内存。</li><li id="f4d2" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">在像C和C++这样的语言中，在将数据写入缓冲区之前，执行所有相关的检查和输入验证。</li><li id="412d" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">在使用任何外部库之前，检查其中的安全漏洞。</li><li id="3356" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">使用源代码分析工具针对漏洞进行静态分析。</li><li id="b886" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated">使用不可执行的堆栈:这意味着即使一个机器码被注入到堆栈中，它也不能被执行，因为特定的内存区域是不可执行的。这是通过设置NX位来实现的。</li></ul><p id="2e26" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">注意:即使采取了这些措施，仍有可能利用缓冲区溢出。因此，这些只是有助于防止利用缓冲区溢出的安全层。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><h1 id="0e13" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">参考</h1><ul class=""><li id="e41c" class="ob oc iq lu b lv lw ly lz mb oy mf oz mj pa mn os oh oi oj bi translated"><a class="ae ks" href="https://insecure.org/stf/smashstack.html" rel="noopener ugc nofollow" target="_blank">砸栈取乐牟利</a></li><li id="1e60" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated"><a class="ae ks" href="http://homes.sice.indiana.edu/yh33/Teaching/I433-2016/lec11-more-bo.pdf" rel="noopener ugc nofollow" target="_blank">缓冲区溢出漏洞利用及对策</a></li><li id="6fcf" class="ob oc iq lu b lv ok ly ol mb om mf on mj oo mn os oh oi oj bi translated"><a class="ae ks" href="http://www.cis.syr.edu/~wedu/Teaching/IntrCompSec/LectureNotes_New/Buffer_Overflow.pdf" rel="noopener ugc nofollow" target="_blank">缓冲区溢出漏洞和攻击</a></li></ul><p id="a1ad" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated">如果你喜欢这个博客，别忘了留下一些掌声:)</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="9690" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated"><em class="ox">我们连线吧？</em></p><p id="5241" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated"><em class="ox">领英:</em><a class="ae ks" href="https://linkedin.com/in/ashwigoel" rel="noopener ugc nofollow" target="_blank"><em class="ox">https://linkedin.com/in/ashwigoel</em></a></p><p id="587c" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated"><em class="ox">网址:</em><a class="ae ks" href="https://ashwingoel.com" rel="noopener ugc nofollow" target="_blank"><em class="ox">https://ashwingoel.com</em></a></p><p id="ecf9" class="pw-post-body-paragraph ls lt iq lu b lv mu jr lx ly mv ju ma mb mw md me mf mx mh mi mj my ml mm mn ij bi translated"><em class="ox">邮件:</em><a class="ae ks" href="mailto:goelashwin36@gmail.com" rel="noopener ugc nofollow" target="_blank"><em class="ox">goelashwin36@gmail.com</em></a></p></div></div>    
</body>
</html>