<html>
<head>
<title>How To Use Structured JSON Logging in Golang Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Golang应用程序中使用结构化JSON日志记录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-structured-json-logging-in-golang-applications-7fc5e2751dbd?source=collection_archive---------3-----------------------#2021-08-09">https://betterprogramming.pub/how-to-use-structured-json-logging-in-golang-applications-7fc5e2751dbd?source=collection_archive---------3-----------------------#2021-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a84a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">结构化日志对于软件调试非常重要。很高兴，在Golang中实现起来非常容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b4bc06b2d0cbc4916f3fe8b0711d249d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hSQ06Riw_dXUEF-Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿尔瓦罗·皮诺在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="7296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厌倦了通过非结构化日志来追踪一个bug？有没有试过强迫一个开发团队以结构化的方式写下他们的错误信息？好吧，在阻止不良软件日志的旅程中，你来对了地方。</p><h1 id="fb2d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是结构化日志记录？</h1><p id="57d5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">日志是软件非常重要的一部分。我们确实需要日志来跟踪系统中发生的事情，随着日志变得越来越大，它变得越来越重要。</p><p id="82f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多很棒的工具可以帮助我们解析日志。例如，我个人是<a class="ae ky" href="https://www.elastic.co/what-is/elasticsearch" rel="noopener ugc nofollow" target="_blank"> ElasticSearch </a>的忠实粉丝。但是这些工具大部分时间依赖于结构化日志，而不是可能以某种格式编写的纯文本blob块。</p><p id="19e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我记得当被分配去追踪一个bug时，系统有大约30个CRON作业在运行一些脚本，所有的脚本都把它们的输出写到一个文件中，这个文件是按日期轮换的。所以至少有某种中央日志记录(不是最推荐的，但是嘿)。有这个古老系统的日志，所以我进去了，手里拿着胶带；我本打算修补这个漏洞。</p><p id="2971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在日志中遇到的第一件事是可怕的:每个脚本都将简单的文本消息打印到日志文件中，根本没有关于它是什么服务的信息。没有上下文，没有复制错误的信息，什么都没有。我睁着水汪汪的大眼睛看着这个:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="69bc" class="mx lw it mt b gy my mz l na nb">"" not allowed</span></pre><p id="5233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">日志很快被填满，旧的日志文件非常大。这并不奇怪，因为大约有50到60个bash脚本，它们都很大并且经常运行。我花了相当长的时间来追踪这个bug，使用结构化日志可以很容易地节省时间。</p><p id="3c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结构化日志是以众所周知的格式编写的日志，有助于读取/查询和存储它们。最常见的方法之一是JSON格式的日志。</p><p id="9d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些日志中，您可以指定一些必须可用的字段，这些字段将始终有助于调试。让我们想象一下我的这个恐怖系统使用了结构化日志记录。如果是这样，输出将如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f251" class="mx lw it mt b gy my mz l na nb">{ "date": "2001-02-03", "service": "buggy-script", "level": "Warning", "message": "'' not allowed", "context": "validateInputFunction"}</span></pre><h1 id="0715" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Golang中轻松的结构化日志</h1><p id="5f80" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">结构化日志在Golang中很容易使用，所以如果您还没有使用它们，您应该开始使用。</p><p id="7ae7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个软件包确实有帮助。我倾向于使用的是一个名为<code class="fe nc nd ne mt b"><a class="ae ky" href="https://github.com/rs/zerolog" rel="noopener ugc nofollow" target="_blank">Zerolog</a></code>的库。最佳日志包还有其他一些竞争对手，包括:</p><ul class=""><li id="e1d4" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">rs/zerolog  —速度极快的JSON结构化日志，我的主要日志包</li><li id="c710" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">sirupsen/logrus  —可能是最流行的日志包，结构化JSON日志。</li><li id="9e26" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://github.com/uber-go/zap" rel="noopener ugc nofollow" target="_blank"> uber-go/zap </a> —使用结构化JSON日志的超高速日志记录器。</li><li id="ef35" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><a class="ae ky" href="https://github.com/natefinch/lumberjack" rel="noopener ugc nofollow" target="_blank"> natefinch/lumberjack </a> —日志轮换包，以我的经验来看大多是和基于文件的日志一起使用。</li></ul><p id="1edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会在这篇文章中比较包，但也许在未来。让我们从使用<code class="fe nc nd ne mt b">zerolog</code>开始，尝试一下我们如何能够超级容易地使用它，并使用一些简单易懂的特性。</p><p id="0ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将从比较常规的日志包输出开始，只是为了向您展示结构化日志的样子。</p><p id="245b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也向您展示了<code class="fe nc nd ne mt b">zerolog</code>与常规的日志程序是兼容的，所以您可以只替换导入包。但这不会给你所有我们很快就会用到的好特性。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结构化日志-Zerolog-比较默认日志输出和zero log的Golang示例</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">输出—第一行是常规记录器，第二行是zerolog</p></figure><p id="4a60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从示例输出中可以看到，<code class="fe nc nd ne mt b">zerolog</code>输出JSON格式的日志更容易被Elasticsearch这样的集中式日志记录器接收。</p><p id="56e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们想添加更多的JSON字段呢？使用<code class="fe nc nd ne mt b">zerolog</code>的可链接API就足够简单了。大多数函数返回一个<code class="fe nc nd ne mt b">zerolog</code>。事件，它允许我们递归调用函数。</p><p id="d878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为服务名添加一个字段，并添加一些关于错误的数据。根据数据类型，您应该使用适当的函数。您可以在此找到所有可用的字段<a class="ae ky" href="https://github.com/rs/zerolog#standard-types" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为上下文日志添加了多个字段</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JSON中添加的上下文字段</p></figure><p id="34ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看到<code class="fe nc nd ne mt b">Info()</code>功能了吗？这用于控制要使用的日志级别。是的，它有日志级别。另一个额外的层来控制日志是伟大的。例如，我经常为我的程序使用一个调试标志，打开这个标志会输出很多在生产中没有记录的日志。</p><p id="219c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用日志级别很容易做到这一点。让我们用一个简单的程序来尝试一下——尝试切换调试标志并控制输出。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在我们的程序中使用日志级别来控制显示哪些日志</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">程序的唯一输出是信息日志，因为调试是假的</p></figure><p id="afeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，每个日志级别都有一个值，如果某个日志级别的值太高，您将看不到所有日志。所以，要小心使用。例如，如果我们将全局日志级别设置为“致命”，我们甚至看不到信息日志。您可以在zerolog <a class="ae ky" href="https://github.com/rs/zerolog#standard-types" rel="noopener ugc nofollow" target="_blank">文档</a>中查看所有日志级别和层级。</p><h2 id="8862" class="mx lw it bd lx nv nw dn mb nx ny dp mf li nz oa mh lm ob oc mj lq od oe ml of bi translated">那不要重复自己(干)呢？</h2><p id="80d4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在你可能在想，“太好了，原木看起来棒极了。”但是对于一个简单的日志来说，这需要输入很多内容，而且我需要一遍又一遍地重复服务名。</p><p id="8d9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很高兴，<code class="fe nc nd ne mt b">zerolog</code>允许我们创建带有默认值的定制日志程序。</p><p id="ffae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个程序，它说Hello，每次用包含在每个日志消息中的计数器记录日志。这一次，让我们在创建记录器时添加默认字段。同样，我们可以使用文档中提到的所有数据类型。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们记录器的默认字段</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">干式测井仪的输出</p></figure><h1 id="a14d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="db2e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">希望你会发现<code class="fe nc nd ne mt b">Zerolog</code>很容易使用。在我的发展过程中它给了我很大的帮助。在这篇文章中，我不会讨论如何将这些来自<code class="fe nc nd ne mt b">Stdout</code>的日志吸收到流行的框架中，比如<code class="fe nc nd ne mt b">Elasticsearch</code>。</p><p id="5ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请继续关注，因为我总是很高兴收到读者的反馈或问题。</p><p id="4ee7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次到此为止。走出去，记录世界上的一切！</p></div></div>    
</body>
</html>