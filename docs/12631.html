<html>
<head>
<title>Docker, WSL, and oneAPI — A Quick How-To Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker、WSL和oneAPI——快速操作指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-wsl-and-oneapi-a-quick-how-to-guide-d7db3363b303?source=collection_archive---------10-----------------------#2022-06-17">https://betterprogramming.pub/docker-wsl-and-oneapi-a-quick-how-to-guide-d7db3363b303?source=collection_archive---------10-----------------------#2022-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f0fc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">优化用于部署的容器化oneAPI工作负载</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/42e3b270573f83efcd898b4a15d0b620.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SUU2qTbj-TITR2z9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯蒂安·威迪格在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="5774" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">什么是容器？</strong></h1><p id="823a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在我的上一篇博客中，我花了一些时间谈论为什么作为一名开发人员高效对我很重要。容器技术的发展可以极大地帮助我们实现这个目标。</p><p id="23e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">首先，让我们快速地为那些不知道的人介绍一下容器是什么。Docker是最常见的容器化解决方案，所以我将从他们的<a class="ae kv" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">网站</a>上获取容器的定义:</p><blockquote class="mp mq mr"><p id="bc18" class="lo lp ms lq b lr mk jr lt lu ml ju lw mt mm lz ma mu mn md me mv mo mh mi mj ij bi translated">容器是一个标准的软件单元，它将代码及其所有依赖项打包，以便应用程序能够快速可靠地从一个计算环境运行到另一个计算环境。Docker容器映像是一个轻量级的、独立的、可执行的软件包，包括运行应用程序所需的一切:代码、运行时、系统工具、系统库和设置。</p></blockquote><p id="1f03" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">容器可以在Windows或Linux系统上运行，相对容易设置和部署，并且容易共享或分发给其他人(通过像<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>这样的服务)。</p><p id="bc39" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，使用容器也有一些限制。你必须在每一个你想运行容器的系统上设置一个容器运行时，容器会变得很大，如果你经常上传和下载它们，这可能是一个问题，而且它们不像虚拟机(VM)那样在底层系统上提供硬的资源分离。尽管有这些限制，对于许多用例来说，容器是一种很棒的方式，所以让我们谈谈它如何帮助我们这些开发人员。</p><h1 id="81a2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">这对开发者意味着什么？</strong></h1><p id="dd53" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用容器作为我们开发过程的一部分意味着您可以创建和维护一个稳定的、可重复的环境来开发软件。如果您曾经破坏了您的开发环境，只需启动容器的另一个实例就可以获得一个干净的工作环境。</p><p id="05e6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一件很酷的事情是你可以在一个系统上创建和运行多个开发和测试环境(也就是多个Linux版本)。最重要的是，您通常不必担心搞乱您的主机系统，因为容器隔离了大多数资源。</p><p id="8cc5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于客户使用容器的开发人员来说，将应用程序放在容器中可以让您在一个更可控的环境中运行。这有助于减少bug，减少您的测试表面积，并提高您的上市时间(TTM)，这对您和您的客户都有好处。</p><p id="ca88" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有其他选项可用于解决一些“多开发环境”问题，例如基于虚拟机(VM)的解决方案。您可以创建一个基本的Windows Subsystem for Linux (WSL)实例，在其中配置开发环境，并多次部署该实例。您还可以使用更强大的企业解决方案，如VMware虚拟桌面基础架构(VDI)。然而，这些解决方案并不适用于所有平台上的每个人，因此出于这篇博客的目的，我将重点关注利用容器来帮助使用oneAPI开发和部署软件。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="1999" class="kw kx iq bd ky kz nd lb lc ld ne lf lg jw nf jx li jz ng ka lk kc nh kd lm ln bi translated"><strong class="ak">使用oneAPI开发容器</strong></h1><p id="0241" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了利用oneAPI开发容器来提供前面提到的稳定的开发环境，我们首先需要在我们的开发系统上设置Docker。一般来说，你可以去Docker的网站，按照他们的安装说明进行操作。您可能还记得我以前的博客，我在开发中使用了WSL环境，所以有点复杂。</p><p id="203d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我本打算就此写一篇简单的文章，但幸运的是，在我之前已经有许多人这样做了。我发现如果你想遵循这种方法，ferarias<a class="ae kv" href="https://medium.com/@ferarias/docker-in-windows-11-using-wsl2-8e30faddc32c" rel="noopener">story</a>是最容易理解的。</p><p id="d3a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦Docker设置完成，您就可以从Docker Hub获取最新、最棒的oneAPI开发容器。</p><p id="8e3b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有用于在CentOS8、Ubuntu 18.04或Ubuntu 20.04上开发oneAPI代码的oneAPI开发容器。对于这个例子，我将构建并打包一些简单的SYCL代码，因此我将提取oneAPI基础工具包Ubuntu 20.04映像。使用Docker命令行，我只需运行:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0cf6" class="nn kx iq nj b gy no np l nq nr">&gt; docker pull intel/oneapi-basekit:devel-ubuntu20.04</span></pre><p id="c1b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这会将容器下载到我的本地系统。要进入开发环境，您可以使用以下命令运行容器:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="7151" class="nn kx iq nj b gy no np l nq nr">&gt; docker run -ti --name=ubuntu-dev-20.04 intel/oneapi-basekit:devel-ubuntu20.04</span></pre><p id="6efa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ns nt nu nj b">-ti</code>标志告诉Docker，一旦它启动并运行，就在容器中为我提供一个交互终端。name标志将我们的运行容器命名为ubuntu-dev-20.04。</p><h1 id="e7eb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">构建一些代码</strong></h1><p id="da1a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了使事情简单一点，我将利用oneAPI示例。我去了oneAPI示例Github:</p><div class="nv nw gp gr nx ny"><a href="https://github.com/oneapi-src/oneAPI-samples" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub-oneapi-src/oneAPI-Samples:英特尔oneAPI工具包示例</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">oneAPI样本库为英特尔oneAPI工具包提供代码样本。我们建议查看特定的…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><p id="afcc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">…并在我的开发容器中克隆了repo。我将使用位于<code class="fe ns nt nu nj b">DirectProgramming-&gt;DPC++-&gt;N-BodyMethods-&gt;Nbody</code>文件夹中的<code class="fe ns nt nu nj b">Nbody</code>样本。</p><p id="f33e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用开发容器的好处是我不必运行</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="ae41" class="nn kx iq nj b gy no np l nq nr">&gt; source /opt/intel/oneapi/setvars.sh</span></pre><p id="fde4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我在上一个例子中所做的那样，因为oneAPI开发容器在构建时已经运行了这个命令。我只需转到<code class="fe ns nt nu nj b">Nbody</code>文件夹，按照说明构建并运行<code class="fe ns nt nu nj b">Nbody</code>示例:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="d6c6" class="nn kx iq nj b gy no np l nq nr">&gt; mkdir build<br/>&gt; cd build<br/>&gt; cmake ..<br/>&gt; make<br/>&gt; make run</span></pre><p id="1fb1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以下是我的英特尔i9阿尔德湖外星人R13系统的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/58ef29a976ff753e89fbae2ec2047d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uYcMjgs4hMAc3upPvrtaHQ.png"/></div></div></figure><h1 id="f3c1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">创建生产容器</strong></h1><p id="c187" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们知道我们的代码是在开发容器中构建的，让我们看看如何将它放在容器中交付给客户，让他们在自己的系统上运行。</p><p id="6faa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Docker将使用<a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"> Dockerfile </a>格式构建一个新容器。对于那些不熟悉如何使用Docker文件的人，请查看Docker的<a class="ae kv" href="https://docs.docker.com/compose/gettingstarted/" rel="noopener ugc nofollow" target="_blank">入门</a>指南。</p><p id="6632" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我将利用Docker <a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>功能告诉Docker构建过程在一个容器中构建我的代码，然后将其复制到另一个容器中。这允许我在一个地方拥有整个构建和打包工作流，同时还允许我在没有所有开发工具的情况下发布一个容器。这是我的生产容器Dockerfile文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="8248" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您将看到，对于生产容器，我使用了<code class="fe ns nt nu nj b">intel/oneapi-runtime:latest</code>容器作为基础，因为它提供了运行任何基于oneAPI的工作负载所需的所有运行时。</p><p id="13b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一步是获取这个Dockerfile，我将其命名为<code class="fe ns nt nu nj b">Dockerfile.runtime</code>，并运行docker build命令来创建我的新容器。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="2cfd" class="nn kx iq nj b gy no np l nq nr">&gt; docker build . -f Dockerfile.runtime -t tonymintel/nbody:runtime</span></pre><p id="3a77" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个命令告诉Docker使用当前路径构建我的<code class="fe ns nt nu nj b">Dockerfile.runtime</code>文件，并将图像标记为<code class="fe ns nt nu nj b">tonym/nbody:runtime</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/9e037c36860a9e7aba9a3f7c4bb5ff21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJKkPfw-_SPdP7Anc1j7-A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个成功的docker构建！耶！</p></figure><p id="0877" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">容器的快速运行显示，我们的构建成功完成，并按照我们的要求用完了代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/cf9ec94901c57dbab66890c03a0e989b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*woFV5pDfkPcd1voFX_Qjgw.png"/></div></div></figure><p id="6009" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我只需要包装好我的集装箱，并将其运送给我的客户。我可以将它上传到Docker Hub，或者使用docker save命令将图像保存在我的本地系统上并发送文件。</p><p id="398c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">就我而言，我只是将它推送到Docker Hub:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="b175" class="nn kx iq nj b gy no np l nq nr">&gt; docker push tonymintel/nbody:runtime</span></pre><p id="0aa9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这会将图像推送到我的<code class="fe ns nt nu nj b">tonymintel</code> Docker Hub帐户，并使用标签runtime将其保存到<code class="fe ns nt nu nj b">nbody</code>存储库中。现在，任何能够访问<code class="fe ns nt nu nj b">tonymintel/nbody</code> Docker Hub库的人都可以通过常规的Docker命令获取并运行代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/ed15cd458a9abe0ff32a732a0fc745c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ER2GD0ERtT25pxFjqWk-dA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Docker Hub上标记的nbody repo</p></figure><h1 id="1489" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">将我的生产容器缩小了4倍</h1><p id="10cb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如高效的开发人员对我来说很重要一样，拥有高效的解决方案对我们应用程序的用户来说也很重要。正如我的同事詹姆斯·莱因德斯所说，我们需要确保带给他们“跳出盒子的快乐”。</p><p id="c4ce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从我的截图，你可以看到我上传的容器是1.32GB。这是一个非常大的Docker容器，供我的客户下载。</p><p id="9b76" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的生产容器基于intel/oneapi-runtime容器，它为构建oneapi代码的所有工具包提供了所有运行时。这不一定是件坏事。oneAPI提供了各种我可能想要与我的代码集成的库，所以拥有一个我知道会运行我的代码的运行时包是很棒的。然而，因为我是开发人员，我知道我使用了什么库，所以让我们看看是否可以优化我们的生产容器，使它变得更小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/bc6330a25f4a494b46aa2822bb981e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWjpDiHQKCE-eav2y-pjkg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">英特尔/oneapi-运行时:截至2022年6月的最新Docker Hub文件</p></figure><p id="a495" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">经过一番检查后，我创建了一个新的Dockerfile.prod，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="99cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这里有很多文本，所以让我试着解释一下发生了什么:</p><ol class=""><li id="781c" class="os ot iq lq b lr mk lu ml lx ou mb ov mf ow mj ox oy oz pa bi translated">第1–9行和第32–34行在两个docker文件中是相同的。他们构建我们的二进制文件，并在容器启动时运行它</li><li id="c8d6" class="os ot iq lq b lr pb lu pc lx pd mb pe mf pf mj ox oy oz pa bi translated">第11–30行主要是样板代码，用于设置英特尔的apt库，然后通过APT安装一些英特尔包。这些行摘自<code class="fe ns nt nu nj b">oneapi-runtime</code>docker文件，可在此处找到:</li></ol><div class="nv nw gp gr nx ny"><a href="https://github.com/intel/oneapi-containers" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">GitHub -英特尔/oneapi-容器</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">英特尔oneAPI产品将提供跨标量、矢量部署应用和解决方案所需的工具</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">github.com</p></div></div><div class="oh l"><div class="pg l oj ok ol oh om kp ny"/></div></div></a></div><p id="553a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的<code class="fe ns nt nu nj b">Dockerfile.prod</code>中的关键线路是28线。如果你去看原始的<code class="fe ns nt nu nj b">intel/oneapi-runtime</code> Dockerfile ( <a class="ae kv" href="https://hub.docker.com/r/intel/oneapi-runtime/tags" rel="noopener ugc nofollow" target="_blank">点击这里</a>并点击一个摘要SHA并找到最大的图像层)，它为所有可能的运行时包做了一个apt-get。在我的例子中，我知道我只使用了DPC++，所以我的<code class="fe ns nt nu nj b">Dockerfile.prod</code>只包含那个<code class="fe ns nt nu nj b">intel-oneapi-runtime-dpcpp-cpp</code>包。</p><p id="a4c9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我只需构建我的新Dockerfile，验证它像以前一样工作，并将其推送到云中。</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0b14" class="nn kx iq nj b gy no np l nq nr">&gt; docker build . -f Dockerfile.prod -t tonymintel/nbody:production<br/>&gt; docker run -it tonymintel/nbody:production<br/>&gt; docker push tonymintel/nbody:production</span></pre><p id="d002" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我看到我的客户的下载量提高了约4倍……希望有更多的惊喜。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/4d98b363f05ba07f90c07e52612591ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NaAUQMgWYJkrb9tFhuJ8Zg.png"/></div></div></figure><p id="e059" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可能会问，我还能做得更好吗？为了避免悬念，答案是肯定的，但是它涉及到进入并提取单个文件以省略各种未使用的运行时组件。这有点麻烦，但这是可能的。如果你好奇的话，它最终使这个包大约250MB，性能提高了5倍。</p><p id="6562" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我认为这是一个巨大的胜利，因为它可以真正影响您客户的体验。显然，如果您的客户需要通过标准的互联网连接下载容器，这是一个巨大的成功。在像数据中心或云环境这样的大规模环境中，这可能更有价值，因为在数十或数百个节点上部署相同的pod非常常见，并且网络使用、饱和和延迟始终是一个问题。也许最重要的是，如果您的客户为部署他们的容器支付网络或存储费用，他们会感谢您(或至少不会抱怨)让他们花费更多的容器。:)</p><h1 id="5855" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">结论</strong></h1><p id="68bf" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">作为开发人员，容器是帮助我们构建和测试代码的有用技术。根据我们的客户(也就是他们是否会使用容器)，它还可以真正帮助我们向客户交付更可靠的代码。</p><p id="3425" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">学习所有的技术肯定需要做一些工作，但在很多情况下这绝对是值得的。我希望这有助于您了解如何利用容器以及如何为您的客户优化这些容器。</p><p id="a5a8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下次见！</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="85be" class="nn kx iq nj b gy no np l nq nr"><strong class="nj ir">Want to Connect?</strong></span><span id="2c88" class="nn kx iq nj b gy ph np l nq nr">If you want to see what random tech news I’m reading, you can <a class="ae kv" href="https://twitter.com/tonymongkolsmai" rel="noopener ugc nofollow" target="_blank">follow me</a> on Twitter.</span><span id="f66a" class="nn kx iq nj b gy ph np l nq nr">Tony is a Software Architect and Technical Evangelist at Intel. He has worked on several software developer tools and most recently led the software engineering team that built the data center platform which enabled Habana’s scalable MLPerf solution.</span><span id="a450" class="nn kx iq nj b gy ph np l nq nr">Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.</span></pre></div></div>    
</body>
</html>