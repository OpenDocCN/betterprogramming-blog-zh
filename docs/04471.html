<html>
<head>
<title>3 Ways to React to @State Changes in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI中对@State变化做出反应的3种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/three-ways-to-react-to-state-changes-in-swiftui-a30545c72361?source=collection_archive---------5-----------------------#2020-04-15">https://betterprogramming.pub/three-ways-to-react-to-state-changes-in-swiftui-a30545c72361?source=collection_archive---------5-----------------------#2020-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fd41" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们已经没有了。现在怎么办？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e609133d4b13571bcfda893d560e911f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HphHM8MhMBBQh9NGp8Ev4Q.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者照片。</p></figure><p id="3985" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我如何学会在SwiftUI控件中实现一个等效的<code class="fe lr ls lt lu b">onChange</code>来更新其他的<code class="fe lr ls lt lu b">@State</code>变量。</p><p id="ff9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SwiftUI发布将近一年后，我决定尝试一下。我开始动手实现基本的UI控件(如<code class="fe lr ls lt lu b">Slider</code>或<code class="fe lr ls lt lu b">TextField</code>)并学习如何操作视图状态。</p><p id="0dd4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我很快面临根据另一个<code class="fe lr ls lt lu b">@State</code>变量的变化更新一个<code class="fe lr ls lt lu b">@State</code>变量的挑战。</p><p id="af71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">是的，我们知道的属性观察器(如<code class="fe lr ls lt lu b">didSet</code>或<code class="fe lr ls lt lu b">willSet</code>)在<code class="fe lr ls lt lu b">@State</code>变量中不起作用。</p><p id="92bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">经过一些研究(花费的时间比我预期的要长)，我学会了三种方法:</p><ol class=""><li id="1a0e" class="lv lw iq kx b ky kz lb lc le lx li ly lm lz lq ma mb mc md bi translated">UI控件的具体回调:<code class="fe lr ls lt lu b">onEditingChanged</code>。</li><li id="6832" class="lv lw iq kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">绑定变量。</li><li id="07ba" class="lv lw iq kx b ky me lb mf le mg li mh lm mi lq ma mb mc md bi translated">利用<code class="fe lr ls lt lu b"><a class="ae mj" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">Combine</a></code>框架。</li></ol><p id="1d62" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面，我将描述一个具体的简单用例:检查一个<code class="fe lr ls lt lu b">TextField</code>值是否匹配一个预定义的字，并通过切换开关开/关来显示(该控件称为<code class="fe lr ls lt lu b">Toggle</code>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c62fdf9b71bcf7b660277cffdd4d5fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/0*vdNamNH1tSyp8s4U"/></div></figure><p id="dd1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">UI框架代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="ae28" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">onEditingChanged</h1><p id="ec61" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">根据Apple的开发者文档，这个回调在三个控件的inits上可用:<code class="fe lr ls lt lu b">TextField</code>、<code class="fe lr ls lt lu b">Slider</code>和<code class="fe lr ls lt lu b">Stepper</code>。</p><pre class="kg kh ki kj gt nr lu ns nt aw nu bi"><span id="22ea" class="nv mv iq lu b gy nw nx l ny nz">TextField:<br/>init(_:text:onEditingChanged:onCommit:)</span><span id="93df" class="nv mv iq lu b gy oa nx l ny nz">Slider:<br/>init(value:in:onEditingChanged:)</span><span id="e7c2" class="nv mv iq lu b gy oa nx l ny nz">Stepper:<br/>init(_:onIncrement:onDecrement:onEditingChanged:)</span></pre><p id="8901" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在这里可以做的是用这个参数增强<code class="fe lr ls lt lu b">TextField</code>的初始化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f4da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法的一个可能的缺点是用户按下键盘的<code class="fe lr ls lt lu b">return</code>键后会调用<code class="fe lr ls lt lu b">onEditingChanged</code>。</p><p id="98f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但如果你不希望这种情况实时发生，这是一个可行的解决方案。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="8d2c" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">绑定变量</h1><p id="3443" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated"><code class="fe lr ls lt lu b">Binding</code>是一个属性包装器类型，它可以读写一个真实源所拥有的值。</p><p id="04bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该引用使视图能够编辑依赖于该数据的任何视图的状态。</p><p id="4424" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用它来模仿UIKit方法中的属性观察者(getter/setter):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="80de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不得不说，我并不特别喜欢这种方法，因为在呈现部分声明绑定和业务看起来并不干净。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="8c50" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">组合框架</h1><p id="98d4" class="pw-post-body-paragraph kv kw iq kx b ky nm jr la lb nn ju ld le no lg lh li np lk ll lm nq lo lp lq ij bi translated">通过组合事件处理操作符，使用<code class="fe lr ls lt lu b">Combine</code>框架定制异步事件的处理——在我们的例子中，是监听状态变化事件。</p><p id="3cf3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Combine的词汇表中，我们有:</p><ul class=""><li id="3480" class="lv lw iq kx b ky kz lb lc le lx li ly lm lz lq ob mb mc md bi translated"><code class="fe lr ls lt lu b">ObservableObject</code> —一种带有发布者的对象类型，在对象更改前发出。</li><li id="c350" class="lv lw iq kx b ky me lb mf le mg li mh lm mi lq ob mb mc md bi translated"><code class="fe lr ls lt lu b">ObservedObject</code> —声明对符合<code class="fe lr ls lt lu b">ObservableObject</code>协议的引用类型的依赖。它是一个属性包装器类型，订阅一个可观察对象，并在可观察对象改变时使视图无效。</li><li id="3be2" class="lv lw iq kx b ky me lb mf le mg li mh lm mi lq ob mb mc md bi translated"><code class="fe lr ls lt lu b">Published</code> —发布用属性标记的属性的类型。</li></ul><p id="2ddb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法通过从视图中提取业务逻辑，迫使我们(以一种好的方式)拥有一个更清晰的代码。</p><p id="550a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建视图模型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="af3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在所需视图中使用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5b6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我不知道你怎么想，但我不得不说我更喜欢第三种选择，因为我对数据流有更多的控制，代码更容易维护。我需要在真实世界的用例中使用它。</p></div></div>    
</body>
</html>