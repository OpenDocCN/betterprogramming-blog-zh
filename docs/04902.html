<html>
<head>
<title>How to Merge Adapters Sequentially in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中顺序合并适配器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-merge-adapters-sequentially-in-android-11914eac53d?source=collection_archive---------7-----------------------#2020-05-20">https://betterprogramming.pub/how-to-merge-adapters-sequentially-in-android-11914eac53d?source=collection_archive---------7-----------------------#2020-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5601" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为Android开发人员推出全新的MergeAdapter</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e4021aaccfab9889c900c52aaad1af7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3F-VgjabIL3IAbj0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@azhar93?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿兹哈鲁尔·伊斯拉姆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="0d4a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="504e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>是在<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/jetpack/androidx/releases/recyclerview" rel="noopener ugc nofollow" target="_blank">recyclerview:1.2.0-alpha02</a></code>中引入的新功能，使我们能够依次连接多个适配器。这提供了更多的封装和可重用性，而不是将几个数据源合并到同一个适配器中。在本文中，您将学习如何使用<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>和其他一些有用的东西，比如如何跨适配器有效地使用视图池。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="b66b" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">综合</h1><p id="8a1e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Android团队现在已经发布了<code class="fe mn mo mp mq b">recyclerview</code>的新版本。要使用<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>，请将<code class="fe mn mo mp mq b">recyclerview</code>库版本更新为<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/jetpack/androidx/releases/recyclerview" rel="noopener ugc nofollow" target="_blank">1.2.0-alpha02</a></code>,或者在应用内级别<code class="fe mn mo mp mq b">build.gradle</code>文件的依赖标签下包含以下行:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="5482" class="nh la it mq b gy ni nj l nk nl">dependencies <strong class="mq iu">{<br/>   </strong>implementation 'androidx.recyclerview:recyclerview:<strong class="mq iu">1.2.0-alpha02</strong>'<br/><strong class="mq iu">}</strong></span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="d16c" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">使用MergeAdapter</h1><p id="cdb6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们看一个基本的用例。我们需要显示一个标题布局，然后是一个主题列表，以及一个显示加载或错误的页脚。我们有三种不同的适配器，每种类型一个——<code class="fe mn mo mp mq b">HeaderAdapter</code>、<code class="fe mn mo mp mq b">TopicAdapter</code>和<code class="fe mn mo mp mq b">FooterAdapter</code>。</p><p id="ea8c" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">我们希望使用merge-adapter构造函数合并这三个适配器，并将结果<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>实例设置为<code class="fe mn mo mp mq b">recyclerview</code>。第一步是合并三个适配器，如下所示:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="bbe4" class="nh la it mq b gy ni nj l nk nl">val <!-- -->headerAdapter<!-- -->: <!-- -->HeaderAdapter<!-- -->= …<br/>val <!-- -->topicAdapter<!-- -->: <!-- -->TopicAdapter<!-- -->= …<br/>val <!-- -->footerAdapter<!-- -->: <!-- -->FooterAdapter<!-- -->= …</span><span id="34f9" class="nh la it mq b gy nr nj l nk nl">val mergeAdapter = <strong class="mq iu">MergeAdapter</strong>(<!-- -->headerAdapter<!-- -->, <!-- -->topicAdapter<!-- -->, <br/>     <!-- -->footerAdapter<!-- -->)</span></pre><p id="c424" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated"><code class="fe mn mo mp mq b">recyclerview</code>中的视图将根据<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>构造函数中适配器的顺序进行渲染。之后，像往常一样，我们需要调用<code class="fe mn mo mp mq b">setAdapter </code>并传递<code class="fe mn mo mp mq b">mergeAdapter`</code>实例，如下所示:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="6249" class="nh la it mq b gy ni nj l nk nl">recyclerView.adapter = <strong class="mq iu">mergeAdapter</strong></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/a8290e6c9021ced2fbcbf07e5881d666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nbYNmKcRMl5yaajjI19NEg.png"/></div></div></figure><p id="ab4f" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">这样，我们实现了关注点的分离:</p><ul class=""><li id="16e5" class="nt nu it lt b lu nm lx nn ma nv me nw mi nx mm ny nz oa ob bi translated">为了显示加载或错误情况，现在我们可以在<code class="fe mn mo mp mq b">FooterAdapter</code>中进行</li><li id="3ea6" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated">如果我们在主题中有不同的视图类型，那么我们可以在<code class="fe mn mo mp mq b">TopicAdapter</code>中单独完成。</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="9bac" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">探索MergeAdapter</h1><h2 id="42ba" class="nh la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter.Config" rel="noopener ugc nofollow" target="_blank">合并适配器。配置</a></h2><p id="c5df" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">默认情况下，每个适配器都使用自己的<code class="fe mn mo mp mq b">viewHolder</code>池。如果您有相同的布局需要跨不同的适配器使用，您必须使用<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter.Config" rel="noopener ugc nofollow" target="_blank">MergeAdapter.Config</a></code>。我们可以将合并适配器配置为三种不同的类型:</p><ul class=""><li id="0cf8" class="nt nu it lt b lu nm lx nn ma nv me nw mi nx mm ny nz oa ob bi translated"><code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter.Config.StableIdMode#NO_STABLE_IDS" rel="noopener ugc nofollow" target="_blank">MergeAdapter.Config.StableIdMode.NO_STABLE_IDS</a></code> —这是默认模式。每个适配器都有自己的<code class="fe mn mo mp mq b">viewholder</code>池，并忽略来自子适配器的稳定id。</li><li id="2634" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated"><code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter.Config.StableIdMode#ISOLATED_STABLE_IDS" rel="noopener ugc nofollow" target="_blank">MergeAdapter.Config.StableIdMode.ISOLATED_STABLE_IDS</a></code> —在这种模式下，<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a> </code>从子适配器收集所有ID，因为两个不同的<code class="fe mn mo mp mq b">viewHolder</code>可能会返回相同的ID，因为它们彼此不知道对方。然后<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>将隔离每个<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter" rel="noopener ugc nofollow" target="_blank">RecyclerView.Adapter</a></code>的ID池，使其在向<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView" rel="noopener ugc nofollow" target="_blank">RecyclerView</a></code>报告之前覆盖报告的稳定ID。</li><li id="c07c" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated"><code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter.Config.StableIdMode#SHARED_STABLE_IDS" rel="noopener ugc nofollow" target="_blank">MergeAdapter.Config.StableIdMode.SHARED_STABLE_IDS</a></code> —在这种模式下，<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>不会将每个适配器的池相互隔离，也不会像上一种情况那样覆盖ID。</li></ul><h2 id="d9f2" class="nh la it bd lb oh oi dn lf oj ok dp lj ma ol om ll me on oo ln mi op oq lp or bi translated">更新数据和视图持有者</h2><p id="9d59" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我会推荐使用<code class="fe mn mo mp mq b">ListAdapter</code>，它代替一般的<code class="fe mn mo mp mq b">recyclerview.adapter</code>为你处理数据变化。接下来的事情是<code class="fe mn mo mp mq b">viewholder</code>。为了获得<code class="fe mn mo mp mq b">recyclerview</code>中的适配器位置，我们使用<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder#getAdapterPosition%28%29" rel="noopener ugc nofollow" target="_blank">ViewHolder.getAdapterPosition</a></code>，但是当你通过<code class="fe mn mo mp mq b">Merge</code>适配器操作时，你需要使用<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.ViewHolder#getBindingAdapter%28%29" rel="noopener ugc nofollow" target="_blank">ViewHolder.getBindingAdapter()</a></code>。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="3d04" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">结论</h1><p id="f5cf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">由于它仍处于开发的早期阶段，我不建议您在产品代码中使用这个特性。未来可能会有变化，或者在即将到来的版本中可能会删除一些功能。</p><p id="a2ea" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">我还推荐使用<code class="fe mn mo mp mq b">Recyclerview.Adapter</code>的视图类型特性在<code class="fe mn mo mp mq b">recyclerview</code>中显示不同的视图。仅当<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>受益于封装时才使用它。<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/MergeAdapter" rel="noopener ugc nofollow" target="_blank">MergeAdapter</a></code>不是显示不同视图类型的解决方案；这是一种在膨胀不同视图类型的同时提供封装的方式。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="8093" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">奖金</h1><p id="95cf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要了解Android中适配器的更多信息，请阅读以下文章:</p><ul class=""><li id="266b" class="nt nu it lt b lu nm lx nn ma nv me nw mi nx mm ny nz oa ob bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/building-a-reactive-heterogeneous-adapter-in-kotlin-eed9487df29b" rel="noopener">“在Kotlin中构建反应式&amp;异构适配器”</a></li><li id="61b9" class="nt nu it lt b lu oc lx od ma oe me of mi og mm ny nz oa ob bi translated"><a class="ae ky" href="https://medium.com/better-programming/evolution-of-adapters-in-android-2e2ff58c0f98" rel="noopener">“Android中适配器的演变”</a></li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="cbbc" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>