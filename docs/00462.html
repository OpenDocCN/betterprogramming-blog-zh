<html>
<head>
<title>JavaScript: A Review of Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:函数综述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-a-review-of-functions-37ed492eab45?source=collection_archive---------4-----------------------#2019-05-25">https://betterprogramming.pub/javascript-a-review-of-functions-37ed492eab45?source=collection_archive---------4-----------------------#2019-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f795" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单明了的JavaScript基本函数、函数表达式、匿名函数、函数表达式等指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/191841d4c568f7eb281c0bf1dff3b227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mAKf1wYsgvIMq8MEp2eGFw.png"/></div></div></figure><p id="f7c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在深入研究JavaScript函数更微妙的形式时，我发现自己在没有完全理解它们的情况下使用了各种语法结构。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">一个匿名的<em class="lt">立即调用的函数表达式</em>(life)。</p></figure><p id="ac35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当看到上面这段完全有效但有些神秘的代码时，我的主要问题是，“为什么有这么多括号？”在通过实验和研究回答这个问题的过程中，出现了其他更基本的问题，这些问题反过来需要回顾JavaScript中函数的一些基本概念。这篇文章描述并探索了:</p><ul class=""><li id="07c8" class="lu lv iq kt b ku kv kx ky la lw le lx li ly lm lz ma mb mc bi translated"><a class="ae md" href="#ac25" rel="noopener ugc nofollow">基本功能</a></li><li id="8bba" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="#108d" rel="noopener ugc nofollow">函数表达式</a></li><li id="6200" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="#b479" rel="noopener ugc nofollow">匿名函数</a></li><li id="1910" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="#38ab" rel="noopener ugc nofollow">箭头功能</a></li><li id="b7c1" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="#0514" rel="noopener ugc nofollow">工厂职能</a></li><li id="128f" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="#9bf2" rel="noopener ugc nofollow">立即调用函数表达式(IIFEs基础知识</a></li><li id="5b1c" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated"><a class="ae md" href="#ff0d" rel="noopener ugc nofollow">iife的品种</a></li><li id="c407" class="lu lv iq kt b ku me kx mf la mg le mh li mi lm lz ma mb mc bi translated">野生动物的生活</li></ul><h1 id="ac25" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated"><strong class="ak">基本功能</strong></h1><p id="d23d" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">JavaScript的任何中级用户都熟悉函数的基本结构和用法。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">// -&gt; '表示控制台输出</p></figure><p id="1e2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">声明了一个名为<code class="fe ng nh ni nj b">add</code>的函数，它接受参数<code class="fe ng nh ni nj b">x</code>和<code class="fe ng nh ni nj b">y</code>的两个值，并返回这两个值的和。然后声明一个名为<code class="fe ng nh ni nj b">mySum</code>的变量，它的值被设置为调用函数时返回的值，并将整数值<code class="fe ng nh ni nj b">4</code>和<code class="fe ng nh ni nj b">5</code>作为参数传递给函数。最后，<code class="fe ng nh ni nj b">mySum</code>的值输出到控制台:<code class="fe ng nh ni nj b">9</code>。</p><p id="74a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是基本的东西。然而，在这个结构中可以发现一些微妙之处。让我们考虑这个更简单的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="fa84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们在这个函数中不使用参数，所以使用的空括号<code class="fe ng nh ni nj b">()</code>是<em class="nk">而不是可选的</em>(就像在其他一些语言中一样)。</p><p id="5ed2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">函数本身没有包含<code class="fe ng nh ni nj b">()</code>将会抛出错误:“语法错误:意外标记{ …”</p><p id="c70d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，在函数调用中没有包含<code class="fe ng nh ni nj b">()</code>将只是无声地失败，或者更准确地说，它看起来什么也不做。这是我们对基本函数声明的隐藏性质的第一个线索。请注意，这种行为与在代码中简单地包含一个未定义的名称形成了鲜明的对比:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="5ce0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们定义一个函数，命名为<code class="fe ng nh ni nj b">basicFunc</code>。更准确地说，我们创建了一个名为<code class="fe ng nh ni nj b">basicFunc</code>的变量<em class="nk">，并将其值设置为我们定义的函数。通过将我们的“函数名”指向一个新值，我们可以看到这种情况:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">将函数重新定义为字符串！</p></figure><p id="935b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们设置新值，而不需要用<code class="fe ng nh ni nj b">let</code>、<code class="fe ng nh ni nj b">var</code>或<code class="fe ng nh ni nj b">const</code>声明变量——事实上，这将抛出一个错误，因为当我们定义函数时，这个初始声明已经在“幕后”发生了。在我们将标识符指向一个字符串之后，对函数的调用就会失败，因为名字不再指向一个函数。</p><h1 id="108d" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">函数表达式</h1><p id="d16a" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">事实上，我们的基本函数声明和用法相当于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="a72c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们声明了一个名为<code class="fe ng nh ni nj b">funcExp</code>的变量，并将其值显式设置为一个<strong class="kt ir"> <em class="nk">匿名函数</em> </strong>。这是一个<strong class="kt ir"> <em class="nk">函数表达式</em> </strong>的形式。它的行为与我们以前的、不太明确的版本完全一样，包括声明变量的值可以被改变的事实。因此，我们的早期版本也是命名一个变量，然后“指向”一个匿名函数(即使它没有被写成这样的表达式)。</p><p id="db17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你写你自己的代码时，如果你清楚你所使用的名字，偶然“覆盖”一个函数的可能性看起来可以忽略不计。然而，当合并来自其他来源(库、模块等)的代码时。)或者试图理解或重构他人的工作，这样的问题可能很重要。</p><p id="68cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，我们可以通过用<code class="fe ng nh ni nj b">const</code> ( <em class="nk">而不是</em> <code class="fe ng nh ni nj b">let</code>或<code class="fe ng nh ni nj b">var</code>)声明函数来防止函数的重定义。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div><p class="lp lq gj gh gi lr ls bd b be z dk translated">使用“const”函数表达式可以防止重定义。</p></figure><p id="bdbf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们的函数将始终是我们第一次声明它的函数，任何重新定义或修改它的尝试，无论是偶然的还是其他的，都将抛出一个错误。</p><p id="3cd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我原以为这种语法只是一种更老的、但实际上等效的函数声明形式，但这种略显冗长的形式支持更好的控制，并为我们代码的读者提供更多信息。</p><h1 id="b479" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">匿名函数</h1><p id="2724" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">如上所述，函数表达式(见上文)将匿名函数与命名变量相关联。事实上，<em class="nk">除了这里考虑的函数的第一个基本形式之外的所有</em>形式的函数(见上面的<a class="ae md" href="#ac25" rel="noopener ugc nofollow">基本函数</a>)，都明确涉及到一个匿名函数形式。</p><p id="74ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些评论家会争辩说，匿名函数的这种使用使得跟踪行号和/或函数名的错误变得困难或不可能。这似乎夸大了完全匿名函数的潜在错误报告困难，更重要的是，这种函数的使用与在命名函数(与标识符相关的函数)中使用<em class="nk">形式的</em>匿名函数混为一谈。为了证明这一点，让我们看看三种不同形式的函数，每一种都包含相同的错误，记录它们的类型，并比较堆栈跟踪(<strong class="kt ir">剧透:</strong>它们是相同的):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="619c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以上三种形式的错误的堆栈跟踪实际上是相同的，包括对错误的确切点的引用(包括行号)和对函数“name”的引用。</p><p id="2342" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，尽管在第二和第三个例子中使用了匿名函数的<em class="nk">形式</em>,但在所有情况下结果类型都是一个命名函数。因此，我们看不出解释器追踪错误和命名包含错误的函数的能力有什么不同。</p><p id="34a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在某些情况下(见下面的“各种类型的函数”),函数表达式从未被赋予标识符(没有任何意义上的命名),因此总体上仍然是一个真正的匿名函数。显然，在这种情况下，我们的堆栈跟踪永远不会引用函数的“名称”，但我仍然不知道在这种构造中跟踪错误有什么困难——如果您知道任何这类问题，请在评论中告诉我。</p><h1 id="38ab" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">箭头功能</h1><p id="7c24" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">第三种包含错误的函数形式(如上)是一个<strong class="kt ir"> <em class="nk">箭头函数</em> </strong>。如果我们将基本函数重新创建为箭头函数，我们会得到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="7aa3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这种结构有两个主要的潜在好处:</p><p id="6554" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1:较短的语法</strong></p><p id="a1d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过省略<code class="fe ng nh ni nj b">function</code>关键字，我们减少了总的字符数(但可能会在某种程度上降低代码的透明度)。在特殊情况下，我们可以进一步减少字符数，例如，当只使用一个参数时，我们可以完全省略括号:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="b186" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">精明的人会注意到这个例子也省略了花括号。如果函数只包含一个表达式，表示要返回的值(或者只执行一条语句)，花括号也是可选的。</p><p id="d970" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2:没有绑定“this”关键字</strong></p><blockquote class="nl nm nn"><p id="5fc9" class="kr ks nk kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">箭头函数从父作用域继承它们的作用域，这被称为“词法作用域”虽然在使用箭头函数时保证了词法作用域(因此关键字<code class="fe ng nh ni nj b">this</code>的值将总是从定义它的父作用域中导出)，但是其他形式的函数具有依赖于它们的<strong class="kt ir">执行上下文的作用域，</strong>因此它们的值<code class="fe ng nh ni nj b">this</code>也根据执行上下文而变化。</p></blockquote><p id="b94d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果前一段读起来像一个单词沙拉，这可能表明需要更好地理解JavaScript中的作用域概念(试试克里斯蒂安·萨尔塞斯库的这篇文章)和/或合理地掌握稍微复杂一些的<code class="fe ng nh ni nj b">this</code>关键词(我推荐布兰登·莫雷利的这篇文章)。</p><p id="2c8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时候，代码比散文说得更清楚。以下示例(在浏览器控制台中运行)演示了arrow函数的词法范围，而不是其他函数形式的上下文范围:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="9eb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面，箭头函数是在全局(窗口)范围内定义的。这个函数的<code class="fe ng nh ni nj b">this</code>值是<code class="fe ng nh ni nj b">window</code>,不管它是从全局范围还是从一个对象内部被调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="4921" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相比之下，上面的例子是<em class="nk">不是</em>一个箭头函数，当从对象内部调用它时<code class="fe ng nh ni nj b">this</code>的值不再是<code class="fe ng nh ni nj b">window</code>(因为它是在对象的范围内执行的)。</p><p id="b495" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于箭头函数的词法作用域的一个实用示例，请参见下一节:“工厂函数”</p><p id="be72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用箭头函数有两个主要的潜在缺点:</p><p id="f95d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 1:更不透明的语法:</strong></p><p id="54db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就个人而言，我喜欢arrow函数更稀疏的语法。一旦学会了，在现实世界的代码库中解析它通常是容易的。然而，<code class="fe ng nh ni nj b">function</code>关键字的省略不可否认对初学者不太友好。</p><p id="0030" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，当与其他稀疏形式结合时(例如，一些立即调用函数表达式的形式，如本文的介绍和下面的<a class="ae md" href="#ff0d" rel="noopener ugc nofollow">相应章节</a>中所介绍的)，这种简洁的结构对于外行来说可能会变得晦涩难懂。</p><p id="b3d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> 2。词法范围阻止手动绑定范围:</strong></p><p id="47ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如上所述，要完全理解作用域、它的绑定以及对关键字<code class="fe ng nh ni nj b">this</code>的值产生的影响，需要付出一些努力(我仍在努力)。我推荐Dario Garcia Moya的这篇文章，它很好地介绍了与箭头函数相关的问题。</p><p id="8635" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，如果你的代码使用了<code class="fe ng nh ni nj b">call</code>、<code class="fe ng nh ni nj b">apply</code>或<code class="fe ng nh ni nj b">bind</code>来指定某个动作的范围，那么避免在代码的上下文中使用箭头函数。如果您没有使用这些方法来绑定特定的作用域(如果您还不明白这是什么意思，您可能就不会这样做)，那么您可以考虑使用箭头函数了——很可能。我仍然模棱两可，因为警告(更多的将在下一节揭示)可能看起来相对微妙。</p><h1 id="0514" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">工厂功能:</h1><blockquote class="nl nm nn"><p id="c33f" class="kr ks nk kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">“<strong class="kt ir">工厂函数</strong>是任何不是返回(假定是新的)对象的类或构造函数的函数。在JavaScript中，任何函数都可以返回一个对象。如果没有<code class="fe ng nh ni nj b">new</code>关键字，它就是一个工厂函数。”(Eric Elliot，<a class="ae md" href="https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1" rel="noopener">使用ES6+ </a>的JavaScript工厂功能)</p></blockquote><p id="f947" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae md" href="#38ab" rel="noopener ugc nofollow">前一节</a>中描述的arrow函数的词法作用域，使它们在许多情况下非常有用，提供了一种更简单、更简洁的方法来创建对象实例。让我们首先回顾一下用于创建对象实例的<em class="nk">构造器模式</em>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="df72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意这与工厂函数方法的对比:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="9415" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">arrow函数的词法作用域消除了重复使用<code class="fe ng nh ni nj b">this</code>关键字的需要，因此大大简化了结构。还要注意，实例化新实例不需要关键字<code class="fe ng nh ni nj b">new</code>。</p><p id="1975" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管在上面两个有限的例子中行为是相同的，但是形式并不是在所有方面都是等价的。一个主要的区别是，工厂函数产生单例对象，而构造函数模式将从对象原型继承(在对象原型中可以定义各种属性和方法)。</p><p id="9ec9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">选择使用一种模式可能很复杂，并且/或者是基于风格/品味/与总体模式的最佳匹配。有时选择可能很简单；例如，如果由工厂函数产生的(单例)对象实例的数量变得足够大，以至于它将显著影响内存使用，那么构造器模式可以通过将对象实例的一部分功能移动到对象原型来实现内存使用的显著减少。相反，如果对象的功能彼此差异很大，就不可能简单地将这些功能转移到原型中。此外，在有些情况下，使用单例来确保不变性和/或避免实例化多个这样的对象。</p><p id="da48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我知道这是一个我还没有资格详细阐述的领域，因此，我将建议进一步阅读，既是为了我自己，也是为了你，读者。我们最好从仔细阅读本节开头引用的Eric Elliot的文章开始，然后继续阅读Chris Ferdinandi的JavaScript构造器模式介绍。</p><h1 id="9bf2" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">立即调用的函数表达式:基础</h1><p id="0c33" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">现在让我们来看看在运行时一遇到就执行的函数— <strong class="kt ir"> <em class="nk">立即调用的函数表达式</em> </strong> (IIFEs) —也称为“iffys”。这是一个非常简单的匿名生活的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="e767" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没有单独的语句来调用该函数，因为final <code class="fe ng nh ni nj b">()</code>会这样做。<code class="fe ng nh ni nj b">void</code>关键字表示后面是一个表达式，而不是一个函数定义。为了同样的效果，我们可以用更神秘的<code class="fe ng nh ni nj b">!</code>代替<code class="fe ng nh ni nj b">void</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="2d32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">后一种形式可能被认为更容易混淆不知情的人，因为在JavaScript(和许多其他语言)中，感叹号<code class="fe ng nh ni nj b">!</code>，又名“砰”，是逻辑“非”操作符。顺便提一下，它实际上也是这样操作的，并调用函数表达式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="a08f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，更神秘的<code class="fe ng nh ni nj b">!</code>可以用来有意地利用它的布尔运算。它还可以用来帮助避免前面连接的模块丢失尾部分号时的错误。最后，它可能比其他形式节省一两个字节的内存。</p><p id="5a38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将函数标记为表达式的第三种方法是将其括在括号中，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="05f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们使用arrow函数结构来删除关键字<code class="fe ng nh ni nj b">function</code>，我们最终会得到这篇文章介绍中显示的结构，它首先引起了我的兴趣:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="1831" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在已经回答了我最初的问题“为什么有这么多括号？”，我们很可能会问一个更重要的问题:“这有什么意义？”由于到目前为止给出的示例只是在每个函数中执行一条语句，因此只执行语句而不将其包装在函数表达式中似乎没有什么区别。</p><p id="d2d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用IIFE的主要原因是函数表达式创建了一个新的作用域上下文或“闭包”(如果你需要回顾作用域的概念，我会再次推荐Cristian Salcescu的这篇文章。这可以用一个虚构的例子来说明:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="50c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们能够用相同的标识符<code class="fe ng nh ni nj b">name</code>声明第二个变量，这在相同的作用域内是非法的，并在各自的作用域内使用每个变量，而不会干扰彼此的值。</p><p id="a14d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当编写包含许多相似但不同的操作的代码时，这会带来直接的好处。例如，在编写计算器应用程序时，我发现自己想在许多地方使用像<code class="fe ng nh ni nj b">result</code>这样的变量名。通过尝试使用描述性标识符(以提高代码可读性)，我求助于使用诸如<code class="fe ng nh ni nj b">tempResultA</code>、<code class="fe ng nh ni nj b">tempResultB</code>等变体。远非理想，但通过明智地使用IIFEs(或其他作用域解决方案)很容易解决。</p><blockquote class="nl nm nn"><p id="369f" class="kr ks nk kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">这种封装避免了“污染”全局(或父)范围。它还有助于保护封装的代码免受更改全局值的意外/无意影响。</p></blockquote><h1 id="ff0d" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">生活的多样性</h1><p id="ca67" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">让我们更进一步，声明一个变量标识符并指向一个立即调用的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="8b57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然这确实为我们提供了IIFEs的所有范围相关的优势，但这个特定的案例并没有增加任何额外的功能。尽管试图给我们的生活分配一个标识符，我们只是简单地分配了一个“未定义”的值，因为函数已经执行了，但是没有一个执行提供了一个值(它只是在控制台记录了一个字符串)。因此，我们在内存中放置了一个标识符，但没有带来任何好处。</p><p id="7630" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果我们<em class="nk">从函数表达式返回一个值</em>，而不是简单地执行语句，我们将成功地将变量设置为该值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="201f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，当在终端中运行时，这种形式不需要括号来封装函数表达式，但是在没有括号的某些浏览器中会抛出错误。<em class="nk">下面的箭头函数形式</em>是否在所有情况下都需要这样的封装括号(如果没有括号，将会抛出错误):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><blockquote class="nl nm nn"><p id="0a80" class="kr ks nk kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">当设置(或计算)变量值时，这种模式为我们提供了一种获得范围封装好处的简洁方式，以及由此产生的闭包。</p></blockquote><p id="a541" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个提醒我们自己的好时机，我们也可以将参数传递给IIFEs的参数，就像常规函数一样。例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="c01c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们在return语句周围加上花括号，就会发生有趣的事情:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="47e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些花括号告诉JavaScript返回一个对象文字，这意味着我们可以读取与<code class="fe ng nh ni nj b">ary</code>键相关的值，在上面的例子中，使用<code class="fe ng nh ni nj b">arrowIIFE.ary</code>，它表示形式:&lt;life name&gt;。&lt;对象文字键&gt;</p><p id="7c7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还可以添加一个函数来改变我们的数组，并将该函数作为一个对象文字返回，这为我们提供了在生命执行后更改我们声明的数组的能力:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><blockquote class="nl nm nn"><p id="4d7b" class="kr ks nk kt b ku kv jr kw kx ky ju kz no lb lc ld np lf lg lh nq lj lk ll lm ij bi translated">有了这个模式，我们就有了一个非常真实的例子——模块模式。</p></blockquote><p id="ef74" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我在没有完全理解它的情况下，在完成一个旨在创建井字游戏的练习时使用的模式。下面的例子是我的解决方案中的<code class="fe ng nh ni nj b">board</code>模块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="87f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你大概可以猜到上面的例子用了一个9元素的数组来表示井字棋盘。如果你已经阅读了这篇文章，希望你也理解了如何在<code class="fe ng nh ni nj b">board</code>名称空间中使用<code class="fe ng nh ni nj b">addPiece</code>和<code class="fe ng nh ni nj b">reset</code>函数。</p><p id="fc83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，我们已经看到了直接运行的函数，以及设置变量值的函数。你可能也想知道，“能不能创造一个命名的生命，在它被立即调用后又被调用？”是的，它可以:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="baab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们看到一个包含命名函数定义<em class="nk">的生命，它返回自身</em>。因此，它在初始执行<em class="nk">和</em>时执行命名函数中的代码，随后每次调用IIFE时执行。在这个例子中，我们还有一个参数<code class="fe ng nh ni nj b">msg</code>，它的默认参数包含在IIFE中。</p><h1 id="3e5d" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">野外生活</h1><p id="6391" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">在结束之前，让我们花一点时间了解一下生命是如何以及为什么被真正使用的。</p><p id="79e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">数据隐私:</strong></p><p id="723c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例子来自Marius Schultz的<a class="ae md" href="https://mariusschulz.com/blog/use-cases-for-javascripts-iifes" rel="noopener ugc nofollow" target="_blank"><em class="nk">JavaScript生命的用例</em></a>；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="edc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ng nh ni nj b">count</code>变量，以及增加变量并在返回的id字符串中使用变量的值的函数，都不能从生命的外部访问，因为它创建了一个闭包(局部作用域)。因此，唯一id产生的过程被保护免受意外或有意的修改(除非通过直接重写生命)。</p><p id="e64d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">模块模式为API: </strong></p><p id="c553" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Addi Osmani的<a class="ae md" href="https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s02.html" rel="noopener ugc nofollow" target="_blank"> <em class="nk">学习JavaScript设计模式</em> </a>示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="8f06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里使用的模块模式不仅在<code class="fe ng nh ni nj b">basketModule</code>中巧妙地命名了它的方法，还通过公开返回的API呈现了许多方法，同时保持了许多方法的私有性。</p><p id="5667" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">更好的定时重复:</strong></p><p id="e5ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个例子改编自Safraz Ahmed的<a class="ae md" href="https://sarfraznawaz.wordpress.com/2012/01/26/javascript-self-invoking-functions/" rel="noopener ugc nofollow" target="_blank"> <em class="nk"> JavaScript自调用函数</em> </a>。</p><p id="8e5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设您希望您的网页每5秒重复运行一些代码，可能是为了查询数据库或API，或者出于其他原因。简单(但不太有效)的方法是使用<code class="fe ng nh ni nj b">setInterval</code>每5秒调用一次函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="e306" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，如果<code class="fe ng nh ni nj b">doStuff</code>中的代码没有在5秒内完成，它将被再次调用。不难想象(或体验)这可能不会产生预期的结果，甚至会导致严重的问题。如果我们使用一个在代码执行后经过一段设定时间<em class="nk">后才调用自身的生命，这样的问题就可以避免:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="9af1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我只触及了生活中生活中生活的表面，但是希望你现在已经准备好了，当你遇到他们的时候，能够识别和更好地理解他们。</p><h1 id="f82c" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论:</h1><p id="f03e" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">JavaScript程序员可以使用各种形式的函数，其中许多可以利用底层概念的不同方面，比如闭包、范围、绑定、调用的时间和模式等等。</p><p id="b61d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过提高对JavaScript函数的熟练程度，可以获得更多的控制和效率，避免许多错误，并加深对真实世界代码库的理解。</p><h1 id="6258" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">使用的资源:</h1><p id="43b7" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated"><a class="ae md" href="https://gomakethings.com/an-introduction-to-the-javascript-constructor-pattern/" rel="noopener ugc nofollow" target="_blank"> <em class="nk">介绍JavaScript构造器模式</em> </a>，作者Chris Ferdinandi</p><p id="6c60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://medium.freecodecamp.org/an-introduction-to-scope-in-javascript-cbd957022652" rel="noopener ugc nofollow" target="_blank"> <em class="nk">介绍JavaScript </em> </a>中的作用域，作者Cristian Salcescu</p><p id="410b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://medium.com/@vvkchandra/essential-javascript-mastering-immediately-invoked-function-expressions-67791338ddc6" rel="noopener"> <em class="nk">基本JavaScript:掌握即时调用函数表达式</em> </a>，作者钱德拉·冈达马拉朱</p><p id="2d2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">布兰登·莫雷利<a class="ae md" href="https://codeburst.io/javascript-arrow-functions-for-beginners-926947fc0cdc" rel="noopener" target="_blank"> <em class="nk"> JavaScript:初学者的箭头函数</em> </a></p><p id="8dcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://www.sitepoint.com/javascript-design-patterns-singleton/" rel="noopener ugc nofollow" target="_blank"> <em class="nk"> JavaScript设计模式:单例模式</em> </a>，作者萨米尔·赛义德</p><p id="615d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1" rel="noopener"> <em class="nk"> JavaScript工厂函数与ES6+ </em> </a>，作者Eric Elliot</p><p id="f147" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://sarfraznawaz.wordpress.com/2012/01/26/javascript-self-invoking-functions/" rel="noopener ugc nofollow" target="_blank"> <em class="nk"> JavaScript自我调用函数</em> </a>，作者Safraz Ahmed</p><p id="6b0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript:给初学者的关键词“这个”，作者布兰登·莫雷利</p><p id="55fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s02.html" rel="noopener ugc nofollow" target="_blank"> <em class="nk">学习JavaScript设计模式</em> </a>，作者Addi Osmani</p><p id="0ad7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://www.codementor.io/dariogarciamoya/understanding-this-in-javascript-with-arrow-functions-gcpjwfyuc" rel="noopener ugc nofollow" target="_blank"> <em class="nk">用JavaScript理解箭头函数中的“this”</em></a>，作者达里奥·加西亚·莫亚</p><p id="dcb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://mariusschulz.com/blog/use-cases-for-javascripts-iifes" rel="noopener ugc nofollow" target="_blank"><em class="nk">JavaScript的使用案例</em> </a>，作者Marius Schultz</p><p id="7f88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://stackoverflow.com/questions/2422026/what-do-empty-parentheses-after-a-function-declaration-do-in-javascript" rel="noopener ugc nofollow" target="_blank"> <em class="nk">空括号做什么…？</em> </a>，StackOverflow</p><p id="1c13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae md" href="https://stackoverflow.com/questions/3755606/what-does-the-exclamation-mark-do-before-the-function" rel="noopener ugc nofollow" target="_blank"> <em class="nk">感叹号……表示什么？</em> </a>、StackOverflow</p></div></div>    
</body>
</html>