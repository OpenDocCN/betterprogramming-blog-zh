<html>
<head>
<title>How to Secure Kubernetes Using Network Policies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用网络策略保护Kubernetes</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-secure-kubernetes-using-network-policies-bbb940909364?source=collection_archive---------12-----------------------#2020-04-22">https://betterprogramming.pub/how-to-secure-kubernetes-using-network-policies-bbb940909364?source=collection_archive---------12-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c78" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kubernetes网络政策图解指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/12a3a8857200c8321861029cb1052345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UxM8DoQHShWLbXdI"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kushagra Kevat 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="feca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着越来越多的组织采用<a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>并在生产中运行它，有必要了解它的核心并适当地保护它。Kubernetes改变了为每个应用程序运行单独虚拟机的传统概念，而是允许您忘记底层基础架构，只需在通用节点集群中部署pod。这不仅简化了架构，还简化了基础架构的管理。</p><p id="d2ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes是一个开源的容器编排平台，代码库可以在GitHub上在线获得。虽然这有助于社区的贡献，但也为黑客提供了寻找漏洞和准备攻击的机会。大多数设置Kubernetes的自动化工具都是为了迎合各种用户，因此它们在默认情况下并不实施所有的安全性。您必须有意识地尝试在您的Kubernetes集群中应用适当的安全策略，创建网络策略就是其中之一。</p><p id="4a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数组织运行分层体系结构，根据应用程序执行的功能对其进行分组。最常见的是三层架构。有一个web层负责托管用户界面和体验应用程序。业务层托管业务API以执行功能(也称为中间件)，数据层运行后端应用程序，如数据库。</p><p id="79c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为简单起见，默认情况下，Kubernetes允许所有的pod相互通信。但是，您可以使用网络安全策略和入口在Kubernetes中实施分层架构。简单地说，Kubernetes中的网络安全策略类似于防火墙。运行传统架构的组织通常拥有防火墙，只允许所需层或服务器之间的通信。</p><p id="302f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，与防火墙不同，网络策略在第3层分段模型上工作，而不是在第7层模型上工作，第7层模型更高级，被大多数现代防火墙和威胁检测软件使用。但是拥有一些控制权总比没有任何权限好，因此成为了安全的良好起点。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将架构层分成多个名称空间</h1><p id="854c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们假设您的组织正在运行一个三层架构，并且您的堆栈中运行着基于web的应用程序、中间件应用程序和数据库应用程序。您已经将这些应用程序装箱，并决定转移到Kubernetes。安全团队对默认设置不满意，他们希望您应用分层方法来复制他们在Kubernetes中的现有架构。</p><p id="07a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现有的体系结构将服务器分成三个逻辑区域，防火墙定义了它们之间的通信。下面是它的工作原理:</p><ul class=""><li id="8c60" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">您不希望web应用程序直接与数据库交互，尽管它可以具有到internet的出站连接。那是暴露于外部世界的层。</li><li id="27ed" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">除了数据库层，中间件不应该有任何出站连接，它应该只监听来自web层的请求。</li><li id="f49f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">数据库不应该连接到互联网或其层之外的任何其他应用程序，应该只允许来自中间件层的连接。</li></ul><p id="3fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes世界中，您可以通过名称空间对应用程序进行分区。以下是解决问题的方法:</p><ul class=""><li id="c043" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">为web应用程序创建web命名空间。这一层没有任何限制，因为它将暴露于外部世界，并应与互联网交互。</li><li id="c409" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">为中间件应用程序创建一个中间件名称空间。创建仅允许来自web和中间件命名空间的连接的入口网络策略，以及仅允许到中间件和数据库命名空间的链接的出口网络策略。</li><li id="26ea" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">为数据库应用程序创建数据库命名空间。创建仅允许来自中间件和数据库命名空间的连接的入口网络策略，以及仅允许到数据库命名空间的链接的出口网络策略。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4a8f24b9fa33b03361eee67394f625e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*mfVnUSw3w2rvRFz4JClVpw.png"/></div></figure><p id="0e0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在命名空间层和pod层实施网络策略。尽管开发人员并不完美，但你并不想审查软件的每一个细节，因为这只会扼杀团队的生产力。平衡这一点的聪明方法是在名称空间上应用默认的网络策略，而不是依赖开发人员在pod级别上为您创建它。当然，这可能会随着您公司的安全原则而改变，您可能希望进行一些更细粒度的访问控制。Kubernetes网络政策也有可能做到这一点。</p><p id="b821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要确认您通过RBAC认证和授权用户，并且开发人员只能访问他们团队的名称空间。在向团队成员授予任何集群级别的角色之前，请三思。您应该只为集群管理员以及网络和安全团队保留集群级别的角色。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="60ed" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用网络策略</h1><p id="3302" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Kubernetes中应用网络策略非常简单。您只需要创建网络策略清单，并使用<code class="fe no np nq nr b">kubectl</code>命令在集群上应用它们。确保您拥有适当的群集级别权限。此外，检查您是否有允许在Kubernetes集群上安装网络策略的必要的网络插件，以及是否启用了网络策略。查看官方<a class="ae ky" href="https://kubernetes.io/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/" rel="noopener ugc nofollow" target="_blank"> Kubernetes文档</a>了解更多详情。</p><p id="5984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在名称空间级别应用默认的网络策略，并实施所需的规则来满足需求。让我们开始吧。</p><h2 id="b76d" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">创建名称空间</h2><p id="95d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">创建web、中间件和数据库名称空间，并分别用层“web”、“中间件”和“数据库”标记它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="5cf6" class="ns md it bd me nt nu dn mi nv nw dp mm li nx ny mo lm nz oa mq lq ob oc ms od bi translated">创建默认网络策略</h2><p id="7288" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">web名称空间可以允许所有连接，并且也不需要有出口规则，因为web应用程序的一些组件需要与internet应用程序通信。因此，我们不需要在web名称空间上应用任何网络策略。</p><p id="1c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将首先为中间件名称空间创建一个策略。为了测试，我配置了端口80。您需要将其更改为您的中间件端口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="325e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这成为我们的默认策略，因此适用于中间件名称空间中的所有pod。让我们试着去理解YAML:</p><ul class=""><li id="941f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">像所有Kubernetes清单一样，YAML文件以<code class="fe no np nq nr b">apiVersion</code>开头。在这种情况下，<code class="fe no np nq nr b">apiVersion</code>就是<code class="fe no np nq nr b">networking.k8s.io/v1</code>。</li><li id="b227" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们正在创建的<code class="fe no np nq nr b">Object</code>的<code class="fe no np nq nr b">Kind</code>是一个<code class="fe no np nq nr b">NetworkPolicy</code>。</li><li id="0f2f" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">在<code class="fe no np nq nr b">middleware</code>名称空间中，网络策略的名称是<code class="fe no np nq nr b">middleware-network-policy</code>。</li><li id="b3bc" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe no np nq nr b">podSelector</code>是{}，表示名称空间中的所有pod。</li><li id="1915" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe no np nq nr b">policyType </code>表示是<code class="fe no np nq nr b">Ingress</code>还是<code class="fe no np nq nr b">Egress</code>策略。对我们来说，两者都是。</li><li id="36a7" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe no np nq nr b">ingress </code>部分有一个<code class="fe no np nq nr b">from </code>声明列表，定义了允许流量的位置。在这种情况下，它来自端口80上标记为<code class="fe no np nq nr b">tier=web</code>或<code class="fe no np nq nr b">tier=middleware</code>的所有名称空间。</li><li id="833e" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe no np nq nr b">egress </code>部分有一个定义允许的流量目的地的<code class="fe no np nq nr b">to </code>声明列表。在这种情况下，对于端口80，它指向所有标记为<code class="fe no np nq nr b">tier=database</code>或<code class="fe no np nq nr b">tier=middleware</code>的名称空间。此外，它还有一个<code class="fe no np nq nr b">to</code>声明，允许出站流量通过UDP端口53进行DNS解析。</li></ul><p id="6e5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一个数据库网络策略。为了测试，我配置了端口80。您需要将其更改为您的数据库端口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="7984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样了！您已经成功创建了默认网络策略，用于在Kubernetes上实施您的组织策略。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="017e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">是时候做些测试了</h1><p id="8b14" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建三个NGINX部署，每个名称空间一个，看看它们是如何相互交互的。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="8cf2" class="ns md it nr b gy ok ol l om on">$ kubectl create deployment nginx --image=ewoutp/docker-nginx-curl -n web<br/>deployment.apps/nginx created</span><span id="8969" class="ns md it nr b gy oo ol l om on">$ kubectl create deployment nginx --image=ewoutp/docker-nginx-curl -n middleware<br/>deployment.apps/nginx created</span><span id="1b55" class="ns md it nr b gy oo ol l om on">$ kubectl create deployment nginx --image=ewoutp/docker-nginx-curl -n database<br/>deployment.apps/nginx created</span><span id="4f11" class="ns md it nr b gy oo ol l om on">$ kubectl get deployment --all-namespaces|grep nginx<br/>database      nginx      1/1     1            1           20s<br/>middleware    nginx      1/1     1            1           33s<br/>web           nginx      1/1     1            1           65s</span></pre><p id="5158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，我们在所有三个名称空间上创建了部署。</p><p id="c0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先列出豆荚来获取它们的IP。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="0638" class="ns md it nr b gy ok ol l om on">$ kubectl get pod --all-namespaces -o wide|grep nginx<br/>database      nginx-f67f7854c-k44gg  1/1     Running   0          65s     10.52.0.3     gke-cluster-3-default-pool-48567dd4-fmlf   &lt;none&gt;           &lt;none&gt;<br/>middleware    nginx-f67f7854c-5l2zx  1/1     Running   0          60s     10.52.0.4     gke-cluster-3-default-pool-48567dd4-fmlf   &lt;none&gt;           &lt;none&gt;<br/>web           nginx-f67f7854c-ldsbb  1/1     Running   0          69s     10.52.2.5     gke-cluster-3-default-pool-48567dd4-qgng   &lt;none&gt;           &lt;none&gt;</span></pre><p id="5765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在web pod上使用<code class="fe no np nq nr b">kubectl exec</code>来检查它是否可以与中间件pod连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="2aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的。我们可以。让我们尝试从中间件pod连接到数据库pod。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="f14a" class="ns md it nr b gy ok ol l om on">$ kubectl exec -it nginx-f67f7854c-ldsbb -n web -- curl 10.52.0.3<br/>^Ccommand terminated with exit code 130</span></pre><p id="834c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们试图从web pod连接到数据库pod时，它会无限期等待并超时。我们预料到了这一点，因为来自web名称空间的任何pod都不应该直接与数据库名称空间pod通信。</p><p id="e1f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试从中间件pod连接到数据库pod，会发生什么情况？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了预期的回复！</p><p id="eb81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">web pod的中间件怎么样？</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="8dbb" class="ns md it nr b gy ok ol l om on">$ kubectl exec -it nginx-f67f7854c-5l2zx -n middleware -- curl 10.52.0.5<br/>^Ccommand terminated with exit code 130</span></pre><p id="1ce9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所料，它也超时了。</p><p id="96a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们尝试一下数据库到中间件。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="5a27" class="ns md it nr b gy ok ol l om on">$ kubectl exec -it nginx-f67f7854c-5l2zx -n middleware -- curl 10.52.0.4<br/>^Ccommand terminated with exit code 130</span></pre><p id="923e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所料，它失败了。web pod的数据库呢？</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="f0f5" class="ns md it nr b gy ok ol l om on">$ kubectl exec -it nginx-f67f7854c-5l2zx -n middleware -- curl 10.52.0.5<br/>^Ccommand terminated with exit code 130</span></pre><p id="8b0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">又暂停了。我们预料到了这一点，因为数据库只能与其名称空间内的pod通信。</p><p id="caed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下名称空间内的通信是否存在。为此，我们将启动另一组名为NGINX-1的NGINX部署。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="00cd" class="ns md it nr b gy ok ol l om on">$ kubectl create deployment nginx-1 --image=ewoutp/docker-nginx-curl -n web<br/>deployment.apps/nginx-1 created</span><span id="441d" class="ns md it nr b gy oo ol l om on">$ kubectl create deployment nginx-1 --image=ewoutp/docker-nginx-curl -n middleware<br/>deployment.apps/nginx-1 created</span><span id="61a8" class="ns md it nr b gy oo ol l om on">$ kubectl create deployment nginx-1 --image=ewoutp/docker-nginx-curl -n database<br/>deployment.apps/nginx-1 created</span><span id="e14a" class="ns md it nr b gy oo ol l om on">$ kubectl get deployment --all-namespaces|grep nginx-1<br/>database      nginx-1   1/1     1            1           21s<br/>middleware    nginx-1   1/1     1            1           25s<br/>web           nginx-1   1/1     1            1           32s</span><span id="1336" class="ns md it nr b gy oo ol l om on">$ kubectl get pod --all-namespaces -o wide|grep nginx-1<br/>database      nginx-1-cd6cf6cc7-xz8lf   1/1     Running   0          64s   10.52.0.6     gke-cluster-3-default-pool-48567dd4-fmlf   &lt;none&gt;           &lt;none&gt;<br/>middleware    nginx-1-cd6cf6cc7-27ztk   1/1     Running   0          68s   10.52.2.6     gke-cluster-3-default-pool-48567dd4-qgng   &lt;none&gt;           &lt;none&gt;<br/>web           nginx-1-cd6cf6cc7-r6nj4   1/1     Running   0          75s   10.52.0.5     gke-cluster-3-default-pool-48567dd4-fmlf   &lt;none&gt;           &lt;none&gt;</span></pre><p id="f7cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷，现在让我们在web名称空间上尝试NGINX到NGINX-1。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且很管用！中间件对中间件呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="f105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那也可以。和数据库添加到数据库窗格？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="87a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所料，这也很有效。</p><p id="d6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们通过服务来公开应用程序，看看它们是如何工作的。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="8d8f" class="ns md it nr b gy ok ol l om on">$ kubectl expose deployment nginx --port 80 -n web<br/>service/nginx exposed<br/>$ kubectl expose deployment nginx --port 80 -n middleware<br/>service/nginx exposed<br/>$ kubectl expose deployment nginx --port 80 -n database<br/>service/nginx exposed<br/>$ kubectl get svc --all-namespaces|grep nginx<br/>database      nginx ClusterIP  10.0.10.126     80/TCP          2m15s<br/>middleware    nginx ClusterIP  10.0.2.63       80/TCP          2m20s<br/>web           nginx ClusterIP  10.0.12.220     80/TCP          2m29s</span></pre><p id="f4f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从web转向中间件，看看会发生什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="06af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从中间件到数据库？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="1496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它如预期的那样工作。从web到带有服务的数据库pod的curl怎么样？</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="744c" class="ns md it nr b gy ok ol l om on">$ kubectl exec -it nginx-f67f7854c-ldsbb -n web -- curl nginx.database<br/>^Ccommand terminated with exit code 130</span></pre><p id="464d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所料，这没有联系。至此，我们已经成功配置了网络策略，以在应用程序层内实施网络隔离。除非明确声明，否则默认情况下，任何开发人员都不能违反应用程序架构，并且您可以确保开发人员没有通过RBAC创建网络策略的权限。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5199" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">多走一步</h1><p id="75f1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们已经创建了默认的网络策略，以确保流量在正确的方向上流动，并且网络隔离到位。但是，我们刚刚根据名称空间隔离了网络。我们可以更进一步，在pod级别应用网络策略，以确保通信更加精细。只有正确的应用程序单元可以在正确的端口上访问正确的中间件组件，并且正确的中间件组件可以在正确的端口上连接到正确的数据库单元。</p><p id="a2bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes的网络政策足够灵活，可以提供这种功能，我将简要介绍一下这种可能性。让我们看看它的网络策略清单结构。</p><pre class="kj kk kl km gt og nr oh oi aw oj bi"><span id="3fd0" class="ns md it nr b gy ok ol l om on">apiVersion: networking.k8s.io/v1<br/>kind: NetworkPolicy<br/>metadata:<br/>  name: test-network-policy<br/>  namespace: default<br/>spec:<br/>  podSelector:<br/>    matchLabels:<br/>      role: db<br/>  policyTypes:<br/>  - Ingress<br/>  - Egress<br/>  ingress:<br/>  - from:<br/>    - ipBlock:<br/>        cidr: 172.17.0.0/16<br/>        except:<br/>        - 172.17.1.0/24<br/>    - namespaceSelector:<br/>        matchLabels:<br/>          project: myproject<br/>    - podSelector:<br/>        matchLabels:<br/>          role: frontend<br/>    ports:<br/>    - protocol: TCP<br/>      port: 6379<br/>  egress:<br/>  - to:<br/>    - ipBlock:<br/>        cidr: 10.0.0.0/24<br/>    ports:<br/>    - protocol: TCP<br/>      port: 5978</span></pre><ul class=""><li id="e416" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">在你的<code class="fe no np nq nr b">ingress</code>中可以有多个<code class="fe no np nq nr b">from</code>区块，在你的<code class="fe no np nq nr b">egress</code>中可以有多个<code class="fe no np nq nr b">to</code>区块。</li><li id="279d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">你可以搭配一把<code class="fe no np nq nr b">ipBlock</code>、<code class="fe no np nq nr b">namespaceSelector</code>或者<code class="fe no np nq nr b">podSelector</code>。</li><li id="819b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您只能允许流量通过特定的<code class="fe no np nq nr b">protocol </code>和<code class="fe no np nq nr b">ports</code>。在上面的示例中，只允许从端口6379到端口5978的流量。</li><li id="935c" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">您还可以使用<code class="fe no np nq nr b">except</code>声明排除IP范围的特定部分。在上面的示例中，来自172.17.0.0/16的流量是允许的，但来自子网172.17.1.0/24的流量除外，它是172.17.0.0/16范围的一部分。</li></ul><p id="13c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以自由使用任何排列和组合来尽可能限制流量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="486a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="c931" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您通读！我希望你喜欢这篇文章。这些只是关于如何在您的Kubernetes集群中实施网络策略的一些指南。虽然您应该实现它，但是您可以根据团队的需求和安全策略进行更改。</p></div></div>    
</body>
</html>