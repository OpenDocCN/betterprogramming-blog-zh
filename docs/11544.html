<html>
<head>
<title>Creating Extension Methods in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中创建扩展方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-an-extension-methods-in-c-d8c773d6a71c?source=collection_archive---------5-----------------------#2022-03-29">https://betterprogramming.pub/creating-an-extension-methods-in-c-d8c773d6a71c?source=collection_archive---------5-----------------------#2022-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="146b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用附加行为扩展类，而不修改它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/852a5f3cf75245e3e0159e0eee4b2c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0qkMw-mByTTFp_Ck"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@romulusprince?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦吉·加利</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始创建扩展方法之前，有人能告诉我到底什么是扩展方法吗？</p><p id="7bb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，让我们从一个简单的介绍开始。</p><h1 id="1b96" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">介绍</h1><p id="e7f4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">按照<a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="noopener ugc nofollow" target="_blank"> MSDN </a>的说法，扩展方法使你能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或修改原始类型。扩展方法是静态方法，但是调用它们时就好像它们是扩展类型上的实例方法一样。</p><p id="9f3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你猜怎么着听起来不错，微软！但是让我们来解释一下。</p><p id="1c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">扩展方法是<a class="ae kv" href="https://www.c-sharpcorner.com/article/solid-design-principles-simplified-with-uml/" rel="noopener ugc nofollow" target="_blank">开闭原则</a>的一个完美例子，即“开放用于扩展，关闭用于修改”。软件实体应该对扩展开放，但对修改关闭。这仅仅意味着一个实体应该容易扩展而不需要修改它自己。</p><ul class=""><li id="6d49" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">它说的是，现在你可以显式地添加一个新方法到现有的<code class="fe my mz na nb b">"class String"</code>(那不是很好吗？).</li><li id="af17" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">如果你想检查一个字符串是否是回文，你可以简单地创建一个扩展方法，一劳永逸地完成。</li></ul><h2 id="49d1" class="nh lt iq bd lu ni nj dn ly nk nl dp mc lf nm nn me lj no np mg ln nq nr mi ns bi translated"><strong class="ak">但问题是怎么做？</strong></h2><p id="f858" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了大家的利益，我们实际上不会使用另一个字符串回文的例子。相反，我们将实现一些有用的东西。</p><p id="533d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们编写一个扩展方法，通过它的值来获得对<code class="fe my mz na nb b">enum</code>的描述。相信我，我不得不在谷歌上搜索这个答案很多次，以至于我决定写这篇文章，以免为了得到我的金枪鱼而游过充满塑料垃圾的太平洋。</p><h1 id="b51b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">履行</h1><p id="d7b1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先:“你能修改一下<code class="fe my mz na nb b">class String</code>吗？”</p><p id="fa7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是:不会，当然不会！就此而言，您不能对系统的类进行任何更改。现在你可能会说我可以继承<code class="fe my mz na nb b">"class String"</code>并通过覆盖它现有的方法来扩展额外的功能？你也不能这么做，因为这是一个密封类。这意味着它对继承也是关闭的。</p><p id="a715" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何扩展现有类的行为呢？</p><p id="9252" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快速浏览一下图1。这是我们将要做的事情的大图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/dab34fba69feefa48298902ab8051ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zhXr1aMSoNsw-NAjh1A0g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图1:类型enum和string的扩展方法</p></figure><p id="f752" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上图所示，有两种扩展方法，</p><ul class=""><li id="b135" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">第一个，<code class="fe my mz na nb b">GetEnumDescription()</code>用于<code class="fe my mz na nb b">“type enum”</code>获取枚举值的<code class="fe my mz na nb b">“description”</code>。</li><li id="2030" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">第二，扩展方法<code class="fe my mz na nb b">GetEnumValueByDescription()</code>，由<code class="fe my mz na nb b">“type string”</code>通过描述获取<code class="fe my mz na nb b">“enum value”</code>。</li></ul><p id="4034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在继续创建一个enum，如下面的清单1所示。这是一系列旗舰手机:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单1: FlagshipSmartphone.cs</p></figure><h1 id="85c0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">GetEnumDescription()</h1><p id="62d9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了获得描述，我们将在enum上创建一个扩展方法。</p><p id="271b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在创建扩展方法时，我们需要注意一些规则。</p><p id="b791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">规则1: </strong>扩展方法被定义为静态的，但是通过使用实例方法语法来调用。在下面的语法中，我们创建了一个静态方法<code class="fe my mz na nb b">GetEnumDescription()</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单2:方法GetEnumDescription的空主体</p></figure><p id="ef4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">规则2 </strong>:第一个参数指定我们正在为哪个类型创建扩展方法，在本例中是<code class="fe my mz na nb b">“Enum”</code>。参数总是由<code class="fe my mz na nb b">“this modifier”</code>修饰。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单3:带有这个参数的GetEnumDescription()</p></figure><p id="f78b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规则3: 为了访问扩展方法，必须显式地导入名称空间。为了访问下面的<code class="fe my mz na nb b">“GetEnumDescription() method”</code>，我们需要在caller类中添加<code class="fe my mz na nb b">“using ExtensionMethod;”</code>名称空间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单3: GetEnumDescription()及其名称空间</p></figure><p id="1da6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">规则#4: </strong> <code class="fe my mz na nb b">“Overriding is strictly prohibited”</code>，可以使用扩展方法来扩展类或接口的行为，但不能覆盖已有的行为。</p><p id="6ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经完成了所有的规则，让我们给这个空身体添加一些逻辑。在下面的清单中，我所做的就是获取第3行中的<code class="fe my mz na nb b">“type enum”</code>的<code class="fe my mz na nb b">“fieldinfo”</code>并且在下一行中搜索自定义属性，如果类型匹配，则返回描述，如果类型匹配，则抛出异常。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单4: GetEnumDescription()</p></figure><p id="516f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一切就绪，让我们看看魔法。根据我们的图表，让我们在<code class="fe my mz na nb b">“class Program”</code>中调用这个扩展方法，在下面的清单5中，我们创建了一个类型为<code class="fe my mz na nb b">“FlagshipSmartphone enum”</code>的变量，其值为<code class="fe my mz na nb b">“Samsung”</code>。然后在第4行，我们实际上是在()的帮助下调用新创建的扩展方法。)点运算符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单5:调用扩展方法()</p></figure><p id="c634" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行应用程序，您应该能够看到如图2所示的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/53f86caff12eb5187c677b88777e7f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*j6eAIl8t6qmdPh2odwuZjg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图GetEnumDescription()的输出</p></figure><h1 id="f84d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">GetEnumValueByDescription()</h1><p id="2cb6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然我们已经熟悉了所有的细节，让我们直接进入代码吧。我们将重用<code class="fe my mz na nb b">“GetEnumDescription()”</code>以避免重写相同的逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单6: GetEnumValueByDescription()</p></figure><ul class=""><li id="d39f" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">您可能会问，我们在清单6中做了什么？</li><li id="5d62" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">首先，我们使用第一个参数<code class="fe my mz na nb b">string</code>作为<code class="fe my mz na nb b">“this”</code>。</li><li id="be21" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">然后我们将返回一个泛型类型参数<code class="fe my mz na nb b"><strong class="ky ir">“&lt;T&gt;”</strong></code>,使这个方法可以在所有类型的枚举中重用。</li><li id="5857" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">就逻辑而言，我们通过枚举值循环寻找匹配的描述。一旦描述匹配，我们就返回枚举值，如果没有描述匹配的枚举，我们就抛出一个异常。你可以用你想要的方式处理它，但是为了简单起见，现在我只是抛出一个异常。</li></ul><p id="ed9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们继续在我们的<code class="fe my mz na nb b">“class Program”</code>中调用这个方法。正如您在第8行中看到的。我们用的是<strong class="ky ir">(。)</strong>字符串变量上的点运算符<code class="fe my mz na nb b">iphone</code>来调用我们的扩展方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单7:在第8行调用GetEnumValueByDescription()。</p></figure><p id="332d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在这里运行这个家伙！您应该能够看到如图3所示的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/13bb69a4ccd0b116d100e37b66ea413d.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*xG4cdELY2eQdnaQUlMHnNA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图GetEnumValueByDescription()的输出</p></figure><p id="046f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是如何扩展现有类的行为，而无需修改它们。你也可以使用其他设计模式来实现这一点，但这是一个你可以使用的捷径。</p><p id="fe5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一件更有趣的事。因为它是用户定义的静态类，所以您也可以使用类名直接调用该方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单8:用静态类调用扩展方法</p></figure><p id="aa73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">C#中有一些预定义的扩展方法。</p><p id="8036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果以下面的例子为例，我们有一个<code class="fe my mz na nb b">“int array”</code>，我们在阵列上使用了<code class="fe my mz na nb b">“FirstOrDefault()”</code>。</p><p id="1dce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是你猜怎么着？数组没有任何名为<code class="fe my mz na nb b">FirstOrDefault()</code>的方法。这是因为<code class="fe my mz na nb b">FirstOrDefault()</code>是一个扩展方法，任何实现<code class="fe my mz na nb b">“IEnumerable interface”</code>的集合都可以使用它。</p><p id="1016" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，Array按照图4实现了<code class="fe my mz na nb b">IEnumerable interface</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单9:使用扩展方法FirstOrDefault()</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/cfb93b2cdc49d87b65aff0a24842d7e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*iebp0LF4U6qCGEsMfEvM9w.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图4:类数组</p></figure><p id="2a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在清单8中了解到的，我们可以直接使用静态类来调用扩展方法。所以我们也可以用下面的代码重写清单9中的代码。</p><p id="a1c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:第一个参数是，“集合类型的<code class="fe my mz na nb b">this</code>”。这意味着您必须将一个<code class="fe my mz na nb b">“integer array”</code>作为第一个参数传递给<code class="fe my mz na nb b">FirstOrDefault()</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单10:用静态类调用扩展方法</p></figure><p id="e9ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是它总是倾向于使用扩展方法，我的意思是这就是为什么它们是为。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="b1b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">extension方法的这个主题向我们展示了如何在不修改类的情况下扩展类以获得额外的行为。</p><p id="63a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也让我们了解了静态类是如何工作的。您可以深入研究系统的类来发现扩展方法。你会惊讶地知道到目前为止你已经使用了多少扩展方法。</p><p id="3ecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p><pre class="kg kh ki kj gt og nb oh oi aw oj bi"><span id="21a9" class="nh lt iq nb b gy ok ol l om on"><strong class="nb ir">Want to Connect?</strong></span><span id="244c" class="nh lt iq nb b gy oo ol l om on">Hit me up on <a class="ae kv" href="https://www.linkedin.com/in/rikampalkar/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</span></pre></div></div>    
</body>
</html>