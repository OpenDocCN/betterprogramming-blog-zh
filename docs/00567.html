<html>
<head>
<title>Github Templates: The Smarter Way to Formalize Pull Requests Among Development Teams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Github模板:在开发团队中形式化拉取请求的更聪明的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/github-templates-the-smarter-way-to-formalize-pull-requests-among-development-teams-89f8d6a204f?source=collection_archive---------0-----------------------#2019-06-11">https://betterprogramming.pub/github-templates-the-smarter-way-to-formalize-pull-requests-among-development-teams-89f8d6a204f?source=collection_archive---------0-----------------------#2019-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2dec" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不再有令人困惑的拉取请求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/090ada2a9a11e95db290e10676f7f19a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2599X6HCREZXkYc6UQL2A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@rawpixel?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">rawpixel.com</a>从<a class="ae ky" href="https://www.pexels.com/photo/group-hand-fist-bump-1068523/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</p></figure><h1 id="1b9a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="1620" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">欢迎光临！今天我要给你一个更好、更简单、更有效的方法来保持拉请求不仅统一，而且完全定制给你的开发团队。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8797" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">共同的问题</h1><p id="6693" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果您曾经作为软件开发人员单独或作为团队的一员与Github一起工作过，您应该对我将要向您展示的问题很熟悉。</p><h2 id="a8b5" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">留下不太好的提交消息</h2><p id="7fcd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，无意义的提交消息。这些消息通常会被发送多次，因为我们作为开发人员很懒，会不断地用相同的注释将更改推送到Github，即使更新与该消息没有任何关系。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/386ba1d9e0ff2388b2bc750f568adb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0bI1GYVzDvntoMqQo-NdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我在我的团队拥有的一个共享回购中发现的一组典型的提交消息。</p></figure><p id="1444" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated"><strong class="lt iu">边注:</strong>如果你想看一些笑出声来的commit消息，我强烈推荐网站<a class="ae ky" href="http://whatthecommit.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nr"> What the Commit </em> </a>。只需不断刷新页面，获得源源不断的令人捧腹(且准确)的提交消息。</p><h2 id="ac1a" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">完全令人费解的拉请求</h2><p id="06b3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">你已经看到了(和/或提交了)像这样的对回购的拉取请求——不要试图否认它。为了保护罪犯的隐私，姓名和识别细节被省略了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/a5b91c1f661a7239326e2fc809a453b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_0EmQc6rz3Hdo1ZTRJc0g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非常好。这无疑告诉了我我需要知道的事情。</p></figure><p id="4b23" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">是的，这是GitHub上的一个实际的pull请求，标题只是“赶上”一大堆commit消息，没有给出任何上下文，也没有提供任何其他细节，任何人都不知道这里发生了什么。</p><p id="1ab1" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">在这一点上，你可能会对自己说，事实上，这和你以前看到的(或提交的)东西很相似，你可能看不出有什么大问题。</p><p id="6f45" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">如果你是一个独自开发自己项目的人，总是知道代码库中的一切，我可能倾向于同意你的观点。然而，如果你在一个有10或20名其他开发人员的团队中，构建一个被成百上千人使用的应用程序，其他开发人员必须查看你所做的更改，确定代码和逻辑是否合理，并且不会破坏你的<code class="fe nt nu nv nw b">master</code>代码分支中的任何东西，这是一个非常非常大的问题。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0628" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">临时解决方案——不要费心使用这些选项，⚠️</h1><p id="368b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了解决这些问题，我的开发团队过去尝试了几种不同的解决方案:</p><h2 id="034b" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">选项1:完全手动的过程</h2><p id="807a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个松散的需求集合，我们必须手工添加到每个新的拉请求中。比如:</p><ul class=""><li id="6d30" class="nx ny it lt b lu nm lx nn ma nz me oa mi ob mm oc od oe of bi translated">链接到我们在backlog中正在制作的专题报道，</li><li id="71d9" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">链接到自动化的Jenkins分支，我们的功能分支在这里构建并部署到QA中，</li><li id="718e" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">链接到用于测试的功能分支，</li><li id="0993" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">代码覆盖率报告，</li><li id="f12a" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">其他回购中相关PRs的链接等。</li></ul><p id="1a57" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">这很好，除了人们通常忘记(或者只是不关心添加)一个或多个链接，我们没有一个正式的系统让新加入团队的开发人员知道如何格式化他们的PRs。</p><h2 id="9211" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">选项2:每次都需要复制/粘贴到PR中的模板</h2><p id="bb7e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们的第二次尝试稍微不太手工:我的团队将一个pull请求模板保存在一个Slack <code class="fe nt nu nv nw b">.txt</code>文件中，该文件被固定在我们的一个开发通道中。这看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="3780" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">但是再一次，开发人员必须找到模板，复制markdown格式，并将其粘贴到每个打开的pull请求中，并填写其中的内容。</p><p id="153b" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">这种方法效果更好，因为模板至少确保了遗忘东西的可能性更小，但它仍然不是万无一失的。通常(因为开发人员也是人，人们也很懒，包括我自己)，我们只是去找一个旧的关闭的PR，复制它的内容并粘贴到我们正在处理的新PR中。这是可以的，直到有人忘记更新故事链接或端到端测试链接…你看到问题了。</p><p id="9750" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">但这是最好的解决方案，直到我们的团队有了一些新的开发人员。</p><p id="6dc6" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">当我向我们的一个新开发人员展示我们使用的PR模板时(通过从另一个关闭的pull请求中复制)，他问我们为什么不直接使用<a class="ae ky" href="https://help.github.com/en/articles/creating-a-pull-request-template-for-your-repository" rel="noopener ugc nofollow" target="_blank"> Github模板</a>，我说，“因为我们都没听说过它们。”然后，他给我看了一些很酷很容易做的东西。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e88a" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">更好的解决方案——我们现在使用的(你应该Too)⭐️</h1><h2 id="ec9e" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">选项3: Github模板——制作PRs的自动化方式</h2><p id="aeb2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Github模板是GitHub的一项了不起的发明，用于请求和发布。因为PRs是我的团队所关心的，所以我找到了GitHub文档来了解更多。</p><p id="a4bb" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">以下是我从医生那里了解到的情况:</p><blockquote class="on"><p id="4781" class="oo op it bd oq or os ot ou ov ow mm dk translated">当您将“拉”请求模板添加到存储库中时，项目参与者将自动在“拉”请求正文中看到模板的内容。— GitHub文档</p></blockquote><p id="f934" class="pw-post-body-paragraph lr ls it lt b lu ox ju lw lx oy jx lz ma oz mc md me pa mg mh mi pb mk ml mm im bi translated">这正是我的团队需要的东西。这是一种确保每个拉取请求都是统一的方法，而我们的开发人员不必考虑这一点。完美。</p><p id="eb9a" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">事实证明，它也非常容易安装。</p><h2 id="cbac" class="mz la it bd lb na nb dn lf nc nd dp lj ma ne nf ll me ng nh ln mi ni nj lp nk bi translated">在项目中设置Github模板</h2><p id="b1bb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然建立一个公关模板非常简单，但为了方便起见，我很乐意在这里列出步骤。</p><p id="8bcf" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated"><strong class="lt iu">第一步:在项目</strong>的根目录下添加一个 <code class="fe nt nu nv nw b"><strong class="lt iu">.github/</strong></code> <strong class="lt iu">文件夹</strong></p><p id="bb8b" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">文件上说你可以把公关模板放在根目录下，或者放在一个名为<code class="fe nt nu nv nw b">docs/</code>或<code class="fe nt nu nv nw b">.github/</code>的文件夹里。</p><p id="f407" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">因为我们想在开发的大部分时间忽略PR文件夹，所以我选择在隐藏的<code class="fe nt nu nv nw b">.github/</code>文件夹中创建模板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/fc2ff71f1b56c2ddae98ba3442132469.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*auh1c__Y09u5TVzlMTOgDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我的repo的一个镜头，在项目的根目录下有一个隐藏的`. github/`文件夹。</p></figure><p id="1913" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated"><strong class="lt iu">第二步:在</strong>文件夹中添加你的 <code class="fe nt nu nv nw b"><strong class="lt iu">pull_request_template.md</strong></code> <strong class="lt iu"> markdown文件</strong></p><p id="70c2" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">为了让Github自动从PR模板的markdown文件中提取格式，您必须将文件命名为<code class="fe nt nu nv nw b">pull_request_template.md</code>。</p><p id="2567" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">下面是我的团队使用的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我们团队目前使用的拉式请求模板。</p></figure><p id="0a40" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated"><strong class="lt iu">第三步:将这些文件添加到您的</strong> <code class="fe nt nu nv nw b"><strong class="lt iu">master</strong></code> <strong class="lt iu">分支中，并为顺利完成所有拉取请求做好准备</strong></p><p id="da98" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">这里有一个添加了拉式请求模板的<a class="ae ky" href="https://github.com/paigen11/mysql-registration-passport" rel="noopener ugc nofollow" target="_blank">回购</a>的截图，以及一个我提出的拉式请求示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/f90e4944f2f14b7bd33f88f2aad7e970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c5e806CRqS_PkMC_eFuRQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是我在这个项目中打开一个新的PR时自动生成的自动PR。</p></figure><p id="6d55" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">事实上，在任何回购中包含一个标准化的PR模板非常简单。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="36d2" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">结论</h1><p id="25e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当你和一个开发团队一起开发一个任务关键型产品时，拉请求是不可避免的，但是在Github的<code class="fe nt nu nv nw b">pull_request_templates</code>的帮助下，它们可以不那么痛苦。</p><p id="2928" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">格式化公关模板的好处有很多，但我认为最重要的是它们的灵活性；无论您的团队认为有必要审查和接受什么，拉请求都可以很容易地包含在任何回购中并实现。这是开发人员需要的那种轻松，用于PRs之类的必要手续。</p><p id="149e" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">过几周再来看看，我会写关于JavaScript、ES6或其他与web开发相关的东西。</p><p id="c003" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">感谢您的阅读，我希望这能帮助您更好地管理自己团队的拉动请求，使之更加简单有序。如果你觉得有帮助，请与你的朋友分享！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fe77" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated"><strong class="ak">参考资料和更多资源:</strong></h1><ul class=""><li id="e420" class="nx ny it lt b lu lv lx ly ma pe me pf mi pg mm oc od oe of bi translated">示例原文，手动拉取请求模板gist:<a class="ae ky" href="https://gist.github.com/paigen11/0df23cdf168057dd5e8cf3c61d5beb0f" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/paigen 11/0 df 23 CDF 168057 DD 5 e 8 cf 3c 61 D5 beb 0 f</a></li><li id="7a3c" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">回购中的拉式请求模板:【https://github.com/paigen11/mysql-registration-passport T2】T3</li><li id="ef98" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">新的自动拉请求模板示例gist:<a class="ae ky" href="https://gist.github.com/paigen11/9ef7fd2b08de2b8a9976615c633ada02" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/paigen 11/9 ef 7 FD 2 b 08 de 2 b 8 a 9976615 c 633 ada 02</a></li><li id="98c4" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">Github模板文档:<a class="ae ky" href="https://help.github.com/en/articles/creating-a-pull-request-template-for-your-repository" rel="noopener ugc nofollow" target="_blank">https://help . github . com/en/articles/creating-a-pull-request-template-for-your-repository</a></li></ul></div></div>    
</body>
</html>