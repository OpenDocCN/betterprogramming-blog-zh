<html>
<head>
<title>Customize Your Xcode Project With Tuist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tuist定制您的Xcode项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/customize-your-xcodeproject-with-tuist-6fc41fb59262?source=collection_archive---------10-----------------------#2021-02-09">https://betterprogramming.pub/customize-your-xcodeproject-with-tuist-6fc41fb59262?source=collection_archive---------10-----------------------#2021-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">添加依赖项和自定义模块来个性化您的iOS项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a263b18220ca7fc3aec2ecff06c77cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QU51flFuevD3aD98"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@drew_hays?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德鲁·海斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="82f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这是关于使用Tuist配置项目的系列文章的第二部分。如果你还没有看完第一部分</em>  <em class="lv">，请查看</em> <a class="ae ky" href="https://medium.com/better-programming/stop-committing-the-xcodeproj-fa83527ba156" rel="noopener"> <em class="lv">。</em></a></p><p id="6b1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://tuist.io" rel="noopener ugc nofollow" target="_blank"> Tuist </a>是一个神奇的工具，可以通过编程创建Xcode项目和一个<code class="fe lw lx ly lz b">xcworkspace</code>。项目使用Swift进行定义，并通过可重用的功能和类型进行描述。</p><p id="c52c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上周，我们探索了Tuist创建的默认配置。我们看到了Tuist如何用两个支持模块准备app target:一个用于UI，一个用于逻辑。</p><p id="c0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迟早，我们需要向我们的项目添加其他依赖项。我们如何才能做到这一点？让我们探索我们的替代方案。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0950" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">向项目添加依赖项</h1><p id="c045" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们假设我们想要在我们的UI目标中添加<a class="ae ky" href="https://github.com/onevcat/Kingfisher" rel="noopener ugc nofollow" target="_blank"> Kingfisher </a>库，以便能够从远程URL加载图像。从Swift Package Manager (SPM)添加新的依赖关系非常简单。我们必须:</p><ol class=""><li id="5204" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">在<code class="fe lw lx ly lz b">Project</code>结构中安装依赖项。这是通过在<code class="fe lw lx ly lz b">Project</code>中添加<code class="fe lw lx ly lz b">packages</code>参数来完成的。</li><li id="5a24" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">在<code class="fe lw lx ly lz b">makeFrameworkTargets</code>中指定依赖关系。</li><li id="b6fa" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">运行<code class="fe lw lx ly lz b">tuist generate</code>。</li></ol><p id="0b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="9cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我们用这样的代码运行<code class="fe lw lx ly lz b">tuist generate</code>，我们会看到一个小小的警告:</p><pre class="kj kk kl km gt nu lz nv nw aw nx bi"><span id="b8b4" class="ny mi it lz b gy nz oa l ob oc">Package “Kingfisher” has been linked against [“FirstTuistAppKit”, “FirstTuistAppUI”], it is a static product so may introduce unwanted side effects.</span></pre><p id="4815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">酷的是Tuist为我们解决了SPM依赖性。令人不快的是<code class="fe lw lx ly lz b">static</code>产品必须与单一目标挂钩。默认情况下，<code class="fe lw lx ly lz b">makeFrameworkTarget</code>功能在应用程序定义的所有目标上运行。因此，依赖性被添加到所有附加目标中。</p><p id="f8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两种选择:</p><ol class=""><li id="41b6" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">更改模板以指定哪个目标具有哪个依赖项。在<code class="fe lw lx ly lz b">Kit</code>框架中加入翠鸟是没有意义的，它没有UI组件。</li><li id="3e20" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">定义一个目标来托管静态依赖项，并使所有其他目标都依赖于该静态依赖项。</li></ol></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="10ec" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">添加框架结构</h1><p id="92fd" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">为了实现第一种选择，我们可以引入一个支持结构。这个结构允许我们定义一个带有名称的框架，一组主目标的依赖项，以及一组测试目标的依赖项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码显示了如何更新<code class="fe lw lx ly lz b">Project+Template.swift</code>文件来适应这些变化。我在示例中只留下了相关的代码。</p><ol class=""><li id="2bd6" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">定义<code class="fe lw lx ly lz b">Framework</code>结构。</li><li id="4273" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">更新<code class="fe lw lx ly lz b">app</code>函数的签名，并在<code class="fe lw lx ly lz b">makeAppTarget</code>调用中使用新的<code class="fe lw lx ly lz b">Framework</code>结构。</li><li id="4474" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">更改<code class="fe lw lx ly lz b">makeFrameworkTargets</code>的签名。</li><li id="eabb" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">使用<code class="fe lw lx ly lz b">framework.dependencies</code>属性创建框架的依赖关系。</li><li id="a3ca" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">使用<code class="fe lw lx ly lz b">framework.testDependencies</code>属性来创建测试目标的依赖项。</li><li id="38a6" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">使用新参数更新我们创建框架目标的行。</li></ol><p id="2421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们只需使用<code class="fe lw lx ly lz b">Project.swift</code>文件中的新结构来声明框架及其依赖关系。这可以通过下面的代码轻松完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1a1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在示例中，有一种情况是使用<code class="fe lw lx ly lz b">Project.Framework</code>来定义一个没有依赖关系的框架(第5行)，还有一种情况是我们添加了<code class="fe lw lx ly lz b">Kingfisher</code>依赖关系(第6到9行)。</p><p id="7deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行<code class="fe lw lx ly lz b">tuist generate</code>，警告已经消失。这是件好事。我们现在可以只向需要它们的目标添加特定的依赖项。但是如果我们引入另一个需要<code class="fe lw lx ly lz b">Kingfisher</code>的UI模块会怎么样呢？我们会遇到同样的问题。因此，我们可以实施第二种选择。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8533" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">创建依赖关系主机模块</h1><p id="e6dd" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一个<code class="fe lw lx ly lz b">host</code>模块是一个空的框架，它唯一的任务是托管来自SPM的包。我们可以将一个<code class="fe lw lx ly lz b">host</code>模块链接到其他几个我们称之为<code class="fe lw lx ly lz b">code</code>模块的目标。通过这种设置，我们解决了以前解决方案的局限性。</p><p id="96a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这个选择，我们必须修改项目定义的结构。</p><p id="95a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:Tuist还不能创建所需的文件夹结构。因此，一个初步的步骤是在</em> <code class="fe lw lx ly lz b"><em class="lv">Targets</em></code> <em class="lv">文件夹下创建</em> <code class="fe lw lx ly lz b"><em class="lv">KingfisherFramework</em></code> <em class="lv">。</em></p><p id="cc26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们注意到的第一件事是，<code class="fe lw lx ly lz b">host</code>和<code class="fe lw lx ly lz b">code</code>模块共享两条信息:模块的<code class="fe lw lx ly lz b">name</code>和它的<code class="fe lw lx ly lz b">dependencies</code>。<code class="fe lw lx ly lz b">code</code>模块有额外的信息:T5。我们可以用两种情况定义一个<code class="fe lw lx ly lz b">Framework</code>枚举:<code class="fe lw lx ly lz b">code</code>情况和<code class="fe lw lx ly lz b">host</code>情况。每个案例都有自己的相关值来指定此信息。以下代码阐释了这些模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个核心模型开始，我们可以为<code class="fe lw lx ly lz b">Project.Framework</code> enum定义一系列属性，从而简化框架的创建。这些属性提供了一个有用的快捷方式来检索有用的信息，如<code class="fe lw lx ly lz b">name</code>、源的<code class="fe lw lx ly lz b">path</code>、<code class="fe lw lx ly lz b">target</code>等等。以下<code class="fe lw lx ly lz b">extension</code>展示了这些属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="50c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了所有这些属性，我们最终可以更改<code class="fe lw lx ly lz b">app</code>函数，使其利用新的数据结构。这个新组织提供了很多好处:</p><ol class=""><li id="3a24" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">我们可以完全删除<code class="fe lw lx ly lz b">makeFrameworkTargets</code>功能。</li><li id="388a" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe lw lx ly lz b">app</code>函数实现变得更具声明性。</li><li id="c469" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><code class="fe lw lx ly lz b">Project.swift</code>文件中的项目定义也是声明性的。</li></ol><p id="9de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下代码片段显示了Tuist项目的其余部分是如何更改的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app功能应该如何改变。看看“目标”变量。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目的新面貌。再看附加的“目标”属性的表现性。</p></figure><p id="a409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们运行<code class="fe lw lx ly lz b">tuist generate</code>命令，Tuist会创建一个包含所有必需依赖项的项目。我们可以用<code class="fe lw lx ly lz b">open {appName}.xcworkspace</code>打开<code class="fe lw lx ly lz b">xcworkspace</code>，如果我们点击<code class="fe lw lx ly lz b">⌘+B</code>，我们可以看到项目构建完成。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e7cf" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">添加新目标</h1><p id="7dda" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">最后，我们想在我们的应用程序中添加新的目标。这有助于创建模块化的应用程序。也许我们希望有一个处理小教程的onboarding模块，它依赖于同一个<a class="ae ky" href="https://github.com/onevcat/Kingfisher" rel="noopener ugc nofollow" target="_blank"> Kingfisher </a>框架。</p><p id="f754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了所有这些组件，添加一个新的<code class="fe lw lx ly lz b">code</code>模块就非常简单了。</p><p id="2a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建一个非常简单的脚本来配置模块的基本结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e0ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用下面一行来运行这个命令:</p><pre class="kj kk kl km gt nu lz nv nw aw nx bi"><span id="f084" class="ny mi it lz b gy nz oa l ob oc">./create_module.sh Onboarding</span></pre><p id="d1ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:记住更改脚本的执行权限。这可以通过运行</em> <code class="fe lw lx ly lz b"><em class="lv">chmod +x create_module.sh</em></code> <em class="lv">来实现。如果我们忘记了这一步，我们可以使用</em> <code class="fe lw lx ly lz b"><em class="lv">shell create_module.sh Onboarding</em></code> <em class="lv">来运行脚本。</em></p><p id="af83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该脚本在<code class="fe lw lx ly lz b">Targets</code>文件夹中创建一个<code class="fe lw lx ly lz b">Onboarding</code>文件夹。然后它创建了<code class="fe lw lx ly lz b">Targets/Onboarding/Sources</code>和<code class="fe lw lx ly lz b">Target/Onboarding/Tests</code>子文件夹，以及在<code class="fe lw lx ly lz b">Sources</code>和<code class="fe lw lx ly lz b">Tests</code>文件夹中分别命名为<code class="fe lw lx ly lz b">Onboarding.swift</code>和<code class="fe lw lx ly lz b">OnboardingTests.swift</code>的两个Swift文件。</p><p id="8f45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们运行<code class="fe lw lx ly lz b">tuist edit</code>来打开Tuist项目。一旦Xcode启动，我们就可以添加新的<code class="fe lw lx ly lz b">Onboarding</code>框架。这可以通过在<code class="fe lw lx ly lz b">Project.swift</code>文件的<code class="fe lw lx ly lz b">additionalTargets</code>属性中添加一个新条目来完成(下面代码片段的第8行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，通过运行<code class="fe lw lx ly lz b">tuist generate</code>，Tuist创建最终的项目。在Xcode中打开时，我们可以看到这张图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a7d47fcdc6c1323ed27be0306bebb662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pl_7mERdVbgpzbd71i49eQ.png"/></div></div></figure><p id="0e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tuist创建了<code class="fe lw lx ly lz b">Onboarding</code>和<code class="fe lw lx ly lz b">OnboardingTests</code>目标。<code class="fe lw lx ly lz b">Onboarding</code>框架已经作为依赖项添加到了<code class="fe lw lx ly lz b">FirstTuistApp</code>目标中。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6820" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="823a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在今天的文章中，我们探讨了如何将<code class="fe lw lx ly lz b">Project+Templates.swift</code>文件更新为:</p><ul class=""><li id="b839" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu oe nk nl nm bi translated">向我们的项目添加第三方依赖项。</li><li id="0b45" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu oe nk nl nm bi translated">定义主机框架和代码框架。</li><li id="6bce" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu oe nk nl nm bi translated">创建更具声明性的项目定义。</li><li id="f813" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu oe nk nl nm bi translated">添加更多自定义框架来模块化我们的应用程序。</li></ul><p id="83b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了所有这些要素，我们就可以利用一个强大的工具来描述我们的项目，并与我们的团队分享，从而限制合并冲突的可能性。</p></div></div>    
</body>
</html>