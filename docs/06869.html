<html>
<head>
<title>An Extremely Easy Tip to Improve Web Performance With Async/Await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Async/Await提高Web性能的一个非常简单的技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-extremely-easy-tip-to-improve-web-performance-with-async-await-b609e7e65744?source=collection_archive---------7-----------------------#2020-11-12">https://betterprogramming.pub/an-extremely-easy-tip-to-improve-web-performance-with-async-await-b609e7e65744?source=collection_archive---------7-----------------------#2020-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3bc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个很好的拯救技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/83604074d48c6dddce6bc9a6f34e2c22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cue6Q7r4AGEaXNCu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="902c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你喜欢使用<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>语法吗？我也是。在我看来，它比<code class="fe lv lw lx ly b">Promise</code>连锁店要好。但是我想知道你是否正确地使用它。有时它会使你的程序运行得比预期的慢。在这篇文章中，我想告诉你一些非常重要的事情，当使用<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>时会有更好的性能，这在你的项目中非常容易采用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="af62" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">阅读前</h1><p id="3b73" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">许多JavaScript开发人员都喜欢<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>语法。我认为人们喜欢这种语法的主要原因是因为<code class="fe lv lw lx ly b">Promise</code> hell，它通过调用<code class="fe lv lw lx ly b">then</code>不断生成深度。</p><p id="8940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>让开发者通过使用<code class="fe lv lw lx ly b">await</code>关键字来减少或摆脱<code class="fe lv lw lx ly b">Promise</code>的困扰。但是，您有没有想过，如果以非优化的方式使用这种语法，可能会降低应用程序的速度？</p><p id="c550" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那我们该怎么办？让我们谈谈我们的选择。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b5cc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">助手功能</h1><p id="4bc9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们假设有一个函数叫做<code class="fe lv lw lx ly b">sleep</code>。它把时间拖延到你想拖延多久，这是一个<code class="fe lv lw lx ly b">Promise</code>基数。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0af3" class="nh mh it ly b gy ni nj l nk nl">const sleep = t =&gt; {<br/>  return new Promise(res =&gt; {<br/>    setTimeout(res, t);<br/>  });<br/>};</span></pre><p id="3133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且我们还有一个假的<code class="fe lv lw lx ly b">fetch</code>方法。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="03d6" class="nh mh it ly b gy ni nj l nk nl">const fetch = url =&gt; {<br/>  const time = url.length * 1000;<br/>  return sleep(time);<br/>};</span></pre><p id="4e83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假方法<code class="fe lv lw lx ly b">fetch</code>采用一个字符串类型的参数，它用于计算延迟的时间长度。如果我们调用<code class="fe lv lw lx ly b">fetch('/notice')</code>，由于<code class="fe lv lw lx ly b">/notice</code>有7个字符，延迟时间将是7秒。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a171" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">基本情况和问题</h1><p id="51f8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，我们访问应用程序的主页；大概是<code class="fe lv lw lx ly b">/</code>。当我们访问主页面时，代码试图通过<code class="fe lv lw lx ly b">fetch</code> ing加载数据。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0035" class="nh mh it ly b gy ni nj l nk nl">// React base<br/>async componentDidMount() {<br/>  const banners = await fetch('/banners');<br/>  const events = await fetch('/events');<br/>  const notices = await fetch('/notices');</span><span id="21eb" class="nh mh it ly b gy nm nj l nk nl">  /* Do other tasks here */</span><span id="d87d" class="nh mh it ly b gy nm nj l nk nl">  this.setState({<br/>    ...this.state,<br/>    banners,<br/>    events,<br/>    notices<br/>  });<br/>}</span></pre><p id="fd59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前制作了一个假的<code class="fe lv lw lx ly b">fetch</code>方法，这是一个<code class="fe lv lw lx ly b">Promise</code>基地。它采用字符串类型的参数。</p><ul class=""><li id="3e29" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">/banners</code> →八个字符/八秒延迟</li><li id="c19a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">/events</code> →七个字符/七秒钟延迟</li><li id="7156" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">/notices</code> →八个字符/八秒延迟</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/51316c72eae602969e71e00ee33c384d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2skN8-2YJ7GulDCIzSlp9A.png"/></div></div></figure><p id="0bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的获取时间将是23秒，因为它在调用下一个获取之前等待当前获取结束。</p><p id="d64f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果提取的顺序很重要，这种结构就很好。例如，我们应该在获取<code class="fe lv lw lx ly b">/my-profile</code>之前获取<code class="fe lv lw lx ly b">/login</code>,因为它是仅限会员的信息。</p><p id="4243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在渲染之前需要获取五个以上的API，该怎么办？API越多，用户在看到页面之前等待的时间就越长。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="957f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决办法</h1><p id="49d8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">解决方案非常简单明了。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b262" class="nh mh it ly b gy ni nj l nk nl">// React base<br/>async componentDidMount() {<br/>  const bannersFetch = fetch('/banners');<br/>  const eventsFetch = fetch('/events');<br/>  const noticesFetch = fetch('/notices');</span><span id="7d3f" class="nh mh it ly b gy nm nj l nk nl">  /* Do other tasks here */</span><span id="379b" class="nh mh it ly b gy nm nj l nk nl">  const banners = await bannersFetch;<br/>  const events = await eventsFetch;<br/>  const notices = await noticesFetch;</span><span id="62f5" class="nh mh it ly b gy nm nj l nk nl">  this.setState({<br/>    ...this.state,<br/>    banners,<br/>    events,<br/>    notices<br/>  });<br/>}</span></pre><p id="a3fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与早期版本唯一不同的一点是，我们不再将<code class="fe lv lw lx ly b">await</code>关键字放在<code class="fe lv lw lx ly b">fetch</code>之前。相反，我们把它放在后面。接下来会发生什么？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/85bb70719a218d2533ef4a765e44e8df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYUs_PBIVpB8gyuBjebUQA.png"/></div></div></figure><p id="234f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个<code class="fe lv lw lx ly b">fetch</code>请求都将被发送到服务器，因为它们都不会在触发下一个<code class="fe lv lw lx ly b">fetch</code>之前等待响应。</p><p id="6ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在上面的例子中<code class="fe lv lw lx ly b">componentDidMount</code>没有额外的工作，最长等待时间也只有8秒。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="674d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">承诺带来魔力</h1><p id="78ed" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们能够从几行代码更改中获得巨大好处的原因是因为承诺。基本上，Promise是一个异步工作的API。然而，秘密实际上隐藏在事件队列中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/e86bf22958b9523bd06a842ee1184310.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0uAtm9M_GfIF19CZSV_yg.png"/></div></div></figure><p id="9a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，JavaScript是一种单线程方法。这意味着无论如何，程序中必须只有一个任务在运行。容器是一种队列类型，它保存任务直到轮到它们被执行，被称为<em class="oe">事件队列</em>或<em class="oe">任务队列；</em>根据您阅读的文档，这可能会有所不同。</p><p id="5fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以被视为<em class="oe">正常任务</em>的任务示例有<code class="fe lv lw lx ly b">console.log(1)</code>、<code class="fe lv lw lx ly b">obj.foo()</code>或任何类似的非异步作业。</p><p id="0d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Promise是一个异步API。在运行时，JavaScript向承诺事件队列发送一个承诺任务(或基于承诺的任务)。并且承诺队列中的任务也必须等待轮到它们被调用。但是请注意，只有在正常任务完全为空的情况下，Promise队列中的任何任务才能被拉出并运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/0a90fc55fb41b81465c9fecfc185fffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m2LfVF-GFm_VNLxF6hOcdA.png"/></div></div></figure><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fc54" class="nh mh it ly b gy ni nj l nk nl">const banners = await fetch('/banners');<br/>const events = await fetch('/events');<br/>const notices = await fetch('/notices');</span></pre><p id="bf8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为每行都有<code class="fe lv lw lx ly b">await</code>关键字，所以Promise队列不能接收更多的任务。首先，执行<code class="fe lv lw lx ly b">fetch('/banners')</code>。程序等待其响应，并将下一个<code class="fe lv lw lx ly b">fetch</code>任务放入队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/d0e25fe8f215a5420de3b49965cdd670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RK5MT1q7yUVggtkAUB3sA.png"/></div></div></figure><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3581" class="nh mh it ly b gy ni nj l nk nl">const bannersFetch = fetch('/banner');<br/>const eventsFetch = fetch('/events');<br/>const noticesFetch = fetch('/notices');</span><span id="1a62" class="nh mh it ly b gy nm nj l nk nl">const banners = await bannersFetch;<br/>const events = await eventsFetch;<br/>const notices = await noticesFetch;</span></pre><p id="7536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个代码，所有三个<code class="fe lv lw lx ly b">fetch</code>都可以按照从上到下的顺序堆叠在承诺队列中。这些承诺将在几乎相同的时间被取出并执行(而正常队列是空的)，但是它们不必再等待前一个<code class="fe lv lw lx ly b">fetch</code>的响应。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dd69" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">演示</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh oi l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="06e4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="09da" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">async</code> / <code class="fe lv lw lx ly b">await</code>语法让我们的生活更加轻松愉快，但是我们应该好好使用它们。简单地把<code class="fe lv lw lx ly b">await</code>关键词放在某个地方可能会导致非常不同的结果，这取决于你把它放在哪里。</p></div></div>    
</body>
</html>