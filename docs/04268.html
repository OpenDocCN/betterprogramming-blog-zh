<html>
<head>
<title>Build a Rails API With JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JWT构建一个Rails API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-rails-api-with-jwt-61fb8a52d833?source=collection_archive---------2-----------------------#2020-04-02">https://betterprogramming.pub/build-a-rails-api-with-jwt-61fb8a52d833?source=collection_archive---------2-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae36" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用JavaScript Web令牌设置您的用户身份验证，以提高安全性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4c452754c3a3333b9e0e9495d7917daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VKPoLz0BokYh0Wuj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由约书亚·富勒(Unsplash)拍摄</p></figure><p id="cbbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是从头开始创建和设置Rails API应用程序的指南。</p><p id="a99d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重点将是用户登录和注册，并通过JWT对他们进行授权/认证。请记住，这种方法只是众多方法中的一种。让我们从设置开始。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bb10" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置</h1><p id="bea2" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们生成一个Rails API。从终端运行以下命令:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6454" class="ne md it na b gy nf ng l nh ni">rails new jwt-rails-api-app --database=postgresql --api</span></pre><p id="0e8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">包含标志<code class="fe nj nk nl na b">--database=postgresql</code>以指示<a class="ae lu" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>将被用作数据库，而不是<a class="ae lu" href="https://www.sqlite.org/" rel="noopener ugc nofollow" target="_blank"> SQLite </a>，并且包含标志<code class="fe nj nk nl na b">--api</code>以指示该应用将被设置为API，并且避免生成视图和视图助手，因为它们对于API不是必需的。</p><p id="9085" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打开新生成的文件夹，打开<code class="fe nj nk nl na b">Gemfile</code>。我们需要包括一些宝石作为设置的一部分。</p><p id="2931" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先是取消注释/包含:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="038e" class="ne md it na b gy nf ng l nh ni">gem 'bcrypt'</span></pre><p id="445c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Bcrypt 将为用户管理密码散列。</p><p id="47c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第二是取消注释/包含:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3d90" class="ne md it na b gy nf ng l nh ni">gem 'rack-cors'</span></pre><p id="fb7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这允许API中的跨源资源共享(CORS)。CORS阻止来自未知来源的API调用。</p><p id="cd67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，包括:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fc6b" class="ne md it na b gy nf ng l nh ni">gem 'jwt'</span></pre><p id="bbe9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从终端运行<code class="fe nj nk nl na b">bundle install</code>在应用程序中安装这三个gem。</p><p id="ad42" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，导航到<code class="fe nj nk nl na b">config/initializers/cors.rb</code>，取消对以下内容的注释，并用星号替换“example.com”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/160bb8be88d188bc98f316e11f88429e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RZblS9I87OdfmlYh.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克-奥二氏分级量表</p></figure><p id="977d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，导航到<code class="fe nj nk nl na b">config/routes.rb</code>。我们将为此应用程序定义可访问的路由。</p><p id="6b83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于本指南，我们将只关注处理登录、注册用户和自动登录的路由。我们将定义几个自定义路由来处理登录和自动登录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/89eab61ae7b6fb836574d40215817f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WWCjUSQvkGUHGqKPl6Opgg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">路线</p></figure><p id="ba75" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于本指南，我们将只关注为<code class="fe nj nk nl na b">User</code>生成控制器和模型。理想情况下，对其他人也可以采取同样的方法。</p><p id="6448" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从生成<code class="fe nj nk nl na b">User</code>的模型开始。我们需要一个<code class="fe nj nk nl na b">User</code>实例的以下属性:<code class="fe nj nk nl na b">:username</code>、<code class="fe nj nk nl na b">:password</code>和<code class="fe nj nk nl na b">:age</code>。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="619a" class="ne md it na b gy nf ng l nh ni">rails g model User username:string password_digest:string age:integer</span></pre><p id="9d8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只是需要注意一些事情。在<code class="fe nj nk nl na b">:password</code>中，如果bcrypt被实现，它将期望一个属性<code class="fe nj nk nl na b">password_digest</code>来散列密码。</p><p id="56be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">重要</strong> : <strong class="la iu"> </strong>为了确保该功能的实现，在<code class="fe nj nk nl na b">User</code>模型中定义用户宏<code class="fe nj nk nl na b">has_secure_password</code>。最后，用以下代码生成<code class="fe nj nk nl na b">User</code>控制器<strong class="la iu"> </strong>:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8fb9" class="ne md it na b gy nf ng l nh ni">rails g controller Users</span></pre><p id="20bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">User</code>的型号、控制器和路线现已设定。现在，让我们运行:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="0512" class="ne md it na b gy nf ng l nh ni">rails db:create &amp;&amp; rails db:migrate</span></pre><p id="e1db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于测试目的，我们可以在<code class="fe nj nk nl na b">db/seeds.rb</code>文件中创建一个<code class="fe nj nk nl na b">User</code>实例。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a8e4" class="ne md it na b gy nf ng l nh ni">user = User.create(username: "reizl", password: "sample", age: 27)</span></pre><p id="ec23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要播种数据库，运行<code class="fe nj nk nl na b">rails db:seed</code>。既然设置已经完成，我们有了要处理的数据，现在我们可以把注意力放在控制器的方法上了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3c2f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">应用控制器方法</h1><p id="6f77" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们关注一下应用程序控制器。该控制器中定义的方法可以在其他控制器中访问，如<code class="fe nj nk nl na b">User</code>。这里定义了许多方法，对用户进行身份验证和授权至关重要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="2035" class="ne md it bd me nq nr dn mi ns nt dp mm lh nu nv mo ll nw nx mq lp ny nz ms oa bi translated">编码_令牌</h2><p id="286f" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">先从<code class="fe nj nk nl na b">encode_token</code>说起吧。当稍后调用此方法时，对象将作为参数发送。</p><p id="b068" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将利用JWT gem提供的方法<code class="fe nj nk nl na b">encode</code>来生成令牌。<code class="fe nj nk nl na b">JWT.encode</code>有两个参数，<code class="fe nj nk nl na b">payload</code>对象和一个表示“秘密”的字符串。方法<code class="fe nj nk nl na b">encode_token</code>将返回由JWT生成的令牌。</p><p id="8bd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，对于其余的方法，从<code class="fe nj nk nl na b">authorized</code>开始解释并逐步向上会更有好处，考虑到这是它所需要的一连串事件。方法之间会有一些来回的跳跃。</p><p id="3f71" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在探索这些方法之前，宏<code class="fe nj nk nl na b">before_action :authorized</code>本质上是说，如果对这个API有任何请求，那么将总是首先调用方法<code class="fe nj nk nl na b">authorized</code>。</p><h2 id="9a4c" class="ne md it bd me nq nr dn mi ns nt dp mm lh nu nv mo ll nw nx mq lp ny nz ms oa bi translated">经授权的</h2><p id="8b9e" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">顾名思义，这个方法检查用户是否被授权。但是它依赖于一系列的方法。</p><p id="7c6c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果用户没有登录或者请求没有发送必要的凭证，这个方法将发回一个JSON响应，要求他们登录。为了确定该信息，调用方法<code class="fe nj nk nl na b">logged_in?</code>。</p><p id="5fbb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同样，顾名思义，它检查用户是否登录。<code class="fe nj nk nl na b">logged_in?</code>方法返回true或false，这取决于在它内部调用的另一个方法的返回值。</p><h2 id="da09" class="ne md it bd me nq nr dn mi ns nt dp mm lh nu nv mo ll nw nx mq lp ny nz ms oa bi translated">登录用户</h2><p id="d9ee" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">方法<code class="fe nj nk nl na b">logged_in_user</code>调用了另一个方法<code class="fe nj nk nl na b">decoded_token</code>。从<code class="fe nj nk nl na b">decoded_token</code>调用<code class="fe nj nk nl na b">auth_header</code>方法，该方法查看请求的信息。</p><p id="6c20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法只涉及报头，特别是“授权”的密钥。理想情况下，这将包含一个由JWT生成的令牌，并且将采用<code class="fe nj nk nl na b">Bearer &lt;token&gt;</code>的格式，这就是<code class="fe nj nk nl na b">auth_header</code>将返回的内容。</p><p id="cb1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了获得令牌，我们将在<code class="fe nj nk nl na b">Bearer &lt;token&gt;</code>上使用<code class="fe nj nk nl na b">.split(" ")[1]</code>方法。一旦令牌被获取并分配给令牌变量，JWT提供的<code class="fe nj nk nl na b">decode</code>方法将被使用。</p><p id="9588" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">JWT.decode</code>接受四个参数，要解码的令牌、编码时分配的秘密字符串、真值和算法(这里是‘hs 256’)。否则，如果有错误，它将返回nil。</p><p id="c6cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl na b">decoded_token</code>的返回值将代表来自<code class="fe nj nk nl na b">JWT.decode</code>的数组。我们只关心第一个索引，它将是一个键为“<code class="fe nj nk nl na b">user_id</code>”的对象(这将来自<code class="fe nj nk nl na b">User</code>的控制器)。</p><p id="728a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从“<code class="fe nj nk nl na b">user_id</code>”中，我们可以确定数据库中是否存在具有该特定ID的<code class="fe nj nk nl na b">User</code>实例。如果有，用户是“授权的”，如果没有，他们不是。</p><p id="7a67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(由于涉及一系列方法，请随意再读一遍。)</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="930a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用户控制器</h1><p id="ad02" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">现在，让我们把焦点转移到用户的控制器上。我们将关注用户登录、用户注册(创建用户)和用户的自动登录。许多方法依赖于应用程序控制器中定义的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ef52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们从宏<code class="fe nj nk nl na b">before_action :authorized, only: [:auto_login]</code>开始。</p><p id="7156" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与前面类似，我们声明如果在应用程序中访问任何路由，应用程序控制器中的<code class="fe nj nk nl na b">authorized</code>方法将首先运行。但只是具体到路线，<code class="fe nj nk nl na b">auto_login</code>。这意味着可以直接访问<code class="fe nj nk nl na b">create</code>或<code class="fe nj nk nl na b">login</code>。</p><h2 id="c7c5" class="ne md it bd me nq nr dn mi ns nt dp mm lh nu nv mo ll nw nx mq lp ny nz ms oa bi translated">创造</h2><p id="ae12" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当用户注册时，会在后端创建一个新的用户实例。将向<code class="fe nj nk nl na b">/users</code>发出一个POST请求，该请求将被重定向到用户控制器<code class="fe nj nk nl na b">create</code>方法。</p><p id="edfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们检查一下在<code class="fe nj nk nl na b">create</code>方法中发生了什么。</p><p id="5795" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建一个用户实例。如果有效，就用用户实例的id创建一个有效负载对象，并将其传递给在应用程序控制器中定义的<code class="fe nj nk nl na b">encode_token</code>方法。如果需要，有效负载对象可以包含多个键。</p><p id="1981" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，<code class="fe nj nk nl na b">encode_token</code>将返回一个由JWT生成的令牌字符串。JSON对象使用用户和令牌的键值对作为响应来呈现。</p><h2 id="b1b9" class="ne md it bd me nq nr dn mi ns nt dp mm lh nu nv mo ll nw nx mq lp ny nz ms oa bi translated">注册</h2><p id="7395" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">当现有用户登录时，会实现类似的方法。但是，一个POST请求将被发送到<code class="fe nj nk nl na b">/login</code>，该请求将被重定向到用户控制器<code class="fe nj nk nl na b">login</code>方法。</p><p id="0cd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不同之处在于，我们使用<code class="fe nj nk nl na b">find_by</code>方法从传递的参数中检查现有的用户实例，特别是用户名。然后，<code class="fe nj nk nl na b">bcrypt</code>提供的<code class="fe nj nk nl na b">authenticate</code>方法比较从params传递的密码和存储在数据库中的密码是否匹配。</p><p id="e39b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果用户实例和authenticate方法都通过了，那么JWT将生成一个令牌，并使用用户和令牌的键值对呈现一个JSON对象，然后作为响应发送出去。</p><h2 id="c882" class="ne md it bd me nq nr dn mi ns nt dp mm lh nu nv mo ll nw nx mq lp ny nz ms oa bi translated">自动登录</h2><p id="4bc1" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">让我们检查位于用户控制器中的<code class="fe nj nk nl na b">auto_login</code>方法。</p><p id="f0d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里真的没什么事情。最大的问题是变量<code class="fe nj nk nl na b">@user</code>从何而来？</p><p id="8fa4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于方法<code class="fe nj nk nl na b">authorized</code>将在<code class="fe nj nk nl na b">auto_login</code>之前运行，应用控制器<strong class="la iu"> </strong>中的方法链也将运行。方法之一<code class="fe nj nk nl na b">logged_in_user</code>将返回一个可访问的全局<code class="fe nj nk nl na b">@user</code>变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6452" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="83cb" class="pw-post-body-paragraph ky kz it la b lb mu ju ld le mv jx lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">定义好路线和方法后，我们的Rails API就设置好了！我们可以使用<code class="fe nj nk nl na b">rails s</code>或<code class="fe nj nk nl na b">rails s -p 4000</code>来运行我们的服务器(如果你想在不同的端口上运行的话)。</p><p id="e282" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了测试路由和功能，我们可以利用<a class="ae lu" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>或者从客户端应用程序(比如React)进行连接。本指南不包括测试路由和功能。</p><p id="3ff2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本指南主要介绍如何设置一个rails API，该API集成了bcrypt散列和JWT来处理用户认证/授权。</p><p id="3cf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它还涵盖了实现方法背后的逻辑过程。希望本指南已经为使用JWT构建Rails API提供了指导。感谢您的阅读！</p><p id="3f3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有关详细信息，请参考我的存储库:</p><ul class=""><li id="2c77" class="ob oc it la b lb lc le lf lh od ll oe lp of lt og oh oi oj bi translated"><a class="ae lu" href="https://github.com/reireynoso/jwt-rails-api-template" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li></ul></div></div>    
</body>
</html>