<html>
<head>
<title>UIKit or SwiftUI: Which Should You Use in Production?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">UIKit和SwiftUI:在生产中应该使用哪个？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/uikit-or-swiftui-which-should-you-use-in-production-f57258bc6ad5?source=collection_archive---------9-----------------------#2020-10-07">https://betterprogramming.pub/uikit-or-swiftui-which-should-you-use-in-production-f57258bc6ad5?source=collection_archive---------9-----------------------#2020-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="46dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI准备好上线了吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0f77d8e522335a6e2c7fd953ddf43911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uqSWA_30Auiz_7F4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马里奥·多贝尔曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="68b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">苹果最近发布了iOS 14，这意味着SwiftUI已经有了一年的缓冲期，不仅可以被爱好者在他们的宠物项目中采用，还可以被企业团队在他们的商业应用中采用。</p><p id="a69f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字面上大家都说写SwiftUI代码很好玩，但是SwiftUI到底是玩具还是专业工具？如果我们想认真对待它，我们需要考虑它作为工具的稳定性和灵活性，而不是作为玩具。</p><p id="cbc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在生产代码中什么时候开始使用SwiftUI比较合适？</p><p id="f257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在2020年到2022年之间开始一个新的重大项目，这个问题很难回答！</p><p id="4ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管SwiftUI带来了所有的创新，即使到了iOS 14，我们<a class="ae ky" href="https://steipete.com/posts/state-of-swiftui/" rel="noopener ugc nofollow" target="_blank">仍然有漏洞，缺乏定制的灵活性</a>。</p><p id="30c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这可以通过情景调用UIKit来缓解，但您能估计最终有多少代码会用UIKit编写吗？从长远来看，SwiftUI会成为一种负担吗？在这种情况下，你最好用UIKit写所有的东西。</p><p id="5877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只能赌iOS 15不会有SwiftUI的问题。意味着最多到2022年(随着iOS 16的发布)，我们才会有一个放松和充分信任SwiftUI的完美时刻。</p><p id="214a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将在两个场景中阐述如何构建项目:</p><ol class=""><li id="3d30" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">您正在支持iOS 11或12，但考虑在可预见的未来将应用程序迁移到SwiftUI。</li><li id="11a8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">您正在支持iOS 13+,但希望控制与SwiftUI相关的风险，并能够无缝地回退到UIKit。</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="383f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">粘性UI框架</h1><p id="98a0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">历史上，UI框架是移动应用架构的核心。我们占领了UIKit，并围绕它建造了一切。</p><p id="3e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑一下你上一个UIKit项目，试着评估一下要完全摆脱UIKit并用另一个UI框架代替它需要多少努力，比如<a class="ae ky" href="https://github.com/texturegroup/texture/" rel="noopener ugc nofollow" target="_blank"> AsyncDisplayKit </a>？</p><p id="7ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于大多数项目来说，这意味着完全重写。</p><p id="0b1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Web工程师会嘲笑我们，因为他们总是有大量的UI框架。因此，他们学会了应用“依赖规则”,并将UI视为系统中的外围“细节”,就像他们使用的数据库的具体类型一样。</p><p id="7d3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是否意味着我们这些移动开发者没有将UI从业务逻辑中分离出来？我们做到了，对吗？MVC，MVVM，毒蛇等等。在那里帮助我们，但我们还是被困住了。</p><p id="24d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">移动应用很少负责任何核心业务逻辑，例如计算贷款利息和批准贷款。企业希望最小化这里的众多风险，所以他们在后端运行这样的逻辑。</p><p id="81db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，现代移动应用程序上运行着大量的业务逻辑，但这种逻辑是不同的。它只是更关注表现形式，而不是业务运行的核心规则。</p><p id="4c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们需要更好地将表示相关的业务逻辑从我们使用的UI框架的细节中分离出来。</p><p id="d203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们做不到这一点，难怪框架会被完整地嵌入到代码库中。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="9ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UIKit和SwiftUI的API对于代码库都是粘性的。这些框架正在推动开发人员使它们超级集中，绑定到所有东西，直接用在根本不是UI的地方！</p><p id="6c6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以SwiftUI中的<code class="fe nn no np nq b">@FetchRequest</code>为例。它将<code class="fe nn no np nq b">CoreData</code>模型细节混合在表示层中。看起来很方便。但同时，这也是对CS中多个软件设计原则和最佳实践的重大违反。这种代码在短期内节省了时间，但从长远来看，可能会对项目造成重大损害。</p><p id="3b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">@AppStorage</code>怎么样？UI层中的数据IO操作。你如何测试它？你能容易地识别容器中的键名冲突吗？您能否将它无缝迁移到另一种数据存储类型，如Keychain？</p><p id="24f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，开发速度被最大化，质量保证、可维护性和代码重用被忽略。</p><p id="53c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有屏幕走线呢？</p><p id="75a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UIKit总是小声对我们说:“嘶！就用<code class="fe nn no np nq b">presentViewController(:, animated:, completion:)</code>；别烦那些讨厌的协调员！”</p><p id="72a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，SwiftUI并没有窃窃私语。它冲着我们尖叫:“听着。你要么照我说的做，要么我就用最精细的方法杀了你全家！”(*)</p><p id="be13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有办法保护我们的代码库免受这些野蛮API的攻击？</p><p id="8a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然可以！</p><p id="e2cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(*)令人尖叫的API通常是一件好事——程序员犯错误的机会更少了。然而，当这些API不能正常工作时，就会成为一个巨大的问题，例如SwiftUI有问题的编程导航。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c611" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">分离用户界面层</h1><p id="772b" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如你所见，框架到处都有陷阱。</p><p id="3ed0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你咬的钩子越多，就越难在特定的屏幕或整个应用上放弃使用这个框架。</p><p id="eec2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们希望系统足够坚固，能够从UIKit过渡到SwiftUI(反之亦然),我们需要确保UI和系统其余部分之间的边界不是木栅栏，而是长城！</p><p id="8d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何东西都不应该溜进来，甚至是字符串格式。</p><p id="13ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你能在没有UIKit或SwiftUI的情况下将一个float 5434.35转换成“$5，434.35”吗？太好了——让我们在别处做吧！</p><p id="156b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">框架中用于屏幕路由的API是否强加了视图的紧密耦合？我们需要引入一个边界来隔离它们。</p><p id="a978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不仅需要从UI层提取尽可能多的逻辑，还需要使UIKit组件及其SwiftUI对应组件与它们所插入的套接字完全兼容。</p><p id="101b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何让UIKit和SwiftUI达到一个共同的标准？</p><p id="dfb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道SwiftUI完全是数据驱动的，由反应式数据绑定提供支持。幸运的是，UIKit可以用MVVM和反应式框架来扭曲。</p><p id="87bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着数据源、委托、目标动作和UIKit APIs的其余部分应该在UI层中隔离。</p><p id="021d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线条<code class="fe nn no np nq b">import UIKit</code>不应该出现在任何视图模型及更远的地方。</p><p id="5a72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该注意到，只要UI组件是完全数据驱动的，屏幕模块的确切架构模式就不重要。为了便于举例，我将在本文中提到MVVM。</p><p id="c3a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在。我们应该为视图模型使用哪个反应式框架？我们知道SwiftUI只与<a class="ae ky" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a>一起工作，而UIKit最好由RxCocoa支持。</p><p id="e3e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种方式都有可能，所以这个要看你能不能支持iOS 13 (Combine)以及你有多爱RxSwift。</p><p id="3e41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者兼顾吧！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="3f57" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">RxSwift和SwiftUI之间的桥梁</h1><p id="0673" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Combine从iOS 13开始提供，对于那些仍然需要支持iOS 11或12的人来说，这是一个交易破坏者。</p><p id="8674" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我讲一个从(UIKit + RxSwift)迁移到(SwiftUI + RxSwift)的简单方法。</p><p id="729b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这个最小的设置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="7b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图是数据驱动的:视图模型完全控制视图的状态变化。</p><p id="eafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在不接触ViewModel代码的情况下将这个屏幕迁移到SwiftUI。</p><p id="461e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以让它工作:</p><ol class=""><li id="e6b4" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">定义一个新的<code class="fe nn no np nq b">ObservableObject</code>，其中的<code class="fe nn no np nq b">@Published</code>变量被绑定到来自原始视图模型的<code class="fe nn no np nq b">Driver</code>(或<code class="fe nn no np nq b">Observable</code>)。</li><li id="1757" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">在SwiftUI的视图中调整每个<code class="fe nn no np nq b">Driver</code>到<code class="fe nn no np nq b">Publisher</code>并绑定到<code class="fe nn no np nq b">@State</code>。</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ad1b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将可观察对象绑定到@Published</h1><p id="aecf" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对于第一种方法，我们需要创建一个新的<code class="fe nn no np nq b">ObservableObject</code>来反映原始视图模型中的每个可观察变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1d83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原始视图模型和适配器之间的值绑定代码应该尽可能简洁。下面是<code class="fe nn no np nq b">Driver</code>和<code class="fe nn no np nq b">Observable</code>的桥接情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="803d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们所需要的是来自RxSwift的一个<code class="fe nn no np nq b">Binder</code>，它将值分配给特定的<code class="fe nn no np nq b">@Published</code>值。下面是执行桥接的<code class="fe nn no np nq b">binder</code>函数的一个片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b91c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到我们的视图模型，您可以在<code class="fe nn no np nq b">Adapter</code>初始化中进行绑定:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的一个缺点是样板代码必须为你拥有的每个<code class="fe nn no np nq b">@Published</code>变量重复。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6fd7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将可观察对象绑定到@State</h1><p id="16a0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">第二种方法需要更少的设置代码，并且基于SwiftUI视图消费外部状态的另一种方式:<code class="fe nn no np nq b">onReceive</code> view modifier，为local <code class="fe nn no np nq b">@State</code>赋值。</p><p id="1fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的美妙之处在于我们可以在SwiftUI视图中直接使用原始的ViewModel:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="0bba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">viewModel.isLoadingData</code>是一个<code class="fe nn no np nq b">Driver</code>，所以我们需要将它从Combine转换成一个<code class="fe nn no np nq b">Publisher</code>。</p><p id="2aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">社区已经提出了<a class="ae ky" href="https://github.com/CombineCommunity/RxCombine" rel="noopener ugc nofollow" target="_blank"> RxCombine </a>库，它允许从<code class="fe nn no np nq b">Observable</code>到<code class="fe nn no np nq b">Publisher</code>的桥接，所以扩展它以支持<code class="fe nn no np nq b">Driver</code>很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="f2ca" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">将UIKit与联合收割机连接</h1><p id="6b48" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果你支持iOS 13+，你可以考虑使用Combine来构建应用程序中的网络和其他非UI模块。</p><p id="5d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管将Combine与UIKit绑定有些不方便，但从长远来看，当您的项目完全迁移到SwiftUI时，选择Combine作为驱动应用程序中数据的核心框架应该是有回报的。</p><p id="267f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，您可以在<code class="fe nn no np nq b">sink</code>功能中更新UIKit视图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="4e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者您可以使用前面提到的RxCombine库将<code class="fe nn no np nq b">Publisher</code>转换为<code class="fe nn no np nq b">Observable</code>，充分利用RxCocoa中可用的数据绑定:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我应该注意，如果我们选择Combine作为应用程序中的主要反应框架，RxSwift、RxCocoa和RxCombine的使用应该仅限于UIKit视图的数据绑定，因此我们可以轻松地摆脱这些依赖关系以及应用程序中的最后一个UIKit视图。</p><p id="05fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，ViewModel应该用just Combine构建(no <code class="fe nn no np nq b">import RxSwift</code>！).</p><p id="37a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重温最初的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9b12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当需要在SwiftUI中重建这个屏幕时，一切都会为您设置好:在ViewModel中不需要做任何更改。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b216" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">关于路由的思考</h1><p id="dc6e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在过去，我已经探索过<a class="ae ky" href="https://nalexn.github.io/swiftui-deep-linking/" rel="noopener ugc nofollow" target="_blank">编程导航</a>在SwiftUI中是如何工作的，根据我的经验，这是SwiftUI中仍然遭受各种故障和崩溃以及缺乏动画定制的部分。</p><p id="e71e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">久而久之，这个问题肯定会解决的，但是现在，我不会把路由交给SwiftUI。</p><p id="9c54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当选择退出SwiftUI的路由时，我们不会失去太多。只要SwiftUI由UIKit支持，与我们使用UIKit所能实现的相比，就不会有积极的性能差异。</p><p id="68a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我为本文构建的示例项目中，我使用了传统的协调器模式(MVVM-R ),这种模式对于用SwiftUI的<code class="fe nn no np nq b">UIHostingController</code>构建的屏幕来说工作得很好。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="464d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="8f21" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如果我们想要控制与使用特定UI框架相关的风险，我们应该付出额外的努力来控制它在代码库中的扩展。</p><p id="b224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI的现有问题不应该阻止您至少在可预见的将来准备好您的项目迁移到这个框架。</p><p id="2757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从UI层提取尽可能多的业务逻辑，并使您的UIKit屏幕数据驱动。这样一来，迁移到SwiftUI将变得轻而易举。</p><p id="5043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经构建了一个<a class="ae ky" href="https://github.com/nalexn/uikit-swiftui" rel="noopener ugc nofollow" target="_blank">示例项目</a>，它带有普通的登录/主页/详细信息屏幕，展示了UIKit和SwiftUI视图如何成为一个外围虚拟详细信息，可以很容易地分离和替换。</p><p id="f955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两个目标——一个运行在UIKit上，另一个运行在SwiftUI上，两者共享代码库的基本部分。</p></div></div>    
</body>
</html>