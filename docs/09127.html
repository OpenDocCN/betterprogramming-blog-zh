<html>
<head>
<title>Why You Probably Shouldn’t Invent a New Query Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么你不应该发明一种新的查询语言</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-you-probably-shouldnt-invent-a-new-query-language-8073370f462c?source=collection_archive---------12-----------------------#2021-07-16">https://betterprogramming.pub/why-you-probably-shouldnt-invent-a-new-query-language-8073370f462c?source=collection_archive---------12-----------------------#2021-07-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e47a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ORM并不总是有用的。找出原因以及你能做些什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7eb02111d688e308167c4069c7076c2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7U6bajTJgRiLFnTz.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><blockquote class="ky"><p id="4721" class="kz la it bd lb lc ld le lf lg lh li dk translated"><em class="lj">“比数据孤岛更糟糕的是什么？发明自己的查询语言的数据孤岛。”——埃里克·伯恩哈德松</em></p></blockquote><p id="e104" class="pw-post-body-paragraph lk ll it lm b ln lo ju lp lq lr jx ls lt lu lv lw lx ly lz ma mb mc md me li im bi translated">在他臭名昭著且被广泛讨论的名为“<a class="ae mf" href="https://erikbern.com/2018/08/30/i-dont-want-to-learn-your-garbage-query-language.html" rel="noopener ugc nofollow" target="_blank">我不想学你的垃圾查询语言</a>”，<a class="ae mf" href="https://erikbern.com/" rel="noopener ugc nofollow" target="_blank">埃里克·伯恩哈德松</a>的博客文章中，表达了许多其他数据工程师和分析师强烈关注的问题，即他“真的不喜欢发明自己的查询语言的软件”，他“只是想要回他的SQL”。</p><p id="f54b" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">这个相当简短但充满激情的咆哮总结了几乎普遍的经验，即需要自己语言的技术通常会产生一套全新的、不同的复杂性。</p><p id="2169" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">在过去的十年中，不同类型的数据库呈爆炸式增长(看看我上一篇文章中<a class="ae mf" href="https://arctype.com/blog/newsql/" rel="noopener ugc nofollow" target="_blank">NoSQL数据库类型的数量就知道了)，专业化程度的提高迫使数据工程师和分析师学习更多的新编程语言。</a></p><p id="5461" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">它们都有自己的语法和特殊的古怪之处，虽然ORM有时会有所帮助，但它们通常会让事情变得更加困难。</p><p id="5959" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">也就是说，新的查询语言通常是必要的(就像NoSQL数据库的情况)。这就引出了一个问题，那就是我们如何判断一门新语言实际上增加的价值是否大于它带来的问题。要回答这个问题，我们需要深入了解是什么导致了所有这些冲突。</p><h1 id="de3e" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">为什么查询语言这么多？</h1><p id="9b72" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me li im bi translated">有许多查询语言——如此之多，以至于即使是最全面的列表<a class="ae mf" href="https://github.com/AnanthaRajuC/List-of-programming-language-lists/blob/master/Query%20language.md" rel="noopener ugc nofollow" target="_blank">也遗漏了许多重要的参与者。我甚至不想尝试收集这样的列表，因为似乎每分钟都有新的列表添加进来。所以我们来看看是什么原因造成的。</a></p><p id="8fa5" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">简而言之，有这么多不同的查询语言，因为有这么多不同的东西要查询。此外，数据通常必须存储在各种模型中，具有不同种类的模式以及物理和逻辑模式之间不同程度的分离。例如，存储在关系数据库中的数据与存储在JSON文件中的数据需要不同的技术和语法。</p><p id="8134" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">早期的分层或网络数据库查询语言看起来与关系查询语言非常不同。在数据库的早期，人们必须显式地导航记录之间的路径。这也解释了为什么过去十年由于NoSQL带来的新挑战而特别富有成果。</p><p id="5b66" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">即使在关系数据库中，不同的供应商也希望通过他们自己的SQL方言(T-SQL、PostgreSQL等)提供特殊的特性和功能。).</p><p id="ebcd" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">所有这些加起来很快，回想起来，我们最终不可避免地会有无数种选择来存储和查询数据。总的来说，这实际上是一件很好的事情，因为这样，通过竞争可以不断提高。</p><p id="9032" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">然而，由于太多不同的查询语言而导致开发缓慢，因此发明了对象关系映射器(ORM)。但是，正如我们将要看到的，它们也常常使事情变得更加复杂。</p><h1 id="7150" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">为什么ORM并不总是有用</h1><p id="109d" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me li im bi translated">让我们首先深入了解一下什么是ORM，以及为什么您可能想要使用它们。</p><p id="e6a9" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">对象关系映射是计算机科学中经常使用的一个过程，通过面向对象编程语言在不兼容的<a class="ae mf" href="https://en.wikipedia.org/wiki/Type_system" rel="noopener ugc nofollow" target="_blank">类型系统</a>之间转换数据。目标是创建一个数据库对象的抽象数据库层，然后可以使用您选择的编程语言对其进行查询。</p><p id="fefb" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">简而言之，它允许您使用自己选择的语言而不是数据库的查询语言与数据库进行交互。这可以通过一个使用SQL的快速示例得到最好的解释:</p><p id="fece" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated"><code class="fe ni nj nk nl b">SELECT * FROM users WHERE name = 'Jane Doe';</code></p><p id="1f81" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">对象关系映射的思想是使用您喜欢的编程语言的面向对象范例编写类似上面的查询以及更复杂的查询。这就是ORM的用武之地。ORM库在不同的编程语言中实现了这种技术。例如，使用一个JavaScript ORM，上面的查询看起来像这样:</p><pre class="kj kk kl km gt nm nl nn no aw np bi"><span id="b6b5" class="nq mm it nl b gy nr ns l nt nu">var orm = require('generic-orm-library');var user = orm("users").where({ name: 'Jane Doe' });</span></pre><p id="6eb5" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">当然，使用ORM可以带来很多好处:</p><ul class=""><li id="1b25" class="nv nw it lm b ln mg lq mh lt nx lx ny mb nz li oa ob oc od bi translated"><strong class="lm iu">没有SQL </strong>:如果你已经阅读了<a class="ae mf" href="https://arctype.com/blog/reimagining-the-sql-curriculum/" rel="noopener ugc nofollow" target="_blank">我关于学习SQL </a>的博客文章，但是仍然不相信你应该学习SQL，那么ORMs允许你使用你选择的编程语言。</li><li id="4ba5" class="nv nw it lm b ln oe lq of lt og lx oh mb oi li oa ob oc od bi translated">没有方言:ORM抽象了数据库系统，例如，从MySQL转换到PostgreSQL要容易得多。</li><li id="ce56" class="nv nw it lm b ln oe lq of lt og lx oh mb oi li oa ob oc od bi translated"><strong class="lm iu">额外特性</strong>:一些ORM具有高级特性，比如对事务、连接池、迁移、种子和流的支持，这些特性在某些情况下很有用。</li><li id="ac96" class="nv nw it lm b ln oe lq of lt og lx oh mb oi li oa ob oc od bi translated">性能:如果你真的不擅长SQL，那么对于某些查询，ORM会比你表现得更好。</li></ul><p id="fca8" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">正如您可能已经从本节的标题中推断出的那样，也有许多缺点:</p><ul class=""><li id="5729" class="nv nw it lm b ln mg lq mh lt nx lx ny mb nz li oa ob oc od bi translated"><strong class="lm iu">性能:</strong>如果你是SQL高手，你可以自己编写更高性能的查询。</li><li id="23af" class="nv nw it lm b ln oe lq of lt og lx oh mb oi li oa ob oc od bi translated"><strong class="lm iu">学习</strong>:ORM不像普通的查询语言那样工作，所以如果那是你所习惯的，学习如何使用它们是有开销的。</li><li id="3bc9" class="nv nw it lm b ln oe lq of lt og lx oh mb oi li oa ob oc od bi translated"><strong class="lm iu">太多</strong>:当你仅仅考虑<a class="ae mf" href="https://en.wikipedia.org/wiki/List_of_object%E2%80%93relational_mapping_software" rel="noopener ugc nofollow" target="_blank">有多少</a>种不同的ORM并且每种都有自己的学习过程时，学习问题只会变得更糟。</li><li id="3363" class="nv nw it lm b ln oe lq of lt og lx oh mb oi li oa ob oc od bi translated"><strong class="lm iu">配置</strong>:ORM的初始配置可能需要很长时间，而且很痛苦。</li><li id="7435" class="nv nw it lm b ln oe lq of lt og lx oh mb oi li oa ob oc od bi translated"><strong class="lm iu">黑盒</strong>:ORM提供的抽象层可能会阻碍真正的查询问题或数据库问题的解决。</li></ul><p id="4bf4" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">总而言之，ORM声称的好处是它们通过增加一个抽象层减少了开发时间，但是它经常产生更大的麻烦。不使用SQL，您现在必须在一些ORM文档中来回滚动，以确定如何编写最基本的查询。调试也可能是一个问题，因为正如Erik所说，有时ORM会将一个查询“转换成使用全表扫描连接17个表的怪物”，最终会得到“臃肿的高级数据类，而不是易于理解的元组或字典，这些元组或字典包含的数据是一种简单的哑格式，很容易进行内省。”</p><p id="fc60" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">所以ORM是有用的，但不一定能解决根本问题:已经有太多的查询语言了。那么能做些什么呢？我们是否应该听从Erik的建议，将“发明新的查询语言暂停30年”？</p><h1 id="d15f" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">什么时候应该发明一种新的查询语言？</h1><p id="9f53" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me li im bi translated">虽然Erik呼吁暂停肯定更像是一个玩笑，而不是一个严肃的解决方案(我认为)，但它确实表达了一种情绪，即我们需要停止如此快速地添加如此多的查询语言。</p><p id="f0c2" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">当然，我们知道其中许多是处理新的数据类别、新的数据存储方式或太多新数据所必需的，但是我们如何知道哪些是必需的，哪些不是呢？</p><p id="e59d" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">这就是为什么我为那些想加入查询语言生态系统的新开发人员建议一些简单的指导性问题和规则:</p><h2 id="a2dd" class="nq mm it bd mn oj ok dn mr ol om dp mv lt on oo mx lx op oq mz mb or os nb ot bi translated">我的语言只是另一种方言吗？</h2><p id="2228" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me li im bi translated">这一点似乎太明显了，但是即使像Oracle和Microsoft这样的大型组织也不能完全遵循这一规则，从而导致了T-SQL和PL/SQL这样的方言。</p><p id="7eba" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">在这一点上，几乎每个数据库都有自己定义存储过程、函数、触发器的方式，其差异甚至比查询和数据定义更明显。</p><p id="d9d9" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">例如，Sybase和SQL Server的脚本语言称为T-SQL。严格来说，SQL Server是数据库，T-SQL是语言，但在提到代码时，这两者经常互换使用。</p><p id="a81e" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">MySQL的脚本语言与T-SQL截然不同，这可以从<a class="ae mf" href="https://dev.mysql.com/doc/refman/5.7/en/language-structure.html" rel="noopener ugc nofollow" target="_blank">参考</a>手册的文档中看出。您可能会遇到的第一个主要区别是<code class="fe ni nj nk nl b">IF</code>只允许在编程块中使用。第二个将是定界符，然后是单词<code class="fe ni nj nk nl b">go</code>，并且差异从那里倍增。</p><p id="4b2f" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">所以请不要再创造另一种SQL方言。这并不意味着我们不应该迭代和改进SQL，但是不要尝试做一些没有人要求的不必要的事情，因为没有人会费心去学习它。</p><h2 id="fcdb" class="nq mm it bd mn oj ok dn mr ol om dp mv lt on oo mx lx op oq mz mb or os nb ot bi translated">我的语言能解决任何新问题吗？</h2><p id="2c9f" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me li im bi translated">这条规则与第一条非常相似，只是适用范围更广。有许多数据库和数据类型是标准SQL无法完成的。图形数据库就是一个很好的例子，因为在这种情况下，存储和语言都是专门设计来做关系数据库不能做的事情的。</p><p id="56c5" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">这并不意味着您应该将已经非常流行的Cypher等成熟的图形查询语言加入到列表中。它由Neo4j创建，用于他们自己的图形数据库，并最终开源为一个名为<a class="ae mf" href="https://www.opencypher.org/" rel="noopener ugc nofollow" target="_blank"> openCypher </a>的独立项目，允许任何数据库实现相同的语言。它非常直观，使用ASCII字符来制作形状，以便进行简洁而富有表现力的查询。</p><p id="9dc4" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated"><code class="fe ni nj nk nl b">MATCH (d:Database)-[:USES]-&gt;(Cypher)-[:QUERIES]-&gt;(:Model:Graph)</code></p><p id="3a3b" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">另一种广泛使用的图查询语言是SPARQL，它看起来像SQL，由W3C创建，用于查询RDF图模型。它不像其他两种语言那样常见，但由于主-谓-宾数据模型，它具有独特的特征。它甚至可以用于具有按照RDF结构建模的表的SQL数据库。一些图形数据库也支持自己的语言，如ArangoDB、DGraph、TigerGraph等。</p><p id="63ec" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">目前最常见的图形查询语言是<a class="ae mf" href="http://tinkerpop.apache.org/gremlin.html" rel="noopener ugc nofollow" target="_blank"> Gremlin </a>，它是<a class="ae mf" href="http://tinkerpop.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache TinkePop </a>图形计算框架的一部分。它编写简单，易于学习，并被许多图形数据库甚至可以模拟图形查询的非图形数据库广泛支持。另一方面，对于长查询来说，它可能有些冗长，但是对于OLTP和分析工作来说，它通常工作得很好。</p><p id="a4f2" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated"><code class="fe ni nj nk nl b">g.V().has("lang","gremlin").out("supported_by").values("db_name")</code></p><p id="2211" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">也就是说，国际标准图形查询语言的时机已经成熟。包括Neo4j、TigerGraph在内的行业厂商都把这个叫出来了，我肯定是同意的。随着图形继续被广泛采用，我们肯定已经达到了这个行业的临界点，在这一点上，添加另一种语言可能弊大于利。</p><h2 id="d972" class="nq mm it bd mn oj ok dn mr ol om dp mv lt on oo mx lx op oq mz mb or os nb ot bi translated">我的语言好用吗？</h2><p id="275c" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me li im bi translated">如果你已经做到了这一步，并且你的语言解决了一个前无古人的新颖用例，那么你可能真的有理由开发自己的查询语言——这就是为什么最后一个问题关注于你应该如何去做。</p><p id="2e21" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">问问自己“别人要多久才能学会我的新语言？”如果你的答案是“几个星期”，那么你应该开始花大量时间尽可能地简化你的语法。</p><p id="ba8d" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">这不仅仅意味着创建教程和文档，它们应该是不言自明的。相反，这意味着你必须认真努力提供过程和抽象，让新手学会你的语言并在几个小时内解决你的主要用例，如果不是几分钟的话。</p><p id="5ab8" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">如果你认为你做不到，你的语言可能还没有准备好。</p><h1 id="b2cf" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">结论</h1><p id="5d9b" class="pw-post-body-paragraph lk ll it lm b ln nd ju lp lq ne jx ls lt nf lv lw lx ng lz ma mb nh md me li im bi translated">SQL是当今最普遍的编程语言之一，但无数其他语言也值得认可。这些语言通常与解决关系数据库无法解决的用例的特定技术联系在一起。</p><p id="aab7" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">然而，这导致了查询语言的过度生产，由于陡峭的学习曲线，这大大减慢了开发时间。ORMs的引入是为了解决这个问题，但最终却让事情变得更加复杂。</p><p id="2663" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">这就是为什么聪明的开发人员应该小心不要在混合中引入另一种查询语言。为了指导这个决定，我列出了他们应该问自己的一些关键问题，以便更好地了解现有的生态圈、用例以及简单性。</p><p id="7f12" class="pw-post-body-paragraph lk ll it lm b ln mg ju lp lq mh jx ls lt mi lv lw lx mj lz ma mb mk md me li im bi translated">也就是说，没有什么比使用优秀的旧SQL更好的了。</p></div></div>    
</body>
</html>