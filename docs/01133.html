<html>
<head>
<title>An Introduction to Prisma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Prisma简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-prisma-5631e4eb0e38?source=collection_archive---------16-----------------------#2019-08-16">https://betterprogramming.pub/an-introduction-to-prisma-5631e4eb0e38?source=collection_archive---------16-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Prisma最重要的概念和构建示例应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b6a8c36fb84634cefed9f479f59e05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y32eOZKLj8TvGCd_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kevnbhagat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯文·巴加</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prisma是一个现代的ORM替代品，它将数据库变成了一个全功能的GraphQL、REST或gRPC API。它提供了强大的抽象和构建块来开发灵活和可伸缩的后端。</p><p id="d1aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看Prisma最重要的概念，甚至构建一个示例应用程序来给你一些使用它的练习。每当我们看实际例子时，我们都将关注GraphQL。</p><p id="a20a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，不要再浪费时间了，让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3d86" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么关心Prisma</h1><p id="8904" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，问题仍然是为什么你应该首先使用Prisma。以下是开发人员应该考虑使用Prisma的一些原因，以及它可以有所帮助的地方。</p><h2 id="22b8" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">类型安全</h2><p id="3628" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma提供了一个类型安全的API，可以从前端和后端使用，包括过滤器、聚合和事务。这极大地增强了ide的智能自动完成或跳转到定义的特性，也使得代码生成更加容易。</p><h2 id="e7e8" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">SDL(模式定义语言)</h2><p id="40fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma允许您使用现代SDL定义您的模型，并自动迁移您的底层数据库。它提供了一种简洁而强大的方式来指定您的GraphQL模式。欲了解更多信息，请参考Prisma官方博客上的这篇文章。</p><h2 id="0e44" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">简单的数据库工作流</h2><p id="e07c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma的总体目标是通过提供以下功能来消除数据库工作流程的复杂性并简化应用程序中的数据访问:</p><ul class=""><li id="4305" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">用于处理关系数据的简单而强大的API</li><li id="bc1a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">使用Prisma Admin进行可视化数据管理</li><li id="766e" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">自动数据库迁移</li><li id="95b7" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">轻松导入和导出数据</li></ul><h2 id="31fd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">清洁和分层架构</h2><p id="cd62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma提供了一个干净的架构，它尊重同步、查询优化/性能和安全性。它通过提供内置的DAT(数据访问层)来实现这一点，DAT用于抽象数据库访问的复杂性，以便开发人员可以专注于他们的数据，而不是担心如何从数据库中存储和检索数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/53e0f12f21f07dfe3447a98cee5fec99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sEejmC21KDazZbyM.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">棱镜建筑</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6463" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据模型</h1><p id="9718" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">数据模型定义了底层数据库模式，因此是Prisma客户端所有自动生成的CRUD操作的基础。</p><p id="d602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据模型是使用GraphQL SDL的子集编写的，并使用。prisma文件扩展名。这些文件需要在您的<code class="fe oa ob oc od b">datamodel</code>属性下的<code class="fe oa ob oc od b">prisma.yml</code>文件中引用。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="5c4c" class="mz md it od b gy oi oj l ok ol">datamodel: datamodel.prisma</span></pre><h2 id="f603" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">积木</h2><p id="3f1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们来看看数据模型的构建模块:</p><ul class=""><li id="b8f4" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">类型—类型由多个具有类型的字段组成，通常代表应用程序域中的实体(例如，用户、任务)。每种类型都映射到一个数据库表，并具有自动生成的CRUD操作。</li><li id="323b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">指令——指令用于为我们的数据模型中的类型提供额外的信息或添加特定的行为。</li><li id="3e6a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">关系—关系描述两种类型之间的关系。</li></ul><h2 id="7d0b" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">示例:</h2><p id="a223" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个简单的<code class="fe oa ob oc od b">database.prisma</code>文件的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4c34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该示例包含数据模型的几个重要概念:</p><ul class=""><li id="747c" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">用户和帖子之间的一对多关系</li><li id="15bd" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">按照<code class="fe oa ob oc od b">!</code>操作符的指示，所有字段都是必需的</li><li id="d5ae" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">这些字段使用诸如<code class="fe oa ob oc od b">@id</code>的注释，使它们在公开的Prisma API中是只读的</li><li id="b9cd" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">@unique</code>指令确保永远不会有两个值相同的记录</li><li id="3e0a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">这两种类型被映射到它们自己的数据库表</li></ul><p id="053d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是如何将类型映射到数据库表的直观表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/6a922916f9b9742e73bbcba90818afb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2Md0ilYSMNxCjIRs.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src:<a class="ae ky" href="https://www.prisma.io/docs/datamodel-and-migrations/datamodel-MYSQL-knul/#object-types" rel="noopener ugc nofollow" target="_blank">https://www . prisma . io/docs/data model-and-migrations/data model-MYSQL-knul/# object-types</a></p></figure><p id="381f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于Prisma数据模型的更多信息，我建议访问官方文档。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7ada" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Prisma客户端</h1><p id="911e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma client是一个自动生成的库，它取代了API中的典型ORM。它提供了客户机和位于数据库之上的Prisma服务器之间的连接。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/47b9f08be36a95bf87c59c77e7ff2bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h_XvpBxrajFF6yAg.png"/></div></div></figure><p id="0686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它提供了一个无缝的API，允许您处理关系数据、连接和事务。</p><p id="cea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以使用Prisma API提供的<code class="fe oa ob oc od b">prisma generate</code>命令生成。我们也可以通过编辑<code class="fe oa ob oc od b">prisma.yml</code>文件来更改配置。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="da4c" class="mz md it od b gy oi oj l ok ol">generate:<br/> - generator: typescript-client<br/>   output: ../src/generated/prisma-client</span></pre><p id="7f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们定义了我们的客户机应该在TypeScript中生成，以及输出应该保存在哪个文件夹中。</p><p id="5651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了客户端的基础知识，让我们看看如何使用它进行基本的数据访问和操作。</p><h2 id="25b4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">定义数据</h2><p id="9677" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma客户端从<code class="fe oa ob oc od b">datamodel.prisma</code>文件自动生成，并向其所有模型公开CRUD功能。</p><p id="9148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于以下部分，让我们假设我们有这个数据模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="3d85" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">读取数据</h2><p id="e2cc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每当您从Prisma客户端查询数据库记录时，您会自动获得记录的所有标量字段。这意味着默认情况下，您只获得不被视为关系的字段(例如，当我们查询用户记录时，我们只获得id、姓名和电子邮件)</p><p id="9f69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">提取所有记录</strong></p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="f34f" class="mz md it od b gy oi oj l ok ol">const users: User[] = await prisma.users()</span></pre><p id="bf3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们从数据库中获取所有用户，并将它们保存到一个数组中。</p><p id="c1d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">提取单个记录</strong></p><p id="cfc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取单个记录也很简单。我们只需要包含带有唯一字段的<code class="fe oa ob oc od b">where</code>参数，就像我们示例中的<code class="fe oa ob oc od b">id</code> <em class="oo"> </em>一样。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="42fc" class="mz md it od b gy oi oj l ok ol">const post: Post = await prisma.post({ id: 'cjli6tknz005s0a23uf0lmlve' })</span></pre><p id="cb42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">选择字段</strong></p><p id="61c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，我们获取记录的所有标量字段。如果我们只想获取特定的字段，我们需要编写自己的查询片段，如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="b802" class="mz md it od b gy oi oj l ok ol">const fragment = `<br/>fragment UserWithPosts on User {<br/>  id<br/>  email<br/>  posts {<br/>    id<br/>    title<br/>  }<br/>}</span><span id="6a19" class="mz md it od b gy op oj l ok ol">const user = await prisma.users().$fragment(fragment)</span></pre><p id="d2aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用<code class="fe oa ob oc od b">$fragment</code> API来指定我们想要查询的字段。之后，我们使用Prisma服务获取字段。</p><h2 id="ee13" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">写入数据</h2><p id="b6b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们知道了如何使用Prisma客户端从数据库中读取数据，让我们继续将数据写入数据库。</p><p id="9f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建记录</strong></p><p id="fb08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在数据库中创建新记录时，我们使用<code class="fe oa ob oc od b">create()</code>方法，该方法使用一个输入对象和记录的所有标量字段。</p><p id="c973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个方法调用返回一个对象的承诺，该对象包含所创建模型的所有标量字段。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="d901" class="mz md it od b gy oi oj l ok ol">const post: Post = prisma.createPost({<br/>  title: 'An Introduction into Prisma',<br/>  author: {<br/>    connect: { email: 'test@test.com' },<br/>  },<br/>})</span></pre><p id="1ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建一个新帖子，作者是<em class="oo">test@test.com</em>。</p><p id="e507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更新记录</strong></p><p id="ac48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当更新现有记录时，我们需要使用<code class="fe oa ob oc od b">update()</code>方法，该方法采用一个带有两个字段的输入对象:</p><ul class=""><li id="74b1" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">其中—此字段用于标识将要更新的记录。您可以使用任何唯一的字段来标识记录。</li><li id="aad6" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">数据-包含将被更新的标量字段的对象</li></ul><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="a7b4" class="mz md it od b gy oi oj l ok ol">const updatedUser: User = await prisma.updateUser({<br/>  data: {<br/>    name: 'Test',<br/>  },<br/>  where: {<br/>    <!-- -->email<!-- -->: 'test@test.com',<br/>  },<br/>})</span></pre><p id="e73a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">删除记录:</strong></p><p id="936b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当从数据库中删除一条记录时，我们使用<code class="fe oa ob oc od b">delete()</code>方法，该方法将一个<code class="fe oa ob oc od b">where</code> <em class="oo"> </em>对象作为输入。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c48e" class="mz md it od b gy oi oj l ok ol">const deletedUser: User = await prisma.deleteUser({<br/>  email: 'test@test.com',<br/>})</span></pre><h2 id="6223" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">实时订阅</h2><p id="1889" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们知道了如何定义和操作数据，让我们看看如何使用<code class="fe oa ob oc od b">$subscribe</code>属性订阅数据库事件和接收实时更新。</p><p id="62d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">$subscribe</code>属性基于WebSockets，并且是为数据模型中的每个模型类型自动生成的。</p><p id="f53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">基础订阅</strong></p><p id="59d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为我们的<code class="fe oa ob oc od b">User</code>模块订阅的<code class="fe oa ob oc od b">create</code>和<code class="fe oa ob oc od b">update</code>事件。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="aa52" class="mz md it od b gy oi oj l ok ol">const createdAndUpdatedUserIterator: UserAsyncIterator = await db.$subscribe<br/>  .user({<br/>    mutation_in: ['UPDATED', 'CREATED'],<br/>  })<br/>  .node()</span></pre><p id="07d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">订阅与查询</strong></p><p id="ce9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用节点属性订阅特定用户的事件。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="77dc" class="mz md it od b gy oi oj l ok ol">const createdUserIterator = await db.$subscribe<br/>  .user({<br/>    mutation_in: ['CREATED', "UPDATED"],<br/>    node: {<br/>      email_contains: `test@test.com`,<br/>    },<br/>  })<br/>  .node()</span></pre><p id="6621" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想了解更多关于Prisma客户端的信息，您可以访问<a class="ae ky" href="https://www.prisma.io/docs/prisma-client/" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4b31" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Prisma服务器</h1><p id="5c07" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma服务器是连接到数据库的基础结构组件。在部署之前，需要使用数据库连接和您的用户凭证对其进行配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/9fbd4c32ac8b77112244c6026829b7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_pn_7BPPir2jxZKl.png"/></div></div></figure><p id="f5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prisma服务器的主要职责是将Prisma客户机发出的请求翻译成实际的数据库查询。</p><h2 id="44a0" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">本地设置</h2><p id="2dce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">目前推荐的设置Prisma服务器的方法是通过Docker。这可以通过编写一个简单的<code class="fe oa ob oc od b">docker-compose.yml</code>文件来完成，该文件包含Prisma服务器的配置和我们数据库的配置。之后，您只需要使用<code class="fe oa ob oc od b">docker-compose up</code>命令启动它。</p><p id="68fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以使用不同的数据库来完成，如MySQL、PostgresSQL或MongoDB。这里我展示了一个使用MySQL作为数据库的示例配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="37d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个简单的docker-compose文件，它将创建两个容器:</p><ul class=""><li id="e1b3" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">prisma </code> —包含我们的Prisma服务器</li><li id="f84d" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">mysql-db</code> —运行MySQL数据库本地实例的容器</li></ul><p id="28b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Prisma容器使用MySQL作为它的数据库，它可以用它的容器名来引用它。</p><h2 id="23fc" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">演示服务器(Prisma cloud)</h2><p id="1722" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">另一种选择是使用Prisma的云服务，而不是在本地托管数据库和服务器。这些演示服务器完全免费，但你需要一个<a class="ae ky" href="https://www.prisma.io/cloud/" rel="noopener ugc nofollow" target="_blank"> Prisma Cloud </a>账户。</p><p id="7587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些服务器的速率限制为每十秒钟十个请求(平均)，因此不能用于任何生产环境。下面是一些使用演示服务器有意义的用例。</p><p id="9786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">用例</strong></p><p id="b986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些服务器的潜在使用案例包括:</p><ul class=""><li id="1683" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">样机研究</li><li id="9d59" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">没有显著用户基础的个人项目</li><li id="cd6a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">学问</li></ul><p id="f7c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在下面的CRUD应用程序示例中看到如何使用演示服务器。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="509a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Prisma管理</h1><p id="47f6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma admin是一种与您的数据和数据库进行可视化交互的方式。它还可以让你使用一个现代而简单的图形用户界面来修改现有的数据和向数据库中添加新的数据。</p><h2 id="4269" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">结构</h2><p id="758f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma管理界面包括四个主要区域:</p><ul class=""><li id="b4bb" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">中心-查询和结果区域</li><li id="54e0" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">右侧—详细信息区域</li><li id="a0de" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">左侧—侧栏</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/47ff288bc2701406589f63d71ce1b383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rTHWdfJWB-W5TYUT.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src:<a class="ae ky" href="https://www.prisma.io/docs/prisma-admin/overview-el3e/#areas" rel="noopener ugc nofollow" target="_blank">https://www . prisma . io/docs/prisma-admin/overview-el3e/# areas</a></p></figure><h2 id="d7cd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">访问Prisma admin</h2><p id="1efd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma管理页面可在您的Prisma服务的<code class="fe oa ob oc od b"><em class="oo">/_admin</em></code>端点获得。</p><p id="9de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><ul class=""><li id="72c0" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="https://eu1.prisma.sh/myuser/project/dev/_admin" rel="noopener ugc nofollow" target="_blank">https://eu1.prisma.sh/myuser/project/dev/_admin</a></code></li><li id="57fc" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe oa ob oc od b"><a class="ae ky" href="http://localhost:4466/_admin" rel="noopener ugc nofollow" target="_blank">http://localhost:4466/_admin</a></code></li></ul><p id="96f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在您的<code class="fe oa ob oc od b">prisma.yml</code>文件中找到Prisma服务的端点。Prisma admin也可以使用控制台中的Prisma <code class="fe oa ob oc od b">admin command</code>打开。</p><p id="ce71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想试试，你可以打开Prisma自己提供的<a class="ae ky" href="https://eu1.prisma.sh/public-demo-services/potential-blackbird-528536/demo/_admin" rel="noopener ugc nofollow" target="_blank">演示服务</a>。</p><h2 id="a39f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">写入数据</h2><p id="8742" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Prisma admin提供了一个GUI，可以让您轻松地创建、更新和删除数据库中的数据。</p><p id="67a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个数据库操作都是一个两步过程:</p><ol class=""><li id="3c81" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu or nr ns nt bi translated">在Prisma用户界面中进行更改</li><li id="bef0" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu or nr ns nt bi translated">完成后，点击右下角的“保存到数据库”按钮</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0f03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建基本服务器</h1><p id="b158" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们对Prisma有了理论上的了解，并且知道了它的用途，让我们用它来构建一个简单的GraphQL服务器，以便更好地理解我们上面谈到的概念和结构。</p><h2 id="8966" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">设置</h2><p id="13b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从使用npm(节点包管理器)下载GraphQL CLI并设置我们的项目开始:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4627" class="mz md it od b gy oi oj l ok ol">npm install -g prisma graphql-cli</span></pre><p id="1410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们可以通过键入以下命令来创建我们的项目:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="d405" class="mz md it od b gy oi oj l ok ol">graphql create primsa-crud</span></pre><p id="1d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，您将会看到一系列类似这样的项目模板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/14310ad61c53321a82ce3974a66e15e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*QCy-SBuKKZpnZsVlULe9Ag.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建Prisma项目</p></figure><p id="e49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将选择typescript-basics并按enter键继续。这将创建一个样例项目，它具有一个名为post的GraphQL类型和完整的CRUD功能。</p><p id="594c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件夹结构应该如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/d1efc6b0321396d016363f539e06b0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*efqIG4ikAVwJFZ4V7YZYfQ.png"/></div></figure><h2 id="f17b" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">项目结构</h2><p id="6c97" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经设置了项目，让我们研究一下生成的文件及其在项目中的角色:</p><p id="c258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> /prisma: </strong></p><ul class=""><li id="821e" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">prisma.yml</code>—Prisma数据库API的根配置文件</li><li id="a1c5" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">seed.graphql</code> —包含用数据播种数据库的突变</li><li id="8874" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">datamodel.graphql </code> —包含在SDL编写的数据模型</li></ul><p id="2b68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> /src: </strong></p><ul class=""><li id="5727" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">index.ts</code> —启动GraphQL服务器并设置配置的服务器入口点</li><li id="2236" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">schema.graphql</code> —定义应用程序模式并包含客户端的GraphQL API</li><li id="b4db" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe oa ob oc od b">generated/prisma.graphql</code> —定义Prisma模式和所有由Prisma自动生成且不应手动编辑的CRUD功能</li></ul><h2 id="4aef" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">数据模型和模式:</h2><p id="4981" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个Prisma应用程序最重要的文件是<code class="fe oa ob oc od b">datamodel.prisma</code>和<code class="fe oa ob oc od b">schema.graphql</code>，因为它们定义了我们的数据模型，因此是API的基础。</p><p id="724f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是基本数据模型的样子:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6ab8" class="mz md it od b gy oi oj l ok ol">type Post {<br/>  id: ID! @unique<br/>  isPublished: Boolean! @default(value: "false")<br/>  title: String!<br/>  content: String!<br/>}</span></pre><p id="1546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们添加第二种类型来获得使用SDL的良好感觉。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8305" class="mz md it od b gy oi oj l ok ol">type User {<br/>  id: ID! @id<br/>  email: String! @unique<br/>  password: String!<br/>}</span></pre><p id="cf67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只是添加了另一个具有三个字段的类型。我们还使用@unique声明符来确保每个值在数据库中只使用一次。</p><p id="bc78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经更新了<code class="fe oa ob oc od b">datamodel.prisma</code>文件，让我们继续添加<code class="fe oa ob oc od b">User</code>类型和突变到我们的<code class="fe oa ob oc od b">schema.graphql</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="6fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们浏览一下代码:</p><ul class=""><li id="5bc8" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">我们使用标准的GraphQL语法定义了<code class="fe oa ob oc od b">user</code>类型</li><li id="511b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">将<code class="fe oa ob oc od b">createUser()</code>函数添加到我们的突变中</li><li id="d69c" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">添加一个用户查询，该查询将获取所有以前保存的用户</li></ul><h2 id="8e6c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">查询和变异实现</h2><p id="031f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在只剩下解析器函数的实现了。所以让我们在我们的<code class="fe oa ob oc od b">index.ts</code>文件中实现它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="bc53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建两个解析器方法，这两个方法都调用由Prisma客户端实例生成的一个方法，这个方法被称为<code class="fe oa ob oc od b">prisma</code>并附加到<code class="fe oa ob oc od b">context</code> <em class="oo"> </em>对象。</p><h2 id="e7e4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">部署和测试</h2><p id="d19b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们已经完成了我们的应用程序，我们只需要将它部署到一个演示服务器上，并使用GraphQL Playground测试它。我们可以使用下面的命令来做到这一点。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8405" class="mz md it od b gy oi oj l ok ol">prisma deploy</span></pre><p id="c0e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果出现一个对话框，您需要选择演示服务器和ping效果最好的位置。然后需要在Prisma cloud上注册一个账号并连接。</p><p id="d00d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，您可以使用以下命令运行应用程序:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ab9e" class="mz md it od b gy oi oj l ok ol">yarn start<br/>or<br/>npm run start</span></pre><p id="814e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的应用程序现在应该正在运行，您应该能够访问位于<a class="ae ky" href="http://localhost:4000." rel="noopener ugc nofollow" target="_blank"> http://localhost:4000上的GraphQL playground。</a></p><p id="f080" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以测试我们的查询和突变:</p><p id="f9a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建帖子</strong></p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="9e58" class="mz md it od b gy oi oj l ok ol">mutation {<br/>  createDraft(<br/>    title: "Prisma is a great and easy tool",<br/>    content: "It really is."<br/>  ) {<br/>    id<br/>    title<br/>    content<br/>  }<br/>}</span></pre><p id="e196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">创建用户</strong></p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="c671" class="mz md it od b gy oi oj l ok ol">mutation {<br/>  createUser(<br/>    email: "<a class="ae ky" href="mailto:test123@test.com" rel="noopener ugc nofollow" target="_blank">test123@test.com</a>",<br/>    password: "test123"<br/>  ) {<br/>    id<br/>    email<br/>    password<br/>  }<br/>}</span></pre><p id="f90b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获取所有用户</strong></p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="3237" class="mz md it od b gy oi oj l ok ol">query{<br/>  users{<br/>    id<br/>    email<br/>    password<br/>  }<br/>}</span></pre><p id="85d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，请在下面的评论中留下。完整的代码也可以在我的Github上找到。</p><div class="ou ov gp gr ow ox"><a href="https://github.com/TannerGabriel/Blog/tree/master/prisma-crud" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">TannerGabriel/博客</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">🚀在几秒钟内引导您的GraphQL服务器基本入门套件，用于灵活的基于类型脚本的GraphQL服务器…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">github.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="feae" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">推荐阅读:</h2><div class="ou ov gp gr ow ox"><a href="https://medium.com/dailyjs/an-introduction-into-stencil-js-a08e41e2102" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">Stencil.js简介</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">Stencil是一个编译器，可以生成Ionic团队开发的Web组件。模板结合了…的最佳概念</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl ks ox"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c60d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="f794" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你一直坚持到最后！希望这篇文章能帮助你理解Prisma的基础知识，以及为什么它对我们后端开发人员如此有用。</p><p id="609a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您发现这很有用，请考虑推荐并与其他开发人员分享。如果你有任何问题或反馈，请在下面的评论中告诉我。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a709" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oo">原载于https://gabrieltanner.org</em><a class="ae ky" href="https://gabrieltanner.org/blog/prisma-introduction" rel="noopener ugc nofollow" target="_blank"><em class="oo"/></a><em class="oo">。</em></p></div></div>    
</body>
</html>