<html>
<head>
<title>How To Protect Your Microservices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何保护您的微服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-protect-your-microservices-8d74045061c1?source=collection_archive---------7-----------------------#2022-06-14">https://betterprogramming.pub/how-to-protect-your-microservices-8d74045061c1?source=collection_archive---------7-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1be9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用身份验证服务来验证JWT令牌并保护您的其他微服务(实验01 —第1部分)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbdd296c925c9c4c315809576b98272b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UPpUI6gvPb0hRETQGNzUA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">国际国王教会在<a class="ae kv" href="https://unsplash.com/s/photos/security-guard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c2a9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">开始前</h1><p id="5b46" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当我开始学习微服务时，我想知道如何保护服务并确保用户被授权使用API。</p><p id="4a7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当我们希望使用单片架构时，我对如何构建身份认证系统和保护路由非常有信心，但对于微服务，范式和方法都有所不同。</p><p id="f707" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这次的微服务lab01中，我试图澄清我的疑惑，我将向大家展示如何配置一个基本的待办应用(哇，我知道的超级原创。我认为待办应用是Hello World！配置一个微服务架构，让用户登录并在列表中添加待办事项，查看他们的任务等。但只有在授权的情况下！</p><p id="e2df" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们完全同意，这个应用程序可以在一个整体架构中管理，因为它很简单。其实简单的事情的美好就在于我们可以越来越复杂。</p><p id="eabb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以从我的<a class="ae kv" href="https://github.com/anotherbuginthecode/microservices-labs" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中克隆代码，我将创建几个实验室实验，在那里我将尝试解决一些问题或添加高级功能，如CI/CD、测试和自动化。</p><p id="e31a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我将跳过我创建前端服务的部分，因为这已经超出了范围。</p><p id="e145" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">文章将按如下方式组织:</p><p id="ee87" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">第一部分:</p><ul class=""><li id="519f" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">整体情况</li><li id="ac86" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">授权服务</li></ul><p id="23a3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第二部分</strong>:</p><ul class=""><li id="21f9" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">待办服务</li><li id="b18b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">用docker-compose运行所有服务</li></ul><p id="1cfa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">所以跟着来，让我们开始吧。</p><h1 id="ad1b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">大局</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/344efae101faa934747133bbe766b12b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7WVp-0CGsqqOYjS8afmQQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用<a class="ae kv" href="https://excalidraw.com/" rel="noopener ugc nofollow" target="_blank"> Excalidraw </a>制作的草图</p></figure><p id="a6ab" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如上所述，web应用程序将允许用户登录，在他们的待办事项列表上创建任务，查看他们当前的任务，以及执行其他操作。</p><p id="e1a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为此，我在<a class="ae kv" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue3 </a>中创建了一个前端服务。auth服务用<a class="ae kv" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>编写，负责验证用户和保护服务。最后，用负责处理web应用程序核心动作的<a class="ae kv" href="https://flask.palletsprojects.com/en/2.1.x/" rel="noopener ugc nofollow" target="_blank"> Flask </a>开发待办服务。</p><p id="1b3e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">作为一种最佳实践——也是因为解耦微服务架构的性质——每个后端服务都有自己的数据库，在我的例子中是一个PostgreSQL。</p><p id="d0d1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Auth和to-do服务是REST应用程序，它们将使用REST APIs与前端以及彼此之间进行通信。</p><p id="c207" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，对于每个服务，我都创建了一个docker文件，并使用docker-compose将它们连接起来。如果你<a class="ae kv" href="https://github.com/anotherbuginthecode/microservices-labs" rel="noopener ugc nofollow" target="_blank">克隆存储库</a>，你会看到一些实用的bash脚本或Makefile，我用来加速重复的任务，并在构建阶段设置docker。</p><h1 id="b0d0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">授权服务</h1><p id="330d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，让我们看看项目的结构。如果你有兴趣知道Django项目中的每个文件负责什么，我建议在这里阅读<a class="ae kv" href="https://techvidvan.com/tutorials/django-project-structure-layout/" rel="noopener ugc nofollow" target="_blank">或者</a><a class="ae kv" href="https://django-project-skeleton.readthedocs.io/en/latest/structure.html" rel="noopener ugc nofollow" target="_blank">Django官方文档</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/a2bb068fdfbcf05e46af3a407a93c483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*X1odDvR5I6zEMsQ_zYdqUg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">授权服务项目结构</p></figure><h2 id="2529" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated"><strong class="ak"> <em class="nr">授权文件夹</em> </strong></h2><p id="3714" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它是你输入<code class="fe ns nt nu nv b">django-admin startproject &lt;your-project-name&gt;</code>时创建的文件夹。<strong class="lq ir"> </strong>里面有像<code class="fe ns nt nu nv b">settings.py</code>一样最重要的文件(用于添加所有的应用和中间件应用。它是主设置文件)和<code class="fe ns nt nu nv b">urls.py</code>(它包含了我们网站的所有端点)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/49dd4507b56a52fc938432bbb58ecb4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*Y3slY6ax7jUwMuWtGKZbtQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">授权文件夹中的文件</p></figure><p id="46b8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如前所述，auth是一个REST应用程序，为了实现这一点，有一个令人惊叹的模块叫做<a class="ae kv" href="https://www.django-rest-framework.org/" rel="noopener ugc nofollow" target="_blank"> django-rest-framework </a>。</p><p id="45ed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它将帮助您解决许多令人头痛的问题，为您提供易于理解的说明。结合<a class="ae kv" href="https://django-rest-framework-simplejwt.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">djangorestframework-simple jwt</a>，你可以得到一个全功能的jwt-token管理器。它将允许您在用户登录时生成访问令牌，验证传递的令牌是否有效和/或过期，并刷新令牌系统。</p><p id="acff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">从下面的代码中可以看出，这一切都不费吹灰之力。</p><h2 id="8cb7" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated"><code class="fe ns nt nu nv b"><strong class="ak">urls.py</strong></code></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="0677" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated"><strong class="ak"> views.py </strong></h2><p id="6724" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如您所注意到的，我在<code class="fe ns nt nu nv b">views.py</code>中创建了一个名为<code class="fe ns nt nu nv b">TokenDecode</code>的自定义端点。它的目标是解码作为POST请求传递的jwt令牌，并返回相关的<code class="fe ns nt nu nv b">user_id</code>。如果向auth服务发送无效令牌，它将引发AuthenticationFailed错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="a8ab" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated"><strong class="ak"> decorators.py </strong></h2><p id="2a09" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我对使用Python中的decorators相当陌生，但是自从我开始使用它们以来，我已经印象深刻了。</p><blockquote class="nz oa ob"><p id="a273" class="lo lp oc lq b lr mk jr lt lu ml ju lw od mm lz ma oe mn md me of mo mh mi mj ij bi translated">装饰器是Python中一个非常强大和有用的工具，因为它允许程序员修改函数或类的行为。装饰者允许我们包装另一个函数，以便扩展被包装函数的行为，而不用永久地修改它。</p></blockquote><p id="b517" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您查看代码时，在函数定义上方您会看到类似于<code class="fe ns nt nu nv b">@decorator_name.</code>的东西，这可能是因为有一个decorator将函数作为参数，并在包装函数内扩展了他的行为。</p><p id="7ebc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们的例子中，我们有<code class="fe ns nt nu nv b">@jwt_required</code> decorator，它必须检查授权是否在请求的头中。否则将引发AuthenticationFailed错误。</p><p id="0a4f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">使用这种方法，我们可以确保只有拥有jwt令牌的用户才能调用我们的API。此外，Django将检查令牌是否有效，并防止未经授权的用户访问我们的视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="a178" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">用户文件夹</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/04b7c958bd50220daa669f06ef951815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*pSaNB4IrRhjXRqTz2Sqkxw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用户文件夹中的文件</p></figure><p id="0ecb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这里，我们可以发现用户是如何在数据库中定义的(<code class="fe ns nt nu nv b">models.py</code>)以及人们如何与这个界面进行交互(<code class="fe ns nt nu nv b">views.py</code>)。</p><h2 id="9299" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated"><strong class="ak"> models.py </strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="00ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">作为一个实验项目，我想让这部分简单一些。因此，我们将只使用电子邮件和密码来定义我们的用户。</p><h2 id="438e" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated"><strong class="ak">views . py+serializer . py</strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="553f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这里，我定义了<code class="fe ns nt nu nv b">APIView</code>以及人们如何与应用程序交互。在我们的例子中，用户可以注册到应用程序中，获得在应用程序中注册的所有用户的列表，也许在未来我可以保护这条路线，只允许管理员用户或特殊角色与之交互。</p><p id="e8b6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">他们还可以通过<code class="fe ns nt nu nv b">user_id</code>获得某个用户的详细信息。</p><p id="5853" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如你所看到的，除了<code class="fe ns nt nu nv b">RegisterView</code>之外，所有的API都用<code class="fe ns nt nu nv b">@jwt_required</code>装饰器来保护。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="0777" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated"><strong class="ak"> urls.py </strong></h2><p id="b887" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每个视图都需要一个端点才能被调用。那么，让我们看看我为APIViews定义了哪些路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="cc9f" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">Docker文件夹</h2><p id="5c7b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们看看docker文件夹里面有什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/95375d93038558790c9af53db8ebf049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*kyNV7Vxfh-lzpGJUBgRqWw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">docker文件夹中的文件</p></figure><p id="e3d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> Dockerfile </strong></p><blockquote class="nz oa ob"><p id="e34a" class="lo lp oc lq b lr mk jr lt lu ml ju lw od mm lz ma oe mn md me of mo mh mi mj ij bi translated"><a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">“Docker</a>可以通过读取来自<code class="fe ns nt nu nv b">Dockerfile</code>的指令自动构建图像。一个<code class="fe ns nt nu nv b">Dockerfile</code>是一个文本文档，它包含用户可以在命令行上调用的所有命令来组合一个图像。使用<code class="fe ns nt nu nv b">docker build</code>,用户可以创建一个连续执行几个命令行指令的自动化构建。”</p></blockquote><p id="04f6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我是这样定义Dockerfile的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="55c8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的灵感来自<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/dockerize-your-django-apps-428189407c69">Mariano Martinez Grasso</a>写的这篇文章。</p><p id="7d03" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它写得很好，为您的下一个Django应用程序提供了很好的技巧和最佳实践。</p><p id="d9aa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">基础映像将首先执行的脚本<code class="fe ns nt nu nv b">entrypoint.sh</code>作为入口点。当您启动docker容器时，它将检查与PostgreSQL DB的连接是否已建立，然后继续执行其他指令。</p><p id="e4e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我的例子中，只有当<code class="fe ns nt nu nv b">POSTGRES_ENABLED=1</code>否则，容器将使用默认数据库db.sqlite3运行时，才进行这种检查</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="9ec5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">基本docker映像将用于创建开发映像(这就是所谓的<a class="ae kv" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>)。当您通过命令<code class="fe ns nt nu nv b">docker run</code>运行容器时，bash脚本<code class="fe ns nt nu nv b">start-server.sh </code>将通过执行您将在本地启动服务器时使用的基本指令来启动。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="791f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">启动服务</strong></h1><p id="11a9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，是时候推出服务了！我准备了一个<code class="fe ns nt nu nv b">Makefile</code>来自动化那些无聊的东西。如果你已经下载了代码，你只需输入命令<code class="fe ns nt nu nv b">make &lt;target&gt;</code>就可以享受了！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><ul class=""><li id="728f" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated"><code class="fe ns nt nu nv b">docker-build</code>:它将创建一个名为<code class="fe ns nt nu nv b">msalab01/auth:v1</code>的docker图像</li><li id="b711" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><code class="fe ns nt nu nv b">docker-run</code>:启动名为<code class="fe ns nt nu nv b">lab01_auth</code>的docker容器。如果需要使用不同的端口，必须在make命令中用变量port指定，否则，将使用<code class="fe ns nt nu nv b">8000</code></li><li id="b71e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><code class="fe ns nt nu nv b">local-build</code>:它将启动<code class="fe ns nt nu nv b">bootstrap.sh</code>，自动完成所有初始设置，如创建虚拟环境和安装依赖项</li><li id="30d7" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><code class="fe ns nt nu nv b">local-run</code>:它将启动<code class="fe ns nt nu nv b">start_local_server.sh</code>，这是一个bash脚本，执行所有基本指令来本地运行服务器。(注意:它将使用db.sqlite3作为默认数据库)</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="7743" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="681d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你做到了！现在一切都准备好了，你可以欣赏风景，测试路线，进行实验和改进</p><p id="46c7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">别忘了让我知道！我喜欢讨论和学习新东西。</p><p id="5c33" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我希望在<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/build-a-todo-app-using-a-microservices-architecture-and-use-auth-service-to-protect-its-routes-f8f0d2ad6669">第二部分</a>中见到你，在那里我将向你展示我是如何创建待办事项服务并使用授权服务保护它的。</p><p id="edd4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后，我们将以所有微服务与docker-compose一起运行来结束lab01！</p><p id="a392" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">再见！</p><h1 id="8fae" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">有用的链接</h1><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/build-a-todo-app-using-a-microservices-architecture-and-use-auth-service-to-protect-its-routes-f8f0d2ad6669"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">使用微服务架构构建Todo应用程序，并使用授权服务来保护其路线</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">使用身份验证服务来验证JWT令牌并保护您的其他微服务(实验01 —第2部分)</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb kp on"/></div></div></a></div><div class="ok ol gp gr om on"><a href="https://github.com/anotherbuginthecode/microservices-labs" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">GitHub -另一个bug in代码/微服务-实验室:一系列实验来了解…</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">在我学习微服务架构的过程中，进行了一系列的实验。有时候我会看到一些文章或者…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="pc l oy oz pa ow pb kp on"/></div></div></a></div><div class="ok ol gp gr om on"><a rel="noopener  ugc nofollow" target="_blank" href="/dockerize-your-django-apps-428189407c69"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd ir gy z fp os fr fs ot fu fw ip bi translated">将你的Django应用归档</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">从本地开发到生产</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">better编程. pub</p></div></div><div class="ow l"><div class="pd l oy oz pa ow pb kp on"/></div></div></a></div><p id="a09d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Django项目结构布局:<a class="ae kv" href="https://techvidvan.com/tutorials/django-project-structure-layout/" rel="noopener ugc nofollow" target="_blank">https://techvidvan . com/tutorials/django-project-structure-layout/</a></p></div></div>    
</body>
</html>