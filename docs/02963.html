<html>
<head>
<title>Introduction to JavaScript Symbols</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript符号简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-javascript-symbols-6832aa8266f6?source=collection_archive---------10-----------------------#2020-01-11">https://betterprogramming.pub/introduction-to-javascript-symbols-6832aa8266f6?source=collection_archive---------10-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2334" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">ES6引入的新数据类型，您可能已经错过了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d9a0ebcefaa754236a9e80d1aee1c91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vY7cxSj5lRwo9dBs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mesmitpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯密特·帕特尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在ES2015中，引入了名为<code class="fe lv lw lx ly b">Symbol</code>的新原语类型。这是一个唯一且不可变的标识符。一旦创建，就不能复制。</p><p id="8baa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次你创造一个新的符号，它都是独一无二的。符号主要用于对象中的唯一标识符。这是一个符号的唯一目的。</p><p id="229c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一些特殊的符号，我们可以用它们来实现各种操作或者覆盖一些操作的默认行为。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="11ff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">定义符号</h1><p id="0305" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有一些它自己的静态属性和方法公开全局符号注册表。它就像一个内置对象，但是它没有构造函数，所以我们不能写<code class="fe lv lw lx ly b">new Symbol</code>用<code class="fe lv lw lx ly b">new</code>关键字构造一个符号对象。</p><p id="8858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了创造新的符号，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6ef4" class="nh mh it ly b gy ni nj l nk nl">const fooSymbol = Symbol('foo')</span></pre><p id="e2eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，每次我们调用<code class="fe lv lw lx ly b">Symbol</code>函数，我们都会得到一个新的符号，所以如果我们写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d5c4" class="nh mh it ly b gy ni nj l nk nl">Symbol('sym') === Symbol('sym')</span></pre><p id="87b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的表达是<code class="fe lv lw lx ly b">false</code>。这是因为每个符号都是独一无二的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0879" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">内置符号</h1><p id="c907" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有一些内置符号被用作各种方法和值的标识符。当使用一些运算符时，调用带有一些符号的方法。</p><h2 id="f4f3" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.hasInstance</code></h2><p id="f00c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Symbol.hasInstance</code>是一个检查对象是否是给定构造函数的实例的方法。当调用<code class="fe lv lw lx ly b">instanceof</code>操作符时，这个方法被调用。</p><p id="6048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以如下重写<code class="fe lv lw lx ly b">Symbol.hasInstance</code>方法:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d52e" class="nh mh it ly b gy ni nj l nk nl">class Foo {  <br/>  static [Symbol.hasInstance](instance) {<br/>    return typeof instance.foo != 'undefined';<br/>  }<br/>}<br/>console.log({ foo: 'abc' } instanceof Foo);</span></pre><p id="aa56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们定义了如果有一个<code class="fe lv lw lx ly b">foo</code>属性的值，那么这个对象就是<code class="fe lv lw lx ly b">Foo</code>类的一个实例。因此，<code class="fe lv lw lx ly b">{ foo: ‘abc’ } instanceof Foo</code>应该返回<code class="fe lv lw lx ly b">true</code>，因为它将<code class="fe lv lw lx ly b">foo</code>属性设置为<code class="fe lv lw lx ly b">'abc'</code>。</p><h2 id="706f" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.isConcatSpreadable</code></h2><p id="3e51" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">Symbol.isConcatSpreadable</code>是一个布尔值，指示是否应该通过array <code class="fe lv lw lx ly b">concat</code>方法在数组中展平一个对象。</p><p id="8ecb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在下面的代码中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个<code class="fe lv lw lx ly b">console.log</code>应该输出:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="64f9" class="nh mh it ly b gy ni nj l nk nl">["a", "b", "c", true, false]</span></pre><p id="b77c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个应该输出:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0f02" class="nh mh it ly b gy ni nj l nk nl">["a", "b", "c", Array(2)]</span></pre><p id="d50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为在第二个<code class="fe lv lw lx ly b">concat</code>调用之前，我们将<code class="fe lv lw lx ly b">arr2[Symbol.isConcatSpreadable]</code>设置为<code class="fe lv lw lx ly b">false</code>，这防止了<code class="fe lv lw lx ly b">arr2</code>的内容扩散到由<code class="fe lv lw lx ly b">concat</code>方法返回的新数组中。</p><h2 id="d385" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.iterator</code></h2><p id="18a9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们想要为spread操作符或<code class="fe lv lw lx ly b">for...of</code>循环返回一个迭代器时，就会调用这个方法。在运行<code class="fe lv lw lx ly b">for...of</code>循环时调用它。</p><p id="b070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="92e1" class="nh mh it ly b gy ni nj l nk nl">const obj = {<br/>  0: 1,<br/>  1: 2,<br/>  2: 3<br/>};<br/>console.log(obj[0]);</span></pre><p id="4be6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您尝试使用<code class="fe lv lw lx ly b">for...of</code>循环或<code class="fe lv lw lx ly b">forEach</code>函数循环遍历数组，或者尝试对其使用spread运算符，那么使用<code class="fe lv lw lx ly b">obj</code>对象的示例将会导致错误，因为它不是一个可迭代的对象。</p><p id="f546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过添加一个带有符号<code class="fe lv lw lx ly b">Symbol.iterator</code>的生成器函数来使它可迭代，如下面的代码所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="f355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们像下面这样用<code class="fe lv lw lx ly b">for...of</code>循环迭代<code class="fe lv lw lx ly b">obj</code>对象时:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="77ed" class="nh mh it ly b gy ni nj l nk nl">for (let num of obj) {<br/>  console.log(num);<br/>}</span></pre><p id="35b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到了新的<code class="fe lv lw lx ly b">obj</code>对象的条目，我们把它变成了iterable。</p><p id="d97f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扩展操作符也可以工作。如果我们有以下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="947f" class="nh mh it ly b gy ni nj l nk nl">console.log([...obj]);</span></pre><p id="e566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从<code class="fe lv lw lx ly b">console.log</code>输出中得到<code class="fe lv lw lx ly b">[1, 2, 3]</code>。</p><h2 id="e3b6" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.match</code></h2><p id="2f7f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个布尔属性，它是替换字符串的匹配子字符串的正则表达式实例的一部分。它由字符串的<code class="fe lv lw lx ly b">replace</code>方法调用。</p><p id="34ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以使用它来调用带有正则表达式字符串的<code class="fe lv lw lx ly b">startsWith</code>和<code class="fe lv lw lx ly b">endsWith</code>方法:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1b12" class="nh mh it ly b gy ni nj l nk nl">const regexpFoo = /foo/;<br/>regexpFoo[Symbol.match] = false;<br/>console.log('/foo/'.startsWith(regexpFoo));<br/>console.log('/baz/'.endsWith(regexpFoo));</span></pre><p id="a4df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的部分是我们将<code class="fe lv lw lx ly b">regexpFoo[Symbol.match]</code>设置为<code class="fe lv lw lx ly b">false</code>，这表明我们调用的字符串<code class="fe lv lw lx ly b">startsWith</code>和<code class="fe lv lw lx ly b">endsWith</code>不是正则表达式对象，因为<code class="fe lv lw lx ly b">isRegExp</code>检查将表明<code class="fe lv lw lx ly b">'/foo/'</code>和<code class="fe lv lw lx ly b">'/baz/'</code>字符串不是正则表达式对象。</p><p id="44a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，它们将被视为正则表达式对象，即使它们是字符串，我们也会得到以下错误:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7e1d" class="nh mh it ly b gy ni nj l nk nl">Uncaught TypeError: First argument to String.prototype.startsWith must not be a regular expression</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/c6ed69ee81a83b77cc914f56362983aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WGJYcs9qkR0izPD2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@digitalfive?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Niklas Garnholz </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="e751" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.replace</code></h2><p id="014c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">替换字符串的匹配子字符串的正则表达式方法。由<code class="fe lv lw lx ly b">String.prototype.replace</code>方法调用。</p><p id="821d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe lv lw lx ly b">Symbol.replace</code>符号作为方法的标识符，我们可以为我们的对象创建我们自己的<code class="fe lv lw lx ly b">replace</code>方法，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="e748" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Replacer</code>类有一个构造函数，它接受一个可以用来替换当前字符串实例的值。</p><p id="24db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行最后一行时，我们应该得到<code class="fe lv lw lx ly b">‘bar’</code>,因为<code class="fe lv lw lx ly b">string</code>的值是<code class="fe lv lw lx ly b">'foo'</code>,我们调用<code class="fe lv lw lx ly b">replace</code>方法，用我们传递给<code class="fe lv lw lx ly b">Replacer</code>的构造函数的内容替换它本身。</p><h2 id="d104" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.search</code></h2><p id="a79b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一种正则表达式方法，返回与正则表达式匹配的字符串中的索引。由<code class="fe lv lw lx ly b">String.prototype.search</code>方法调用。</p><p id="9c14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以实现我们自己的<code class="fe lv lw lx ly b">Symbol.search</code>方法，就像我们在下面的代码中做的那样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们的<code class="fe lv lw lx ly b">Symbol.search</code>方法查找<code class="fe lv lw lx ly b">string</code>，也就是我们调用<code class="fe lv lw lx ly b">search</code>的字符串，是否有我们传递到<code class="fe lv lw lx ly b">this.value</code>字段的内容，这个字段是我们调用构造函数时分配的。</p><p id="0431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们从<code class="fe lv lw lx ly b">console.log</code>输出得到<code class="fe lv lw lx ly b">true</code>，因为<code class="fe lv lw lx ly b">'bar'</code>在<code class="fe lv lw lx ly b">‘foobar'</code>中。另一方面，如果我们调用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="723e" class="nh mh it ly b gy ni nj l nk nl">console.log('foobar'.search(new Searcher('baz')));</span></pre><p id="8c8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到值<code class="fe lv lw lx ly b">false</code>，因为<code class="fe lv lw lx ly b">‘baz’</code>不在<code class="fe lv lw lx ly b">'foobar'</code>中。</p><h2 id="beaf" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.species</code></h2><p id="6a48" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一种属性，其值为一个函数，即用于创建派生对象的构造函数。</p><h2 id="d875" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.split</code></h2><p id="9a53" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正则表达式对象的一部分，它根据匹配正则表达式的索引来拆分字符串。它由字符串的<code class="fe lv lw lx ly b">split</code>方法调用。</p><h2 id="02b4" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.toPrimitive</code></h2><p id="f2eb" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">将对象转换为相应原始值的方法。当使用<code class="fe lv lw lx ly b">+</code>一元操作符或者将一个对象转换为原始字符串时，就会调用这个函数。</p><p id="0501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以编写自己的<code class="fe lv lw lx ly b">Symbol.toPrimitive</code>方法来将各种值转换为原始值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="fe17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8577" class="nh mh it ly b gy ni nj l nk nl">10<br/>hello<br/>true<br/>false</span></pre><p id="8a27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来自代码底部的<code class="fe lv lw lx ly b">console.log</code>语句。</p><h2 id="5a36" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.toString</code></h2><p id="a38f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">返回对象的字符串表示形式的方法。每当一个对象的<code class="fe lv lw lx ly b">toString</code>方法被调用时，它就会被调用。</p><h2 id="fcde" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated"><code class="fe lv lw lx ly b">Symbol.unscopables</code></h2><p id="af0e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个对象，它自己的属性名是从相关对象的<code class="fe lv lw lx ly b">with</code>环境绑定中排除的属性名。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7713" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="6ae4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">符号是ES6引入的一种新的数据类型。它们用于识别对象的属性。它们是不可变的，每个实例都被认为是不同的，即使它们可能有相同的内容。</p><p id="7e5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在自己的代码中实现由特殊符号标识的各种方法，以实现某些操作，如<code class="fe lv lw lx ly b">instanceof</code>，将对象转换为原始值，以及搜索子字符串。</p></div></div>    
</body>
</html>