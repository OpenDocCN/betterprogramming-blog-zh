<html>
<head>
<title>gRPC File Upload and Download in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python上传和下载gRPC文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/grpc-file-upload-and-download-in-python-910cc645bcf0?source=collection_archive---------0-----------------------#2022-09-08">https://betterprogramming.pub/grpc-file-upload-and-download-in-python-910cc645bcf0?source=collection_archive---------0-----------------------#2022-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="658b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过流式终端传输文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bec94d4f511a22ad9c58dfa3915df426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFZFLoW8JEmZyldjPTqYXw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·汤纳在<a class="ae ky" href="https://unsplash.com/s/photos/connect?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过阅读这篇文章，您将学习如何设置自己的gRPC客户端和服务器，以便用Python上传/下载文件。供您参考，gRPC被称为远程过程调用，是一个现代的开放源码，用于将设备、移动应用程序和浏览器连接到后端服务。</p><p id="2139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其核心具有以下特性:</p><ul class=""><li id="7f11" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">simple service definition</code> —通过协议缓冲区定义，一个强大的二进制序列化工具</li><li id="6116" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">scalable</code> —扩展到每秒百万次RPC</li><li id="2a33" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">multi-platform advantage</code> —跨不同语言和平台工作</li><li id="d0bd" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">streaming support</code> —支持客户端和服务器之间的双向流传输</li></ul><p id="3072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本教程涵盖以下概念和实现:</p><ul class=""><li id="d88a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">安装Python模块和gRPC工具</li><li id="1609" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">通过协议缓冲区定义服务</li><li id="410d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">生成gRPC代码</li><li id="fd8d" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">建立一个gRPC服务器用于文件上传和下载</li><li id="26d6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">构建一个gRPC客户端从服务器上传和下载文件</li><li id="f6f6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">更新流媒体服务</li><li id="2581" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">更新gRPC服务器以上传/下载文件</li><li id="f607" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">更新gRPC客户端以上传/下载文件</li></ul><p id="4a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们继续下一节的设置和安装</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0e32" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">设置</h1><p id="20f3" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">强烈建议您在继续安装之前设置一个虚拟环境。</p><h2 id="a300" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">gRPC</h2><p id="e1c6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在您的终端上运行以下命令来安装<code class="fe me mf mg mh b">grpcio</code>:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="b909" class="nr mv it mh b gy oh oi l oj ok">pip install grpcio</span></pre><h2 id="7400" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">gRPC工具</h2><p id="9fd4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">除此之外，我们需要安装协议缓冲编译器附带的gRPC工具来生成服务器和客户端代码。您可以按如下方式安装它:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="b70b" class="nr mv it mh b gy oh oi l oj ok">pip install grpcio-tools</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8f28" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">定义服务</h1><p id="27d2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在您的工作目录中创建一个名为<code class="fe me mf mg mh b">protos</code>的新文件夹。然后，创建一个名为<code class="fe me mf mg mh b">hello.proto</code>的新文件。该文件充当整个项目的服务定义(适用于客户机和服务器)。</p><p id="4d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将定义数据序列化的结构。</p><ul class=""><li id="9268" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">message</code> —表示包含一系列名称-值对的信息的逻辑记录。每个项目通常被称为字段。您必须定义字段类型、字段名称和字段编号。字段编号用作唯一标识符，不应更改。它从1开始，1到15范围内的数字用一个字节进行编码。另一方面，16到2047范围内的数字需要两个字节来编码。</li></ul><p id="1f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的例子:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="a903" class="nr mv it mh b gy oh oi l oj ok">message HelloRequest {<br/>  string name = 1;<br/>  int32 age = 2;<br/>}</span><span id="cb9c" class="nr mv it mh b gy ol oi l oj ok">message StringResponse {<br/>  string message = 1;<br/>}</span></pre><p id="62b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">HelloRequest</code>消息包含一个字符串和int32变量。因为没有限制，所以您可以将它用于请求或响应。在这种情况下，我们将使用它作为请求，这意味着传入的请求应该有一个string类型的<code class="fe me mf mg mh b">name</code>变量和一个int32类型的<code class="fe me mf mg mh b">age</code>变量。</p><p id="0e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，StringResponse消息只包含一个消息变量。因此，我们的gRPC服务将接受两个输入变量(string，int32)并返回一个变量(string)作为响应。</p><ul class=""><li id="5e7b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">service </code> —代表服务定义。每个服务可以有多个rpc，它们有自己的请求和响应定义。</li></ul><p id="7410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码片段演示了一个简单的服务定义，它利用了来自</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="8681" class="nr mv it mh b gy oh oi l oj ok">service Greeter {<br/>  // Sends a greeting<br/>  rpc SayHello (HelloRequest) returns (StringResponse) {}<br/>}</span></pre><p id="431e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">Greeter</code>服务包含一个接受<code class="fe me mf mg mh b">HelloRequest</code>消息并返回<code class="fe me mf mg mh b">StringResponse</code>消息的<code class="fe me mf mg mh b">SayHello</code> rpc。</p><blockquote class="om on oo"><p id="9cb5" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">协议缓冲区定义是通用的，与您使用的平台和编程语言无关。有关协议缓冲区的更多信息，请查看<a class="ae ky" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank">语言指南(proto3) </a>。</p></blockquote><p id="8fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看下面的原型文件作为参考:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5292" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">生成gRPC代码</h1><p id="30b0" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">下一步是生成相应的Python代码，供客户机和服务器使用。假设您的工作目录如下:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="ab4b" class="nr mv it mh b gy oh oi l oj ok">root (working directory)<br/>|<br/>|--protos<br/>|  |-hello.proto<br/>|--client.py (client code, will be created in the later section)<br/>|--server.py (server code, will be created in the later section)</span></pre><p id="c391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从您的工作目录中调用以下命令:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="9beb" class="nr mv it mh b gy oh oi l oj ok">python -m grpc_tools.protoc -I=. --python_out=. --grpc_python_out=. ./protos/hello.proto</span></pre><p id="7fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将在protos文件夹中生成以下文件:</p><ul class=""><li id="2873" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">hello_pb2.py</code></li><li id="c9b7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">hello_pb2_grpc.py</code></li></ul><blockquote class="om on oo"><p id="2600" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">文件的前缀取决于*的名称。原型文件。每当对原型文件进行修改时，都需要重新生成gRPC代码。</p></blockquote></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="1dc5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">gRPC服务器</h1><p id="c9f4" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在您的工作目录中创建一个名为<code class="fe me mf mg mh b">server.py</code>的新文件。</p><h2 id="83ca" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">导入</h2><p id="1db2" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">打开它并添加以下导入语句:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="0430" class="nr mv it mh b gy oh oi l oj ok">from concurrent import futures<br/>import logging<br/>import os<br/>import grpc<br/>from protos import hello_pb2, hello_pb2_grpc</span></pre><h2 id="07af" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">类别定义</h2><p id="511e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">然后，用名为<code class="fe me mf mg mh b">SayHello</code>的函数定义<code class="fe me mf mg mh b">Greeter</code>类:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="6452" class="nr mv it mh b gy oh oi l oj ok">class Greeter(hello_pb2_grpc.GreeterServicer):<br/>    def SayHello(self, request, context):<br/>        return hello_pb2.StringResponse(message=f'Hello, {request.name}! Your age is {request.age}')</span></pre><p id="110b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数内部，您可以实现所需的逻辑并将<code class="fe me mf mg mh b">StringResponse</code>消息返回给客户端。</p><blockquote class="om on oo"><p id="00f1" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">函数名应该与我们之前在<code class="fe me mf mg mh b">proto</code>文件中定义的相匹配。</p></blockquote><h2 id="b1d2" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">主要功能</h2><p id="33c6" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">之后，定义一个名为serve的新函数，并在其中添加以下代码:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="8158" class="nr mv it mh b gy oh oi l oj ok">def serve():<br/>    server = grpc.server(futures.ThreadPoolExecutor(max_workers=4))<br/>    hello_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)<br/>    server.add_insecure_port('[::]:50051')<br/>    server.start()<br/>    server.wait_for_termination()</span></pre><p id="e010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将使用端口50051上的4个工作线程运行服务器。</p><p id="f951" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件底部添加以下代码作为最后一笔:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="8074" class="nr mv it mh b gy oh oi l oj ok">if __name__ == '__main__':<br/>    logging.basicConfig()<br/>    serve()</span></pre><p id="b8ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下网址找到完整的服务器代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="eaf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您的工作目录中运行以下命令:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="e65d" class="nr mv it mh b gy oh oi l oj ok">python server.py</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5a43" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">gRPC客户端</h1><p id="3cb9" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">完成服务器代码后，创建一个名为<code class="fe me mf mg mh b">client.py</code>的新Python文件。</p><h2 id="76a3" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">导入</h2><p id="1cd5" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在文件顶部添加以下导入语句:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="4ff1" class="nr mv it mh b gy oh oi l oj ok">import logging<br/>import os<br/>import grpc<br/>from protos import hello_pb2, hello_pb2_grpc</span></pre><h2 id="c152" class="nr mv it bd mw ns nt dn na nu nv dp ne li nw nx ng lm ny nz ni lq oa ob nk oc bi translated">主要功能</h2><p id="bf58" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">继续添加一个名为<code class="fe me mf mg mh b">run</code>的新函数，代码如下:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="93aa" class="nr mv it mh b gy oh oi l oj ok">def run():<br/>    with grpc.insecure_channel('localhost:50051') as channel:<br/>        stub = hello_pb2_grpc.GreeterStub(channel)<br/>        response = stub.SayHello(hello_pb2.HelloRequest(name='John Doe', age=30))<br/>        print("Greeter client received: " + response.message)</span></pre><p id="50e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将在端口50051连接到gRPC服务器，并使用以下输入调用SayHello rpc:</p><ul class=""><li id="be14" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">name</code> —无名氏</li><li id="7a71" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">age</code> — 30</li></ul><p id="e9c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe me mf mg mh b">client.py</code>脚本的末尾添加以下代码:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="75a3" class="nr mv it mh b gy oh oi l oj ok">if __name__ == '__main__':<br/>    logging.basicConfig()<br/>    run()</span></pre><p id="dd80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看下面的代码片段作为参考:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="bd64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保您当前正在运行<code class="fe me mf mg mh b">server.py</code>。打开一个新终端并运行以下命令:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="5597" class="nr mv it mh b gy oh oi l oj ok">python client.py</span></pre><p id="966e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到以下输出:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="9968" class="nr mv it mh b gy oh oi l oj ok">Greeter client received: Hello, John Doe! Your age is 30</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5d9f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">更新流媒体服务</h1><p id="b4f7" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">对于文件响应，最好的方法是通过流返回字节。您可以按如下方式定义消息:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="2b7d" class="nr mv it mh b gy oh oi l oj ok">message FileResponse {<br/>  bytes chunk_data = 1;<br/>}</span></pre><p id="3bdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于文件请求，在使用它作为消息的定制字段类型之前，首先创建一个<code class="fe me mf mg mh b">MetaData</code>消息是一个好主意。</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="1e5e" class="nr mv it mh b gy oh oi l oj ok">message MetaData {<br/>  string filename = 1;<br/>  string extension = 2;<br/>}</span></pre><p id="f424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许您传递图像/音频/视频/文件数据以及其他重要信息。由于流式传输将在文件结束之前被间隔调用，我们可以避免通过<code class="fe me mf mg mh b">oneof</code>关键字发送相同的信息。</p><blockquote class="om on oo"><p id="5548" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated"><code class="fe me mf mg mh b">oneof</code>除了<code class="fe me mf mg mh b">oneof</code>中的所有字段共享内存之外，字段与常规字段类似，并且最多可以同时设置一个字段。</p></blockquote><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="7f1e" class="nr mv it mh b gy oh oi l oj ok">message UploadFileRequest {<br/>  oneof request {<br/>    MetaData metadata = 1;<br/>    bytes chunk_data = 2;<br/>  }<br/>}</span></pre><p id="228a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们可以先发送<code class="fe me mf mg mh b">Metadata</code>消息，然后将文件传输到gRPC服务器。</p><p id="b5ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要用两个新的rpc来更新欢迎服务:</p><ul class=""><li id="dc6f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">上传文件</li><li id="f133" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">下载文件</li></ul><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="d99e" class="nr mv it mh b gy oh oi l oj ok">service Greeter {<br/> rpc SayHello (HelloRequest) returns (StringResponse) {}<br/> rpc UploadFile(stream UploadFileRequest) returns (StringResponse) {}<br/> rpc DownloadFile(MetaData) returns (stream FileResponse) {}<br/>}</span></pre><blockquote class="om on oo"><p id="d4d1" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">在流式功能的请求或响应消息前添加<code class="fe me mf mg mh b">stream</code>关键字。</p></blockquote><p id="c195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在以下要点中找到完整的<code class="fe me mf mg mh b">hello.proto</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="3c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住运行以下命令来重新生成gRPC代码:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="ea1e" class="nr mv it mh b gy oh oi l oj ok">python -m grpc_tools.protoc -I=. --python_out=. --grpc_python_out=. ./protos/hello.proto</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0131" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">更新gRPC服务器</h1><p id="eb0a" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在<code class="fe me mf mg mh b">Greeter</code>服务下用两个新功能修改<code class="fe me mf mg mh b">server.py</code>文件:</p><ul class=""><li id="7ab8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe me mf mg mh b">UploadFile</code></li><li id="0346" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><code class="fe me mf mg mh b">DownloadFile</code></li></ul><p id="2b84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe me mf mg mh b">SayHello</code>函数不同，<code class="fe me mf mg mh b">UploadFile</code>的输入参数是一个迭代器，因为我们已经将它指定为一个流请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="d0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环遍历迭代器以获取请求字段。由于我们使用了<code class="fe me mf mg mh b">oneof</code>关键字，迭代器中的每个请求可以是<code class="fe me mf mg mh b">MetaData</code>或<code class="fe me mf mg mh b">bytes</code>。我们可以很容易地使用条件检查来确定内容并相应地处理它。</p><p id="77cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将把<code class="fe me mf mg mh b">chunk_data</code>存储到一个<code class="fe me mf mg mh b">bytearray</code>变量中，并保存在流的末尾。然后，我们向客户端返回一条<code class="fe me mf mg mh b">StringResponse</code>消息。</p><p id="113b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同时，<code class="fe me mf mg mh b">DownloadFile</code>函数将把一个文件流回客户机。最简单的实现是逐块读取文件，并将其作为<code class="fe me mf mg mh b">FileResponse</code>消息返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><blockquote class="om on oo"><p id="8c17" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">出于演示目的，我将chunk_size设置为1024。根据您的使用情况，您可以将其设置为更高的值。</p></blockquote><p id="7e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有流功能的<code class="fe me mf mg mh b">server.py</code>的完整代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="1526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用以下命令停止服务器并重新运行它:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="a220" class="nr mv it mh b gy oh oi l oj ok">python server.py</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2d34" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">更新gRPC客户端</h1><p id="ba60" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们更新<code class="fe me mf mg mh b">client.py</code>文件来调用以下函数:</p><ul class=""><li id="aedd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">上传文件</li><li id="2c40" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">下载文件</li></ul><p id="4f35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe me mf mg mh b">UploadFile</code> rpc接受一个迭代器，因为它是一个流请求。因此，创建一个名为<code class="fe me mf mg mh b">read_iterfile</code>的新迭代器来逐块读取文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><blockquote class="om on oo"><p id="67e4" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">出于演示目的，我将<code class="fe me mf mg mh b">chunk_size</code>设置为1024。根据您的用例修改它。</p></blockquote><p id="d723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，可以如下调用<code class="fe me mf mg mh b">rpc</code>:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="0665" class="nr mv it mh b gy oh oi l oj ok">def run():<br/>    with grpc.insecure_channel('localhost:50051') as channel:<br/>        ...</span><span id="9509" class="nr mv it mh b gy ol oi l oj ok">        response = stub.UploadFile(read_iterfile('test.txt'))<br/>        print("Greeter client received: " + response.message)</span></pre><blockquote class="om on oo"><p id="d5b1" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">用文件的路径替换<code class="fe me mf mg mh b">test.txt</code>。</p></blockquote><p id="490e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe me mf mg mh b">DownloadFile</code> rpc返回一个流响应。我们可以很容易地对它进行迭代，并逐块保存文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><blockquote class="om on oo"><p id="5786" class="kz la op lb b lc ld ju le lf lg jx lh oq lj lk ll or ln lo lp os lr ls lt lu im bi translated">根据您的用例替换<code class="fe me mf mg mh b">filename</code>和<code class="fe me mf mg mh b">extension</code>变量的值。</p></blockquote><p id="7dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">client.py</code>的完整代码位于以下要点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="f2e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行以下命令，测试通过gRPC上传和下载文件的情况:</p><pre class="kj kk kl km gt od mh oe of aw og bi"><span id="0a8d" class="nr mv it mh b gy oh oi l oj ok">python client.py</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="7d1d" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="26a8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">让我们回顾一下你今天所学的内容。</p><p id="b107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文首先简要介绍了gRPC，然后继续介绍设置和安装。</p><p id="26af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，讨论了通过协议缓冲区的消息和服务定义。它还强调了生成供客户机和服务器应用程序使用的gRPC代码的步骤。</p><p id="ed14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还解释了基本的客户机和服务器代码实现。随后，它提供了代码来更新现有的代码，以便通过流媒体上传和下载文件。</p><p id="a89a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢你阅读这篇文章。请随意查看我的其他文章。祝你有美好的一天！</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="73bc" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">参考</h1><ol class=""><li id="9eaa" class="lv lw it lb b lc nm lf nn li ov lm ow lq ox lu oy mb mc md bi translated"><a class="ae ky" href="https://grpc.io/docs/languages/python/quickstart/" rel="noopener ugc nofollow" target="_blank"> gRPC文档—快速入门</a></li><li id="d3a0" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu oy mb mc md bi translated"><a class="ae ky" href="https://developers.google.com/protocol-buffers/docs/proto3" rel="noopener ugc nofollow" target="_blank"> proto3 —语言指南</a></li></ol></div></div>    
</body>
</html>