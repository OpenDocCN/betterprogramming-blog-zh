<html>
<head>
<title>Complexity Analysis of Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法的复杂性分析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/complexity-analysis-of-an-algorithm-2268e19b29ef?source=collection_archive---------12-----------------------#2020-04-20">https://betterprogramming.pub/complexity-analysis-of-an-algorithm-2268e19b29ef?source=collection_archive---------12-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b238" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何理解您正在编写的算法的详细指南，加上一些大O符号</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1dc70106d115350d85bb9488f92d8b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzvg-1oRdZLmaAnQasSnUA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@hikeshaw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">H . Shaw</a>在<a class="ae kv" href="https://unsplash.com/s/photos/complex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们将讨论计算机科学中最重要但也是最令人恐惧的话题之一——算法复杂性，尤其是时间复杂性。因为时间就是金钱！</p><p id="30fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:在本文中，我们交替使用算法和程序这两个词。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f788" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是复杂性分析？</h1><p id="0308" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">它是一个工具，允许我们解释当输入越来越大时，算法将如何运行。</p><p id="a180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，有人可能会问，为什么我们需要计算一个程序有多复杂？只要给它足够快的硬件和更多的资源，程序应该是罚款，对不对？</p><p id="0141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，也许在理想世界里，每个程序员都希望自己生活在其中。在现实世界中，我们需要关注复杂性，因为硬件和资源都是要花钱的。</p><p id="e53f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果一个程序花一秒钟为一个用户完成工作，想象一下如果有一百万个用户会发生什么。随着用户数量的增加(即输入数量的增加)，程序占用的资源越来越多(即复杂性的增加)。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2af0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">我们不能使用Profilers吗？</h1><p id="5262" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Profilers是可以测量程序运行速度的程序，以毫秒或秒为单位。因此，有人会认为我们可以只比较两个程序执行所需的秒数。目标实现。对吗？实际上，不完全是。</p><p id="7d42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个例子:一个程序需要一秒钟来为一个用户完成它的工作。对于不同的编程语言，这一秒钟可能会有所不同。你可能会有一个用低级语言编写的非常糟糕的程序，比如汇编，它可能需要和用高级语言编写的非常好的程序一样长的时间来执行，比如Swift或Java。我们可以得出结论，时间不是衡量一个好的、有效的计划的方式。我们又回到起点了。我们如何计算算法复杂性？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="aac4" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">算法复杂性</h1><p id="06ef" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">算法复杂性是设计用来在思想层面比较两种算法的，而忽略了底层细节，如运行的硬件、编程语言等。</p><p id="b51b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个JavaScript的例子:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="f0ff" class="nc mb iq my b gy nd ne l nf ng">var number = list[0];</span></pre><p id="e40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你能数出这一行代码中有多少条指令吗？</p><p id="cb9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是两个。为什么？：</p><ul class=""><li id="9f00" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">第一个指令是从“列表”中查找0ᵗʰ索引处的对象</li><li id="5051" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">第二条指令是将该对象分配到一个新的变量“数字”中。</li></ul><p id="e0a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，对于上面的一行程序，我们可以说<em class="ls"> f </em> ( <em class="ls"> n </em> ) <em class="ls"> = 2 </em>。无论如何，这个程序中的指令数将是2。</p><p id="1434" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果你不熟悉数学记数法f(n) </em> <a class="ae kv" href="https://www.mathsisfun.com/sets/function.html" rel="noopener ugc nofollow" target="_blank"> <em class="ls">这里阅读更多</em> </a> <em class="ls">。</em></p><p id="6063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们举一个更复杂的例子:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="cac8" class="nc mb iq my b gy nd ne l nf ng">var number = list[0];<br/>for (var i=0; i&lt;n; ++i) {<br/>   if (list[i] &gt;= number) {<br/>      number = list[i];<br/>   }<br/>}</span></pre><p id="a7f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你能列出上面代码中的所有指令吗？我会等的。试试吧。</p><p id="78d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们是:</p><ul class=""><li id="7154" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">从列表中查找0ᵗʰ对象。</li><li id="0d42" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">把上面的物体分配给数字。</li><li id="6a05" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">创建值为0的变量“I”。</li><li id="7609" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">比较` i <n/></li><li id="8853" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Get an ith object from the list.</li><li id="1291" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Compare it with number.</li><li id="b06c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Again, get an ith object from the list.</li><li id="2305" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Assign it to the number.</li><li id="9b02" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">For the next loop iteration, compare `i<n/></li><li id="9b31" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">Increment `i` (at ++i).</li></ul><p id="e6d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">The last six instructions are only performed if the loop executes at least once when the <em class="ls"> n &gt; 0 </em>。</p><p id="b817" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，指令的数量不是一个确定的数字，它随输入n而变化。</p><ul class=""><li id="919c" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">如果<em class="ls"> n </em> =0，将执行前4 + 2 (=6)条指令。因为循环将检查“i &lt; n”并立即退出。继续，手动运行并验证它。</li><li id="772c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">如果<em class="ls"> n </em> =1，将执行所有4 + 6 (=10)条指令。其中6是循环执行的指令数。</li><li id="aa3f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">如果<em class="ls"> n </em> =2，将执行所有4 + 6*2 (=16)条指令。因为循环执行了两次。</li></ul><p id="2338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以把上面的函数写成4 + 6 <em class="ls"> n </em>，其中<em class="ls"> n </em>是提供给程序的输入，因为循环执行了n次。</p><p id="ff59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">最终答案:<em class="ls">f</em>(<em class="ls">n</em>)<em class="ls">= 4+6n</em>。</strong></p><p id="a94e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的复杂性计算听起来可能足够好，但它不是计算复杂性的最佳方法。想象一下为一个非常非常大的程序计算指令。为了简化，我们可以利用渐近行为。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="eca5" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">渐近行为</h1><p id="e96c" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">用简单的数学语言来说，渐近行为是一种限制行为的方法。没明白吗？别担心。只是跟着走。</p><h2 id="b79b" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">举例说明</h2><p id="d14e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">假设我们对函数<em class="ls"> f </em> ( <em class="ls"> n </em>)的性质感兴趣，因为<em class="ls"> n </em>变得非常大。如果<em class="ls"> f(n) = n </em> <em class="ls"> + 3n，</em>那么随着<em class="ls"> n </em>变得非常大，项<em class="ls"> 3n </em>与<em class="ls"> n </em>相比变得无关紧要。函数<em class="ls"> f(n) </em>被称为“渐近等价于<em class="ls"> n </em>”。在维基百科上阅读<a class="ae kv" href="https://en.wikipedia.org/wiki/Asymptotic_analysis" rel="noopener ugc nofollow" target="_blank">更多这方面的内容。</a></p><p id="1fcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，我们可以简单地把<em class="ls"> f(n)=4+6n </em>写成<em class="ls"> f(n)=6n </em>因为随着<em class="ls"> n </em>变大，常数4变得无关紧要。</p><p id="a2ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们正在从<em class="ls"> 6n </em>投放<em class="ls"> 6 </em>。为什么？因为不同的编程语言对同一代码块执行不同数量的指令是有道理的。此外，我们只对最大的增长项(到无穷大)感兴趣，它是<em class="ls"> n </em>。于是，我们的<em class="ls"> f(n)=6n </em>就变成了刚好<em class="ls"> f(n)=n </em>。(在数学中这是不允许的，但是在计算机科学中，由于上面给出的原因，这是允许的。)</p><p id="c68c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这告诉我们的是放弃所有的装饰常数。这使得检测程序的渐近行为变得非常容易，我们不必计算指令，这是一种解脱。</p><h2 id="7281" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">实践</h2><p id="8e81" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们看一些例子，找到渐近行为，</p><ul class=""><li id="2c7c" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><em class="ls"> f(n) = 5n + 12 </em>给出<em class="ls"> f(n) = n </em>。因为我们必须同时放弃12和5。</li><li id="b0f5" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><em class="ls"> f(n) = 2 </em>给出<em class="ls"> f(n) = 1 </em>。我们去掉了乘数2 * 1，但是我们仍然需要在这里放一个1来表示这个函数有一个非零值。当一个程序有<em class="ls"> f(n)=1 </em>的复杂度时，它被认为是最好的。</li><li id="66e2" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><em class="ls"> f(n) = n + 10000n + 56675 </em>给出<em class="ls"> f(n) = n </em>。即使前面的因子if <em class="ls"> n </em>很大，我们仍然可以找到一个值为<em class="ls"> n </em>，这使得<em class="ls"> n </em>大于等式中的所有其他项。</li></ul><p id="dd72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">经验法则:</em> </strong> <em class="ls">对于一个不执行循环或递归的程序，复杂度将为f(n)=1。如果我们回到上面的一行程序，f(n)将永远是1，因为即使列表有一百万个对象，指令的数量也不会改变。</em></p><p id="e7f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果一个程序有多个顺序循环，其中最慢的一个决定了渐近行为。两个嵌套循环后跟一个单独的循环在渐近上与单独的嵌套循环相同，因为嵌套循环在简单循环中占主导地位。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0166" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">“奇特的”θ(theta)符号</h1><h2 id="81b5" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">这是什么？</h2><p id="a4c4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">到目前为止，我们已经使用数学<em class="ls"> f(n) </em>来表示程序的渐近行为。现在我们将转向计算机科学符号，即θ符号。</p><p id="1adb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">渐近地，我们会说我们的程序是θ<em class="ls">(f(n))，</em>也是我们的程序有<em class="ls"> f(n) </em> =1变成θ(1)，<em class="ls"> f(n)=n </em>变成θ(<em class="ls">n</em>)等等。</p><h2 id="ef18" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated"><strong class="ak">θ(n)读作“n的θ<em class="og">”</em></strong></h2><p id="fa49" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">比如我们可以说<em class="ls"> f(n) </em> = <em class="ls"> 2n </em>是一个函数是<em class="ls">θ(n)</em>。我们也可以把<em class="ls">2n∈θ(n)</em>写成“两个<em class="ls"> n </em>是<em class="ls"> n. </em>的θ”</p><p id="3d2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，那是什么意思？不要迷惑。我们要说的是，如果我们已经计算了一个程序需要的指令的数量，这些指令是<em class="ls"> 2n </em>，那么我们算法的渐近行为由<em class="ls"> n </em>描述，这是我们通过丢弃常数找到的。我们已经经历过了。这里没什么新鲜的。</p><p id="a51b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们应用上面的符号，下面是一些真正的数学陈述:</p><ul class=""><li id="5521" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><em class="ls">n⁶+3n∈θ(n⁶)</em></li><li id="cf7b" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><em class="ls">2ⁿ+12∈θ(2ⁿ)</em></li><li id="6531" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><em class="ls">3ⁿ+2ⁿ∈θ(3ⁿ)</em></li><li id="f8e5" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><em class="ls">nⁿ+n∈θ(nⁿ)</em></li></ul><p id="4bc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们放在θ(<em class="ls">这里是</em>)里面的东西，叫做时间复杂度，或者只是我们程序的复杂度。所以，一个带有θ(<em class="ls">n</em>)的程序是复杂的<em class="ls"> n </em>。带有θ(<em class="ls">n</em>)的程序是复杂的<em class="ls"> n </em>。</p><p id="daf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对θ(1)、θ(n)、θ(<em class="ls">n</em>)和θ(log(<em class="ls">n</em>))也有专门的称呼，因为它们经常出现。它们如下:</p><ul class=""><li id="364a" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">θ(1)=恒定时间复杂度。</li><li id="3046" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">θ(<em class="ls">n</em>)=线性复杂度。</li><li id="dc4c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">θ(<em class="ls">n</em>)=二次复杂度。</li><li id="dee8" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">θ(log(<em class="ls">n</em>)=对数复杂度。</li></ul><p id="b006" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经验法则:θ较大的程序比θ较小的程序运行得慢。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5233" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">大O符号</h1><p id="2548" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我打赌你已经听过很多次了。可能你在面试的时候被问到过这个问题。大O是最受欢迎的术语，因为它更糟糕。不，不，这不是更差，而是更差的时间复杂度符号。所以，它说的是一个程序，它的表现有多差。因此，所述程序将<strong class="ky ir">永远不会</strong>超过某个界限。简而言之，Big-O符号只是一个上限！</p><h2 id="2f19" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">这是什么？</h2><p id="a986" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们如何找到这个上限？更重要的是，当我们已经如上所述计算出精确的复杂度时，为什么我们还需要找到一个上界呢？嗯，有一个很好的理由这么做。</p><p id="a256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，计算一个程序的θ(<em class="ls">n</em>)复杂度真的很难，在这种情况下，我们必须让程序变得比原来更糟，以便简化复杂度计算。</p><h2 id="b70a" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">举例说明</h2><p id="3ec9" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">例如，在一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Selection_sort" rel="noopener ugc nofollow" target="_blank">选择排序</a>程序中，外循环执行<em class="ls"> n次</em>次，但是内循环执行<em class="ls"> n-1 </em>次，然后<em class="ls"> n-2 </em>次等等，直到外循环的最后一次迭代，在此期间内循环将只运行一次。</p><p id="10b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们必须计算出内循环的总和<em class="ls"> n + (n-1) + (n-2) + … + 2 + 1 </em>。外环复杂度计算很容易，它将是“<em class="ls"> n </em>”。在这种情况下，为了使复杂性计算更容易，我们使程序变得更糟——我们使内部循环变得更糟。怎么会？不是让它运行<em class="ls"> n </em>然后<em class="ls"> n-1 </em>等等，而是让它运行<em class="ls"> n </em>次。</p><p id="0ead" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在很容易将复杂度计算为θ(<em class="ls">n</em>)，因为有两个循环正好运行了<em class="ls"> n </em>次。还有，由于我们的程序不比<em class="ls"> n </em>差，可以说我们原来的算法是O( <em class="ls"> n </em>)。所以，我们的程序可以比O( <em class="ls"> n </em>)更好但不会更差。就说这么多。</p><h2 id="6494" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated"><strong class="ak"> O( <em class="og"> n </em>)读作<em class="og"> n </em>平方的大oh】</strong></h2><p id="db91" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果一个原始的(即未改变的)程序的复杂度是θ(<em class="ls">n</em>)，那么我们可以说它实际上是O( <em class="ls"> n </em>)，因为大O只是一个更差的程序复杂度。但是，如果一个原始程序的Big-O复杂度是O( <em class="ls"> n </em>)，那么这意味着该程序的更差复杂度是O( <em class="ls"> n </em>)，该程序可能已经被改变，以便导出O( <em class="ls"> n </em>)。所以这个程序可能是θ(<em class="ls">n</em>)或者更好，可能是θ(<em class="ls">n</em>)或者θ(1)。</p><p id="7d38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综上，如果我们的程序是θ(<em class="ls">n</em>)，我们还是可以说是O( <em class="ls"> n </em>)。但是反过来并不总是正确的。概而言之，任何为θ(<em class="ls">a</em>)的程序都是O( <em class="ls"> b </em>)其中<em class="ls"> b </em>比<em class="ls"> a </em>差。</p><p id="cb79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，我们对程序的修改并不需要给我们一个实际上有意义或等同于我们原来程序的程序。对于给定的n，它只需要执行比原始指令更多的指令。我们使用它只是为了计算指令，而不是实际解决我们的问题。</p><h2 id="9289" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">实践</h2><p id="2074" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们来看几个例子。找出以下哪些是正确的:</p><ol class=""><li id="8e29" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi translated">一个θ(<em class="ls">n</em>)算法是O( <em class="ls"> n </em>)</li><li id="93a9" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">一个θ(<em class="ls">n</em>)算法是O( <em class="ls"> n </em>)</li><li id="c05f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">一个θ(<em class="ls">n</em>)算法是O( <em class="ls"> n </em>)</li><li id="8f18" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">一个θ(<em class="ls">n</em>)算法是O(1)</li><li id="108d" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">一个O(1)算法是θ(1)]</li><li id="0004" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">一个O( <em class="ls"> n </em>)算法是θ(1)</li></ol><h2 id="895c" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated"><strong class="ak">解决方案</strong></h2><ol class=""><li id="ef34" class="nh ni iq ky b kz ms lc mt lf oi lj oj ln ok lr oh nn no np bi translated"><strong class="ky ir">Aθ(<em class="ls">n</em>)算法为O( <em class="ls"> n </em> ) </strong>:真。我们肯定可以在不改变原程序的情况下实现O( <em class="ls"> n </em>)。</li><li id="c75e" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir">Aθ(<em class="ls">n</em>)算法为O( <em class="ls"> n </em> ) </strong>:由于<em class="ls"> n </em>比<em class="ls"> n </em>差，这个是真的。</li><li id="c613" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir">Aθ(<em class="ls">n</em>)算法为O( <em class="ls"> n </em> ) </strong> : As <em class="ls"> n </em>比<em class="ls"> n </em>差，这个是真的。</li><li id="8efa" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir">Aθ(<em class="ls">n</em>)算法为O(1) </strong>:此为假。因为O(1)应该比θ(<em class="ls">n</em>)差。反而其实更好。</li><li id="8b91" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir">一个O(1)算法是θ(1):</strong>真。因为这两种复杂性是相同的。</li><li id="5d5b" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir"> A O( <em class="ls"> n </em>)算法是θ(1)</strong>:A O(<em class="ls">n</em>)程序可以是θ(<em class="ls">n</em>)也可以是θ(1)。如果是θ(<em class="ls">n</em>)那么这将为假，否则如果是θ(1)这将为真。所以，这是真/假取决于程序。但一般来说，这是错误的。</li></ol><p id="10fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我之前说过，O是复杂度的上限。O界有两种类型，紧界和上界。如果一个程序是θ(<em class="ls">n</em>)和O( <em class="ls"> n </em>)，那么O( <em class="ls"> n </em>)就是一个紧界，因为它和θ(<em class="ls">n</em>)相同。如果一个程序是θ(1)且O(1)或O( <em class="ls"> n </em>)那么O(1)称为紧界，O( <em class="ls"> n </em>)则不是紧界，只是上界(也许我们可以称之为弱界，我不知道)。</p><p id="6777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们找到的界不是紧界，那么我们可以把is写成o( <em class="ls"> n </em>)，读作“小o的<em class="ls"> n，</em>”来说明我们知道我们的界不是紧的。</p><p id="2dcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们能找到紧边界就更好了，因为这些能给我们更多关于程序行为的信息。我想这就是为什么“O”比“O”用得少的原因。但是，这并不总是容易做到的。</p><h2 id="786e" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">总结一下，数学上我们可以写，(这是我怎么记得的)</h2><p id="ab05" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">θ≤O≤O(读作θ小于/等于Big-O，而Big-O小于/等于Small-o)</p><p id="6a9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">经验法则:</em> </strong> <em class="ls">算出一个算法的O复杂度比θ复杂度更容易。</em></p><p id="7ed8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你已经和θ，O，O讲和了，因为在结束符号部分之前，我们将再引入两个符号。它们很容易理解，我保证！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="503c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">大欧米伽符号</h1><h2 id="95f4" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">这是什么？</h2><p id="6d69" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们在上面看到了Big-O符号，它告诉我们程序的极限，在这里我们的程序不会比一个特定的界限慢。如果我们反其道而行之，修改我们的程序使之更好，并计算复杂性，我们使用符号ω，读作“big-omega”这给了我们复杂性，我们知道我们的程序不会更好。当我们想要证明一个程序运行缓慢或者是一个坏程序时，这是特别有用的。</p><p id="8981" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">比如我们说算法是ω(<em class="ls">n</em>)，那么算法不可能比<em class="ls"> n </em>更好。可能是θ(<em class="ls">n</em>)或者θ(<em class="ls">n</em>⁴)或者更糟。所以，ω给了我们一个算法复杂度的下界。</p><p id="40e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于小o，如果我们知道我们的界不是紧的，我们可以写ω。比如一个θ(<em class="ls">n</em>)算法是ω(<em class="ls">n</em>)和ω( <em class="ls"> n </em> ⁴).</p><p id="50c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，从数学上讲，ω≤ω≤θ(读作小ω比大ω小/相等，大ω比θ小/相等)</p><h2 id="463f" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">实践</h2><p id="b415" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们练习一下。对于以下θ复杂性，写下一个紧和非紧O界，以及一个你选择的紧和非紧ω界，前提是它们存在。</p><ol class=""><li id="6dab" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi">Θ(1)</li><li id="7c91" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">θ(√<em class="ls">n</em>)(<em class="ls">n</em>的平方根)</li><li id="82ff" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">θ(<em class="ls">n</em>)</li></ol><h2 id="35c1" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">解决方法</h2><ol class=""><li id="14cb" class="nh ni iq ky b kz ms lc mt lf oi lj oj ln ok lr oh nn no np bi translated">严格的界限将是O(1)和ω(1)。非紧界O将是o( <em class="ls"> n </em>)。这些函数不能小于1，所以不存在非紧ω界。</li><li id="977d" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">紧边界将是O(√ <em class="ls"> n </em>)和ω(√<em class="ls">n</em>)。当<em class="ls"> n </em>大于√ <em class="ls"> n </em>时，非紧O界限将为o( <em class="ls"> n </em>)。当1小于√n时，非紧ω界为ω(1)。</li><li id="e84d" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated">紧边界将是O( <em class="ls"> n </em>)和ω(<em class="ls">n</em>)。非紧o绑定将是o( <em class="ls"> n </em> ⁴)或o( <em class="ls"> n </em> ⁵)或o( <em class="ls"> n </em> ⁶).)非紧ω界限将是ω( <em class="ls"> n </em>)或ω( <em class="ls"> n </em>)或ω(√ <em class="ls"> n </em>)或ω(1)。</li></ol><p id="633d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不记得所有的符号和它们的用法，也不要担心。最重要的符号是O和θ。</p><p id="5074" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">经验法则:</em> </strong> <em class="ls">所有的符号O、O、ω、ω和θ有时都是有用的，O是最常用的，因为它比θ更容易确定，也比ω更实用。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1417" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">θ、O和ω符号概述</h1><p id="a432" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">ω≤ω≤θ≤O≤O(这个应该不需要解释)。</p><h2 id="c81e" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">一些幽默</h2><p id="05e6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><em class="ls">(感谢</em><a class="ae kv" href="https://www.youtube.com/channel/UCAiE4uwGJqERSzr174WbJZA" rel="noopener ugc nofollow" target="_blank"><em class="ls">【Mitch Mithunpaul】</em></a><em class="ls">，以下是来自他的YouTube评论)</em></p><p id="2402" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大O就像一个老大哥说:无论你做什么，你永远不会比我好。</p><p id="6c8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欧米茄就像你的小弟弟，他说，做你想做的任何坏事，但如果你跌倒，我会在那里接住你。</p><p id="293f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">西塔就像你的妹妹，根据恶作剧的利害关系——被吼还是糖果，她不停地转换立场。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5c4a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">对数</h1><p id="52bf" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果你知道对数是什么，请随意跳过这一节。这只是简单的介绍。</p><h2 id="ef8f" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">定义</h2><p id="fdc0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">对数是一种应用于数字的运算，它使数字变小，很像数字的平方根。老实说，这个定义并不适合我——我总是需要一个合乎逻辑的例子来更好地理解。</p><h2 id="7a0e" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">例子</h2><p id="3c6d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">2ˣ = 1024.如果我们想解出这个x的方程，我们需要找到一个数，当它被应用于2时，结果是1024。现在，我们可以手工做这个，解出x，我们会得到10乘以2的⁰=1024.对数帮助我们用一种新的符号来表示这一点。在这种情况下，10是1024的以2为底的对数，我们可以把它写成log₂(1024，读作1024的以2为底的对数。</p><h2 id="b76e" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">概括来说:</h2><p id="bd4b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">对于2ˣ = N，那么log₂(N) = x</p><h2 id="c0af" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">使用以2为底的对数</h2><p id="fe5e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">因为我们用2作为基数，所以这些对数叫做以2为基数的对数。我们将只使用基数为2的对数，因为它们比任何其他类型的对数都更常见。这是因为我们通常只有两个不同的实体:0和1。</p><p id="db84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="http://tutorial.math.lamar.edu/Classes/Alg/LogFunctions.aspx" rel="noopener ugc nofollow" target="_blank"> <em class="ls">如果你想练习对数</em> </a> <em class="ls">。</em></p><h2 id="bc37" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">实践</h2><p id="60a4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">指出你在下面每种情况下找到的对数(以2为底):</p><ol class=""><li id="fb9e" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr oh nn no np bi">2ˣ = 64</li><li id="f495" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi">(2²)ˣ = 64</li><li id="a67f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi">4ˣ = 4</li><li id="c775" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi">2ˣ = 1</li><li id="722f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi">2ˣ + 2ˣ = 32</li><li id="cf0f" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi">(2ˣ) * (2ˣ) = 64</li></ol><h2 id="9160" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">解决方法</h2><ol class=""><li id="caa1" class="nh ni iq ky b kz ms lc mt lf oi lj oj ln ok lr oh nn no np bi translated">2ˣ = 64 :这个很简单。就像我们之前看到的例子一样。这里x会是6。因此，log(64)=6。</li><li id="a57c" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir"> ( )ˣ = 64 </strong>:我们可以把这个简化为2个ˣ.如果我们解出x，我们会得到3，那么它就变得和上面第一个问题一样了。因此，log(64)=6。</li><li id="2233" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir"> 4ˣ = 4 </strong>:记住，我们必须在等式的左边使用2，因此我们将它重写为2 ˣ，这与第二个问题相同。解出x后，我们会发现1。因此，log(4)=2。</li><li id="e665" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir"> 2ˣ = 1 </strong> : log(1)=0。因为x需要为0才能让左边变成1。</li><li id="6bf4" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir"> 2ˣ + 2ˣ = 32 </strong>:我们可以把这个函数简化为2*2ˣ = 2 *2ˣ = 2 ⁺ˣ，求解x后，我们会发现4。因此，2 ⁺⁴=32，因此log(32)=5。</li><li id="95b7" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr oh nn no np bi translated"><strong class="ky ir"> (2ˣ) * (2ˣ) = 64 </strong>:我们可以把这个改写成2ˣ⁺ˣ = 2 ˣ.这和第二个问题是一样的。因此，log(64)=6。</li></ol></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e9b3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">递归复杂性</h1><p id="1139" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们大多数人都知道什么是递归函数——我们在大学的阶乘程序中做过。</p><h2 id="c363" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">定义</h2><p id="0885" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">递归函数是调用自身的函数。</p><h2 id="21eb" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">例子</h2><p id="d279" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">正如我之前提到的，我们都见过的最常见的例子是阶乘。阶乘程序可以递归编写——显然是一个非常短的程序。</p><h2 id="60ff" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">分析复杂性</h2><p id="234d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们来分析一下这个程序的复杂度。它没有任何循环，但复杂度不是常数。如果我们只是简单地回到基础(计算指令)，我们会清楚地发现程序执行了n次。所以函数是θ(<em class="ls">n</em>)，线性复杂度。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="cdba" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">对数复杂度</h1><h2 id="26fa" class="nc mb iq bd mc nv nw dn mg nx ny dp mk lf nz oa mm lj ob oc mo ln od oe mq of bi translated">二分搜索法的例子</h2><p id="fd73" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">正如我在对数部分提到的，对数使n变得更小。一个著名的问题是<a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法</a>。二分搜索法通过将数组切成两半来查找数组中的元素，并继续这样做，直到找到该元素。</p><p id="ab2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二分搜索法最简单的实现是递归算法。因此，对于每个调用，数组中的元素数量将减半:</p><p id="7e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">0ᵗʰ迭代:<em class="ls"> n </em> <br/> 1ˢᵗ迭代:<em class="ls"> n </em> / 2 <br/> 2ⁿᵈ迭代:<em class="ls"> n </em> / 4 <br/> 3ʳᵈ迭代:<em class="ls">n</em>/8<br/>…<br/><em class="ls">I</em>ᵗʰ迭代:<em class="ls">n</em>/2<em class="ls">ⁱ</em><br/>…<br/>最后一次迭代:1</p><p id="8d6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，在I-迭代中，我们的数组有<em class="ls"> n </em> / 2 <em class="ls"> ⁱ </em>个元素。如果我们希望找到哪个迭代将是最后一次迭代，1 = <em class="ls"> n </em> / 2 <em class="ls"> ⁱ </em>必须重写为2 <em class="ls"> ⁱ </em> = <em class="ls"> n </em>。</p><p id="0497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，使用对数，i = log( <em class="ls"> n </em>)。这告诉我们，执行二分搜索法所需的指令数量是log( <em class="ls"> n </em>)，其中n是输入数组中元素的数量。</p><p id="cffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我们比较二分搜索法算法和线性搜索算法。线性搜索算法复杂度为O( <em class="ls"> n </em>)。我们可以清楚地看到，log( <em class="ls"> n </em>)比n小得多，所以，我们可以得出结论，二分搜索法算法肯定比线性搜索算法好。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="1136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你学会了这个看似很难的题目。等你熬过来了就好办了！</p><p id="ebf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你已经走到这一步，我衷心感谢你。我知道这是一篇非常长的文章，但有专门关于算法复杂性的书籍——我在这里试图做的是总结我从Dionysis Zindros的文章中所学到的东西，正如本文结尾所提到的。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="8a5e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">一些附加材料</h1><ul class=""><li id="b6c5" class="nh ni iq ky b kz ms lc mt lf oi lj oj ln ok lr nm nn no np bi translated">哈佛CS50 —渐近符号<br/><a class="ae kv" href="https://youtu.be/iOq5kSKqeR4" rel="noopener ugc nofollow" target="_blank">https://youtu.be/iOq5kSKqeR4</a></li><li id="6a6d" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">大O记法(通用快速教程)<br/><a class="ae kv" href="https://youtu.be/V6mKVRU1evU" rel="noopener ugc nofollow" target="_blank">https://youtu.be/V6mKVRU1evU</a></li><li id="8141" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">大O符号(还有ω和θ)—最佳数学解释<br/><a class="ae kv" href="https://youtu.be/ei-A_wy5Yxw" rel="noopener ugc nofollow" target="_blank">https://youtu.be/ei-A_wy5Yxw</a></li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="598f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢dionysizndros。这篇文章是<a class="ae kv" href="http://discrete.gr/complexity" rel="noopener ugc nofollow" target="_blank">的总结，一篇非常详细的文章可以在这里访问</a>。我花了五个小时看完整篇文章，但这是非常值得的！</p></div></div>    
</body>
</html>