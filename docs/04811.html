<html>
<head>
<title>Stop Using Post/PostDelayed in Your Android Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止在你的Android视图中使用Post/PostDelayed</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-post-postdelayed-in-your-android-views-9d1c8eeaadf2?source=collection_archive---------0-----------------------#2020-05-12">https://betterprogramming.pub/stop-using-post-postdelayed-in-your-android-views-9d1c8eeaadf2?source=collection_archive---------0-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a356" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">防止可避免的碰撞</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18819c3591033bd603442651abacc30d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BwWQN0ol_F5dP4dj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="dd0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从一开始，Android就提供了一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/reference/android/os/Handler" rel="noopener ugc nofollow" target="_blank">Handler</a></code> API。正如文档所述，它允许您在一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/reference/android/os/Looper" rel="noopener ugc nofollow" target="_blank">Looper</a></code>的线程上从一个队列中传递消息。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5a4e" class="md me it ly b gy mf mg l mh mi">Handler().postDelayed({<br/>   doSomething()<br/>}, delay)</span></pre><p id="7354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个API很方便，但却很狡猾。在视图上使用它时，不要让自己被愚弄。为了理解危险在哪里，我们需要更深入地挖掘<code class="fe lv lw lx ly b">View</code>类。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="43b0" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">视图的处理程序</h1><p id="d6f0" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">Android中的<code class="fe lv lw lx ly b">View</code>利用了<code class="fe lv lw lx ly b">Handler</code> API。它充当内部<code class="fe lv lw lx ly b">Handler</code>的通道，并公开<code class="fe lv lw lx ly b">post()</code>和<code class="fe lv lw lx ly b">postDelayed()</code>两个函数。</p><p id="b34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仔细看看它的实现(在我写这篇文章的时候):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="224e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您注意Javadoc注释。<code class="fe lv lw lx ly b">removeCallbacks</code>行暗示了一些关于移除回调的事情。</p><p id="24ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看它的实际应用:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5a67" class="md me it ly b gy mf mg l mh mi">myView.postDelayed({<br/>    myView.animateSomething()<br/>}, delay)</span></pre><p id="42df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我想在给定的延迟到期时动画显示我的视图。</p><p id="47fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦延迟过期，什么告诉我我的视图仍然存在？用户仍然可以看到它？</p><p id="bf04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看，视图有生命周期。它们可能会在任何时候被销毁，要么是被系统销毁，要么是因为你的用户在你的应用内导航。</p><p id="b350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为您在一个<code class="fe lv lw lx ly b">Looper</code>中对一条消息进行了排队，所以如果您不告诉它这样做，系统就会传递它。您的应用程序可能会因为<code class="fe lv lw lx ly b">NullPointerException</code>而崩溃。</p><p id="6963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在明白这个小评论是多么重要了。我见过太多由于这个API导致的崩溃，因为开发人员未能处理生命周期。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="48d7" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">如果我想延迟对视图的操作，该怎么办？</h1><p id="4f3d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">您仍然可以使用这个API并提取在您的<code class="fe lv lw lx ly b">Handler</code>中声明的<code class="fe lv lw lx ly b">Runnable</code>。正如方法注释中所暗示的，只要回调与代码相关，就需要移除它。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c9be" class="md me it ly b gy mf mg l mh mi">private val animateRunnable = Runnable {<br/>    myView.animateSomething()<br/>}</span><span id="3b66" class="md me it ly b gy np mg l mh mi">myView.postDelayed(animateRunnable, delay)</span><span id="12c3" class="md me it ly b gy np mg l mh mi">// Somewhere in your code<br/>myView.removeCallback(animateRunnable)</span></pre><p id="a0c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我主张禁止这些方法，因为它们被误用或不合适。</p><p id="488c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您正在使用RxJava，您将不再需要它们。创建一个带延迟或定时器的流是微不足道的。您可以轻松处理您的流。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e0d7" class="md me it ly b gy mf mg l mh mi">val disposable = Observable.timer(delay, TimeUnit.MILLISECONDS)<br/>    .subscribe {<br/>        myView.animateSomething()<br/>    }</span><span id="00cf" class="md me it ly b gy np mg l mh mi">// Somewhere in your code<br/>disposable.dispose()</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="146c" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">如果我需要等待下一帧呢？</h1><p id="28a6" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">到目前为止，我只提到了<code class="fe lv lw lx ly b">postDelayed()</code>。对我来说，<code class="fe lv lw lx ly b">post()</code>是我见过的应用于<code class="fe lv lw lx ly b">View</code>的最被误用的API。</p><p id="1e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然没有延迟，为什么还要使用<code class="fe lv lw lx ly b">post()</code>？记得<code class="fe lv lw lx ly b">Handler</code>正在<code class="fe lv lw lx ly b">Looper</code>排队等候消息。过账会将消息排队并传递到下一帧。</p><p id="b1ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我看到开发人员使用这种方法，因为视图没有被布局。假设您想在一个视图出现时就对其进行动画处理。您需要它的位置和/或大小，这取决于您想要实现的动画。</p><p id="8a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您必须等待视图被测量。因此，您将动画委托给下一帧，并祈祷视图将准备就绪。有了这个解决方案，有两点非常突出:</p><ol class=""><li id="9c96" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">你不能保证你的视角会在下一帧被测量。</li><li id="7e9f" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">这段代码看起来很不完整。</li></ol><p id="fa2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe lv lw lx ly b">postDelayed()</code>还有更靠谱的机制。您应该使用<code class="fe lv lw lx ly b">ViewTreeObserver</code>来代替，特别是以下两个回调函数:</p><ul class=""><li id="d65f" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu oe nw nx ny bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/reference/android/view/ViewTreeObserver.OnPreDrawListener" rel="noopener ugc nofollow" target="_blank">OnPreDrawListener</a></code>当视图即将被布局时通知您。此时，视图已被测量</li><li id="528c" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu oe nw nx ny bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.android.com/reference/android/view/ViewTreeObserver.OnGlobalLayoutListener" rel="noopener ugc nofollow" target="_blank">OnGlobalLayoutListener</a></code>每当视图状态改变时触发一个事件</li></ul><p id="41ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些方法时你必须小心。如果在执行操作后忘记删除侦听器，很可能会造成内存泄漏。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="68e3" class="md me it ly b gy mf mg l mh mi">myView.<em class="no">viewTreeObserver</em>.addOnPreDrawListener(object : ViewTreeObserver.OnPreDrawListener {<br/>    override fun onPreDraw(): Boolean {<br/>        myView.animateSomething()<em class="no"><br/>        </em>myView.<em class="no">viewTreeObserver</em>.removeOnPreDrawListener(this)<br/>        return true<br/>    }<br/>})</span><span id="3034" class="md me it ly b gy np mg l mh mi">myView.<em class="no">viewTreeObserver</em>.addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {<br/>    override fun onPreDraw(): Boolean {<br/>        myView.animateSomething()<em class="no"><br/>        </em>myView.<em class="no">viewTreeObserver</em>.removeOnGlobalLayoutListener(this)<br/>    }<br/>})</span></pre><p id="d6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的是，使用<a class="ae ky" href="https://developer.android.com/kotlin/ktx" rel="noopener ugc nofollow" target="_blank"> KTX扩展，</a>并让它们为您处理样板文件。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5459" class="md me it ly b gy mf mg l mh mi">myView.<em class="no">doOnPreDraw </em>{<strong class="ly iu"><br/></strong>    myView.animateSomething()<br/>}</span><span id="3479" class="md me it ly b gy np mg l mh mi">myView.<em class="no">doOnLayout </em>{<strong class="ly iu"><br/></strong>    myView.animateSomething()<br/>}</span></pre><p id="887f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那都是乡亲们！当提倡禁止这种机制时，我可能听起来很刺耳。至少，我鼓励你把他们赶走，并思考他们是否适合这项任务。</p></div></div>    
</body>
</html>