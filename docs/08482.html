<html>
<head>
<title>Is YAML Ready For JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">YAML准备好接受JavaScript了吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-yaml-ready-for-javascript-b501c7a087c6?source=collection_archive---------2-----------------------#2021-05-05">https://betterprogramming.pub/is-yaml-ready-for-javascript-b501c7a087c6?source=collection_archive---------2-----------------------#2021-05-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf2a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较XML、JSON和YAML，了解数据格式化的趋势</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a7fbbc046ca1de54e9c0c828fbf77a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpTN1wIa05ki3F9S1r8RGQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="f11a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">世界上最流行的编程语言是什么？</p><p id="f1eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://www.developer.com/news/is-yaml-taking-over-the-world/" rel="noopener ugc nofollow" target="_blank"> DevOps厂商Datree.io说是YAML </a>。在分析了数百万个开源GitHub项目后，Datree.io发现了6000万个YAML文件。此外，它在10，000多个私人资料库中发现了至少一份YAML的文件。</p><p id="d47a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么是YAML？</p><p id="0795" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/YAML" rel="noopener ugc nofollow" target="_blank"> YAML </a>，是“YAML不是标记语言”的递归首字母缩写，是一种人类可读的数据序列化语言。它通常用于配置文件和存储或传输数据的应用程序中。例如，<a class="ae lu" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"> Swagger </a>已经使用了YAML，这是OpenAPI的一个工具集，是服务器和客户端的标准。YAML经常用在用<code class="fe lv lw lx ly b">C++</code>、Go、Java、JavaScript、Rust和Python编写的项目中。</p><p id="78a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML的故事从XML开始。</p><h1 id="2fb0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">XML(可扩展标记语言)</h1><h2 id="6148" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">定义</h2><p id="982f" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">XML是一种标记语言，它定义了一组规则，用于以人类可读和机器可读的格式对文档进行编码。它使用标签来定义结构，类似于HTML。</p><p id="b09a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XML是SGML(标准通用标记语言)的应用。它的初稿于1996年在太阳微系统公司发表。XML 1.0于1998年2月10日成为W3C的推荐标准。</p><p id="2478" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XML有三个主要功能:</p><ul class=""><li id="291f" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">它是一种标记语言。</li><li id="1091" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">它是在客户端和服务器之间传输的数据格式。</li><li id="4215" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">它用于定义配置。</li></ul><p id="cfa9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XML有过它的全盛时期，但是正在衰落。</p><p id="bd72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一种标记语言，XML可以用XSLT(可扩展样式表语言转换)转换成HTML。然而，现代web应用程序是由JavaScript框架/库编写的，如React、Angular和Vue。XML不再是构建网站的可行选择。</p><p id="bf38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XML是客户机和服务器之间发送数据的默认格式。AJAX已经被用来描述部分刷新网页的<code class="fe lv lw lx ly b">XMLHttpRequest</code>对象。尽管AJAX代表异步JavaScript和XML，但AJAX经常使用JSON在客户机和服务器之间发送数据。</p><p id="8947" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SOAP(简单对象访问协议)是一种流行的消息协议，它使用XML作为其数据格式。REST(表述性状态转移)API已经大部分取代了web服务的SOAP。虽然REST API支持XML，但是它的主要数据格式是JSON。有趣的是，使用YAML来记录和定义REST API越来越受欢迎。</p><p id="fc9e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XML配置文件已经被许多不同的应用服务器使用，比如Apache Tomcat和Jetty。你处理过那些庞大的文件吗？</p><p id="f29b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">较新的服务器，比如<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/whats-new-in-node-js-15-fc24e87e2590"> NodeJS </a>，默认情况下没有XML功能。今天的热门选择是JSON和YAML。</p><h2 id="c89e" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">谷歌趋势</h2><p id="6f6d" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">以下是显示XML受欢迎程度下降的谷歌趋势:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/5aa05e91d81e6d575a8b99c75093fcb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5C5mLas26z1pgEjHwdrkw.png"/></div></div></figure><h2 id="b8b1" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">创建React应用程序中的用法</h2><p id="18c6" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">我们下载一份<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/upgrade-create-react-app-based-projects-to-version-4-cra-4-d7962aee11a6"> Create React App </a>:</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="56f1" class="mr ma it ly b gy ob oc l od oe">npx create-react-app react-app<br/>cd react-app</span></pre><p id="ef28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装的存储库中包含哪些XML文件？</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="2757" class="mr ma it ly b gy ob oc l od oe">$ find . -name "*.xml"<br/>./node_modules/json-schema/draft-zyp-json-schema-03.xml<br/>./node_modules/json-schema/draft-zyp-json-schema-04.xml</span></pre><p id="e1a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个应用程序中有两个XML文件。</p><h2 id="f472" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">XML格式的Package.json</h2><p id="449d" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">如果我们使用XML格式重写<code class="fe lv lw lx ly b">package.json</code>,它将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="f698" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">用JavaScript解析XML</h2><p id="9d1d" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">将以下XML文件添加到<code class="fe lv lw lx ly b">/public</code>文件夹中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="236a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该文件可以从网络浏览器访问(在<code class="fe lv lw lx ly b">npm start</code>之后)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a4a86b724b88529c7eea829f9d0e4e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*8Ank2B1Qi1CcxBTonv54Fg.png"/></div></figure><p id="86ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用下面的代码替换<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="af1f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">public/config.xml</code>在第10行获取，并在第11行转换为文本。</p><p id="45df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第13行使用<code class="fe lv lw lx ly b">DOMParser</code>将XML文本解析成DOM文档。</p><p id="0da5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从DOM文档中检索出<code class="fe lv lw lx ly b">location</code>值，并保存到state中(第16行)。</p><p id="eca0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从DOM文档中检索出<code class="fe lv lw lx ly b">year</code>值，并保存到state中(第17行)。</p><p id="8d50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第25行表明这是<code class="fe lv lw lx ly b">config.xml</code>的代码片段。</p><p id="d426" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第26行和第27行显示了<code class="fe lv lw lx ly b">location</code>和<code class="fe lv lw lx ly b">year</code>值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/b4da598da5058586a781dbeb457a4171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*QWwHK5GMY-jiSluBUk2mIA.png"/></div></figure><h2 id="b566" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">警告</h2><p id="0cb1" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">您可能想知道为什么我们在示例中使用XML 1.0，而不是2004年2月4日推出的XML 1.1。</p><p id="7f20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">XML 1.1从未被广泛采用，因为W3C在XML 1.0的第五版中引入了相同的变化。到目前为止，XML 1.0仍然是最广泛采用和实现的版本。</p><p id="ee67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的建议来自Elliotte Rusty Harold的书《有效的XML:改进XML的50种具体方法》:</p><blockquote class="oi oj ok"><p id="f352" class="ky kz ol la b lb lc ju ld le lf jx lg om li lj lk on lm ln lo oo lq lr ls lt im bi translated">“关于XML 1.1，您需要了解的一切可以归结为两条规则:</p><p id="2f2f" class="ky kz ol la b lb lc ju ld le lf jx lg om li lj lk on lm ln lo oo lq lr ls lt im bi translated">1.不要用。</p><p id="7ac4" class="ky kz ol la b lb lc ju ld le lf jx lg om li lj lk on lm ln lo oo lq lr ls lt im bi translated">2.(仅供专家使用)如果您会说蒙古语、彝语、柬埔寨语、阿姆哈拉语、迪维希语、缅甸语或极少数其他语言，并且您想用这些语言编写标记(不是您的文本而是您的标记)，那么您可以将XML声明的version属性设置为1.1。否则，请参考规则1。"</p></blockquote><h1 id="b031" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">JSON (JavaScript对象符号)</h1><h2 id="c729" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">定义</h2><p id="1bc8" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">JSON是一种数据交换格式，它使用人类可读的文本来存储和传输数据对象。它由名称/值对和数组数据类型组成。记录用逗号分隔，名称和值都用双引号括起来。</p><p id="1e9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JSON是由道格拉斯·克洛克福特在2001年3月首先规定的。它基于JavaScript编程语言标准ECMA-262第三版(1999年12月)的子集。它于2013年10月成为ECMA国际标准。</p><p id="b7f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JSON有两个主要功能:</p><ul class=""><li id="601c" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">它是在客户端和服务器之间传输的数据格式。</li><li id="bfd7" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">它用于定义配置。</li></ul><p id="4f4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JSON是用于交换数据的轻量级格式。它广泛用于各种AJAX框架和工具包中，为远程调用提供简单的对象序列化。JSON是独立于语言的，序列化/反序列化JavaScript对象只需很少的编码，甚至不需要编码。</p><p id="1ce9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JSON语法简单，对数据类型的支持有限，包括<code class="fe lv lw lx ly b">object</code>、<code class="fe lv lw lx ly b">array</code>、<code class="fe lv lw lx ly b">number</code>、<code class="fe lv lw lx ly b">string</code>、<code class="fe lv lw lx ly b">boolean</code>和<code class="fe lv lw lx ly b">null</code>。JSON没有名称空间、注释或属性支持。它可能不支持复杂的配置。这些限制也使它变得简单，因此它可以快速传输和解析。</p><p id="9079" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JSON文件不一定要命名为<code class="fe lv lw lx ly b">.json</code>。事实上，它可能被命名为<code class="fe lv lw lx ly b">.js</code>，因为JSON对象是一个有效的JavaScript文件。众所周知的例子就是<code class="fe lv lw lx ly b">webpack.config.js</code>。</p><h2 id="bff1" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">谷歌趋势</h2><p id="140b" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">以下是显示XML和JSON之间比较的Google趋势:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl op"><img src="../Images/f1e636f43937de1e54031ddd910393dc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*BPmeJX5iZ7-jS0VdGQMS0A.png"/></div></figure><h2 id="f303" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">创建React应用程序中的用法</h2><p id="2857" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">Create React App包含多少个JSON文件？</p><pre class="kj kk kl km gt nx ly ny nz aw oa bi"><span id="83db" class="mr ma it ly b gy ob oc l od oe">$ find . -name "*.json" | wc -l<br/>    2374</span></pre><p id="ad2d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">整个应用程序中有2374个JSON文件，不包括那些命名为<code class="fe lv lw lx ly b">.js</code>的JSON文件。</p><h2 id="39b6" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">json格式的Package.json</h2><p id="7042" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">以下是Create React App中的<code class="fe lv lw lx ly b">package.json</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="f219" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">用JavaScript解析JSON</h2><p id="5901" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">将以下JSON文件添加到<code class="fe lv lw lx ly b">/public</code>文件夹中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="81e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该文件可通过网络浏览器访问(在<code class="fe lv lw lx ly b">npm start</code>之后)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/970e36ecb89c8ec60abc24dbe285d633.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*PsSX3k1JXunOLR6yB_674A.png"/></div></figure><p id="1184" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用以下代码替换<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2c1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">public/config.json</code>在第10行获取，并在第11行转换成JSON对象。</p><p id="9066" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从JSON对象中检索出<code class="fe lv lw lx ly b">location</code>值，并保存到state中(第13行)。</p><p id="1642" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从JSON对象中检索出<code class="fe lv lw lx ly b">year</code>值，并保存到state中(第14行)。</p><p id="3c09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第22行表明这是<code class="fe lv lw lx ly b">config.json</code>的代码片段。</p><p id="6241" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第23行和第24行显示了<code class="fe lv lw lx ly b">location</code>和<code class="fe lv lw lx ly b">year</code>值。</p><p id="a118" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">获取和处理JSON不是比处理XML更容易吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/16aa5d8110f1a6395ad1abb0f612eb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1394/format:webp/1*830aRV3J4NDaPrHDDnSCVA.png"/></div></figure></div><div class="ab cl or os hx ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="im in io ip iq"><h1 id="67c8" class="lz ma it bd mb mc oy me mf mg oz mi mj jz pa ka ml kc pb kd mn kf pc kg mp mq bi translated">YAML (YAML不是标记语言)</h1><h2 id="d124" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">定义</h2><p id="5500" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">YAML最初被认为是另一种标记语言。然而，随着YAML将注意力从文件转移到数据，官方的定义已经改变。今天，它清楚地表明YAML不是标记语言。</p><p id="12d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看官方<a class="ae lu" href="https://yaml.org/" rel="noopener ugc nofollow" target="_blank"> YAML站点</a>，100%写于YAML 1.2。你可以看到它是多么的人性化。以下是该网站的前几行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5f54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML创建于2001年5月15日。它没有正式的W3C规范。YAML 1.2于2009年7月21日发布。</p><p id="2fa2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管它看起来与JSON不同，但YAML是JSON的超集(也就是说，一个有效的YAML文件可以包含JSON)。此外，JSON可以转换成YAML。</p><p id="40f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">《YAML》极具可读性。让我们看一些例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9753" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML文件可以选择以文档分隔符(<code class="fe lv lw lx ly b">---</code>，第1行)开始，也可以选择以文档附件(<code class="fe lv lw lx ly b">...</code>，第5行)结束。</p><p id="b7ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注释以数字符号(<code class="fe lv lw lx ly b">#</code>，第1行)开始，可以从一行的任何地方开始，一直延续到该行的末尾。</p><p id="8b2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">列表的成员是从相同缩进级别开始的行，以一个<code class="fe lv lw lx ly b">- </code>开始(一个破折号和一个空格，第2-4行)。</p><p id="94b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的列表相当于下面类似JSON的格式(缩写形式，第2行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="942d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一个字典用一个简单的<code class="fe lv lw lx ly b">key: value</code>形式表示(冒号后面必须跟一个空格)，数据结构层次由轮廓缩进来维护。这里有一个YAML的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="d0c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的字典相当于下面类似JSON的格式(缩写形式，第2–6行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="be55" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML提供了引用其他数据对象的能力。通过使用<code class="fe lv lw lx ly b">$ref</code>引用一个定义，可以在YAML文件中编写递归。</p><p id="078e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是<code class="fe lv lw lx ly b">TreeNode</code>的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="b048" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第4–10行定义了一个<code class="fe lv lw lx ly b">TreeNode</code>的属性。</p><p id="2f76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第10行使用<code class="fe lv lw lx ly b">$ref</code>写递归，其中<code class="fe lv lw lx ly b">#</code>到达当前文档的根，然后沿着路径<code class="fe lv lw lx ly b">/definition/TreeNode</code>到达元素<code class="fe lv lw lx ly b">TreeNode</code>。</p><p id="463d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第11–20行显示了一个定义树的例子。</p><p id="2a00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于所有的YAML语法，你可以查看84页的手册。</p><p id="3f65" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML有三个主要功能:</p><ul class=""><li id="eba4" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">它是在客户端和服务器之间传输的数据格式。</li><li id="3a2e" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">它用于定义配置。</li><li id="c6d6" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">它用于离线数据处理。</li></ul><p id="ede0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然在客户机和服务器之间传输数据比XML简单，但是YAML——这种非常容易理解的语法——性能并不好。使用空白可以使YAML文件比JSON文件大，JSON文件仍然是快速传输和解析数据的首选。</p><p id="1605" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML克服了JSON的限制(例如，名称空间、注释、属性和复杂的配置)。它正在接管配置文件的JSON。此外，YAML用于离线数据处理，它利用YAML的配置功能，不太关心性能。</p><p id="3feb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML有其自身的局限性。它的缩进格式容易出现语法和验证错误。由于缺乏跨所有语言的特性，某些类型的可移植性可能不存在。由于YAML的声明性，调试很困难。不存在断点和类似的功能。</p><h2 id="1028" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">谷歌趋势</h2><p id="98c8" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">以下是谷歌趋势，展示了XML、JSON和YAML之间的比较:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/5a88e5446b9ebf1766abd7b45b21f8db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OEIhnRNEdPjO0vlbJ_9SFw.png"/></div></div></figure><h2 id="fc14" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">创建React应用程序中的用法</h2><p id="7eb0" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">Create React App中包含多少YAML文件？</p><p id="9a4b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">没有。</p><h2 id="bca6" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">YAML格式的Package.json</h2><p id="e3f3" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">如果我们用YAML格式重写<code class="fe lv lw lx ly b">package.json</code>,它看起来会像下面这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><h2 id="1631" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">用JavaScript解析YAML</h2><p id="639a" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">将以下YAML文件添加到<code class="fe lv lw lx ly b">/public</code>文件夹中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9b92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该文件可以从网络浏览器访问(在<code class="fe lv lw lx ly b">npm start</code>之后)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/7d10a1191400715788adf4af8846e048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*abCa8PXHGhReFoVE4agsjw.png"/></div></figure><p id="2dc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要用JavaScript解析YAML，<a class="ae lu" href="https://github.com/nodeca/js-yaml" rel="noopener ugc nofollow" target="_blank"> js-yaml </a>是首选之一。需要安装的软件包:<code class="fe lv lw lx ly b">npm i js-yaml</code>。</p><p id="047d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们用下面的代码替换<code class="fe lv lw lx ly b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7015" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">public/config.yaml</code>在第11行获取，并在第12行转换为文本。</p><p id="9f26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第13行使用来自<code class="fe lv lw lx ly b">js-yaml</code>的<code class="fe lv lw lx ly b">load</code>将文本解析成一个YAML文档。<code class="fe lv lw lx ly b">load</code>函数返回普通对象、字符串、数字、<code class="fe lv lw lx ly b">null</code>或<code class="fe lv lw lx ly b">undefined</code>，或者在出错时抛出<code class="fe lv lw lx ly b">YAMLException</code>。</p><p id="484e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从对象中获取<code class="fe lv lw lx ly b">location</code>值并保存到状态(第15行)。</p><p id="d832" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从对象中检索出<code class="fe lv lw lx ly b">year</code>值并保存到状态(第16行)。</p><p id="c7c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第24行表明这是<code class="fe lv lw lx ly b">config.json</code>的代码片段。</p><p id="ed2e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第25行和第26行显示<code class="fe lv lw lx ly b">location</code>和<code class="fe lv lw lx ly b">year</code>值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/b5da9f4c669ce9dd453ac92c3731a16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*ceBzGgwVcs6KR142VEeMWA.png"/></div></figure><p id="0e66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe lv lw lx ly b">public/config.yaml</code>是多文档YAML文件怎么办？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7d34" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将收到一个异常:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/c75acd0d23fe8785fa17d36e1c9a9e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bsg2jMatUKrUt5EuXVwh_w.png"/></div></div></figure><p id="726c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的代码中，应该使用<code class="fe lv lw lx ly b">loadAll</code>而不是<code class="fe lv lw lx ly b">load</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ca63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">loadAll</code>(第4行)类似于<code class="fe lv lw lx ly b">load</code>，但是理解多文档源。</p><p id="e45b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第6行输出<code class="fe lv lw lx ly b">data</code>对象<code class="fe lv lw lx ly b">[["Apple", "Orange", "Pear"], ["Red", "White", "Blue"]</code>。</p><p id="cb35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了输出<code class="fe lv lw lx ly b">data</code>对象，我们还可以使用<code class="fe lv lw lx ly b">dump</code>将<code class="fe lv lw lx ly b">data</code>对象序列化为YAML文档。下面的一些代码显示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="fd09" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第6行以YAML格式转储数据对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c3b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lv lw lx ly b">load</code>、<code class="fe lv lw lx ly b">loadAll</code>和<code class="fe lv lw lx ly b">dump</code>是YAML解析器中的常用函数。</p><h2 id="55e1" class="mr ma it bd mb ms mt dn mf mu mv dp mj lh mw mx ml ll my mz mn lp na nb mp nc bi translated">警告</h2><p id="e2a8" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated"><code class="fe lv lw lx ly b">.yml and</code> <code class="fe lv lw lx ly b">.yaml</code>你可能都看了。YAML文件的文件扩展名应该是什么？</p><p id="c864" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://yaml.org/faq.html" rel="noopener ugc nofollow" target="_blank">官方推荐</a>为<code class="fe lv lw lx ly b">.yaml</code>。</p><blockquote class="oi oj ok"><p id="5087" class="ky kz ol la b lb lc ju ld le lf jx lg om li lj lk on lm ln lo oo lq lr ls lt im bi translated">“请使用’。可能的话，就叫“yaml”</p></blockquote><p id="1773" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Windows及其8.3规则强化了三字符扩展名的趋势。8.3规则是一种文件格式，支持最大八个字符的文件名和最多三个字符的扩展名，尽管今天所有版本的Windows和其他现代操作系统都支持长文件名。</p><p id="88f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">两个<code class="fe lv lw lx ly b">.yml and</code> <code class="fe lv lw lx ly b">.yaml</code>都可以，事实上，任何文件扩展名都适用于YAML文件。官方的说法应该是<code class="fe lv lw lx ly b">.yaml</code>。</p><h1 id="1c15" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="f80b" class="pw-post-body-paragraph ky kz it la b lb nd ju ld le ne jx lg lh nf lj lk ll ng ln lo lp nh lr ls lt im bi translated">我们比较了XML、JSON和YAML。</p><ul class=""><li id="f386" class="ni nj it la b lb lc le lf lh nk ll nl lp nm lt nn no np nq bi translated">XML作为一种标记语言和数据格式已经衰落了。</li><li id="de84" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">JSON是客户机和服务器之间传输的数据格式的赢家。</li><li id="f26b" class="ni nj it la b lb nr le ns lh nt ll nu lp nv lt nn no np nq bi translated">YAML接管了配置文件的JSON，并被用于离线数据处理。</li></ul><p id="8ce0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">YAML准备好接受JavaScript了吗？</p><p id="9fc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有点吧。如果浏览器决定开始支持YAML，这一天可能会到来。</p><p id="1c72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。我希望这有所帮助。你可以在这里看到我的其他媒体出版物<a class="ae lu" href="https://medium.com/@jenniferfubook/jennifer-fus-web-development-publications-1a887e4454af" rel="noopener"/>。</p></div></div>    
</body>
</html>