<html>
<head>
<title>Factory: Circular Dependency Chains</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂:循环依赖链</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/factory-circular-dependency-chains-ece39a7d2bc8?source=collection_archive---------6-----------------------#2022-12-23">https://betterprogramming.pub/factory-circular-dependency-chains-ece39a7d2bc8?source=collection_archive---------6-----------------------#2022-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1632" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何找到并消除它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3205b42dfe6cf3a48f85488ca7eaf4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqxGzj6w6bcUPOST8ndTww.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@adliwahid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">阿德利·瓦希德</a>在<a class="ae ky" href="https://unsplash.com/photos/V395x8YyfJE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="4677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae ky" href="https://github.com/hmlongco/Factory" rel="noopener ugc nofollow" target="_blank"> Factory </a>这样的依赖注入系统可以让你的代码更容易编写和测试。但是偶尔会出现问题，我们在DI系统中看到的一个更常见的问题与循环依赖有关。</p><h1 id="a4f3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是循环依赖？</h1><p id="8428" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设A需要B来构造，B需要一个C，但是如果C需要A会怎么样呢？检查下列类定义。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="3621" class="mx lw it mt b be my mz l na nb">class CircularA {<br/>    @Injected(Container.circularB) var circularB<br/>}<br/><br/>class CircularB {<br/>    @Injected(Container.circularC) var circularC<br/>}<br/><br/>class CircularC {<br/>    @Injected(Container.circularA) var circularA<br/>}</span></pre><p id="11dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试图构造<code class="fe nc nd ne mt b">CircularA</code>的实例将导致无限循环。</p><p id="43b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？A的注入属性包装需要一个B来构造A，好吧。我们做一个吧。但是B的包装器需要一个C，不注入A就无法完成，而A又需要一个B…等等。无限地。</p><p id="cde8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个循环依赖链。</p><p id="5bf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，当这段代码编译并运行时，要打破这个循环已经太晚了。我们已经在程序中有效地编写了一个无限循环。</p><p id="1505" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就引出了两个问题:</p><ol class=""><li id="05b2" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">我们如何找出问题所在？</li><li id="e791" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">我们如何解决它？</li></ol><h1 id="1552" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们如何找出问题所在？</h1><p id="4ccf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">先从发现问题开始。虽然检查上面的代码并找出错误很容易，但是在拥有数百甚至数千个依赖关系的大型系统中，找到有问题的依赖关系链可能会很困难。</p><p id="9de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，当这些代码被编译并运行时，做任何事情都为时已晚。Swift要求我们提供一个对象的实例，我们<em class="nt">可以</em>创建该对象的所有依赖项……但是该对象的属性初始化器要求我们首先提供另一个对象的实例，这将我们带到链的下游。华盛顿州冲洗。重复一遍。</p><p id="8fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，应用程序所能做的就是退出。</p><p id="b517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有了Factory，我们可以优雅地死去，并在这个过程中抛弃显示问题所在的依赖链。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="78a0" class="mx lw it mt b be my mz l nu nb">2022-12-23 14:57:23.512032-0600 FactoryDemo[47546:6946786] Factory/Factory.swift:393: <br/>Fatal error: circular dependency chain - CircularA &gt; CircularB &gt; CircularC &gt; CircularA</span></pre><p id="93cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调试模式下运行时，工厂现在会跟踪依赖关系链，并在检测到循环依赖关系链时发出致命错误。我们不需要通过检查调用堆栈来找出问题所在。工厂会告诉我们。</p><p id="cf59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nc nd ne mt b">CircularA &gt; CircularB &gt; CircularC &gt; CircularA</code></p><p id="b77d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们试图制造一个A，这是制造一个B，这是制造一个C…这是循环，并试图再次制造一个A。</p><p id="ce0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了上面的信息，我们应该能够找到问题并解决它。</p><h1 id="27f5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">修复问题</h1><p id="19bf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以让工厂自己解决问题。考虑对<code class="fe nc nd ne mt b">CircularC</code>的以下更改和对<code class="fe nc nd ne mt b">circularA</code>的新工厂定义。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="68a5" class="mx lw it mt b be my mz l na nb">class CircularC {<br/>    weak var circularA: CircularA?<br/>}<br/><br/>extension Container {<br/>    static var circularA = Factory&lt;CircularA&gt; {<br/>        let a = CircularA()<br/>        a.circularB.circularC.circularA = a<br/>        return a<br/>    }<br/>}</span></pre><p id="350b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种机制通常用于修复严格的父子关系，也可以用在这里……但是很臭。如果有人试图自己制造一个<code class="fe nc nd ne mt b">CircularB</code>会发生什么？</p><p id="070c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看我们是否能做得更好。</p><h2 id="cf99" class="nv lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">惰性装载</h2><p id="2023" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个问题的经典解决方案是延迟加载。</p><p id="1025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需将CircularC的注入包装改为<code class="fe nc nd ne mt b">LazyInjected</code>，或者更好的是<code class="fe nc nd ne mt b">WeakLazyInjected</code>，以避免保留周期。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="61de" class="mx lw it mt b be my mz l na nb">class CircularC {<br/>    @WeakLazyInjected(Container.optionalA) var circularA<br/>}</span></pre><p id="1f94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe nc nd ne mt b">CircularA</code>的这个实例直到被请求时才会被提供，所以在对象被构造之后<em class="nt">，循环依赖链已经被打破。</em></p><p id="b7ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果我们真的想让C引用原来的A，我们可能要把原来的工厂范围<code class="fe nc nd ne mt b">circularA</code>改为<code class="fe nc nd ne mt b"> .shared</code>，并把<code class="fe nc nd ne mt b">optionalA</code>指向那个工厂。</p><p id="1b76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，这仍然不是最佳的。</p><h2 id="2d39" class="nv lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">重构</h2><p id="776e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">从架构的角度来看，如果A依赖于B，那么我们通常希望A能够看到B，但是B应该不知道A的存在。</p><p id="21dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可见性沿着链条向下流动。</p><p id="0e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，更好的解决方案可能需要找到<code class="fe nc nd ne mt b">CircularA</code>和<code class="fe nc nd ne mt b">CircularC</code>所依赖的功能，并将其分解到它们都可以包含的第三个<em class="nt">对象中。</em></p><p id="4cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像这样的循环依赖通常违反了单一责任原则，应该首先避免。</p><h1 id="5fd7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">引擎盖下。</h1><p id="70e0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">所以工厂做循环依赖链检测，但是它是怎么做的呢？</p><p id="51ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工厂内部，有一个单一的函数可以解决特定的依赖关系。它检查工厂是否被新的注册覆盖了，它还检查对象是否被缓存在不同的作用域中。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="47ce" class="mx lw it mt b be my mz l na nb">func resolve(_ params: P) -&gt; T {<br/>    let _ = Container.autoRegistrationCheck<br/>    let currentFactory: (P) -&gt; T = (SharedContainer.Registrations.factory(for: id) as? TypedFactory&lt;P, T&gt;)?.factory ?? factory<br/>    let instance: T = scope?.resolve(id: id, factory: { currentFactory(params) }) ?? currentFactory(params)<br/>    SharedContainer.Decorator.decorate?(instance)<br/>    return instance<br/>}</span></pre><p id="5b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的东西都流经这个地方。</p><p id="8a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提供循环依赖检测，代码已经扩展，现在看起来像这样。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="8b50" class="mx lw it mt b be my mz l na nb">func resolve(_ params: P) -&gt; T {<br/>    let _ = Container.autoRegistrationCheck<br/>    <br/>    let currentFactory: (P) -&gt; T = (SharedContainer.Registrations.factory(for: id) as? TypedFactory&lt;P, T&gt;)?.factory ?? factory<br/><br/>    #if DEBUG<br/>    defer { dependencyChain.removeLast(); dependencyLock.unlock() }<br/>    dependencyLock.lock()<br/>    let typeComponents = String(describing: T.self).components(separatedBy: CharacterSet(charactersIn: "&lt;&gt;"))<br/>    let typeName = typeComponents.count &gt; 1 ? typeComponents[1] : typeComponents[0]<br/>    let typeIndex = dependencyChain.firstIndex(where: { $0 == typeName })<br/>    dependencyChain.append(typeName)<br/>    if let index = typeIndex {<br/>        fatalError("circular dependency chain - \(dependencyChain[index...].joined(separator: " &gt; "))")<br/>    }<br/>    #endif<br/><br/>    let instance: T = scope?.resolve(id: id, factory: { currentFactory(params) }) ?? currentFactory(params)<br/><br/>    SharedContainer.Decorator.decorate?(instance)<br/><br/>    return instance<br/>}</span></pre><p id="a1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的原始代码都在那里，但是现在有一个<code class="fe nc nd ne mt b">DEBUG</code>部分，它通过将当前类名推送到堆栈(数组)上，创建所需的实例，然后将该名称移除到堆栈上来跟踪当前类名。</p><p id="7555" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数是可重入的，所以如果在创建A的实例时，它试图创建B，它将再次调用这个函数。同样的情况，当B试图做一个C，当C再次试图做一个a。</p><p id="10c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是每次我们想创建一个类型的新实例时，我们都要检查该类型是否已经在堆栈中。</p><p id="6563" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是，那么我们有一个循环依赖链，我们需要中止，在这个过程中转储链。</p><p id="bfac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一点很重要，工厂类型可能是可选的，所以需要一点额外的代码来从看起来像" Optional &lt; CircularA &gt;"的类型字符串中提取基本类型名。</p><p id="6526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Factory是线程安全的，我们在检测代码周围做了一些额外的锁定，以防止数组损坏。</p><h1 id="d0e3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">完成块</h1><p id="7e7a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于社区的支持，Factory仍在发展、成长和变得更好。我感谢你的帮助，评论，是的，甚至是错误报告。</p><p id="e526" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么要说的吗？一如既往，请在下面留下评论或类似内容。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="8c24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nt">本文是</em> <a class="ae ky" href="https://medium.com/p/365ce5038ef7/edit" rel="noopener"> <em class="nt">雨燕依赖注入系列</em> </a> <em class="nt">的一部分。</em></p></div></div>    
</body>
</html>