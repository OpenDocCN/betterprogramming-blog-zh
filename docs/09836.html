<html>
<head>
<title>5 Different Ways to Pass Data in iOS Codebases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS代码库中传递数据的5种不同方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-different-ways-to-pass-data-in-ios-codebases-a784f72a8f50?source=collection_archive---------7-----------------------#2021-10-19">https://betterprogramming.pub/5-different-ways-to-pass-data-in-ios-codebases-a784f72a8f50?source=collection_archive---------7-----------------------#2021-10-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa8c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">依赖注入、委托方法等等</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/13ee9f1fd472bbc7cfe03b86e93cd814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dor1OT-lor3UM5-k"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安迪·霍姆斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3e49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">视图控制器和视图之间的数据传递是iOS开发的一个重要方面。事实上，不正确的实现可能会导致应用程序失败，并产生不正确的最终结果。</p><h1 id="6399" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">入门指南</h1><p id="f847" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本文中，我们将学习如何实现在视图控制器之间传递数据的五种方法。</p><ol class=""><li id="7b6f" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">使用<code class="fe my mz na nb b">internal</code>或<code class="fe my mz na nb b">public</code>修改器</li><li id="adac" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">实现委托方法</li><li id="7a6e" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">依赖注入</li><li id="3829" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated"><code class="fe my mz na nb b">NotificationCenter</code></li><li id="ffe8" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">全局变量</li></ol></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="2ce1" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">1.使用内部(默认)或公共修饰符</h1><p id="70b0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在推送或呈现视图控制器时，通常会设置目标视图控制器的属性值。</p><p id="6761" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要用<code class="fe my mz na nb b">internal</code>级别设置视图控制器内部属性的访问修饰符，默认情况下，如果我们没有用<code class="fe my mz na nb b">private</code>或<code class="fe my mz na nb b">fileprivate</code>修饰符预先声明任何属性。</p><p id="8fa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">internal</code> access允许在同一模块或目标中使用属性或功能，这意味着它对同一应用程序、框架、扩展或Swift包中的其他源代码始终可见。</p><p id="9296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">public</code>访问类似于内部访问，但是它允许在模块内部和外部使用实体。您可以在Swift <a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html" rel="noopener ugc nofollow" target="_blank">文档</a>中了解更多关于访问级别的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/ecee62d6ca766dddf59ad817d13876cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1dO82PcYL-3AMuJ3qAvUQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将任务对象从<code class="fe my mz na nb b">ListViewController</code>传递到<code class="fe my mz na nb b">DetailViewController</code></p></figure><p id="43a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了。现在，让我们以如上图所示的两个控制器为例，其中左视图控制器想要将一个<code class="fe my mz na nb b">Task</code>对象传递给右视图控制器。</p><p id="72f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，将目标视图控制器的<code class="fe my mz na nb b">Task</code>对象(在本例中为<code class="fe my mz na nb b">DetailViewController</code>)设为<code class="fe my mz na nb b">internal</code>，以确保其值可以从左侧视图控制器中设置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a329" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe my mz na nb b">showDetail</code>函数中，初始化目的视图控制器后，我们可以用函数参数中的当前任务设置<code class="fe my mz na nb b">detailVC</code>的<code class="fe my mz na nb b">task</code>属性。此方法仅适用于向前方向—推动和呈现视图控制器。</p><p id="d170" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是它在Xcode中的样子。自动完成选项中只有<code class="fe my mz na nb b">task</code>和<code class="fe my mz na nb b">taskId</code>可见。私有属性不会出现在下拉选项中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/c35d9dfd2b064cb6d80ca78051572af6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QjB1WLq5i0bSxzR3KD3xg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有public和private修饰符的自动完成示例</p></figure><p id="83d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果您正在使用Storyboard，那么最好使用segue在视图控制器之间传递数据。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="876b" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">2.实现委托方法</h1><p id="6ba0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">反向传递数据的一个正确方法是使用委托方法。在本例中，我们将把更新后的<code class="fe my mz na nb b">task</code>数据从<code class="fe my mz na nb b">DetailViewController</code>传递到<code class="fe my mz na nb b">ListViewController</code>。</p><h2 id="0b73" class="nx lt iq bd lu ny nz dn ly oa ob dp mc lf oc od me lj oe of mg ln og oh mi oi bi translated">设置委托方法</h2><p id="38ac" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">委托方法是基于Swift协议创建的，该协议指定了需要由采用类实现的必需方法。</p><p id="88e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们通过创建一个名为<code class="fe my mz na nb b">DetailViewControllerDelegate</code>的新协议来设置委托方法。</p><p id="e63c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它包含<code class="fe my mz na nb b">didUpdate(task:)</code>函数，该函数使采用类能够接收事件更新。</p><p id="d87f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，<code class="fe my mz na nb b">ListViewController</code>将接收到由<code class="fe my mz na nb b">DetailViewController</code>发出的更新后的<code class="fe my mz na nb b">task</code>对象。请参见下图中的流程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/514e36f9491cb3d90bdae63d7e51761d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJabjyECahS-pxqLnR_Prw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用委托方法发回数据</p></figure><p id="b4ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开，<code class="fe my mz na nb b">DetailViewController</code>并用下面的代码更新。委托方法可以放在同一个文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="dc84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面更新的代码中，我们知道每当调用<code class="fe my mz na nb b">updateTask</code>时，它都会发出委托，通过<code class="fe my mz na nb b">didUpdate</code>委托函数发送<code class="fe my mz na nb b">task</code>对象。</p><p id="196a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，实现视图控制器(在本例中是ListViewController)将接收发送的数据。</p><h2 id="7a30" class="nx lt iq bd lu ny nz dn ly oa ob dp mc lf oc od me lj oe of mg ln og oh mi oi bi translated">更新接收器视图控制器</h2><p id="1687" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在<code class="fe my mz na nb b">ListViewController</code>中，我们需要实现所需的委托方法，并将委托分配给自身。</p><p id="a165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，打开<code class="fe my mz na nb b">ListViewController</code>并更新<code class="fe my mz na nb b">showDetail()</code>功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9681" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在文件的底部，添加一个带有<code class="fe my mz na nb b">DetailViewControllerDelegate</code>协议的扩展名，如下面的代码所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="bedd" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">3.依赖注入</h1><p id="392c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这种模式下，在创建一个类的实例之前，需要一个或多个依赖对象。在本例中，我们将创建一个视图控制器，只有将数据传递到它的<code class="fe my mz na nb b">init()</code>函数中才能创建它。事实上，如果在初始化过程中数据丢失，它会给出一个错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/60a7581959c56f7b6a36e693fae4ff79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fNztfs8kQwr52UrspbWpPg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建DetailViewController实例时需要数据</p></figure><p id="d30f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是创建具有依赖关系的视图控制器的代码示例。在这段代码中，我们已经将task属性更新为private，因此它将无法从类外部进行设置。</p><p id="e98a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，我们添加了<code class="fe my mz na nb b">init(task:)</code>来确保<code class="fe my mz na nb b">task</code>对象在初始化时被传递。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="8771" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe my mz na nb b">ListViewController</code>中，我们将对<code class="fe my mz na nb b">showDetail()</code>进行一点更新，如下面的代码所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cb6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，对于依赖注入的高级用法，我们可以集成到项目中的优秀库很少，例如<a class="ae kv" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank"> SwiftInject </a>和<a class="ae kv" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank"> Resolver </a>。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="73ca" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">4.通知中心</h1><p id="5152" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe my mz na nb b"><a class="ae kv" href="https://developer.apple.com/documentation/foundation/notificationcenter" rel="noopener ugc nofollow" target="_blank">NotificationCenter</a></code>是Apple提供的一个很棒的API，可以向多个视图控制器发送数据。它由两个组件组成，观察者和发送者。</p><p id="bf28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个视图控制器向自身添加一个观察者时，它将从发送者那里收到一个带有可选有效负载的通知。视图控制器想要订阅更新的键必须在<code class="fe my mz na nb b">Observer</code>中指定。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="acfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面给出了上面编写的代码的细节:</p><ol class=""><li id="f7b4" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">首先，我们定义了密钥，以便正确使用它</li><li id="a3d1" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">创建一个函数，为这个视图控制器添加一个观察者，并在<code class="fe my mz na nb b">viewDidLoad</code>中调用它</li><li id="d067" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">创建一个当观察者收到通知时将被调用的函数</li><li id="226e" class="mp mq iq ky b kz nc lc nd lf ne lj nf ln ng lr mu mv mw mx bi translated">处理收到的通知的有效负载</li></ol><p id="5ca3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以从其他视图控制器发送一个<code class="fe my mz na nb b">Dictionary</code>类型的数据。所以，所有的观察者都会立即收到数据。</p><p id="bd8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，我们创建了一个<code class="fe my mz na nb b">broadcastInfo()</code>函数来通知所有观察者这个概要文件已经用指定的有效载荷更新了，这个有效载荷包括一个标题、副标题和图像:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="a040" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">5.全局变量</h1><p id="d19b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了创建一个全局变量，我们只需要一个具有静态<code class="fe my mz na nb b">var</code>属性的结构，如下面的代码所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="754e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不太推荐这种方法，因为任何更改都很难跟踪，而且这可能是错误发生的主要原因。但是，您可以通过使用类似redux的库<a class="ae kv" href="https://github.com/ReSwift/ReSwift" rel="noopener ugc nofollow" target="_blank"> ReSwift </a>来适当地实现它，这是一个具有单向数据的状态管理工具。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="3a55" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">结论</h1><p id="f36c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">太好了！现在，我们已经完成了关于如何在iOS项目中传递数据的所有基本的五个方法。希望对你的iOS开发有所帮助。</p><p id="c247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。编码快乐！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="9a76" class="ls lt iq bd lu lv no lx ly lz np mb mc jw nq jx me jz nr ka mg kc ns kd mi mj bi translated">参考</h1><p id="f9cf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/Protocols.html" rel="noopener ugc nofollow" target="_blank"> Swift协议文件</a></p><p id="86d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html" rel="noopener ugc nofollow" target="_blank">使用Segues查看控制器指南</a></p><p id="e512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html" rel="noopener ugc nofollow" target="_blank"> Swift访问控制文件</a></p><p id="917a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/foundation/notificationcenter" rel="noopener ugc nofollow" target="_blank">通知中心文档</a></p><p id="fb07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/ReSwift/ReSwift" rel="noopener ugc nofollow" target="_blank">https://github.com/ReSwift/ReSwift</a></p><p id="55f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank">https://github.com/hmlongco/Resolver</a></p><p id="1d8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/Swinject/Swinject" rel="noopener ugc nofollow" target="_blank">https://github.com/Swinject/Swinject</a></p></div></div>    
</body>
</html>