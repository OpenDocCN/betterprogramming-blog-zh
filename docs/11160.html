<html>
<head>
<title>How Fast is WebAssembly Versus JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">WebAssembly相对于JavaScript有多快？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-fast-is-webassembly-versus-javascript-bc0eca058a54?source=collection_archive---------0-----------------------#2022-02-23">https://betterprogramming.pub/how-fast-is-webassembly-versus-javascript-bc0eca058a54?source=collection_archive---------0-----------------------#2022-02-23</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="2f63" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">进行一些简单的基准测试产生了一些令人惊讶的结果</h2></div><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/b105467578f03816ce582fa254d1de19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3HVuM0X6enQoSY7c"/></div></div><p class="kw kx gj gh gi ky kz bd b be z dk translated">在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae la" href="https://unsplash.com/@veri_ivanova?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Veri Ivanova </a>拍摄的照片</p></figure><p id="e3ae" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">几天前，我想尝试建立一个完全由WebAssembly驱动的网站。在我看来，今天最简单的方法是使用<a class="ae la" href="https://dotnet.microsoft.com/en-us/apps/aspnet/web-apps/blazor" rel="noopener ugc nofollow" target="_blank">微软的Blazor </a>。本质上，您可以在以前使用JavaScript的地方编写C#代码，Blazor会将C#编译成WebAssembly，以允许它在浏览器中运行。</p><p id="c4ab" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然而，我有点惊讶地发现，当我测试它与用JavaScript编写的应用程序的速度时，它明显慢了。因此，我决定对WebAssembly进行基准测试，看看它与JavaScript在现实场景中的表现如何，比如从JavaScript调用WebAssembly模块。</p><h1 id="3ffe" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">什么是WebAssembly？</h1><p id="1d27" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在我们深入基准测试之前，你们中的一些人可能不熟悉WebAssembly，所以我将快速介绍一下它是什么。如果您已经熟悉，请随意跳到下一部分。</p><p id="0be3" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">WebAssembly是一种低级汇编语言，可以在任何主流浏览器中运行。它被设计得很快，比JavaScript快得多，以便处理要求更高性能的现代web用例。与在运行时使用实时编译器的JavaScript不同，WebAssembly在构建时编译，并由浏览器直接执行，与Java在构建时编译的方式相同。</p><p id="fac7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">工程师通常不会编写WebAssembly，相反，你可以像今天一样用你喜欢的编程语言编写代码，然后编译成WebAssembly。</p><p id="d925" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">几个主要的语言已经得到支持，包括C#、C/C++、Rust和TypeScript——许多其他语言<a class="ae la" href="https://github.com/appcypher/awesome-wasm-langs" rel="noopener ugc nofollow" target="_blank">目前正在为生产做准备。</a></p><p id="8dcc" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">WebAssembly当前不能访问DOM，因此它必须依赖于调用JavaScript来呈现WebAssembly模块的任何输出。</p><h1 id="1975" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">WebAssembly比JavaScript快吗？</h1><p id="69c1" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">将C#编译成WebAssembly实际上只有Blazor才有可能，所以对于基准测试来说不是很有用。相反，我将使用TypeScript(技术上来说，<a class="ae la" href="https://www.assemblyscript.org/" rel="noopener ugc nofollow" target="_blank"> AssemblyScript </a>)，它可以很容易地编译成WebAssembly模块。</p><h2 id="e00c" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">基准1:立方数</h2><p id="4c82" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">我尝试的三个基准中的第一个是对数字进行立方运算。这些功能本身非常简单:</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="824d" class="mu ly iv nh b gy nl nm l nn no">// AssemblyScript<br/>export function cube(n: i32): i32 {<br/>  return n * n * n;<br/>}</span><span id="cc28" class="mu ly iv nh b gy np nm l nn no">// JavaScript<br/>function cube(n) {<br/>    return n * n * n<br/>}</span></pre><p id="998d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然后我使用<a class="ae la" href="https://benchmarkjs.com/" rel="noopener ugc nofollow" target="_blank"> BenchmarkJS </a>建立了一个简单的基准:</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="1ef5" class="mu ly iv nh b gy nl nm l nn no">suite.add('JavaScript', function() {<br/>    cube(1000)<br/>})<br/>.add('WebAssembly', function() {<br/>    wasm_functions.cube(1000)<br/>})<br/>.on('cycle', function(event) {<br/>    <strong class="nh iw"><em class="nq">console</em></strong>.log(<strong class="nh iw"><em class="nq">String</em></strong>(event.target));<br/>})<br/>.on('complete', function() {<br/>    <strong class="nh iw"><em class="nq">console</em></strong>.log('Fastest is ' + this.filter('fastest').map('name'));<br/>})<br/>.run();</span></pre><p id="4a79" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，运行基准测试:</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="2612" class="mu ly iv nh b gy nl nm l nn no">Running tests for cube<br/>JavaScript x 886,730,026 ops/sec ±1.41% (86 runs sampled)<br/>WebAssembly x 168,566,364 ops/sec ±0.84% (95 runs sampled)</span><span id="df2d" class="mu ly iv nh b gy np nm l nn no">Fastest is JavaScript</span></pre><p id="ff19" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">正如你所看到的，它一点也不接近——<strong class="ld iw">JavaScript快了五倍多。</strong></p><h2 id="041a" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">基准2:排序数组</h2><p id="f12d" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">在现代计算中，给一个数字立方形非常容易，即使对于JavaScript也是如此。因此，我决定尝试一些稍微复杂一点的东西:对数组进行排序。同样，方法很简单:</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="f5a1" class="mu ly iv nh b gy nl nm l nn no">// AssemblyScript<br/>export function sort_array(arr: Array&lt;number&gt;): void<br/>{<br/>  arr.sort()<br/>}</span><span id="a8ee" class="mu ly iv nh b gy np nm l nn no">// JavaScript<br/>function sort_array(arr)<br/>{<br/>    arr.sort()<br/>}</span></pre><p id="a0c0" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">本质上，两者都将使用内置数组排序，结果如下:</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="1150" class="mu ly iv nh b gy nl nm l nn no">Running tests for sorting an array<br/>JavaScript x 1,186 ops/sec ±0.57% (94 runs sampled)<br/>WebAssembly x 402 ops/sec ±0.91% (85 runs sampled)</span><span id="6329" class="mu ly iv nh b gy np nm l nn no">Fastest is JavaScript</span></pre><p id="6113" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这一次更接近了，但是JavaScript仍然比T4快了三倍。</p><h2 id="d6cc" class="mu ly iv bd lz mv mw dn md mx my dp mh lk mz na mj lo nb nc ml ls nd ne mn nf bi translated">基准3:阶乘</h2><p id="e9bd" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">对于最后一个基准测试，我决定尝试稍微复杂一点的东西——计算给定数字的阶乘。阶乘是将一个给定的数和它之前的所有正数相乘得到的数。例如，4的阶乘是24，因为你乘以1x2x3x4。</p><p id="074e" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">下面是每个实现的代码:</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="70c8" class="mu ly iv nh b gy nl nm l nn no">// AssemblyScript<br/>export function factorial(num: i32): i32 {<br/><br/>  if (num === 0) return 1<br/>  if (num === 1) return 1;<br/><br/>  let fact = num;<br/><br/>  fact = fact * factorial(num-1);<br/>  return fact;<br/>}</span><span id="ccff" class="mu ly iv nh b gy np nm l nn no">// JavaScript<br/>function factorial(num){<br/><br/>    if (num === 0) return 1<br/>    if (num === 1) return 1;<br/><br/>    let fact = num;<br/><br/>    fact = fact * factorial(num-1);<br/>    return fact;<br/>}</span></pre><p id="0636" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">两者都利用了递归——有一种更有效的方法，但是我想通过使用递归来使它更费力一些。结果如下:</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="416d" class="mu ly iv nh b gy nl nm l nn no">Running tests for factorials<br/>JavaScript x 118,328 ops/sec ±1.23% (93 runs sampled)<br/>WebAssembly x 218,274 ops/sec ±1.07% (88 runs sampled)</span><span id="6cf9" class="mu ly iv nh b gy np nm l nn no">Fastest is WebAssembly</span></pre><p id="4fdf" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">最后，WebAssembly速度更快— <strong class="ld iw">几乎是JavaScript的两倍，事实上是</strong>。一个有趣的观察是，WebAssembly只会随着阶乘的增加而变得更快。</p><p id="2dec" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">上面的基准是阶乘6，但是如果我使用阶乘3重新运行基准，JavaScript轻松获胜。</p><p id="a26d" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">如果你对我如何运行基准测试的代码感兴趣，你可以在这里查看repo<a class="ae la" href="https://github.com/apeacock1991/webassembly_benchmark" rel="noopener ugc nofollow" target="_blank"/>——它非常粗糙，但确实有效。</p><h1 id="c220" class="lx ly iv bd lz ma mb mc md me mf mg mh kb mi kc mj ke mk kf ml kh mm ki mn mo bi translated">为什么WebAssembly在某些情况下会比较慢？</h1><p id="5433" class="pw-post-body-paragraph lb lc iv ld b le mp jw lg lh mq jz lj lk mr lm ln lo ms lq lr ls mt lu lv lw io bi translated">基准测试之后，我很好奇为什么WebAssembly在很多操作上比JavaScript慢那么多。在谷歌上搜索了一番后，我看到了一篇有趣的文章，给出了一些很好的见解:</p><blockquote class="nr ns nt"><p id="a191" class="lb lc nq ld b le lf jw lg lh li jz lj nu ll lm ln nv lp lq lr nw lt lu lv lw io bi translated">根据WebAssembly模块的大小，创建它的实例的过程通常需要几秒钟，通常是几十秒钟。<br/> - PSPDFKIT</p></blockquote><p id="8654" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">这里说的是C++代码，但同样适用于我们的基准测试。同样，我们每次调用函数，都要在WebAssembly实例中加载到内存中(类似于JavaScript，有一个WebAssembly VM运行在执行WebAssembly模块的浏览器中)，这就增加了很多开销。</p><p id="a8ce" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">你可以做一些优化，在文章中有概述，但是仍然会有大约300毫秒的开销。因此，对于大多数操作来说，WebAssembly不会比原生JavaScript更快——绝对不要把所有网站的JavaScript都转换成WebAssembly！</p><p id="9fa7" class="pw-post-body-paragraph lb lc iv ld b le lf jw lg lh li jz lj lk ll lm ln lo lp lq lr ls lt lu lv lw io bi translated">然而，这并不是WebAssembly的真正目的。它的目标是在需要更高性能的网络上实现更丰富的体验，例如机器学习、虚拟现实或游戏。</p><pre class="kl km kn ko gt ng nh ni nj aw nk bi"><span id="a2d4" class="mu ly iv nh b gy nl nm l nn no"><strong class="nh iw">Want to Connect?</strong></span><span id="cb73" class="mu ly iv nh b gy np nm l nn no">I run a free newsletter providing fortnightly technical book recommendations, including my key takeaways from the books. Interested? <a class="ae la" href="https://subscribe.technicalbookclub.com/?utm_source=medium&amp;utm_medium=article&amp;utm_campaign=webassemblybenchmark" rel="noopener ugc nofollow" target="_blank">Sign up here!</a></span></pre></div></div>    
</body>
</html>