<html>
<head>
<title>Limit Concurrent Network Requests With DispatchSemaphore in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Swift中的DispatchSemaphore限制并发网络请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/limit-concurrent-network-requests-with-dispatchsemaphore-in-swift-f313afd938c6?source=collection_archive---------4-----------------------#2020-09-07">https://betterprogramming.pub/limit-concurrent-network-requests-with-dispatchsemaphore-in-swift-f313afd938c6?source=collection_archive---------4-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d1c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">设置一次执行的最大操作数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/726c38361452364156dd93535370fe2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TYPfeCIv5pPkIg7M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·克罗斯比在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="631f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何使用<code class="fe lv lw lx ly b">DispatchSemaphore</code>来限制正在进行的网络请求的数量。</p><p id="5337" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">限制资源密集型操作允许我们更有效地管理线程资源。例如，当您的任务是同时获取十幅高质量图像时，一次只允许执行一个或两个图像加载操作是很有用的。</p><p id="6de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这是您将在本教程中掌握的内容:</p><ul class=""><li id="7a30" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">后台执行任务<code class="fe lv lw lx ly b">DispatchQueue</code>。</li><li id="0e1b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">利用<code class="fe lv lw lx ly b">DispatchSemaphore</code>并设置并发操作的最大数量。</li><li id="4a3d" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">理解使用<code class="fe lv lw lx ly b">sync</code>和<code class="fe lv lw lx ly b">async</code>执行的区别。</li></ul></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="60d2" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">我们开始吧</h1><p id="a1b8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">首先，让我们创建一个<code class="fe lv lw lx ly b">URL</code>、一个背景<code class="fe lv lw lx ly b">DispatchQueue</code>和一个值为2:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="66bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信号量的<code class="fe lv lw lx ly b">value</code>参数表示允许的并发操作的最大数量。换句话说，我们将只允许同时获取两个图像。</p><p id="8116" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们添加一个名为<code class="fe lv lw lx ly b">loadRandomPhoto()</code>的方法并创建一个<code class="fe lv lw lx ly b">async</code>任务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="15f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任务体中增加<code class="fe lv lw lx ly b">semaphore.wait()</code>和<code class="fe lv lw lx ly b">semaphore.signal()</code>，如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="3f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">semaphore.wait()</code>命令<em class="nt">将信号量计数器递减</em>1。我们在初始化<code class="fe lv lw lx ly b">DispatchSemaphore</code>时将计数器设置为2，因此一旦运行<code class="fe lv lw lx ly b">loadRandomPhoto()</code>功能，<code class="fe lv lw lx ly b">value</code>将减1。</p><p id="5333" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">semaphore.signal()</code>命令增加信号量的计数器，意味着一个操作结束，另一个操作可以取代它的位置。</p><p id="bdb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望在<code class="fe lv lw lx ly b">async</code>任务结束时运行<code class="fe lv lw lx ly b">semaphore.signal()</code>命令。<code class="fe lv lw lx ly b">defer</code>语句很方便地实现了这一点，所以我们不需要担心将命令插入错误的位置。</p><p id="95e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们从<code class="fe lv lw lx ly b">url</code>属性中获取<code class="fe lv lw lx ly b">Data</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="006f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于调试目的，我们简单地打印从<code class="fe lv lw lx ly b">Data</code>获得的<code class="fe lv lw lx ly b">UIImage</code>。</p><p id="2d7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在，我们必须启动几个图像加载操作，并观察输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="843d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lv lw lx ly b">for</code>循环触发了<code class="fe lv lw lx ly b">loadRandomPhoto()</code>函数十次。</p><p id="2870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们运行Xcode Playground，我们将看到成批打印的两个图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1471bb6509d68a9078e37a7d863b393d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/1*Mha1_JWFe_DMWabnXf44IQ.gif"/></div></figure><p id="eaf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">信号量已经完成，但是使用<code class="fe lv lw lx ly b">sync</code>执行和<code class="fe lv lw lx ly b">async</code>执行有什么区别呢？</p><p id="e463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当使用<code class="fe lv lw lx ly b">sync</code>时，调用它的线程将被阻塞，直到任务完成，而<code class="fe lv lw lx ly b">async</code>执行不会等待任务完成。因此，它不会阻塞当前线程。</p><p id="747c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的例子中，让我们删除<code class="fe lv lw lx ly b">DispatchSemaphore</code>并将<code class="fe lv lw lx ly b">async</code>执行改为<code class="fe lv lw lx ly b">sync</code>执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="81a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们看到图像一次只加载一个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f1e67f9c56e4d60760a17ebccb3293d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/1*wvBXP-pTNvyaRe70eLOWXw.gif"/></div></figure><p id="431c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当使用<code class="fe lv lw lx ly b">value</code>设置为1的<code class="fe lv lw lx ly b">DispatchSemaphore</code>时，使用<code class="fe lv lw lx ly b">sync</code>会产生相同的结果。</p><p id="94bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在我们上面的例子中，尽管我们指定了<code class="fe lv lw lx ly b">DispatchQueue</code>的<code class="fe lv lw lx ly b">.background</code>服务质量，但是<code class="fe lv lw lx ly b">sync</code>调用仍然发生在主线程<em class="nt">上。结果，我们让图像加载操作冻结我们的UI，直到它们完成。</em></p><p id="cc45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在<code class="fe lv lw lx ly b">DispatchQueue.main</code>上调用<code class="fe lv lw lx ly b">sync</code>时最好非常小心。如果我们从主线程调用它，应用程序将由于<a class="ae ky" href="https://stackoverflow.com/a/49260434" rel="noopener ugc nofollow" target="_blank">死锁</a>而终止。另一方面，当从后台线程调用它时，我们应该避免添加耗时的代码块来防止UI冻结。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="33c4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">包扎</h1><p id="b3fc" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我希望这篇教程对你有所帮助。感谢阅读！</p></div></div>    
</body>
</html>