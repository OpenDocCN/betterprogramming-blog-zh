<html>
<head>
<title>The Ultimate Guide to the SwiftUI 2 Application Life Cycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 2应用程序生命周期的终极指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-ultimate-guide-to-the-swiftui-2-application-life-cycle-e4358e27a92a?source=collection_archive---------10-----------------------#2020-10-21">https://betterprogramming.pub/the-ultimate-guide-to-the-swiftui-2-application-life-cycle-e4358e27a92a?source=collection_archive---------10-----------------------#2020-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cdb7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">再见AppDelegate</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/179fcb2468b376db2164e6f771a46243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nhb0C-BMierO2SW0bvtKqA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片基于<a class="ae ky" href="https://thenounproject.com/kavya261990/collection/space/?i=3437783" rel="noopener ugc nofollow" target="_blank">火箭</a>由<a class="ae ky" href="https://thenounproject.com/kavya261990" rel="noopener ugc nofollow" target="_blank"> Icongeek26 </a>上的<a class="ae ky" href="https://thenounproject.com/" rel="noopener ugc nofollow" target="_blank">名词项目</a></p></figure><p id="6c0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长久以来，iOS开发者一直将<code class="fe lv lw lx ly b">AppDelegate</code>作为他们应用的主要入口。随着SwiftUI2在WWDC 2020上的发布，苹果引入了一个新的应用生命周期，它(几乎)完全废除了<code class="fe lv lw lx ly b">AppDelegate</code>，为类似DSL的方法让路。</p><p id="a60b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讨论为什么引入这一变化，以及如何在新的或现有的应用程序中利用新的生命周期。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1e5a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">指定应用程序入口点</h1><p id="8ee7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们需要回答的第一个问题是“我们如何告诉编译器我们应用程序的入口点？”<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0281-main-attribute.md" rel="noopener ugc nofollow" target="_blank"> SE-0281 </a>指定基于类型的程序入口点如何工作:</p><blockquote class="nd ne nf"><p id="b969" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">“Swift编译器会将注释有<code class="fe lv lw lx ly b">@main</code>属性的类型识别为提供程序的入口点。标有<code class="fe lv lw lx ly b">@main</code>的类型只有一个隐含的需求:声明一个静态的<code class="fe lv lw lx ly b">main()</code>方法</p></blockquote><p id="f7b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建新的SwiftUI应用程序时，该应用程序的<code class="fe lv lw lx ly b">@main</code>类如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="752e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么SE-0281中提到的静态<code class="fe lv lw lx ly b">main()</code>函数在哪里呢？</p><p id="9110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，为了用户的方便，框架提供者可以(也应该)提供默认的实现。查看上面的代码片段，您会注意到<code class="fe lv lw lx ly b">SwiftUIAppLifeCycleApp</code>符合<code class="fe lv lw lx ly b">App</code>协议。Apple提供了一个协议扩展，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="51e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们知道了——这个协议扩展提供了一个负责应用程序启动的默认实现。</p><p id="adb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于SwiftUI框架不是开源的，我们看不到苹果是如何实现的，但是<a class="ae ky" href="https://github.com/apple/swift-argument-parser" rel="noopener ugc nofollow" target="_blank"> Swift Argument Parser </a>是开源的，也使用这种方法。查看<code class="fe lv lw lx ly b">ParsableCommand</code>的源代码，了解他们如何使用协议扩展来提供作为程序入口点的静态<code class="fe lv lw lx ly b">main</code>函数的默认实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这一切听起来有点复杂，好消息是，在创建新的SwiftUI应用程序时，您实际上不必担心这一点:在创建您的应用程序时，只需确保在生命周期下拉列表中选择“SwiftUI应用程序”，就大功告成了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a2c304a85599a95774e4cbbdccac3562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*XWa5RgMK2WllmlHk.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nn">创建新的SwiftUI项目</em></p></figure><p id="3fda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看一些常见的场景。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d526" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">初始化资源/你最喜欢的SDK或框架</h1><p id="74c2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">大多数应用程序需要在应用程序启动时执行几个步骤:获取一些配置值，连接到数据库，或者初始化框架或第三方SDK。</p><p id="fc24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，你会在你的<code class="fe lv lw lx ly b">ApplicationDelegate</code>的<code class="fe lv lw lx ly b">application(_:didFinishLaunchingWithOptions:)</code>方法中这样做。由于我们不再有应用程序委托，我们需要找到其他方法来初始化我们的应用程序。根据您的具体要求，这里有一些策略:</p><ul class=""><li id="ac56" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">在你的主类上实现一个初始化器(参见<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID205" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="05de" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">设置存储属性的初始值(参见<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID206" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="3626" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">使用闭包设置默认属性值(参见<a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID232" rel="noopener ugc nofollow" target="_blank">文档</a></li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f6dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些都不能满足你的需求，你可能需要一个<code class="fe lv lw lx ly b">ApplicationDelegate</code>。一直读到最后，了解如何添加一个。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ed5c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">处理应用程序的生命周期</h1><p id="7df9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">知道应用程序处于哪种状态有时很有用。例如，您可能希望在应用程序变为活动状态时获取新数据，或者在应用程序变为非活动状态并转换到后台时刷新任何缓存。</p><p id="1539" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，你会在你的<code class="fe lv lw lx ly b">ApplicationDelegate</code>上实现<code class="fe lv lw lx ly b">applicationDidBecomeActive</code>、<code class="fe lv lw lx ly b">applicationWillResignActive</code>或<code class="fe lv lw lx ly b">applicationDidEnterBackground</code>。</p><p id="0117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从iOS 14.0开始，苹果提供了一个新的API，允许以更优雅和可维护的方式跟踪应用程序的状态:<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/scenephase" rel="noopener ugc nofollow" target="_blank">ScenePhase</a></code>。你的项目可以有多个场景，但是很可能你只有一个场景，用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swiftui/windowgroup" rel="noopener ugc nofollow" target="_blank">WindowGroup</a></code>表示。</p><p id="13f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI跟踪环境中场景的状态，您可以通过使用<code class="fe lv lw lx ly b">@Environment</code>属性包装器获取当前值，然后使用<code class="fe lv lw lx ly b">onChange(of:)</code>修饰符监听任何更改，从而使代码可以访问当前值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f4d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，你也可以从应用程序的其他位置读取相位。当读取应用程序顶层的阶段时(如代码片段所示)，您将获得应用程序中所有阶段的汇总。值为<code class="fe lv lw lx ly b">.inactive</code>意味着应用程序中没有任何场景处于活动状态。</p><p id="2d13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当读取一个视图上的阶段时，您将收到包含该视图的阶段的值。请记住，此时您的应用程序可能包含具有其他阶段值的其他场景。关于场景阶段的更多细节，请阅读苹果的<a class="ae ky" href="https://developer.apple.com/documentation/swiftui/scenephase" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="24a6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">处理深层链接</h1><p id="63f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">以前，当处理深层链接时，您必须实现<code class="fe lv lw lx ly b">application(_:open:options:)</code>并将传入的URL路由到最合适的处理程序。</p><p id="8f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了新的应用程序生命周期模型，这变得容易多了。你可以通过将<code class="fe lv lw lx ly b">onOpenURL</code>修改器附加到应用程序最顶层的场景来处理传入的URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="8f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">真正酷的是:你可以在你的应用程序中安装多个URL处理程序——使深度链接变得更加容易，因为你可以在最合适的地方处理传入的链接。</p><p id="3670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可能的话，你应该使用<a class="ae ky" href="https://developer.apple.com/documentation/xcode/allowing_apps_and_websites_to_link_to_your_content" rel="noopener ugc nofollow" target="_blank">通用链接</a>(或<a class="ae ky" href="https://firebase.google.com/docs/dynamic-links" rel="noopener ugc nofollow" target="_blank"> Firebase动态链接</a>，它利用<a class="ae ky" href="https://firebase.google.com/docs/dynamic-links/operating-system-integrations" rel="noopener ugc nofollow" target="_blank">iOS应用</a>的通用链接)，因为这些使用关联的域来创建你拥有的网站和你的应用之间的连接——这将允许你安全地共享数据。</p><p id="e6b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，您仍然可以使用<a class="ae ky" href="https://developer.apple.com/documentation/xcode/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app" rel="noopener ugc nofollow" target="_blank">自定义URL方案</a>链接到您的应用程序中的内容。</p><p id="fd40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论哪种方式，在您的应用程序中触发深层链接的简单方法是在您的开发机器上使用以下命令:</p><p id="a1bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">$ xcrun simctl openurl booted &lt;your url&gt;</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/deb1b27e3198e681ea0199413c87110c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RMYt_zbKht6oqYJdTn9S_w.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示:打开深层链接并继续用户活动</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e9c2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">持续用户活动</h1><p id="7195" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你的应用使用<code class="fe lv lw lx ly b">NSUserActivity</code>到<a class="ae ky" href="https://developer.apple.com/documentation/foundation/nsuseractivity" rel="noopener ugc nofollow" target="_blank">与</a> Siri、Handoff或Spotlight集成，你需要处理用户活动的延续。</p><p id="97e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，新的应用程序生命周期模型通过提供两个修饰符使这变得更容易，这两个修饰符允许您广告一个活动并在以后继续它。</p><p id="7d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个片段，展示了如何宣传一项活动，例如，在详细信息视图中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="978b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了继续这个活动，您可以在顶级导航视图中注册一个<code class="fe lv lw lx ly b">onContinueUserActivity</code>闭包，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2bc7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">求助——以上都不适合我！</h1><p id="5179" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">新的应用程序生命周期并不支持<code class="fe lv lw lx ly b">AppDelegate</code>的所有回调。如果以上都不能满足你的需求，你可能需要一个<code class="fe lv lw lx ly b">AppDelegate</code>。</p><p id="a11e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能需要一个<code class="fe lv lw lx ly b">AppDelegate</code>的另一个原因是，如果您使用任何第三方SDK，它们利用<a class="ae ky" href="https://pspdfkit.com/blog/2019/swizzling-in-swift/" rel="noopener ugc nofollow" target="_blank">方法swizzling </a>将自己注入到应用程序生命周期中。<a class="ae ky" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank">火情</a>是一个<a class="ae ky" href="https://stackoverflow.com/a/62633158/281221" rel="noopener ugc nofollow" target="_blank">众所周知的案例</a>。</p><p id="5b24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了帮助您，Swift提供了一种将<code class="fe lv lw lx ly b">AppDelegate</code>的conformer与您的<code class="fe lv lw lx ly b">App</code>实现:<code class="fe lv lw lx ly b">@UIApplicationDelegateAdaptor</code>连接起来的方法。下面是它的使用方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ecf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您复制一个现有的<code class="fe lv lw lx ly b">AppDelegate</code>实现，不要忘记删除<code class="fe lv lw lx ly b">@main</code>属性——否则，编译器会抱怨有多个应用程序入口点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a937" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="3f63" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">说完这些，我们再来讨论一下苹果为什么要做出这样的改变。我认为有几个原因:</p><p id="0d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SE-0281 明确声明设计目标之一是“提供一个更通用的轻量级机制，用于将程序的入口点委托给指定的类型。”</p><p id="1224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Apple为处理应用程序生命周期而选择的基于DSL的方法与在SwiftUI中构建UI的声明式方法非常一致。使用相同的概念使事情更容易理解，并有助于新的开发人员。</p><p id="da3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，新的应用程序生命周期模型使实现应用程序启动变得更容易、更简单。</p><p id="031b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何声明式方法的主要好处是:框架/平台提供者负责实现特定功能，而不是将实现特定功能的负担推给开发人员。如果有必要进行任何更改，在不破坏许多开发人员的应用程序的情况下发布这些更改会容易得多——理想情况下，开发人员不必更改他们的实现，因为框架会为您处理一切。</p><p id="52ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，新的应用程序生命周期模型使实现应用程序启动变得更容易、更简单。你的代码会更干净，更容易维护——如果你问我的话，这总是一件好事。</p><p id="bd14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能帮助您理解新应用程序生命周期的来龙去脉。</p><p id="c82b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e15a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">进一步阅读</h1><p id="d456" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果您想了解更多信息，请查看以下资源:</p><div class="od oe gp gr of og"><a href="https://medium.com/firebase-developers/firebase-and-the-new-swiftui-2-application-life-cycle-e568c9f744e9" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Firebase和新的SwiftUI 2应用程序生命周期</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">了解如何在SwiftUI 2应用程序中初始化Firebase</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://github.com/peterfriese/Colors" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">底色/颜色</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">这是Colors的源代码，这是一个示例应用程序，用于演示新的SwiftUI 2应用程序生命周期…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0281-main-attribute.md" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">苹果/swift——进化</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">一种Swift语言功能，用于指定一种类型作为开始程序执行的入口点。而不是写…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">github.com</p></div></div><div class="op l"><div class="ow l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://developer.apple.com/documentation/swiftui/app" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Apple开发者文档</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">应用</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">developer.apple.com</p></div></div></div></a></div><div class="od oe gp gr of og"><a href="https://developer.apple.com/documentation/xcode/allowing_apps_and_websites_to_link_to_your_content" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Apple开发者文档</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">允许应用程序和网站链接到您的内容</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">developer.apple.com</p></div></div></div></a></div></div></div>    
</body>
</html>