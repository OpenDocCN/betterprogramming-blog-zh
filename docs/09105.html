<html>
<head>
<title>Understand the Versatility of Asterisks in Python — Know 8 Use Cases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Python中星号的多功能性——了解8种用例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-the-versatility-of-asterisks-in-python-know-8-use-cases-722bff20e84c?source=collection_archive---------6-----------------------#2021-07-15">https://betterprogramming.pub/understand-the-versatility-of-asterisks-in-python-know-8-use-cases-722bff20e84c?source=collection_archive---------6-----------------------#2021-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7535" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">复习星号的基本用法和高级用法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2812cb14f18b3c5ed3c7d43c1577a377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AyAnf7UCU2jm7eiQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@mikekilcoyne?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔·基尔科因</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python编程中，我们大多使用字母和数字，但不会使用太多符号。最常见的符号是运算符，包括加法(+)、减法(-)、乘法(*)和除法(/)。在这些运算符中，星号的用法比其他运算符多。在本文中，我想回顾一下除了作为乘法运算符之外的这些用法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d63" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.权力运营商</h1><p id="d63e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一种用法是作为幂运算符。不使用内置的<code class="fe mz na nb nc b">pow</code>函数，可以简单地使用<code class="fe mz na nb nc b">**</code>来计算取幂。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7a54" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; pow(5, 3)<br/>125<br/>&gt;&gt;&gt; 5**3<br/>125</span></pre><h1 id="c5ee" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">2.捕获所有可迭代的解包</h1><p id="f651" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">也被称为<em class="nr">明星表情</em>。当我们处理一个iterable时，比如一个tuple，我们可以通过创建多个变量来解包这个tuple以检索各个条目，如下所示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2411" class="nh md it nc b gy ni nj l nk nl">data = (1, 2, 3, 4)<br/>a, b, c, d = data<br/># <em class="nr">a=1, b=2, c=3, d=4</em></span></pre><p id="6e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，也可以使用带星号的表达式(带有*前缀的变量名)来捕获解包中的多个项目。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c4ca" class="nh md it nc b gy ni nj l nk nl">a, *b = data<br/><em class="nr"># a=1, b=[2, 3, 4]</em></span></pre><p id="8bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在带星号的表达式中，有三点需要注意。</p><ol class=""><li id="451a" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><strong class="lb iu">拆包中只能有一个带星号的表达式。</strong>因为它旨在捕获所有未被其他变量考虑的项目，所以使用多个带星号的表达式将无法知道哪些项目与哪些变量相关。</li><li id="9970" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">带星号的表达式将创建一个列表对象</strong>，尽管我们从一个元组对象开始。</li><li id="92be" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><strong class="lb iu">带星号的表达式不仅可以和元组一起使用</strong>，我们还可以将这种技术应用于其他可迭代对象(例如，列表、字符串)。</li></ol><h1 id="6b93" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">3.解包Iterables以创建变量</h1><p id="919a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在前面的示例中，星号出现在赋值语句的左侧，用于创建新的list对象。但是，它也可以出现在赋值语句的右侧。在这种情况下，它解包现有的iterable。</p><p id="88a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用共享项和其他不同的项创建多个iterables时，这种技术非常有用。考虑下面的例子。我们首先创建一个由共享项组成的列表对象，并在其他列表对象中解包该列表对象以检索共享项。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f0e0" class="nh md it nc b gy ni nj l nk nl">shared_items = [1, 2, 3]<br/><br/>items1 = [*shared_items, 4, 5, 6]<br/>items2 = [-3, -2, -1, *shared_items]</span></pre><p id="3453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们可以使用列表连接来连接列表，但我个人认为这种方法可读性更好。更重要的是，它可以与任何iterable一起工作，而列表连接只在列表之间工作。观察下面的效果。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4a6d" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; shared_numbers = range(3)<br/>&gt;&gt;&gt; [*shared_numbers, 3, 4, 5]<br/>[0, 1, 2, 3, 4, 5]<br/>&gt;&gt;&gt; shared_numbers + [3, 4, 5]<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: unsupported operand type(s) for +: 'range' and 'list'</span></pre><h1 id="7a90" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">4.不同数量的位置参数</h1><p id="6503" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">定义函数时，有两种类型的参数:位置参数和关键字参数。关键字参数是由标识符指定的，位置参数是由它们的位置指定的。在大多数情况下，我们定义了一定数量的位置参数。然而，我们可以定义带有不同数量位置参数的函数——带星号。解释前请看下面一个琐碎的例子。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3a3e" class="nh md it nc b gy ni nj l nk nl">def rounded_sum(*numbers):<br/>    total = 0<br/>    for number in numbers:<br/>        total += round(number)<br/>    print(<strong class="nc iu">f"Received </strong>{numbers}<strong class="nc iu"> -&gt; rounded sum: </strong>{total}<strong class="nc iu">"</strong>)<br/>    return total</span></pre><ul class=""><li id="caaa" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu og ny nz oa bi translated"><code class="fe mz na nb nc b">rounded_sum</code>函数只有一个参数<code class="fe mz na nb nc b">*numbers</code>，这表示当您调用这个函数时，您可以设置任意数量的位置参数，如下所示。</li></ul><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8b05" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; rounded_sum(2.4, 3.7, 4.8)<br/>Received (2.4, 3.7, 4.8) -&gt; rounded sum: 11<br/>11</span></pre><ul class=""><li id="172d" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu og ny nz oa bi translated">您会注意到函数将不同数量的参数作为一个tuple对象进行处理。在例子中，我们用三个数字调用函数，当我们打印<code class="fe mz na nb nc b">numbers</code>时，它是由这三个数字组成的元组对象。</li></ul><p id="9957" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这里没有详细介绍，但是应该注意，位置参数的可变数量应该在其他位置参数之后。否则，Python无法判断哪个位置变量与哪个参数对应。</p><h1 id="7e12" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">5.打开字典</h1><p id="1c29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">星号的另一个常见用法是打开字典。通过使用现有的字典，它通常用在赋值语句的右侧。假设我们有以下字典作为开始。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d154" class="nh md it nc b gy ni nj l nk nl">science_scores = {<strong class="nc iu">"math"</strong>: 90, <strong class="nc iu">"physics"</strong>: 95, <strong class="nc iu">"chemistry"</strong>: 92}<br/>art_scores = {<strong class="nc iu">"english"</strong>: 93, <strong class="nc iu">"spanish"</strong>: 94}</span></pre><p id="b5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与解包列表、元组或其他可重复项不同，解包字典需要使用两个星号。如下所示，我们通过解包现有的字典来创建一个新的字典对象。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fa46" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; combined_scores = {**science_scores, **art_scores}<br/>&gt;&gt;&gt; print(combined_scores)<br/>{'math': 90, 'physics': 95, 'chemistry': 92, 'english': 93, 'spanish': 94}</span></pre><p id="1367" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述操作也可以称为字典的合并/更新。还有一些其他的技术，你可以在我之前的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/dictionary-merging-and-updating-in-python-3-9-4ac67c667ce">文章</a>中找到，我在这里不展开这个话题。</p><h1 id="6d06" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">6.不同数量的关键字参数</h1><p id="2c6b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了不同数量的位置参数，还可以在Python函数中定义不同数量的关键字参数。惯例是用<code class="fe mz na nb nc b">**kwargs</code>来表示这样的特征。当你看到一个使用<code class="fe mz na nb nc b">**kwargs</code>的函数签名时，意味着你可以设置任意数量的关键字参数。当然，这些论点必须是有效的；否则，该功能无法正确使用它们。</p><p id="d274" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在两种常见情况下，您可能希望在函数定义中使用<code class="fe mz na nb nc b">**kwargs</code>。</p><p id="17a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，你不知道函数将采用什么关键字参数。在这种情况下，使用<code class="fe mz na nb nc b">**kwargs</code>允许这样的灵活性。例如，有人可以使用下面的API函数，允许用户向服务器发送任何关键字参数。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b731" class="nh md it nc b gy ni nj l nk nl">def send_info_to_server(**kwargs):<br/>    print(<strong class="nc iu">f"Send the info: </strong>{kwargs}<strong class="nc iu">"</strong>)<br/>    <em class="nr"># do something to prepare the information</em></span></pre><p id="fb92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个调用这个函数的例子。如您所见，我们可以传递任何关键字参数，这些参数在函数中被处理为一个<code class="fe mz na nb nc b">dict</code>对象。换句话说，当您编写自己的涉及<code class="fe mz na nb nc b">**kwargs</code>的函数时，您将它们作为字典对象来处理。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2035" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; send_info_to_server(postId="abc", userId="user")<br/>Send the info: {'postId': 'abc', 'userId': 'user'}<br/>&gt;&gt;&gt; send_info_to_server(like=True, status="success")<br/>Send the info: {'like': True, 'status': 'success'}</span></pre><p id="ee0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，通过将关键字参数“打包”为<code class="fe mz na nb nc b">**kwargs</code>，可以使函数定义更加清晰。对于这些关键字参数，理想情况下它们应该有已知的默认值，您可以在函数体中指定这些值。如果一些参数没有合适的默认值，最好明确地列出它们，因为让你的函数签名清晰比使用<code class="fe mz na nb nc b">**kwargs</code>让你的函数签名看起来干净更重要。</p><h1 id="233b" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">7.定义仅关键字参数</h1><p id="aa55" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">星号在函数定义中的另一个重要用途是创建只有关键字的参数。顾名思义，这些参数只能使用关键字来指定。通常，参数通过关键字或位置进行解析。(这里在参数解析方面有太多的技术细节，感兴趣的用户可以参考<a class="ae ky" href="https://www.python.org/dev/peps/pep-3102/" rel="noopener ugc nofollow" target="_blank">官方PEP </a>进行更详细的讨论。).</p><p id="989d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑下面的例子来说明关键字参数可以按位置设置。正如你所看到的，<code class="fe mz na nb nc b">multiply(5, 4)</code>没有使用第二个参数的关键字。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6986" class="nh md it nc b gy ni nj l nk nl">def multiply(number, multiplier=1):<br/>    return number * multiplier<br/><br/>multiply(5, 4)<br/>multiply(5, multiplier=4)</span></pre><p id="7e4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，为了明确起见，我们可以用星号实现仅关键字参数特性，如下所示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="60d6" class="nh md it nc b gy ni nj l nk nl">def explicit_multiply(number, *, multiplier=1):<br/>    return number * multiplier</span></pre><p id="583e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的函数中，我们用<code class="fe mz na nb nc b">*</code>表示星号后面的所有参数都只能设置为关键字参数。这样，我们通过强制使用已定义的关键字来提高代码的可读性。有了这个更新的函数，通过设置参数的位置来调用这个函数就不起作用了。见下文。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1525" class="nh md it nc b gy ni nj l nk nl">&gt;&gt;&gt; explicit_multiply(5, multiplier=4)<br/>20<br/>&gt;&gt;&gt; explicit_multiply(5, 4)<br/>Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: explicit_multiply() takes 1 positional argument but 2 were given</span></pre><h1 id="52de" class="mc md it bd me mf nm mh mi mj nn ml mm jz no ka mo kc np kd mq kf nq kg ms mt bi translated">8.什么都导入(不要用！)</h1><p id="9714" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">许多人犯的另一个常见错误是通过使用*作为通配符从模块中导入所有内容。你可能以前在什么地方见过这个。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c8cc" class="nh md it nc b gy ni nj l nk nl">from module_abc import *<br/>from module_xyz import *</span></pre><p id="adc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然看起来你不需要输入特定的组件(例如，函数和类)，但是它有两个问题。1)不清楚您从这些模块中使用了什么。读者会很困惑。2)它可能会有显著的副作用，其中许多副作用会导致bug。例如，两个模块可能共享一些碰巧具有相同名称的函数。当所有内容都被导入时，您正在使用的函数可能与您想要使用的函数不同。因此，为了避免这些问题，最好的做法是显式地指定导入的项目，如下所示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="157e" class="nh md it nc b gy ni nj l nk nl">from module_abc import fun_a, ClassA<br/>from module_xyz import fun_x, ClassY</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bf5e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="3586" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了Python中星号的八种常见用法。有些是与他人相关的，而有些人似乎是独立的。然而，他们有一个共同点:参与*。当你在学习一门新的编程语言时，找到在某些方面有联系的东西通常是一个好主意，这样你可以强化相关的技术并更好地了解它们。</p></div></div>    
</body>
</html>