<html>
<head>
<title>Going Native With Spring Boot 3 GA</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Spring Boot 3 GA一起实现本地化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/going-native-with-spring-boot-3-ga-4e8d91ab21d3?source=collection_archive---------1-----------------------#2022-11-24">https://betterprogramming.pub/going-native-with-spring-boot-3-ga-4e8d91ab21d3?source=collection_archive---------1-----------------------#2022-11-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7bc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何使用Spring Boot 3原生映像支持的实用指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4cac14b7085b8f1f6f82816835c7f498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJncosLl1TOjyqICa5hdog.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片</p></figure><p id="082f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Spring Boot 3今天正式上市，2022年感恩节！对于整个Spring社区来说，这的确是一个巨大的里程碑！Spring和GraalVM团队在将原生映像支持引入Spring Boot 3方面做了出色的工作。在我将一些微服务升级到Spring Boot 3以利用其原生映像支持的POC工作中，我亲眼目睹了我在过去一两个月中在GitHub存储库中提出的问题是如何得到及时解决和修复的。</p><p id="dd6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几个月前，我出版了<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/how-to-integrate-spring-native-into-spring-boot-microservices-add2ece541b8?sk=6ba4674550db30783f7c5c68ba13c141"> <em class="lv">春原:让Spring Boot飞翔的翅膀</em> </a>。探索Spring Native如何提升基于Spring Boot 2框架的应用令人大开眼界。在Spring Boot 3中，我们现在内置了GraalVM本地映像支持！这对我们应用程序开发人员来说实际上意味着什么？让我们采用一种实用的方法将Spring Boot 2.7.x应用程序转换为Spring Boot 3，并探索Spring Boot 3附带的原生图像支持。</p><h1 id="4570" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Spring Boot 3中的本机映像支持</h1><p id="6aac" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">原生映像支持主要是让应用程序及其库能够在构建时进行分析，以配置运行时需要或不需要的内容。我们的目标是以最佳方式做到这一点，以最小的足迹。有了原生映像支持，基于Spring Boot 3构建的应用可以即时启动、减少内存消耗，并立即达到峰值性能。有关原生映像支持给基于Spring Boot框架的应用程序带来的提升的更多细节，请参考我的文章<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/how-to-integrate-spring-native-into-spring-boot-microservices-add2ece541b8?sk=6ba4674550db30783f7c5c68ba13c141"><em class="lv">Spring Native:The Wings That Make you flying</em></a>。</p><h1 id="270e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">升级Spring Boot</h1><p id="b198" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">我们将使用一个名为<code class="fe mt mu mv mw b"><a class="ae lu" href="https://github.com/wenqiglantz/customerservice-spring-boot-3" rel="noopener ugc nofollow" target="_blank">customer-service</a></code>的演示应用，构建于Spring Boot 2.7.5之上。第一步是将其升级到Spring Boot 3。跟随我的<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/notes-on-spring-boot-3-upgrade-a15e16f84862?sk=dd1bcbfe20a3e9a2182340b877c6c4ae"><em class="lv">Spring Boot 3升级笔记</em> </a>获取升级的详细说明。请务必将Spring Boot升级到正式版3.0.0。</p><h1 id="96e0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">建立你的本土形象</h1><p id="354f" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">记住，我们必须在我们的根pom中添加<code class="fe mt mu mv mw b">spring-native</code>作为一个新的依赖项，以便在Spring Boot 2应用中启用原生支持，并添加<code class="fe mt mu mv mw b">spring-aot-maven-plugin</code>？在Spring Boot 3中，原生支持被嵌入，这意味着你不再需要导入<code class="fe mt mu mv mw b">spring-native</code>依赖，也不需要添加<code class="fe mt mu mv mw b">spring-aot-maven-plugin</code>，你所需要做的就是在根pom中将<code class="fe mt mu mv mw b">spring-boot-starter-parent</code>的版本升级到3.0.0。您的pom的<code class="fe mt mu mv mw b">&lt;parent&gt;</code>部分应该如下所示:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="0785" class="nb lx it mw b be nc nd l ne nf">&lt;parent&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;<br/>    &lt;version&gt;3.0.0&lt;/version&gt;<br/>    &lt;relativePath /&gt;<br/>&lt;/parent&gt;</span></pre><p id="2cd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mt mu mv mw b">spring-boot-starter-parent</code>声明了一个<code class="fe mt mu mv mw b">native</code>概要文件，它配置了创建本地映像所需的执行。您可以在命令行上使用<code class="fe mt mu mv mw b">-P</code>标志激活概要文件，例如<code class="fe mt mu mv mw b">mvn clean -Pnative spring-boot:build-image</code>。是的，就是这么简单，调用<code class="fe mt mu mv mw b">native</code> maven profile！<code class="fe mt mu mv mw b">native</code> profile到底是做什么的？根据Spring的文档有三件事:</p><ol class=""><li id="9483" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt nl nm nn no bi translated">当Spring Boot Maven插件被应用到一个项目时<code class="fe mt mu mv mw b">process-aot</code>的执行。</li></ol><p id="8493" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">2.合适的设置，以便<a class="ae lu" href="https://docs.spring.io/spring-boot/docs/3.0.x-SNAPSHOT/maven-plugin/reference/htmlsingle/#build-image" rel="noopener ugc nofollow" target="_blank">构建图像</a>生成本地图像。</p><p id="9cc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">3.<a class="ae lu" href="https://graalvm.github.io/native-build-tools/latest/maven-plugin.html" rel="noopener ugc nofollow" target="_blank">原生构建工具Maven插件</a>的合理默认值，特别是:</p><ul class=""><li id="1456" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt np nm nn no bi translated">确保插件使用原始类路径，而不是主jar文件，因为它不理解我们重新打包的jar格式。</li><li id="df6f" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">验证是否有合适的GraalVM版本可用。</li><li id="ecff" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">下载第三方可达性元数据。</li></ul><p id="b12d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了从<code class="fe mt mu mv mw b">native</code>档案中获益，你的Spring Boot 3应用应该定义两个插件:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="c078" class="nb lx it mw b be nc nd l ne nf">&lt;plugin&gt;<br/>    &lt;groupId&gt;org.graalvm.buildtools&lt;/groupId&gt;<br/>    &lt;artifactId&gt;native-maven-plugin&lt;/artifactId&gt;<br/>&lt;/plugin&gt;<br/>&lt;plugin&gt;<br/>   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;<br/>&lt;/plugin&gt;</span></pre><p id="6c50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于为多模块项目配置插件的细节，请参考Spring的文档<a class="ae lu" href="https://docs.spring.io/spring-boot/docs/3.0.x-SNAPSHOT/maven-plugin/reference/htmlsingle/#_using_the_native_profile" rel="noopener ugc nofollow" target="_blank">使用本地概要文件</a>。</p><h1 id="5693" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">使用GitHub操作构建GraalVM本机映像</h1><p id="9cdf" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">有两种方法可以构建本机映像:</p><ul class=""><li id="8ae6" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt np nm nn no bi translated">云原生构建包(Cloud-Native Buildpacks):在<a class="ae lu" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank">云原生计算基金会</a> (CNCF)中的一个孵化项目，它提供了一种机制，在不使用<code class="fe mt mu mv mw b">Dockerfile</code>的情况下，将你的应用源代码转换成开放容器倡议(OCI)兼容的容器映像。我们将在下面的示例代码中使用Buildpacks来构建我们的客户服务本机映像。</li><li id="0f46" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">原生构建工具:如果想不用Docker直接生成原生可执行文件，可以使用GraalVM原生构建工具。原生构建工具是GraalVM附带的插件。</li></ul><p id="06ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑到生成本机映像需要很长的构建时间，因此无论何时提出pull请求或者将代码推送到main/master分支，构建本机映像都是不切实际的。那么，我们应该如何处理JVM构建和本机映像构建呢？两个工作流程:</p><ul class=""><li id="9c16" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt np nm nn no bi translated">JVM的CI工作流:没有本机映像支持</li><li id="be71" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">GraalVM本机映像的CI工作流:具有本机映像支持</li></ul><p id="80d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们仔细看看每个工作流程。</p><h1 id="73bf" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">JVM的CI工作流</h1><p id="443c" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">这是开发人员的默认CI工作流，由PR或代码推送自动触发。如果您已经将GitHub操作用于您的CI/CD，那么您的JVM工作流应该仍然是您的默认CI工作流。请参见下面我的JVM CI工作流示例。该工作流程的主要步骤包括:</p><ul class=""><li id="79ab" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt np nm nn no bi translated">用Maven和Buildpacks构建</li><li id="3090" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">标记并将图像推送到AWS弹性容器注册表(ECR)</li><li id="d734" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">用Trivy漏洞扫描器扫描图像</li></ul><p id="0afd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据您的项目需求，您可以添加其他典型的CI步骤，例如声纳扫描等。，到此CI工作流中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h1 id="0a76" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">GraalVM本机映像的CI工作流</h1><p id="cf4b" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">这是GraalVM本机映像的CI工作流。由于构建本机映像比在JVM上构建应用程序需要更长的时间，因此我们可以将此工作流配置为手动触发或运行夜间构建。这个工作流和JVM CI工作流的主要区别是maven build使用Buildpacks添加了一个<code class="fe mt mu mv mw b">-Pnative</code>参数来启用<code class="fe mt mu mv mw b">spring-boot-starter-parent</code>的<code class="fe mt mu mv mw b">native</code>概要文件(第57行)，并且它还在这个工作流中安装了GraalVM(第38–44行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="1205" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感兴趣者的作业:我在我的上一篇文章<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-github-actions-reusable-workflow-8604e8cbf258"> <em class="lv">中写过关于GitHub Actions的可重用工作流的博客，深入探究GitHub Actions的可重用工作流</em> </a> <em class="lv">。</em>我鼓励对将这两个工作流转换成可重用工作流感兴趣的读者，并相应地从您的应用程序的CI工作流中调用它们。</p><h1 id="41e8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">本机映像和JVM映像之间的映像大小比较</h1><p id="183d" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">对于我们的<code class="fe mt mu mv mw b">customer-service</code>应用程序，我运行了原生映像CI工作流和JVM CI工作流，两个映像被推送到ECR。本机映像的大小不到JVM映像的一半；Spring Boot 3原生支持的另一个承诺是产生更小的映像足迹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f3a8aa182f7daafc84df9d6eedb6f667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q3VnGFiqOrT-qBIUW1n2YA.png"/></div></div></figure><p id="0eb2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">请注意:</strong></p><p id="d54a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的映像比较只是为了探索本机映像和JVM映像。您决不能在同一个ECR存储库中混合这两个映像。根据您的应用程序，如果它与原生映像支持配合得很好，并且您的团队已经决定将原生映像投入生产，那么请删除您的<code class="fe mt mu mv mw b">ci-jvm.yml</code>中的最后一步<code class="fe mt mu mv mw b">Tag and push image to AWS ECR</code>，这样JVM CI工作流只进行构建和映像扫描，但不会将映像推送到ECR。</p><p id="cbc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果由于某种原因，你的应用遇到了多个问题，主要是处理第三方库与原生支持的兼容性，你和你的团队最终决定你的应用还没有准备好采用原生支持，那么你需要删除你的<code class="fe mt mu mv mw b">ci-native-image.yml</code>中<code class="fe mt mu mv mw b">Tag and push image to AWS ECR</code>的最后一步。您可以定期手动触发本机映像配置项工作流，以查看是否已解决任何与第三方本机支持兼容性相关的问题。</p><h1 id="4ee2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">应用程序启动</h1><p id="2260" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">一旦我们的本机映像构建成功，让我们启动我们的应用程序:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="f7a2" class="nb lx it mw b be nc nd l ne nf">docker run --rm -p 8500:8500 docker.io/library/customer-service:latest</span></pre><p id="8448" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">耶！<code class="fe mt mu mv mw b">customer-service</code> app启动0.256秒！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/114ca42bef6d0c2e5d821f6a21d76f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4D9jb2ZXvVvZjBtxqr3O6Q.png"/></div></div></figure><p id="b1e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们通过创建一个新客户来验证API:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/5254fd17f8ad744223adab0b7c6938c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_DfFVUZAyJhYSRGxRCpwg.png"/></div></div></figure><p id="7ca0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，客户创建POST调用是成功的，因为从数据库中检索到了<code class="fe mt mu mv mw b">customerId</code>，并且在响应中成功返回了<code class="fe mt mu mv mw b">customer</code>对象。因此，我们的应用程序确实如预期的那样运行。</p><h1 id="4159" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">故障排除提示</h1><p id="1b24" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">我不得不承认，构建我们的演示应用程序的本机映像并不是一次完全顺利的经历。我遇到了一些困难，这需要我做一些研究来找到解决方法。我想分享一下我的故障排除经验。</p><p id="0842" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mt mu mv mw b">customer-service</code>的原生映像构建没有问题，但当我尝试启动应用程序时，我遇到了以下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/62bc99d4ddc7b0aa6e812676e178f6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CLN3JK0IoEkKSdA0d_Fccg.png"/></div></div></figure><p id="0982" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我很困惑，因为该文件存在于正确的目录中。为什么GraalVM看不到它？啊！它必须与我们的应用程序的<code class="fe mt mu mv mw b">resource-config.json</code>在一起，因为<code class="fe mt mu mv mw b">db.changelog-master.xml</code>是一个资源文件，它是来自我们自己的应用程序的代码。通过追踪目标文件夹的<code class="fe mt mu mv mw b">classes\META-INF\native-image\com.github.wenqiglantz.service\customerservice\resource-config.json</code>，见下面截图，出入明显！在那个<code class="fe mt mu mv mw b">resource-config.json</code>文件中，它引用的是<code class="fe mt mu mv mw b">db.changelog-master.yaml</code>，而不是它的XML文件，这就是GraalVM找不到XML文件的原因。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/b26b34296936a91195f3a6ce34b13f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lV6rM4PUBQEe9gHxZqGhbQ.png"/></div></div></figure><p id="fdef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为什么会这样？本机映像工具依赖于运行时对应用程序可访问代码的静态分析。然而，该分析并不总是能够预测Java本地接口(JNI)、Java反射、动态代理对象或类路径资源的所有用途。这些动态特性的未检测到的使用必须以<a class="ae lu" href="https://www.graalvm.org/22.2/reference-manual/native-image/metadata/" rel="noopener ugc nofollow" target="_blank">元数据</a>(在代码中预先计算或作为JSON配置文件)的形式提供给<code class="fe mt mu mv mw b">native-image</code>工具。</p><p id="f7d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">怎么修？基本上，我们需要一种方法来用正确的资源条目补充为我们的应用程序自动生成的<code class="fe mt mu mv mw b">resource-config.json</code>，特别是要包括我们的Liquibase配置文件<code class="fe mt mu mv mw b">db.changelog-master.xml</code>和<code class="fe mt mu mv mw b">db.changelog-1.0.xml</code>。让我们探索两种方法:</p><ul class=""><li id="03fa" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt np nm nn no bi translated">追踪代理</li><li id="0cba" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">RuntimeHintsRegistrar</li></ul><h1 id="aaec" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">追踪代理</h1><p id="509d" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">GraalVM提供了一个跟踪代理来轻松收集元数据和准备配置文件。代理跟踪应用程序在常规Java虚拟机上执行期间动态特性的所有使用情况。对于我们的客户服务应用程序，我使用下面的命令在项目根目录下运行跟踪代理:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="5e80" class="nb lx it mw b be nc nd l ne nf">java -Dspring.aot.enabled=true -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/native-image -jar .\target\customerservice-0.0.1-SNAPSHOT.jar</span></pre><p id="4c28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="lv">注意</em> </strong> <em class="lv"> : </em> <code class="fe mt mu mv mw b"><em class="lv">-agentlib</em></code> <em class="lv">前必须指定一个</em> <code class="fe mt mu mv mw b"><em class="lv">-jar</em></code> <em class="lv">选项或一个类名或任何应用参数作为</em> <code class="fe mt mu mv mw b"><em class="lv">java</em></code> <em class="lv">命令的一部分。</em></p><p id="e0d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行时，代理查找<code class="fe mt mu mv mw b">native-image</code>工具需要额外信息的类、方法、字段和资源。当应用程序完成并且JVM退出时，代理将元数据写入指定输出目录<code class="fe mt mu mv mw b">src/main/resources/META-INF/native-image</code>中的JSON文件。</p><p id="c4ce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">可能需要多次运行应用程序(使用不同的执行路径),以提高动态特性的覆盖率。<code class="fe mt mu mv mw b">config-merge-dir</code>选项添加到现有的一组配置文件中，如下所示:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="3889" class="nb lx it mw b be nc nd l ne nf">java -Dspring.aot.enabled=true -agentlib:native-image-agent=config-merge-dir=src/main/resources/META-INF/native-image -jar .\target\customerservice-0.0.1-SNAPSHOT.jar</span></pre><p id="6fa9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在该目录(或其任何子目录)中搜索名为<code class="fe mt mu mv mw b">jni-config.json</code>、<code class="fe mt mu mv mw b">reflect-config.json</code>、<code class="fe mt mu mv mw b">proxy-config.json</code>、<code class="fe mt mu mv mw b">resource-config.json</code>、<code class="fe mt mu mv mw b">predefined-classes-config.json</code>、<code class="fe mt mu mv mw b">serialization-config.json</code>的文件，这些文件将自动包含在构建过程中。</p><p id="d43e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看运行跟踪代理后会发现什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/c0a1c6665ad21adcc98d56f2c8a4651b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IbjnnIN5WGr94uvKAC2_4Q.png"/></div></div></figure><p id="c5df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是的，跟踪代理确实生成了JSON文件列表，如上面的截图所示，在<code class="fe mt mu mv mw b">resource-config.json</code>中，我们可以看到我们的两个Liquibase配置文件确实已经添加，这意味着它们将包含在我们的本机映像构建中！这个办法管用！现在让我们看看使用<code class="fe mt mu mv mw b">RuntimeHintsRegistrar</code>的另一种方法。</p><h1 id="3bae" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">RuntimeHintsRegistrar</h1><p id="2514" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">由于在这种特殊情况下我们需要为资源提供自己的提示，我们可以使用Spring Boot 3.0附带的<code class="fe mt mu mv mw b">RuntimeHintsRegistrar</code> API。我们需要做的就是创建一个实现<code class="fe mt mu mv mw b">RuntimeHintsRegistrar</code>接口的类，然后对提供的<code class="fe mt mu mv mw b">RuntimeHints</code>实例进行适当的调用。然后我们可以在任何一个<code class="fe mt mu mv mw b">@Configuration</code>类上使用<code class="fe mt mu mv mw b">@ImportRuntimeHints</code>来激活这些提示。请看下面我在<code class="fe mt mu mv mw b">CustomerController</code>类中的实现。</p><ul class=""><li id="09da" class="ng nh it la b lb lc le lf lh ni ll nj lp nk lt np nm nn no bi translated">第3行:通过<code class="fe mt mu mv mw b">@ImportRuntimeHints</code>激活提示。</li><li id="54b9" class="ng nh it la b lb nq le nr lh ns ll nt lp nu lt np nm nn no bi translated">第29–41行:创建一个名为<code class="fe mt mu mv mw b">CustomerControllerRuntimeHints </code>的类来实现<code class="fe mt mu mv mw b">RuntimeHintsRegistrar</code>。特别要注意第38行和第39行，这两个Liquibase配置文件在这里被“暗示”</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3236" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，让我们通过在本地运行下面的命令再次构建我们的本机映像，然后检查我们的AOT编译器在目标目录下生成的文件。见下图。是的，有效！我们的Liquibase XML文件现在成功地包含在<code class="fe mt mu mv mw b">resource-config.json</code>中，还有默认的YAML文件，用蓝色突出显示。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="a499" class="nb lx it mw b be nc nd l ne nf">mvn clean -Pnative spring-boot:build-image -Dmaven.test.skip</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/fd67387153ef5639b1f83a9dceb35bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_263vXCqrNyClGv3fagj6g.png"/></div></div></figure><h1 id="153b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Spring Boot协议3的局限性</h1><p id="3d8c" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">尽管Spring Boot 3围绕其原生支持有许多优势，但Spring Boot 3周围的生态系统尚未跟上。Spring团队对Spring Boot 3的局限性相当开放，正如这里记录的<a class="ae lu" href="https://docs.spring.io/spring-boot/docs/3.0.0-RC1/reference/html/native-image.html#native-image.advanced.known-limitations" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="cfd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些流行的测试框架，比如Mockito和WireMock，还没有本地支持。对于那些有兴趣为更新Spring Boot 3生态系统做出贡献的人，GraalVM创建了<a class="ae lu" href="https://github.com/oracle/graalvm-reachability-metadata" rel="noopener ugc nofollow" target="_blank">可达性元数据存储库</a>，以鼓励开源社区为这一重要工作做出贡献。</p><h1 id="e162" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">可达性元数据存储库</h1><p id="6611" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">当您使用<a class="ae lu" href="https://www.graalvm.org/22.1/reference-manual/native-image/" rel="noopener ugc nofollow" target="_blank"> GraalVM本机映像</a>构建本机可执行文件时，它只包括从您的应用程序入口点可到达的元素、它的依赖库以及通过静态分析发现的JDK类。然而，由于Java的动态特性，包括反射、资源访问、动态代理和序列化，某些元素(如类、方法或字段)的可达性可能是不可发现的。</p><p id="34ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果某个元素不可访问，则它不会包含在生成的可执行文件中，这可能会导致运行时失败。为了包含可达性不可发现的元素，本机映像构建器需要外部提供的<a class="ae lu" href="https://www.graalvm.org/reference-manual/native-image/metadata/" rel="noopener ugc nofollow" target="_blank">可达性元数据</a>。</p><p id="f817" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个存储库为不支持GraalVM本机映像的库提供了<a class="ae lu" href="https://www.graalvm.org/22.2/reference-manual/native-image/ReachabilityMetadata/" rel="noopener ugc nofollow" target="_blank">可达性元数据</a>。</p><p id="2ec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，为本机映像构建启用可访问性元数据。对于本机映像中包含的每个库，插件<code class="fe mt mu mv mw b">native-maven-plugin</code>将自动在与插件一起发布的存储库中搜索GraalVM可达性元数据。</p><h1 id="0d95" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="9d70" class="pw-post-body-paragraph ky kz it la b lb mo ju ld le mp jx lg lh mq lj lk ll mr ln lo lp ms lr ls lt im bi translated">随着Spring Boot 3 GA的发布，人们对它的GraalVM原生映像支持有了更多的期待。在这个故事中，我们深入探讨了将Spring Boot 2应用程序升级到Spring Boot 3的步骤，激活其本机映像支持，使用GitHub Actions工作流构建本机映像CI管道，并探索故障排除技巧，包括如何使用跟踪代理和<code class="fe mt mu mv mw b">RuntimeHintsRegistrar</code>。Spring Boot 3原生图像支持有着巨大的潜力，我们还讨论了围绕其生态系统的限制，这一点还没有跟上，并呼吁Spring开源社区的贡献和支持。我希望这篇文章对你有所帮助。</p><p id="53d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随意在<a class="ae lu" href="https://github.com/wenqiglantz/customerservice-spring-boot-3" rel="noopener ugc nofollow" target="_blank">我的GitHub库</a>中查看我的演示应用<code class="fe mt mu mv mw b">customer-service</code>的源代码。</p><p id="dc87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编码快乐！</p><p id="93fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">又及:非常感谢Spring Boot项目负责人<a class="ae lu" href="https://twitter.com/snicoll" rel="noopener ugc nofollow" target="_blank">斯蒂芬·尼科尔</a>，回顾了这个故事，并提供了宝贵的意见和指导！在Spring Boot GA发布的这个大日子里，他的盘子里肯定有上百万件事情，然而他还是花时间来阅读这篇文章，并提供更正和指导。我是如此的谦卑和荣幸！</p><h1 id="4b3e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">参考</h1><div class="oe of gp gr og oh"><a href="https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/#how-to-contribute" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">Spring本地文档</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">与Java虚拟机相比，本机映像可以为多种类型的虚拟机提供更便宜、更可持续的托管服务</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">docs.spring.io</p></div></div><div class="oq l"><div class="or l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://www.graalvm.org/22.2/reference-manual/native-image/metadata/AutomaticMetadataCollection/#tracing-agent" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">使用跟踪代理收集元数据</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">本机映像工具依赖于运行时对应用程序可访问代码的静态分析。然而……</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">www.graalvm.org</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://github.com/oracle/graalvm-reachability-metadata" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">GitHub-Oracle/graalvm-可达性-元数据:包含社区驱动的存储库…</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">当您使用GraalVM本机映像来构建本机可执行文件时，它只包含从您的…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov ks oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://docs.spring.io/spring-boot/docs/3.0.0-RC1/reference/html/native-image.html#native-image.developing-your-first-application" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">GraalVM本机映像支持</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">GraalVM本机映像提供了一种部署和运行Java应用程序的新方法。与Java虚拟机相比…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">docs.spring.io</p></div></div></div></a></div></div></div>    
</body>
</html>