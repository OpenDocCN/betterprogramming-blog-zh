<html>
<head>
<title>SwiftUI and How NOT to Initialize Bindable Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI和如何不初始化可绑定对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-101-how-not-to-initialize-bindable-objects-6e539d1b5344?source=collection_archive---------0-----------------------#2019-06-10">https://betterprogramming.pub/swiftui-101-how-not-to-initialize-bindable-objects-6e539d1b5344?source=collection_archive---------0-----------------------#2019-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/48455e8b737c7e5e0c03741e2fb6f459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXGNBXDq6nEhqvnKy2eecg.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="fe24" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">或者只是在init()不是你的朋友的时候</h2></div><p id="19b8" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">如果你和我一样，在苹果全球开发者大会之后的几天里，通常会有很多很多<em class="lp">很多</em>样本和演示程序被创建，这些程序是为了理解和测试苹果几天前发布的大量概念、代码和库而编写的。</p><p id="fa22" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">事实上，我有时觉得自己有点像一条试图吞下大象的蟒蛇。</p><p id="9357" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不管怎样，除了深呼吸和潜水，你还能做什么？</p><h1 id="23b7" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">意想不到的</h1><p id="d710" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">所以你写代码，写更多的代码，偶尔停下来，用头撞最近的平面。你删除一切，重新开始，写更多的代码。</p><p id="f99a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后你撞上了一个意想不到的行为。你停下来想，“是我吗…还是我刚刚发现了一个bug？”</p><p id="dda1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">毕竟，我们正在测试beta代码，经常会发现大量的bug。没有人可以幸免，即使是苹果。</p><p id="97fc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，在这种情况下，我意识到我发现的不是一个bug——但它很容易变成一个bug。(后来我确定<em class="lp">是</em>的一个错误，而且比我最初认为的更糟糕，因为真正的问题在于苹果对<code class="fe mn mo mp mq b">NavigationButton</code>的实现。)</p><p id="73a2" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">不管怎样，这仍然是一个很好的例子，说明了如何正确地使用<a class="ae mr" href="https://developer.apple.com/xcode/swiftui/" rel="noopener ugc nofollow" target="_blank"> SwiftUI </a>的BindableObject作为视图模型，所以让我们开始吧。</p><p id="50f4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">注意:从Xcode Beta 5开始，BindableObject被ObservableObject、ObservedObject和Published所取代。</strong></p><p id="39b5" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">虽然“对象的数据已更改”机制已经更新，但下面描述的过早初始化问题仍然存在。</p><h1 id="de6a" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">可绑定对象</h1><p id="04a3" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">让我们从<code class="fe mn mo mp mq b">BindableObject</code>开始，根据苹果的文档，它是“作为视图模型的对象”。(从字面上看，这就是目前所有的文档。)</p><p id="c77b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">长话短说，苹果已经认识到了巨大的视图控制器问题，并且正在鼓励(我所说的鼓励很大程度上是指<em class="lp">要求</em>)开发者使用模型和视图模型。</p><p id="33a1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这里有一个实现，可以归结为这个讨论。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9d53" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的<code class="fe mn mo mp mq b">InitListViewModel</code>是一只<code class="fe mn mo mp mq b">BindableObject</code>。可绑定对象<em class="lp">需要</em>有一个<code class="fe mn mo mp mq b">didChange</code>变量，这是一个组合的<em class="lp">主题</em>。这通常是一个<code class="fe mn mo mp mq b">PassthroughSubject</code>，稍后我们会解释为什么会这样。</p><p id="261b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">归结起来，<code class="fe mn mo mp mq b">didChange</code> publisher只是为模型指定一种方式来通知视图它的数据已经改变。当状态发生变化时，视图会自动重新生成并重新显示任何受更新数据影响的视图。</p><p id="0242" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在本例中，<code class="fe mn mo mp mq b">InitListViewModel</code>数据是一个简单的字符串数组。</p><p id="3787" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当ViewModel初始化时，它调用我们的<code class="fe mn mo mp mq b">load</code>方法来获取我们的数据。通常这是一个API调用，但是为了这个演示的目的，我们将使用一个<code class="fe mn mo mp mq b">DispatchQueue.main.asyncAfter</code>块来模拟一个网络API调用。</p><p id="da73" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">注意，在程序块的末尾，我们做了一个<code class="fe mn mo mp mq b">self.didChange.send(self)</code> <em class="lp">，</em>，这是我们的神奇通知触发发生的时候，我们的视图被告知要更新。</p><h1 id="ca6a" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">景色</h1><p id="40b2" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">我们的观点非常简单。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a134" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的<code class="fe mn mo mp mq b">InitListView</code>包含一个单独的<code class="fe mn mo mp mq b"><em class="lp">@ObjectBinding</em></code> <em class="lp"> </em>变量，该变量包含我们的<code class="fe mn mo mp mq b">BindableObject</code> ViewModel。该对象在初始化时被传递给视图。</p><p id="e9ce" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的视图主体返回一个非常简单的<code class="fe mn mo mp mq b">List</code>对象，它观察我们的<code class="fe mn mo mp mq b">viewModel</code>上的<code class="fe mn mo mp mq b">list</code>变量。我们的列表是使用初始的空数组构建的，然后，两秒钟后，当我们的<code class="fe mn mo mp mq b">didChange</code>通知被发送时，列表被自动重建。</p><p id="bac4" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">以根用户<code class="fe mn mo mp mq b">InitListView</code>运行这段代码，您会看到一个空列表，几秒钟后会看到一个简短的名字列表。</p><h1 id="49a7" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">现在是虫子</h1><p id="e9a4" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">为了更好地查看我们的bug，我们需要能够来回切换到我们的<code class="fe mn mo mp mq b">InitListView</code>，所以让我们创建一个新的屏幕来启动我们的旧屏幕:</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9659" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们有一个启动我们的<code class="fe mn mo mp mq b">InitListView</code>的<code class="fe mn mo mp mq b">NavigationButton</code>，包含在一个<code class="fe mn mo mp mq b">NavigationView</code>中。请注意，ViewModel是作为参数创建并传递给视图的。</p><p id="4e3e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在将我们项目的根视图切换到<code class="fe mn mo mp mq b">InitMenuView</code>并重新运行它。快速点击<code class="fe mn mo mp mq b">List Sample</code>按钮，您应该会看到之前看到的内容。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b4146446c51aef07d1b07e8b44bd3083.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*BaD0wt9n4GrJBlTSYuuM9A.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">首次运行更新后的屏幕。</p></figure><p id="b167" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">一个空列表，然后显示我们的老朋友迈克、杰克和吉尔的更新。</p><p id="6189" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，点击后退按钮，然后再次点击<code class="fe mn mo mp mq b">List Sample</code>按钮。</p><figure class="ms mt mu mv gt iv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/7f7f6e6da2f68fde9424e93f12845e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*iv2wbvwhwwZ4pMLteREgRQ.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">屏幕后再次点击列表样本按钮。</p></figure><p id="1b37" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们的数据显示<strong class="kv jf">马上</strong>。</p><p id="908c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">刚刚发生了什么？</p><h1 id="2a6c" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">WTF？(搞什么鬼)</h1><p id="e8ce" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">当我第一次看到这个的时候，我的第一反应是我的<code class="fe mn mo mp mq b">InitListViewModel</code>由于某种原因没有被发布，我有一个bug。</p><p id="f40c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我花了一些时间试图弄清楚如何发布视图模型。没有欢乐。</p><p id="6104" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我花了更多的时间试图找出如何重新创建和/或重新分配我的视图模型到我的视图的对象绑定参数。没有欢乐。</p><p id="064c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然后我注意到了别的东西。重新运行应用程序…然后在第一次点击按钮之前等待几秒钟。这样做，你不会看到一个空屏幕，而是一个充满数据的屏幕。</p><p id="3c5c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">就在那时，天开始亮了。</p><h1 id="4616" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">疯狂背后的方法</h1><p id="2e27" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">如果你停下来想想，这是怎么回事就很清楚了。SwiftUI中几乎每个视图都是一个结构。结构<em class="lp">在创建时必须</em>初始化。</p><p id="1899" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">当我们初始化<code class="fe mn mo mp mq b">InitListView</code> <em class="lp"> </em>时，我们的<code class="fe mn mo mp mq b">InitListViewModel</code>也被创建并作为参数传递给视图。</p><p id="1c84" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><strong class="kv jf">即其</strong> <code class="fe mn mo mp mq b"><strong class="kv jf">init</strong></code> <strong class="kv jf">方法在那个时间点被称为</strong>。</p><p id="40a1" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这又调用了我们的<code class="fe mn mo mp mq b">load</code>方法。我们的“API”调用在那时进行，并在两秒钟后返回。</p><p id="833a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">但是这什么时候发生呢？</p><p id="069a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">在我们<code class="fe mn mo mp mq b">InitMenuView</code><em class="lp"/><code class="fe mn mo mp mq b">NavigationButton</code><em class="lp"/>的时候我们指定了我们的<code class="fe mn mo mp mq b">destination</code>。</p><pre class="ms mt mu mv gt nd mq ne nf aw ng bi"><span id="008f" class="nh lr je mq b gy ni nj l nk nl">NavigationButton(destination: InitListView(model: InitListViewModel()) )</span></pre><p id="2eb3" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated"><code class="fe mn mo mp mq b">InitListViewModel</code>在那个时间点被初始化。</p><h1 id="09bb" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">结果</h1><p id="1a86" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">这有相当大的影响。制作一个有十几个导航按钮的主屏幕，有十几个目的地，<strong class="kv jf">，每一个都将在启动时初始化。</strong></p><p id="6e3c" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">创建一个包含100个列表项的可公开列表视图，滚动它，<strong class="kv jf">每个目的地都会被初始化。</strong></p><p id="977e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">幸运的是，有一个解决方案，虽然在这个时候它只是一个局部的。</p><h1 id="1e1a" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">生命周期管理</h1><p id="3af7" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">SwiftUI提供了一组在视图生命周期中调用的视图修改器，其中之一就是<code class="fe mn mo mp mq b">onAppear</code>。</p><p id="422b" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">让我们重构我们的代码。我们将保持ViewModel中的所有内容不变，但是删除了<code class="fe mn mo mp mq b">init</code>函数。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2100" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我们将添加一个<code class="fe mn mo mp mq b">onAppear</code>修饰符到我们的主列表中，用一个闭包直接调用我们的视图模型的<code class="fe mn mo mp mq b">load</code>函数。</p><figure class="ms mt mu mv gt iv"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="11a0" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">这类似于我们在UIKit中管理事件的方式，我们经常从<code class="fe mn mo mp mq b">viewDidLoad</code>调用或配置我们的视图模型。</p><p id="bb7d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">运行新代码，等待几秒钟，然后点击<code class="fe mn mo mp mq b">List Sample</code>。您将看到我们预期的空白屏幕，然后是我们的数据屏幕。成功！</p><p id="575d" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">对吗？</p><h1 id="4a06" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">另一个问题</h1><p id="8615" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">嗯，我们解决了第一个问题，但现在我们有了另一个问题。</p><p id="8a38" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">点击后退按钮，然后再次点击<code class="fe mn mo mp mq b">List Sample</code>，你会看到我们加载的数据…现在我们有了一个更隐蔽的问题。</p><p id="29fb" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">我承认，这个问题还没有找到解决方案，因为我还没有找到“重置”视图模型的好方法。<code class="fe mn mo mp mq b">NavigationButton</code>目的地只是坐在那里，有一个初始化的视图，它显然计划永远保留。</p><p id="4a73" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">是的，您可以编写一些代码来清空数组，但是这样做没有任何作用，因为它只是假设视图状态没有改变。试图清空数组并在视图出现之前调用<code class="fe mn mo mp mq b">self.didChange.send(self)</code> <em class="lp">会导致应用程序崩溃。(又一个bug？)</em></p><p id="0d7e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">太悲伤了。</p><h1 id="311f" class="lq lr je bd ls lt lu lv lw lx ly lz ma kk mb kl mc kn md ko me kq mf kr mg mh bi translated">完成处理程序</h1><p id="00a0" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">我本可以把第一个“bug”记为根本不是bug。这就是Swift的工作方式。</p><p id="3e27" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">然而，第二个问题让我相信这毕竟是一个bug。</p><h2 id="8b3c" class="nh lr je bd ls nm nn dn lw no np dp ma lc nq nr mc lg ns nt me lk nu nv mg nw bi translated">怎么修？</h2><p id="0b16" class="pw-post-body-paragraph kt ku je kv b kw mi kf ky kz mj ki lb lc mk le lf lg ml li lj lk mm lm ln lo im bi translated">一个简单的解决方案(对苹果来说)是改变导航按钮之类的东西的性质。每个问题都源于视图结构过早初始化的事实。</p><p id="ac10" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">因此，如果我正在编写这个API，我将引入一个<code class="fe mn mo mp mq b">NavigationButton</code>的变体，它将工厂闭包作为它的目的地参数，并且该闭包将在每次被调用时返回一个新的视图和一个新的视图模型。</p><p id="887a" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">问题解决了。每次你按下按钮，你会得到一个新的，工厂新鲜的视图实例。更重要的是，你不会过早地初始化几十、几百或几千个愚蠢的东西。(你能想象这在一个列表里吗？)</p><p id="ab96" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">现在，<em class="lp">可能</em>有几次你实际上<em class="lp">想要</em>保持给定屏幕的状态，为此你可以保留现有的方法签名。毕竟，这就是选项卡视图能够维护每个单独选项卡视图的状态的方式。</p><p id="9c03" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">顺便说一下，初始化问题是为什么我们通常想在代码中使用<code class="fe mn mo mp mq b">PassthroughSubject</code>。在我们准备好之前，我们不想要任何视图更新。</p><p id="6675" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">无论如何，<strong class="kv jf">这里的底线是，您需要<em class="lp">非常</em>清楚您将什么代码放入了SwiftUI视图</strong> <strong class="kv jf">和视图模型</strong>的初始化函数中，因为这些代码可以而且将会被调用，而且经常是在您最不期望的时候。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h1 id="29e2" class="lq lr je bd ls lt oe lv lw lx of lz ma kk og kl mc kn oh ko me kq oi kr mg mh bi translated">实验数字电视系统</h1><ul class=""><li id="1896" class="oj ok je kv b kw mi kz mj lc ol lg om lk on lo oo op oq or bi translated">评论中指出，作为一条规则，视图构造函数不应该有副作用。这并没有修复我们的<code class="fe mn mo mp mq b">NavigationButton</code>错误，但是指出了一个事实，我们的<code class="fe mn mo mp mq b">onAppear</code>解决方案看起来是正确的。</li><li id="8ee7" class="oj ok je kv b kw os kz ot lc ou lg ov lk ow lo oo op oq or bi translated">早期版本在视图内部使用了一个<code class="fe mn mo mp mq b">@State</code> <em class="lp"> </em>变量，而不是一个<code class="fe mn mo mp mq b">@ObjectBinding</code>变量，但这只是将初始化从视图内部推到视图外部，结果基本相同。</li><li id="b788" class="oj ok je kv b kw os kz ot lc ou lg ov lk ow lo oo op oq or bi translated">Xcode 11 Beta 2刚刚退出，也出现了同样的问题。</li><li id="ee4a" class="oj ok je kv b kw os kz ot lc ou lg ov lk ow lo oo op oq or bi translated">从Xcode 11 Beta 3开始，<em class="lp"> NavigationButton </em>已被弃用，并被替换为<em class="lp"> NavigationLink </em>。<em class="lp"> NavigationLink </em>看起来与<em class="lp"> NavigationButton </em>工作方式相同，具有相同的基本行为(包括视图初始化问题)。</li></ul><p id="ad7f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo im bi translated">下次见。</p></div></div>    
</body>
</html>