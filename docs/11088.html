<html>
<head>
<title>Callbacks vs. Promises vs. Async Await: A Step by Step Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回调vs .承诺vs .异步Await:逐步指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/callbacks-vs-promises-vs-async-await-a-step-by-step-guide-f93d13447604?source=collection_archive---------1-----------------------#2022-02-17">https://betterprogramming.pub/callbacks-vs-promises-vs-async-await-a-step-by-step-guide-f93d13447604?source=collection_archive---------1-----------------------#2022-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ae9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">引擎盖下也有点。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68aa3c76c2039b7f70da4333486fcdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uOs34laWWv_5T1uy5W9fGA.jpeg"/></div></div></figure><p id="b85e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我发现这令人困惑，我想你可能也是，比如回调vs承诺vs异步，用什么呢？这到底是什么？每一个是如何工作的？它是如何在引擎盖下工作的？这就是我想在这个帖子里一劳永逸地解释的。</p><h1 id="3cf4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">复试</h1><p id="15c4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如果我们应该100%正确地知道回调是什么，那么回调就是我们传递给另一个接受另一个函数作为参数的函数。并且我们传入的函数可以在将来的任何时候被我们传入的函数调用。然后它被称为<code class="fe mn mo mp mq b">higher order function</code>，接受一个函数作为参数。</p><p id="f39b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个回调:</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="46bb" class="nc lr it mq b gy nd ne l nf ng">function someFunctionAcceptingCallback(number, callback){<br/>return callback(number + 10)<br/>}<br/>function divide(answer) {<br/>return answer / 2</span><span id="cbde" class="nc lr it mq b gy nh ne l nf ng">}</span><span id="6bc4" class="nc lr it mq b gy nh ne l nf ng">someFunctionAcceptingCallback(5, divide) // 7.5 if we console.log it</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="7778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个很好的例子是javascript中的<code class="fe mn mo mp mq b">addEventListener</code>。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt my mq mz na aw nb bi"><span id="9c3d" class="nc lr it mq b gy nd ne l nf ng">document.getElementById('addUser').addEventListener('click', function() {// Do something})</span></pre></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="6d83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以这里发生的是，<code class="fe mn mo mp mq b">addEventListener</code>允许我们等待执行，直到稍后的某个特定时刻，在这种情况下，当点击<code class="fe mn mo mp mq b">addUser</code>按钮时，只有这时我们的<code class="fe mn mo mp mq b">callback</code>函数才会被执行。这是一个异步事件。</p><p id="6ab4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是它是如何工作的呢？..Javascript是单线程的，这意味着它不能同时执行多个代码，javascript有一个<code class="fe mn mo mp mq b">call stack</code>，它从上到下一次运行一个任务。</p><p id="64c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以当我们添加我们的<code class="fe mn mo mp mq b">addEventListener</code>时，我们并不真正调用javascript本地方法，我们调用WEB API中的方法。我们可以把WEB API想象成另一个线程。</p><p id="529f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以WEB API <code class="fe mn mo mp mq b">addEventListener</code>是一个DOM事件，它等待我们的按钮被点击，然后当它被点击时，它将我们传递的<code class="fe mn mo mp mq b">callback</code>函数作为参数，并将其推送到一个叫做<code class="fe mn mo mp mq b">task queue/callback queue</code>的东西，然后一个叫做<code class="fe mn mo mp mq b">event loop</code>的东西拾取回调函数并将其推送到<code class="fe mn mo mp mq b">call stack</code>并执行，但只有当回调函数是<code class="fe mn mo mp mq b">task queue/callback queue</code>中的第一个函数时。我做了一个直观的例子来说明它是如何工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/5e2615997435815f142905de6d3219cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYDHBgU4sEBalipCs29ITA.png"/></div></div></figure><p id="57cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用回调函数的一个完美例子是什么？..你猜对了，网络请求。</p><p id="2136" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们想要做的是发出一个网络请求，在我们得到服务器的响应后，我们的回调函数被调用。</p><p id="2980" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是由于javascript是单线程的，所以在ec6中引入promises之前，无法在javascript中实现这一点。</p><p id="75b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们在不使用任何WEB API的情况下调用网络请求，会发生什么，我们的代码会被阻塞，在我们的网络请求完成之前,<code class="fe mn mo mp mq b">call stack</code>不会执行任何代码。这被称为代码阻塞，如果我们的代码是同步的并且需要很长时间来执行，那么我们的网页将被冻结，没有javascript代码将被执行，因为我们直接在调用堆栈上调用网络请求，它阻塞了其余的javascript代码的执行。</p><p id="775f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们解决这个问题的方法是利用另一个叫做<code class="fe mn mo mp mq b">XMLHttpRequest</code>的WEB API。</p><p id="28fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">XMLHttpRequest</code>是一个WEB API，我们传入我们的回调函数，一旦<code class="fe mn mo mp mq b">XMLHttpRequest</code>完成，它就把它推给<code class="fe mn mo mp mq b">task queue/callback queue</code>,<code class="fe mn mo mp mq b">event loop</code>会拾取它，并把它推给<code class="fe mn mo mp mq b">call stack</code>让它执行我们的回调函数。</p><p id="182b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="d23f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没事吧。我们可以通过使用WEB API使网络请求异步，并传递回调函数，一旦我们从网络请求得到响应，它就应该执行这些函数。</p><p id="0e74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nl">军规</em></p><h2 id="e109" class="nc lr it bd ls nm nn dn lw no np dp ma ld nq nr mc lh ns nt me ll nu nv mg nw bi translated">回调地狱</h2><p id="f9dc" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">如果我们想按顺序发出网络请求，那么第一个请求，然后第二个请求，依此类推，就会变得非常混乱，让我来演示一下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c51b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它很难阅读，因为大脑习惯于按顺序思考，它容易出错，而且可能变得更糟，我们还需要检查每个请求中的错误，所以最终的代码会更长，可读性更差，因此更容易出错，更难维护。</p><p id="b707" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是怎么解决的？有一些简单的方法可以让它变得更好，也有很多库可以用来逃离回调地狱，让代码变得更好。</p><p id="89a6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们来谈谈承诺，它们能做什么以及如何工作。</p><h1 id="caf9" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">承诺</h1><p id="2e90" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">那什么是承诺呢？</p><p id="2762" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在promises被引入原生javascript之前，我们需要使用其他方法和库来处理异步编程，根本没有办法使用普通的原生javascript。</p><p id="4395" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当承诺被引入时，对javascript开发人员来说这是一件大事，现在你可以轻松地编写异步网络请求，避免回调地狱。</p><p id="df54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之前我们讨论过<code class="fe mn mo mp mq b">XMLHttpRequest</code>是一个WEB API，因为javascript是单线程的，为了避免代码阻塞，我们必须将我们的异步函数传递给<code class="fe mn mo mp mq b">call stack</code>以外的其他东西。</p><p id="65ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是承诺不使用任何<code class="fe mn mo mp mq b">callback queue</code>，那么如果是这样的话，承诺用什么来进行异步呢？</p><h2 id="4abd" class="nc lr it bd ls nm nn dn lw no np dp ma ld nq nr mc lh ns nt me ll nu nv mg nw bi translated">微队列</h2><p id="af91" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这是在ec6中引入的，基本上，它就像<code class="fe mn mo mp mq b">micro queue</code>一样，但对于承诺，它有一点不同。<code class="fe mn mo mp mq b">micro queue</code>的优先级高于<code class="fe mn mo mp mq b">callback queue</code>，因此，例如，如果我们运行以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="832f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，即使我们的<code class="fe mn mo mp mq b">setTimeout</code>将在0秒后直接运行回调，并且承诺也设置为这样做，这是即时的，承诺将首先运行其回调，因为它使用了<code class="fe mn mo mp mq b">micro queue</code>，并且其优先级高于<code class="fe mn mo mp mq b">setTimout</code> WEB API方法正在使用的<code class="fe mn mo mp mq b">callback queue</code>。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="6dfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们深入研究一下承诺，承诺有3种状态，<code class="fe mn mo mp mq b">pending</code> <code class="fe mn mo mp mq b">fulfilled</code> <code class="fe mn mo mp mq b">rejected.</code></p><p id="9e03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">pending</code>表示承诺尚未被解决或拒绝，在API请求的上下文中，当我们发出请求而服务器没有发回任何响应时，承诺将处于待定状态。</p><p id="b553" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">fulfilled</code>表示承诺已经解决，在API请求的上下文中，当我们得到成功的响应时，承诺将会解决。</p><p id="9f29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">rejected</code>表示我们的承诺已被拒绝，在API请求的上下文中，当我们得到404响应时，承诺将被拒绝，我们可以<code class="fe mn mo mp mq b">catch</code>错误。</p><p id="2d9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们可以创建一个超时为3秒的新承诺，3秒过后，我们可以解析该承诺。这意味着我们可以在用纯本地JavaScript完成一些事情之后再做一些事情，而不需要使用异步执行的库。这适用于任何执行，我们不知道什么时候会得到响应。</p><p id="79a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在承诺被解决后，我们可以做<code class="fe mn mo mp mq b">.then()</code>并且我们在<code class="fe mn mo mp mq b">.then()</code>中拥有的任何东西都只会在承诺被解决时被执行。为了演示这一点，让我们做一个承诺，该承诺在3秒钟后被解析，并向resolve传递一个字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6b92" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以在承诺中包含一个<code class="fe mn mo mp mq b">fetch</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="6edf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">Fetch</code>也是基于承诺的，所以当我们在<code class="fe mn mo mp mq b">fetch</code>上调用<code class="fe mn mo mp mq b">.then()</code>时，我们真正做的是等待，直到服务器解析承诺/返回响应。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="e667" class="lq lr it bd ls lt nx lv lw lx ny lz ma jz nz ka mc kc oa kd me kf ob kg mg mh bi translated">链接</h1><p id="5472" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">除了回调地狱，我们可以用不同的方式链接承诺，例如，如果我们想在第一个请求解决后再提出另一个请求，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="c19b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里我取了一个todo，然后我们将响应转换为JSON，然后我们解析它，然后我们对<code class="fe mn mo mp mq b">myPromise</code>执行<code class="fe mn mo mp mq b">.then()</code>，这将是承诺的解析值。然后我们用我们的JSON数据调用一个函数<code class="fe mn mo mp mq b">doSomething()</code>，然后我们记录我们完成了。</p><h2 id="756a" class="nc lr it bd ls nm nn dn lw no np dp ma ld nq nr mc lh ns nt me ll nu nv mg nw bi translated">承诺。所有</h2><p id="70fa" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">承诺有一个叫做<code class="fe mn mo mp mq b">Promise.all</code>的东西，它允许我们等待任意数量的承诺被解析，然后执行一个代码块。这可能非常非常有用，例如，如果我们需要调用一组请求并等待所有请求完成，那么我们可以用几行代码来完成，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="1454" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">异步等待</h1><p id="5fc9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">所以基本上，如果我们可以编写看起来连续但实际上完全基于承诺的代码会怎么样呢？正如我们看到的承诺，在它解决后，我们需要打电话给<code class="fe mn mo mp mq b">.then()</code>，它并不像我们希望的那样是连续的。</p><p id="3dab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是async-await的意义所在。</p><p id="44c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Async await是一种编写异步代码的新方法，基本上是为了简化我们如何编写链式承诺而创建的。</p><p id="3d52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Async await是非阻塞的，就像我们期望的那样，因为它是异步的，每个async-await都返回一个带有其已解决状态的承诺。</p><p id="7276" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于承诺链，我们是这样做的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="939a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编写同步异步代码的最佳方式如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="bac1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是async-await背后的思想。</p><p id="ce3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以编写async-await的正确方法是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="66ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不需要做<code class="fe mn mo mp mq b">fetchData().then(resolvedData)...</code>，我们只需要做<code class="fe mn mo mp mq b">const data = await fetchData()</code>，而<code class="fe mn mo mp mq b">data</code>将保存解析的数据，直到<code class="fe mn mo mp mq b">fetchData()</code>解析了它的承诺，下一行才会执行。</p><p id="2196" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要记住的一点是，当我们有一个异步函数时，这基本上是一个承诺，事实上，整个函数就是一个承诺。我们做的和异步函数解析承诺时一样，所以我们能做的是<code class="fe mn mo mp mq b">asyncFunction.then()</code>在函数解析了它的承诺后执行代码，这发生在我们所有的<code class="fe mn mo mp mq b">awaits</code>都解析了并且我们从函数返回之后。</p><p id="e4c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在我们的<code class="fe mn mo mp mq b">asyncFunc()</code>中会发生的是，首先它会发出<code class="fe mn mo mp mq b">fetchData()</code>请求，然后等待，直到服务器解析出承诺。然后当它解析时，它将调用<code class="fe mn mo mp mq b">fetchUserData()</code>请求，并等待直到承诺从服务器解析。然后，它才会更新<code class="fe mn mo mp mq b">userState</code>。</p><p id="b239" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想调用这个函数，并等待它完成所有这些步骤，我们只需做<code class="fe mn mo mp mq b">asyncFunc().then()</code>，就像我们对我们的承诺所做的一样，因为async是一个承诺，当我们从函数返回一些东西时，它基本上与我们解析一个承诺相同。</p><h1 id="679c" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="6530" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在，我没有提到所有的内容，实际上，有很多内容我没有提到，比如如何捕捉错误、优化技术等等。但我认为这会让你对这三者之间的区别有一个基本的了解，它们是如何工作的，你如何使用它们。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="ab69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能也会喜欢:</p><div class="oc od gp gr oe of"><a href="https://medium.com/@anton.franzen/ec6-magic-you-wish-you-knew-8494da448866" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">你希望知道的魔法</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">一些简洁的ec6技巧可以加快编码速度</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a rel="noopener  ugc nofollow" target="_blank" href="/boost-the-seo-of-your-websites-with-next-js-2ea29f5ae67"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">用Next.js提升你网站的搜索引擎优化</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">如何添加关键字、元标签等</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">better编程. pub</p></div></div><div class="oo l"><div class="ou l oq or os oo ot ks of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://medium.com/mlearning-ai/machine-learning-engineering-is-hard-985ff23cb21f" rel="noopener follow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd iu gy z fp ok fr fs ol fu fw is bi translated">机器学习工程很难</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">人们让这看起来很容易，但实际上很难…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">medium.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot ks of"/></div></div></a></div><p id="4ccb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嘿，我叫安东👋，我是来自瑞典的自由职业前端开发人员。</p><p id="2289" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何前端工作或者偏远岗位随时联系我。</p></div></div>    
</body>
</html>