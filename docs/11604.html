<html>
<head>
<title>How To Create Your Own Writing Assistant App Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python创建自己的写作助手应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-your-own-writing-assistant-app-using-python-bc9265b8e5ea?source=collection_archive---------1-----------------------#2022-04-03">https://betterprogramming.pub/how-to-create-your-own-writing-assistant-app-using-python-bc9265b8e5ea?source=collection_archive---------1-----------------------#2022-04-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="c584" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">只需100行代码，就能使用人工智能毫不费力地生成博客</h2><div class=""/><div class=""><h2 id="76bb" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用Dash和HuggingFace构建一个强大的博客工具</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/3a2fc2f911f2c926d3169cf05ab60248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mIkzhuLVFneKNmiE"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">科伦·费迪达在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="6f6d" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">机器接管了吗？</h1><p id="62d5" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">由“人工智能”驱动的写作助手声称通过自动生成内容使你成为更好的博客作者，已经大受欢迎。他们经常利用通过机器学习创建的大量语言模型，<a class="ae lh" href="https://openai.com/blog/openai-api/" rel="noopener ugc nofollow" target="_blank">，像OpenAI </a>的GPT-3。</p><p id="44a8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在这篇文章中，我将向您展示使用类似于GPT-3的技术来创建自己的写作助手是多么容易，该应用程序还将使用传统的可读性测量方法对内容进行评分。我们将使用Python库<a class="ae lh" href="https://dash.plotly.com/" rel="noopener ugc nofollow" target="_blank"> Dash </a>、<a class="ae lh" href="https://huggingface.co/" rel="noopener ugc nofollow" target="_blank"> HuggingFace </a>和<a class="ae lh" href="https://github.com/cdimascio/py-readability-metrics" rel="noopener ugc nofollow" target="_blank">py-可读性-度量</a>。如果您已经熟悉了这些库，您可以在文章末尾找到完整的代码，以及指向我的GitHub的链接。</p><h1 id="5baf" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">目录:</h1><ul class=""><li id="6afd" class="nb nc it mc b md me mg mh mj nd mn ne mr nf mv ng nh ni nj bi translated">人工智能写作助手的问题</li><li id="35d5" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">什么是语言模型？</li><li id="f412" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">拥抱变形金刚入门</li><li id="de2e" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">可读性入门</li><li id="cc3d" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">Dash入门</li><li id="f349" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">构建基本的写作助手</li><li id="5358" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">添加高级功能</li><li id="eb07" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">结论和完整代码</li></ul><h1 id="b98e" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">人工智能写作助手的问题</h1><p id="3573" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">像Shortly.ai和Jasper.ai(正式名称为Jarvis.ai)这样的写作辅助工具的一个最大问题是，对于你所得到的东西来说，它们可能变得相当昂贵。考虑到人工智能生成的文本通常需要手动编辑才能保持连贯，它并不像市场宣传的那样节省大量时间。再加上有些工具甚至限制生成字数或者收取超龄费！</p><p id="c9b5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里以jasper.ai的产品定价为例。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi np"><img src="../Images/a0cb41f9966d1056450dfe7e33a0748f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwaF6Jf5hdpVI44xFRRM4A.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://www.jasper.ai/pricing" rel="noopener ugc nofollow" target="_blank">https://www.jasper.ai/pricing</a></p></figure><p id="408a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">不完全是我认为便宜的内容，我需要修改自己。如果你有兴趣了解更多我尝试过的基于人工智能的写作工具，可以看看我不久前写的这篇文章:</p><div class="nq nr gp gr ns nt"><a href="https://medium.com/geekculture/robots-to-the-rescue-online-writing-tools-that-make-blogging-a-breeze-6fc434b9ef7c" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">机器人来拯救——让写博客变得轻而易举的在线写作工具</h2><div class="oa l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og lb nt"/></div></div></a></div><p id="7843" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">它讨论了一些写作工具，结论是它们可以为想法的产生提供很大的帮助，但如果你希望一种不干涉的方法，就不是很好了。例如，shortly.ai在我遇到作家受阻时帮助我提出想法。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="f452" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">什么是语言模型？</h1><p id="ed0e" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在引擎盖下，我们的写作助手将利用一个预先训练的统计语言模型，该模型是在一个大型文本数据语料库上训练的。统计语言模型是单词序列的概率分布，可以让我们预测序列中的下一个单词。想象一下，你的手机会自动预测你在短信中的下一个单词。多亏了语言模型，这才成为可能。</p><p id="a540" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">通过自然语言处理(NLP)和数据科学领域的进步，许多强大的语言模型都是开源的，可供任何人尝试。我们使用预先训练的模型，因为我们自己构建这些大型语言模型既耗时又昂贵，因为大型语言模型需要大量的计算机能力来训练。训练GPT-3花费了数百万美元，它是市场上最大、最强大的语言模型之一。</p><h1 id="0f81" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">拥抱变形金刚入门</h1><p id="9898" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">HuggingFace transformers Python库是探索大型语言模型的最简单的方法之一。它简单明了的语法和公共的、最先进的模型中心使初学者可以轻松处理任何NLP任务，如文本生成、问题回答、语义相似性、主题建模和情感分析。</p><p id="9234" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">使用pip安装库</strong></p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="947d" class="oy lj it ou b gy oz pa l pb pc">pip install transformers</span></pre><p id="18ad" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果你是HuggingFace和NLP的新手，我强烈推荐你复习免费的HuggingFace NLP课程。它解释了从设置新的Python环境到探索transformers库、微调语言模型以及应用transformers解决NLP任务的所有内容。</p><div class="nq nr gp gr ns nt"><a href="https://huggingface.co/course/chapter0/1?fw=pt" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">简介-拥抱脸课程</h2><div class="pd l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">欢迎来到拥抱脸课程！这一介绍将引导你建立一个工作环境。如果…</h3></div><div class="oa l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">huggingface.co</p></div></div><div class="ob l"><div class="pe l od oe of ob og lb nt"/></div></div></a></div><p id="d66c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对于我们的写作助手应用程序，我们将重点使用HuggingFace库的文本生成模型和函数。生成文本很简单，只需要几行代码。下面是使用HuggingFace管道生成文本的基本实现:</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="2261" class="oy lj it ou b gy oz pa l pb pc">#import dependencies<br/>from transformers import pipeline</span><span id="d006" class="oy lj it ou b gy pf pa l pb pc">#instantiate generator <br/>generator = pipeline('text-generation', model='gpt2')</span><span id="eb8d" class="oy lj it ou b gy pf pa l pb pc">#pass a prompt to the generator<br/>generator("Hello, I'm a language model,")</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/ef4a7c2ccbd5d9fd334f799ed74c079e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLGK6VCzTA_zfo8HgKHDEQ.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">文本生成输出</p></figure><p id="7169" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">只需<em class="ph">三行代码</em>，我们就能生成文本！这就是拥抱脸的力量。请注意，生成文本依赖于一些随机性，因此即使我们使用相同的提示，您的结果也可能与我的结果不匹配。</p><p id="c2ce" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如果没有在管道中声明语言模型，生成器默认为<a class="ae lh" href="https://huggingface.co/gpt2" rel="noopener ugc nofollow" target="_blank"> GPT-2 </a>。<a class="ae lh" href="https://huggingface.co/models?pipeline_tag=text-generation&amp;sort=downloads" rel="noopener ugc nofollow" target="_blank">查看您可以在模型中心</a>中用于文本生成的模型列表。您可以通过传入模型参数来声明模型。如果您没有模型，它会自动下载。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/09f7c5ce3fb16d5e25819cd01b8f8f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5NFBx0kFU5bTsvSNGEyYA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">下载新模型</p></figure><p id="4e7d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意，您也可以将参数传递给生成器。我们传递一个<code class="fe pj pk pl ou b"><strong class="mc jd">max_length</strong></code> <strong class="mc jd"> </strong>来增加输出的字数，我们传递<code class="fe pj pk pl ou b"><strong class="mc jd">num_return_sequences</strong></code> <strong class="mc jd"> </strong>来增加返回的输出数。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="b9bd" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">可读性入门</h1><p id="a42c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><a class="ae lh" href="https://github.com/cdimascio/py-readability-metrics" rel="noopener ugc nofollow" target="_blank"> py-readability-metrics库</a>用于生成有用的可读性分数。这允许我们更好地评估输出的复杂性。使用它的各种评分函数，我们可以确定生成的输出是否适合目标受众。</p><h2 id="a554" class="oy lj it bd lk pm pn dn lo po pp dp ls mj pq pr lu mn ps pt lw mr pu pv ly iz bi translated"><strong class="ak">使用pip安装库</strong></h2><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="5745" class="oy lj it ou b gy oz pa l pb pc">pip install py-readability-metrics</span><span id="ba53" class="oy lj it ou b gy pf pa l pb pc">python -m nltk.downloader punkt<br/>import nltk<br/>nltk.download('punkt')</span></pre><p id="84f3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">该库需要NLTK标点符号扩展<code class="fe pj pk pl ou b">punkt</code>，所以一定要下载它。</p><p id="2a67" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用这个库很简单，但是大多数指标至少需要100个单词，所以如果生成少量文本，就不能使用它们。烟雾指标也需要至少30个句子。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="8887" class="oy lj it ou b gy oz pa l pb pc">from readability import Readability</span><span id="f0f8" class="oy lj it ou b gy pf pa l pb pc">text = 'In a shocking finding, scientists discovered a herd of unicorns living in a remote, previously unexplored valley, in the Andes Mountains. Even more surprising to the researchers was the fact that the unicorns spoke perfect English.\n\nThe finding is so startling, it\'s a shock to so many who took part in the experiment.\n\n"It shows that you are not just living with a set of social norms and conventions about things with a genetic basis," said researchers Dr. Kip Thao and Dr. Hui Zhang. "Your DNA is so important that you will survive this experiment if it does not change."\n\nThe researchers took part in this research because we have these really special abilities and we are trying to find ways of not taking it for granted."&lt;|endoftext|&gt;'</span><span id="94ec" class="oy lj it ou b gy pf pa l pb pc">r = Readability(text)</span><span id="c3c8" class="oy lj it ou b gy pf pa l pb pc">r.dale_chall()</span><span id="fa35" class="oy lj it ou b gy pf pa l pb pc">dc = r.dale_chall()</span><span id="bf43" class="oy lj it ou b gy pf pa l pb pc">print(dc.score)<br/>print(dc.grade_levels)</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/3cea5a6deea45fefa85fe10d6d124b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*v66RnHxtJ4MQlO4ddV8IEw.png"/></div><p class="ld le gj gh gi lf lg bd b be z dk translated">dale_chall可读性分数和等级级别</p></figure><p id="a73c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意，我们可以输出可读性分数和等级级别。根据提供的文本，我们看到<a class="ae lh" href="https://en.wikipedia.org/wiki/Dale%E2%80%93Chall_readability_formula" rel="noopener ugc nofollow" target="_blank">戴尔·查尔测量</a>将它评为11或12年级的阅读水平。</p><p id="2d8d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">他们的库包含几个不同的度量标准。<a class="ae lh" href="https://github.com/cdimascio/py-readability-metrics" rel="noopener ugc nofollow" target="_blank">通过查看库的GitHub repo中的自述文件，了解关于每个指标的更多信息</a>。以下是包含的指标列表:</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="4fa5" class="oy lj it ou b gy oz pa l pb pc">r = Readability(text)<br/><br/>r.flesch_kincaid()<br/>r.flesch()<br/>r.gunning_fog()<br/>r.coleman_liau()<br/>r.dale_chall()<br/>r.ari()<br/>r.linsear_write()<br/>r.smog()<br/>r.spache()</span></pre><p id="58c5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用可读性指标将使我们更容易评估生成的输出的可读性。有时生成的输出不是很一致，因此能够快速轻松地评估它将使整个过程更加用户友好。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="655c" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">Dash入门</h1><p id="81fd" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">Dash by Plotly是一个基于Flask、Plotly.js和React.js编写的强大的Python开源框架。它抽象出了这些技术的复杂性，将它们提炼为易于应用的组件。我将提供基础知识的简要概述，但如果你是全新的<a class="ae lh" href="https://dash.plotly.com/" rel="noopener ugc nofollow" target="_blank"> Dash库</a>或者想要深入了解所有功能，请查看我的初学者教程或网站，<a class="ae lh" href="https://pythondashboards.com" rel="noopener ugc nofollow" target="_blank">pythondashboards.com</a>:</p><div class="nq nr gp gr ns nt"><a href="https://levelup.gitconnected.com/how-to-create-powerful-web-apps-and-dashboards-using-dash-2-0-a05db174f20d" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">如何使用Dash 2.0创建强大的Web应用和仪表盘</h2><div class="pd l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">使用Python设计多页面Web应用程序</h3></div><div class="oa l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ob l"><div class="px l od oe of ob og lb nt"/></div></div></a></div><p id="6ad0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Dash有一个不断发展的社区，里面充满了热情的开发者和创造者。由于该框架是开源的，<a class="ae lh" href="https://plotly.com/dash-community-components/" rel="noopener ugc nofollow" target="_blank">社区开发了一些非常酷的组件，可以集成到任何Dash应用</a>中。</p><p id="f872" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><strong class="mc jd">使用pip安装仪表板:</strong></p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="00ec" class="oy lj it ou b gy oz pa l pb pc">pip install dash</span></pre><h1 id="509e" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">仪表板基础</h1><p id="2a89" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">使用Dash，您不需要从头开始编写任何HTML或CSS，尽管理解每一个的基础对于用户界面(UI)设计肯定有帮助。</p><p id="4f4a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Dash应用程序主要由两部分组成:</p><p id="9d26" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">1.布局</p><p id="e805" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">2.复试</p><h1 id="b762" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">仪表板布局</h1><p id="6749" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">布局由组件树组成，描述应用程序的外观以及用户如何体验内容。Dash附带了多个组件库，如<code class="fe pj pk pl ou b">dash_core_components</code>、<code class="fe pj pk pl ou b">dash_html_components</code>和Dash DataTable。</p><p id="984e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe pj pk pl ou b">dash_html_components</code>库中几乎每个HTML标签都有一个组件。<code class="fe pj pk pl ou b">dash_core_components</code>库包括高级交互组件，如日期选择器、清单、输入字段、图表和下拉列表。<code class="fe pj pk pl ou b"><strong class="mc jd">Dash DataTable</strong></code>使得将可过滤的、分页的数据表集成到你的应用程序中变得容易。<a class="ae lh" href="https://dash.plotly.com/" rel="noopener ugc nofollow" target="_blank">查看文档，获取核心组件库的完整列表</a>。</p><h2 id="3d09" class="oy lj it bd lk pm pn dn lo po pp dp ls mj pq pr lu mn ps pt lw mr pu pv ly iz bi translated">仪表板引导组件</h2><p id="db12" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">除了Dash的核心库，我还使用Dash Bootstrap组件库来简化网站<a class="ae lh" href="https://en.wikipedia.org/wiki/Responsive_web_design" rel="noopener ugc nofollow" target="_blank">响应式设计</a>。类似于Dash HTML组件库允许您使用Python应用HTML，Dash Bootstrap CSS组件库允许您添加受Bootstrap CSS框架影响的Bootstrap前端组件。</p><p id="164f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用pip安装Dash引导组件库:</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="9f69" class="oy lj it ou b gy oz pa l pb pc">pip install dash-bootstrap-components</span></pre><h1 id="7280" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">Dash回调</h1><p id="f409" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">回调是让Dash应用程序交互的逻辑所在。回调是Python函数，每当输入组件的属性发生变化时都会自动调用。例如，想象一个网站上的按钮。单击时，会在后台触发一个回调，触发按钮的功能。可以链接回调，使一个更改触发整个应用程序的多个更新。</p><p id="3691" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">基本上，回调由<strong class="mc jd"> <em class="ph">输入</em> </strong>和<strong class="mc jd"> <em class="ph">输出</em> </strong>组成。它们也可以包括<strong class="mc jd">状态</strong>。该功能通过<code class="fe pj pk pl ou b">app.callback</code> <a class="ae lh" href="https://www.python-course.eu/python3_decorators.php" rel="noopener ugc nofollow" target="_blank">装饰器</a>工作。输入和输出只是用户可以与之交互的组件的属性。例如，输入可以是从下拉列表中选择的选项，输出可以是可视化。假设我有一个州的下拉列表，当我选择CA时，加利福尼亚会在地图上突出显示。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="6373" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">创建写作助手应用程序</h1><p id="f789" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们将从构建一个简单的Dash应用程序大纲开始，然后我们将逐渐添加功能，使其变得更加复杂。我们的第一个组件将是具有简单标题和输入字段的容器，然后我们将实现一个基本的文本生成器。一旦启动并运行，我们将添加一个扩展和清除按钮。最后，我们将增加可读性分数。</p><h2 id="f065" class="oy lj it bd lk pm pn dn lo po pp dp ls mj pq pr lu mn ps pt lw mr pu pv ly iz bi translated">创建虚线轮廓</h2><p id="7191" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">首先创建一个名为app.py的文件。导入依赖项并为Dash应用程序创建一个大纲，用基本布局实例化该应用程序。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="2325" class="oy lj it ou b gy oz pa l pb pc"><strong class="ou jd">#import dependencies</strong><br/>from dash import Dash, dcc, html, Input, Output, State, callback_context<br/>import dash_bootstrap_components as dbc<br/>from transformers import AutoTokenizer, AutoModelForCausalLM<br/>from readability import Readability<br/>import nltk</span><span id="8d86" class="oy lj it ou b gy pf pa l pb pc"><strong class="ou jd">#instantiate dash</strong><br/>app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])</span><span id="a7a0" class="oy lj it ou b gy pf pa l pb pc"><strong class="ou jd">#create layout</strong><br/>app.layout = html.Div([dbc.Container([<br/>   <br/>   ])<br/>  ])</span><span id="ac95" class="oy lj it ou b gy pf pa l pb pc"><strong class="ou jd">#run app server</strong><br/>if __name__ == '__main__':<br/>    app.run_server(debug=True)</span></pre><p id="f843" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意，我们从一个<code class="fe pj pk pl ou b">html.Div</code>组件和一个<code class="fe pj pk pl ou b">dbc.Container </code>组件开始布局。其余的应用程序组件将存在于该容器中。一个容器组件利用了<a class="ae lh" href="https://getbootstrap.com/docs/4.0/layout/grid/" rel="noopener ugc nofollow" target="_blank"> bootstrap的网格</a>，增加了<a class="ae lh" href="https://medium.com/swlh/dashboards-in-python-for-beginners-using-dash-responsive-mobile-dashboards-with-bootstrap-css-2a0d05a53cf6" rel="noopener">的响应性，并防止组件拉伸整个屏幕</a>。</p><p id="bfa7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">下面是一个简单的组件概要，用于设置应用程序的UI结构。将此添加到<code class="fe pj pk pl ou b">dbc.Container</code>组件中:</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="ac29" class="oy lj it ou b gy oz pa l pb pc">html.H1("Eric's Writing Assistant")<br/>, html.Br()<br/>, html.H3("Enter a prompt")<br/>, html.Br()<br/>, html.Br()<br/>, html.H3("Generated Text")<br/>, html.Div(id='my-output')</span></pre><p id="34ae" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated"><code class="fe pj pk pl ou b">html.H1</code>和<code class="fe pj pk pl ou b">H3</code>是保存简单文本的标题组件。<code class="fe pj pk pl ou b">html.Br</code>组件是一个换行符，在整个应用程序中增加了一些空间。最后，id=' <em class="ph"> my-output' </em>的<code class="fe pj pk pl ou b">html.Div</code>组件将用于保存生成的文本。</p><p id="f3b5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">通过在命令行中键入<code class="fe pj pk pl ou b">python app.py</code>来运行我们目前所拥有的。这应该会显示在浏览器中:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi py"><img src="../Images/11e84506d1b44e485a544492684343ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7v8dQdiI6HnIQhLqw2r-Zw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">到目前为止的写作助手应用</p></figure><p id="46b4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">应用程序工作(总是一个好迹象)，所以让我们继续添加功能！</p><h2 id="9e4b" class="oy lj it bd lk pm pn dn lo po pp dp ls mj pq pr lu mn ps pt lw mr pu pv ly iz bi translated">添加输入字段</h2><p id="b666" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们需要一个输入字段，接受我们的写作提示。为了保持布局简洁，我将创建一个函数<strong class="mc jd"> </strong>，我们可以调用它来生成我们想要包含的组件树。</p><p id="d1f3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">将此函数添加到Dash实例化的上方(app = Dash…):</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="4749" class="oy lj it ou b gy oz pa l pb pc">def textareas():<br/>    return html.Div([ <br/>            dbc.Textarea(id = 'my-input'<br/>                , size="lg"<br/>                , placeholder="Enter text for auto completion")<br/>            , dbc.Button("Submit"<br/>                , id="gen-button"<br/>                , className="me-2"<br/>                , n_clicks=0)<br/>            ])</span></pre><p id="6a63" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">请注意，我们使用了<code class="fe pj pk pl ou b">dbc.Textarea</code>组件来生成一个大的文本字段。我们还包含了一个<code class="fe pj pk pl ou b">dbc.Button</code>组件，这样我们就可以将提示提交给文本生成器。</p><p id="dea4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在dash应用程序布局中，在<code class="fe pj pk pl ou b">html.H3</code>组件之后调用函数。完整的代码将如下所示:</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="d863" class="oy lj it ou b gy oz pa l pb pc">#import dependencies<br/>from dash import Dash, dcc, html, Input, Output, State, callback_context<br/>import dash_bootstrap_components as dbc<br/>import plotly.express as px<br/>from transformers import AutoTokenizer, AutoModelForCausalLM</span><span id="f9df" class="oy lj it ou b gy pf pa l pb pc">#create an input field<br/>def textareas():<br/>    return html.Div([ <br/>            dbc.Textarea(id = 'my-input'<br/>                , size="lg"<br/>                , placeholder="Enter text for auto completion")<br/>            , dbc.Button("Submit"<br/>                , id="gen-button"<br/>                , className="me-2"<br/>                , n_clicks=0)<br/>            ])</span><span id="ca15" class="oy lj it ou b gy pf pa l pb pc">#instantiate dash<br/>app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])</span><span id="24c7" class="oy lj it ou b gy pf pa l pb pc">#create layout<br/>app.layout = html.Div([dbc.Container([<br/>        html.H1("Eric's Writing Assistant")<br/>        , html.Br()<br/>        , html.H3("Enter a prompt")<br/>        , textareas()<br/>        , html.Br()<br/>        , html.Br()<br/>        , html.H3("Generated Text")<br/>        , html.Div(id='my-output')<br/>   ])<br/>  ])</span><span id="6365" class="oy lj it ou b gy pf pa l pb pc">#run app server<br/>if __name__ == '__main__':<br/>    app.run_server(debug=True)</span></pre><p id="da82" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">该应用程序加载后将如下所示:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pz"><img src="../Images/aed885efaeb010e52962a4f026a96d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aX_i-NNnzoEjmPbmVmUywA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">到目前为止的写作助手应用</p></figure><h2 id="05cb" class="oy lj it bd lk pm pn dn lo po pp dp ls mj pq pr lu mn ps pt lw mr pu pv ly iz bi translated">添加文本生成器</h2><p id="b3d1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">为了生成文本，我们需要添加一个<code class="fe pj pk pl ou b">callback</code> <strong class="mc jd"> <em class="ph"> </em> </strong>，它将提示作为输入，并将文本输出到id = ' <em class="ph"> my-output </em>的<code class="fe pj pk pl ou b">html.Div</code>组件。我们将使用HuggingFace AutoTokenizer和<code class="fe pj pk pl ou b">AutoModelFOrCausalLM</code>来实现文本生成模型，而不是使用transformers管道。</p><p id="2280" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">将这几行代码添加到<code class="fe pj pk pl ou b">textareas</code>函数之上。他们将实例化语言模型:</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="7388" class="oy lj it ou b gy oz pa l pb pc">tokenizer = AutoTokenizer.from_pretrained("gpt2")</span><span id="d3de" class="oy lj it ou b gy pf pa l pb pc">model = AutoModelForCausalLM.from_pretrained("gpt2")</span></pre><p id="b225" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接下来，在<code class="fe pj pk pl ou b">app.layout</code>之外创建回调。回调使用<code class="fe pj pk pl ou b">Output</code>、<code class="fe pj pk pl ou b">Input</code>和<code class="fe pj pk pl ou b">State</code>。它们每个都需要一个<code class="fe pj pk pl ou b"><em class="ph">component_id</em></code>和一个<code class="fe pj pk pl ou b"><em class="ph">component_property</em></code>。完成的回调将如下所示:</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="4b53" class="oy lj it ou b gy oz pa l pb pc"><a class="ae lh" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(<br/>    Output(component_id='my-output', component_property='children'),<br/>    Input(component_id='gen-button', component_property='n_clicks'),<br/>    State(component_id='my-input', component_property='value')    <br/>)<br/>def update_output_div(gen, input_value):<br/>    gen_text = ""<br/>    <br/>    if input_value is None or input_value == "":<br/>            input_value = ""<br/>            gen_text = ""</span><span id="4b01" class="oy lj it ou b gy pf pa l pb pc">    else:<br/>       <br/>        input_ids = tokenizer(input_value<br/>                      , return_tensors="pt").input_ids</span><span id="3fac" class="oy lj it ou b gy pf pa l pb pc">        gen_tokens = model.generate(<br/>            input_ids,<br/>            do_sample=True,<br/>            temperature=0.9,<br/>            max_length=100,<br/>        )<br/>        gen_text = tokenizer.batch_decode(gen_tokens)[0]<br/>    <br/>    return html.P(gen_text)</span></pre><p id="2492" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">由于应用程序启动时的<code class="fe pj pk pl ou b">input_value</code>是<code class="fe pj pk pl ou b">None</code>，我们使用if/else语句来处理None并防止显示错误。当我们输入文本提示并单击Submit按钮时，input_value被标记化并传递给模型。回调返回包装在<code class="fe pj pk pl ou b">html.P</code>组件中的生成文本。</p><p id="a543" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">生成应用程序，它应该是全功能的！</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qa"><img src="../Images/cf90242b6e5ab166387c1e70da5aed83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUCPbwHxZxfUfteURbPvaw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">写作助手App</p></figure><blockquote class="qb"><p id="0111" class="qc qd it bd qe qf qg qh qi qj qk mv dk translated">恭喜你！您刚刚完成了我们的基本写作助手应用程序。</p></blockquote><h1 id="d6eb" class="li lj it bd lk ll lm ln lo lp lq lr ls ki ql kj lu kl qm km lw ko qn kp ly lz bi translated">添加高级功能</h1><p id="1289" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">现在，我们已经完成了基础知识，让我们为应用程序添加一些高级功能。我们将添加一个扩展按钮，它接受新生成的文本作为提示，并根据更新后的input_value生成新的文本。此外，我们将添加一个Clear按钮来清除提示和生成的数据。最后，我们将使用可读性指标对输出进行评分。</p><h2 id="9e3a" class="oy lj it bd lk pm pn dn lo po pp dp ls mj pq pr lu mn ps pt lw mr pu pv ly iz bi translated">添加扩展和清除</h2><p id="e537" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">我们可以通过使用<code class="fe pj pk pl ou b"><a class="ae lh" href="https://dash.plotly.com/advanced-callbacks" rel="noopener ugc nofollow" target="_blank">callback_context</a></code>将expand和clear函数添加到我们已经有的回调中。它允许我们区分哪个按钮是最后按下的。</p><p id="9541" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了让我们的扩展函数工作，我们需要创建两个全局变量:</p><ul class=""><li id="d835" class="nb nc it mc b md mw mg mx mj qo mn qp mr qq mv ng nh ni nj bi translated">存储生成的文本的列表。</li><li id="84a6" class="nb nc it mc b md nk mg nl mj nm mn nn mr no mv ng nh ni nj bi translated">用于计算单击Expand次数的变量。</li></ul><p id="f3a1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">我们需要一个变量来计算点击次数，因为清除n_clicks状态可能是不可能的。</p><p id="c551" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">创建全局变量，将它们添加到<code class="fe pj pk pl ou b">textareas</code>函数之上。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="9ebf" class="oy lj it ou b gy oz pa l pb pc">gen_text_list = []<br/>exv = 0</span></pre><p id="e891" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">给<code class="fe pj pk pl ou b">app.layout</code>增加两个新的<code class="fe pj pk pl ou b">dbc.Button</code>组件，一个用于扩展，一个用于清除。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="3093" class="oy lj it ou b gy oz pa l pb pc">, dbc.Button("Expand", id="expand-button", n_clicks=0)<br/>, dbc.Button("Clear", id="clear-button", n_clicks=0)</span></pre><p id="bc8d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">对于每个按钮，通过将<code class="fe pj pk pl ou b">component_id</code> <em class="ph"> </em>和<code class="fe pj pk pl ou b"><strong class="mc jd">n_clicks</strong></code>作为<code class="fe pj pk pl ou b">component_property</code>，向回调添加新的输入。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="5908" class="oy lj it ou b gy oz pa l pb pc"><a class="ae lh" href="http://twitter.com/app" rel="noopener ugc nofollow" target="_blank">@app</a>.callback(<br/>Output(component_id='my-output', component_property='children'),<br/>Input(component_id='gen-button', component_property='n_clicks'),<br/><strong class="ou jd">Input(component_id='expand-button', component_property='n_clicks'),<br/>Input(component_id='clear-button', component_property='n_clicks'),</strong><br/>State(component_id='my-input', component_property='value') <br/>)<br/>def update_output_div(gen, ex, input_value):</span></pre><p id="a124" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在回调函数中，在函数的开头添加一个<code class="fe pj pk pl ou b">changed_id</code> <strong class="mc jd"> </strong>变量和逻辑来跟踪最后按下的按钮。另外，在<code class="fe pj pk pl ou b">change_id</code>之后添加全局变量。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="b39e" class="oy lj it ou b gy oz pa l pb pc">changed_id = [p['prop_id'] for p in callback_context.triggered][0]</span><span id="de1b" class="oy lj it ou b gy pf pa l pb pc">global gen_text_list</span><span id="2d0a" class="oy lj it ou b gy pf pa l pb pc">global exv</span></pre><p id="6356" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接下来我们将使用<code class="fe pj pk pl ou b">If</code>语句根据<code class="fe pj pk pl ou b">changed_id</code> <strong class="mc jd"> </strong>变量的值来执行我们的逻辑。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="2294" class="oy lj it ou b gy oz pa l pb pc">if 'gen-button' in changed_id: <br/>    &lt;our submit logic here&gt;</span><span id="c87c" class="oy lj it ou b gy pf pa l pb pc">if 'expand-button' in changed_id:<br/>    &lt;our expand logic here&gt;</span><span id="faf5" class="oy lj it ou b gy pf pa l pb pc">if 'clear-button in changed_id:<br/>    &lt;our clear logic here&gt;</span></pre><p id="6d93" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">提交按钮的逻辑需要稍微改变一下。文本生成并存储在<code class="fe pj pk pl ou b">gen_text</code>变量后，需要将文本追加到<code class="fe pj pk pl ou b">gen_text_list</code>中进行存储。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="c538" class="oy lj it ou b gy oz pa l pb pc">if 'gen-button' in changed_id:<br/>        <br/>        if input_value is None or input_value == "":<br/>            input_value = ""<br/>            gen_text = ""</span><span id="0f3b" class="oy lj it ou b gy pf pa l pb pc">else:<br/>        input_ids = tokenizer(input_value,  return_tensors="pt").input_ids</span><span id="421d" class="oy lj it ou b gy pf pa l pb pc">    gen_tokens = model.generate(<br/>                input_ids,<br/>                do_sample=True,<br/>                temperature=0.9,<br/>                max_length=100,<br/>            )<br/>            gen_text = tokenizer.batch_decode(gen_tokens)[0]<br/>            <br/>            gen_text_list.append(gen_text)</span></pre><p id="260a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">Expand按钮的逻辑看起来与Submit按钮几乎相同，但是它没有使用输入字段中的文本，而是使用了<code class="fe pj pk pl ou b">gen_text_list</code>中最近的条目。</p><p id="1af5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">此外，由于提示将超过100个令牌，因此需要调整<code class="fe pj pk pl ou b">max_length</code>参数。我创建了一个MAX_LENGTH变量，并将其设置为<code class="fe pj pk pl ou b">100 + 100 * number of Expand clicks + 1 or (100 + 100*(exv+1)</code>。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="8dae" class="oy lj it ou b gy oz pa l pb pc">if 'expand-button' in changed_id:</span><span id="193c" class="oy lj it ou b gy pf pa l pb pc">if len(gen_text_list) &gt; 0:<br/>            MAX_LENGTH = 100 + 100*(exv+1)<br/>            input_ids = tokenizer(gen_text_list[exv], return_tensors="pt").input_ids</span><span id="77a5" class="oy lj it ou b gy pf pa l pb pc">    gen_tokens = model.generate(<br/>                input_ids,<br/>                do_sample=True,<br/>                temperature=0.9,<br/>                max_length=MAX_LENGTH,<br/>            )<br/>            gen_text = tokenizer.batch_decode(gen_tokens)[0]<br/>           <br/>            gen_text_list.append(gen_text)<br/>            exv+=1<br/>        else:<br/>            html.P("no text has been generated")</span></pre><p id="2570" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">“清除”按钮的逻辑非常简单。只需要设置<code class="fe pj pk pl ou b">gen_text = ‘’</code>、<code class="fe pj pk pl ou b">exv = 0</code>和<code class="fe pj pk pl ou b">gen_text_list = []</code>。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="15ef" class="oy lj it ou b gy oz pa l pb pc">if 'clear-button' in changed_id:<br/>        gen_text = ''<br/>        exv = 0<br/>        gen_text_list = []</span></pre><p id="7c55" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">应用程序现在看起来像这样。我也用了几次扩展按钮。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qr"><img src="../Images/8921a8f18d00139d676a7c00fd3445aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*80A4ol1GXqS7i6XluppkGw.png"/></div></div></figure><h1 id="de98" class="li lj it bd lk ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">添加可读性分数</h1><p id="c97d" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">可读性分数的实现非常简单。我们需要在布局中的<code class="fe pj pk pl ou b"><em class="ph">my-output</em></code> Div上方添加一个新的<code class="fe pj pk pl ou b">html.Div</code> <strong class="mc jd"> </strong>。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="1ff6" class="oy lj it ou b gy oz pa l pb pc">, html.Div(id='readability-score')</span></pre><p id="537d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">将这个新组件作为回调的另一个<code class="fe pj pk pl ou b">Output</code>添加到第一个组件的正下方。另外，将其添加到回调的return语句中。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="863b" class="oy lj it ou b gy oz pa l pb pc">Output(component_id = 'readability-score', component_property='children'),</span><span id="c461" class="oy lj it ou b gy pf pa l pb pc">....callback logic stuff...</span><span id="a39c" class="oy lj it ou b gy pf pa l pb pc">return html.P(gen_text), html.P(f"Readability Score: {score}")</span></pre><p id="d491" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最后，在将gen_text添加到列表之后，向Submit按钮和Expand按钮添加一个if/else语句。</p><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="4517" class="oy lj it ou b gy oz pa l pb pc">if len(gen_text.strip().split(" ")) &gt;100:<br/>     print(len(gen_text))<br/>     r = Readability(gen_text)<br/>     fk = r.flesch_kincaid()<br/>     score = fk.score<br/>                <br/> else: <br/>     score = 'Not 100 tokens'</span></pre><p id="fa84" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了避免出现错误消息，该逻辑会检查令牌字符串是否大于100。如果是，则生成分数。否则，它将返回一条消息。</p><p id="d03e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这是最终应用程序的样子:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qs"><img src="../Images/556d177afd9dc373ac88514fb347d221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUIhY63vEdj_YePYl28wNw.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated">写作助手app</p></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="5701" class="li lj it bd lk ll oo ln lo lp op lr ls ki oq kj lu kl or km lw ko os kp ly lz bi translated">最后的想法和完整的代码</h1><p id="d665" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">创建一个写作助手可以在一个下午用不到100行代码完成。我们创建了一个Dash应用程序，它接受输入，基于该输入生成文本，扩展该文本，并对其可读性进行评分。</p><p id="a60e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">虽然我们的应用程序没有Shortly或Jasper的所有功能，但如果有动力，我们可以继续添加它们。我们甚至可以使用GPT-3 API！最终，我认为最好是节省你的钱，使用像HuggingFace提供的语言模型这样的免费工具，即使它们功能不那么强大。</p><p id="31e7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您可以在下面我的GitHub资源库中找到完整的代码:</p><div class="nq nr gp gr ns nt"><a href="https://github.com/bendgame/WritingAssistantApp" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jd gy z fp ny fr fs nz fu fw jc bi translated">GitHub-bend game/writing assistant app:Code for medium教程如何创建写作助手…</h2><div class="pd l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="oa l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">github.com</p></div></div><div class="ob l"><div class="qt l od oe of ob og lb nt"/></div></div></a></div><pre class="ks kt ku kv gt ot ou ov ow aw ox bi"><span id="df85" class="oy lj it ou b gy oz pa l pb pc">Thank You!</span><span id="04c4" class="oy lj it ou b gy pf pa l pb pc"><em class="ph">If you enjoyed my work, </em><a class="ae lh" href="https://medium.com/@erickleppen" rel="noopener"><em class="ph">follow me on Medium</em></a><em class="ph"> for more!</em></span><span id="b82b" class="oy lj it ou b gy pf pa l pb pc"><a class="ae lh" href="https://erickleppen.medium.com/membership" rel="noopener"><em class="ph">Get FULL ACCESS and help support my content by subscribing</em></a>!</span><span id="5111" class="oy lj it ou b gy pf pa l pb pc"><em class="ph">Let’s connect on </em><a class="ae lh" href="https://www.linkedin.com/in/erickleppen01/" rel="noopener ugc nofollow" target="_blank"><em class="ph">LinkedIn</em></a></span><span id="f5c6" class="oy lj it ou b gy pf pa l pb pc"><em class="ph">Analyze Data using Python? Check out my </em><a class="ae lh" href="https://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"><em class="ph">website</em></a>!</span><span id="a202" class="oy lj it ou b gy pf pa l pb pc"><a class="ae lh" href="http://pythondashboards.com/" rel="noopener ugc nofollow" target="_blank"><strong class="ou jd">— Eric Kleppen</strong></a></span></pre></div></div>    
</body>
</html>