<html>
<head>
<title>Building Contextual Mode of Top App Bar in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose中构建顶部应用程序栏的上下文模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-contextual-mode-of-top-app-bar-in-jetpack-compose-aecdfcfd3fef?source=collection_archive---------8-----------------------#2022-02-18">https://betterprogramming.pub/building-contextual-mode-of-top-app-bar-in-jetpack-compose-aecdfcfd3fef?source=collection_archive---------8-----------------------#2022-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6d11" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建定制的Android用户界面变得简单多了</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/819eab5cc5506e6aaec97f2595f35b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ET4TI0SakC-VNsyWeZy_yQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@alesnesetril?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ales Nesetril </a>在<a class="ae kv" href="https://unsplash.com/s/photos/technology?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经在Whatsapp、Gmail、Contacts等许多应用中看到了长按选择聊天、电子邮件或联系人时的上下文模式。它提供了一个显示上下文操作菜单的临时UI。</p><p id="6643" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在传统的视图系统中，<a class="ae kv" href="https://developer.android.com/reference/android/view/ActionMode" rel="noopener ugc nofollow" target="_blank"> ActionMode </a>是显示上下文动作的首选技术。在本帖中，我们将探索如何使用Jetpack Compose实现同样的功能。</p><h1 id="4e74" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们将建造什么</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e5a488d0c1ca05f859408d941adffd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*ozd3ZdpgEQ41csigWfkghg.gif"/></div></figure><h1 id="9b4a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">不说话，只是代码？</h1><p id="4758" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好吧，如果你有兴趣直接跳到代码，这里的<a class="ae kv" href="https://github.com/tusharkathuria/AndroidPlayground/blob/main/contextual-app-bar/src/main/java/com/tusharkathuria/androidplayground/contextualappbar/MainActivity.kt" rel="noopener ugc nofollow" target="_blank">是指向活动文件的链接，该文件包含实现上述结果的代码。</a></p><h1 id="51ae" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><p id="f600" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这篇文章假设你已经知道Jetpack Compose和Material Top App Bar实现。请参考以下链接进行回顾:</p><ul class=""><li id="d6a0" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><a class="ae kv" href="https://developer.android.com/courses/pathways/compose" rel="noopener ugc nofollow" target="_blank">构建学习路径</a></li><li id="74c1" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/google-developer-experts/exploring-jetpack-compose-topappbar-c8b79893be34" rel="noopener">在撰写中浏览顶部应用程序栏</a></li></ul><h1 id="a795" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们开始吧</h1><p id="cd27" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将从创建一个带有顶部应用程序栏和切换上下文模式的按钮的支架开始。点击按钮时，应用程序栏颜色会切换，并且会添加共享操作来指示上下文模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="9cd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样我们得到了以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/bc6b1206bc2336c1e0ba8aac0b76a5bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*BKaxDB7Wp2MI0MJ4RWSDtw.gif"/></div></figure><h1 id="f215" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">更改状态栏颜色</h1><p id="392e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们还可以在切换上下文模式时更改状态栏的颜色。为此，我们将使用伴奏者的<a class="ae kv" href="https://google.github.io/accompanist/systemuicontroller/" rel="noopener ugc nofollow" target="_blank">系统UI控制器</a>:</p><p id="4b81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加依赖关系:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="df2f" class="nl lt iq nh b gy nm nn l no np">implementation "com.google.accompanist:accompanist-systemuicontroller:$accompanist_version"</span></pre><p id="ae07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更改状态栏颜色:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="e249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种改变，我们得到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/16f863883d7cbed57f0a8e7bea64b425.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*OhkU5_wHgA195RVebJG9Ng.gif"/></div></figure><p id="ee69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们的工具栏有了一个全功能的上下文模式。但是如果能使用一些动画来使这种颜色的过渡平滑一些，那就更好了。接下来让我们试着这样做。</p><h1 id="2b11" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">实现更平稳的过渡</h1><p id="50ce" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们使用<code class="fe nq nr ns nh b"><a class="ae kv" href="https://developer.android.com/jetpack/compose/animation#updateTransition" rel="noopener ugc nofollow" target="_blank">updateTransition</a></code> API来制作颜色变化的动画。用以下初始化替换颜色变量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="533e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这导致以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a2393fc6d69789e243b1212c3f3473a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*kesLJXYXDJDis7ar6hnr_Q.gif"/></div></figure><p id="d528" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，颜色变化现在是动画，但看起来有两个不同的过渡。这是因为状态栏的颜色变化是在副作用中完成的。要解决这个问题，我们需要获得对状态栏空间的完全控制。一旦我们有了这个控件，状态栏颜色的改变就可以像背景和内容颜色的改变一样进行。</p><h1 id="9255" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在状态栏后面绘图</h1><p id="0aa0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将使用<code class="fe nq nr ns nh b"><a class="ae kv" href="https://developer.android.com/reference/androidx/core/view/WindowCompat#setDecorFitsSystemWindows(android.view.Window,boolean)" rel="noopener ugc nofollow" target="_blank">setDecorFitsSystemWindows</a></code> API和伴奏者的<a class="ae kv" href="https://google.github.io/accompanist/insets/" rel="noopener ugc nofollow" target="_blank"> Insets </a>的组合来控制状态栏后面的空间。</p><p id="3c1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加依赖关系:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="f8a9" class="nl lt iq nh b gy nm nn l no np">implementation "com.google.accompanist:accompanist-insets:$accompanist_version"</span></pre><p id="b3d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在调用<code class="fe nq nr ns nh b">setContent</code>之前，通过在<code class="fe nq nr ns nh b">onCreate</code> <em class="nt"> </em>中添加以下代码，获得设备空间的边对边控制:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="9a0c" class="nl lt iq nh b gy nm nn l no np">WindowCompat.setDecorFitsSystemWindows(<em class="nt">window</em>, false)</span></pre><p id="cd62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe nq nr ns nh b">ProvideWindowInsets</code> <em class="nt">包裹撰写层次。</em>这使我们能够使用insets库提供的各种修改器。点击阅读更多<a class="ae kv" href="https://google.github.io/accompanist/insets/" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="1172" class="nl lt iq nh b gy nm nn l no np"><em class="nt">setContent </em><strong class="nh ir">{<br/>    </strong><em class="nt">ProvideWindowInsets </em><strong class="nh ir">{<br/>        .<br/>        .<br/>        .<br/>    }<br/>}</strong></span></pre><p id="cfb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新副作用来设置透明状态栏的颜色。这对于确保状态栏后面的内容(我们稍后将绘制它)是可见的非常重要:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="f97a" class="nl lt iq nh b gy nm nn l no np"><em class="nt">SideEffect </em><strong class="nh ir">{<br/>    </strong>systemUiController.setStatusBarColor(<br/>        color = Color.Transparent,<br/>        darkIcons = !isContextual<br/>    )<br/><strong class="nh ir">}</strong></span></pre><p id="7baa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将以下修饰符添加到TopAppBar调用中:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="8e6a" class="nl lt iq nh b gy nm nn l no np"><em class="nt">TopAppBar</em>(<br/>    .<br/>    .<br/>    .</span><span id="fd65" class="nl lt iq nh b gy nu nn l no np">    modifier = Modifier.<em class="nt">background</em>(statusBarColor).<em class="nt">statusBarsPadding</em>()<br/>)</span></pre><p id="dfc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在顶部应用程序栏上方添加一个等同于状态栏高度的填充，并对其应用所需的颜色。</p><p id="e5a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这些更改，我们得到了以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/17321ead7ff78e283f1d0f59525055f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*QxlFynAhej19rLdGJINgOw.gif"/></div></figure><p id="a826" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在变化发生在一个单独的过渡中，但是现在我们在正常模式下看到顶部应用程序栏中不需要的顶部高度。Jetpack Compose目前不提供任何方式来指定特定边上的高程。让我们使用一种变通方法来解决这个问题。</p><h1 id="9aa2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">应用仅底部高程</h1><p id="5a29" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">让我们使用<a class="ae kv" href="https://stackoverflow.com/users/3585796/philip-dukhov" rel="noopener ugc nofollow" target="_blank"> Philip Dukhov </a>建议的<a class="ae kv" href="https://stackoverflow.com/a/69914668/4176416" rel="noopener ugc nofollow" target="_blank">变通方法</a>来解决这个问题。</p><p id="8c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建仅应用底部高程的自定义修改器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d6c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将此修改器应用到顶部应用程序栏可组合:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="8294" class="nl lt iq nh b gy nm nn l no np"><em class="nt">TopAppBar</em>(<br/>    .<br/>    .<br/>    .</span><span id="1e12" class="nl lt iq nh b gy nu nn l no np">    modifier = Modifier.<em class="nt">background</em>(statusBarColor).<em class="nt">statusBarsPadding</em>().<em class="nt">bottomElevation</em>()<br/>)</span></pre><p id="e44c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这些改变，我们得到了我们最终想要的结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/e5a488d0c1ca05f859408d941adffd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/1*ozd3ZdpgEQ41csigWfkghg.gif"/></div></figure><p id="f238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这些，我们现在已经实现了顶部应用程序栏的全功能上下文模式。如果你想要一些自定义的颜色变化动画，你也可以在调用<code class="fe nq nr ns nh b">animateColor</code> <em class="nt"> </em>时尝试应用自定义的<a class="ae kv" href="https://developer.android.com/jetpack/compose/animation#animationspec" rel="noopener ugc nofollow" target="_blank">动画规格</a></p><h1 id="1b45" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">后续步骤</h1><ul class=""><li id="8939" class="mq mr iq ky b kz ml lc mm lf nv lj nw ln nx lr mv mw mx my bi translated">构建一个自定义的顶部应用程序栏组件，该组件采用<code class="fe nq nr ns nh b">isContextual</code>布尔参数。这将使我们能够在应用程序的所有屏幕上使用它</li><li id="6f64" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">通过使用主题中的语义颜色而不是硬编码颜色来支持深色主题</li></ul><h1 id="4792" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="68bb" class="mq mr iq ky b kz ml lc mm lf nv lj nw ln nx lr mv mw mx my bi translated"><a class="ae kv" href="https://github.com/tusharkathuria/AndroidPlayground/blob/main/contextual-app-bar/src/main/java/com/tusharkathuria/androidplayground/contextualappbar/MainActivity.kt" rel="noopener ugc nofollow" target="_blank">GitHub中的最终代码</a></li><li id="9550" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://developer.android.com/reference/android/view/ActionMode" rel="noopener ugc nofollow" target="_blank">动作模式</a></li><li id="a12a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://google.github.io/accompanist/systemuicontroller/" rel="noopener ugc nofollow" target="_blank">伴奏系统UI控制器</a></li><li id="4493" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://developer.android.com/jetpack/compose/animation#updateTransition" rel="noopener ugc nofollow" target="_blank">Jetpack中的动画合成</a></li><li id="d4b1" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://google.github.io/accompanist/insets/" rel="noopener ugc nofollow" target="_blank">伴奏插图</a></li></ul></div></div>    
</body>
</html>