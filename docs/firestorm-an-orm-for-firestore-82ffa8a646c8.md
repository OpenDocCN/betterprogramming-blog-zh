# firestor:Firestore 的 orm

> 原文：<https://betterprogramming.pub/firestorm-an-orm-for-firestore-82ffa8a646c8>

## 确保类型安全，用 Firestorm 写更干净的代码

![](img/de5520bf735e388bfafc24e9929b521c.png)

[Firestore](https://firebase.google.com/docs/firestore) 标志

Firestorm 是一个 Firestore 表单。如果你从未使用过 Firestore，它是一个 NoSQL 数据库，可以让你启动你的项目，而不必担心可扩展性。

如果你熟悉[坚实的原则](https://medium.com/better-programming/solid-principles-simple-and-easy-explanation-f57d86c47a7f)，你会知道每个模块/类应该有一个单一的职责。当使用原生 Firestore 库编写代码时，很容易在业务逻辑中混淆访问数据库的代码。此外，您接收的数据将是 JSON 格式，如果您使用的是 TypeScript，那么您可能会享受到类型安全的好处。

Firestorm 通过将您的集合(和子集合)定义为模型，允许您轻松地从数据库层抽象出来，然后您可以使用这些模型来执行创建、读取、更新和删除 **(** CRUD)操作。这有助于确保类型安全，并有助于编写更干净的代码。

# 要求

Firestorm 依赖于使用 TypeScript 的[实验装饰器](https://www.typescriptlang.org/docs/handbook/decorators.html)来定义你的模型。请确保您的`tsconfig.json` ( `ES5`是最低目标)中包含以下内容:

```
{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
  }
}
```

# 装置

```
$ npm install firebase-firestorm
```

# 入门指南

在这一节中，我们将带你看一个使用帖子、评论和作者的基本博客数据库的例子。

## 1.初始化火焰风暴

一初始化你的 Firestore 应用程序，就给`firestorm.initialize(firestore, options?)`打电话。

```
import * as firestorm from 'firebase-firestorm';
...
const firestore = firebase.initializeApp(...);
firestorm.initialize(firestore, /* options */);
...
```

## 2.定义根集合

这里我们有一个代表一个`posts`集合的类。实体类通常是非具体化的，因为它们表示集合中的单个文档。要定义根集合，您必须:

*   从`Entity`类扩展而来。
*   用`@rootCollection(opts: ICollectionConfig)`注释你的类。
*   声明一系列字段，用`@field(opts: IFieldConfig)`标注。

```
import { Entity, rootCollection, field } from 'firebase-firestorm';@rootCollection({
  name: 'posts',
})
export default class Post extends Entity {
  @field({ name: 'title' })
  title!: string; @field({ name: 'content' })
  content!: string;
}
```

## 3.定义子集合

> *你的每一个模型，无论它们代表一个根集合还是子集合，都必须从提供的* `*Entity*` *类中扩展。*

现在我们希望`posts`集合中的文档有一个`comments`的子集合。首先，我们需要为评论创建一个类。注意我们没有用`@rootCollection`来注释这个类。

```
import { Entity, rootCollection, field } from 'firebase-firestorm';export default class Comment extends Entity {
  @field({ name: 'content' })
  content!: string; @field({ name: 'by' })
  by!: string;
}
```

回到`Post`类，我们可以使用`@subCollection(opts: ISubcollectionConfig)`装饰器添加`Comment`作为子集合。

```
import { Entity, ICollection, rootCollection, field } from 'firebase-firestorm';
import Comment from './Comment';@rootCollection({
  name: 'posts',
})
export default class Post extends Entity {
  ...
  @subCollection({
    name: 'comments',
    entity: Comment, // we must define the entity class due to limitations in Typescript's reflection capabilities. Progress should be made on this issue in future releases.
  })
  comments!: ICollection<Comment>;
  ...
}
```

## 4.定义文档参考

最后，我们希望`posts`集合中的文档引用`authors`集合(另一个根集合)中的作者。首先，我们定义`Author`实体:

```
import { Entity, rootCollection, field } from 'firebase-firestorm';@rootCollection({
  name: 'authors',
})
export default class Author extends Entity {
  @field({ name: 'name' })
  name!: string;
}
```

然后我们可以使用`@documentRef(opts: IDocumentRefConfig)`装饰器添加一个对`Post`实体的`Author`引用:

```
import { Entity, ICollection, IDocumentRef, rootCollection, field } from 'firebase-firestorm';
import Author from './Author';@rootCollection({
  name: 'posts',
})
export default class Post extends Entity {
  ...
  @documentRef({
    name: 'author',
    entity: Author, // we must define the entity class due to limitations in Typescript's reflection capabilities. Progress should be made on this issue in future releases.
  })
  author!: IDocumentRef<Author>;
  ...
}
```

## 5.查询/更新数据

现在我们已经建立了模型，我们准备开始查询。调用`Collection(entity : IEntity)`将返回用户可以用来操作数据的方法列表。

**获取文件**

```
...
const post = Collection(Post).get('post-1').then((post : Post) => {
  console.log(post);
});
...
```

**得到一个子集合**

在我们的例子中，`Comment`是`Post`的子集合。您可以从检索到的文档或文档引用中获取子集合。

```
// Comment subcollection from document.
const post = Collection(Post).get('post-1').then((post : Post) => {
  const commentCollection = post.collection(Post);
});// Comment subcollection from document ref.
const postRef = Collection(Post).doc('post-1');
const commentCollection = postRef.collection(Post);
```

**查询数据**

您可以使用`find(query : ICollectionQuery)`方法来查询数据。完整的选项列表可在[文档](https://lmcq.github.io/firebase-firestorm/)中找到，但它们本质上与 Firestore 提供的选项相同。

```
const posts = Collection(Post).find({
    where: [
      ['title', '==', 'Example Title'],
      ...
    ],
  });
```

**创建文档**

```
...
  const post = new Post();
  post.id = 'post-1'; // id is optional, if it is not defined it will be generated by firestore.
  post.title = 'Untitled';
  let savedPost : Post;
  Collection(Post).create(post).then((_savedPost : Post) => {
    savedPost = _savedPost;
  });
...
```

**更新文件**

```
...
  const post = new Post();
  post.id = 'post-1'; // id is required.
  post.title = 'Untitled';
  let savedPost : Post;
  Collection(Post).update(post).then((_savedPost : Post) => {
    savedPost = _savedPost;
  });
...
```

**移除文件**

```
...
  Collection(Post).remove('post-id').then(...);
...
```

## 6.格式化数据

实体的一个实例可能包含一些属性，比如您不希望包含的子集合，例如，如果您正在构建一个 REST API。在一个实体的实例上调用`toData()`方法将产生一个普通的 JSON 对象，只包含原始数据、嵌套的 JSON 对象和已经使用`.get()`方法检索的文档引用。例如:

```
import { Collection } from 'firebase-firestorm';
import Author from './Author';
import Post from './Post';Collection(Post).get('post-1').then((post: Post) => {
  console.log(post.toData());
  /*
  Output:
  {
    id: ...,
    title: ...,
    content: ...
  }
  */
 post.author.get().then((author: Author) => {
   console.log(post.toData());
   /*
    Output:
    {
      id: ...,
      title: ...,
      content: ...,
      author: {
        id: ...,
        name: ...
      }
    }
   */
 });
});
```

# 自定义数据类型

## 数组

Firestore 文档可以包含字符串、数字、对象等数组。在 Firestorm 中定义数组就像在`Entity`文件中将属性指定为数组类型一样简单。例如:

```
class Example extends Entity {
  @field({ name: 'example_property_1' })
  property1!: string[]; @field({ name: 'example_property_2' })
  property2!: IDocumentRef<AnotherEntity>[];
}
```

## 嵌套数据

Firestore 文档可以包含嵌套对象(或地图)。对于嵌套对象，您需要创建一个新的类来表示该对象，并在您的`Entity`中添加一个带有该类的属性，用`@map`装饰器包装。

```
class Example extends Entity {
  @map({ name: 'nested_object' })
  nestedObject!: Nested;
}class Nested {
  @field({ name: 'nested_property' })
  nestedProperty!: string;
}
```

然后使用这个实体:

```
...
const nested = new Nested();
nested.nestedProperty = 'test';
const example = new Example();
example.nestedObject = nested;
...
```

## 地理点

地理点存储位置数据，可用于野外。我们为 Firestore 的 GeoPoint 提供了一个包装类，它基本上提供相同的功能。

```
class Example extends Entity {
  @geopoint({
    name: 'geopoint_property',
  })
  geopoint!: IGeoPoint;
}
```

然后指定一个地理点:

```
...
  const example = new Example();
  example.geopoint = new Geopoint(latitude, longitude);
...
```

## 时间戳

您可以在您的`Entity`文件中表示日期和时间数据。像 GeoPoints 一样，我们的时间戳表示本质上是 Firestore 的包装。您可以将该字段的选项设置为`updateOnWrite`，它在创建或更新文档时使用服务器时间戳，或者使用`updateOnCreate`或`updateOnUpdate`。

```
class Example extends Entity {
  @timestamp({
    name: 'timestamp_property',
    updateOnWrite: true,
  })
  timestamp!: ITimestamp;
}
```

# 重要问题

*   根集合、子集合和嵌套映射的所有文件都必须有一个唯一的类名，这是由于元数据存储将所有内容联系在一起的方式。我们正在寻找解决这个问题的方法。
*   确保地理点、时间戳和文档参考等字段的类型前面有`I`，例如`IDocumentRef`、`ITimestamp`、`IGeoPoint`。

# 限制

*   目前不支持使用快照监听文档更新
*   目前不支持事务和批量写入
*   不支持脱机存在

# 包扎

这应该足够让你开始了。有关更多信息，请查看 [Github](https://github.com/lmcq/firebase-firestorm) 上的回购协议，或查看[文档](https://lmcq.github.io/firebase-firestorm/)。