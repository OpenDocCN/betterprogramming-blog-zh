<html>
<head>
<title>How I Automated Database Schema Migrations in a Multi-Tenant Database Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在多租户数据库模型中自动化数据库模式迁移</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-automated-database-schema-migrations-in-a-multi-tenant-database-model-using-liquibase-f75f9683ee06?source=collection_archive---------1-----------------------#2020-10-10">https://betterprogramming.pub/how-i-automated-database-schema-migrations-in-a-multi-tenant-database-model-using-liquibase-f75f9683ee06?source=collection_archive---------1-----------------------#2020-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a998" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">我如何使用Liquibase、Docker、Gradle、Jenkins和Shell脚本在PostgreSQL数据库中自动化数据库模式迁移</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/591da034adda6711b5fc18c8a4f2d674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IVnh54J60OozcAGs"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@_imkiran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sai Kiran Anagani </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="620b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我目前正在开发的一个应用程序中，有一个将数据库迁移到管道中的自动化需求。我们的数据库模型基于多租户数据库设计。这意味着在同一个数据库中，您可以找到许多模式。数据库结构将如下所示。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi lt"><img src="../Images/f2d55a2524fb6db21a406c9334a925c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DlKpMFWVp395-Yif_69DwQ.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><strong class="bd lu">多租户数据库模型</strong></p></figure><p id="19c3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当需要进行数据库迁移时，我们通常针对每个模式运行迁移脚本，这是一项繁琐的任务。</p><p id="e1d2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，假设我们要添加一个新列，<strong class="kz ir"> </strong> <code class="fe lv lw lx ly b">column_A</code>到<code class="fe lv lw lx ly b">table_1</code>。为此，我们应该编写以下SQL语句。</p><pre class="kh ki kj kk gt lz ly ma mb aw mc bi"><span id="799c" class="md me iq ly b gy mf mg l mh mi">Alter table table_1 Add Column column_A varchar(255)</span></pre><p id="2d52" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为我们使用多租户数据库设计，所以需要对数据库中的每个模式进行相同的更改，因为每个模式中都有<code class="fe lv lw lx ly b">table_1</code>。</p><p id="6a40" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，我们开始使用如下所示的PL/PGSQL脚本来完成这项工作。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7b8d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将根据数据库中的每个模式更新我们的DB更改。然而，这必须手动完成。如果我们能够将它与我们的构建管道集成，将会节省很多时间。</p><p id="db3b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，我想到手动实现一个解决方案。但是我在网上搜索了一个已经为我解决了这个问题的解决方案。然后我就有了一个叫做<a class="ae kw" href="https://www.liquibase.org/" rel="noopener ugc nofollow" target="_blank"> Liquibase </a>的东西。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="8aca" class="ms me iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">为什么使用Liquibase而不是手动解决方案</h1><p id="64c1" class="pw-post-body-paragraph kx ky iq kz b la nj jr lc ld nk ju lf lg nl li lj lk nm lm ln lo nn lq lr ls ij bi translated">使用Liquibase代替手动解决方案的主要好处是可以获得支持。由于Liquibase库在全世界已经被下载了超过3000万次，当出现问题时，可以很容易地找到解决方案。</p><p id="10cf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">而Liquibase社区版(免费版)几乎支持我们所有的需求。按照现在的情况，没有必要使用专业版。pro版本的一个主要好处是Liquibase本身的直接支持。但由于Liquibase在开发人员社区中很受欢迎，大多数时候只需在网上查找就能找到解决方案。</p><h2 id="925d" class="md me iq bd mt no np dn mx nq nr dp nb lg ns nt nd lk nu nv nf lo nw nx nh ny bi translated">Liquibase的工作原理</h2><p id="60e0" class="pw-post-body-paragraph kx ky iq kz b la nj jr lc ld nk ju lf lg nl li lj lk nm lm ln lo nn lq lr ls ij bi translated">Liquibase管理一个叫做<code class="fe lv lw lx ly b">changelog</code>的文件。看起来是这样的。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d0b7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以向这个<code class="fe lv lw lx ly b">changelog</code>文件添加任意数量的<code class="fe lv lw lx ly b">changesets</code>，如上面的代码片段所示。</p><p id="4095" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当您从Liquibase运行<code class="fe lv lw lx ly b">update</code>命令时，它将更新您的数据库中的特定数据库模式。(我们如何运行<code class="fe lv lw lx ly b">update</code>将在后面讨论)。</p><p id="59cd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<code class="fe lv lw lx ly b">changelog</code>文件中，<code class="fe lv lw lx ly b">--changeset author.name::tracking_number</code>是重要的。通过这个SQL注释，Liquibase识别出它是一个新的<code class="fe lv lw lx ly b">changeset</code>。Liquibase在一个名为<code class="fe lv lw lx ly b">databasechangelog</code>的表中跟踪这些<code class="fe lv lw lx ly b">changesets</code>。你可以通过下面的链接找到更多关于<code class="fe lv lw lx ly b">databasechangelog</code>表和Liquibase如何工作的信息。</p><div class="nz oa gp gr ob oc"><a href="https://www.liquibase.org/get-started/how-liquibase-works" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">开始使用Liquibase如何工作| Liquibase.org</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Liquibase使用一个changelog来显式地按顺序列出数据库更改。变更日志充当变更的分类帐，并且…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">www.liquibase.org</p></div></div><div class="ol l"><div class="om l on oo op ol oq kq oc"/></div></div></a></div><p id="6000" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">通过与上表比较，Liquibase可以识别应该运行的新<code class="fe lv lw lx ly b">changesets</code>和已经执行的。</p><p id="9432" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">除了<code class="fe lv lw lx ly b">databasechangelog</code>表，Liquibase还在DB模式中维护了另一个表，用于同步目的。那叫<code class="fe lv lw lx ly b">databasechangeloglock</code>。如果您针对您的模式并行运行迁移脚本，这个表会很方便。</p><p id="11d6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">Liquibase只是一个Java库。如果您使用<a class="ae kw" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>作为构建工具，您可以在您的<code class="fe lv lw lx ly b">build.gradle</code>文件中添加Liquibase依赖项，或者如果您使用<a class="ae kw" href="http://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> Maven </a>，您可以在您的<code class="fe lv lw lx ly b">pom.xml</code>文件中添加liqui base依赖项。我将解释这应该如何集成到Gradle任务中，因为我们使用Gradle作为我们的构建工具。Liquibase官方文档描述了如果使用Maven作为构建工具，如何在Maven中集成Liquibase。</p><div class="nz oa gp gr ob oc"><a href="https://docs.liquibase.com/tools-integrations/maven/home.html" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">专家</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">Liquibase可以通过一个Maven插件来控制，这个插件可以从中央Maven存储库中获得。你可以找到…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">docs.liquibase.com</p></div></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="f364" class="ms me iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">如何将Liquibase更新作为梯度任务运行</h1><p id="4c1f" class="pw-post-body-paragraph kx ky iq kz b la nj jr lc ld nk ju lf lg nl li lj lk nm lm ln lo nn lq lr ls ij bi translated">以下代码片段显示了如何在<code class="fe lv lw lx ly b">build.gradle</code>文件中使用Liquibase。</p><ol class=""><li id="8e62" class="or os iq kz b la lb ld le lg ot lk ou lo ov ls ow ox oy oz bi translated">添加Liquibase作为依赖项，并将其作为插件应用。</li></ol><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="d43b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">2.定义一个Gradle任务来运行Liquibase <code class="fe lv lw lx ly b">update</code>作为构建的一部分。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a719" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您可以在<code class="fe lv lw lx ly b">activities</code>块中添加任意数量的DB模式来运行<code class="fe lv lw lx ly b">changesets</code>。这里我添加了两个模式。您必须提供<code class="fe lv lw lx ly b">changelog</code>文件路径、数据库模式URL、数据库用户名和数据库密码作为Liquibase属性。(像我在这里所做的那样将<code class="fe lv lw lx ly b">username</code>和<code class="fe lv lw lx ly b">password</code>存放在户外不是一个好习惯。您应该将这些凭证存储在类似AWS参数存储的地方。这是如何做到的将在后面讨论。)</p><p id="bf62" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当您构建项目时，<code class="fe lv lw lx ly b">dev</code>任务将会运行，并且由于build <code class="fe lv lw lx ly b">dependsOn</code>既有<code class="fe lv lw lx ly b">dev</code>任务又有<code class="fe lv lw lx ly b">update</code>任务，Liquibase <code class="fe lv lw lx ly b">update</code>命令也将作为Gradle任务的一部分运行。</p><p id="9095" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后通过查看DB模式中的<code class="fe lv lw lx ly b">databasechangelock</code>表，您可以确保<code class="fe lv lw lx ly b">changesets</code>已经运行。新的一行应该已经添加到<code class="fe lv lw lx ly b">databasechangelock</code>表中。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi pa"><img src="../Images/f211af4dacaffaf5c82567c278d0e30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zf6rmxS1iGDtOrC9xKcHxg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated"><strong class="bd lu">grad le任务已成功运行</strong></p></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="20ed" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这样做了之后，需求就改变了。该要求坚持认为，这一进程应包括在詹金斯管道。所以我从Gradle构建中删除了这个任务，并把它放到了<code class="fe lv lw lx ly b">Jenkinsfile</code>中。</p><p id="4327" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你还不知道什么是<code class="fe lv lw lx ly b">Jenkinsfile</code>，下面的教程会给你一个很好的概述。</p><div class="nz oa gp gr ob oc"><a href="https://www.jenkins.io/doc/book/pipeline/jenkinsfile/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">使用Jenkinsfile</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">本节以《Pipeline入门》中介绍的信息为基础，介绍了更多有用的步骤…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">www.jenkins.io</p></div></div><div class="ol l"><div class="pb l on oo op ol oq kq oc"/></div></div></a></div><p id="c7fd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe lv lw lx ly b">Jenkinsfile</code>使用<a class="ae kw" href="https://groovy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Groovy </a>来定义管道中应该做什么。您可以在<code class="fe lv lw lx ly b">Jenkinsfile</code>中定义阶段来运行不同的程序。例如，您可以定义一个阶段来构建您的代码。然后，您可以定义另一个阶段来将您的代码部署到服务器。你可以通过我上面提到的Jenkins官方网站找到如何做到这一点。</p><p id="af23" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以我的第一个方法是在Jenkins运行的Linux EC2实例中安装Liquibase，并编写一个shell脚本来更新DB模式。但是这是不可能的，因为这个Jenkins设置是由第三方供应商创建的，他们不愿意给我<code class="fe lv lw lx ly b">pem</code>文件来访问特定的EC2实例。没有通过<code class="fe lv lw lx ly b">ssh</code>访问EC2机器，我不得不寻找另一种方法从<code class="fe lv lw lx ly b">Jenkinsfile</code>运行Liquibase，而不在机器上安装Liquibase。</p><p id="d282" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后我发现Liquibase有自己的Docker镜像。您可以使用Docker映像运行任何Liquibase命令。您应该提供<code class="fe lv lw lx ly b">changelog</code>文件和凭证来访问数据库。对于一个<a class="ae kw" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a> DB，可以这样做。</p><pre class="kh ki kj kk gt lz ly ma mb aw mc bi"><span id="3d3e" class="md me iq ly b gy mf mg l mh mi">docker run --rm -v &lt;PATH TO CHANGELOG DIR&gt;:/liquibase/changelog liquibase/liquibase --url="jdbc:postgresql://&lt;IP OR HOSTNAME&gt;:5432/&lt;DATABASE&gt;?currentSchema=&lt;SCHEMA NAME&gt;" --changeLogFile=/liquibase/changelog/&lt;CHANGELOG NAME ie: "changelog.xml"&gt; --username=&lt;USERNAME&gt; --password=&lt;PASSWORD&gt; update</span></pre><p id="fca1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的命令所做的是将<code class="fe lv lw lx ly b">&lt;PATH TO CHANGELOG DIR&gt;</code>挂载到Docker容器中的<code class="fe lv lw lx ly b">/liquibase/changelog</code>目录，并从那里运行命令。</p><p id="1ee0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，这更新了一个模式的更改。但是因为我的数据库模型是多租户的，所以应该为每个模式运行。我应该遍历数据库的每个模式。问题是从哪里获取模式和凭证。一个非常简单的方法是在<code class="fe lv lw lx ly b">Jenkinsfile</code>本身的环境变量中定义模式和DB凭证。然而，保持DB凭证公开并不是一个好的做法。正如我前面提到的，我可以很容易地将这些细节存储在AWS参数存储中。</p><p id="e58c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">您需要做的是使用AWS CLI从AWS参数存储中检索这些细节，并遍历模式，使用Liquibase Docker映像为每个模式运行DB迁移。可以通过使用Shell脚本来完成，如下所示。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="acfc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">上面的代码片段是实际<code class="fe lv lw lx ly b">Jenkinsfile</code>的一部分。第一阶段暂停管道，并询问用户是否希望在运行单元测试之前运行迁移。如果他们确认要运行迁移，则只运行第二阶段。否则，将跳过第二阶段。</p><p id="5ed0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第二阶段检查用户是否希望运行数据库迁移，并相应地运行Shell脚本。在这里，<code class="fe lv lw lx ly b">withAWS</code>属性的作用是使用凭证连接到特定的AWS帐户。然后使用AWS CLI从AWS参数存储中检索模式列表、用户名和密码。</p><p id="535a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，它遍历模式列表，并对每个模式执行<code class="fe lv lw lx ly b">liquibase update</code>命令。</p><p id="6b74" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在流程完成后，您可以通过查看<code class="fe lv lw lx ly b">databasechangelog</code>来验证更新是否已经正确运行。</p><p id="6785" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是在多租户数据库模型中自动化数据库迁移的一种方式。也许还有其他更有效的方法。也许Liquibase并不是一个好的解决方案。请在评论区告诉我你对此的建议和想法。我认为这可能在某种程度上帮助某人。</p><p id="bd98" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，由于这是我第一篇关于Medium的文章，所以可能还有很多东西我应该学习。我希望将来能写更多这样的文章，你对此的想法将是无价的。</p><p id="5b46" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="pc">感谢阅读！</em></p></div></div>    
</body>
</html>