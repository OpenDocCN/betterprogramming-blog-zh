<html>
<head>
<title>Integrate Node.js Client for Google Maps Services With a NestJS Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Google地图服务的Node.js客户端与NestJS应用程序集成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/integrate-nodejs-client-for-google-maps-services-with-a-nestjs-application-f1969d47a639?source=collection_archive---------6-----------------------#2022-01-10">https://betterprogramming.pub/integrate-nodejs-client-for-google-maps-services-with-a-nestjs-application-f1969d47a639?source=collection_archive---------6-----------------------#2022-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f23f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将Google地图服务的NodeJS客户端包装在NestJS应用程序中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e8bcf7b195880e37f32b62ec5596783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*itxM3IyicB9V_IPs"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@ilyapavlov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊利亚·巴甫洛夫</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="d47c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建一个NestJS应用程序时，一个常见的疑问是，实现某些功能的适当方式是否尊重框架架构，以充分利用它提供的可伸缩性。</p><p id="0cc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文的主要目标是提出一种方法，将Google Maps服务的NodeJS客户端封装在一个NestJS模块中，并使用依赖注入使其易于跨应用程序重用。尽管本文特别使用了<code class="fe ls lt lu lv b"><a class="ae kv" href="https://www.npmjs.com/package/@googlemaps/google-maps-services-js" rel="noopener ugc nofollow" target="_blank">@googlemaps/google-maps-service-js</a></code> npm包，但它也可以作为其他基于客户端的外部服务的灵感。</p><h1 id="4e5e" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">NestJS框架</h1><p id="d21d" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">NestJS是一个用于创建可伸缩和松散耦合的服务器端NodeJS应用程序的框架。它的主要特征之一是实现的架构和目录结构，这加强了应用程序的模块化性质。最重要的是，NestJS完全支持TypeScript，并且还可以在幕后与<a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>和<a class="ae kv" href="https://github.com/fastify/fastify" rel="noopener ugc nofollow" target="_blank"> Fastify </a>一起工作，这使得它成为一个最新的、可行的替代框架，用于使用众所周知的工具构建可靠的web服务器。</p><h1 id="004c" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">框架体系结构</h1><p id="8217" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">正如<a class="ae kv" href="https://docs.nestjs.com/#philosophy" rel="noopener ugc nofollow" target="_blank"> NestJS文档</a>中所述，其架构深受Angular架构的启发。文件夹结构基本上组织在模块中，这些模块表示绑定应用程序特定上下文的某个实体。每个模块通常由文件<code class="fe ls lt lu lv b">app.module.ts</code>、<code class="fe ls lt lu lv b">app.controller.ts</code>和<code class="fe ls lt lu lv b">app.service.ts</code>组成。模块的常见文件夹结构如下所示:</p><pre class="kg kh ki kj gt mt lv mu mv aw mw bi"><span id="7bcd" class="mx lx iq lv b gy my mz l na nb">google-maps<br/>| — google-maps.controller.ts<br/>| — google-maps.module.ts<br/>| — google-maps.service.ts</span></pre><h1 id="a353" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Google地图服务的Node.js客户端</h1><p id="4773" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">google maps服务的<a class="ae kv" href="https://github.com/googlemaps/google-maps-services-js" rel="noopener ugc nofollow" target="_blank">客户端是一个库，创建它是为了与Google </a>提供的<a class="ae kv" href="https://developers.google.com/maps/apis-by-platform#web_service_apis" rel="noopener ugc nofollow" target="_blank"> Web API直接从给定项目的编程语言进行交互，在本例中，是带有NodeJS的TypeScript。</a></p><p id="10f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于<code class="fe ls lt lu lv b"><a class="ae kv" href="https://www.npmjs.com/package/@googlemaps/google-maps-services-js" rel="noopener ugc nofollow" target="_blank">@googlemaps/google-maps-service-js</a></code> npm包提供了许多重复使用的方法和类，在该服务中使用依赖注入的一种方式是将google maps服务客户端封装在模块类的getter方法中，以及最常用的方法中，以便更好地服务于应用程序。</p><h1 id="409a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">将库包装在模块中</h1><p id="0be0" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated"><code class="fe ls lt lu lv b">google-maps</code>模块文件夹由一个<code class="fe ls lt lu lv b">module.ts</code>文件和一个service.ts文件组成，其中包含一个客户端getter和其他最常用的方法。该服务将如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述代码由以下功能组成，使用了<a class="ae kv" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> OOP </a>方法:</p><ul class=""><li id="5363" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe ls lt lu lv b">GoogleMapsService</code>类扩展了默认的<code class="fe ls lt lu lv b">Client</code>类，并调用super()方法来实例化它，以便使用它的所有方法和属性；</li><li id="7374" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">声明一个私有属性来存储访问google api服务所需的访问密钥；</li><li id="85e0" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">出于安全原因，使用内置的NestJS服务<code class="fe ls lt lu lv b">ConfigService</code>从环境变量中检索accessKey</li><li id="c5d1" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">在这个例子中，定义了一个名为<code class="fe ls lt lu lv b">getCoordinates</code>的异步方法，使用。与其相关的<a class="ae kv" href="https://developers.google.com/maps/documentation/geocoding/overview" rel="noopener ugc nofollow" target="_blank"> web服务API</a>通信的地理编码方法；</li><li id="09fc" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">假设应用程序使用的是TypeScript，包还为库提供了自定义类型，因此可以为创建为LatLngLiteral的方法定义返回值的类型。</li></ul><p id="7efb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述服务的整个结构在NestJS文档中的<a class="ae kv" href="https://docs.nestjs.com/providers#services" rel="noopener ugc nofollow" target="_blank">专用部分有很好的描述。</a></p><p id="1468" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于本文中描述的应用程序没有提供任何外部路由来与上面提供的服务进行交互，因此没有controller.ts文件来处理外部请求。</p><p id="fc7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">至于模块文件，它负责绑定与给定上下文相关的所有文件，并被注入到其他模块中。在<a class="ae kv" href="https://docs.nestjs.com/modules" rel="noopener ugc nofollow" target="_blank"> NestJS文档</a>中可以找到更多关于这部分的内容。<code class="fe ls lt lu lv b">google-maps.module.ts</code>看起来如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a665" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码将创建的服务定义为提供者，并将其导出，以便可以在其他模块中重用。</p><h1 id="26fd" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">依赖注入</h1><p id="2660" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">最后，需要在使用google-maps服务的模块内部声明创建的google-maps模块，然后在使用google-maps服务方法的类上使用依赖注入。其他模块如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9e59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，对于服务级别的DI:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c0dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码使用NestJS依赖注入格式来使用创建的google-maps服务，还使用google-maps类型来定义<code class="fe ls lt lu lv b">getAddressCoords</code>方法的返回值。</p><h1 id="0e18" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="8248" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如前所述，在具有多个实体范围的可伸缩应用程序中以模块化的方式编写代码是很有趣的。</p><p id="c7b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到所描述的场景，本文中的应用程序展示了一种模块化外部服务的方法，使代码更具可重用性，并将上下文相关的方法和值集中在同一个模块中。</p></div></div>    
</body>
</html>