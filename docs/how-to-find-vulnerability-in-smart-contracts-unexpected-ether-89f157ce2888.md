# 如何发现智能合同中的漏洞—意想不到的以太

> 原文：<https://betterprogramming.pub/how-to-find-vulnerability-in-smart-contracts-unexpected-ether-89f157ce2888>

## 黑掉一个游戏智能合约，学习其防范措施

![](img/863624365aabec6a6bc56d231e37e354.png)

图片来源:[静止不动](https://unsplash.com/@stillnes_in_motion)

通常，当您向协定发送 ether 时，它必须执行回退函数或协定中定义的另一个函数。这里有两个例外，ether 可以存在于一个契约中而不执行任何代码。依赖于发送给它们的所有以太网的代码执行的协定在以太网被强制发送的情况下容易受到攻击。

# 🔓漏洞

一种典型的防御性编程技术是*不变量检查*，这种技术在强制执行正确的状态转换或验证操作方面很有价值。这种方法包括定义一组不变量(不需要改变的度量或参数),并检查它们在一次(或多次)操作后不会改变。不变量的一个例子是`totalSupply`固定发行 [ERC20 令牌](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md)。因为任何函数都不应该改变这个不变量。

特别是，有一个显而易见的不变量可能很容易使用，但实际上可能被外部用户操纵(尽管智能合约中规定了规则)。这是合同中存储的当前乙醚。通常，当开发人员第一次了解可靠性时，他们会有一个误解，认为契约只能通过可支付函数来接受。这种误解会导致契约对其中的以太平衡有错误的假设，从而导致各种漏洞。这个漏洞的关键是`this.balance`的(不正确)使用。

有两种方法可以(强制)将以太发送到不使用 payable 函数或不执行契约上任何代码的契约:

## 1.自毁

每个契约将能够执行`selfdestruct`功能，从契约地址中删除所有字节码，并将存储在那里的所有以太网发送到参数指定的地址。如果指定的地址也是协定，则不会调用任何函数(包括回退)。因此，`selfdestruct`函数可以被强制发送以太到任何契约，而不管该契约中可能存在的任何代码，甚至是没有可支付函数的契约。这意味着攻击者可以创建一个具有`selfdestruct`功能的契约，向它发送以太，调用`selfdestruct(target)`并强制以太被发送到`target`契约。

## 2.当前乙醚

另一种让以太进入契约的方法是用以太预加载契约地址。协定地址是确定性的—事实上，该地址是根据创建协定的地址的 Keccak-256(类似于 SHA-3)哈希和创建协定的事务随机数计算出来的。具体来说，它的形式如下:

```
address = sha3(rlp.encode([account_address,transaction_nonce]))
```

让我们探讨一下在这种情况下可能出现的一些陷阱。考虑一下`EtherGame.sol`中过于简单的契约。

这个契约代表一个简单的游戏(自然会涉及比赛条件)，玩家向契约发送 0.5 以太，希望自己成为第一个到达三个里程碑之一的玩家。里程碑以以太命名。第一个到达里程碑的人可以在游戏结束后分享以太。当到达 10 以太的最后一个里程碑时，游戏结束；用户可以要求他们的奖励。

`EtherGame`合同的问题来自于`this.balance`14 号线和 32 号线的不良使用。攻击者可以通过`selfdestruct`函数(前面已经讨论过)强制发送少量乙醚(比如 0.1 乙醚)来阻止任何未来的玩家到达里程碑。`this.balance`由于这 0.1 以太的贡献，永远不会是 0.5 以太的倍数，因为所有合法玩家只能发送 0.5 以太的增量。这防止了第 18、21 和 24 行上的所有‘if’条件为真。

更糟糕的是，错过一个里程碑的攻击者可以强行送出 10 个以太(或者等量的将契约平衡转移到`finalMileStone`以上的以太)，可以永远锁定契约中的所有奖励。这是因为由于第 32 行上的需求(即，因为`this.balance`大于`finalMileStone`，所以`claimReward`功能将总是恢复。

# 预防技术

这种漏洞通常是由于滥用`this.balance`而产生的。如果可能，合同逻辑应该防止依赖合同余额的精确值，因为它可以被人为操纵。如果应用基于`this.balance`的逻辑，您将不得不处理意外的余额。

如果需要沉积乙醚的精确量，应使用自定义变量，该变量在可支付函数中递增，以安全地跟踪沉积乙醚。该变量不受通过`selfdestruct`调用发送的强制以太网的影响。

考虑到这一点，修正后的`EtherGame`契约看起来可能是这样的:

在这里，我们创建了一个新变量`depositedWei`，它跟踪已知的乙醚沉积，我们在测试中使用的就是这个变量。请注意，我们不再引用`this.balance`。

如果还没有，请查看另一个漏洞“可重入性”:

[](/preventing-smart-contract-attacks-on-ethereum-a-code-analysis-bf95519b403a) [## 防止对以太坊的智能合约攻击——代码分析

### 让我们编写一个易受攻击的智能合约代码，看看攻击是如何工作的，并了解修复它的预防技术

better 编程. pub](/preventing-smart-contract-attacks-on-ethereum-a-code-analysis-bf95519b403a)