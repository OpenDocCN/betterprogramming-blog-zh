<html>
<head>
<title>Django Model Decorators — Tips and Tricks With Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django模型装饰者——实现的技巧和诀窍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/django-model-decorators-tips-and-tricks-with-implementation-c4c027d24a7f?source=collection_archive---------3-----------------------#2022-03-17">https://betterprogramming.pub/django-model-decorators-tips-and-tricks-with-implementation-c4c027d24a7f?source=collection_archive---------3-----------------------#2022-03-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="83e1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习一次性编写功能，并在模型或应用程序之间共享</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/415a76a2214846bb51a74be7e9813bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7pLMXzxINiAXX0Yokk4qw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@stephen2520?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯蒂芬·汉密尔顿</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="5421" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动机和路线图</h1><p id="9c52" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们打算将功能应用于Django模型，该模型可以被复制并容易地应用于多个模型。我们将讨论一些示例，并通过执行以下操作来解决这些问题:</p><ol class=""><li id="582e" class="mk ml iq lq b lr mm lu mn lx mo mb mp mf mq mj mr ms mt mu bi translated">向模型中添加字段</li><li id="594d" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">向模型添加属性</li><li id="57ea" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj mr ms mt mu bi translated">添加一个工厂装饰器，附加一个默认的serialiser供REST框架使用</li></ol><p id="95c1" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">在我们开始解决上述问题之前，让我们快速刷新一下关于decorators和Django模型的几个要点。如果您对这些完全满意，请随意跳过。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/2bb5664175582e0aa99a882487c8b86f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6iJ0VpOvF8Iq0gGX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@sincerelymedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">真诚媒体</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="81a3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">装修工:复习</h1><p id="eaa6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">装饰器是应用于函数(或类)的函数，导致丰富的功能。本质上，它们是将函数应用于函数的语法糖，将一个函数“包装”到另一个函数中。</p><p id="7e64" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">有很多关于装饰者的教程解释了他们是如何工作的，所以要深入理解请参考这些。</p><p id="9dbc" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">为了这篇文章，我们将强调理解一个非常重要的部分:装饰者作用于函数/类，在它们周围放置一个层。</p><p id="1f5e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">看看这个装饰器，它在被包装的函数执行之前和之后起作用。然后查看如何使用它的两个等价选项。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2ac3" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">运行任何一个都会产生相同的输出，如下所示:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="46af" class="nl kx iq nh b gy nm nn l no np">In [2]: func1("Hello World!") # same for func2(...)<br/>I cam do something before the function call!<br/>Hello World!<br/>I can do something after the function call!</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a073428306c6bd94b8414858397edc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ElApl1m-4wON1SPhzVoJTA.png"/></div></figure><h1 id="13f5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Django模型</h1><p id="37de" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Django模型被定义为用于定义数据库结构以及提供底层数据库的抽象接口的类。当这些被使用时，例如在进行迁移时，后台会发生相当多的“奇迹”。我们将了解其中一些是如何工作的。</p><p id="8c8e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">请看这个例子:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="580f" class="nl kx iq nh b gy nm nn l no np">from django.db import models</span><span id="c94f" class="nl kx iq nh b gy nr nn l no np">class DummyModel(models.Model):<br/>    number = models.IntegerField()</span></pre><p id="7960" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这将在您的数据库中生成一个带有整数列和ID(.pk)当然。</p><h1 id="fda2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.向模型中添加字段</h1><p id="6ec2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设我们想在模型上放置一个字段，如何在装饰器中实现呢？对于一个简单的类，这将是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b5af" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">如果你尝试用Django模型来做这件事，那它就不起作用了！没有抛出错误，但是也没有发生任何事情。例如，使用以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="979c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">等同于上述，文本字段<code class="fe ns nt nu nh b">1</code>不会被创建，也不会被添加到数据库中。但这是为什么呢？</p><p id="f98a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">模型的创建不仅仅是向Python类添加成员:神奇的事情发生在使用field对象的<code class="fe ns nt nu nh b">contribute_to_class</code>方法时。让我们看看它是如何工作的，以及我们应该对上面的代码片段做些什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="909c" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这就是我们想要它做的:在模型上创建一个UUID字段，它也将出现在迁移中。</p><p id="4fd2" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这是使用抽象模型类从派生的替代方法，是为程序员提供的一种选择。让我们看看我们还能为这些装饰者做些什么。</p><h1 id="63aa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.向模型添加属性和额外功能</h1><p id="a3bb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设有一些功能，比如您想要添加到多个模型中的公共派生参数。让我们看看如何用属性来扩展上述内容。</p><p id="c02e" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">例如，如果您想要跟踪模型的创建和更改时间，并知道模型在数据库中的年龄，那么您可以执行以下操作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="8c31" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这将对模型应用创建日期和修改时间字段。创建日期是在创建时记录的，以后不能更改，而修改时间是在每次模型发生变化时更新的。</p><p id="3cbb" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">更新时间的一个注意事项是，它仅适用于Python代码更改模型，不适用于在数据库上评估直接SQL的情况[1]。这是由于Django处理变化和触发信号的方式[2]。</p><p id="c881" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">模型的年龄是一个派生参数，取决于当前时间，因此它作为模型对象的一个属性来实现。</p><p id="0103" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">为了清楚起见，这相当于将这些字段和属性直接写入类中(也参见[1]):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="a707" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated"><em class="nv"> n.b. </em>这个设计也是一个选择，也有其他方法可以达到同样的结果，例如创建一个抽象模型类来派生(可能使用多个继承)。这种选择可能会使代码更加易读和优雅。</p><h1 id="6cd0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.为模型创建一个通用且简单的序列化程序</h1><p id="d1a6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在使用REST框架的情况下，可能需要许多序列化器，其中一些非常简单和相似。这里有一个技巧来添加一个默认的简单串行器到模型中，可以和它们一起导入。这或多或少有点像序列化工厂</p><p id="4f4d" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">下面是一个简单的序列化器，可以为模型反复创建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3c34" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">大约两年后，应该创建一个工厂函数，为任何给定的模型创建序列化程序。我们也可以用模型本身的装饰器来做这件事:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="35c0" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">这可以以多种方式扩展，例如提供通用的APIViews，或者在被许多模型使用的情况下向它们添加更多的功能。</p><h1 id="9b3c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="a6a6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经看到了如何将decorators应用到Django模型中，释放各种各样的Pythonic功能。在大多数情况下，这些是人们可以做出的选择，或者决定以不同的方式获得类似的结果。</p><p id="35bb" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx na lz ma mb nb md me mf nc mh mi mj ij bi translated">非常感谢您阅读这篇文章。希望你学到了或者看到了新的东西！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/07e24c5637bd821e5219877e9caf25a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rluW8a0NBmAFVO1J"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@michelleding?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米歇尔丁</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><h2 id="4ddc" class="nl kx iq bd ky nx ny dn lc nz oa dp lg lx ob oc li mb od oe lk mf of og lm oh bi translated">参考资料:</h2><ul class=""><li id="61c9" class="mk ml iq lq b lr ls lu lv lx oi mb oj mf ok mj ol ms mt mu bi translated">[1]<a class="ae kv" href="https://stackoverflow.com/questions/3429878/automatic-creation-date-for-django-model-form-objects" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/3429878/automatic-creation-date-for-django-model-form-objects</a></li><li id="3ce6" class="mk ml iq lq b lr mv lu mw lx mx mb my mf mz mj ol ms mt mu bi translated">[2]<a class="ae kv" href="https://docs.djangoproject.com/en/3.2/ref/signals/#pre-save" rel="noopener ugc nofollow" target="_blank">https://docs.djangoproject.com/en/3.2/ref/signals/#pre-save</a></li></ul></div></div>    
</body>
</html>