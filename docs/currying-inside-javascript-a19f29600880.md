# JavaScript 中的 Currying

> 原文：<https://betterprogramming.pub/currying-inside-javascript-a19f29600880>

## 适用于任何地方的概念

![](img/67c4091d6d1b20d7fa05293854041b08.png)

照片由[émile Perron](https://unsplash.com/@emilep?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

**Currying** 是处理函数时的一种高级技术，在多种编程语言中都有使用。

当你把一个接受多个参数的函数分解成一系列嵌套函数时，你就有了一个*库里*。每个嵌套函数都应该有函数的下一个参数。

curry 函数每次都会返回一个新函数，直到每次调用都收到所有的参数。这些参数可以贯穿整个闭包过程，并将全部用于执行最终的函数。

一个非常基本的例子是这样的:

要使用它，您可以多次调用该函数，直到它到达最后一个函数:

所以现在发生的是`combineWords`是一个固化的函数(很明显),在它执行系列中的下一个函数之前等待一个单词。您可以将`'wow!'`到`combineWords`绑定到一个变量，并重用它来创建其他以`'wow!'`开头的问候语:

如果这个概念有点难以理解，可以试着这样理解:“母亲在烹饪前期待所有四个鸡蛋(论点)，她的四个孩子将每人拿一个给她，一次一个。”

对于要调用的`cook`回调，需要一个接一个地传入所有四个鸡蛋，每个鸡蛋都预先填充下一个函数，等待调用。

如果你停在第三个蛋上:

然后，由于还没有到达期望的最后一个函数`egg4`，所以`collect`的值就是那个函数:

为了完成咖喱，收集最后一个鸡蛋:

```
let collect = start(new Egg())
collect = collect(new Egg())
collect = collect(new Egg())
collect = collect(new Egg())*// collect === 'served'*
```

现在，重要的是要知道每个嵌套函数都可以访问 curry 函数的外部作用域。了解了这一点，您就可以在每个嵌套函数之间提供定制逻辑，以适应特定的情况。但是最好留下一个咖喱作为咖喱，不要其他的。

更高级的 curry 函数可以如下图。我将提供一个`ES5`版本和一个`ES6`版本，因为有很多展示 ES5 语法的旧教程，对于新的 JavaScript 开发人员来说可能有点难以阅读。

ES5:

ES6:

让我们更详细地解释这个例子。

当您调用`curry(fn)`时，它将返回内部的`curried`函数，该函数将在调用时等待下一个参数。当你调用这个内部函数时，它会计算两个条件:

1.  调用者传入的参数是否足够满足`fn`的所有参数？
2.  还是仍然缺少`fn`需要的参数？

如果*1*是这种情况，我们就有了`fn`声明的所有我们需要的参数，库里将通过返回对`fn`的调用并将所有收到的参数传递给它(现在基本上正常调用`fn`)来结束。

然而，如果*数字 2* 是这种情况，咖喱必须继续，我们必须以某种方式回到内部`curried`函数，以便我们可以继续接收更多的参数，直到它满足`fn`的参数。代码`return (...args2) => curried.apply(this, [...args, ...args2])`累积了到目前为止公开的所有参数，并使用它们继续这种情况下的搜索。

有一条重要的规则:

在等待收集所有参数之前要调用的函数必须有固定数量的参数。这意味着该函数不能有扩展参数(如`fn(...args)`)

例如:

# 结论

我认为咖喱是一个有趣的技术，因为创造一个咖喱涉及到其他先进的技术。这里涉及到闭包、高阶函数和递归。

这篇文章到此结束。我希望你找到了一些有价值的东西，并在未来寻找更多！