<html>
<head>
<title>Load Testing GraphQL Performance With k6 and StepZen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用k6和StepZen负载测试GraphQL性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/load-testing-graphql-performance-with-k6-and-stepzen-949e0e10c328?source=collection_archive---------19-----------------------#2022-06-27">https://betterprogramming.pub/load-testing-graphql-performance-with-k6-and-stepzen-949e0e10c328?source=collection_archive---------19-----------------------#2022-06-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f197" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简化负载测试的简要指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aaa541772f1233af015933cdce16ab31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*k0Q7ek5dPonFkyVN.png"/></div></div></figure><p id="c744" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于许多公司来说，性能是使用GraphQL的主要原因。但这是一个有效的论点吗？开发人员经常将GraphQL与REST APIs进行比较，并将N+1请求(或过度提取)视为选择GraphQL的一个重要原因。</p><p id="fe2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来测试一下，看看GraphQL APIs是否能超越现有的REST APIs。为此，我们将采用两个GraphQL化的REST API(IP-API和Frankfurter)并对GraphQL的性能进行负载测试，将GraphQL中的嵌套数据与原始REST API进行比较。</p><p id="1da4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用工具<a class="ae ln" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> k6 </a>，这是当今最流行的负载测试工具之一，来做这个性能测试。</p><h1 id="0fdb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">探索GraphQL API</h1><p id="c442" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们探索一个从REST API转换而来的StepZen GraphQL API。在这种情况下，我使用StepZen CLI将IP-API REST API转换为GraphQL，使用文档中的<a class="ae ln" href="https://stepzen.com/docs/quick-start/with-rest-import" rel="noopener ugc nofollow" target="_blank">指令</a>。这个免费的REST API允许您根据IP地址搜索位置。我们用StepZen图形化了<a class="ae ln" href="https://ip-api.com/" rel="noopener ugc nofollow" target="_blank"> IP-API </a> REST API，并用GraphiQL进行了探索。GraphiQL接口可以在<a class="ae ln" href="https://graphqldd.stepzen.net/api/dd1cf47f51ac830fe21dc00ec80cee65/__graphql?query=query%20GetLocation%20%7B%0A%20%20ipApi_location%28ip%3A%20%228.8.8.8%22%29%20%7B%0A%20%20%20%20ip%0A%20%20%20%20city%0A%20%20%20%20country%0A%20%20%7D%0A%7D%0A" rel="noopener ugc nofollow" target="_blank">这里</a>找到，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/9afb45fd4620db69759fa3d40bd4b03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4tuf5veAPMA58ME8.png"/></div></div></figure><p id="e0a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在屏幕的左侧看到发送给GraphQL API的查询，而右侧显示响应。它被命名为<code class="fe mm mn mo mp b">GetLocation</code>。建议命名查询，因为它有助于GraphQL APIs，例如，缓存。另外，请注意，响应与您请求的查询具有相同的形状。</p><p id="0a1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在研究了这个GraphQL API之后，让我们设置k6，以便在下一节中使用它来测试GraphQL。</p><h2 id="3848" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">将k6用于GraphQL</h2><p id="c79d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了对这个GraphQL API进行负载测试，我们将使用一个开源负载测试工具<a class="ae ln" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> k6 </a>。您可以在本地机器上运行k6，方法是从GitHub存储库安装或者使用k6的云产品。使用这个工具，您可以测试任何接受HTTP请求的API。您可以运行的最简单的测试是使用k6的<code class="fe mm mn mo mp b"><a class="ae ln" href="https://k6.io/docs/javascript-api/k6-http/post" rel="noopener ugc nofollow" target="_blank">http.post</a></code>函数。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="57b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个k6脚本现在可以使用查询来加载测试GraphQL API的性能。因为IP地址是静态的，所以k6会在你的性能测试中反复提出同样的请求。</p><p id="eb62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，由于GraphQL API将缓存结果，测试将变得不太现实，因为不同的用户在访问GraphQL API时将使用不同的IP地址。因此，您应该在GraphQL查询中使用动态变量。具有动态值<code class="fe mm mn mo mp b">ip</code>的相同查询将如下所示:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="5f32" class="mq lp iq mp b gy ni nj l nk nl">query GetLocation($ip: String!) {<br/>  ipApi_location(ip: $ip) {<br/>    ip<br/>    city<br/>    country<br/>  }<br/>}</span></pre><p id="4dee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当发送请求时，您需要在GraphQL查询旁边附加一个JSON对象，其中包含一个值为<code class="fe mm mn mo mp b">ip</code>。如果您访问<a class="ae ln" href="https://graphqldd.stepzen.net/api/dd1cf47f51ac830fe21dc00ec80cee65/__graphql?query=query%20GetLocation%28%24ip%3A%20String%21%29%20%7B%0A%20%20ipApi_location%28ip%3A%20%24ip%29%20%7B%0A%20%20%20%20ip%0A%20%20%20%20city%0A%20%20%20%20country%0A%20%20%7D%0A%7D%0A&amp;variables=%7B%0A%20%20%22ip%22%3A%20%228.8.8.8%22%0A%7D" rel="noopener ugc nofollow" target="_blank"> GraphiQL界面</a>，您可以使用“查询参数”选项卡:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/ec7c27c6a462b4da55264172e60f85c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Gulc5t7cExjr9uz6.png"/></div></div></figure><p id="b128" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用动态查询参数，您可以使用k6的<code class="fe mm mn mo mp b"><a class="ae ln" href="https://k6.io/docs/javascript-api/k6-http/batch/" rel="noopener ugc nofollow" target="_blank">http.batch</a></code>函数向GraphLQ API发送多个带有不同<code class="fe mm mn mo mp b">ip</code>值的请求，以模拟更真实的测试场景:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fe45" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行这个k6脚本将向GraphQL API发送一批具有不同IP地址的请求。这些请求是并行发送的，这比只发送一个请求更现实。你也可以创建一个IP地址数组，然后循环创建一个新的数组，传递给<code class="fe mm mn mo mp b">http.batch</code>函数。下一节将使用这些脚本用k6对这个GraphQL API进行性能测试。</p><h2 id="d00c" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">负载测试GraphQL查询</h2><p id="162f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">设置好k6脚本后，我们现在可以在GraphQL API上进行性能测试。我们可以运行两个测试，一个使用静态IP地址，另一个使用批量请求和动态IP地址。运行这些测试只需要你在本地机器上下载<a class="ae ln" href="https://k6.io/docs/getting-started/installation/" rel="noopener ugc nofollow" target="_blank"> k6并安装</a>，或者你应该有一个k6云账户。</p><p id="1f75" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要运行第一个测试，您需要将脚本保存在一个名为<code class="fe mm mn mo mp b">simple.js</code>的文件中，这样您就可以使用:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="4bda" class="mq lp iq mp b gy ni nj l nk nl">k6 run --vus 10 --duration 30s simple.js</span></pre><p id="94c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个命令用10个vu(虚拟用户)运行K6 30秒。要获得更多关于运行k6的信息，请点击<a class="ae ln" href="https://k6.io/docs/getting-started/running-k6/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/105101c140f2a084eb1f21418f72c04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*27lCqodgO0n4f71w.png"/></div></div></figure><p id="67de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果显示，GraphQL API在30秒内被点击了近2500次，平均持续时间为122毫秒。这非常接近于95%的所有请求的平均命中持续时间，意味着没有异常值。</p><p id="e47c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过查看结果，我们还可以测试运行在StepZen上的GraphQL API的可伸缩性。因此，我们需要仔细看看GraphQL API处理的迭代次数:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="4d33" class="mq lp iq mp b gy ni nj l nk nl">iterations.....................: 2472 82.082529/s</span></pre><p id="57f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们用10个并发vu运行k6脚本30秒时，您可以看到k6命中GraphQL API近2500次——或每秒82次。如果GraphQL API是完全可伸缩的，当我们将并发vu的数量增加到100时，它应该能够处理十倍以上的迭代。让我们试试这个:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="0b51" class="mq lp iq mp b gy ni nj l nk nl">k6 run --vus 100 --duration 30s simple.js</span></pre><p id="19c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将导致以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/cecdf8f07a8f0cc4690d34f7eef93bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G8y05BSFZ-yis-BM.png"/></div></div></figure><p id="be08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如对一个完美的可伸缩服务的预期，迭代次数不是820次而是798次，只有3%的差别。GraphQL API的可伸缩性并不完美，但已经非常接近完美了。</p><p id="ffa7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了用静态IP地址测试简单的查询之外，我们还可以通过将动态IP地址放在一个名为<code class="fe mm mn mo mp b">batch.js</code>的文件中来运行这个脚本:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="06d0" class="mq lp iq mp b gy ni nj l nk nl">k6 run --vus 10 --duration 30s batch.js</span></pre><p id="bc35" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个测试中对GraphQL API的迭代是成批发送的，这意味着每次迭代都会产生三个HTTP请求——这是添加到<code class="fe mm mn mo mp b">http.batch</code>函数的请求数。正如我们之前所了解的，GraphQL API几乎是完全可伸缩的。</p><p id="b6ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">GraphQL API在这个测试中可以处理的迭代次数应该大致相同，而HTTP请求的数量应该大三倍左右。当我运行测试时，迭代次数导致:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="75f5" class="mq lp iq mp b gy ni nj l nk nl">http_reqs......................: 7251   240.737555/s<br/>iteration_duration.............: avg=124.43ms min=116.53ms med=121.91ms max=509.1ms  p(90)=126.39ms p(95)=129.13ms<br/>iterations.....................: 2417   80.245852/s</span></pre><p id="078e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于2417个请求和2500个请求，迭代次数是相当的，HTTP请求的数量是迭代次数的三倍。</p><p id="912c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们知道k6可以测试GraphQL API的性能，并且graph QL API是可伸缩的。让我们在下一节测试一个更重的GraphQL查询。</p><h2 id="2961" class="mq lp iq bd lq mr ms dn lu mt mu dp ly la mv mw ma le mx my mc li mz na me nb bi translated">负载测试不同的数据源</h2><p id="18a0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">确定数据形状的能力并不是开发人员采用GraphQL作为API查询语言的唯一原因。GraphQL APIs只有一个端点，查询(或其他操作)也可以处理嵌套数据。您可以在一个请求中从不同的数据库表(如SQL连接)甚至不同的数据源请求数据。这与REST APIss不同，在REST API中，您通常必须访问多个端点才能从其他来源获取数据。</p><p id="ddfc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们正在测试的StepZen GraphQL API 的<a class="ae ln" href="https://graphqldd.stepzen.net/api/dd1cf47f51ac830fe21dc00ec80cee65/__graphql?query=query%20GetConversion%20%7B%0A%20%20frankfurter_latest_rates%28from%3A%20%22EUR%22%2C%20to%3A%20%22USD%22%29%20%7B%0A%20%20%20%20amount%0A%20%20%20%20base%0A%20%20%20%20date%0A%20%20%20%20rates%0A%20%20%7D%20%0A%7D%0A" rel="noopener ugc nofollow" target="_blank">graph QL接口中，您可以探索其他可用的查询。其中一个查询将从</a><a class="ae ln" href="https://www.frankfurter.app/" rel="noopener ugc nofollow" target="_blank"> Frankfurter </a> REST API获取数据，REST API是一个包含欧洲央行发布的当前和历史汇率数据的开源API。</p><p id="d162" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个REST API使用StepZen以与IP-API相同的方式转换为GraphQL。要获得欧元对美元的当前兑换率，您可以查询:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="26fa" class="mq lp iq mp b gy ni nj l nk nl">query GetConversion {<br/>  frankfurter_latest_rates(from: "EUR", to: "USD") {<br/>    amoun<br/>    base<br/>    date<br/>    rates<br/>  }<br/>}</span></pre><p id="dd47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的查询获得了当前日期从1欧元到美元的汇率。因为这个API的模式是来自IP-API和Frankfurter的数据的组合，所以您可以做更多的事情。使用这种组合，您可以根据IP地址获得当前位置，并将该位置的本地货币转换为美元。</p><p id="bcfc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该货币转换可在字段<code class="fe mm mn mo mp b">priceInCountry</code>中获得。您可以通过访问<a class="ae ln" href="https://graphqldd.stepzen.net/api/dd1cf47f51ac830fe21dc00ec80cee65/__graphql?query=query%20GetConversion%28%24ip%3A%20String%21%2C%20%24amount%3A%20Float%21%2C%20%24from%3A%20String%21%29%20%7B%0A%20%20ipApi_location%28ip%3A%20%24ip%29%20%7B%0A%20%20%20%20ip%0A%20%20%20%20city%0A%20%20%20%20country%0A%20%20%20%20currency%0A%20%20%20%20priceInCountry%28amount%3A%20%24amount%2C%20from%3A%20%24from%29%0A%20%20%7D%0A%7D%0A&amp;variables=%7B%22amount%22%3A1%2C%22from%22%3A%22EUR%22%2C%22ip%22%3A%228.8.8.8%22%7D%0A" rel="noopener ugc nofollow" target="_blank"> GraphiQL接口</a>或下图来查看结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/cc3becfb2237a57c5d3af6e5fac97adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7DZ5JPQyH5CsTnQV.png"/></div></div></figure><p id="3831" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除了IP地址位置之外，该查询还让GraphQL API将欧元转换为该位置的本地货币。在这种情况下，这意味着再次将欧元转换为美元。</p><p id="4a50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了获得这些数据，GraphQL API将执行以下操作:</p><ul class=""><li id="5e5e" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">向底层IP-API REST API发送请求，根据IP地址获取位置和货币；</li><li id="c340" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">使用Frankfurter REST API将该地点的货币转换为欧元。</li></ul><p id="a7d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在k6脚本中使用这个嵌套查询来对GraphQL API进行另一个性能测试。这个查询的深度与我们在上一节中使用的查询不同，因为数据来自不同的来源，所以现在是嵌套的。您可以将下面的k6脚本放在一个名为<code class="fe mm mn mo mp b">nested.js</code>的新文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并在与之前测试相同的环境下运行它:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="674a" class="mq lp iq mp b gy ni nj l nk nl">k6 run --vus 10 --duration 30s nested.js</span></pre><p id="1d2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个性能测试的结果类似于批处理请求的测试结果。批处理不是发生在k6脚本中，而是发生在GraphQL API中，它处理对底层REST APIs的两个请求。</p><p id="2b61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于GraphQL API是为高性能而构建的，所以只获取IP地址位置的初始查询与获取IP地址位置和货币转换的查询之间的差异很小。您可以在下面的k6负载测试的输出中检查一些内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/fb40ef51782de11195c0750136859bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*43jE4HkonsS7JV8d.png"/></div></div></figure><p id="f2ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们刚刚运行的测试表明，GraphQL完全能够在一个请求中从不同来源获取数据。让我们在最后一节将GraphQL查询分解为REST API请求来证明这一点。</p><h1 id="f200" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">将GraphQL与REST性能进行比较</h1><p id="4b3a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">您已经了解了如何使用k6测试GraphQL的性能，以及它与测试REST API有何不同。我们测试的最后一个GraphQL查询调用了两个不同的REST API端点。我们可以尝试两种场景来比较GraphQL和REST的性能。</p><p id="4016" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要么设置两个单独的测试，将各个REST端点的性能与其对应的GraphQL查询进行比较，要么通过从k6测试中直接调用两个REST API端点来重新创建GraphQL API的完整行为。</p><p id="c04c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">后者是最有趣的测试，因为两个REST端点都需要为GraphQL查询返回数据以进行解析。我们测试的GraphQL查询行为是:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="8494" class="mq lp iq mp b gy ni nj l nk nl">query GetConversion($ip: String!, $amount: Float!, $from: String!) {<br/>  ipApi_location(ip: $ip) {<br/>    ip<br/>    cit<br/>    country<br/>    currency<br/>    priceInCountry(amount: $amount, from: $from)<br/>  }<br/>}</span></pre><p id="5dfa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这会向REST端点发送请求:</p><ul class=""><li id="9459" class="nm nn iq kt b ku kv kx ky la no le np li nq lm nr ns nt nu bi translated">从IP-API: <code class="fe mm mn mo mp b"><a class="ae ln" href="http://ip-api.com/json/8.8.8.8?fields=city,country,currency" rel="noopener ugc nofollow" target="_blank">http://ip-api.com/json/8.8.8.8?fields=city,country,currency</a></code>获取IP地址<code class="fe mm mn mo mp b">8.8.8.8</code>的位置和货币</li><li id="7124" class="nm nn iq kt b ku nv kx nw la nx le ny li nz lm nr ns nt nu bi translated">将IP地址位置的货币转换为法兰克福的欧元:<code class="fe mm mn mo mp b"> <a class="ae ln" href="https://api.frankfurter.app/latest?amount=1&amp;from=EUR&amp;to=USD" rel="noopener ugc nofollow" target="_blank">https://api.frankfurter.app/latest?amount=1&amp;from=EUR&amp;to=USD</a></code></li></ul><p id="9082" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了使用k6进行测试，您需要在一个新文件中设置以下脚本，我们称之为<code class="fe mm mn mo mp b">rest.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="af0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个k6性能测试不仅会调用两个REST端点。但是在真实的场景中，如果第一个请求没有返回IP地址的本地货币，那么到达第二个端点将位置的货币转换成欧元是没有意义的。</p><p id="a930" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在与其他测试相同的条件下运行上述测试:</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="57b3" class="mq lp iq mp b gy ni nj l nk nl">k6 run --vus 10 --duration 30s rest.js</span></pre><p id="8c8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这给出了以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/31a398242336d60dd587b8dae1e44a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iSIKJDFhiB-EWU3j.png"/></div></div></figure><p id="01d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最突出的一点是，只有50次迭代(每次迭代有两个HTTP请求)在30秒内完成。在这些测试中，只有3个vu能够发送请求，所有请求中有20%都失败了。与GraphQL API相比，这些测试结果令人失望。两个REST APIs的图形化版本可以处理更多的请求并更快地解决它们。这是为什么呢？</p><p id="78ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用StepZen创建的GraphQL API应用了缓存，而REST API本身似乎根本没有应用任何缓存。对IP-API端点的请求似乎有20%的时间会失败。此外，GraphQL API还会在需要时对N+1请求进行批处理或优化。例如，您需要两次从currency REST API请求相同的数据。</p><h1 id="3ae3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="6f69" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">GraphQL的使用一直在增加，特别是在前端开发人员中，他们需要一种更具声明性的方式来处理数据。在这篇文章中，我们探讨了如何使用k6对GraphQL API进行性能测试。这个GraphQL API是用StepZen通过转换来自IP-API和Frankfurter的开源REST APIs创建的。测试结果显示，GraphQL API在所有场景下都接近完美的可伸缩性和高性能。</p><p id="a789" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">相比之下，在测试中，单独的REST API端点有显著的性能问题。这是由于StepZen GraphQL API的性能优化，比如缓存。有关GraphQL的完整性能测试脚本，请参见<a class="ae ln" href="https://github.com/stepzen-dev/stepzen-graphql-benchmark" rel="noopener ugc nofollow" target="_blank"> this repository </a>中的StepZen GraphQL基准测试工具。</p><pre class="kg kh ki kj gt ne mp nf ng aw nh bi"><span id="fa83" class="mq lp iq mp b gy ni nj l nk nl"><strong class="mp ir">Want to connect?</strong></span><span id="2e5a" class="mq lp iq mp b gy oa nj l nk nl">Learn more or ask questions about StepZen on the Discord <a class="ae ln" href="https://discord.com/invite/9k2VdPn2FR" rel="noopener ugc nofollow" target="_blank">here</a>.</span></pre></div></div>    
</body>
</html>