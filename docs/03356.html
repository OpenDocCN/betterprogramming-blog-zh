<html>
<head>
<title>Search Technique on Graphs: Breadth-First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图上搜索技术:广度优先搜索</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/search-technique-on-graphs-breadth-first-search-dab467f73ff8?source=collection_archive---------29-----------------------#2020-02-04">https://betterprogramming.pub/search-technique-on-graphs-breadth-first-search-dab467f73ff8?source=collection_archive---------29-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1eb6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">四处搜寻</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4896164bc6888f8e598fefbcd3e7201c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4bHowcZgckG1dNjACgPWg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://www.pinterest.co.uk/brashash/" rel="noopener ugc nofollow" target="_blank"> AnaSophia Eiseman </a></p></figure><p id="8c8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">广度优先搜索</em> (BFS)是图上常见的搜索技术。BFS是深度优先搜索的同伴。当DFS在图的深度方向上遍历时，BFS在图的宽度方向上遍历。它被用来在图中寻找一个节点。它也可以用来获得从一个给定节点到那个节点的路径，或者只是遍历一个图中的所有节点和边。</p><h2 id="a0ce" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">为什么使用BFS而不是DFS？</h2><p id="340f" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">假设我们想在一棵树上找到一个节点，我们事先知道这棵树不是浓密的(直径更大),并且这个节点位于树的中间。然后我们使用BFS而不是DFS。</p><p id="01f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当边上没有权重或权重相同时，它通常用于查找从某个给定节点到某个节点的最短路径。</p><p id="aebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一块用到的所有<a class="ae ky" href="https://github.com/abecus/DS-and-Algorithms/tree/master/graph" rel="noopener ugc nofollow" target="_blank">代码都可以在GitHub上找到。</a></p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="7f77" class="nb lx it bd ly nc nd ne mb nf ng nh me jz ni ka mh kc nj kd mk kf nk kg mn nl bi translated">广度优先搜索</h1><p id="ea8c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在广度优先搜索技术中，我们逐层遍历图。首先，从一个起始节点开始，我们存储它的所有相邻节点。然后，我们浏览存储的节点，并以首先浏览首先存储的节点的方式存储它们的所有相邻节点。</p><p id="43a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以这样的方式维护图的遍历，即我们探索一个级别的所有节点，然后是它下面的级别，等等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8b63b20620c985fe10e90b854c9a3452.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*NfWwd4xZg28zmVWvIq1tNQ.png"/></div></figure><p id="1a1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我们希望使用BFS从节点3转到所有节点。假设我们在0层(因为我们的自然数从0开始)。我们将节点3存储在一个队列中。(队列被定义为至少支持从前面移除项目和将项目添加到后面或常数时间的追加操作的数据结构，并且通常使用双向链表来实现。)现在说我们的队列是[3]。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/cdf471ee1d72a3bafdd467e767da6259.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*dgI7khaiWnA1XY-dGXRu8w.png"/></div></figure><p id="30c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过从队列的前面弹出项目，即节点3，并遍历它，我们转到第1层的相邻节点2。现在我们将节点2添加到队列[2]中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/05a004b6bccaba246ca65d77d3e8692c.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*8t0h_W3ujorvjspSTxOZCA.png"/></div></figure><p id="7081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次从队列的前端(即节点2)弹出项目，并转到节点2的所有相邻节点，即第2层的0和4。然后我们将这些节点添加到队列[0，4]。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8bf73938094a5bb4cc80c67c5c8bf336.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*G8V_IDUGTfPbBdxZyn0daA.png"/></div></figure><p id="1f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次从队列的前面弹出项目，它们是节点0和4。然后从节点0，我们到它的相邻节点6，把它追加到队列，队列就变成了[6]。我们对节点4的相邻节点5和1进行同样的操作，队列变成[6，5，1]，它们位于第3层。这就是我们如何在图中使用BFS技术进行遍历。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="db53" class="nb lx it bd ly nc nd ne mb nf ng nh me jz ni ka mh kc nj kd mk kf nk kg mn nl bi translated">让我们编码吧</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="3087" class="lw lx it nq b gy nu nv l nw nx">from collections import deque <br/>def bfs(G, start, end):<br/>    ...</span></pre><p id="4981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一行，我们正在导入Python的内置队列模块。然后我们创建一个函数<code class="fe ny nz oa nq b">bfs</code>，它接受参数图、开始节点和结束节点。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="68e0" class="lw lx it nq b gy nu nv l nw nx">if start in Graph.graph:<br/>    visited = set()        <br/>    parent = {}        <br/>    queue = deque([])    <br/>    visited.add(start)        <br/>    queue.append(start)<br/>    ...</span></pre><p id="c063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二行中，我们检查开始节点是否在图中。如果是，那么我们初始化访问过的集合来检查一个节点以前是否被访问过，有一个父字典作为父指针来重新创建路径，还有一个队列来存储节点。之后，我们将开始节点插入到被访问的集合和队列中。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="d034" class="lw lx it nq b gy nu nv l nw nx">while queue:            <br/>    ...</span></pre><p id="9e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们一直循环，直到队列为空。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="e5bc" class="lw lx it nq b gy nu nv l nw nx">node = queue.popleft()<br/>if node==end:                <br/>    return backtrace(parent, start, end)  <br/>visited.add(node)<br/>...</span></pre><p id="c147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们从队列的前面弹出节点，并检查该节点是否是结束节点。如果是，那么我们调用函数<code class="fe ny nz oa nq b">backtrace</code>，用它来重新创建到结束节点的路径。如果该节点不是结束节点，那么我们将把该节点添加到已访问的集合中。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="f7dd" class="lw lx it nq b gy nu nv l nw nx">for child, _ in G.getAdjacentNodes(node):                <br/>    if child not in visited:                    <br/>        parent[child]=node                    <br/>        queue.append(child)<br/>...</span></pre><p id="416c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们循环遍历该节点的所有相邻节点。如果它们以前没有被访问过，我们将把它们添加到队列中(即，把它们添加到末尾)，并在父字典中将它们的父标记为<code class="fe ny nz oa nq b">node</code> <em class="lv"> </em>。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="438b" class="lw lx it nq b gy nu nv l nw nx">return f"Path does not exists between the Nodes ({start} to {end})"</span></pre><p id="1e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有找到结束节点或者开始节点不在图中，我们返回一条消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了重新创建路径，我们使用父字典并使用结束节点进行循环，直到找到开始节点。在这个过程中，我们将循环的节点添加到数组或列表中。在最后一行中，我们返回了反向列表，因为我们追加了从结束节点到开始节点的路径。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="e165" class="nb lx it bd ly nc nd ne mb nf ng nh me jz ni ka mh kc nj kd mk kf nk kg mn nl bi translated">运行代码</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8b63b20620c985fe10e90b854c9a3452.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*NfWwd4xZg28zmVWvIq1tNQ.png"/></div></figure><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="12cb" class="lw lx it nq b gy nu nv l nw nx">G=Graph()<br/>G.add(3, [2])<br/>G.add(2, [0,4])<br/>G.add(0, [6,5])<br/>G.add(4, [5,1])</span></pre><p id="5a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe ny nz oa nq b"><a class="ae ky" href="https://github.com/abecus/DS-and-Algorithms/blob/master/graph/graph.py" rel="noopener ugc nofollow" target="_blank">Graph</a></code>类创建一个如上图。</p><pre class="kj kk kl km gt np nq nr ns aw nt bi"><span id="cda3" class="lw lx it nq b gy nu nv l nw nx">print(bfs(G, 3, 5))<br/># [3,2,0,5]</span></pre><p id="e46b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行<code class="fe ny nz oa nq b">bfs</code>函数，将3作为起始节点，5作为结束节点，打印出[3，2，0，5]。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="38cd" class="nb lx it bd ly nc nd ne mb nf ng nh me jz ni ka mh kc nj kd mk kf nk kg mn nl bi translated">时间复杂度</h1><p id="b1b7" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">与DFS类似，BFS的时间复杂度是O(V+E ),因为访问每个节点一次并检查该节点是否被访问需要恒定的时间。此外，我们已经使用邻接表(使用嵌套字典和集合)表示了该图。</p><p id="130d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我将介绍拓扑排序算法。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="4786" class="nb lx it bd ly nc nd ne mb nf ng nh me jz ni ka mh kc nj kd mk kf nk kg mn nl bi translated">资源</h1><p id="421d" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">你可以在我的GitHub上找到我在上面用过的所有<a class="ae ky" href="https://github.com/abecus/DS-and-Algorithms/tree/master/graph" rel="noopener ugc nofollow" target="_blank">代码。</a></p><p id="7307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>