<html>
<head>
<title>8 Classic JavaScript Mistakes You Should Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该避免的8个经典JavaScript错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-classic-javascript-coding-mistakes-you-should-avoid-14f198ea9e36?source=collection_archive---------5-----------------------#2020-06-22">https://betterprogramming.pub/8-classic-javascript-coding-mistakes-you-should-avoid-14f198ea9e36?source=collection_archive---------5-----------------------#2020-06-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="7a77" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">混淆相等运算符、缺少参数、忽略范围等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/a4c7b5c3a62ad73bc61cefc696df4e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B9Nov6Rq57sUBtKM"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@8thshot?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Muhd Asyraaf </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2676" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">JavaScript是当今web开发中最流行的语言之一。它很容易开始，有一个友好的语法，并拥有一些强大的功能。但是掌握它需要时间和大量的练习。</p><p id="2f9b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然初学者容易犯一些经典错误，但有编程经验的开发人员也不能完全避免错误。任何人都可能因为忽略JavaScript的细微差别而犯错误。这可能会在您的代码中导致意外的结果。让我们探讨一些JavaScript开发人员会犯的众所周知的错误，并了解如何避免它们。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e5f3" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">误用加法运算符合并数组</h1><p id="874c" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">与所有编程语言一样，JavaScript提供了一个用于整数和浮点数相加的<code class="fe na nb nc nd b">+</code>运算符。</p><p id="ff7d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是一旦您使用运算符添加不同的类型，如字符串和数字，类型转换就会发生。这些值被连接起来而不是相加，如下所示:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="ab84" class="ni me iu nd b gz nj nk l nl nm">var x = 1 + 1 //2<br/>var y = 1 + '1' // '11'</span></pre><p id="0573" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这并不重要，但是使用加法运算符合并数组会导致更多意想不到的结果:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="8492" class="ni me iu nd b gz nj nk l nl nm">a = [1,2]<br/>b = [3,4,5]</span><span id="19d1" class="ni me iu nd b gz nn nk l nl nm">console.log(a + b); // [1,23,4,5,6]</span></pre><p id="e734" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">加法运算符并不真正合并数组。相反，它将<code class="fe na nb nc nd b">a</code>的最后一个元素与<code class="fe na nb nc nd b">b</code>的第一个元素连接起来。为了正确合并JavaScript数组，使用<code class="fe na nb nc nd b">concat()</code>方法或<code class="fe na nb nc nd b">spread</code>操作符。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="484c" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">不正确地使用等式运算符</h1><p id="6b72" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">JavaScript提供了用于相等检查的<code class="fe na nb nc nd b">==</code>和<code class="fe na nb nc nd b">===</code>操作符，您可以很容易地在代码中互换这两个操作符，从而导致灾难性的结果。这里有一个例子可以说明它们之间的区别:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="c2a4" class="ni me iu nd b gz nj nk l nl nm">false === 0 //false<br/>false == 0 //true</span><span id="e55d" class="ni me iu nd b gz nn nk l nl nm">10 === '10' //false<br/>10 == '10' //true</span></pre><p id="09f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">triple equals是一个严格的等式运算符，它在比较中检查数据类型和值。另一方面，double equals会在完成任何必要的类型转换后进行相等检查，这样两个操作数就有了共同的类型。</p><p id="971f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由<code class="fe na nb nc nd b">==</code>操作符完成的类型强制要求您熟悉falsy值，以防止意外的结果。例如，<code class="fe na nb nc nd b">NaN</code>不能转换成普通的falsy值类型:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="c6ce" class="ni me iu nd b gz nj nk l nl nm">null == undefined //true</span><span id="4c5c" class="ni me iu nd b gz nn nk l nl nm">null == NaN //false</span></pre><p id="3a32" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">建议您尽可能使用<code class="fe na nb nc nd b">===</code>。另外，需要注意的是<code class="fe na nb nc nd b">switch</code>块只做严格的比较。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8528" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">忽略“变量”和范围</h1><p id="4395" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">初学者在开始时，往往会忘记在声明中使用<code class="fe na nb nc nd b">var</code>，JavaScript也没有抱怨。相反，它假设变量具有全局范围。这可能对您的代码库有害，并导致错误。下面的例子说明了这样一种差异:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="c56f" class="ni me iu nd b gz nj nk l nl nm">var a = 1;</span><span id="af6a" class="ni me iu nd b gz nn nk l nl nm">function simple() {<br/>a = 5;<br/>}</span><span id="5444" class="ni me iu nd b gz nn nk l nl nm">simple()<br/>console.log(a); //5</span></pre><p id="b368" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，避免<code class="fe na nb nc nd b">var</code>可能会导致参考误差，如下所示:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="46d6" class="ni me iu nd b gz nj nk l nl nm">console.log(x); //ReferenceError<br/>x = 1;</span><span id="c4c5" class="ni me iu nd b gz nn nk l nl nm">console.log(x); //undefined<br/>var x = 1;</span></pre><p id="a9b8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与大多数编程语言不同，JavaScript没有为<code class="fe na nb nc nd b">var</code>提供块级范围。例如，在下面的代码中，<code class="fe na nb nc nd b">i</code>的值将存在于循环之外:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="8d35" class="ni me iu nd b gz nj nk l nl nm">for (var i = 0; i &lt; 5; i++) {<br/>  /* ... */<br/>}<br/>console.log(i);  // 5</span></pre><p id="b71a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了确保值<code class="fe na nb nc nd b">i</code>保持在那个块内，我们需要使用<code class="fe na nb nc nd b">let</code>来代替。不同之处在于:<code class="fe na nb nc nd b">var</code>是函数作用域，而<code class="fe na nb nc nd b">let</code>是块作用域。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="8847" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">函数调用中缺少参数</h1><p id="af27" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">JavaScript函数不检查收到的参数数量，这可能会产生错误。在向函数声明中添加新参数，但在调用时不传递参数的情况下，这些参数将被视为<code class="fe na nb nc nd b">undefined</code>。</p><p id="9e19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">解决这个问题的一个方法是使用<code class="fe na nb nc nd b">||</code>来确保参数在主体中有一个默认值。第二种方式实际上更受欢迎，从ES6+开始就有了。它要求您设置默认参数，如下所示:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="22fb" class="ni me iu nd b gz nj nk l nl nm">function sum(num1 = 0, num2 = 0){<br/>console.log(num2 + num1);<br/>}</span><span id="5848" class="ni me iu nd b gz nn nk l nl nm">sum(2,3); //prints 5<br/>sum(); //prints 0</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="e6b1" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">处理`<code class="fe na nb nc nd b">this</code>'参考</h1><p id="bfe5" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><code class="fe na nb nc nd b">this</code>关键字让每个JavaScript开发人员感到困惑。也许，它与Java等其他编程语言提供的功能有很大不同。</p><p id="3eda" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">this</code>关键字引用一个对象，引用可以根据函数的调用方式而改变，而不是在哪里定义<em class="no">。</em></p><p id="5a4a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于对象内部的方法，<code class="fe na nb nc nd b">this</code>指的是调用者对象本身，而对于独立的函数，<code class="fe na nb nc nd b">this</code>指的是一个全局对象。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="af94" class="ni me iu nd b gz nj nk l nl nm">let user = {<br/>  name: "your name",<br/>  getName() {<br/>    console.log(this.name);<br/>  }<br/>};</span><span id="22a7" class="ni me iu nd b gz nn nk l nl nm">user.getName();</span></pre><p id="7d3c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，如果我们提取函数，<code class="fe na nb nc nd b">this</code>引用将会改变:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="0db6" class="ni me iu nd b gz nj nk l nl nm">let user = {<br/>  name: "your name",<br/>  getName: function(){<br/>    console.log(this.name);<br/>  }<br/>};</span><span id="0912" class="ni me iu nd b gz nn nk l nl nm">user.getName() //your name<br/>var getUsername = user.getName;</span><span id="e36d" class="ni me iu nd b gz nn nk l nl nm">getUsername() //undefined</span></pre><p id="4133" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">尽管<code class="fe na nb nc nd b">getUsername</code>持有<code class="fe na nb nc nd b">getName</code>的引用，但是调用位置已经改变，从而使<code class="fe na nb nc nd b">this</code>成为一个全局对象。因此<code class="fe na nb nc nd b">getUsername() </code>返回未定义。</p><p id="91f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">this</code>关键字的另一个更棘手的情况是在匿名函数中使用。匿名函数中的<code class="fe na nb nc nd b">this</code>上下文不能访问外部对象，因此指向全局范围。要访问匿名函数中的对象属性，我们需要传递对象的实例，如下所示:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="0cd0" class="ni me iu nd b gz nj nk l nl nm">let user = {<br/>  name: "your name",<br/>  getName: function(){<br/>    var self = this;<br/>    (function () {<br/>        console.log(self.name);<br/>    }());<br/>    <br/>  }<br/>};</span></pre><p id="bbea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">不像上面那样将<code class="fe na nb nc nd b">this</code>引用存储在变量中，我们也可以在匿名函数上调用<code class="fe na nb nc nd b">call(this)</code>，如下所示:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="17a4" class="ni me iu nd b gz nj nk l nl nm">let user = {<br/>  name: "your name",<br/>  getName: function(){<br/>  <br/>    (function () {<br/>        console.log(this.name);<br/>    }).<strong class="nd iv">call(this)</strong><br/>    <br/>  }<br/>};</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fd00" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">过度沉迷于嵌套回调</h1><p id="c761" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">异步编程是JavaScript的一个重要部分，它很容易陷入嵌套回调，也称为<em class="no">回调地狱。这里有一个典型的例子:</em></p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj np"><img src="../Images/d2c658105b36c88b5477d38b79831e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*reSb1u18osNfxKG38eX-gA.png"/></div></div></figure><p id="742e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦嵌套回调超出了几层深度，我们就会以可怕的末日金字塔告终。你可以通过承诺来避免这种情况，如下所示:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="1926" class="ni me iu nd b gz nj nk l nl nm">getUser()<br/>    .then(user =&gt; getLocation(user))<br/>    .then(location =&gt; getPosts(location))<br/>    .then(posts =&gt; doStuff(posts));</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="afe9" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">创造深层次的承诺</h1><p id="b9c4" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">就像回调地狱一样，你很容易以<em class="no">承诺地狱</em>结束——深度嵌套的承诺。出现这种情况是因为对不同的承诺类型缺乏了解。例如，我们可以有三个不需要嵌套的独立承诺，如下所示:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="5c7f" class="ni me iu nd b gz nj nk l nl nm">enterHome()<br/>  .then(() =&gt; {<br/>    return greet('family')<br/>      .then(() =&gt; {<br/>        return goSleep();<br/>      });<br/>  });</span></pre><p id="6282" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以使用如下所示的<code class="fe na nb nc nd b">Promise.all</code>函数并行运行它们，而不是顺序运行它们:</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="d7d6" class="ni me iu nd b gz nj nk l nl nm">Promise.all([<br/>  enterHome(),<br/>  greet('family'),<br/>  goSleep()<br/>]);</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="d487" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用“for-in”循环的数组迭代</h1><p id="59bb" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">JavaScript提供了几种迭代数组的方法。<code class="fe na nb nc nd b">ForEach</code>、经典<code class="fe na nb nc nd b">for,</code>和<code class="fe na nb nc nd b">for</code> - <code class="fe na nb nc nd b">of</code>循环是一些推荐的方式。人们可能会不经意地使用<code class="fe na nb nc nd b">for</code> … <code class="fe na nb nc nd b">in</code>循环，因为它们看起来很舒服——但这通常不是一个好主意，因为它们枚举了一个对象的属性名。</p><p id="5216" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在数组的情况下，这意味着，<code class="fe na nb nc nd b">for</code> - <code class="fe na nb nc nd b">in</code>循环本质上是在索引上迭代——有时，以任意顺序，这违背了数组迭代的目的。</p><p id="d745" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">继承的方法和原型也在<code class="fe na nb nc nd b">for</code> - <code class="fe na nb nc nd b">in</code>循环中枚举，最终导致性能变慢。这意味着如果你扩展<code class="fe na nb nc nd b">Array.prototype</code>来包含一个方法，它也会被枚举。</p><pre class="kk kl km kn gu ne nd nf ng aw nh bi"><span id="c7dc" class="ni me iu nd b gz nj nk l nl nm">Array.prototype.hello = "hey!";<br/>var array = ['a', 'b', 'c'];<br/><br/>for (var i in array) {<br/>    console.log(array[i]);<br/>}</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="fa9a" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="7d94" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">上述众所周知的错误是由于JavaScript与其他语言相比在工作方式上的细微差异造成的。更好地理解该语言将有助于避免这些经典错误，并确保您的代码库保持稳固。</p><p id="39da" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。感谢阅读。</p></div></div>    
</body>
</html>