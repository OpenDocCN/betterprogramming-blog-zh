<html>
<head>
<title>Apple Sign-In: Custom Servers and an Expiry Conundrum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苹果登录:定制服务器和到期难题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/apple-sign-in-custom-servers-and-an-expiry-conundrum-d1ad63223870?source=collection_archive---------4-----------------------#2019-10-11">https://betterprogramming.pub/apple-sign-in-custom-servers-and-an-expiry-conundrum-d1ad63223870?source=collection_archive---------4-----------------------#2019-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c7aa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">服务器端使用应该采用苹果登录吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7edfb56c9accdc529d0431f10f0d55fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FNLygRrPkQfNj_b3CjFu5w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/apple?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kv" href="https://unsplash.com/@medhatdawoud?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Medhat Dawoud </a>拍摄的照片</p></figure><p id="5890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2020年7月:参见<a class="ae kv" href="/@crspybits/part-ii-apple-sign-in-custom-servers-and-an-expiry-conundrum-b3e9735dc079?source=your_stories_page---------------------------" rel="noopener ugc nofollow" target="_blank">苹果登录:定制服务器和到期难题(第二部分)</a> ]</p><p id="44ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，我在将苹果登录与我的应用程序集成方面取得了很大进展，但这并不容易。我仍然有一个问题——看起来像是一个节目中止。</p><p id="9638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我写这篇文章的目的是分享我的学习，并希望得到一些反馈。尽管我相信我的用例并没有那么不寻常，但我感觉自己好像是在荒野中。</p><p id="54b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想使用Apple登录产生的OAuth令牌来访问我的服务器上的HTTP REST API。</p><p id="9809" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我从登录的角度详细说明一下我的系统。我的系统可能有点不寻常，因为它没有本地登录类型。它允许登录各种社交登录和云服务提供商:Dropbox、谷歌和脸书。</p><p id="bae2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近整合了微软(OneDrive)的服务器端，并且正在开发苹果的登录功能。重点其实是云服务提供商。我的应用(苹果应用商店上的<a class="ae kv" href="https://apps.apple.com/us/app/neebla/id1244482164" rel="noopener ugc nofollow" target="_blank"> Neebla </a>，后端的<a class="ae kv" href="https://github.com/crspybits/SyncServerII" rel="noopener ugc nofollow" target="_blank"> SyncServerII </a>)有一个BYOCS——“自带云存储”的概念。</p><p id="8553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户上传的数据通常存储在他们自己的云存储系统中，这些数据可以安全地与其他用户共享。社交登录(包括Apple登录)只有在云存储用户的邀请下才能进行，社交用户的数据存储被委托给邀请用户的存储。</p><p id="4cc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Neebla和SyncServerII上典型的登录和REST API用法的一个例子是<a class="ae kv" href="https://developers.google.com/identity/sign-in/ios" rel="noopener ugc nofollow" target="_blank"> Google登录</a>。Google提供了客户端iOS框架。用户使用他们的Google用户名和凭证登录，由此产生了几个结果:</p><ol class=""><li id="ea9a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">OAuth令牌—授权代码和访问令牌。</li><li id="ea52" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">登录框架在客户端自动刷新访问令牌。</li><li id="e7da" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">这些令牌可以发送到我的自定义服务器，访问令牌很容易验证，使用谷歌端点。</li><li id="33f2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">定制服务器上的初始令牌验证可以在端点请求处理的早期进行，无需访问定制服务器的数据库(如这里的<a class="ae kv" href="https://github.com/IBM-Swift/Kitura-Credentials" rel="noopener ugc nofollow" target="_blank">风格</a>)。</li></ol><p id="6f69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我提到这几点是为了建立一个我希望在其他登录提供商身上看到的期望框架(并不是因为我是一个死忠的谷歌粉丝)。</p><p id="12d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我将转到Apple登录，并从实现的角度描述这个过程是如何工作的。我将分三步考虑这个问题，这三步对应于我的系统中的机制。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="98d1" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">1.客户端登录</h1><p id="9ae5" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我在iOS客户端应用程序中集成苹果登录的体验与<a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2019/706" rel="noopener ugc nofollow" target="_blank">苹果开发者视频</a>中描述的非常相似。</p><p id="8be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了几个例外。<a class="ae kv" href="https://developer.apple.com/documentation/authenticationservices/adding_the_sign_in_with_apple_flow_to_your_app" rel="noopener ugc nofollow" target="_blank">我用了他们的演示app </a>。我遇到的两个问题似乎都和iOS模拟器有关，至少从Xcode 11.1开始。</p><p id="bb73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">帐户不会从应用程序的启动一直保留(例如，使用他们的<code class="fe nk nl nm nn b">getCredentialState</code>方法)，并且应用程序很容易锁定。</p><p id="19ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个问题主要是一个烦恼。你只需要继续登录。为了解决第二个问题，我要么切换到不同的设备模拟器，要么在设置应用程序中注销我的苹果账户。</p><p id="eb0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我目前正在使用登录的结果作为我进一步发展的输入。具体来说，我使用下面的五项结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/ff2dd3387f526c6c91736ded874e357a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sg2fK1q5SNNN4pt5kEgkXg.png"/></div></div></figure><p id="9d10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将集中讨论其中的三个。<code class="fe nk nl nm nn b">user</code> <strong class="ky ir"> </strong>属性提供了唯一的密钥来标识用户，而不是电子邮件地址。<code class="fe nk nl nm nn b">authorizationCode</code> <strong class="ky ir"> </strong>和<code class="fe nk nl nm nn b">identityToken</code> <strong class="ky ir"> </strong>为OAuth。</p><p id="3936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以将<code class="fe nk nl nm nn b">authorizationCode</code>传递到您的服务器来创建一个刷新令牌。这方面的更多内容将在下面的第3部分中介绍。<code class="fe nk nl nm nn b">identityToken</code>(或者只是ID令牌)是一个JWT (JSON web令牌)，10分钟后到期。你也可以把它传递给你的服务器。</p><p id="8220" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个令牌一直是我持续沮丧的一个来源，所以我要再说一些事情。</p><p id="2214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在iOS应用中刷新的ID令牌是<em class="np">不是</em> <strong class="ky ir"> </strong>。比如在苹果开发者论坛上看到<a class="ae kv" href="https://forums.developer.apple.com/thread/117867" rel="noopener ugc nofollow" target="_blank">这个线程</a>。这违背了我对OAuth登录机制的典型期望。</p><p id="65ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，<em class="np">而不是</em> <strong class="ky ir"> </strong>似乎有可能创建另一个ID令牌，即服务器端的ID令牌，以延长ID令牌的有效期。具体来说，刷新令牌(再次参见下面的3)可以用于验证，而不是用于创建新的ID令牌。参见<a class="ae kv" href="https://developer.apple.com/documentation/signinwithapplerestapi/generate_and_validate_tokens" rel="noopener ugc nofollow" target="_blank">苹果文档</a>。</p><p id="6e31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明，ID令牌只是在用户登录时创建并提供给你的应用程序。所以，基本上只期望得到一次。</p><p id="d780" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这引发了定制服务器REST API难题。</p><p id="a2b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当iOS应用程序使用Apple sign-in向服务器进行鉴定时，应该向自定义服务器发送什么？</p><p id="9475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我考虑的参考案例中，Google sign-in，我发送OAuth访问令牌。它的到期日期会定期更新，因为Google登录框架会定期在iOS应用程序上更新访问令牌。</p><p id="f842" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从表面上看，我们可以使用两个令牌从客户端iOS应用程序发送到服务器:</p><ol class=""><li id="171b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">ID标记。</li><li id="a725" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">刷新令牌(不好意思，继续读)。</li></ol><p id="1d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://stackoverflow.com/questions/58178187" rel="noopener ugc nofollow" target="_blank">我在这里概述了这些策略的一些考虑事项</a>。关于刷新令牌的另一个考虑是，有些人认为它不应该给客户端——例如，<a class="ae kv" href="https://github.com/AzureAD/microsoft-authentication-library-for-objc/issues/618" rel="noopener ugc nofollow" target="_blank">iOS版MSAL不允许iOS客户端访问刷新令牌。</a></p><p id="1eca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，刷新令牌功能强大，经验法则是客户端不可信。</p><p id="e2db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于这些原因，我选择将ID令牌发送到我的服务器进行端点身份验证。我将把这个令牌保存在我客户端的钥匙串中。我还将授权代码发送到我的服务器，但是不要将它保存在客户机上(例如，它永远不会被发送回客户机)。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d108" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">2.服务器端初始凭证验证</h1><p id="7b04" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我用Swift编写的定制服务器使用插件的<a class="ae kv" href="https://github.com/IBM-Swift/Kitura-Credentials" rel="noopener ugc nofollow" target="_blank"> IBM的Kitura凭证框架</a>为每个端点请求进行初始授权。</p><p id="461d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/IBM-Swift/Kitura-CredentialsGoogle" rel="noopener ugc nofollow" target="_blank">例如，对于Google </a>，它检查用户(通过OAuth访问令牌表示)是否是Google用户。它<em class="np">不</em> <strong class="ky ir"> </strong>检查用户在系统上是否有帐户。</p><p id="c42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我正在创建一个<a class="ae kv" href="https://github.com/crspybits/CredentialsAppleSignIn" rel="noopener ugc nofollow" target="_blank">苹果登录Kitura凭证插件</a>。这个插件使用ID令牌为用户进行初始授权。它<em class="np">不</em> <strong class="ky ir"> </strong>检查ID令牌的到期，原因如上所述。</p><p id="a9e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，它假设额外的验证将在服务器上进行(参见下面的第3节)。</p><p id="734e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查ID令牌的有效性并不容易。在我看过的两个WWDC 2019视频中，苹果都没有谈到它。他们的在线文档很少。</p><p id="9502" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些早期采用者已经在博客上对此进行了讨论，这很有帮助。比如见<a class="ae kv" href="https://blog.curtisherbert.com/so-theyve-signed-in-with-apple-now-what/" rel="noopener ugc nofollow" target="_blank">柯蒂斯赫伯特</a>和<a class="ae kv" href="https://developer.okta.com/blog/2019/06/04/what-the-heck-is-sign-in-with-apple" rel="noopener ugc nofollow" target="_blank">奥克塔</a>。</p><p id="2863" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的<a class="ae kv" href="https://github.com/crspybits/CredentialsAppleSignIn" rel="noopener ugc nofollow" target="_blank">Apple sign-in Kitura Credentials plugin</a>的代码可能是我能提供的最好的检查ID令牌有效性的代码，但是我将给出一个你需要遵循的步骤的概要来总结:</p><ol class=""><li id="9d14" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">通过对苹果的HTTP端点请求，获得苹果的JSON web key (JWK)。</li><li id="3c29" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将JWK重构为PEM公钥。</li><li id="bbb3" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用该公钥验证ID标记的签名(记住，ID标记是一个JWT)。</li><li id="6a80" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">解码ID令牌的有效负载。</li><li id="d4f7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">验证有效负载的声明，不包括到期日期。</li></ol><p id="9a5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用两个框架来完成上述步骤:</p><ul class=""><li id="462c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nq ly lz ma bi translated"><a class="ae kv" href="https://github.com/IBM-Swift/Swift-JWT.git" rel="noopener ugc nofollow" target="_blank">https://github.com/IBM-Swift/Swift-JWT.git</a></li><li id="50ea" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nq ly lz ma bi translated"><a class="ae kv" href="https://github.com/ibm-cloud-security/Swift-JWK-to-PEM.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ibm-cloud-security/Swift-JWK-to-PEM.git</a></li></ul><p id="ef16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将让您深入研究我的代码以获取详细信息。我也给了一些更多的网络链接。</p><p id="7a84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在这里给出一个进一步的细节。这些步骤<em class="np">不</em> <strong class="ky ir"> </strong>向苹果公司核实你的应用程序目前是否获得该用户的授权。更具体地说，上面唯一的HTTP/network调用是在步骤1中，这是一个简单的HTTP GET，您不需要向Apple提供任何信息。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="80bc" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">3.服务器端最终验证</h1><p id="fbf6" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">好了，你还在看书。还差一步。太棒了。抱歉。</p><p id="551d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还剩下什么？我们在上面的步骤2中对用户进行了初始的服务器端验证。然而，我们实际上还没有向苹果核实这个用户目前是否有效。(您需要检查该用户是否确实是您系统中的用户，但这超出了本博客的范围)。</p><p id="b016" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，如果你正在为一个定制服务器做最后的验证，苹果没有提供视频和稀疏的文档。</p><p id="df8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用来进行最终凭证验证的总体策略是定期使用刷新令牌进行验证。</p><p id="956c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将用户和应用程序的信息通过HTTP POST调用传递到苹果端点，我假设如果用户撤销了应用程序的权限，它将失败。周期性地，我每24小时不超过一次——因为苹果公司说如果你做得超过这个次数，他们可能会掐死你。</p><p id="352a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">刷新令牌是通过授权码和您的一些工作创建的。在我的系统中，当用户创建帐户时，授权码会从iOS应用程序上传到我的服务器。</p><p id="2c55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实证明,( a)创建刷新令牌和(b)使用刷新令牌进行验证的程序代码非常相似。下面我给出主要步骤。</p><p id="5e48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将再次向您推荐我的程序代码，以了解如何将授权代码交换为刷新令牌的完整细节。这次具体参考我的<a class="ae kv" href="https://github.com/crspybits/SyncServerII/tree/dev/Sources/Server/Account%20Specifics/AppleSignIn" rel="noopener ugc nofollow" target="_blank"> SyncServerII repo </a>和<code class="fe nk nl nm nn b">AppleSignInCreds+Refresh.swift</code>和<code class="fe nk nl nm nn b">AppleSignInCreds+ClientSecret.swift</code>文件。</p><p id="355c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建刷新令牌和验证刷新令牌需要一组参数。这是我的服务器上保存这些参数的结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/6e2c9f9a418823d0c447ebf2d3296d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54JvCJlQvYpXefum1hKjKg.png"/></div></div></figure><p id="cc1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">底部的四个参数(<code class="fe nk nl nm nn b">keyId</code>、<code class="fe nk nl nm nn b">teamId</code>、<code class="fe nk nl nm nn b">privateKey</code>和<code class="fe nk nl nm nn b">clientId</code>)是生成客户端密码所需的主要参数。在其他系统中(例如，Google sign-in)，OAuth的客户端机密只是一个复制和粘贴的字符串。</p><p id="c87d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于苹果登录，客户端密码更复杂。这实际上是一个你必须创造和签署的JWT。</p><p id="6030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nk nl nm nn b">teamId</code>来自苹果开发者网站(见下图)。<code class="fe nk nl nm nn b">clientId</code>是您的iOS应用的捆绑包ID或应用ID，例如<code class="fe nk nl nm nn b">biz.SpasticMuffin.SharedImages</code>。</p><p id="c6ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要获得<code class="fe nk nl nm nn b">keyId</code>和<code class="fe nk nl nm nn b">privateKey</code>，你必须通过苹果开发者网站上的步骤。以下是当前执行此操作的<a class="ae kv" href="https://developer.apple.com/account/resources/authkeys/add" rel="noopener ugc nofollow" target="_blank"> URL </a>，看起来像是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/648d3c6ecbf2030806dcd5ce6a2f2bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qaP_Eu08_IMzIU86WVNbtA.png"/></div></div></figure><p id="c50b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也是下载私钥的方式。将私钥保存在私人的地方！对于我的服务器，这放在一个私有的JSON服务器配置文件中。</p><p id="631e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦有了这些参数，就必须在JWT报头和有效载荷中使用它们，并签名以创建JWT字符串。详情见我上面引用的文件— <code class="fe nk nl nm nn b">AppleSignInCreds+ClientSecret.swift</code>。再次，我使用<a class="ae kv" href="https://github.com/IBM-Swift/Swift-JWT.git" rel="noopener ugc nofollow" target="_blank">斯威夫特JWT </a>的重物。</p><p id="bca6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你有了JWT字符串，也就是客户端秘密。你还需要一个重定向URI。为此，你似乎需要自己的TLS安全(HTTPS)网络域名。亚克。我告诉过你这最后一步很糟糕。</p><p id="368c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您使用<a class="ae kv" href="https://developer.apple.com/account/resources/identifiers/list/serviceId" rel="noopener ugc nofollow" target="_blank">苹果开发者网站</a>上的<em class="np">服务Id </em> <strong class="ky ir"> </strong>设置了这个重定向URI。当你去那里点击大的<code class="fe nk nl nm nn b">+</code>图标，它看起来像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/2b944dd636771f7733d742139a1d9135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJFi1f3wkI8w9AUlHyCHzA.png"/></div></div></figure><p id="77a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现这一步令人困惑。你不仅要输入一个网络域名(如yourdomain.com)和一个“返回网址”(如webddomain.com/callback)——我还不确定这些有什么用——并上传一个特殊文件到你的网络服务器上的一个特殊位置，你还必须给出一个“标识符”:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/0698d62470fa7abb06f5c7604b954755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2p1E9gqQHAJ6g012x0sp8g.png"/></div></div></figure><p id="a52b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它有一些陈述不充分的约束/属性。据我所知，它<em class="np">不可能</em> <strong class="ky ir"> </strong>与你的iOS应用ID相同。所以，我用了<code class="fe nk nl nm nn b">biz.SpasticMuffin.SharedImages.AppleSignIn</code>，到目前为止似乎还行。</p><p id="6690" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住，这个服务ID练习的要点是获取一个重定向URL，您需要它来创建刷新令牌。还记得刷新令牌吗？</p><p id="3399" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">鉴于上述所有情况，您应该能够将所有这些放在一起，并从授权代码创建刷新令牌。参见上面我引用的文件中的方法<code class="fe nk nl nm nn b">generateRefreshToken</code>—<code class="fe nk nl nm nn b">AppleSignInCreds+Refresh.swift</code>。</p><p id="233e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">深呼吸。一切顺利，现在你有一个刷新令牌。在我的服务器中，我将其保存到我的服务器数据库中的用户记录中，之后，不超过24小时，执行一次刷新令牌验证步骤。</p><p id="c13c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个验证步骤非常类似于上面生成刷新令牌的过程。见<code class="fe nk nl nm nn b">AppleSignInCreds+Refresh.swift</code>中我的方法<code class="fe nk nl nm nn b">validateRefreshToken</code>。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="d951" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">在关闭时</strong></h1><p id="b078" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">嗯，要么你把上面的都看完了，要么你只是浏览了一下。无论如何，它并不真的漂亮。在我集成到服务器上的五个OAuth类型的登录系统中，这一个是最大的挑战。也是我最不满意的一个。</p><p id="b612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么我不满意？让我们用我的谷歌登录框架的起点来回顾一下。</p><h2 id="edea" class="nv mo iq bd mp nw nx dn mt ny nz dp mx lf oa ob mz lj oc od nb ln oe of nd og bi translated">1.OAuth令牌—授权代码和访问令牌</h2><p id="5b96" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们确实可以通过苹果登录获得这两个版本。(而且我模糊了一个区别，把ID令牌称为访问令牌，这不太正确。)</p><h2 id="6e7d" class="nv mo iq bd mp nw nx dn mt ny nz dp mx lf oa ob mz lj oc od nb ln oe of nd og bi translated"><em class="oh"> 2。登录框架在客户端自动刷新访问令牌</em></h2><p id="2248" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们做<em class="np">不是</em> <strong class="ky ir"> </strong>得到这个。事实上，我们显然无法获得更新的ID令牌。</p><p id="ff1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我最大的一个问题。对于每个HTTP请求，我没有真正好的初始方法来验证我的服务器REST API中的用户——因为我似乎必须忽略ID令牌的到期日期。</p><h2 id="1017" class="nv mo iq bd mp nw nx dn mt ny nz dp mx lf oa ob mz lj oc od nb ln oe of nd og bi translated"><em class="oh"> 3。这些令牌可以被发送到我的定制服务器，并且访问令牌很容易被验证——使用Google端点</em></h2><p id="5406" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我一直在这里陈述困难。Apple推荐的验证ID令牌的方法不使用Apple端点。他们也不谈论令牌过期的问题。</p><h2 id="da6f" class="nv mo iq bd mp nw nx dn mt ny nz dp mx lf oa ob mz lj oc od nb ln oe of nd og bi translated"><em class="oh"> 4。初始令牌验证</em></h2><p id="f03d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">定制服务器上的初始令牌验证可以在端点请求处理的早期进行，无需访问定制服务器数据库(如<a class="ae kv" href="https://github.com/IBM-Swift/Kitura-Credentials" rel="noopener ugc nofollow" target="_blank"> Kitura凭证</a>中的样式)。</p><p id="9465" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许说得够多了。我对初始令牌验证不满意。</p><p id="407d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想知道是否存在安全漏洞，攻击者以某种方式获取用户的ID令牌。现在，他们可以永久访问服务器，因为令牌实际上不会过期。</p><p id="d641" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯。我想我需要使用额外的策略。上述工作的一部分，创建一个客户秘密，包括签署我自己的JWT。大约每24小时向客户发送一次我自己的JWT，并且可以检查它的到期时间，怎么样？以及在初始服务器交互后扔掉苹果的不过期ID令牌。</p><p id="dadb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯。但是没有。这似乎打开了一个更大的蠕虫罐。获得ID令牌的攻击者可能会继续获得这些额外的或新的JWT，并继续对服务器进行伪造的有效访问。</p><p id="be58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">似乎有必要让客户端能够向服务器发送一些正在进行的、更新的凭证。这些持续更新的凭证可以限制某人获得单个id令牌的攻击所造成的损害。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="10c8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">摘要</h1><p id="2125" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">总之，在服务器端使用苹果登录可能还为时过早。</p><p id="82bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们关于服务器端编码主要部分的文档很少。而且似乎缺乏对主要服务器端用例的支持:对定制服务器的REST API进行安全认证。</p><p id="c4fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我还不能得出结论，应该有一种方法在iOS客户端上获得更新的ID令牌。如果苹果能在这些问题上提供一些指导，我将不胜感激。</p><h2 id="4031" class="nv mo iq bd mp nw nx dn mt ny nz dp mx lf oa ob mz lj oc od nb ln oe of nd og bi translated"><strong class="ak">更新(10/19/19) </strong></h2><p id="c650" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我收到了苹果开发者技术支持的回复。我问:</p><blockquote class="oi oj ok"><p id="4f68" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">我的问题是，我想不出一个很好的方法来以这种方式使用苹果登录系统。我的主要问题是，Apple Sign In发行的id令牌显然无法更新，而且很快就会过期(10分钟后)。</p></blockquote><p id="aa19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">苹果回应道:</p><blockquote class="oi oj ok"><p id="c76d" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">我已经审查了您的请求，并得出结论，没有支持的方式来实现预期的功能给定当前的运输系统配置。</p></blockquote><p id="bf16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如这位支持人员进一步建议的那样，我将通过苹果反馈助手提出更改请求。此外，虽然我还没有得到证实(我在一个后续问题中要求证实)，但我计划以此为理由，在下一个<a class="ae kv" href="https://apps.apple.com/us/app/neebla/id1244482164" rel="noopener ugc nofollow" target="_blank"> Neebla </a>应用版本中暂时不支持苹果登录。</p><h2 id="80b6" class="nv mo iq bd mp nw nx dn mt ny nz dp mx lf oa ob mz lj oc od nb ln oe of nd og bi translated">进一步更新(2010年4月4日发布)</h2><p id="a286" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在2月2日20，我有进一步的电子邮件沟通苹果开发者技术支持(DTS)。不幸的是，他们只是在我已经知道的基础上增加了一些细节。我的问题还没有解决。</p><p id="7277" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在苹果DTS人员进一步回复，添加细节后，我回复如下(我添加了一些我发给苹果的邮件中没有的粗体字)。</p><blockquote class="oi oj ok"><p id="737d" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">感谢您的邮件和持续的支持。然而，我认为我们还没有就这个问题进行充分的沟通。</p><p id="6628" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">我怀疑这归结为对这种OAuth类型的系统应该支持的用例的期望。我认为苹果登录支持两种主要的用例:</p><p id="9357" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">(1) <strong class="ky ir">当用户首次登录iOS客户端时，从iOS应用程序(可能还有其他客户端应用程序)到自定义服务器的初始连接</strong>。identityToken可用于此目的，因为它不应在此初始连接的短暂持续时间内过期。</p><p id="cc9c" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">(2) <strong class="ky ir">在定制服务器上，最多每天一次验证</strong>特定用户是否仍然是有效用户(“确认用户在该设备上的Apple ID在苹果服务器上仍然保持良好信誉”)。这可以使用刷新令牌来完成。</p><p id="ef6a" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">就时间而言，我期望呈现的用例(到目前为止我还无法使用Apple Sign In解决)基本上落在上面的(1)和(2)之间。该用例是<strong class="ky ir">验证从iOS客户端应用程序到定制服务器</strong>的持续请求。这些请求位于identityToken过期后到24小时标记之间的时间间隔内。它们也落在每个后续24小时周期之间的间隔中。例如，用户在身份令牌最初到期后一小时(或到期后25小时，或49小时……)撤销访问应用程序的权利(例如，通过https://appleid.apple.com/account/manage<a class="ae kv" href="https://appleid.apple.com/account/manage" rel="noopener ugc nofollow" target="_blank"/>)。定制服务器如何处理这个问题？在我看来，在服务器上留出24小时的认证间隔是一个安全问题。攻击者可以访问用于身份验证的令牌，并获得长达24小时的服务器访问权限。</p><p id="68a9" class="kw kx np ky b kz la jr lb lc ld ju le ol lg lh li om lk ll lm on lo lp lq lr ij bi translated">对我来说，这是一个典型的在定制服务器上请求认证的主要用例，也是我可以在其他OAuth类型的系统上做的事情(例如，Google Sign In，脸书)。我更希望可以在客户端刷新访问令牌，或者在服务器端提供一些其他机制，以便可以更频繁地检查用户有效性(而不是每24小时一次)。</p></blockquote><h2 id="3ad0" class="nv mo iq bd mp nw nx dn mt ny nz dp mx lf oa ob mz lj oc od nb ln oe of nd og bi translated">最终更新(2020年7月)</h2><p id="55a4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">苹果公司正在更新他们的苹果登录系统。也许他们一直在听像我这样的人说话？:).参见<a class="ae kv" href="/@crspybits/part-ii-apple-sign-in-custom-servers-and-an-expiry-conundrum-b3e9735dc079?source=your_stories_page---------------------------" rel="noopener ugc nofollow" target="_blank">苹果登录:定制服务器和到期难题(第二部分)</a>。</p></div></div>    
</body>
</html>