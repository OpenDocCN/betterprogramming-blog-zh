<html>
<head>
<title>Local Variable Type Inference in Java 10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 10中的局部变量类型推理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/local-variable-type-inference-in-java-10-cb4967dd6eb0?source=collection_archive---------5-----------------------#2020-08-20">https://betterprogramming.pub/local-variable-type-inference-in-java-10-cb4967dd6eb0?source=collection_archive---------5-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d621" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更简洁的代码和更简单的变量声明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f36c97d925a04fde31fd18677dcccb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wgc8sP3To3zXeW2XxRViXg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异盐@ Ponshukan，JR新潟站|作者拍摄</p></figure><p id="14c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Java经常被批评为过于冗长。促成这种特征的一个方面是明确指定每种类型的要求，这导致了许多额外的<a class="ae lu" href="https://codeburst.io/signal-to-noise-ratio-a45ae45c3545" rel="noopener" target="_blank">噪声</a>。</p><p id="fe93" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用JDK 10和<a class="ae lu" href="https://openjdk.java.net/jeps/286" rel="noopener ugc nofollow" target="_blank"> JEP 286 </a> : <em class="lv">局部变量类型推断</em>给了我们一种新的更少杂乱的声明局部变量的方法。</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="ad9b" class="mb mc it lx b gy md me l mf mg"><strong class="lx iu">TABLE OF CONTENTS</strong></span><span id="9f31" class="mb mc it lx b gy mh me l mf mg"><a class="ae lu" href="#e55c" rel="noopener ugc nofollow">General Concept<br/></a><a class="ae lu" href="#f684" rel="noopener ugc nofollow">Reading Vs. Writing Code<br/></a><a class="ae lu" href="#389b" rel="noopener ugc nofollow">Explicit Context<br/></a><a class="ae lu" href="#94aa" rel="noopener ugc nofollow">Implicit Context</a><br/><a class="ae lu" href="#80c1" rel="noopener ugc nofollow">Caveats</a><br/><a class="ae lu" href="#1afb" rel="noopener ugc nofollow">Conclusion</a><br/><a class="ae lu" href="#be7b" rel="noopener ugc nofollow">Resources</a></span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="e55c" class="mp mc it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">一般概念</h1><p id="e184" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">名称本身完美地描述了该功能的核心及其局限性:</p><h2 id="cb16" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated"><strong class="ak">局部变量</strong></h2><ul class=""><li id="8cb1" class="nw nx it la b lb ng le nh lh ny ll nz lp oa lt ob oc od oe bi translated">仅支持局部变量</li><li id="047f" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated">没有方法参数</li><li id="a1b3" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated">没有返回类型</li><li id="16c2" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated">没有字段</li><li id="6c0d" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated">没有兰姆达斯</li></ul><h2 id="076a" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated"><strong class="ak">类型推断</strong></h2><p id="1961" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">Java编译器会自动为我们检测正确的类型。</p><p id="bb14" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实际上，这对于JDK来说并不是一个全新的功能。钻石运算符<code class="fe ok ol om lx b">&lt;&gt;</code> (JDK 7)已经支持推断类型，lambdas可以推断它们的参数类型(JDK 8):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="20ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这并不意味着Java突然变成了动态类型化的。所有类型都将在编译时推断，而不是在运行时，为我们提供了与以前相同的安全性。</p><h2 id="4eeb" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">如何使用'<code class="fe ok ol om lx b">var'</code></h2><p id="932e" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">基本思想很简单:当我们初始化一个局部变量时，我们可以用新引入的反向类型名<code class="fe ok ol om lx b">var</code>代替显式声明的左手类型。推断类型的所有信息必须由初始值设定项提供(例如，构造函数、文字、方法返回值):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="fba6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于<code class="fe ok ol om lx b">var</code>不是关键字，我们也可以使用<code class="fe ok ol om lx b">final</code>使变量不可重新赋值。</p><h2 id="7103" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">可能会有一些限制</h2><p id="d0d4" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">变量的类型在初始化时必须是可推断的，所以<code class="fe ok ol om lx b">null</code>是不允许的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="85f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Lambdas也不能用<code class="fe ok ol om lx b">var</code>表示，至少在没有显式强制转换的情况下不能。由于lambdas是由幕后的具体函数接口表示的，因此在没有附加上下文的情况下无法推断其类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="d4b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过将它强制转换成一个显式接口，我们也许能够让编译器满意。但是这种令人厌恶的行为并不符合<code class="fe ok ol om lx b">var</code>的本意。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="f684" class="mp mc it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">阅读与编写代码</h1><p id="d64b" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">我们的代码被阅读的次数会比被编写的次数多得多。</p><p id="0c89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编写代码时，所有的上下文仍然在那里。无论何时有人阅读我们的代码，甚至是我们自己，我们都需要能够用它来推理。</p><blockquote class="op oq or"><p id="ade7" class="ky kz lv la b lb lc ju ld le lf jx lg os li lj lk ot lm ln lo ou lq lr ls lt im bi translated">"程序是要被人类阅读的，只是偶尔让计算机执行."—唐纳德·克努特</p></blockquote><p id="3235" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Java的冗长可能是一种精神负担，因为它让我们面对比理解它实际所需更多的代码。有助于减少这些额外的、通常是多余的信息。但并不是所有被它删除的代码都是多余的。它可能会消除更大背景下的任何指标。</p><p id="5af4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">用代码进行推理意味着理解它的上下文和影响。如果我们删除显式类型信息，我们需要确保上下文可以通过其他方式推导出来。仅仅因为编译器可以推断出正确的类型并不意味着我们人类也可以这样做。</p><p id="aad8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该总是能够理解局部范围内的代码，而不知道围绕它的完整的更大的画面。这就是为什么不是每个局部变量声明都应该使用<code class="fe ok ol om lx b">var</code>的原因。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="389b" class="mp mc it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">显式上下文</h1><p id="24ac" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><code class="fe ok ol om lx b">var</code>的优秀用例是已经包含显式上下文的构造:构造函数、文字和静态工厂方法。</p><h2 id="5164" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">构造器</h2><p id="ca8e" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">构造函数是由它们的类型组成的，所以不可能有更多的信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8186" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不需要额外的上下文。</p><h2 id="8d8a" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">文字</h2><p id="2280" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">如果我们遵守它们的特殊符号，文字可以提供推断正确类型所需的所有上下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8216" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们不遵守，文字可能被推断为另一种类型。实际上，由于隐式转换，它们仍然可能工作。但是实际类型可能是错误的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="3f05" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">文字<code class="fe ok ol om lx b">byte</code>和<code class="fe ok ol om lx b">short</code>没有特殊的指示符，所以它们总是被推断为<code class="fe ok ol om lx b">int</code>。</p><h2 id="5c56" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">静态工厂方法</h2><p id="371c" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">许多类型包含静态工厂方法，通过类名或工厂方法名提供与构造函数一样多的信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="94aa" class="mp mc it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">隐含语境</h1><p id="f1d6" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated"><code class="fe ok ol om lx b">var</code>的另一个方面是替换不必要信息的能力。</p><h2 id="c59d" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">中间值</h2><p id="a4d7" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">局部变量是一种在狭窄范围内存储中间值的简单而廉价的方法。为了理解上下文，这些变量的实际类型可能没有它们的名称和它们的环境那么重要:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6e48" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用更好的变量名，我们可以依靠<code class="fe ok ol om lx b">var</code>并且仍然掌握上下文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="5681" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">环</h2><p id="9ac2" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">如前所述，使用<code class="fe ok ol om lx b">var</code>可以简化循环。通常，周围的上下文提供了足够的信息，所以我们不再需要显式类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="85ed" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">'用资源尝试'</h2><p id="8294" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">一个<code class="fe ok ol om lx b">try-with-resources </code>块可能非常冗长。但是多亏了<code class="fe ok ol om lx b">var</code>，我们可以让它们更简洁:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="be17" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">无商标消费品</h2><p id="fac2" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">特别是泛型类型声明，可能会很冗长。一个简单的<code class="fe ok ol om lx b">Iterator</code>可以复杂到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="01d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">知道了<code class="fe ok ol om lx b">Map</code>是什么类型，我们就不需要考虑迭代器或条目的显式类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f6a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是更容易的眼睛，仍然像以前一样容易理解。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="80c1" class="mp mc it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">警告</h1><p id="69a0" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">除了过度使用<code class="fe ok ol om lx b">var</code>和破坏有价值的信息之外，还有许多警告需要注意。</p><h2 id="485a" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">菱形算子</h2><p id="1065" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">如前所述，菱形运算符<code class="fe ok ol om lx b">&lt;&gt;</code>已经为我们提供了类型推断。编译器根据左边的声明推断右边的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="ad07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe ok ol om lx b">var</code>，我们不再拥有这些信息，必须在初始化器中自己提供:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="aa7e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，这并不意味着我们不能使用diamond操作符。如果初始化器由于其他情况提供了足够的信息，编译器可以推断出正确的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="ac60" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">接口与具体类型</h2><p id="79c0" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">通常，我们针对接口而不是具体的实现进行编码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="edda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种抽象为我们未来的变化提供了很大的灵活性。但是使用类型推断，我们<em class="lv">只</em>得到初始化器的类型，而不是它的接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f04d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于只对局部变量可用，这应该不会造成太大的问题。我们仍然应该针对公共接口的抽象进行编码。但在局部范围内，这并不重要。</p><h2 id="0a33" class="mb mc it bd mq nl nm dn mu nn no dp my lh np nq na ll nr ns nc lp nt nu ne nv bi translated">文字</h2><p id="8c7d" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">如前所述，文字需要通过特定于类型的指示符的附加上下文才能被正确推断:</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="f2f3" class="mb mc it lx b gy md me l mf mg"> <strong class="lx iu">TYPE</strong>   | <strong class="lx iu">INDICATOR</strong><br/>------- | ------------------------------------<br/> String | double-quoted<br/> char   | single-quoted<br/> int    | whole number<br/> long   | whole number ending with "L/l"<br/> float  | decimal number ending with "f/F"<br/> double | decimal number, optional "d/D"<br/> byte   | no indicator, always inferred to int<br/> short  | no indicator, always inferred to int</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1afb" class="mp mc it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="4f1b" class="pw-post-body-paragraph ky kz it la b lb ng ju ld le nh jx lg lh ni lj lk ll nj ln lo lp nk lr ls lt im bi translated">更多的类型推断是Java的一大亮点。静态编译时类型安全与更少的输入和更简洁的代码是双赢的。省略显式类型可以减少混乱，只要我们有其他信息来推断上下文。</p><p id="7bfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是不仅仅是不加区别地用<code class="fe ok ol om lx b">var </code>替换现有的类型声明。代码必须根据其周围的环境进行推理。</p><p id="8120" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过选择更好的变量名和缩小中间值的范围来改善这种上下文。如果使用类型推断仍然损害可理解性，这可能是更深层次结构问题的一个指标，并且<code class="fe ok ol om lx b">var</code>可能不是最好的方法。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt lw lx ov bn ow ox bi"><span id="ab78" class="oy mc it lx b be oz pa l mf mg"><strong class="lx iu">You like my ramblings about Java? Check out my upcoming book!</strong><br/><a class="ae lu" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="be7b" class="mp mc it bd mq mr pb mt mu mv pc mx my jz pd ka na kc pe kd nc kf pf kg ne nf bi translated">资源</h1><ul class=""><li id="9b44" class="nw nx it la b lb ng le nh lh ny ll nz lp oa lt ob oc od oe bi translated"><a class="ae lu" href="https://openjdk.java.net/jeps/286" rel="noopener ugc nofollow" target="_blank"> JEP-286 </a> (OpenJDK)</li><li id="f81b" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><a class="ae lu" href="https://openjdk.java.net/projects/amber/LVTIFAQ.html" rel="noopener ugc nofollow" target="_blank">局部变量类型推断:常见问题解答</a> (OpenJDK)</li><li id="02cc" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><a class="ae lu" href="http://openjdk.java.net/projects/amber/LVTIstyle.html" rel="noopener ugc nofollow" target="_blank">局部变量类型推断:样式指南</a> (OpenJDK)</li><li id="240c" class="nw nx it la b lb of le og lh oh ll oi lp oj lt ob oc od oe bi translated"><a class="ae lu" href="https://www.youtube.com/watch?v=786iemaCJHU" rel="noopener ugc nofollow" target="_blank">Var with Style:Stuart Marks的Java 10中的局部变量类型推理</a> (YouTube)</li></ul></div></div>    
</body>
</html>