<html>
<head>
<title>7 Ways to Inherit Styles Using Styled Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用样式组件继承样式的7种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-ways-to-inherit-styles-using-styled-components-69debaad97e3?source=collection_archive---------0-----------------------#2022-06-27">https://betterprogramming.pub/7-ways-to-inherit-styles-using-styled-components-69debaad97e3?source=collection_archive---------0-----------------------#2022-06-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="53d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解样式组件编码技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/55d6aa125ee58e816262c8fa0ff16c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*STx553pjkB2ZBY_2FVtcKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="63ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">是一个流行的React应用程序风格库，每周下载量超过400万次。它采用CSS-in-JS方法，将每个JavaScript组件与其所有的CSS规则和依赖项捆绑在一起。结合代码分割，它只加载最少的必要代码。</p><p id="bf6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">styled-components</code>中，CSS样式被写成自定义的React组件。在编译期间，很容易跟踪哪些组件是未使用的或未定义的。它通过比较类名或其他方式来提高代码的可管理性。因为它是JavaScript中的CSS，所以它支持具有编程能力的动态样式。</p><p id="1663" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在之前的一篇文章中，我们已经介绍了什么是<code class="fe lu lv lw lx b">styled-components</code>以及如何使用它。我们已经使用<code class="fe lu lv lw lx b">styled-components</code>很多年了，并且经常从现有的组件中创建扩展的组件。在本文中，我们将探讨如何使用样式化组件来继承/共享样式。</p><ul class=""><li id="3ac6" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated"><a class="ae ly" href="#8411" rel="noopener ugc nofollow">在父级配置共享样式</a></li><li id="f6fa" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae ly" href="#af15" rel="noopener ugc nofollow">为应用程序创建全局样式</a></li><li id="b79d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae ly" href="#f5ce" rel="noopener ugc nofollow">使用扩展样式组件</a></li><li id="d328" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae ly" href="#6eec" rel="noopener ugc nofollow">使用合成的CSS道具</a></li><li id="a3ac" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae ly" href="#56a7" rel="noopener ugc nofollow">使用插值函数计算样式值</a></li><li id="ee48" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae ly" href="#07f8" rel="noopener ugc nofollow">使用插值函数计算CSS属性</a></li><li id="bcad" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated"><a class="ae ly" href="#8408" rel="noopener ugc nofollow">用样式对象创建样式组件</a></li></ul><h1 id="16d6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">在Create React应用程序中设置样式组件</h1><p id="b3be" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们使用<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/an-in-depth-guide-for-create-react-app-5-cra-5-b94b03c233f2">创建React App </a>作为探索<code class="fe lu lv lw lx b">styled-components</code>的基础。以下命令创建一个React项目:</p><pre class="kj kk kl km gt nk lx nl nm aw nn bi"><span id="b932" class="no mo it lx b gy np nq l nr ns">% npx create-react-app react-styled-components<br/>% cd react-styled-components</span></pre><p id="f794" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">设置<code class="fe lu lv lw lx b">styled-components</code>:</p><pre class="kj kk kl km gt nk lx nl nm aw nn bi"><span id="afff" class="no mo it lx b gy np nq l nr ns">npm i styled-components</span></pre><p id="7fd7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">styled-components</code>成为<code class="fe lu lv lw lx b">package.json</code>中<code class="fe lu lv lw lx b"><a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/package-jsons-dependencies-in-depth-a1f0637a3129">dependencies</a></code>的一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="af20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们修改<code class="fe lu lv lw lx b">src/App.js</code>来使用<code class="fe lu lv lw lx b">styled-components</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="dba9" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第1行，<code class="fe lu lv lw lx b">styled</code>是从<code class="fe lu lv lw lx b">styled-components</code>导入的。<code class="fe lu lv lw lx b">styled</code>是默认的导出，用于创建<code class="fe lu lv lw lx b">styled.tagname</code>助手方法，将样式从JavaScript转换为实际的CSS规则。</li><li id="aeba" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第3–8行，样式化的组件<code class="fe lu lv lw lx b">Container</code>扩展了<code class="fe lu lv lw lx b">div</code>的样式。它包含了<code class="fe lu lv lw lx b">flex</code>布局的CSS属性。</li><li id="8709" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第10–23行，样式化组件<code class="fe lu lv lw lx b">BlueItem</code>扩展了<code class="fe lu lv lw lx b">div</code>的样式。它包含蓝色组件的CSS属性。</li><li id="a40d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第25–38行，样式化组件<code class="fe lu lv lw lx b">GreenItem</code>扩展了<code class="fe lu lv lw lx b">div</code>的样式。它包含绿色组件的CSS属性。</li><li id="c1e4" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第40–53行，样式化组件<code class="fe lu lv lw lx b">OvalItem</code>扩展了<code class="fe lu lv lw lx b">div</code>的样式。它包含oval组件的CSS属性。</li><li id="eda8" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">这些样式化的组件用于构建React应用程序，位于第57–61行。</li><li id="e2eb" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，我们在浏览器中看到如下UI。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1ac525441d09a50e2836cecd295ef53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*s_beTu8HDZnwEbha6-zn4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="bdcf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码有效。但是，<code class="fe lu lv lw lx b">BlueItem</code>、<code class="fe lu lv lw lx b">GreenItem</code>和<code class="fe lu lv lw lx b">OvalItem</code>之间有许多重复的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6a6d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们应该努力继承/分享相似的风格。</p><h1 id="8411" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">在父级配置共享样式</h1><p id="5a09" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">默认情况下，或者通过将值设置为<code class="fe lu lv lw lx b">inherit</code>，一些CSS属性可以被子元素继承。<a class="ae ly" href="https://www.w3.org/TR/CSS21/propidx.html" rel="noopener ugc nofollow" target="_blank">该CSS属性列表</a>显示默认情况下会继承以下属性:<code class="fe lu lv lw lx b">azimuth</code>、<code class="fe lu lv lw lx b">border-collapse</code>、<code class="fe lu lv lw lx b">border-spacing</code>、<code class="fe lu lv lw lx b"> caption-side</code>、<code class="fe lu lv lw lx b">color</code>、<code class="fe lu lv lw lx b">cursor</code>、<code class="fe lu lv lw lx b">direction</code>、<code class="fe lu lv lw lx b">elevation</code>、<code class="fe lu lv lw lx b">empty-cells</code>、<code class="fe lu lv lw lx b">font-family</code>、<code class="fe lu lv lw lx b">font-size</code>、<code class="fe lu lv lw lx b">font-style</code>、<code class="fe lu lv lw lx b">font-variant</code>、<code class="fe lu lv lw lx b">font-weight</code>、<code class="fe lu lv lw lx b">font</code>、<code class="fe lu lv lw lx b">letter-spacing</code>、<code class="fe lu lv lw lx b">line-height</code>、<code class="fe lu lv lw lx b">list-style-image</code>、<code class="fe lu lv lw lx b">list-style-position</code>、<code class="fe lu lv lw lx b">list-style-type</code>、<code class="fe lu lv lw lx b">list-style</code>、<code class="fe lu lv lw lx b">orphans</code>、<code class="fe lu lv lw lx b">orphans</code></p><p id="0944" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们复制的属性中，<code class="fe lu lv lw lx b">font</code>属性是默认继承的。它可以向上移动到父节点<code class="fe lu lv lw lx b">Container</code>，以节省几行代码(下面代码中的第6行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9551" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，有效。</p><p id="521b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们修改这些条目，从<code class="fe lu lv lw lx b">button</code>扩展，而不是<code class="fe lu lv lw lx b">div</code>(下面代码中的第1、15和29行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7ffd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行<code class="fe lu lv lw lx b">npm start</code>。不再继承<code class="fe lu lv lw lx b">font</code>属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/4f06f02405791262b2edb332956cd184.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*G41uCKgqll4SOivTYdbimQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="b074" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为大多数表单元素，如<code class="fe lu lv lw lx b">button</code>、<code class="fe lu lv lw lx b">input</code>、<code class="fe lu lv lw lx b">textarea</code>和<code class="fe lu lv lw lx b">select</code>，默认情况下不继承<code class="fe lu lv lw lx b">font*</code>属性。</p><p id="9c0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，有一个<code class="fe lu lv lw lx b">as</code>属性可以呈现一个样式化的组件，就像它是指定的元素一样。如果我们在下面代码的第56、57和58行指定<code class="fe lu lv lw lx b">button</code> <code class="fe lu lv lw lx b">as</code> <code class="fe lu lv lw lx b">div</code>，它将正常工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6614" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果没有<code class="fe lu lv lw lx b">as</code>属性，我们必须显式地将<code class="fe lu lv lw lx b">font</code>属性设置为<code class="fe lu lv lw lx b">inherit</code>。</p><p id="ba7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码也可以，在第12、23和34行将<code class="fe lu lv lw lx b">font</code>属性设置为<code class="fe lu lv lw lx b">inherit</code>。同样，对于一个按钮，不需要指定这些属性:<code class="fe lu lv lw lx b">display</code>、<code class="fe lu lv lw lx b">align-items</code>、<code class="fe lu lv lw lx b">justify-content</code>和<code class="fe lu lv lw lx b">box-sizing</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="af15" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">为应用程序创建全局样式</h1><p id="f521" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">有一个助手功能<code class="fe lu lv lw lx b">createGlobalStyle</code>，可以为整个app创建最顶层的共享样式。</p><p id="aa28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是<code class="fe lu lv lw lx b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="4533" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第1行，<code class="fe lu lv lw lx b">createGlobalStyle</code>和<code class="fe lu lv lw lx b">styled</code>一起被导入。</li><li id="4455" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第52–54行，<code class="fe lu lv lw lx b">GlobalStyle</code>是用助手函数<code class="fe lu lv lw lx b">createGlobalStyle</code>生成的。全局上，<code class="fe lu lv lw lx b">font</code>设置为<code class="fe lu lv lw lx b">20px Arial</code>。</li><li id="79e8" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第58行，为应用程序设置了<code class="fe lu lv lw lx b">GlobalStyle</code>。</li><li id="5191" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，有效。</li></ul><p id="0860" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们从<code class="fe lu lv lw lx b">button</code>开始修改扩展项，所有的问题和解决方法都和在父级配置共享样式一样。唯一的区别是global是整个应用程序的最高父级。</p><h1 id="f5ce" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated"><strong class="ak">使用扩展样式的组件</strong></h1><p id="8959" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">对于我们的例子，三个项目彼此略有不同。我们可以从现有的扩展新的，并且只指定变化。</p><p id="320f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是<code class="fe lu lv lw lx b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="dc22" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第21–25行，样式化组件<code class="fe lu lv lw lx b">GreenItem</code>用附加属性扩展了<code class="fe lu lv lw lx b">BlueItem</code>。</li><li id="70a1" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第27–29行，样式化的组件<code class="fe lu lv lw lx b">OvalItem</code>，用一个附加属性扩展了<code class="fe lu lv lw lx b">GreenItem</code>。</li><li id="0c2e" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，它起作用了。</li></ul><p id="2f18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了更好的设计，我们应该定义一个<code class="fe lu lv lw lx b">BaseItem</code>，它只包含常见的样式。然后，<code class="fe lu lv lw lx b">BlueItem</code>、<code class="fe lu lv lw lx b">GreenItem</code>、<code class="fe lu lv lw lx b">OvalItem</code>从<code class="fe lu lv lw lx b">BaseItem</code>开始延伸。</p><p id="56cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们没有以“正确的方式”做这件事有两个原因:</p><ol class=""><li id="2137" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt nw mf mg mh bi translated">展示子样式组件可以覆盖基本样式。</li><li id="669d" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt nw mf mg mh bi translated">用更少的组件保存一些代码行。</li></ol><h1 id="6eec" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用合成的CSS道具</h1><p id="00cc" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们可以组合<code class="fe lu lv lw lx b">css</code>道具来实现相同的风格，而不是扩展样式化的组件。有一个助手函数<code class="fe lu lv lw lx b">css</code>，它通过插值从<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/manipulating-javascript-strings-using-template-literals-f7070412099f">模板文字</a>生成CSS属性。</p><p id="411f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是<code class="fe lu lv lw lx b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="3dff" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第1行，<code class="fe lu lv lw lx b">css</code>和<code class="fe lu lv lw lx b">styled</code>一起被导入。</li><li id="42bc" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第10–19行，css模板文本<code class="fe lu lv lw lx b">blueItem</code>生成在第34行使用的CSS属性。</li><li id="6c8a" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第21–25行，css模板文本<code class="fe lu lv lw lx b">greenItem</code>生成额外的CSS属性。<code class="fe lu lv lw lx b">blueItem</code>和<code class="fe lu lv lw lx b">greenItem</code>在第35行组合使用。</li><li id="49de" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第27–29行，css模板文本<code class="fe lu lv lw lx b">ovalItem</code>生成额外的CSS属性。<code class="fe lu lv lw lx b">blueItem</code>、<code class="fe lu lv lw lx b">greenItem</code>和<code class="fe lu lv lw lx b">ovalItem</code>在第36行组成并使用。</li><li id="fa3c" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，它不能正常工作。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/07aa32d3d2f2af144ba0dce089c2d323.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*o2vK9gBmIy-nnjpV2sjPjw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a522" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">发生了什么事？</p><p id="6765" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">css</code>道具不是<code class="fe lu lv lw lx b">button</code>的属性。为了让它工作，需要使用<code class="fe lu lv lw lx b"><a class="ae ly" href="https://github.com/styled-components/babel-plugin-styled-components" rel="noopener ugc nofollow" target="_blank">babel-plugin-styled-components</a></code>将任何带有<code class="fe lu lv lw lx b">css</code>的元素转换成样式化的组件。</p><p id="f6ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">styled-components</code>安装后，<code class="fe lu lv lw lx b">babel-plugin-styled-components</code>和<code class="fe lu lv lw lx b"><a class="ae ly" href="https://github.com/kentcdodds/babel-plugin-macros" rel="noopener ugc nofollow" target="_blank">babel-plugin-macros</a></code>在<code class="fe lu lv lw lx b">package-lock.json</code>中自带。</p><p id="4384" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们需要做的就是从宏目录中导入项目:</p><pre class="kj kk kl km gt nk lx nl nm aw nn bi"><span id="5d86" class="no mo it lx b gy np nq l nr ns">import styled, { css, keyframes } from 'styled-components<strong class="lx iu">/macro</strong>';</span></pre><p id="1339" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想用<code class="fe lu lv lw lx b">babel-plugin-styled-components</code>试试另一种解决方案吗？</p><p id="d636" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行<code class="fe lu lv lw lx b">npm run eject</code>，将Babel插件(下面代码中的第5行)添加到弹出的<code class="fe lu lv lw lx b">package.json</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bba2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">无论哪种方式，它都像预期的那样工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/1ac525441d09a50e2836cecd295ef53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*s_beTu8HDZnwEbha6-zn4w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="fdef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，可以在模板文字中完成合成(下面代码中的第22行和第29行):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="56a7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用插值函数计算样式值</h1><p id="bc41" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们可以传递一个函数来插入样式化组件的模板文本，并用它来计算样式值。</p><p id="7f2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有多种方法来定义插值属性。下面是一个将道具设置为<code class="fe lu lv lw lx b">fontStyle</code>、<code class="fe lu lv lw lx b">color</code>和<code class="fe lu lv lw lx b">borderRadius</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="7b3b" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第10–19行，样式化的组件<code class="fe lu lv lw lx b">Item</code>使用道具<code class="fe lu lv lw lx b">fontStyle</code>、<code class="fe lu lv lw lx b"> color</code>和<code class="fe lu lv lw lx b">borderRadius</code>。<code class="fe lu lv lw lx b">font-style</code>(第14行)<code class="fe lu lv lw lx b">color</code>(第15行)<code class="fe lu lv lw lx b">border</code>(第17行)<code class="fe lu lv lw lx b">border-radius</code>(第18行)根据道具调整数值。</li><li id="1e85" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，工作。</li></ul><p id="654a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个将道具设置为<code class="fe lu lv lw lx b">itemType</code>的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="d847" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第10–21行，样式组件<code class="fe lu lv lw lx b">Item</code>使用道具<code class="fe lu lv lw lx b">itemType</code>。<code class="fe lu lv lw lx b">font-style</code>(第14-25行)<code class="fe lu lv lw lx b">color</code>(第16行)<code class="fe lu lv lw lx b">border</code>(第18-19行)<code class="fe lu lv lw lx b">border-radius</code>(第20行)根据<code class="fe lu lv lw lx b">itemType</code>调整数值。</li><li id="1296" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，有效。</li></ul><h1 id="07f8" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用插值函数计算CSS属性</h1><p id="5d0c" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">在上面的代码中，我们对<code class="fe lu lv lw lx b">color</code>进行了如下配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3cfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们想让<code class="fe lu lv lw lx b">ovalItem</code>成为<code class="fe lu lv lw lx b">purple</code>呢？多重三元运算会使代码难以阅读。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1091" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">助手函数<code class="fe lu lv lw lx b">css</code>，可以用来计算CSS道具。</p><p id="51e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是<code class="fe lu lv lw lx b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="b954" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第1行，<code class="fe lu lv lw lx b">css</code>和<code class="fe lu lv lw lx b">styled</code>一起被导入。</li></ul><p id="92b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们没有使用函数来生成每个属性值，而是使用它来计算CSS属性(第17–22行、第24–29行和第31–36行)。</p><p id="91d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，我们会在浏览器中看到如下界面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f4313169cf8aa12a6a0e202eaf8ac84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*GFD4IVxMX11JmAvibFbRnA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7883" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者，可以使用<code class="fe lu lv lw lx b">css</code>助手在外部定义<code class="fe lu lv lw lx b">interpolate</code>函数(下面代码中的第10–33行)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="8408" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用样式对象创建样式组件</h1><p id="bd29" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated"><code class="fe lu lv lw lx b">styled-components</code>可选地支持将CSS写成JavaScript对象，而不是字符串。这使得操纵对象变得简单而有用。</p><p id="2978" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里是<code class="fe lu lv lw lx b">src/App.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><ul class=""><li id="70d8" class="lz ma it la b lb lc le lf lh mb ll mc lp md lt me mf mg mh bi translated">在第10–19行，定义了样式化对象<code class="fe lu lv lw lx b">blueItemObject</code>。</li><li id="2bd5" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第21行，样式化的组件<code class="fe lu lv lw lx b">BlueItem</code>是从<code class="fe lu lv lw lx b">blueItemObject</code>创建的。</li><li id="efba" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第23–28行，样式化的对象<code class="fe lu lv lw lx b">greenItemObject</code>由<code class="fe lu lv lw lx b">blueItemObject</code>和附加道具定义。</li><li id="5a90" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第30行，样式化的组件<code class="fe lu lv lw lx b">GreenItem</code>是从<code class="fe lu lv lw lx b">greenItemObject</code>创建的。</li><li id="0c51" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第32–37行，样式化的对象<code class="fe lu lv lw lx b">ovalItemObject</code>由<code class="fe lu lv lw lx b">greenItemObject</code>和附加道具定义。</li><li id="2cc0" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">在第39行，样式化的组件<code class="fe lu lv lw lx b">OvalItem</code>是从<code class="fe lu lv lw lx b">ovalItemObject</code>创建的。</li><li id="4517" class="lz ma it la b lb mi le mj lh mk ll ml lp mm lt me mf mg mh bi translated">执行<code class="fe lu lv lw lx b">npm start</code>，工作正常。</li></ul><h1 id="9516" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="1c32" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated"><code class="fe lu lv lw lx b">styled-components</code>是一个流行的库，用于设计React应用程序。它被React项目广泛采用。通常，需要创建从现有组件扩展而来的组件。我们已经探讨了如何使用样式化组件继承/共享样式的七种方式。</p><p id="f60c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢阅读。</p><p id="ad32" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">希望有些方法对你的项目有用。</p><p id="93e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有兴趣，看看<a class="ae ly" href="https://jenniferfubook.medium.com/jennifer-fus-web-development-publications-1a887e4454af#266e" rel="noopener">其他风格的组件文章</a>。</p></div></div>    
</body>
</html>