<html>
<head>
<title>useBreakpoint Hook — Get Media Query Breakpoints in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用断点挂钩—在React中获取媒体查询断点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/usebreakpoint-hook-get-media-query-breakpoints-in-react-3f1779b73568?source=collection_archive---------1-----------------------#2019-10-01">https://betterprogramming.pub/usebreakpoint-hook-get-media-query-breakpoints-in-react-3f1779b73568?source=collection_archive---------1-----------------------#2019-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b755" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建一个自定义挂钩来获取窗口宽度或断点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/431fc62096e50a5b84c2402a375e3026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qx5PHkuQkQStWZk6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">米凯尔·克里斯滕森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="b1cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用媒体查询根据CSS中的视区宽度轻松选择UI设计，但有时您需要获得窗口宽度或断点，以便根据React中的视区宽度调整UI。</p><p id="76e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了在React中实现这一点，我们将创建一个定制钩子<code class="fe lv lw lx ly b">useBreakpoint</code>，它将根据窗口宽度给出<code class="fe lv lw lx ly b">xs</code>、<code class="fe lv lw lx ly b">sm</code>、<code class="fe lv lw lx ly b">md</code>和<code class="fe lv lw lx ly b">lg</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f737" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们需要测量什么以及何时测量？</h1><p id="8b2a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了获得断点，我们需要测量浏览器的宽度，并在<code class="fe lv lw lx ly b">window</code>对象上获得该宽度。<code class="fe lv lw lx ly b">window</code>对象有两种宽度:<code class="fe lv lw lx ly b">outerWidth</code>和<code class="fe lv lw lx ly b">innerWidth</code>，我们将只使用<code class="fe lv lw lx ly b">innerWidth</code>。</p><p id="8869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了需要度量的东西，但是我们什么时候需要度量它。每当我们调整窗口大小时，我们测量<code class="fe lv lw lx ly b">window.innerWidth</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1b0e" class="nh mh it ly b gy ni nj l nk nl">function calcInnerWidth() {<br/>  /* Get window inner width here */</span><span id="e005" class="nh mh it ly b gy nm nj l nk nl">}</span><span id="6d86" class="nh mh it ly b gy nm nj l nk nl">window.addEventListener('resize', calcInnerWidth)</span></pre><p id="ca1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，每当我们调整窗口大小时，<code class="fe lv lw lx ly b">resize</code>事件被触发，我们计算<code class="fe lv lw lx ly b">innerWidth</code>，但是实现这样的东西有一个小问题，你们中的一些人可能已经发现了。</p><p id="7916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当我们稍微调整窗口大小时，回调函数<code class="fe lv lw lx ly b">calcInnerWidth</code>就会被触发，也就是说，如果我们调整窗口大小时，比如说100毫秒，它会多次执行回调函数。</p><p id="b60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了克服这一点，我们将以给定的时间间隔调用回调函数。</p><p id="f519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于节流功能，我们将使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://lodash.com/docs" rel="noopener ugc nofollow" target="_blank">lodash.throttle</a></code>包。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="28d4" class="nh mh it ly b gy ni nj l nk nl">import throttle from 'lodash.throttle';</span><span id="38a6" class="nh mh it ly b gy nm nj l nk nl">/------- Other Code Goes Here ------/</span><span id="5bcd" class="nh mh it ly b gy nm nj l nk nl">function calcInnerWidth() {<br/>  /* Get window inner width here */</span><span id="4008" class="nh mh it ly b gy nm nj l nk nl">}</span><span id="151d" class="nh mh it ly b gy nm nj l nk nl">window.addEventListener('resize', throttle(calcInnerWidth, 200))</span></pre><p id="cdb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe lv lw lx ly b">calcInnerWidth</code>函数最多每200毫秒调用一次。当我们从这个回调函数内部更新我们的状态时，这将派上用场。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ac55" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">计算断点</h1><p id="3705" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们有了需要测量的内容，当我们需要测量时，让我们根据断点获取设备类型。</p><ul class=""><li id="5a15" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">如果宽度小于320px，那么那个设备就是特小，用<code class="fe lv lw lx ly b">xs</code>表示。</li><li id="b710" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果宽度等于或大于320px，小于720px，那么那个设备小，用<code class="fe lv lw lx ly b">sm</code>表示。</li><li id="49b8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果宽度等于或大于720px，小于1024px，那么那个设备是中型的，用<code class="fe lv lw lx ly b">md</code>表示。</li><li id="5e11" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果宽度等于或大于1024px，则该设备较大，用<code class="fe lv lw lx ly b">lg</code>表示。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码1</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9db3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用断点挂钩</h1><p id="9750" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们有了所有需要的细节，让我们连接React中的所有部分，得到一个完整的<code class="fe lv lw lx ly b">useBreakpoint</code>定制钩子。</p><p id="d104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将使用<code class="fe lv lw lx ly b">useState</code>钩子创建一个状态，它将存储我们当前的设备类型。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="17f4" class="nh mh it ly b gy ni nj l nk nl">const [brkPnt, setBrkPnt] = useState(() =&gt;  getDeviceConfig(window.innerWidth))</span></pre><p id="9855" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当这个钩子被执行时，<code class="fe lv lw lx ly b">brkPnt</code>的初始值将是当前的设备类型。</p><p id="2e57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要在每次调整窗口大小时计算断点。这个计算是一个副作用，所以我们将使用<code class="fe lv lw lx ly b">useEffect</code>钩子来计算它。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="72f0" class="nh mh it ly b gy ni nj l nk nl">useEffect(() =&gt; {</span><span id="96c7" class="nh mh it ly b gy nm nj l nk nl">window.addEventListener('resize', throttle(function() {</span><span id="baab" class="nh mh it ly b gy nm nj l nk nl">setBrkPnt(getDeviceConfig(window.innerWidth));</span><span id="f5fc" class="nh mh it ly b gy nm nj l nk nl">}, 200))<br/>})</span></pre><p id="6b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不希望每次这个钩子被重新调用时都注册事件监听器，也就是说，要么父钩子被更新，要么状态<code class="fe lv lw lx ly b">brkPnt</code>被改变。</p><p id="911f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望它在第一次装载时注册事件处理程序，我们还希望它在卸载时从该事件中取消注册。</p><p id="acf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现这一点，我们必须传递一个空数组<code class="fe lv lw lx ly b">[]</code>作为<code class="fe lv lw lx ly b">useEffect</code>的第二个参数，这表示我们的<code class="fe lv lw lx ly b">useEffect</code>钩子没有依赖关系，传递给它的回调将只被调用一次，即在它所在的组件被挂载之后。</p><p id="0961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了从<code class="fe lv lw lx ly b">resize</code>事件中取消注册，我们需要从<code class="fe lv lw lx ly b">useEffect</code>回调函数中返回一个函数，每当我们的组件被卸载时，这个函数就会被执行，并将我们所有的逻辑放在那里。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2f13" class="nh mh it ly b gy ni nj l nk nl">useEffect(() =&gt; {</span><span id="22a4" class="nh mh it ly b gy nm nj l nk nl">const calcInnerWidth = throttle(function() {</span><span id="0843" class="nh mh it ly b gy nm nj l nk nl">setBrkPnt(getDeviceConfig(window.innerWidth))</span><span id="89b5" class="nh mh it ly b gy nm nj l nk nl">}, 200)</span><span id="6bf2" class="nh mh it ly b gy nm nj l nk nl">window.addEventListener('resize', calcInnerWidth)</span><span id="3a5b" class="nh mh it ly b gy nm nj l nk nl">return () =&gt; window.removeEventListener('resize', calcInnerWidth)</span><span id="f2b6" class="nh mh it ly b gy nm nj l nk nl">}, [])</span></pre><p id="82d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们将整个代码连接在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码2</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a2f8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码3</p></figure><p id="4667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:关于这个问题的更优化和更好的解决方案，请看<a class="ae ky" href="https://medium.com/better-programming/how-to-use-media-queries-programmatically-in-react-4d6562c3bc97" rel="noopener">这篇</a>帖子</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="467b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">资源</h1><div class="od oe gp gr of og"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Window.innerWidth</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">浏览器窗口视区的宽度(以像素为单位),包括垂直滚动条(如果渲染的话)。注意:如果您使用…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">developer.mozilla.org</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">窗口:调整事件大小</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">在一些早期的浏览器中，可以在任何HTML元素上注册resize事件处理程序。仍然有可能…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">developer.mozilla.org</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>