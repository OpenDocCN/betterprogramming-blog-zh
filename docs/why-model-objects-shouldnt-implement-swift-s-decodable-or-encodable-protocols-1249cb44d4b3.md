# 为什么模型对象不能实现 Swift 的可解码或可编码协议

> 原文：<https://betterprogramming.pub/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3>

## 良好做法

## 以及哪些对象应该

![](img/8a4ce95768ddcd16c86db87d8986d0a6.png)

照片由 [Michael Dziedzic](https://unsplash.com/@lazycreekimages?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/search/photos/trespassing?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

到目前为止，你可能在想:“他在说什么？`Decodable`和`Encodable`协议很有用！”

我同意你的观点。`Decodable`和`Encodable`协议确实非常有用。例如，Swift 提供了一种本地方式来解析 JSON 元素，或者从*用户默认设置*中存储和检索对象，这很棒。没毛病。

但是，我认为我们在模型对象中使用这些协议是错误的。我会试着解释为什么。

# 领域模型和数据模型

*域模型*是一个面向对象的模型，它结合了行为和数据。这是我们试图建模的业务规则的代表。

*数据模型*是持久性存储中的数据结构。它没有行为。

持久性存储的一些例子有*用户默认值*、*核心数据*、文件、数据库，甚至外部 API。这些商店的数据模型可能各不相同。

领域模型和数据模型都包含数据，但是领域模型也包含业务规则。

域模型中的对象应该不知道使用了哪个持久存储或数据模型。

那是因为领域模型和数据模型有不同的改变理由。只有当业务规则发生变化或者对要解决的问题有了更多的了解时，领域模型才应该发生变化。

另一方面，数据模型可能因为不同的原因而改变。例如，持久性存储需要从本地存储更改为远程 API。领域模型不应该受到基础设施变化的影响。

# 可解码和可编码

`Decodable`协议用于*水合来自一些外部表示的*对象。例如，它用于将 JSON 对象解析成结构或类。

> 可解码的:一种可以从外部表示中解码自身的类型。

另一方面，`Encodable`协议用于将对象存储到某种外部表示中。例如，它可以用来获得一个对象的 JSON 表示。

> 可编码的:一种可以将自身编码成外部表示的类型。

但是为什么我们不应该在我们的领域模型对象中使用`Decodable`或`Encodable`？

让我们用一个例子来回答这个问题。假设我们有以下用户的 JSON 表示:

```
{
   **"first_name"**:"dick",
   **"last_name"**:"richardson",
   **"mail"**:"drichardson@enclave.com",
   **"day_of_birth"**:7026198103
}
```

我们使用一个名为`User`的`Decodable`结构来解析 JSON 并在我们的域模型中表示一个`User`:

但是如果 JSON 改变了会发生什么呢？假设现在`first`和`last`名称在`name` 字段中:

```
{
   **"name"**:{
      **"first"**:"dick",
     ** "last"**:"richardson"
   },
   **"email"**:"drichardson@enclave.com",
   **"day_of_birth"**:7026198103
}
```

由于这个小小的变化，以前的`User`结构现在无法解析 JSON 数据。我们被迫改变领域模型来解析新的数据模型:

很好。现在`User`结构解析新的 JSON 格式，但是我们必须改变`firstName`和`lastName`的所有用法，分别替换为`name.first`和`name.last`。

由于数据的变化，我们刚刚更改了我们的领域模型。

这就是我在我的领域模型对象中不使用`Decodable`或`Encodable`的原因。

# 将领域模型与数据模型分开

我们需要做的是将领域模型从数据模型中分离出来。

我们可以通过使用两个不同的类或结构来实现这一点。一个解析 JSON，另一个表示域模型对象。

注意`User`不再实现`Decodable`协议，因为它不再用于解析 JSON 数据。`User`现在表示领域模型，并且从数据模型中分离出来。

我们已经创建了一个名为`UserDTO`(数据传输对象)的`Decodable`结构，用于解析 JSON 数据。这个结构包含创建一个`User`所需的数据。

最后，a `UserDTOMapper`从 de `UserDTO`数据中创建一个新的`User`。

# 优势

由于这种方法，领域模型不再与数据耦合，并且不需要每次数据模型改变时都改变。

当然，领域模型并不能避免所有的数据变化。有时候，模式无论如何都会改变。

在这种情况下，问问你自己:“是数据迫使领域模型改变，还是相反？”也许业务规则改变了，领域模型也改变了，这导致了数据模型的改变。

将领域模型从数据中分离出来的另一个好处是领域模型变得更有表现力。我们可以使用更多的*复杂*类型，而不仅仅是简单的`String`、`Int`或其他`Decodable`类型。

在前面的例子中，出生日期现在被表示为`User`结构中的`Date`，不像`UserDTO`结构中的出生日期被表示为`Int`。那些更复杂的类型可以在映射过程中创建。

# 仓库

既然我们知道了从数据中分离领域模型的价值，我想引入一个概念来帮助我们实现这个目标:T21 库 T22。

存储库可以看作是元素的集合，在这里可以存储或检索元素。它提供了获取这些元素并存储它们的方法。

这是领域模型和数据模型之间的边界。这是一个隐藏所使用的真正持久性存储及其所有实现细节的好地方，比如 JSON 解析和到域模型对象的映射。

## 例子

让我们看一个例子:

这是怎么回事？

1.  储存库协议。使用协议是一个好主意，因为这样的话，使用*依赖注入*可以非常容易地改变真正的存储库实现。取名`UserRepository`。这个名称不应该告诉我们任何关于所使用的持久性存储的信息。
2.  存储库实现。与协议不同，类名应该为我们提供关于所选持久性存储的线索。在这种情况下，`APIUserRepository`使用外部 API 来检索`Users`。
3.  存储库使用`URLSession`来执行请求并获得一个`User`。我不打算在这里深究更多的细节，因为我不想错过这个例子的要点。如果你想了解更多关于使用`URLSession`联网的知识，可以在这里看到一个非常好的教程[。](https://www.raywenderlich.com/3244963-urlsession-tutorial-getting-started)
4.  一个`UserDTO`结构用于解析从 API 获得的 JSON 数据。如果数据被成功解析到 DTO 中，那么一个`UserDTOMapper`将从其中创建一个`User`。如果解析失败，则返回`nil`。

仅此而已。很简单吧？

当您使用存储库时，很容易更改所使用的持久性存储。让我们这样做，并将用户存储在本地。顾名思义，这个新的实现使用*用户默认值*来检索用户:

注意，本实施中使用的 DTO 与`APIUserRepository`中使用的相同。当然，这不是强制性的。

每个实现都可以使用不同的 DTO 来满足存储库的需求。但是为了使例子简单，我使用了同一个例子。

# 结论

关于存储库的一个好处是，你可以把所有的实现细节隐藏在协议后面。

使用存储库的对象不应该关心实际使用的是哪种机制。它所关心的只是存储库返回一个域模型对象，在这个例子中是一个`User`。

而且，由于我们已经将域模型从数据模型中分离出来，存储库实现可以在对系统影响最小的情况下进行更改，因为返回的域模型将保持不变。

感谢阅读！