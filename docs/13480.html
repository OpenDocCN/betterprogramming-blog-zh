<html>
<head>
<title>Using React Router for Modularization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React路由器实现模块化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-react-router-for-modularization-872b32315a3b?source=collection_archive---------10-----------------------#2022-08-30">https://betterprogramming.pub/using-react-router-for-modularization-872b32315a3b?source=collection_archive---------10-----------------------#2022-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="81a4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">嵌套路由的简要指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/2706849d4551db3870cc91292e994f03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*gbCeTzc727LZNhGQPXIkHA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="6390" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有时，在构建多页面应用程序时，不同的页面可能有非常不同的特性，或者您可能希望为应用程序的不同部分创建不同的布局。这可以通过模块化来创建应用程序的不同部分来实现。</p><h1 id="7227" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">关于反应路由器</h1><p id="4cdc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">React-Router 是React的一个轻量级客户端和服务器端路由库。它允许您在web应用程序中处理路由，根据URL显示不同的页面。React Router将匹配URL并加载特定页面的组件。版本6将为给定的URL选择最具体的匹配，因此您不必担心排序您的路线。</p><h2 id="eff3" class="ml lo iq bd lp mm mn dn lt mo mp dp lx la mq mr lz le ms mt mb li mu mv md mw bi translated">目标</h2><p id="4ed4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">使用React Router将应用程序分成不同的部分。</p><h2 id="cd84" class="ml lo iq bd lp mm mn dn lt mo mp dp lx la mq mr lz le ms mt mb li mu mv md mw bi translated">先决条件</h2><p id="b136" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">对于本教程，您的计算机上必须安装有<a class="ae mk" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node </a> ≥ 14.0.0和<a class="ae mk" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a> ≥ 5.6。您还需要对构建和使用可重用组件有一个大致的了解，并且您需要一个代码编辑器。我们还将使用<code class="fe mx my mz na b"><a class="ae mk" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">styled-components</a></code>，这是一个允许你直接在JS文件中编写CSS的库。这消除了在不同文件之间来回移动以设计组件样式的需要。</p><p id="e7df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们开始吧。</p><h1 id="b45f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">建立</h1><p id="3cfd" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们将通过在您的终端或cmd上运行以下命令来创建一个新的React应用程序:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="dcec" class="ml lo iq na b gy nf ng l nh ni">npx create-react-app my-router-app</span></pre><p id="55ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">导航到您的应用程序，然后安装<code class="fe mx my mz na b">react-router-dom</code>包和<code class="fe mx my mz na b">styled-components</code>包。命令末尾的<code class="fe mx my mz na b">@6</code>意味着您正在添加react-router-dom的版本6。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4b42" class="ml lo iq na b gy nf ng l nh ni">cd my-router-app<br/>npm install react-router-dom@6 <!-- -->--save styled-components</span></pre><p id="67a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您的<code class="fe mx my mz na b">package.json</code>文件应该类似如下:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="2610" class="ml lo iq na b gy nf ng l nh ni">"dependencies": {<br/>  "@testing-library/jest-dom": "^5.16.5",<br/>  "@testing-library/react": "^13.3.0",<br/>  "@testing-library/user-event": "^13.5.0",<br/>  "react": "^18.2.0",<br/>  "react-dom": "^18.2.0",<br/>  "react-router-dom": "^6.3.0",<br/>  "react-scripts": "5.0.1",<br/>  "styled-components": "^5.3.5",<br/>  "web-vitals": "^2.1.4"<br/>},</span></pre><p id="670b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置完成后，您可以运行应用文件夹中的命令<code class="fe mx my mz na b">npm start</code>来启动。现在，当您在<code class="fe mx my mz na b">localhost</code>上打开端口3000时，您可以看到默认的React应用程序。</p><h1 id="d657" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">创建页面和组件</h1><p id="5936" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们在这一部分创建的所有东西从技术上来说都是一个组件，但是一些组件将作为页面，而另一些将作为页面的一部分呈现。</p><p id="b9af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们首先在src文件夹中创建一个pages目录。这是我们所有页面的位置。此外，在我们的<code class="fe mx my mz na b">src</code>文件夹中，我们创建一个组件目录，在那里我们将放置组成我们页面的其他组件。</p><p id="7d4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将建造一艘<code class="fe mx my mz na b">LoginPage</code>、一艘<code class="fe mx my mz na b">HomePage</code>、一艘<code class="fe mx my mz na b">CollectionsPage</code>和一艘<code class="fe mx my mz na b">FavouritesPage</code>。我们还将使用<code class="fe mx my mz na b">styled-components</code>为我们的组件添加非常简单的样式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">LoginPage.js组件</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">HomePage.js组件</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">CollectionsPage.js组件</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">FavouritesPage.js组件</p></figure><p id="31ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们创建<code class="fe mx my mz na b">Footer</code>组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Footer.js组件</p></figure><p id="6313" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将在下一步创建Navbar组件。</p><h1 id="f827" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">利用嵌套路线对您的应用进行细分</h1><p id="bbde" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">嵌套路由是React路由器提供的最强功能之一。根据React路由器<a class="ae mk" href="https://reactrouter.com/en/main/getting-started/overview#nested-routes" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="nl nm nn"><p id="ecaa" class="kr ks no kt b ku kv jr kw kx ky ju kz np lb lc ld nq lf lg lh nr lj lk ll lm ij bi translated">路由可以相互嵌套，它们的路径也会嵌套(子继承父)</p></blockquote><p id="1e2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mk" href="https://dev.to/tywenk/how-to-use-nested-routes-in-react-router-6-4jhd" rel="noopener ugc nofollow" target="_blank">这里的</a>是一篇很好的文章，深入探讨了如何利用嵌套路线来创建复杂的布局。</p><p id="46b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，我们将使用嵌套路由的概念来有条件地呈现导航栏和页脚组件。</p><p id="7d98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们首先在我们的<code class="fe mx my mz na b">components</code>文件夹中创建一个新组件，我们将其命名为<code class="fe mx my mz na b">MainLaoyout.js</code>。在这个组件中，我们将导入具有相似布局的所有组件以及出现在多个组件上的组件。<code class="fe mx my mz na b">Navbar</code>和<code class="fe mx my mz na b">Footer</code>组件将在<code class="fe mx my mz na b">HomePage</code>、<code class="fe mx my mz na b">CollectionsPage</code>和<code class="fe mx my mz na b">FavouritesPage</code>中渲染。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">MainLayout.js组件</p></figure><p id="efc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从上面可以看出，要在多个页面上呈现一个组件，必须将该组件放在包含该组件的<code class="fe mx my mz na b">Routes</code>标签之外。<code class="fe mx my mz na b">Routes</code>标签是<code class="fe mx my mz na b">Route</code>标签的父标签，其中每个<code class="fe mx my mz na b">Route</code>标签将包含可以导航到的每个页面。这样，<code class="fe mx my mz na b">Navbar</code>和<code class="fe mx my mz na b">Footer</code>组件将出现在<code class="fe mx my mz na b">Routes</code>标签中描述的所有页面上。</p><p id="4a60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们创建Navbar组件。该组件将包含我们的应用程序中所有其他页面的链接。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Navbar.js组件</p></figure><p id="111e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，在我们的<code class="fe mx my mz na b">App.js</code>组件中，我们将不同的部分放在一起以完成我们的应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">App.js组件</p></figure><p id="1a83" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这最后一步结束时，您应该有一个带有导航栏和页脚的主页。当你浏览页面时，你应该看到导航和页脚是持久的，当你点击“注销”选项时，你会看到导航和页脚不再存在。</p><h1 id="271f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="5f07" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在本文中，我们使用嵌套路由来创建模块化。我们的应用程序只有两个区域，但是您可以使用这个概念来创建更多的区域。</p><p id="1a02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，<a class="ae mk" href="https://stackoverflow.com/a/71446125" rel="noopener ugc nofollow" target="_blank">注意</a>标签中的每个子组件必须是一个<code class="fe mx my mz na b">Route</code>组件。这就是为什么在<code class="fe mx my mz na b">MainLayout</code>组件中我们使用了<code class="fe mx my mz na b">React.Fragment</code>，所以当我们从<code class="fe mx my mz na b">App.js</code>组件中渲染它时，它被一个<code class="fe mx my mz na b">Route</code>标签包围着。</p><p id="eaab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇文章对你有帮助！</p></div></div>    
</body>
</html>