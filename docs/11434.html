<html>
<head>
<title>JWT and Passport JWT Strategy for Your NestJS REST API Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的NestJS REST API项目的JWT和护照JWT策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jwt-and-passport-jwt-strategy-for-your-nestjs-rest-api-project-cafa9dd59890?source=collection_archive---------0-----------------------#2022-03-20">https://betterprogramming.pub/jwt-and-passport-jwt-strategy-for-your-nestjs-rest-api-project-cafa9dd59890?source=collection_archive---------0-----------------------#2022-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="177e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步详细实施</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a5d8b9a031774bd637f70b4f1eda52a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nRZtu5J_Yn5Qb0yK"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@blakeguidry?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布莱克·古德瑞</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="f163" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">构建模块—简短介绍</h1><p id="02cb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当涉及到应用程序身份验证(例如用户身份验证)时，基于<a class="ae ky" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a> Web令牌(JWT)的身份验证是最广泛的选择之一，其他选择包括浏览器Cookies和会话身份验证、<a class="ae ky" href="https://oauth.net/" rel="noopener ugc nofollow" target="_blank"> OAuth </a> / <a class="ae ky" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth2 </a>和<a class="ae ky" href="https://openid.net/connect/" rel="noopener ugc nofollow" target="_blank"> OpenID Connect </a>。</p><p id="f225" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">任何人都可以在任何项目中采用和实现JWT。例如，<a class="ae ky" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>为我们提供了solo <code class="fe ms mt mu mv b"><a class="ae ky" href="https://www.npmjs.com/package/@nestjs/jwt" rel="noopener ugc nofollow" target="_blank">@nestjs/jwt</a></code>模块，允许我们将JWT集成到我们的项目中。然而，它需要大量的样板文件。因此，使用专门用于身份验证的外部工具/包可能是首选的解决方案。</p><p id="3763" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><a class="ae ky" href="https://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank"> Passport </a>包是一个被广泛使用的<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>库，其“唯一的目的是认证请求，这是通过一组可扩展的插件来实现的，这些插件被称为策略。直到写这篇文章的时候，护照库由大约537个<a class="ae ky" href="https://www.passportjs.org/packages/" rel="noopener ugc nofollow" target="_blank">策略</a>组成！特别是，对于基于JWT的认证，Passport当然为我们提供了各自的<a class="ae ky" href="https://www.passportjs.org/packages/passport-jwt/" rel="noopener ugc nofollow" target="_blank"> JWT策略</a>。</p><p id="a6d9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于<a class="ae ky" href="https://docs.nestjs.com/security/authentication" rel="noopener ugc nofollow" target="_blank"> Passport是最受欢迎的NodeJS认证库</a>，NestJS提供了自己的<code class="fe ms mt mu mv b"><a class="ae ky" href="https://www.npmjs.com/package" rel="noopener ugc nofollow" target="_blank">@nestjs/passport</a></code>模块，该模块允许将Passport直接集成到任何NestJS应用程序中。</p><p id="464d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这篇文章旨在帮助你如何实现它。实际上，我们将看到如何使用JWT和Passport的JWT策略轻松保护我们的一些路由(端点)。使用Passport包提供的AuthGuard()函数保护路由(端点甚至整个控制器路由)非常简单。</p><p id="82ba" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">NestJS文档提供了一个非常相似的例子，并且假设您已经采取了其中描述的一些步骤。然而，这里我们将经历2个步骤。</p><ul class=""><li id="31cc" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated">首先，我们将使用JSON Web令牌进行用户认证</li><li id="27b5" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">然后将继续使用Passport包保护我们的路由(基本端点),并应用JWT策略。</li></ul><h1 id="d3e6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">基本储存库</h1><p id="590e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了您的方便(考虑到您的时间)，您可以使用我的示例<a class="ae ky" href="https://github.com/zzpzaf/nest-external-config-env.git" rel="noopener ugc nofollow" target="_blank">GitHub repo</a>。回购的要点总结如下:</p><ul class=""><li id="39b1" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm nb nc nd ne bi translated">repo(如在<a class="ae ky" href="https://docs.nestjs.com/security/authentication#implementing-passport-strategies" rel="noopener ugc nofollow" target="_blank"> NestJS文档</a>中)已经分别包括了AuthModule和UsersModule，以及它们的控制器和服务类。</li><li id="4988" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">repo使用单独的solo @ injectable类DbRepo，而不是使用UsersService进行基本的CRUD操作。它同时服务于<code class="fe ms mt mu mv b">AuthService</code>和<code class="fe ms mt mu mv b">UsersService</code>。[ <a class="ae ky" href="https://blog.devgenius.io/nestjs-use-a-solo-injectable-class-as-a-singleton-provider-884911eff279" rel="noopener ugc nofollow" target="_blank">你可以在我的另一篇文章</a>中阅读如何使用solo @ injectable类作为单例提供者</li><li id="647a" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">DbRepo</code>从一个数组中获取一些预先设置在<code class="fe ms mt mu mv b">UserDB</code>类中的用户。</li><li id="7c7b" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><a class="ae ky" href="https://www.npmjs.com/package/class-validator" rel="noopener ugc nofollow" target="_blank"> class-validator </a>和<a class="ae ky" href="https://www.npmjs.com/package/class-transformer" rel="noopener ugc nofollow" target="_blank"> class-transformer </a>包安装完毕。dto和实体是在<code class="fe ms mt mu mv b">src/dataObjects</code>文件夹中定义的，它们被相应地修饰。[ <a class="ae ky" href="https://medium.com/@zzpzaf.se/nestjs-rest-api-class-validator-class-transformer-bf7a0e6b311a" rel="noopener">详见</a>中的帖子</li><li id="5e02" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">repo使用外部定义的变量，所以已经安装了<code class="fe ms mt mu mv b"><a class="ae ky" href="https://www.npmjs.com/package/@nestjs/config" rel="noopener ugc nofollow" target="_blank">@nestjs/config</a></code>包，并且在AppModule中对其进行了全局声明。外部变量在src/config/.env.dev文件中定义。【<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/step-ahead-fast-with-nestjs-environment-configuration-406701b3379f">详见我的帖子</a></li><li id="171b" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">此外，repo使用<a class="ae ky" href="https://joi.dev/" rel="noopener ugc nofollow" target="_blank"> Joi </a>模式验证工具(该工具也在<a class="ae ky" href="https://docs.nestjs.com/pipes#object-schema-validation" rel="noopener ugc nofollow" target="_blank"> NestJS文档</a>中用于对象模式验证)。此外，已经在<code class="fe ms mt mu mv b">src/config/config.schema.ts</code>文件中定义并修饰了一个JSON对象模式验证器(使用适当的Joi属性修饰器)。它正被用于<code class="fe ms mt mu mv b">src/config/.env.dev</code>文件中的外部定义变量。</li><li id="3721" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated">回购协议已定义并使用(通过<code class="fe ms mt mu mv b">AuthController</code>和<code class="fe ms mt mu mv b">UsersController</code>)以下端点</li><li id="010d" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm nb nc nd ne bi translated"><code class="fe ms mt mu mv b">auth/signup<br/>auth/signin<br/>users/<br/>users?<br/>users/:id/</code></li></ul><p id="f1ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它还使用了<code class="fe ms mt mu mv b">/tickets</code>全局前缀，因此对于访问用户，您必须使用:<code class="fe ms mt mu mv b">http://localhost:3000/tickets/users</code>。</p><h1 id="728d" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">把回购放在你的机器里</h1><p id="e8ae" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在您的计算机中，将当前工作目录更改为您要克隆存储库的位置/文件夹。<br/>例如，在终端窗口中使用以下命令:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="746a" class="no la it mv b gy np nq l nr ns">git clone https://github.com/zzpzaf/nest-external-config-env.git</span></pre><p id="e1d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将创建一个名为<code class="fe ms mt mu mv b">nest-external-config-env</code>的新文件夹，其中包含所有回购的文件夹和文件。跳进去，获得项目所需的所有节点包:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="65e2" class="no la it mv b gy np nq l nr ns">cd nest-external-config-env<br/>npm i</span></pre><p id="d1a7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，您已经准备好获取代码编辑器/IDE了。(我用<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VS代码</a>)打开<code class="fe ms mt mu mv b">nest-external-config-env</code>文件夹。如果您愿意，您可以在终端窗口中运行应用程序:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="d81b" class="no la it mv b gy np nq l nr ns">npm run start:dev</span></pre><p id="82d6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，您可以使用<a class="ae ky" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>工具检查一些端点。例如:<a class="ae ky" href="http://localhost:3000/tickets/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/tickets/users</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/402fe8d9f801f5baaa4d73007e83da8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C1FNov_koF0BDly0.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/65544b966cf3efc64f4939fc732017e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1ljxB4-caT0WC4le.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/b00672c114d8e40627a7e525bf057176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LSRRReG1yc-4v-Xe.png"/></div></div></figure><p id="0b99" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">等等。就是这样！现在，我们准备开始了。所以，我们走吧！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="0aae" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated"><a class="ae ky" href="https://www.npmjs.com/package/@nestjs/jwt" rel="noopener ugc nofollow" target="_blank"> @nestjs/jwt </a>包</h1><p id="efbd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://www.npmjs.com/package/@nestjs/jwt" rel="noopener ugc nofollow" target="_blank"> @nestjs/jwt </a>是nestjs的<a class="ae ky" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JWT </a>实用程序模块(基于<a class="ae ky" href="https://github.com/auth0/node-jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> jsonwebtoken </a>包)。它允许我们使用<a class="ae ky" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank"> JSON Web令牌— JWT </a>来认证用户。</p><h1 id="e0b0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">装置</h1><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="4c65" class="no la it mv b gy np nq l nr ns">npm i @nestjs/jwt</span></pre><h1 id="2f95" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">履行</h1><p id="ac21" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个包实际上为我们提供了一个模块<code class="fe ms mt mu mv b"><a class="ae ky" href="https://github.com/nestjs/jwt/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">JwtModule</a></code>，它又公开了一个服务<code class="fe ms mt mu mv b"><a class="ae ky" href="https://github.com/nestjs/jwt/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">JwtService</a></code>。</p><h2 id="894e" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated"><strong class="ak">JwtModule</strong></h2><p id="5e9f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">第一步是在任何项目模块的导入数组部分导入<code class="fe ms mt mu mv b">JwtModule</code>。因此，既然我们想使用它进行用户令牌认证，在我们的例子中，我们必须将它导入到我们的<code class="fe ms mt mu mv b">AuthModule</code>中。</p><p id="c282" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，我们还必须使用它的<code class="fe ms mt mu mv b">register()</code>方法来配置它。基本配置可以仅包括对称秘密(代码)和生成的令牌的到期时间，例如以秒为单位。例如，我们可以这样使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="ffce" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当然，该软件包还提供了一些其他配置选项，例如，使用非对称算法对令牌进行加密/解密。如果你想浏览它们，那么,<a class="ae ky" href="https://github.com/nestjs/jwt/blob/master/README.md" rel="noopener ugc nofollow" target="_blank">官方文件</a>是一个很好的来源。</p><p id="da6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，由于在我们的源代码中使用密码或秘密代码作为字符串不是一个好主意，一个更好的解决方案是在外部定义它们，在一个安全保存的. env配置文件中。注意，我们已经完成了，在我们的克隆回购提供的<code class="fe ms mt mu mv b">.env.dev</code>中。实际上，这是回购提供的<code class="fe ms mt mu mv b">.env.dev</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="4dcc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">还要注意，你不应该公开暴露你的密码或秘密代码。更重要的是，你必须在你的<code class="fe ms mt mu mv b">.gitignore</code>文件中包含任何敏感信息。然而，为了本文的演示目的，在这种情况下这是不正确的。</p><p id="8f59" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，我们可以通过<code class="fe ms mt mu mv b">ConfigService</code>使用外部提供的参数注册<code class="fe ms mt mu mv b">JwtModule</code>，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="9035" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">编码风格由你决定。[您可以一直阅读官方文档，了解更多关于:<a class="ae ky" href="https://docs.nestjs.com/fundamentals/dynamic-modules#introduction" rel="noopener ugc nofollow" target="_blank">动态模块</a>和<code class="fe ms mt mu mv b"><a class="ae ky" href="https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory" rel="noopener ugc nofollow" target="_blank">useFactory()</a></code> ]</p><h2 id="d3b4" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated"><strong class="ak">JwtService</strong></h2><p id="8995" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">接下来，从<code class="fe ms mt mu mv b">JwtModule</code>暴露出来的<code class="fe ms mt mu mv b">JwtService</code>应该被注入到<code class="fe ms mt mu mv b">AuthService</code>(通过<code class="fe ms mt mu mv b">AuthService</code>构造函数)，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="f2d4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们实际上想要做的是接受“登录”过程的请求主体中提供的用户凭证(用户名和明文密码)，然后只验证一次。在成功验证之后，我们可以请求<code class="fe ms mt mu mv b">JwtService</code>为我们提供一个令牌，这个令牌应该作为响应返回给用户。如果验证失败(错误的用户名或用户不存在或错误的密码)，我们可以相应地通知用户。</p><h2 id="d425" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated"><strong class="ak"> JWT有效载荷</strong></h2><p id="eb22" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">还有一件事，我们必须停留一下，就是定义一个有效载荷。这通常是一个JSON对象，是创建JWT所需要的。[阅读更多:<a class="ae ky" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">https://jwt.io/introduction/</a></p><p id="564f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">定义有效负载取决于您自己的业务逻辑和您的特定需求。但是在任何情况下，避免使用过于简单的有效载荷。示例:仅由用户名组成。</p><p id="bbc3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里我们将使用一个2 properties JSON对象作为我们的示例负载。它应该由用户名和<code class="fe ms mt mu mv b">typeid</code>组成。因此，除了用户名和密码的有效性之外，用户必须拥有适当的<code class="fe ms mt mu mv b">typeid</code>才能访问API端点。</p><p id="3ac2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，一个好的实践是为我们的有效负载对象定义我们自己的接口，不管它是否简单。这主要是为了一致性和可扩展性，可以帮助我们避免一些相关的错误。</p><p id="5a64" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意，在我们克隆的repo中，我们使用了一个单独的子文件夹(<code class="fe ms mt mu mv b">datObjects</code>文件夹),它保存了我们项目的所有数据类型对象。因此，创建一个新的TypeScript文件，将其命名为<code class="fe ms mt mu mv b">user-jwt-payload.interface.ts</code>，并将以下示例代码放入其中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="aa5c" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated"><strong class="ak">创建并返回一个JWT </strong></h2><p id="0c07" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，我们准备验证(或不验证)用户，如果验证通过，我们可以向他/她返回令牌。我们可以很容易地做到这一点，通过在<code class="fe ms mt mu mv b">AuthService</code>中使用<code class="fe ms mt mu mv b">signin()</code>方法中的<code class="fe ms mt mu mv b">JwtService</code>，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="b514" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如你所看到的，我们已经使用了内置的JwtService函数<code class="fe ms mt mu mv b">sign()</code>，向它传递了有效载荷对象。该函数将令牌返回给我们，然后将令牌作为响应对象发送回用户。就是这么简单！不是吗？可以用Postman测试一下。例如:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/e0aaed7df89f94fa1f5791792294b9c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zf8ZVDBiBK4VnFDG.png"/></div></div></figure><p id="2944" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">此外，您还可以在<a class="ae ky" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank">https://jwt.io/</a>在线检查生成的令牌。示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/0ebf32a26c67ad5598ba8c9f11d99de1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RyDdwgKLylxZAqwM.png"/></div></div></figure><p id="060f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您还可以测试无效的凭据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/65d11e71ef7a8e439abc998f96526a61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FZZcmKtEXvC6GRBp.png"/></div></div></figure><p id="2707" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">注意:为了明确返回对象是一个令牌(一个JWT)而不仅仅是一个消息(一个字符串)，请将<code class="fe ms mt mu mv b">AutService</code>和<code class="fe ms mt mu mv b">AuthController</code>中的<code class="fe ms mt mu mv b">accessMessage</code>重命名为<code class="fe ms mt mu mv b">accessToken</code>。</p><h2 id="fc2d" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated"><strong class="ak">通过JWT的验证</strong></h2><p id="bd1e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，每当我们想要检查来自端点中的用户的请求时，我们将只检查所提供的令牌的有效性(在请求的授权报头中作为承载令牌提供的JWT)。再也没有用户名和密码了！</p><p id="bae2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">JwtService将通过其内置函数<code class="fe ms mt mu mv b">verifyAsync()</code>来完成这项工作！让我们看看如何为特定的端点做到这一点，例如:为用户/端点。然而，首先，我们必须提取授权头中提供的<code class="fe ms mt mu mv b">Bearer</code>令牌(如果有的话)。</p><p id="fea5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以这样做，例如，对于<code class="fe ms mt mu mv b">UsersController</code>中的<code class="fe ms mt mu mv b">@Get() getUsers()</code>处理程序方法。我们将使用<code class="fe ms mt mu mv b">@Headers</code>装饰器来获取所有传入的头，然后我们将从<code class="fe ms mt mu mv b">authorization</code>头属性中提取<code class="fe ms mt mu mv b">Bearer</code>标记。我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="c108" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">接下来，我们可以定义并调用一个私有方法，使用上面提到的<code class="fe ms mt mu mv b">verifyAsync()</code>来检查所获得的承载令牌的有效性。</p><p id="4a6d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">由于我们将需要<code class="fe ms mt mu mv b">JwtService</code>和<code class="fe ms mt mu mv b">ConfigService</code>(用于获取密钥，该密钥也应在<code class="fe ms mt mu mv b"><strong class="lt iu">verifyAsync()</strong></code>函数中提供)我们必须在继续之前处理2-3次代码调整。</p><p id="6741" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在克隆的回购协议的<code class="fe ms mt mu mv b">UsersModule</code>中，您可以看到我们已经注意到导入了<code class="fe ms mt mu mv b">AuthModule</code>，但是，为了能够使用/注入<code class="fe ms mt mu mv b">JwtService</code>，我们必须从<code class="fe ms mt mu mv b">AuthModule</code>中导出<code class="fe ms mt mu mv b">JwtModule</code>。因此，在其中添加exports属性数组并添加<code class="fe ms mt mu mv b">JwtModule</code>。<code class="fe ms mt mu mv b">AuthModule</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="f7ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，我们准备在我们的<code class="fe ms mt mu mv b">UsersController</code>中注入<code class="fe ms mt mu mv b">JwtService</code>。</p><p id="418d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们已经说过的，我们也需要注入<code class="fe ms mt mu mv b">ConfigService</code>。但既然是在<code class="fe ms mt mu mv b">AppModule</code> ( <code class="fe ms mt mu mv b">isGlobal: true</code>)全局启用，那就没什么可多做的了。我们也准备将它注入到用户控制器中。</p><p id="8e0c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以，我们给他们两个都注射。<code class="fe ms mt mu mv b">UsersController</code>构造函数将类似于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="ee17" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后，我们可以创建一个私有方法来检查所获得的载体的有效性。我们可以将其命名为<code class="fe ms mt mu mv b">isTokenValid</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="9cb4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如你很容易理解的，我们传递给函数2个参数:不记名令牌和JWT秘密。</p><p id="8e97" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果承载令牌无效，该方法抛出一个<code class="fe ms mt mu mv b">HttpException</code>，否则它返回一个解密了全部有效载荷的对象。有效负载对象包括:用户名、<code class="fe ms mt mu mv b">typeid</code>(在创建令牌时由我们定义)以及由<code class="fe ms mt mu mv b">JwtService</code>自动添加的<code class="fe ms mt mu mv b">iat</code>和<code class="fe ms mt mu mv b">exp</code>属性。<code class="fe ms mt mu mv b">iat</code>代表令牌的创建和<code class="fe ms mt mu mv b">exp</code>、到期时间(预计相差3600秒)。</p><p id="64cf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们实际上需要从返回的有效载荷对象中得到的只是<code class="fe ms mt mu mv b">username</code>和<code class="fe ms mt mu mv b">typeid</code>。</p><p id="4d52" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">username</code>需要检查带有<code class="fe ms mt mu mv b">username</code>的用户是否仍然存在。因为在生成令牌后，用户总是有可能被删除。所以，我们必须检查用户的存在，然后决定令牌是否有效。因此，我们使用“用户名”来检查用户是否存在于我们的<code class="fe ms mt mu mv b">DbRepo</code>中。</p><p id="804c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">之后，我们检查<code class="fe ms mt mu mv b">typeid</code>。在我们的例子中，一个令牌被认为是有效的，只对拥有<code class="fe ms mt mu mv b">typeid</code> 1和2的用户有效。如果这是真的，那么<code class="fe ms mt mu mv b">IsTokenValid()</code>返回真。</p><p id="a110" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，我们使用从有效负载获得的<code class="fe ms mt mu mv b">typeid</code>值来保持<code class="fe ms mt mu mv b">stuck</code>(而不是从找到的用户的<code class="fe ms mt mu mv b">user.typeid</code>属性)，因此任何<code class="fe ms mt mu mv b">typeid</code>值的更改都将被忽略。</p><p id="0148" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所以，让我们从<code class="fe ms mt mu mv b">getUsers()</code>处理程序调用它。</p><p id="3cb9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该处理程序类似于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="4323" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样。我们现在可以使用邮递员，并对其进行一点测试。这是带有有效不记名令牌的响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/6fd28999fe096e7e2ed684eb7dd8ffcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6BLoRL3rJGatEdJh.png"/></div></div></figure><p id="e5de" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是一个无效令牌示例(时间已过期):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/410c905842e395ec26774327874db6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9eWgUUKHGXD6BRA1.png"/></div></div></figure><p id="ea35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">好像还行。那么，我们下一步能做什么？我们可以为其他端点和CRUD操作重复调用<code class="fe ms mt mu mv b">isTokenValid()</code>。但是你可以理解，这是“不符合<a class="ae ky" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> D </a> RY原则”的。它需要大量样板代码，因此不容易维护。你能想象如果以后我们决定添加更多的端点并使用许多其他模块意味着什么吗？</p><p id="f198" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">不，这不是我们要做的。我们将使用<strong class="lt iu">护照</strong>包代替。</p><p id="e6e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在继续之前，如果您愿意，可以提交。或者，您可以下载或克隆一个干净的repo，其中包含我们到目前为止所描述的@nestjs/jwt实现，供您自己参考。这里是<a class="ae ky" href="https://github.com/zzpzaf/nest-external-config-env-jwt" rel="noopener ugc nofollow" target="_blank">https://github.com/zzpzaf/nest-external-config-env-jwt</a>注意，我们将删除上面使用的部分代码。</p><p id="ee86" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，我们将删除上面使用的部分代码。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="fcb5" class="kz la it bd lb lc ob le lf lg oc li lj jz od ka ll kc oe kd ln kf of kg lp lq bi translated"><a class="ae ky" href="https://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">护照</a>包</h1><h2 id="46b3" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated">装置</h2><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="1adb" class="no la it mv b gy np nq l nr ns">npm i passport @nestjs/passport passport-jwt<br/>npm i --save-dev @types/passport-jwt</span></pre><h2 id="f67e" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated">履行</h2><p id="e99f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在<code class="fe ms mt mu mv b">AuthModule </code>中导入它——我们开始，在<code class="fe ms mt mu mv b">AuthModule</code>的导入数组部分中导入<code class="fe ms mt mu mv b">PassportModule</code>,与我们之前为<code class="fe ms mt mu mv b">JwtModule</code>所做的类似。这里，我们再次使用<code class="fe ms mt mu mv b">Passport</code>提供的<code class="fe ms mt mu mv b">register()</code>内置方法，注册一个策略作为我们项目的默认策略。正如你可能猜到的，默认策略是<a class="ae ky" href="https://www.passportjs.org/packages/passport-jwt/" rel="noopener ugc nofollow" target="_blank"> JWT策略</a>。所以，我们的<code class="fe ms mt mu mv b">AuthModule</code>就变成了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="412f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您所看到的，我们只添加了一行代码:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="fc36" class="no la it mv b gy np nq l nr ns">PassportModule.register<strong class="mv iu">({</strong> defaultStrategy: 'jwt' <strong class="mv iu">})</strong>,</span></pre><p id="66cb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下一步是以我们自己的方式实施这样一个JWT战略。实际上，我们自己的“策略”应该通过一个<code class="fe ms mt mu mv b">@injectable</code>修饰类来实现，该类反过来应该扩展Passport package <code class="fe ms mt mu mv b">PassportStrategy(Strategy)</code>类。</p><p id="75b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将为该类使用一个单独的文件。我们将文件命名为<code class="fe ms mt mu mv b">jwt.strategy.ts</code>，类命名为<code class="fe ms mt mu mv b">JwtStrategy</code>。我们可以将这个文件放在我们项目的<code class="fe ms mt mu mv b">src/auth</code>文件夹中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><h2 id="b83a" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated"><strong class="ak">构造函数——调用父函数:super() </strong></h2><p id="2700" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了使用它，我们必须在构造函数中传递一个至少有两个参数的对象。更准确地说，由于这是一个派生类(来自<code class="fe ms mt mu mv b">PassportStrategy(Strategy)</code>类),我们还必须从父类的<code class="fe ms mt mu mv b">Constructor</code>中调用<code class="fe ms mt mu mv b">super (parent)</code>类——所以我们必须在这个类的<code class="fe ms mt mu mv b">super({})</code>中这样做。<code class="fe ms mt mu mv b">super()</code>方法需要两个参数:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="a378" class="no la it mv b gy np nq l nr ns"><strong class="mv iu">constructor(){</strong>super<strong class="mv iu">({</strong>param1: value1, param2: value2<strong class="mv iu">})}</strong></span></pre><p id="56b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第一个参数— <code class="fe ms mt mu mv b"><strong class="lt iu">jwtFromRequest</strong></code>(必需)—该参数是必需的，因为我们必须从请求的报头中提取JWT承载令牌(有效载荷)，类似于我们之前“手动”所做的。它实际上是一个函数，接受一个请求作为唯一的参数，并返回字符串形式的JWT或空值。更多细节见<a class="ae ky" href="https://github.com/mikenicholson/passport-jwt#extracting-the-jwt-from-the-request" rel="noopener ugc nofollow" target="_blank">从请求中提取JWT</a>。我们可以使用通过ExtractJwt枚举提供的选项。在我们的例子中，我们必须选择<code class="fe ms mt mu mv b">fromAuthHeaderAsBearerToken()</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d68422c5cb03edac5a2a960059aa94ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sZtMg-ULV4X29mwV.png"/></div></div></figure><p id="7991" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">第二个参数(对于第一个参数是必需的)。— <code class="fe ms mt mu mv b">secretOrKey</code> —这是一个字符串或缓冲区，包含用于验证令牌签名的机密(对称)或PEM编码的公钥(非对称)。这里我们将使用我们以前用过的秘密。当然，在我们的情况下，我们必须从<code class="fe ms mt mu mv b">ConfigService</code>获取它。，所以我们还必须在类构造函数中注入<code class="fe ms mt mu mv b">ConfigService</code>。因此，调用超级构造函数应该如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="67a0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><strong class="lt iu"/><code class="fe ms mt mu mv b"><strong class="lt iu">validate()</strong></code><strong class="lt iu">方法— </strong>应该是<code class="fe ms mt mu mv b">PassportStrategy</code>实现类的一部分。对于每个策略，Passport默认调用jwt verify函数。在NestJS中，这个函数是用一个<code class="fe ms mt mu mv b">validate()</code>方法实现的。</p><p id="cea5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果省略这个方法，我们会得到一个异常错误:<br/> <code class="fe ms mt mu mv b">ERROR [ExceptionsHandler] this.<strong class="lt iu">validate</strong> is not a function</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/6781b6e7a4ccfd9b2e4544cf209f72fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/0*rpR8tYsufBHAXNnz.png"/></div></figure><p id="eea1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们使用一个<code class="fe ms mt mu mv b">validate()</code>函数，它应该是一个承诺，只是在我们实现了自己的验证逻辑之后返回一些东西。例如，我们可以返回always true(用于验证所有内容):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="660d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在Passport验证并发现令牌有效(有效签名、未过期等)后，调用<code class="fe ms mt mu mv b">validate()</code>函数。).如果令牌有效，那么它将有效负载解码并提取为一个JSON对象，并使其可用，因此我们可以在<code class="fe ms mt mu mv b">validate()</code>函数中使用它。</p><p id="d9b3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们的例子中，我们使用<code class="fe ms mt mu mv b">validate()</code>函数返回一个用户对象。为了取回用户对象，我们必须访问<code class="fe ms mt mu mv b">DbRepo</code>及其方法。所以，我们必须在<code class="fe ms mt mu mv b">JwTStrategy</code>构造函数中注入<code class="fe ms mt mu mv b">DbRepo</code>。我们的<code class="fe ms mt mu mv b">JwtStrategy</code>应该类似于:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="21ac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在我们定义了我们的<code class="fe ms mt mu mv b">JwtStrategy</code>之后，下一步是将这个策略添加到<code class="fe ms mt mu mv b">AuthModule</code>中的<code class="fe ms mt mu mv b">providers</code>属性数组中。然后，我们还将它与passport模块一起添加到exports属性数组中。因此，我们将它们提供给其他地方和其他模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="25f9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样！现在，我们已经为最后一步做好了准备，并使用Passport来验证JWT令牌，而不是像我们已经完成的那样“手动”进行验证(在<code class="fe ms mt mu mv b">UsersController</code>中)。</p><p id="660a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下一步是保护我们的路线——使用Passport内置方法的端点:<code class="fe ms mt mu mv b">AuthGuard()</code>。</p><h2 id="cd30" class="no la it bd lb og oh dn lf oi oj dp lj ma ok ol ll me om on ln mi oo op lp oq bi translated">Nest.js中<a class="ae ky" href="https://docs.nestjs.com/guards#binding-guards" rel="noopener ugc nofollow" target="_blank">护板</a>机构简介</h2><p id="f26e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在继续之前，我们必须提到，NestJS框架提供了<a class="ae ky" href="https://docs.nestjs.com/guards#binding-guards" rel="noopener ugc nofollow" target="_blank">守卫</a>的“本地”功能。一般我们可以定义/实现自己的<code class="fe ms mt mu mv b">AuthGuard</code>类(实现了NestJS <code class="fe ms mt mu mv b">CanActivate</code>接口)，并为其定制<code class="fe ms mt mu mv b">canActivate()</code>函数。然后，我们可以使用<code class="fe ms mt mu mv b">@UseGuards</code>装饰器来应用(绑定)它。在NestJS中，可以通过两种方式绑定守卫:</p><ol class=""><li id="80da" class="mw mx it lt b lu mn lx mo ma my me mz mi na mm ov nc nd ne bi translated">保护整个控制器路由。</li><li id="3c24" class="mw mx it lt b lu nf lx ng ma nh me ni mi nj mm ov nc nd ne bi translated">保护特定的处理程序(在控制器中)</li></ol><p id="d392" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，我们可以创建并保护一个特定的<code class="fe ms mt mu mv b">@Post</code>处理程序。例如，在我们的auth.controller.ts中，我们可以添加以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="955b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，Passport为我们提供了现成的内置<code class="fe ms mt mu mv b">AuthGuard()</code>功能。因此，我们可以轻松地将其绑定到我们的路由和端点。</p><p id="dd01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面，我们已经使用了NestJS <code class="fe ms mt mu mv b">@UseGuards</code> decorator，并且我们刚刚将自定义的AuthGuard类传递给它，以保护/test端点POST处理程序。</p><p id="3ee8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是我们也可以在控制器级别保护整个路由。而这用护照的<code class="fe ms mt mu mv b">Authguard()</code>简直易如反掌。这是我们的案子。我们可以通过添加以下命令来保护整个<code class="fe ms mt mu mv b">UsersController</code>路线:</p><pre class="kj kk kl km gt nk mv nl nm aw nn bi"><span id="9409" class="no la it mv b gy np nq l nr ns">@UseGuards<strong class="mv iu">(</strong>AuthGuard<strong class="mv iu">())</strong></span></pre><p id="12d0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="d5e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在，如果没有认证，即没有有效的JWT令牌，就无法处理对/users路由的请求。<code class="fe ms mt mu mv b">AuthGuard()</code>通过我们的define <code class="fe ms mt mu mv b">JwtStrategy</code>自动检查JWT令牌的有效性，接受对任何一个<code class="fe ms mt mu mv b">UsersController</code> HTTP方法处理程序的请求，或者拒绝它。</p><p id="bade" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最后一步是从我们之前为<code class="fe ms mt mu mv b">manual</code> JWT令牌验证创建的代码中清除<code class="fe ms mt mu mv b">UsersController getUsers()</code>方法处理程序。下面，我们刚刚推荐了它，所以以后您可以完全删除它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="ea91" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是邮差的测试结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/3c40157ff13c38af907ede01e5d29f1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AvCB8JSeYv3kQ3cP.png"/></div></div></figure><p id="8ee7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您所理解的，这也可以用于您以后想在项目中添加的任何控制器。</p><p id="6a35" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以在:<a class="ae ky" href="https://github.com/zzpzaf/nest-external-config-env-jwt-passport.git" rel="noopener ugc nofollow" target="_blank">https://github . com/zzpzaf/nest-external-config-env-jwt-passport . git</a>访问ready clean repo。</p><p id="dce1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样！我希望你喜欢它，即使它有点长！编码快乐！…敬请关注！</p></div></div>    
</body>
</html>