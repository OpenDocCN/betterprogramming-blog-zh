<html>
<head>
<title>Algorithms With JavaScript: Recursion vs. Iteration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:递归与迭代</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-with-javascript-recursion-vs-iteration-f28cfe6ce29e?source=collection_archive---------5-----------------------#2020-03-27">https://betterprogramming.pub/algorithms-with-javascript-recursion-vs-iteration-f28cfe6ce29e?source=collection_archive---------5-----------------------#2020-03-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a406" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以正确的方式实现自动化</h2></div><p id="37e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为我们构建软件的最重要的原因之一是因为它可以为我们做无聊的、迭代的任务，而不会抱怨它们太多太无聊的工作。至少，如果我们正确地构建我们的程序，这是真的。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/a396288a90ab92ab4932734bbfb32b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z6KAD_iRuhFYV2RyAlHLSQ.jpeg"/></div></div><p class="lq lr gj gh gi ls lt bd b be z dk translated">斯图尔特_罗杰_迈尔斯(pixabay.com)途经<a class="ae lu" href="https://www.needpix.com/photo/974027/rat-race-businessman-repetitive-3d-rendering-boring-business-character-cog-cogwheel" rel="noopener ugc nofollow" target="_blank">Needpix.com</a></p></figure><p id="162f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">反复重复同一个操作有两种方法:迭代和递归。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac15" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">循环</h1><p id="82e4" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">JavaScript为迭代提供了很多方法。有<code class="fe mz na nb nc b">for</code>、<code class="fe mz na nb nc b">while</code>、<code class="fe mz na nb nc b">do while</code>、<code class="fe mz na nb nc b">for in</code>、<code class="fe mz na nb nc b">for of</code>。此外，还有更高级别的循环，如<code class="fe mz na nb nc b">map</code>或<code class="fe mz na nb nc b">forEach</code>。顺便说一下，像<code class="fe mz na nb nc b">find</code>、<code class="fe mz na nb nc b">includes</code>和<code class="fe mz na nb nc b"> sort</code>这样的方法实际上也是循环的，所以要明智地使用它们。</p><p id="eb1a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于我们的例子，我们将使用<code class="fe mz na nb nc b">for loop</code>。让我们构建我们的迭代函数:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/97adac95af6dedc42a64168b8372d217.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*F7T1amWv1b1NRTKNPdeRHw.png"/></div></figure><p id="7f4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个非常简单的函数，接受两个参数。第一个是数字，我们添加到结果中。第二个参数表示我们将进行多少次迭代。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0328" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">递归</h1><p id="66ce" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">JavaScript递归意味着函数调用自己，直到满足某个条件。让我们用递归构建一个函数:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/5e9913e243de5e3523dac33a78c19cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*Ou3u6w5psK4Ja0nYzGMlaw.png"/></div></figure><p id="fe3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与第一部分一样，该函数接受同样的两个参数。然后我们检查参数b是否等于1。如果是，函数返回第一个参数。如果没有，我们返回带有更新参数的函数本身。</p><p id="751f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">两种功能都工作得非常好。再来看看性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6249" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">比较迭代和递归性能</h1><p id="ed80" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">为了检查执行函数需要多少时间，我们将使用<code class="fe mz na nb nc b">console.time</code>方法。</p><p id="2270" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我将从200个操作开始，然后这个数字呈指数增长。</p><p id="6491" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">200-操作案例:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="5c7c" class="nj md it nc b gy nk nl l nm nn">200 operations:</span><span id="d2d6" class="nj md it nc b gy no nl l nm nn">400</span><span id="ca3d" class="nj md it nc b gy no nl l nm nn">Iteration #1: 1.224ms</span><span id="2e5d" class="nj md it nc b gy no nl l nm nn">400</span><span id="5413" class="nj md it nc b gy no nl l nm nn">Recursion #1: 0.258ms</span></pre><p id="523c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于200，递归似乎比迭代快得多。</p><p id="1ffe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2000次手术:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="b4a6" class="nj md it nc b gy nk nl l nm nn">4000</span><span id="bdfe" class="nj md it nc b gy no nl l nm nn">Iteration #1: 1.501ms</span><span id="e746" class="nj md it nc b gy no nl l nm nn">4000</span><span id="9354" class="nj md it nc b gy no nl l nm nn">Recursion #1: 1.226ms</span></pre><p id="5702" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归仍然比迭代快，但并不比第一种情况快多少。</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="d912" class="nj md it nc b gy nk nl l nm nn">2000 operations:</span><span id="a5cd" class="nj md it nc b gy no nl l nm nn">40000</span><span id="1cb2" class="nj md it nc b gy no nl l nm nn">Iteration #1: 5.738ms</span></pre><p id="4b28" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d086c3aa673768d72990e519d0aeba34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*ZUsP2AFYKjPTLoWuGdJPzQ.png"/></div></figure><p id="8fc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">"超过了最大调用堆栈大小。"哇，刚刚发生了什么？</p><p id="786d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在递归的情况下有一个错误，因为它将每个函数调用添加到调用堆栈中。每个浏览器都有调用堆栈大小的限制。比如FireFox最大调用栈是350801，Chrome是25237。</p><p id="ae96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是迭代会尽你所能地工作。我加了20亿次运算测试迭代能力。这花费了一些时间，但是迭代毫无怨言地处理了它:</p><pre class="lf lg lh li gt nf nc ng nh aw ni bi"><span id="8c93" class="nj md it nc b gy nk nl l nm nn">2000000000 operations:</span><span id="e6aa" class="nj md it nc b gy no nl l nm nn">4000000000</span><span id="98e4" class="nj md it nc b gy no nl l nm nn">Iteration #1: 8109.370ms</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="46ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">结论</strong></h1><p id="d536" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">看起来递归比迭代更便宜。但是我们应该小心，不要让递归超出它的处理能力。</p><p id="101f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以在<a class="ae lu" href="https://repl.it/@PavelIlin/RecursionVsIteration" rel="noopener ugc nofollow" target="_blank">回复</a>里玩。</p><p id="099e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总是为你的反馈而高兴。感谢阅读！</p></div></div>    
</body>
</html>