# 使用 Swift 属性包装器的分层依赖注入

> 原文：<https://betterprogramming.pub/create-layered-dependency-injection-with-swift-property-wrappers-6e7a841f0934>

## 在编译时解决依赖关系

![](img/48f93665145ebe1b2a069684bb485b44.png)

杰里米·贝赞格在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 目的

*   依赖注入的简单解决方案
*   依赖关系的编译时解析
*   为不同的层提供不同范围的可注入值:视图模型、视图、路由器、交互器等。
*   减少通过`init`方法传递的依赖项的数量
*   避免在整个项目中传播来自外部库的抽象。

# **解决方案**

尽管解决方案是属性注入，但它也提供了通常归因于构造函数注入的好处。由于属性包装器和关键路径，这些成为可能。它们允许在编译时解决所有的依赖关系。如果缺少任何一项，项目就无法构建。这意味着具有这种依赖关系的每个实例都将在创建时进行设置。

由于我们通过属性注入依赖，传递给`init`方法的参数列表减少了。我们不需要在创建实例的每个地方传递所有的依赖关系。

一个好的项目有一个层次结构。例如，如果我们遵循干净的架构，我们可能会有以下几层:视图、视图模型、交互器(用例)、应用程序状态等。最有可能的是，您不希望所有这些层都访问相同的依赖项。该解决方案使用关键路径来构建依赖关系，只为设计允许的每一层提供那些依赖关系。

让我们看看它是如何工作的。下面的代码样本来自一个测试项目。你可以在本文末尾找到一个链接。

## 注入的属性包装

下面是我们实现属性包装器的方法:

我们使用一个关键路径来标识注入的依赖项。这种关键路径的前缀决定了依赖关系的层范围。例如，注入到视图模型中，我们将使用`\.viewModel.`:

类似地，可以在 keypath 中使用前缀`\.interactor.`来访问交互器的注入:

这里一个很棒的事情是，你不需要指定一个可注入变量的类型。编译器通过 keypath 来推断它。

## 根依赖容器

层是可定制的。你在根`DependencyInjection`类中指定它们:

## 层

在我们的例子中，我们只为两层提供注入:交互器和视图模型。协议允许我们隐藏容器的实现细节，例如，使用模拟注射进行测试。以下是协议的定义:

两层都可以访问`appState`。但是只有交互器可以调用`network`。

如果我们为视图层设置注入，我们可能不会在那里添加`appState`，只允许视图通过它们的视图模型访问`appState`。

`InteractorInjectionProtocol`的实际实现很简单:

对于`ViewModelInjectionProtocol`，我们提供了两个实现，包括测试的模拟版本:

我们通过`init`传递`AppState`的一个实例，因为它是共享的。这里使用的关键字`lazy`对于`gitHubInteractor`来说并不重要，但是在单个应用程序运行期间，我们可能并不总是需要注入时使用它是合理的。

为了全面理解，让我们看看`GitHubInteractor`和`MockGitHubInteractor`的实现:

两个交互器实现相同的协议。在内部，他们也使用依赖注入机制。它们从交互层访问可注入值。因为所有的依赖项都被直接注入到属性中，所以我们不需要通过`init`方法传递它们。

## 装配

为了提供我们项目中所有可用注入的集合，我们将它作为计算属性添加到`DependencyInjection`类的扩展中:

我们为应用程序本身使用不同的程序集，同时运行项目进行预览。因为预览中不需要网络调用。

## 试验

下面是我们如何在测试用例中设置我们的程序集:

# 结论

所开发的解决方案具有以下主要优势:

*   尽管这是一个属性注入，但注入的值在对象构造时变得可用。解析是在编译期间执行的。关键路径的特征确保了这一点。
*   我们不会用额外的依赖来重载`init`方法。依赖关系被直接注入到属性中。
*   它允许您控制从不同层对依赖项的访问。
*   这是一个简单的解决方案，不需要外部库的代码。

# 资源

您可以在我的 GitHub 资源库中找到本文中使用的源代码:

*   [分层依赖注入](https://github.com/ihorvovk/Layered-Dependency-Injection)