<html>
<head>
<title>How To Perform Remote Procedure Calls With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Go执行远程过程调用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-perform-remote-procedure-calls-with-go-e96e9eee691d?source=collection_archive---------11-----------------------#2021-08-30">https://betterprogramming.pub/how-to-perform-remote-procedure-calls-with-go-e96e9eee691d?source=collection_archive---------11-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7abb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Golang中的gRPC API入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29e38ebb9ed3867db261ccc102fba581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhR0GNM_wrfEawQ4HfU2ZQ.jpeg"/></div></div></figure><p id="4d48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">REST APIs长期以来一直统治着开发世界，但是现在出现了一个新玩家——gRPC！在本文中，让我们探究gRPC到底是什么，并使用Golang构建一个简单的初学者API。</p><h1 id="af77" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">gRPC是什么？</h1><p id="8253" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">gRPC是Google开发的用于执行远程过程调用(RPC)的开源框架。这为我们连接多个服务提供了一种有效的方式。gRPC最好的地方是我们可以直接调用API，就像调用其他方法一样！</p><p id="1ca0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是来自官方<a class="ae mn" href="https://grpc.io/docs/what-is-grpc/introduction/" rel="noopener ugc nofollow" target="_blank"> gRPC文档</a>的参考:</p><blockquote class="mo"><p id="e81f" class="mp mq it bd mr ms mt mu mv mw mx lp dk translated">在gRPC中，客户端应用程序可以直接调用不同计算机上的服务器应用程序上的方法，就像它是本地对象一样，这使您可以更轻松地创建分布式应用程序和服务</p></blockquote><p id="52b4" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">此外，gRPC客户机和服务器可以在各种环境中相互通信，而不用考虑所使用的语言或框架。</p><p id="b7ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Arun Mathew Kurian 在这里写了一篇很棒的文章<a class="ae mn" rel="noopener ugc nofollow" target="_blank" href="/understanding-grpc-60737b23e79e">，详细探讨了REST和RPC架构之间的差异。一定要去看看！</a></p><h1 id="3c35" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">Go中的gRPC入门</h1><p id="0d13" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们尝试在Go中开发一个简单的gRPC API。在我们开始之前，请确保您已准备好以下先决条件:</p><h2 id="a710" class="nf lr it bd ls ng nh dn lw ni nj dp ma ld nk nl mc lh nm nn me ll no np mg nq bi translated">安装Go</h2><p id="e342" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">您需要安装Go。点击官方<a class="ae mn" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">链接</a>下载。</p><h2 id="cc80" class="nf lr it bd ls ng nh dn lw ni nj dp ma ld nk nl mc lh nm nn me ll no np mg nq bi translated">安装协议</h2><p id="f1ac" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated"><code class="fe nr ns nt nu b">protoc</code>是一个协议缓冲编译器。检查此处的说明<a class="ae mn" href="https://grpc.io/docs/protoc-installation/" rel="noopener ugc nofollow" target="_blank">以安装</a>。</p><h2 id="0c8a" class="nf lr it bd ls ng nh dn lw ni nj dp ma ld nk nl mc lh nm nn me ll no np mg nq bi translated">安装协议编译器插件</h2><p id="448e" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">通过下面的命令安装协议编译器插件。</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="0d03" class="nf lr it nu b gy nz oa l ob oc">go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26<br/>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1</span></pre><h2 id="6144" class="nf lr it bd ls ng nh dn lw ni nj dp ma ld nk nl mc lh nm nn me ll no np mg nq bi translated">更新路径</h2><p id="800a" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">使用以下命令更新路径:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="3751" class="nf lr it nu b gy nz oa l ob oc">export PATH="$PATH:<strong class="nu iu">$(</strong>go env GOPATH<strong class="nu iu">)</strong>/bin"</span></pre><h1 id="4eb4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建新的Go项目</h1><p id="cbae" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">为了简单起见，我们将在同一个包中进行所有的编码。创建一个名为<code class="fe nr ns nt nu b">go_grpc</code>的文件夹，并在该文件夹中执行以下命令:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="ef36" class="nf lr it nu b gy nz oa l ob oc">go mod init go_grpc</span><span id="055e" class="nf lr it nu b gy od oa l ob oc">go get google.golang.org/grpc<br/>go get google.golang.org/protobuf/reflect/protoreflect@v1.25.0<br/>go get google.golang.org/protobuf/runtime/protoimpl@v1.25.0</span></pre><h1 id="cfc6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建原型文件</h1><p id="f2d9" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在我们已经准备好了设置，让我们创建一个原型文件，在其中定义我们的API。让我们创建一个返回用户详细信息的API。</p><p id="971f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一个名为<code class="fe nr ns nt nu b">user.proto</code>的文件。在我们的原型定义中，我们将用必需的字段定义请求和响应对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b68f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们定义了一个名为<code class="fe nr ns nt nu b">UserService</code>的服务，它提供了一个名为<code class="fe nr ns nt nu b">GetUser</code>的rpc(类似于一个函数)。</p><p id="9c6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据我们的定义，让我们生成一个Go文件。为此，我们执行以下命令:</p><pre class="kj kk kl km gt nv nu nw nx aw ny bi"><span id="cc23" class="nf lr it nu b gy nz oa l ob oc">protoc --go_out=. --go_opt=paths=source_relative <strong class="nu iu">\<br/></strong>    --go-grpc_out=. --go-grpc_opt=paths=source_relative <strong class="nu iu">\<br/></strong>users.proto</span></pre><p id="f026" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将创建两个文件，<code class="fe nr ns nt nu b">users.pb.go</code>和<code class="fe nr ns nt nu b">users_grpc.pb.go</code>。这两个文件都包含填充、序列化和检索我们在原型文件中定义的消息所需的所有代码。</p><p id="834b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它还将包含为客户端和服务器生成的代码。</p><h1 id="25c6" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建服务器</h1><p id="98a1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">接下来，创建一个<code class="fe nr ns nt nu b">main.go</code>文件，在我们的<code class="fe nr ns nt nu b">main</code>函数中，让我们创建gRPC服务器并开始监听端口<code class="fe nr ns nt nu b">8000</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="a896" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们服务器的主要目标是服务<code class="fe nr ns nt nu b">GetUser</code>的请求。它在请求体中打印出<code class="fe nr ns nt nu b">id</code>，并返回一个名称为“John Doe”的标准响应。</p><p id="a4bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们为命令行参数添加了条件检查。因为我们将所有文件放在同一个包中，所以我们将接受一个命令行参数来指定我们是启动服务器还是客户端。</p><h1 id="ebf2" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">创建客户端</h1><p id="38ad" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">最后，让我们创建一个客户机，它可以对我们的服务器进行gRPC调用<code class="fe nr ns nt nu b">GetUser</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="848c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，我们进行调用的方式类似于调用函数。我们所做的是<code class="fe nr ns nt nu b">client.GetUser(context.Background(), request)</code>，这将从服务器返回响应。</p><h1 id="683e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">运行我们的服务器和客户端</h1><p id="f634" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在运行我们的代码之前，让我们从文件夹的根目录使用<code class="fe nr ns nt nu b">go build .</code>来构建它。这将在根目录下创建一个可执行文件<code class="fe nr ns nt nu b">go_grpc</code>。</p><p id="c9c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们打开两个终端——一个用于服务器，一个用于客户端。</p><p id="6bf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第一个终端中，运行<code class="fe nr ns nt nu b">./go_grpc server</code>。如果您已经成功运行了服务器和客户端，您应该会立即看到以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/a1584ff02bf67aaabb3db5104f2c7783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*INz7u6woT2c165l5t_0kYA.png"/></div></div></figure><p id="54f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第二个终端中，使用<code class="fe nr ns nt nu b">./go_grpc client</code>启动客户机，您应该看到服务器终端和客户机终端都将打印出以下输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/7f18c79a4dca130f8d4dd1c100a72176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*udoQmWg3m0m1dpgRt4MG2Q.png"/></div></div><p class="oh oi gj gh gi oj ok bd b be z dk translated">在客户端</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/044f20271060e2e011118659b7059c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fVr_RdtFqkimyp0Ez2xr2A.png"/></div></div><p class="oh oi gj gh gi oj ok bd b be z dk translated">在服务器上</p></figure><p id="3fe3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们走吧！我们的gRPC服务器和客户端已经准备好了。</p><h1 id="90a7" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="31b4" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">在本文中，我们看到了使用<code class="fe nr ns nt nu b">protoc</code>定义一个API并让服务器和客户端生成是多么容易。使用gRPC的一个主要优点是，由于它使用的协议缓冲区优于REST中的标准JSON或XML，因此可以更好地编码数据。</p><p id="4091" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，gRPC允许我们使用HTTP2作为传输协议。考虑到它能与各种语言很好地集成，在各种微服务之间进行有效的通信对我们来说也是一个很好的选择。</p><p id="02f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Napon Mekavuthikul 也写了一篇关于gRPC如何节省开发时间的文章<a class="ae mn" href="https://medium.com/red-crane/grpc-and-why-it-can-save-you-development-time-436168fd0cbc" rel="noopener">这里</a>。请仔细阅读，以了解我们如何使用gRPC进一步改进我们的开发过程和生命周期。</p><p id="3a24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为您的下一个项目尝试gRPC，并分享您的经验！</p></div></div>    
</body>
</html>