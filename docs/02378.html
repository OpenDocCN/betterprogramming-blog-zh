<html>
<head>
<title>Different Ways to Duplicate Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中复制对象的不同方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/different-ways-to-duplicate-objects-in-javascript-c199be34ecb7?source=collection_archive---------4-----------------------#2019-11-26">https://betterprogramming.pub/different-ways-to-duplicate-objects-in-javascript-c199be34ecb7?source=collection_archive---------4-----------------------#2019-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0230" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">原来复制物体有很多不同的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1f855cff0a43bb6902e8ff5b800525c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T4YyhxVPPDDDjoGGhbommg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">詹姆斯·奥尔在<a class="ae kv" href="https://unsplash.com/s/photos/multiple?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，变量可以存储两种类型的数据:</p><ul class=""><li id="6b75" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">原始的</li><li id="7239" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">参考</li></ul><p id="90bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们复制原始值时，只有值会被复制。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="39ea" class="ml mm iq mh b gy mn mo l mp mq">var a = 10;</span><span id="630a" class="ml mm iq mh b gy mr mo l mp mq">var b = a;</span><span id="8b75" class="ml mm iq mh b gy mr mo l mp mq">console.log(a, b); // 10, 10</span><span id="5d8e" class="ml mm iq mh b gy mr mo l mp mq">b = 20;</span><span id="0111" class="ml mm iq mh b gy mr mo l mp mq">console.log(a, b); // 10, 20</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/2b8ca63bd15a5b8a8f63193c3860a856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHktLgj2zMxbt5yWHzXRqw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当我们复制原始值时，只复制值。</p></figure><p id="bc0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是当我们复制引用值时，对象的内存地址是共享的。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="0599" class="ml mm iq mh b gy mn mo l mp mq">var a = { one : 1};</span><span id="aaf4" class="ml mm iq mh b gy mr mo l mp mq">var b = a;</span><span id="30a9" class="ml mm iq mh b gy mr mo l mp mq">a.one = 2;</span><span id="400b" class="ml mm iq mh b gy mr mo l mp mq">console.log(b.one); // 2</span><span id="d989" class="ml mm iq mh b gy mr mo l mp mq">b.one = 3;</span><span id="0a15" class="ml mm iq mh b gy mr mo l mp mq">console.log(a.one); //3</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/e5a05e9c11db89436f6c8f38231e53e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KS9NxYyzCrYDsQuAfBd2mg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当我们将对象赋给其他变量时，只复制内存地址。</p></figure><p id="be97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们改变了<code class="fe mt mu mv mh b">a</code>或<code class="fe mt mu mv mh b">b</code>的属性，我们就改变了对象地址的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/67bfc543257241bbb9709e2f580ca078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGEBUmTdOtzWWnDt-k-XqA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当对象的属性更改时，这些更改会反映在指向该对象的所有变量中。</p></figure><p id="7721" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要复制一个原始值，我们可以使用<code class="fe mt mu mv mh b">assignment operator (=)</code>，但是对于对象我们不能使用赋值操作符。</p><p id="0099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">复制对象时，有两种类型:</p><ul class=""><li id="ad9d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">浅拷贝</li><li id="b903" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">深层拷贝</li></ul><p id="aa48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们将一个源对象浅层复制到一个目标对象时，如果源对象的属性值是原始的，那么该值将被复制到目标对象。但是如果源对象的属性值是reference，那么这个引用在源对象和目标对象之间共享。</p><p id="8231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在深度复制中，源对象的所有属性(包括引用)都作为值复制到目标对象。源对象和目标对象之间不共享引用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/84c62dbc4919f29526c23e9a1562f6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*erH6SNdDY-mE5h2AoopK4w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">浅层拷贝和深层拷贝的区别</p></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="c46d" class="nf mm iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">浅拷贝</h1><h2 id="635f" class="ml mm iq bd ng nw nx dn nk ny nz dp no lf oa ob nq lj oc od ns ln oe of nu og bi translated">使用扩展运算符</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="f035" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">spread操作符将把<code class="fe mt mu mv mh b">obj</code>的所有可枚举属性复制到<code class="fe mt mu mv mh b">copiedObj</code>。</p><h2 id="3f75" class="ml mm iq bd ng nw nx dn nk ny nz dp no lf oa ob nq lj oc od ns ln oe of nu og bi translated">使用循环</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="40fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码将遍历对象的所有属性，并将值复制到目标对象。</p><h2 id="652b" class="ml mm iq bd ng nw nx dn nk ny nz dp no lf oa ob nq lj oc od ns ln oe of nu og bi translated">对象.分配</h2><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="8d0d" class="ml mm iq mh b gy mn mo l mp mq">var source = {one : 1, nested: {two : 2}};</span><span id="b710" class="ml mm iq mh b gy mr mo l mp mq"><strong class="mh ir">var target = Object.assign({}, source);</strong></span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="0106" class="nf mm iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">深层拷贝</h1><p id="8001" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">使用<code class="fe mt mu mv mh b">JSON.stringify</code>和<code class="fe mt mu mv mh b">JSON.parse</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="6a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mt mu mv mh b">JSON.stringify</code>和<code class="fe mt mu mv mh b">JSON.parse</code>只处理数字、字符串和对象文字，不支持函数或符号属性。</p><p id="4ab5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，如果对象中属性的值是<code class="fe mt mu mv mh b">Date</code>，那么使用<code class="fe mt mu mv mh b">JSON.stringify</code>将把<code class="fe mt mu mv mh b">Date object</code>转换成一个字符串。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="32d2" class="ml mm iq mh b gy mn mo l mp mq">var a = { d : new Date() };</span><span id="42f9" class="ml mm iq mh b gy mr mo l mp mq">var b = JSON.parse(JSON.stringify(a));</span><span id="956e" class="ml mm iq mh b gy mr mo l mp mq">b ; // {d: "2019-11-26T00:28:18.775Z"}</span></pre><h2 id="8146" class="ml mm iq bd ng nw nx dn nk ny nz dp no lf oa ob nq lj oc od ns ln oe of nu og bi translated">什么是圆形物体？</h2><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="fe1d" class="ml mm iq mh b gy mn mo l mp mq">var a = {}; </span><span id="b72c" class="ml mm iq mh b gy mr mo l mp mq">a.a = a;</span></pre><p id="4e7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">圆形对象是具有引用自身的属性值的对象。</p><p id="1555" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们执行循环对象的深度复制时，它会无休止地继续下去。<code class="fe mt mu mv mh b">JSON.stringify/parse</code>在循环对象上执行深度复制时会抛出异常错误。</p><p id="cbf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe mt mu mv mh b">Object.assign</code>来复制一个圆形对象——但是首先要避免创建一个圆形对象。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="1fd9" class="nf mm iq bd ng nh ni nj nk nl nm nn no jw np jx nq jz nr ka ns kc nt kd nu nv bi translated">实现自定义克隆</h1><p id="28da" class="pw-post-body-paragraph kw kx iq ky b kz oj jr lb lc ok ju le lf ol lh li lj om ll lm ln on lp lq lr ij bi translated">在<code class="fe mt mu mv mh b">deepClone</code>方法中，我们将遍历对象的所有属性。如果对象的值是基元的，就复制它。如果值是引用，调用<code class="fe mt mu mv mh b">deepclone</code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oh oi l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">纯JavaScript的深度克隆</p></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="1589" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上方法都只关注对象，不关注数组。它们可能不适用于数组。</p><p id="0f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读，我希望你喜欢这篇文章。</p><p id="3ff5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">赞助我一杯<a class="ae kv" href="https://www.buymeacoffee.com/Jagathish" rel="noopener ugc nofollow" target="_blank">☕️咖啡</a>。</p></div></div>    
</body>
</html>