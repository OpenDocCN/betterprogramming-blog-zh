<html>
<head>
<title>The Abstract Factory Pattern for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的抽象工厂模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-abstract-factory-pattern-for-beginners-4c756c21c1b8?source=collection_archive---------0-----------------------#2021-06-10">https://betterprogramming.pub/the-abstract-factory-pattern-for-beginners-4c756c21c1b8?source=collection_archive---------0-----------------------#2021-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="38bd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过例子理解抽象工厂设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4246c039b5c2109517fed74fd420b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCuXkBbkJxSkw6iI8ohrhw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a>在<a class="ae ky" href="https://unsplash.com/s/photos/software-engineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="9728" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我上一篇关于<a class="ae ky" href="https://www.linkedin.com/pulse/approaching-design-patterns-beginners-mind-strategy-m%C3%A1rcio-j%C3%BAnior" rel="noopener ugc nofollow" target="_blank">策略模式</a>的文章中，我涵盖了比预期更多的内容。这一次，我会更直截了当。关于设计模式的一个重要教训似乎是不要将代码提交给作为特定类实例的变量。如果代码是根据特定的对象实现的，它会导致子系统之间的依赖，并使其难以更改或重用。</p><p id="56f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常会创建这样的对象:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2c6e" class="ma mb it lw b gy mc md l me mf">MyClass mc = new MyClass();</span></pre><p id="28b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个应用程序对一个特定类的构造函数有很多这样的调用，那么当需要改变时就很难维护了。希腊哲学家赫拉克利特说过:“变化是生活中唯一不变的东西。”这也适用于系统设计。</p><blockquote class="mg mh mi"><p id="8228" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">“最大化重用的关键在于预测新的需求和对现有需求的变更，以及设计您的系统以便它们可以相应地发展。</p><p id="d3f1" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi">…</p><p id="7e19" class="kz la mj lb b lc ld ju le lf lg jx lh mk lj lk ll ml ln lo lp mm lr ls lt lu im bi translated">一个不考虑变化的设计在将来会有重新设计的风险。”— <a class="ae ky" href="https://books.google.ca/books?id=6oHuKQe3TjQC&amp;pg=PT46&amp;lpg=PT46&amp;dq=The+key+to+maximizing+reuse+lies+in+anticipating+new+requirements+and+changes+to+existing+requirements,+and+in+designing+your+systems+so+that+they+can+evolve+accordingly.+A+design+that+doesn%27t+take+change+into+account+risks+major+redesign+in+the%C2%A0future.&amp;source=bl&amp;ots=lQkIAUfJGC&amp;sig=ACfU3U3_2TsrKv1uWLHc5fnIn0EhsUWITA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwiExZqNsY3xAhVCheAKHYZXA2YQ6AEwB3oECAkQAw#v=onepage&amp;q&amp;f=false" rel="noopener ugc nofollow" target="_blank">设计模式</a></p></blockquote><p id="b978" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我们可以通过如下实例化类来减少依赖性:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="4892" class="ma mb it lw b gy mc md l me mf">MyClass mc = Factory.Create();</span></pre><p id="7d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个<code class="fe mn mo mp lw b">Factory</code>的实例，它像对象工厂一样创建其他对象。并且<code class="fe mn mo mp lw b">create</code>方法返回我们想要的特定对象的新实例。那么，有什么不同呢？作为客户机，我们负责实例化一个新对象的代码不知道任何关于被创建对象的事情。它只知道<code class="fe mn mo mp lw b">Factory</code>接口。那个工厂<em class="mj">抽象了</em>对象创建的过程。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="89e0" class="mx mb it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">抽象</h1><p id="d189" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">当谈到软件设计时，抽象是一个经常使用的词。在我们继续之前，我想确定你明白它的意思。从它的拉丁词根来看，抽象意味着“拖走”或“拉走”你可以找到抽象的几个定义，但我认为当谈到软件时，它仍然带有它最初的含义。</p><p id="ce6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，抽象是一种原则，在这种原则下，您可以去掉代码的一部分，使其独立。因此，这部分代码通常会成为一个接口或一个抽象类——也称为抽象。现在，我们可以在不知道接口如何工作的情况下对其进行编程。</p><p id="2427" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这段计算和显示矩形面积的代码:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="fc67" class="ma mb it lw b gy mc md l me mf">int area = width * length;<br/>Console.WriteLine("area = " + area);</span></pre><p id="191d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这完全依赖于矩形形状，我们知道实现细节。我不会在这里深究糟糕设计的细节，但它可以重新设计如下:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="6f59" class="ma mb it lw b gy mc md l me mf">int area = shape.GetArea();<br/>Console.WriteLine("area = " + area);</span></pre><p id="37f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不再知道实现细节，只需要处理<code class="fe mn mo mp lw b">shape</code>接口，它可以是矩形或圆形。这里是多态现象。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="612c" class="mx mb it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">抽象工厂</h1><p id="650d" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">抽象工厂模式属于一类称为Creational的模式，因为它处理对象创建。创建模式抽象了对象创建的过程。抽象工厂关注对象的家族，而其他工厂关注一种对象。从现在开始，我们将把对象称为产品。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/2a10f262fa61c3dd1f0ee9873680233e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*RT71rBhKwF4lFHyCo_H4eA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="3fc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图显示了两个相关产品系列:<code class="fe mn mo mp lw b">Square</code>和<code class="fe mn mo mp lw b">Circle</code>。让我们从创建一个抽象概念开始:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="72f3" class="ma mb it lw b gy mc md l me mf">interface ISquare<br/>{<br/>    void Draw();<br/>}</span></pre><p id="b262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该图还显示了实现接口的具体类。它可以是不同类型的正方形(例如Square3D)。为了简洁起见，我将省略这一点(因为我不喜欢阅读有大量代码的文章)。只需考虑这两个抽象产品和您的四个具体实现。</p><p id="a573" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要一个工厂来制造它们，对吗？没问题:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="d68c" class="ma mb it lw b gy mc md l me mf">interface IFactory<br/>{<br/>    ISquare CreateSquare();<br/>    ICircle CreateCircle();<br/>}</span></pre><p id="9222" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是该模式的名称:抽象工厂。但是你可能知道，我们不能实例化一个接口。这家工厂会制造一个规则的正方形还是3D的？我不知道。我们需要为每个负责生产产品的工厂提供一个具体的实现。以下是3D形状的示例:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="750e" class="ma mb it lw b gy mc md l me mf">class Factory3D : IFactory<br/>{<br/>    public ISquare CreateSquare()<br/>    {<br/>        return new Square3D();<br/>    }</span><span id="795d" class="ma mb it lw b gy nu md l me mf">    public ICircle CreateCircle()<br/>    {<br/>        return new Circle3D();<br/>    }<br/>}</span></pre><p id="2231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，一家工厂生产不同系列的产品:<code class="fe mn mo mp lw b">Square</code>和<code class="fe mn mo mp lw b">Circle</code>。但是它们作为3D形状彼此相关。这是可能的，因为它们共享相同的接口，尽管它们属于不同的家族。同样的，工厂也共享相同的接口。作为客户，这允许我们选择一个系列，然后所有产品都将属于该系列:</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="9832" class="ma mb it lw b gy mc md l me mf">IFactory factory = new Factory2D();<br/>ISquare square = factory.CreateSquare();<br/>square.Draw();</span></pre><p id="698e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以简单地换到另一家工厂，替换整个系列的产品。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="fc32" class="mx mb it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">结论</h1><p id="e092" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">在本文中，我们看到了抽象工厂模式是如何工作的。这种模式的目的是为创建相关对象系列提供一个接口。你可以在<em class="mj">设计模式</em>这本书里找到这个模式的完整图解。访问我的<a class="ae ky" href="https://github.com/marciosouzajunior/DesignPatterns" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>获取更多代码示例。</p><p id="bf02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>