<html>
<head>
<title>What’s New in TypeScript 4.6?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.6有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-typescript-4-6-5e87cb34cb32?source=collection_archive---------1-----------------------#2022-02-22">https://betterprogramming.pub/whats-new-in-typescript-4-6-5e87cb34cb32?source=collection_archive---------1-----------------------#2022-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="769f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构造函数修复、进一步的JavaScripts检查等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e56d917de8ccd24be74cb0723ff26cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kbjGXlj4QaqzXDspEg0oPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="87a2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">打字稿<code class="fe lu lv lw lx b">4.6</code>版本计划于2月22日发布。28号终于发货了🎉🎉🎉。遗憾的是，它没有第一次那么激动人心。老实说，它把标准定得有点高。它包含了等待类型、仅类型导入说明符等特性。</p><p id="bb17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，这个TypeScript版本仍然令人兴奋。它有一些有用的核心修正。在幕后，TypeScript团队正在进一步为NodeJs集成ES模块。</p><p id="22e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和往常一样，您可以在这里使用TypeScript Playground <a class="ae ly" href="https://www.typescriptlang.org/play?" rel="noopener ugc nofollow" target="_blank">跟随任何示例。</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3c35" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">允许在构造函数中的Super之前有代码</h1><p id="bc03" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">在JavaScript中，我们不允许在构造函数中的任何<code class="fe lu lv lw lx b">super()</code>调用之前使用<code class="fe lu lv lw lx b">this</code>引用。这是因为对象尚未创建。</p><p id="6153" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b0bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，您可以执行代码，只要它与<code class="fe lu lv lw lx b">this</code>引用无关。</p><p id="a223" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Typescript总是更具限制性。这使得JavaScript规则更加严格。它强制<code class="fe lu lv lw lx b">super()</code>处于构造器的顶层。</p><p id="59f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们将上面的JavaScript示例移植到TypeScript，我们会得到以下错误:</p><pre class="kj kk kl km gt nf lx ng nh aw ni bi"><span id="dd79" class="nj mh it lx b gy nk nl l nm nn">A <strong class="lx iu">'super'</strong> call must be the first statement in the constructor when a class contains initialized properties, parameter properties, or private identifiers.</span></pre><p id="d482" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">三年多前，一个与JavaScript平起平坐的PR诞生了。它最近被合并了，现在顶级<code class="fe lu lv lw lx b">super()</code>的限制已经没有了。</p><p id="c192" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，现在这段代码不会给出任何编译错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">关于合并后<a class="ae ly" href="https://github.com/microsoft/TypeScript/pull/29374" rel="noopener ugc nofollow" target="_blank"> PR </a>的原始代码建议</p></figure><p id="b47d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个公关活得太久了，甚至有了自己的蛋糕🤣：</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/9d21d55129890523133afb7f674efadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vLw1Rcnkf2rw62ar.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ly" href="https://github.com/microsoft/TypeScript/pull/29374" rel="noopener ugc nofollow" target="_blank"> PR </a>中发布的图像</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7538" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">相关参数的控制流分析</h1><p id="18f4" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">TypeScript中有一个很酷的特性，您可以在其中表达方法的相关参数的组合。你可以告诉编译器，你想要一个函数参数不同组合的数组。</p><p id="a2e3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们定义一个方法，如果第一个参数是一个<code class="fe lu lv lw lx b">string</code>，第二个应该是一个<code class="fe lu lv lw lx b">number</code>，反之亦然。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a1bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">唯一的问题是我们必须手动检查<code class="fe lu lv lw lx b">a</code>和<code class="fe lu lv lw lx b">b</code>的类型。只有函数的调用在断言约束。</p><p id="b87d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个新版本中，我们可以使用联合鉴别器来帮助我们鉴别<code class="fe lu lv lw lx b">b</code>的类型，因为<code class="fe lu lv lw lx b">a</code>是一个鉴别器(字符串或枚举),并且我们知道它的值。</p><p id="e52f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7c12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，上述内容不适用于非歧视性工会。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ba82" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">索引访问推理改进</h1><p id="8a03" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">如果我们想在TypeScript中表达类似下面的代码，我们会发现一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7b54" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">乍一看，这似乎是正确的，发生了什么事？TypeScript正在使函数<code class="fe lu lv lw lx b">(v) =&gt; void</code>的<code class="fe lu lv lw lx b">v</code>成为类型<code class="fe lu lv lw lx b">string &amp; number &amp; boolean</code>的交集。因为它们之间没有交集，所以会产生<code class="fe lu lv lw lx b">never</code>类型。</p><p id="8e27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个问题可以通过使用映射类型来解决:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f109" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，在TypeScript <code class="fe lu lv lw lx b">4.6</code>之前，下面的调用不会失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b6de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">kind</code>值没有起到鉴别器的作用。这将使<code class="fe lu lv lw lx b">v.toUpperCase()</code>编译产生错误。编译器不会知道<code class="fe lu lv lw lx b">v</code>是一个字符串。</p><p id="0f28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在它工作了，索引访问类型应用于映射类型的问题已经被修复。前面的代码将编译无误。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7d74" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">目标es2022</h1><p id="63aa" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated"><code class="fe lu lv lw lx b">target</code>设置改变哪些JS特性被传输，哪些保持原样。在此版本中，包含了对<code class="fe lu lv lw lx b">--target es2022</code>的支持。</p><p id="b766" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最新的模块<code class="fe lu lv lw lx b">es2022</code>支持是在以前的TypeScript版本中引入的。这使我们能够使用像<code class="fe lu lv lw lx b">top-level await</code>这样的功能。</p><p id="0865" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个<code class="fe lu lv lw lx b">--target es2022</code>将作为<code class="fe lu lv lw lx b">Typescript 4.5</code>版本的一部分发布，但是不幸的是，一些小问题推迟了它的发布。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a8c8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">JavaScript中的其他语法和绑定错误</h1><p id="f4db" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">TypeScript编译器可以接受TypeScript和JavaScript文件作为输入。它可以被配置为甚至在那些JavaScript文件中查找错误。这将阻止我们在运行时发现这些错误。</p><p id="2aa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">选择加入此行为的配置是:</p><pre class="kj kk kl km gt nf lx ng nh aw ni bi"><span id="9f5b" class="nj mh it lx b gy nk nl l nm nn">// tsconfig.json<br/>{<br/>  ...<br/>  <strong class="lx iu">"allowJs": true,</strong><br/>  <strong class="lx iu">"checkJs": true,</strong><br/>  ...<br/>}</span></pre><p id="f98d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们不想在全局范围内启用这些功能，我们可以在每个文件的基础上执行一些调整:</p><ul class=""><li id="53c4" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated"><code class="fe lu lv lw lx b">// @ts-check</code>在JavaScript文件的顶部:将检查该文件的类型错误。</li><li id="0d78" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated"><code class="fe lu lv lw lx b">// @ts-nocheck</code>在文件顶部:将防止任何打字稿错误。尽管它是用JavaScript构建的，但它也禁止对文件进行类型检查。这是为了确保更容易的迁移。</li></ul><p id="b2a4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么这个版本有什么变化呢？Typescript团队继续通过添加新的错误来进一步改进这一功能。</p><p id="c280" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，它现在可以捕捉重新声明的变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c4b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将Visual Studio代码与最新的TypeScript版本一起使用时，也会显示这些错误。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c7c6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包裹</h1><p id="8bcc" class="pw-post-body-paragraph ky kz it la b lb my ju ld le mz jx lg lh na lj lk ll nb ln lo lp nc lr ls lt im bi translated">这个版本的目的是进一步强化一些类型脚本行为。它没有其他产品那么耀眼，但它仍然在代码库和新特性上有所改进。</p><p id="85e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多工作都是由后台的NodeJS集成完成的。NodeJS对ES模块的支持越来越好。它是在以前的TypeScript 4.5版本的实验标志下引入的。希望它很快变得稳定。</p><p id="1c94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。</p><div class="od oe gp gr of og"><a rel="noopener  ugc nofollow" target="_blank" href="/top-5-typescript-features-you-should-master-2358db9ab3d5"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">您应该掌握的五大打字稿功能</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">使用这些必须知道的特性来提高您的打字稿知识</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">better编程. pub</p></div></div><div class="op l"><div class="oq l or os ot op ou ks og"/></div></div></a></div><div class="od oe gp gr of og"><a rel="noopener  ugc nofollow" target="_blank" href="/5-awesome-http-headers-web-developers-should-master-332a1a332084"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">Web开发人员应该掌握的5个非常棒的HTTP头</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">以更简洁的方式提高页面安全性和性能</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">better编程. pub</p></div></div><div class="op l"><div class="ov l or os ot op ou ks og"/></div></div></a></div></div></div>    
</body>
</html>