<html>
<head>
<title>How To Avoid Use Cases Boilerplate in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免Android中的用例样板</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-use-cases-boilerplate-in-android-d0c9aa27ef27?source=collection_archive---------0-----------------------#2022-08-24">https://betterprogramming.pub/how-to-avoid-use-cases-boilerplate-in-android-d0c9aa27ef27?source=collection_archive---------0-----------------------#2022-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f756" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索四种不同的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/631dc5719e95152aa4907f28514d612c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gEq_Om0oEILtB31526pCxw.png"/></div></div></figure><p id="45ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">自从分层架构出现以来，<a class="ae ln" href="https://proandroiddev.com/why-you-need-use-cases-interactors-142e8a6fe576" rel="noopener ugc nofollow" target="_blank">用例</a>就有着争议的名声。</p><p id="ea06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一方面，它们帮助你坚持<a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/the-real-clean-architecture-in-android-part-1-s-o-l-i-d-6a661b103451"> S.O.L.I.D. </a>原则，提高你的代码可读性；另一方面，它们有时是“无用的”(它们唯一做的事情就是调用存储库方法)。</p><p id="adb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正因为如此，业界集中了以下四种方法(仅在用例只是调用存储库方法时使用):</p><h1 id="3037" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">方法1:跳过用例</h1><p id="af9d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">使用这种方法，只有当它在做一些事情时，你才有一个用例，而如果它是“无用的”，你就直接调用存储库。</p><p id="0c94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="cd77" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">赞成的意见</h2><ol class=""><li id="a11b" class="mz na iq kt b ku mg kx mh la nb le nc li nd lm ne nf ng nh bi translated">需要编写的代码更少</li><li id="fe57" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">没有冗余:对存储库方法的改变不需要用例的改变。</li></ol><h2 id="84c2" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">骗局</h2><ol class=""><li id="43e2" class="mz na iq kt b ku mg kx mh la nb le nc li nd lm ne nf ng nh bi translated">不一致</li><li id="ad00" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">可伸缩性:如果repository方法需要不是来自表示层的额外参数，那么使用它的所有虚拟机都需要更新，对于核心存储库来说，这可能是一个很大的重构。</li><li id="ebb5" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">ISP违规:仓库通常有很多方法。因此，当您有一个知识库作为合作者时，每当您不使用的方法被添加、删除或更改时，您的类将需要重新编译。</li><li id="bd0e" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">欺骗:我对这种方法的经验是，懒惰的工程师会找借口从来没有用例，因此用业务逻辑过载视图模型或存储库。</li></ol><h1 id="a4f1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">方法2:保留用例</h1><p id="8ae3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">使用这种方法，您不关心您的用例是否正在做某事，因为您总是有一个用例:</p><p id="6921" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="2cf6" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">赞成的意见</h2><ol class=""><li id="8b0b" class="mz na iq kt b ku mg kx mh la nb le nc li nd lm ne nf ng nh bi translated">一致性。</li><li id="c593" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">可伸缩性:如果存储库方法需要不是来自表示层的额外参数，所有使用用例的虚拟机都不需要更新，因为它们受到用例接口的保护。</li><li id="ff14" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">ISP遵守情况。</li></ol><h2 id="ba81" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">骗局</h2><ol class=""><li id="56f0" class="mz na iq kt b ku mg kx mh la nb le nc li nd lm ne nf ng nh bi translated">更多的代码要写。</li><li id="5831" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">冗余:如果您的存储库方法签名因为从表示层获得不同的参数而改变，您将不得不更新用例类、测试和接口。</li></ol><blockquote class="nn no np"><p id="1bf0" class="kr ks nq kt b ku kv jr kw kx ky ju kz nr lb lc ld ns lf lg lh nt lj lk ll lm ij bi translated">注意:当我说“来自表示层的参数”时，我不是指传递给用例的表示层模型，我是指来自表示层的输入，它被映射到领域模型中。</p></blockquote><p id="162c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在纯OOP中，这两种方法是你仅有的选择，但是当你将函数式编程加入其中时，事情会变得更好。</p><h1 id="8b7a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">方法3:具有类型别名的功能用例</h1><p id="bc74" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">不久前，我提出了<a class="ae ln" href="https://medium.com/swlh/functional-use-cases-f896f92e768f" rel="noopener">功能用例方法</a>，其中你有一个函数或类型别名，而不是用例的接口。</p><p id="b809" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e5c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为你没有接口但是有高阶函数，你想注入什么就注入什么；因此，用一个用例类替换一个存储库方法只是更新DI层的问题。</p><p id="f8b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总的来说，这是一个很好的方法，因为它消除了样板文件，但考虑到大多数Android项目都受到像Koin和Dagger这样的DI框架的严重影响，这些框架需要类型才能工作，这种方法给DI层带来了额外的复杂性。</p><p id="a9d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Dagger中，如果你有多个<code class="fe nu nv nw nx b">suspend () -&gt; Answer&lt;List&lt;SomeModel&gt;, String&gt;</code>，你将无法执行以下操作:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="6617" class="mn lp iq nx b gy oc od l oe of">@Provides<br/>@Singleton<br/>fun provideGetSomeModelUseCase(<br/>    someModelRepository: SomeModelRepository<br/>): GetSomeModelUseCase {<br/>    return someModelRepository::getSomeModels<br/>}</span></pre><p id="4ec5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">除非对于每一个具体的函数，你都不加难看的<code class="fe nu nv nw nx b">@Named</code> hack。</p><p id="5815" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Koin中，您将无法执行以下操作:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="243f" class="mn lp iq nx b gy oc od l oe of">single&lt;GetSomeModelUseCase&gt; {<br/>    get&lt;SomeModelRepository&gt;()::getSomeModels<br/>}</span></pre><h2 id="9ff0" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">赞成的意见</h2><ol class=""><li id="3b4c" class="mz na iq kt b ku mg kx mh la nb le nc li nd lm ne nf ng nh bi translated">编写的代码更少。</li><li id="0de8" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">没有冗余:对存储库方法的改变不需要用例的改变。</li><li id="b13e" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">一致性。</li><li id="9b63" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">可伸缩性:如果存储库方法需要不是来自表示层的额外参数，所有使用用例的虚拟机都不需要更新，因为它们受到用例接口的保护。</li><li id="60f2" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">ISP遵守情况。</li></ol><h2 id="b030" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">骗局</h2><ol class=""><li id="492a" class="mz na iq kt b ku mg kx mh la nb le nc li nd lm ne nf ng nh bi translated">不适用于DI框架</li></ol><p id="38c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是当时我能想到的最好的方法，正如霍华德·史塔克曾经说过的:</p><blockquote class="og"><p id="fe68" class="oh oi iq bd oj ok ol om on oo op lm dk translated">“我受限于我那个时代的技术，但总有一天你会明白的。当你做到了，你将改变世界。现在和将来都是我最伟大的创造……就是你。”</p></blockquote><h1 id="453a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw oq jx ma jz or ka mc kc os kd me mf bi translated">[最终]方法4:具有功能接口的功能用例</h1><p id="476e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">几年后，JetBrains回应了我的祈祷，推出了<a class="ae ln" href="https://kotlinlang.org/docs/fun-interfaces.html" rel="noopener ugc nofollow" target="_blank">功能接口(SAM) </a>。</p><p id="9d15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于这个Kotlin更新，函数可以作为函数接口注入，不像类型别名，是“真正的类型”</p><p id="623e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="30c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">匕首提供了一个可以这样固定的功能:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="3eec" class="mn lp iq nx b gy oc od l oe of">@Provides<br/>@Singleton<br/>fun provideGetSomeModelUseCase(<br/>    someModelRepository: SomeModelRepository<br/>): GetSomeModelUseCase {<br/>    return GetSomeModelUseCase(someModelRepository::getSomeModels)<br/>}</span></pre><p id="6bd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">锦鲤也提供功能:</p><pre class="kg kh ki kj gt ny nx nz oa aw ob bi"><span id="f82e" class="mn lp iq nx b gy oc od l oe of">single&lt;GetSomeModelUseCase&gt; {<br/>    GetSomeModelUseCase(get&lt;SomeModelRepository&gt;()::getSomeModels)<br/>}</span></pre><h2 id="dfaa" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">赞成的意见</h2><ol class=""><li id="beee" class="mz na iq kt b ku mg kx mh la nb le nc li nd lm ne nf ng nh bi translated">编写的代码更少。</li><li id="b131" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">没有冗余:对存储库方法的改变不需要用例的改变。</li><li id="69af" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">一致性。</li><li id="6af1" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">可伸缩性:如果存储库方法需要不是来自表示层的额外参数，所有使用用例的虚拟机都不需要更新，因为它们受到用例接口的保护。</li><li id="0cab" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">ISP遵守情况。</li><li id="fea7" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">与所有DI框架配合良好</li></ol><h2 id="d7d7" class="mn lp iq bd lq mo mp dn lu mq mr dp ly la ms mt ma le mu mv mc li mw mx me my bi translated">反对意见:不适用</h2><p id="a2b1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们终于有了一个没有缺点的解决方案。</p><h1 id="cdfb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">摘要</h1><p id="c930" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">用例是干净架构的关键部分，开发人员总是对它们又爱又恨。</p><p id="01be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望通过应用这个解决方案，你会更爱他们。</p></div></div>    
</body>
</html>