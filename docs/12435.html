<html>
<head>
<title>Gitlab CI for Node Testing and Coverage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于节点测试和覆盖的Gitlab CI</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/gitlab-ci-for-node-testing-and-coverage-d8f8c82f8c1e?source=collection_archive---------7-----------------------#2022-06-06">https://betterprogramming.pub/gitlab-ci-for-node-testing-and-coverage-d8f8c82f8c1e?source=collection_archive---------7-----------------------#2022-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f02" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Nodejs的Gitlab CI v15.0特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8aa8d2508444cf550c02889ad6a1db41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rX050J7TAy3HREr3"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@frostroomhead" rel="noopener ugc nofollow" target="_blank"> Rodion Kutsaev </a>在<a class="ae kv" href="https://unsplash.com/photos/xNdPWGJ6UCQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="7e5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Gitlab是一个流行的开源版本控制系统，可以免费使用，并可以构建在内部网中，Gitlab有许多有用的功能，如Gitlab CI。</p><p id="b3c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Gitlab长期以来一直将CI/CD管道集成到Gitlab中，并演化出了所谓的<a class="ae kv" href="https://docs.gitlab.com/ee/topics/gitlab_flow.html" rel="noopener ugc nofollow" target="_blank"> Gitlab流程</a>。在本文中，我不会浏览整个Gitlab CI指南，也不会解释CI/CD的概念，而是将重点放在如何使节点测试报告更具代表性。</p><p id="a282" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么是这个话题？主要原因是我们经常一起使用<code class="fe ls lt lu lv b">nyc</code>和<code class="fe ls lt lu lv b">mocha</code>来构建Node的测试报告，但是这样的组合需要一点小小的改动，以便适应Gitlab的丰富功能。这篇文章就是关于这些方法的，并将使用一个真实的<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>作为例子。</p><blockquote class="lw lx ly"><p id="34a9" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated"><em class="iq">请注意，本文是基于Gitlab v15.0 </em>编写的</p></blockquote><h1 id="cb21" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">测试报告</h1><p id="e213" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在一份好的测试报告中，我们需要几个重要的特征。</p><ol class=""><li id="8aa5" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated">完整报告的人工制品。</li><li id="ae6a" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">每个<em class="lz">拉取请求</em>或<em class="lz">合并请求</em>的测试总结。</li><li id="d7f4" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">每个<em class="lz">拉取请求</em>或<em class="lz">合并请求</em>的变更覆盖范围。</li><li id="b3c4" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated">整个管道的状态，包括最近的成功或失败及其覆盖范围，最好是徽章的形式。</li></ol><h1 id="7493" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">报告工件</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/e498f079bf4d4661ce28bb9bfb5f09aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*zQGFgwZT3Hsd5mDq.png"/></div></figure><p id="3720" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最新的管道报告，为了能够在这里下载，我们需要添加一个新的<code class="fe ls lt lu lv b">artifacts</code>字段来指定我们希望在所需阶段导出的路径。例如，在上图中，设置如下。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="dcde" class="nt me iq lv b gy nu nv l nw nx">test_ci:<br/>  script:<br/>    - npm run test<br/>  artifacts:<br/>    paths:<br/>      - coverage/</span></pre><p id="08dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们将把<code class="fe ls lt lu lv b">coverage</code>文件夹下的所有东西打包导出。</p><h1 id="44a3" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">测试总结</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/4bef21d6295f09d9212cf5568021257d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MhOZvjqVgGGe4Skr.png"/></div></div></figure><p id="96aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在<em class="lz"> Merge Request </em>中显示一个测试的结果，包括测试了多少个用例，多少个成功或者失败，甚至为了查看每个用例用了多长时间，你需要让Gitlab知道测试报告的格式，并以相应的格式产生结果。</p><p id="00ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们继续延伸上面的<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>例子。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="3903" class="nt me iq lv b gy nu nv l nw nx">test_ci:<br/>  script:<br/>    - npm run test<br/>  artifacts:<br/>    paths:<br/>      - coverage/<br/>    reports:<br/>      junit:<br/>        - test-results.xml</span></pre><p id="1362" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我们使用JUnit格式创建测试报告，并将CI报告的路径通知Gitlab。这样，Gitlab就有能力在每个<em class="lz">合并请求</em>中呈现正确的报告内容和摘要。</p><h1 id="5f34" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><a class="ae kv" href="https://docs.gitlab.com/ee/user/project/merge_requests/test_coverage_visualization.html" rel="noopener ugc nofollow" target="_blank">更改覆盖范围</a></h1><p id="7b6c" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在进行代码评审时，我们都点击进入<em class="lz">变更</em>来看看哪些部分被变更了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/26dd1b231e67a52a8b4210f2ddcf9039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fbRPSpLv0dsZUkWv.png"/></div></div></figure><p id="6d02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于评审者来说，在一个地方看到变更的测试覆盖率会更有效率。所以，我们想让评审者容易知道哪些代码没有被测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fbebef94afeebc7fdf097b1e83d88c5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/0*aSHkT7J0mEQ3xjZ-.png"/></div></figure><p id="f0b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这张图中，我们一眼就能看出14号线没有被测试覆盖，而其他线都在测试中。值得一提的是，即使有测试覆盖，也不代表测试就完成了，比如这里就无法确定边界测试的条件，我们还得依靠评审人员的经验。</p><p id="ba99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们继续扩展原来的设置。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="8869" class="nt me iq lv b gy nu nv l nw nx">test_ci:<br/>  script:<br/>    - npm run test<br/>  artifacts:<br/>    paths:<br/>      - coverage/<br/>    reports:<br/>      junit:<br/>        - test-results.xml<br/>      coverage_report:<br/>        coverage_format: cobertura<br/>        path: coverage/cobertura-coverage.xml</span></pre><h1 id="b4d7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><a class="ae kv" href="https://gitlab.svc.langlive.tech/help/ci/yaml/index#coverage" rel="noopener ugc nofollow" target="_blank">管道徽章</a></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/2586bf57d01b27ea951eba9f21912139.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*WSekN_7jQQonrbiD.png"/></div></figure><p id="21d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在现在流行的开源项目中，用户在<code class="fe ls lt lu lv b">README.md</code>开头就被告知项目的健康状况，这是对用户有用的信息，也是开发者了解项目健康状况的快捷方式。</p><p id="e4fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您看到管道的状态为失败，那么一定有问题。另一方面，覆盖率徽章是项目测试覆盖率是否完整的一个很好的指示器。</p><p id="fe98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，徽章是Gitlab的内置功能。你可以在Gitlab设置中找到徽章的位置。</p><blockquote class="lw lx ly"><p id="f039" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated"><em class="iq">设置&gt; CI/CD &gt;综合管线</em></p></blockquote><p id="5a69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种类型的徽章，<em class="lz">管道状态</em>、<em class="lz">覆盖报告</em>和<em class="lz">最新发布</em>。你可以挑选你想要的。</p><p id="14e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从Gitlab v15.0开始，我们可以在<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>的<strong class="ky ir"> re2语法</strong>中指定一个正则表达式来标识覆盖率数字。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="15de" class="nt me iq lv b gy nu nv l nw nx">test_ci:<br/>  script:<br/>    - npm run test<br/>  coverage: '/All files\s+\|\s+\d+\.\d+/'</span></pre><p id="6553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<strong class="ky ir"> re2语法</strong>的规则是找到跟在<code class="fe ls lt lu lv b">All files</code>后面的浮点数作为覆盖率。如果您没有使用<code class="fe ls lt lu lv b">nyc</code>，您必须根据内容调整规则。</p><h1 id="1d6a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">详情请见<code class="fe ls lt lu lv b">package.json</code></h1><p id="df78" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">上面的例子已经完全实现了开发的必要特性。但是我们还没有解释如何同时生成覆盖率报告、JUnit报告和变更覆盖率。</p><p id="b36a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一切的关键就在<code class="fe ls lt lu lv b">npm run test</code>，也就是<code class="fe ls lt lu lv b">package.json</code>。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="0e6b" class="nt me iq lv b gy nu nv l nw nx">{<br/>  "script": {<br/>    "test": "nyc --reporter=html --reporter=text --reporter=cobertura mocha"<br/>  }<br/>}</span></pre><p id="2bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的设置中我们可以看到，这个busy <code class="fe ls lt lu lv b">nyc</code>负责为三种不同的特性产生三种类型的输出。</p><ul class=""><li id="1863" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr oc ng nh ni bi translated">html:作为整个项目的覆盖报告，将在下载工件时使用。</li><li id="b3a8" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr oc ng nh ni bi translated">text:生成徽章需要控制台输出。</li><li id="8086" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr oc ng nh ni bi translated">cobertura:正如我们从上一节中所知道的，变更覆盖率是使用<code class="fe ls lt lu lv b">cobertura</code>格式来表示的。</li></ul><p id="6c84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等，少了一个？谁为JUnit创建报告？答案是<code class="fe ls lt lu lv b">mocha</code>。但是这不是<code class="fe ls lt lu lv b">mocha</code>的内置特性，所以我们必须使用一个额外的工具来完成。</p><p id="3d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，下载<code class="fe ls lt lu lv b">mocha-junit-reporter</code>包。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="c801" class="nt me iq lv b gy nu nv l nw nx">npm i mocha-junit-reporter — save-dev</span></pre><p id="c06e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，创建<code class="fe ls lt lu lv b">mocha</code>配置文件<code class="fe ls lt lu lv b">.mocharc.js</code>。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="994b" class="nt me iq lv b gy nu nv l nw nx">module.exports = {<br/>  reporter: "./junit-spec-reporter.js"<br/>};</span></pre><p id="dd8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在配置文件中，我们告诉<code class="fe ls lt lu lv b">mocha</code>通过另一个文件生成报告，这个文件也是JUnit生成器。</p><p id="18d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是<code class="fe ls lt lu lv b">junit-spec-reporter.js</code>的内容。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="f3de" class="nt me iq lv b gy nu nv l nw nx">const mocha = require("mocha");<br/>const JUnit = require("mocha-junit-reporter");<br/>const Spec = mocha.reporters.Spec;<br/>const Base = mocha.reporters.Base;</span><span id="7c64" class="nt me iq lv b gy od nv l nw nx">function JunitSpecReporter(runner, options) {<br/>  Base.call(this, runner, options);<br/>  this._junitReporter = new JUnit(runner, options);<br/>  this._specReporter = new Spec(runner, options);<br/>  return this;<br/>}<br/>JunitSpecReporter.prototype.__proto__ = Base.prototype;</span><span id="9bca" class="nt me iq lv b gy od nv l nw nx">module.exports = JunitSpecReporter;</span></pre><p id="cfa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们需要的所有格式都可以正确生成，Gitlab CI将基于这些输出呈现丰富的视图，开发人员可以在Gitlab的网页上完成大部分日常工作，而无需在本地实际构建输出。</p><h1 id="9eef" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="f668" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">CI/CD是非常重要的软件开发实践。然而，为了让每个开发人员都有兴趣甚至信心去“继续”实践，人们必须能够“看到”变化。</p><p id="46f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于工程师来说，眼见为实是我们大多数人的信仰。因此，这些丰富的特性对于管道足够有效是必不可少的。</p><p id="db87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的<code class="fe ls lt lu lv b">.gitlab-ci.yml</code>，包括所有提到的功能，如下所示。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="cb1e" class="nt me iq lv b gy nu nv l nw nx">test_ci:<br/>  script:<br/>    - npm run test<br/>  artifacts:<br/>    paths:<br/>      - coverage/<br/>    reports:<br/>      junit:<br/>        - test-results.xml<br/>      coverage_report:<br/>        coverage_format: cobertura<br/>        path: coverage/cobertura-coverage.xml<br/>  coverage: '/All files\s+\|\s+\d+\.\d+/'</span></pre><p id="0080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以我的经验来看，当一个测试平台搭建完成后，并不是所有人都乐于使用它，毕竟编写测试是额外的工作。但是当平台足够丰富的时候，大部分人都会愿意尝试。</p><p id="876d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个刚刚开始建立开发过程的团队来说，让人们愿意尝试比什么都重要。</p><p id="4f3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以本文重点介绍Gitlab CI，从不同的角度介绍CI在开发过程中的作用。</p></div></div>    
</body>
</html>