<html>
<head>
<title>A “generic” Swift Interview Problem: Filter an Array of Generic Items</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个“通用”的快速面试问题:过滤一系列通用项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-generic-swift-problem-array-of-generic-items-555a0f5d827?source=collection_archive---------9-----------------------#2022-06-08">https://betterprogramming.pub/a-generic-swift-problem-array-of-generic-items-555a0f5d827?source=collection_archive---------9-----------------------#2022-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1585" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">根据我最近的编码采访</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/06ef6257bc135b37e708a07437ec6c1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-kAIqXgRJ5GXRMxaw3ZNg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">今天早上我的花园里长了一朵美丽的苔藓</p></figure><p id="14b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Generic是Swift中一个强大的概念，它为数据结构提供了灵活性，能够在不同的数据类型上执行。然而，它非常依赖编译器推断底层类型的能力。在这篇文章中，我将讨论一个使用泛型的场景。</p><p id="9ac4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近在一次编码面试中，我遇到了如下问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="1a6f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有2种(或更多)过滤器类型都符合相同的协议<code class="fe lt lu lv lw b">Filter</code>。</p><p id="5366" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在每个具体对象中，它可以有多个特定于类型本身的不同参数，这些参数不能从接口访问。</p><p id="b69f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，这些参数看起来具有相同的类型(例如:<code class="fe lt lu lv lw b">Float</code>)，尽管这并不总是正确的。这意味着从更广泛的角度来看，我们可以考虑一个通用的解决方案来更新每个滤波器的值。</p><p id="05de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>假设上述代码来自第三方库，这意味着不建议(允许)我们修改它。接受现实，继续前进。</p><p id="dbf2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来讨论这个问题。</p><p id="de37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们在应用程序中有一个切换器，用户可以在<code class="fe lt lu lv lw b">FilterA</code>和<code class="fe lt lu lv lw b">FilterB</code>之间切换，并调整相应的值。</p><p id="faec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果是<code class="fe lt lu lv lw b">FilterA</code>，UI显示1个滑块来调整<code class="fe lt lu lv lw b">param</code>的值。另外，有两个滑块分别用于“T6”和“T7”。</p><p id="130d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果引入更多的过滤器，我们希望编写能够轻松伸缩的智能整洁的代码。类似于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="275c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后这(可能)发生在函数内部:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f48e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这显然是不可扩展的。对于现有<code class="fe lt lu lv lw b">Filter</code>中的每个新过滤器或新参数，以重复的方式添加更多代码。</p><p id="93c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为不可能修改<code class="fe lt lu lv lw b">FilterA</code>和<code class="fe lt lu lv lw b">FilterB</code>，一个新的包装器来拯救我们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="e2eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在使用包装器是可行的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f847" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当我们创建一个新的filter实例(<code class="fe lt lu lv lw b">FilterManager</code>)时，我们可以传入底层的filter，以及一个带有闭包的参数列表，告诉它们在收到更新时做什么。</p><p id="d586" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不再有if-else或switch-case。然而，泛型的问题出现在最后。</p><p id="693e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编译器能够推断每个对象的具体类型，直到最后一行出现编译错误。</p><blockquote class="lx ly lz"><p id="847c" class="kv kw ma kx b ky kz jr la lb lc ju ld mb lf lg lh mc lj lk ll md ln lo lp lq ij bi translated">异类集合文本只能推断为“[Any]”；如果有意这样做，请添加显式类型批注</p></blockquote><p id="ce6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是什么意思？<code class="fe lt lu lv lw b">filterA</code>和<code class="fe lt lu lv lw b">filterB</code>不都是<code class="fe lt lu lv lw b">FilterManager</code>类型的吗？</p><p id="17de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是对泛型类型的一个常见误解。事实上，<code class="fe lt lu lv lw b">filterA</code>的型号是<code class="fe lt lu lv lw b">FilterManager&lt;FilterA&gt;</code>，而<code class="fe lt lu lv lw b">filterB</code>是<code class="fe lt lu lv lw b">FilterManager&lt;FilterB&gt;</code>。</p><p id="43f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基础类型是编译器决定泛型对象实际类型的关键。在这种情况下，我们的过滤器有不同的类型，容器数组只能推断到最高的共同祖先是<code class="fe lt lu lv lw b">[Any]</code>。</p><p id="36e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然而，我们可以为这两个实例手动定义一个公共类型，并公开我们需要的基本属性和功能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="2875" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在可以创建一个包含<code class="fe lt lu lv lw b">filterA</code>和<code class="fe lt lu lv lw b">filterB</code>的数组了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="031c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个问题的要点是，人们经常假设泛型类型的实例具有相同的类型。但是，如果基础类型不同，情况就不一样了。</p><p id="1971" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">编码快乐！</p><p id="cf7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">旁注:</strong>在写这篇文章的时候，我在想一个更好的解决方案，也许是用<code class="fe lt lu lv lw b">associatedtype</code>或者别的什么。我很高兴如果任何人有其他解决这个问题的方法，可以在评论区发布。</p></div></div>    
</body>
</html>