# 我们测量汽车、电脑和手机的功率。但是代码呢？

> 原文：<https://betterprogramming.pub/we-measure-the-power-of-cars-computers-and-cellphones-but-what-about-code-91ed5583f298>

## 深入了解 Golang 的基准测试

![](img/d32c47eaf87c93e7b62d6e00e4a34c91.png)

托马斯·凯利在 [Unsplash](https://unsplash.com/?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

我不想撒谎——基准测试是*而不是*我最大的优势之一。我没有像我希望的那样经常做这件事。但是自从我开始使用 Go 作为我的首选语言后，它变得越来越频繁了。其中一个原因是因为 Go 对基准测试有很好的内置支持。

Go 让我们开发人员使用测试包进行基准测试。因此，测试包附带了基准测试功能。太棒了。

在本文中，我想更深入地研究基准测试，但是我将从头开始。读完这篇文章后，我希望我已经让您对基准测试有了更好的理解。

让我们开始谈论基准测试。软件开发中的基准测试是关于测试我们编写的代码的性能。

> **基准**是运行[计算机程序](https://en.wikipedia.org/wiki/Computer_program)、一组程序或其他操作的行为，以便评估对象的相对**性能**。—维基百科

基准测试允许我们采用不同的解决方案并测试它们的性能，比较测得的速度。作为开发人员，这是非常重要的知识，尤其是当您有一个需要加速和优化的应用程序时。

记住开发中的一条黄金法则很重要:永远不要过早地优化。仅仅因为我们将学习如何进行基准测试，并不意味着我建议运行和基准测试你拥有的每一段代码。我强烈地感觉到，当你面临性能问题或者纯粹的好奇心正在杀死你的时候，基准测试是一个可以使用的工具。

> "过早优化是万恶之源."
> 
> —唐纳德·e·克努特，“计算机编程的艺术”

在互联网上看到初级开发人员关于不同代码解决方案的帖子并不罕见，他们会问哪一个是最好的。但是当谈论代码时，说某事是最好的，这是我不愿意做的事情。

让我们坚持使用最高性能的表达方式，因为有时较慢的代码更容易维护和阅读。因此，如果你问我，那段代码更好，当然，除非你面临性能问题。

让我们开始学习如何使用 Go 进行基准测试。我从一个初级开发人员那里收集了一些我无法回答的关于性能的问题。

我们会帮他看看的。

*   切片还是贴图更快？
*   切片和贴图的速度受大小影响吗？
*   地图中使用的键类型重要吗？

# 编写一个超级简单的基准

在解决这些问题之前，我将首先构建一个简单的基准，并展示如何用 Go 完成基准测试。在我们知道如何做到这一点之后，让我们进化它来解开所需的答案。

我为这些基准创建了一个新项目，我建议您也这样做，这样您就可以自己尝试了。您需要创建一个目录并运行:

```
go mod init benching
```

您还需要创建一个以`_test.go`结尾的文件。我的情况是`benching_test.go`。

Go 中的基准测试是通过测试包完成的，非常像常规的单元测试。就像单元测试一样，基准测试是由相同的 Go 测试工具触发的。

Go 工具将根据方法的名称知道哪些方法是基准。任何以`Benchmark`开始并接受指向`testing.B`的指针的方法都将作为基准运行。

要点显示了最低基准方法的样子

通过运行带有`-bench=.`标志的`go test`命令来尝试一下。

![](img/1a55f14d35360435c8c1a72401b04e64.png)

通过运行“go test -bench=”。看到输出，我们知道基准测试是有效的

让我们在这里停一会儿，反思一下输出。执行的每个基准将输出三个值:名称、基准运行的次数和`ns/op`。

这个名字不言自明。这是我们在测试文件中设置的名称。

基准测试的执行次数很有趣。每个基准测试都要执行多次，并且每次执行都要计时。然后根据运行次数计算执行时间的平均值。这很好，因为运行一次基准测试会提供很差的统计正确性。

`ns/op`代表纳秒/操作。这是方法调用花费的时间。

如果您有多个基准，并且只想运行一个或几个，那么您可以用字符串替换点，匹配类似`-bench=BenchmarkSimplest`的名称。记住说`-bench=Benchmark`仍然会触发我们的基准，因为字符串匹配方法的开始。

![](img/4d6155c2ead4ade7832a527f24ad1491.png)

替换'-bench= '值可以用来指定要运行的基准

因此，现在我们可以对速度进行基准测试，但这可能并不总是我们想要测量的一切。令人欣慰的是，如果我们看一看[测试包](https://golang.org/pkg/testing/)，我们可以发现添加`-benchmem`标志将添加关于每操作分配的字节(B/op)和每操作分配(allocs/op)的信息。

如果你不熟悉分配和内存，我可以推荐一篇文森特·布兰奇的文章。

![](img/c5a66ee47a308f2efe30e3635ba8b7c6.png)

添加'-benchmem '标志会添加 B/op 和 allocs/op

我们很快就准备好开始对真实事物进行基准测试——请再耐心等我一会儿。我们的基准测试中的输入参数`*testing.B`有什么问题？让我们看看标准库中对它的定义，以了解我们在处理什么。

测试。标准库(golang/src/testing/benchmark . go)中的定义

`Testing.B`是一个保存与运行基准相关的任何数据的结构。它还包含一个名为`BenchmarkResult`的结构，用于格式化输出。如果输出中有你不完全理解的地方，我强烈建议打开`benchmark.go`阅读代码。

需要注意的一件重要事情是`N`变量。还记得基准测试是如何被多次执行的吗？基准测试执行的次数由`testing.B`中的`N`变量指定。

根据[文档](https://golang.org/pkg/testing/)，这需要在基准中考虑，所以让我们更新`BenchmarkSimplest`来考虑`N`。

将精确运行 N 次的基准测试

我们通过制作一个`for`循环来更新它，这个循环将迭代`N`次。当我进行基准测试时，我喜欢将`N`设置为特定的值，所以我确保我的基准测试是公平的。否则，一个基准可能运行 100，000 次，另一个可能运行两次。

这可以通过添加`-benchtime=`标志来完成。输入要么是秒，要么是 X 次，所以要强制基准执行 100 次，我们可以将其设置为`-benchtime=100x`。

![](img/e40ce40b8c34a9e8fee0e4a9bd6aae37.png)

测试新方法 100 次

# 准备，设置，基准！

是时候开始测试和回答之前关于性能的问题了。

*   切片还是贴图更快？
*   切片和贴图的速度受大小影响吗？
*   使用的密钥重要吗？

我将开始实现一个将数据插入地图和切片的基准，然后实现另一个读取数据的基准。我从[戴夫·切尼](https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go)那里偷来的一个技巧是创建一个方法，它接受我们想要进行基准测试的输入参数——这使得对许多不同的价值进行基准测试变得非常容易。

取 X 量并将 X 插入到地图中的方法

该方法将接受一个整数值，该值表示要插入到映射中的整数数量。这样我们就可以测试地图的大小是否会影响插入性能。这个方法将由我们的基准来执行。我还将创建多个基准函数，每个函数插入一个不同的整数进行基准测试。

运行 N 次并将 X 项插入地图的基准方法

看到我如何在每个基准测试中重用相同的方法，但只是修改插入次数了吗？这是一个巧妙的技巧，因为我们可以很容易地测试大量和少量。

![](img/49da5524060887c6f47e2aac9678c035.png)

插入到地图中的基准结果

所以时间增加了——这是意料之中的，因为我们增加了插入的次数。这并没有告诉我们太多，因为我们需要一些东西来比较结果。不过，我们可以花时间来回答一个问题:地图中使用的键类型重要吗？

我将复制所有的方法，并用一个接口替换使用的键类型。为了使事情更简单，我现在有两个文件，`benching_map_interface_test.go`和`benching_map_int_test.go`。基准方法将与名称相关联——这只是为了在我们添加更多基准时保持一个易于导航的结构。

使用接口作为键将基准插入到地图中

![](img/6a11c9cc2208299c5eee40e3ec969b76.png)

基准测试结果表明，键类型确实很重要

我想我们至少找到了一个问题的答案。从结果中我们可以看出，键的类型似乎很重要。考虑到`1000000`基准测试，在该基准测试中使用“Int”而不是`Interface`作为键要快 2.23 倍。但是，我想我以前从来没有见过一个接口被当作一个键使用。

基于键的性能翻倍似乎符合我从 Jason Moiron[那里读到的一个结论。他写了《](https://medium.com/u/776ac72010e0?source=post_page-----91ed5583f298--------------------------------)[围棋表演故事集》、](http://jmoiron.net/blog/go-performance-tales/)很值得一读。

*   切片还是贴图更快？
*   切片和贴图的速度受大小影响吗？
*   d̸o̸e̸s̸̸t̸h̸e̸̸ke̸y̸̸t̸y̸p̸e̸̸u̸s̸e̸d̸̸i̸n̸̸m̸a̸p̸s̸̸m̸a̸t̸t̸e̸r̸？是的，确实如此。

在我们继续之前，我想花点时间添加一个新的基准，因为它很有趣。在我们刚才运行的基准测试中，地图没有预先分配大小。因此，我们可以改变这一点，并对差异进行基准测试。

我们要改变的是`insertXIntMap`方法，我们也要改变 map 的初始化，改为使用 X 的长度。我已经创建了一个新文件，`benching_map_prealloc_int_test.go`，在这个文件中，我已经修改了`insertXIntMap`方法来预先初始化大小。

我将“make(map[int]int，0)”改为“make(map[int]int，x)”

还记得我说过我们可以使用`-bench=`标志来控制运行什么样的基准吗？是时候使用这个技巧了，因为现在我们有了许多基准。但是对于这个特定的基准，我只对比较没有设置大小的地图和有预分配大小的地图感兴趣。

我将我的新基准命名为`BenchmarkInsertIntMapPrealloc`，因此它们与 B `enchmarkInsertIntMap`同名。我们可以以此为契机。这个新的基准文件是另一个`IntMap`基准的精确副本——我只改变了名称和运行方法。

让我们运行基准测试并更改基准标志。

```
go test -bench=BenchmarkInsertIntMap -benchmem -benchtime=100x
```

![](img/dcbc7fe0ffd0e59db7dd3ae228653090.png)

地图中预分配大小之间的差异

这个基准向我们展示了设置地图的大小有相当大的影响。当你看到`1000000`测试有 1.92 倍的性能差异时，事实的确如此。看看分配的字节数(B/op) —好得多。

让我们继续实现切片的插入基准。这将是 map 实现的一个副本，但是这次使用了一个带有`append`的切片。

我还将创建预分配片的基准和未分配大小的基准，因为这很有趣。我们可以重新创建`insertX`方法，复制粘贴所有内容，然后搜索`Map`并用`Slice`替换它。

插入到切片中 X 次，用于基准切片中的插入。

切片附加的基准

对于预分配的片，我们不想使用`append`,因为这会给片增加一个索引。因此，必须更改预分配的索引，以使用正确的索引。

使用正确的索引插入值，而不是“追加”

预分配切片大小基准测试的完整代码

现在我们已经完成了切片基准测试，让我们运行它们并查看结果。

![](img/7c27ab6d743c45a8dcf9b8a587b3e33a.png)

这张图展示了使用切片代替的基准

预分配切片和动态切片之间的差异是巨大的。基准测试是`75388 ns/op`对`7246 ns/op`。这是 10.4 倍速度的性能差异。不过，在某些情况下，使用固定大小的切片可能会很麻烦。我通常不知道我的应用程序的大小，因为它们往往是动态的。

在插入数据时，切片似乎优于地图——在小数字和大数字上。我们还需要测试选择数据的性能。

为了对此进行基准测试，我们将像刚才一样初始化一个切片和映射，添加`X`数量的项目，然后重置计时器。然后我们将开始衡量我们能多快找到`X`物品。我决定使用索引值`i`迭代切片和地图。我将在下面发布两个基准测试的代码——它们几乎是相同的。

从地图中选择的基准

测试切片中选择的基准

![](img/bff800805d32d7f7a3431c3a88376dc5.png)

比较地图和切片的基准结果

如果你注意到了，那么`selectXIntSlice`和`selectXIntMap`的代码是相同的——唯一的区别是`make`命令。不过，这两者的性能差异非常明显。

# 比较基准测试结果

因此，我们现在有了基准数据—让我们将它们汇编成一个表格，以便于查看。

包含 1000000 个项目的所有基准的基准测试结果摘要

那么切片和地图有多大区别呢？

**在比较写入动态大小的性能时，切片快了 21.65 倍** (1321196/75388)。

**在比较写入预分配大小的性能时，切片快了 118.35 倍** (857588/7246)。

**在比较读取的性能时，切片快了 177.19 倍** (507843/2866)。

## **切片快还是贴图快？**

使用这些基准测试，Slices 的表现似乎远远优于 maps。差异如此之大，我想我一定是搞砸了这些基准。

然而，地图更容易使用。在这些基准测试中，我们假设我们知道切片中要使用的索引。我能想到很多情况，我们不知道索引，可能不得不迭代整个切片，就像在`[]User`上用`map[userID]User`代替`for`循环。

## **切片和贴图的速度受尺寸影响吗？**

在这些情况下，大小似乎并不重要。

## **地图中使用的按键类型重要吗**？

是的，确实如此。使用整数证明比接口快 2.23 倍。

# 添加更真实的用例

所以切片看起来更有性能，但是我要说实话——我几乎不知道切片的正确索引。大多数时候，我不得不迭代整个切片来找到我要搜索的内容。这是我经常用地图代替的主要原因。

我将用这个用例创建一个基准。我们会有一个`map[userID]User`和一个`[]User`。基准测试将是一场寻找特定用户的竞赛。

我创建了一个新文件，其中包含生成随机用户的代码。我将在切片和地图中生成 10，000，100，000 和 100 万用户。想象一下，如果我们有一个 API，用户 ID 被发送给我们，我们想要找到那个用户。这是我们将要测试的场景。我还将打乱切片，因为这模拟了一个动态添加数据的真实用例。

我称这个基准为“拯救大兵瑞恩”我们需要找到他，他有用户 ID `7777`。

切片和地图的更真实用例的基准

![](img/3b7fecbce664eeb8148bba4c8870a1d9.png)

在地图和切片中查找用户的基准测试结果

如您所见，切片不再优于地图。如果您查看结果，您会发现无论地图中有多少项目，地图都会保持相同的速度，而每添加一个项目，切片会花费更长的时间。

比较查找用户的性能的基准测试结果摘要

在这个用例中，地图的性能更高，系数为 6678.53 x**(140917**/**21.1)。**

# **结论**

## ****切片还是贴图更快？****

**当谈到原始功率时，切片的性能更好，但不太复杂，也更难使用——正如我们的“拯救大兵瑞恩”基准测试所展示的那样。有时候权力不是一切。**

**我倾向于使用映射，因为它们提供了对存储值的简单访问。正如编程中的许多情况一样，这取决于您的用例。**

## ****切片和贴图的速度受尺寸影响吗？****

**令我难过的是，我妻子说尺寸确实很重要。我的基准也是这么说的。当使用正确的索引号时—当然，没关系。但是如果你不知道你的值存储在什么索引中，那么大小确实很重要。**

## ****地图中使用的键类型重要吗？****

**是的，确实如此。使用整数证明比接口快 2.23 倍。**

**今天就到这里，我希望你已经了解了一些关于基准测试的知识。我知道我肯定有。完整的代码可以在这里找到[。](https://github.com/percybolmer/benchmarking/)**

**不要忘记走出去，为世界树立标杆。**