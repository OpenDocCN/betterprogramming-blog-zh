<html>
<head>
<title>Exploring Rendering in SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索SwiftUI中的渲染</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-rendering-in-swiftui-ac7e88a2381d?source=collection_archive---------4-----------------------#2022-09-11">https://betterprogramming.pub/exploring-rendering-in-swiftui-ac7e88a2381d?source=collection_archive---------4-----------------------#2022-09-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="240a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解SwiftUI何时重新渲染子视图</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e6f6692816358d0b1ff8d0342b20c93d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rdZRffU4d9SuwKYF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sonance?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Viktor Forgacs </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="550f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件工程职业令人惊奇的一个方面是你永远不会停止学习。你每天都接触到不同的技术:学习它们的基本概念是我个人最喜欢的事情之一。</p><p id="23ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">学习新技术最重要的技能之一是识别模式和相似性的能力。这让你即使不是每天都使用一项新技术，也可以对它进行推理。</p><p id="70af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一周前，我的一个同事给我发了这篇关于React渲染的文章。我并不是每天都使用React，但是我熟悉它的基本概念，我不知道它和SwiftUI有多相似。在阅读这篇文章时，我惊讶地发现，当组件的<em class="lv">状态</em>改变时，React会重新渲染，而不是当它的<em class="lv">道具</em>改变时。</p><p id="96e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，我的好奇心被激起了:SwiftUI是做什么的？什么时候重新渲染它的组件？我创建了一个小项目来尝试和理解这一点，今天我想分享我的过程和我的发现。</p><h1 id="60b9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">重新创建应用程序</h1><p id="82c7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我采取的第一步是再现文章中出现的相同情况。我用相同的初始组件创建了一个新的SwiftUI项目:</p><ul class=""><li id="fc8f" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><code class="fe nc nd ne nf b">BigCountNumber</code></li><li id="5706" class="mt mu it lb b lc ng lf nh li ni lm nj lq nk lu my mz na nb bi translated"><code class="fe nc nd ne nf b">Counter</code></li></ul><p id="04f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了简单起见，我将它们放在一个文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="abc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我将<code class="fe nc nd ne nf b">RenderingApp.swift</code>改为加载<code class="fe nc nd ne nf b">Counter</code>视图，而不是<code class="fe nc nd ne nf b">ContentView</code>，这样我就可以测试它了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="087d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在模拟器中运行应用程序，我可以看到每次我点击按钮时计数器都会增加。</p><h1 id="f548" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">可视化渲染</h1><p id="372b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">第二步是理解如何可视化组件何时被重绘。我发现了SwiftUI的<code class="fe nc nd ne nf b">View</code>协议的静态<code class="fe nc nd ne nf b">_printDebug()</code>函数:一个私有方法，可以用来在SwiftUI <code class="fe nc nd ne nf b">View</code>被渲染时对其进行调试。</p><blockquote class="nn no np"><p id="cb1e" class="kz la lv lb b lc ld ju le lf lg jx lh nq lj lk ll nr ln lo lp ns lr ls lt lu im bi translated">C <strong class="lb iu">注意:</strong>提交给Apple之前记得去掉这个函数调用。否则，你的应用将被自动拒绝:你不能在你的应用中使用私有系统API。</p></blockquote><p id="faf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的<code class="fe nc nd ne nf b">View</code>的体中引入函数调用的时候，我们还要加回<code class="fe nc nd ne nf b">return</code>语句:SwiftUI如果属性的体长于一条语句，就无法推断出你要返回什么。</p><p id="e7df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行应用程序，Xcode在控制台中打印了一些信息。应用程序启动时，Xcode会打印:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/0720ea85be9de72b0a4d9edeae885778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9OZqB8BZKo-beYtJo1TK5A.png"/></div></div></figure><p id="607d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且，在点击<code class="fe nc nd ne nf b">increment</code>按钮几次后，它打印出来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/1030fcea8b41eacf8de60d5aede69760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LRKLAcQQ7ADXf2EdiTjySA.png"/></div></div></figure><h1 id="3093" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">添加装饰</h1><p id="a5b9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">React和SwiftUI目前的行为方式是一样的。在该设置中，更改<code class="fe nc nd ne nf b">State</code>与更改相关组件的属性相同。</p><p id="895d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们按照参考文章的建议添加<code class="fe nc nd ne nf b">Decoration</code>组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cb84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了跟踪<code class="fe nc nd ne nf b">Decoration</code>何时被渲染，我将代码添加到了<code class="fe nc nd ne nf b">_printChanges</code>。让我们用<code class="fe nc nd ne nf b">Counter</code>组件来组合它，如本文所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="78f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行应用程序时，Xcode会打印以下输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/01fc0ef9f9d8daac2ddc99adefeea039.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*XWdXXIU8t_EFHtZLTaYkWg.gif"/></div></figure><p id="3105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以观察到<code class="fe nc nd ne nf b">Decoration</code>只出现了一次，而<code class="fe nc nd ne nf b">Counter</code>和<code class="fe nc nd ne nf b">BigCountNumber</code>在我们每次点击按钮时都会更新。</p><p id="c23f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下，SwiftUI的行为方式比React更保守:它避免了对那些<em class="lv">道具</em>没有改变的组件进行不必要的渲染。</p><h1 id="d8af" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">为什么？</h1><p id="67c4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我最好的解释是组件的类型语义。在SwiftUI中，我们创建的<code class="fe nc nd ne nf b">View</code>是<code class="fe nc nd ne nf b">struct</code>:默认情况下是不可变类型。这使得验证什么时候发生了变化，什么时候没有发生变化变得更加容易。</p><p id="fb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个<code class="fe nc nd ne nf b">View</code>的道具改变了，我们必须重新创建它:我们在<code class="fe nc nd ne nf b">View</code>的<code class="fe nc nd ne nf b">body</code>中使用的是创建<code class="fe nc nd ne nf b">View</code>的各种组件的初始化器。我们基本上是在告诉运行时:“看，我正在创建一个新视图。能画出来吗？”。</p><p id="1924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，React使用引用类型:类或函数组件。理解什么时候发生了变化要困难得多(也是昂贵的):组件不会不断地被重新创建。React必须决定何时再次调用<code class="fe nc nd ne nf b">render</code>函数(或定义组件本身的函数)。当一个<code class="fe nc nd ne nf b">class</code>的变量改变时——就像它的一个道具一样——这个类的内存地址不会改变。</p><p id="57ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React承诺提供最新版本的用户界面。为了实现这一点，它必须比SwiftUI更频繁地呈现其组件:每当状态改变时。</p><h1 id="a617" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="74ef" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在今天的文章中，我们探讨了React和SwiftUI之间的渲染差异。我们学习了如何使用<code class="fe nc nd ne nf b">_printChanges</code>私有函数来调试我们的渲染过程，并且我们创建了一个实验项目来测试它。</p><p id="fb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们了解到SwiftUI在属性改变时重绘组件，而不是像React那样在状态改变时重绘。这主要对结构的值语义是可能的。</p></div></div>    
</body>
</html>