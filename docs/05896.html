<html>
<head>
<title>How to Upgrade Your PostgreSQL Version Using Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Docker升级您的PostgreSQL版本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-upgrade-your-postgresql-version-using-docker-d1e81dbbbdf9?source=collection_archive---------3-----------------------#2020-08-17">https://betterprogramming.pub/how-to-upgrade-your-postgresql-version-using-docker-d1e81dbbbdf9?source=collection_archive---------3-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="224b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">升级您的PostgreSQL版本并使用Docker迁移您的数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c818f600c7e889ab24fc818d449dc173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SLpkz2ifr-kv-0FM"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="5c93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我不得不将我的本地<a class="ae kv" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>版本从10.10升级到11.8，以镜像生产环境中存在的相同版本。我原本认为升级会很简单:关闭容器，更新docker-compose服务以引用新版本，然后旋转容器。</p><p id="3e96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当容器上升时，一个错误开始在logs:‌出现</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/e22dd70474cf40eb4fd1f919412ac960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VnU7R0pK_Xm_Mdp2gXfjsQ.png"/></div></div></figure><p id="fff8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">错误非常明显:因为它是由早期版本创建的，所以我的数据与新版本不兼容。当我搜索这个问题的可能解决方案时，我只能找到与macOS相关的内容，并依赖于使用Brew来执行一些shell命令，这些命令将负责升级数据并使其与新版本兼容。</p><p id="e983" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是我用Docker做这个(好吧，所有和web相关的东西，真的)，既然用Linux Ubuntu，就不能用Brew(只针对macOS)。所以我需要一个快速、可靠的解决方案，并且(最好)利用Docker，这样我就不需要在我的本地机器上安装东西了。</p><p id="b736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经过大量的搜索和我自己的一些发现，我想出了以下简单的三步解决方案。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ef16" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">第一步:备份你当前的数据</h1><p id="3de6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在旧的PostgreSQL服务仍在运行的情况下，在docker-compose文件所在的目录中执行以下命令:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="34cc" class="nc mb iq my b gy nd ne l nf ng">docker-compose exec {service_name} pg_dumpall -U {postgres_user} &gt; dump.sql</span></pre><p id="9eca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令生成一个SQL文件，其中包含来自每个数据库、角色等的所有当前数据。稍后，当我们将它导入到新的PostgreSQL版本时，我们将使用它。</p><p id="a3ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在不依赖docker-compose文件配置的情况下完成这项工作，可以使用以下命令启动一个专用于该流程的容器:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ffef" class="nc mb iq my b gy nd ne l nf ng">docker run --rm -v ${CWD}:/tmp -v {local_postgres_data_folder}:/var/lib/postgresql/data -w /tmp {postgres_image}:{current_version_tag} pg_dumpall -U {postgres_user} &gt; dump.sql</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a02f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">步骤2:删除当前服务的映射卷</h1><p id="9e62" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们不能使用旧的数据结构，因为它与新版本的不兼容。除了删除我们的旧PostgreSQL服务使用的卷，我们没有其他选择，这样我们可以在以后更新版本标记，并让服务创建基本文件夹/文件，就像它是第一次干净运行一样。</p><p id="cc49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们找到该卷映射到的位置，打开一个终端，转到该位置，运行命令将其完全删除:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6170" class="nc mb iq my b gy nd ne l nf ng">sudo rm -rf {postgres_volume_directory}</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3335" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">步骤3:更新PostgreSQL版本</h1><p id="1ede" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">有了当前数据的备份，我们现在可以关闭旧的PostgreSQL服务容器，更新docker-compose配置以引用新的版本标记，并重新启动该服务。</p><p id="e1a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务启动完成后，它应该引用一个新卷，其中包含新版本支持的新创建的文件。我们只需要启动导入过程，这样我们的备份也可以被这个新版本使用。我们可以通过使用内部bash终端，用下面的命令来实现:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0b82" class="nc mb iq my b gy nd ne l nf ng"># Connect to the container's bash terminal<br/>docker-compose exec {service_name} bash</span><span id="dd61" class="nc mb iq my b gy nh ne l nf ng"># Now we run the import command<br/>psql -U {postgres_user} -d {default_postgres_database} &lt; {mapped_volume_folder_path}/dump.sql</span></pre><p id="ace8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ni">注意:只有在docker-compose文件的容器中映射了一个卷时，这个命令才有效。</em></p><p id="d469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您喜欢使用一次性命令来运行此导入，您可以使用:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="8d59" class="nc mb iq my b gy nd ne l nf ng">docker run --rm -v ${CWD}:/tmp -v {local_postgres_data_folder}:/var/lib/postgresql/data -w /tmp {postgres_image}:{new_version_tag} psql -U {postgres_user} -d {default_postgres_database}  &lt; dump.sql</span></pre><p id="0f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我们现在有一个新版本的PostgreSQL正在运行，我们保持所有的数据都与该版本兼容。</p></div></div>    
</body>
</html>