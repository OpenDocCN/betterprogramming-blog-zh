<html>
<head>
<title>Android RecyclerView With Kotlin Sealed Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin密封类的Android RecyclerView</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/android-recyclerview-with-kotlin-sealed-classes-6d2985aac3e5?source=collection_archive---------2-----------------------#2020-11-04">https://betterprogramming.pub/android-recyclerview-with-kotlin-sealed-classes-6d2985aac3e5?source=collection_archive---------2-----------------------#2020-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a87a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用密封类的RecyclerViews中的多种视图类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7a6737d63f75c3b3eca3c86cd6fec1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i5YvNlFZ1W6uvJq9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Stephen Frank 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d0f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Android中显示巨大列表的最好方式之一是通过<code class="fe lv lw lx ly b">RecyclerView</code>。作为开发人员，你们可能都用过它。我们有许多高级特性，如视图保持器模式、丰富的动画、提高性能的差异实用程序回调等。像WhatsApp和Gmail这样的应用程序使用<code class="fe lv lw lx ly b">RecyclerView</code>来显示无休止的对话。</p><p id="4fe2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用的一个重要的<code class="fe lv lw lx ly b">RecyclerView</code>特性是视图类型。我们可以在同一个<code class="fe lv lw lx ly b">RecyclerView</code>中显示多个视图类型。在早期，开发人员通过在列表模型中维护一个视图类型标志并在<code class="fe lv lw lx ly b">RecyclerView</code>适配器的<code class="fe lv lw lx ly b">getViewType</code>函数中返回它来实现这一点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0685" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">科特林为什么封课？</h1><p id="1aa0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在为Android开发引入Kotlin之后，我们处理核心实现的方式发生了巨大的变化。我的意思是，像扩展这样的特性几乎取代了维护Android组件基类的需要。Kotlin代理改变了我们使用setters和getters的方式。</p><p id="d210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，是时候更新我们在<code class="fe lv lw lx ly b">RecyclerView</code>适配器中的工作方式了。Kotlin密封类显示出对状态管理的显著影响。如果你想了解他们，我建议你阅读这篇文章。</p><p id="b5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受那篇文章的启发，我想使用密封类在<code class="fe lv lw lx ly b">RecyclerView</code>中实现视图类型。我们将尝试将随机整数或布局的比较转移到类类型。如果你是一个Kotlin书呆子，我相信你会喜欢这个实现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c819" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建Kotlin密封类</h1><p id="a162" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这种方法中，我们需要做的第一件事是创建我们希望在适配器中使用的所有数据类，然后将它们链接到一个密封的类中。让我们创建一组数据类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f25d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我希望在基于服务器数据的列表中显示的几个数据类。您可以拥有任意多的数据类。这种方法可以大规模使用。</p><p id="2514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它最好的一点是，我们可以维护加载状态、页眉、页脚等等，而无需编写任何额外的类。一会儿你就知道怎么做了。下一步是创建保存所有必要数据类的密封类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有自定义模型的密封类</p></figure><p id="7cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我之前说过的，我们可以通过使用Kotlin中的对象在<code class="fe lv lw lx ly b">RecyclerView</code>中添加页眉和页脚，而不需要任何额外的工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有页眉和页脚的密封类</p></figure><p id="6723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们完成了密封类的实现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5e27" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建RecyclerView适配器</h1><p id="557c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经完成了一个密封类，是时候用<code class="fe lv lw lx ly b">UIModel</code>列表创建一个<code class="fe lv lw lx ly b">RecyclerView</code>适配器了。这是一个简单的<code class="fe lv lw lx ly b">RecyclerView</code>，但是有一个密封的类<code class="fe lv lw lx ly b">arraylist</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="96e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码显示了一个没有任何密封类逻辑的<code class="fe lv lw lx ly b">RecyclerView</code>适配器的基本实现。如你所见，我们声明了一个密封的类arraylist ( <code class="fe lv lw lx ly b">UIModel</code>)。下一步是根据位置返回适当的视图类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比较密封的类模型以获取视图类型</p></figure><p id="603f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经成功地返回了基于密封类模型的正确布局，我们需要基于<code class="fe lv lw lx ly b">viewtype</code>在<code class="fe lv lw lx ly b">onCreateViewHolder</code>函数中创建各自的<code class="fe lv lw lx ly b">ViewHolder</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从密封类创建与视图类型相关的视图容器</p></figure><p id="0920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一部分是用当前项目数据更新视图容器，以便适配器可以在UI中反映数据。由于适配器有多个视图，我们必须对类型进行分类，然后调用各自的<code class="fe lv lw lx ly b">ViewHolder</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="172a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将这些片段组合在一起时，最终的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最终适配器</p></figure><p id="8580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一点上，我们可以走了。我们已经实施了所有强制性的东西。您可以在您的<code class="fe lv lw lx ly b">Activity/Fragment</code>中创建一个适配器实例，并将其分配给<code class="fe lv lw lx ly b">RecyclerView</code>。一旦获得数据，您需要用<code class="fe lv lw lx ly b">ArrayList&lt;UIModel&gt;</code>调用<code class="fe lv lw lx ly b">submitData</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将数据发布到RecyclerView适配器</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="515f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated"><strong class="ak"> DiffCallback </strong></h1><blockquote class="nf"><p id="0e22" class="ng nh it bd ni nj nk nl nm nn no lu dk translated">" DiffUtil是一个实用程序类，它可以计算两个列表之间的差异，并输出一个更新操作列表，将第一个列表转换为第二个列表。"— <a class="ae ky" href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil" rel="noopener ugc nofollow" target="_blank">安卓开发者</a></p></blockquote><p id="4751" class="pw-post-body-paragraph kz la it lb b lc np ju le lf nq jx lh li nr lk ll lm ns lo lp lq nt ls lt lu im bi translated">实现<code class="fe lv lw lx ly b">diffcallback</code>不是强制性的，但是如果你正在处理大型数据集，它会提高性能。因此，要在我们的适配器中实现<code class="fe lv lw lx ly b">difCallback</code>，我们需要区分模型并比较必要的变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">difCallback实现</p></figure><p id="f572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这类似于常规的<code class="fe lv lw lx ly b">diffcallback</code>实现，但是我们需要分离类型。一旦创建了它，就在构造函数中将它链接到适配器。</p><p id="83ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>