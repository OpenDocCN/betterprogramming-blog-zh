<html>
<head>
<title>The 5 Most Useful Introspection Functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中最有用的5个自省函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-5-most-useful-introspection-functions-in-python-7084e3bf9f01?source=collection_archive---------4-----------------------#2020-02-08">https://betterprogramming.pub/the-5-most-useful-introspection-functions-in-python-7084e3bf9f01?source=collection_archive---------4-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec53" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">函数来查找有关您正在使用的类型的更多信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/865517ddaaf2b1f2bd4a399f79ad6494.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iS8DhtCCm-Eq8TM5ocmwKQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pxhere.com/en/photo/952361" rel="noopener ugc nofollow" target="_blank"> PxHere </a>提供</p></figure><p id="38c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自省在许多编程语言中是通用的，Python也不例外。一般来说，在面向对象语言的上下文中，<em class="lv">自省</em>是一个对象在运行时找出类型、可用属性和方法，以及对该对象执行附加操作所需的其他信息的能力。</p><p id="de4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将向您展示Python所提供的最有用的自省功能。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="531d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">目录()</h1><p id="3d49" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">第一个函数是<code class="fe na nb nc nd b">dir()</code>函数。它所做的是提供对指定的感兴趣的对象可用的属性和方法的列表，该对象可以是声明的变量或函数。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="05e6" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; a = [1, 2, 3]<br/>&gt;&gt;&gt; dir(a)<br/>['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']</span></pre><p id="a199" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您可能注意到的，<code class="fe na nb nc nd b">dir()</code>函数的返回值实际上是一个排序列表，这意味着我们可以检查某个属性或方法的存在，以查看该对象是否可以执行该操作。下面给出一个例子。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="7169" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; b = [1, 2, 3]<br/>&gt;&gt;&gt; b_dir = dir(b)<br/>&gt;&gt;&gt; 'index' in b_dir<br/>True<br/>&gt;&gt;&gt; 'pop' in b_dir<br/>True</span></pre><p id="e1f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe na nb nc nd b">dir()</code>函数不带参数时，它将返回当前范围内的名字，如下所示。因此，检查在您的开发中定义和使用了什么是有用的。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e202" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; dir()<br/>['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'b', 'b_dir']</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c36f" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">类型()</h1><p id="f3a2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">另一个常用的自检函数是<code class="fe na nb nc nd b">type()</code>函数。顾名思义，该函数返回对象的类型，可以是原始数据类型、对象、类或模块。各种例子如下所示。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="dc16" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; type(1.2)<br/>&lt;class 'float'&gt;<br/>&gt;&gt;&gt; type([1, 2, 3])<br/>&lt;class 'list'&gt;<br/>&gt;&gt;&gt; type((3, 'Three'))<br/>&lt;class 'tuple'&gt;<br/>&gt;&gt;&gt; def do_something():<br/>...     pass<br/>... <br/>&gt;&gt;&gt; type(do_something)<br/>&lt;class 'function'&gt;<br/>&gt;&gt;&gt; class Fruit:<br/>...     pass<br/>... <br/>&gt;&gt;&gt; type(Fruit)<br/>&lt;class 'type'&gt;<br/>&gt;&gt;&gt; type(Fruit())<br/>&lt;class '__main__.Fruit'&gt;<br/>&gt;&gt;&gt; import os<br/>&gt;&gt;&gt; type(os)<br/>&lt;class 'module'&gt;</span></pre><p id="7344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何处理这些输出或者来自<code class="fe na nb nc nd b">type()</code>函数的返回值呢？我们可以通过使用<code class="fe na nb nc nd b">==</code>或<code class="fe na nb nc nd b">is</code>直接将返回值与我们想要检查的类型进行比较。下面给出了一些例子。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="46e8" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; type(1.2) == int<br/>False<br/>&gt;&gt;&gt; type(1.2) == float<br/>True<br/>&gt;&gt;&gt; type([1,2]) == list<br/>True<br/>&gt;&gt;&gt; type((1,2)) is tuple<br/>True</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="653c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">isinstance()</h1><p id="0020" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我们的开发中，一个特别有用的内省函数是<code class="fe na nb nc nd b">isinstance()</code>函数。使用这个函数，我们可以确定某个对象是否是指定类的实例。下面给出一个简单的例子。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="6936" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; isinstance([1,2], list)<br/>True<br/>&gt;&gt;&gt; isinstance([1,2], tuple)<br/>False<br/>&gt;&gt;&gt; isinstance((1,2), tuple)<br/>True</span></pre><p id="1ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要注意的事情是<code class="fe na nb nc nd b">isinstance()</code>函数可以接受一个元组作为它的第二个参数，如下所示。这本质上是独立的<code class="fe na nb nc nd b">or</code>评估。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="fd7b" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; isinstance(1, (int, float, tuple))<br/>True<br/>&gt;&gt;&gt; isinstance(1, int) or isinstance(1, float) or isinstance(1, tuple)<br/>True</span></pre><p id="b849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面给出了一个更实际的使用示例，它涉及一个自定义类。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2700" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; class Fruit:<br/>...     pass<br/>... <br/>&gt;&gt;&gt; apple = Fruit()<br/>&gt;&gt;&gt; isinstance(apple, Fruit)<br/>True</span></pre><p id="a68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到<code class="fe na nb nc nd b">type()</code>和<code class="fe na nb nc nd b">isinstance()</code>都可以用来确定一个对象是否属于某种类型。然而，它们并不相同。</p><p id="42b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们使用<code class="fe na nb nc nd b">type()</code>来确定一个对象是否属于某种类型时，我们是在进行一对一的比较。基本上，我们将对象的类型与我们指定的类型进行比较，看它们是否相同。</p><p id="6a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，<code class="fe na nb nc nd b">isinstance()</code>是一个更灵活的函数——因为它实际上返回一个对象是一个类的实例还是它的子类。换句话说，它将对象与潜在相关类的列表进行比较，这有点像一对多比较。下图显示了相关信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/dd125d8f9bda51d30ed8e176f88ab30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dH-m0JwxLkJmwMdZParWIA.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3a95" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">哈撒特尔()</h1><p id="f24a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时，在我们访问一个对象的属性之前，我们可能想要检查它是否有属性。我们不想看到下面的错误。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="00af" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; class Fruit:<br/>...     pass<br/>... <br/>&gt;&gt;&gt; Fruit().tasty<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: 'Fruit' object has no attribute 'tasty'</span></pre><p id="aae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种情况发生，我们可以在使用<code class="fe na nb nc nd b">hasattr()</code>函数访问对象之前检查它是否有这样的属性。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="dbd9" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; class Fruit:<br/>...     tasty = True<br/>... <br/>&gt;&gt;&gt; fruit = Fruit()<br/>&gt;&gt;&gt; if hasattr(fruit, 'tasty'):<br/>...     print('The fruit is tasty')<br/>... else:<br/>...     print('The fruit is not tasty')<br/>... <br/>The fruit is tasty</span></pre><p id="168e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意到没有，但是我们实际上可以使用<code class="fe na nb nc nd b">dir()</code>函数来实现相同的结果。</p><p id="c35f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还记得，<code class="fe na nb nc nd b">dir()</code>函数返回给定对象的可用属性和方法，这样我们就可以直接比较某个属性是否是返回列表的项目之一。更新后的代码如下所示，修改后的部分以粗体显示。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="e2bb" class="ni me it nd b gy nj nk l nl nm">&gt;&gt;&gt; class Fruit:<br/>...     tasty = True<br/>... <br/>&gt;&gt;&gt; fruit = Fruit()<br/><strong class="nd iu">&gt;&gt;&gt; if 'tasty' in dir(fruit):</strong><br/>...     print('The fruit is tasty')<br/>... else:<br/>...     print('The fruit is not tasty')<br/>... <br/>The fruit is tasty</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="43a2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">id()</h1><p id="48be" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Python中最后但同样重要的内省是<code class="fe na nb nc nd b">id()</code>函数，它返回对象的内存地址，因此它在现有对象中是唯一的。下面是这个函数的一个简单例子。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="ee36" class="ni me it nd b gy nj nk l nl nm">a = 2<br/>b = 1<br/>id(a)<br/>140339209865072<br/>id(b)<br/>140339209865096</span></pre><p id="9e09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Python中一个常见的代码示例是交换两个变量，只需运行下面的代码<code class="fe na nb nc nd b">a, b = b, a</code>就可以实现。让我们看看交换后会发生什么。</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="2d79" class="ni me it nd b gy nj nk l nl nm">id(a)<br/>140339209865096<br/>id(b)<br/>140339209865072<br/>a, b<br/>(1, 2)</span></pre><p id="1d01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，这两个变量已经成功地交换了，这反映在它们的内存地址和值上。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6b7d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">结论</strong></h1><p id="8a0e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在Python中可以非常方便地进行自省。</p><p id="69c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管感兴趣的用户在<a class="ae ky" href="https://docs.python.org/3/library/inspect.html" rel="noopener ugc nofollow" target="_blank"> Python的</a> <code class="fe na nb nc nd b"><a class="ae ky" href="https://docs.python.org/3/library/inspect.html" rel="noopener ugc nofollow" target="_blank">inspect</a></code> <a class="ae ky" href="https://docs.python.org/3/library/inspect.html" rel="noopener ugc nofollow" target="_blank">模块</a>中有更多高级内省方法可以探索，但本文讨论的五个函数是您可以在Python项目中使用的最常见的函数。</p></div></div>    
</body>
</html>