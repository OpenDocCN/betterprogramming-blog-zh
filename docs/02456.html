<html>
<head>
<title>Stop Letting Nested Object Properties Break Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要让嵌套的对象属性破坏您的代码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-letting-nested-object-properties-break-your-code-701bf814ea90?source=collection_archive---------25-----------------------#2019-12-01">https://betterprogramming.pub/stop-letting-nested-object-properties-break-your-code-701bf814ea90?source=collection_archive---------25-----------------------#2019-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ad2e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用可选的链接运算符(<code class="fe ki kj kk kl b">?.</code>)帮助处理未定义的父属性</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d1400f002ac0ec44cd273a189261b11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-t2SYAtIX4xhONRIlCLyA.jpeg"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://unsplash.com/@gecko81de?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">帕特里克·鲍姆</a>在<a class="ae lc" href="https://unsplash.com/s/photos/structure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2709" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果您处理的是非结构化的、不可预测的数据，那么我相信您以前也见过这个错误:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="df73" class="md me it kl b gy mf mg l mh mi">TypeError: Cannot read property ‘hello’ of undefined</span></pre><p id="5a1d" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">不可避免地，有人会发送深度嵌套属性的父属性未定义的数据。现在，我假设您已经解决了这个潜在的错误——我知道我已经解决了——但是它有点笨拙，可能看起来像这样:</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="95cb" class="md me it kl b gy mf mg l mh mi">if(record.education &amp;&amp; record.education.bachelors) {<br/>   // do stuff with record.education.bachelors<br/>}</span></pre><p id="c7c6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我在这里做的是检查以确保在parent(我的顶层变量/对象名)中定义了属性<code class="fe ki kj kk kl b">child</code>。然后，我检查<code class="fe ki kj kk kl b">grandchild</code>是否被定义，这样我就可以用<code class="fe ki kj kk kl b">greatgrandchild</code>做一些事情。</p><p id="c435" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">对我来说，我处理的数据有很多很多层次，这种检查最多是碍眼，最糟糕的是搞砸了。</p><p id="cdc9" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">还好有解决的办法！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7797" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">可选的链接运算符</h1><p id="bf2a" class="pw-post-body-paragraph ld le it lf b lg nh ju li lj ni jx ll lm nj lo lp lq nk ls lt lu nl lw lx ly im bi translated">如果我们希望值返回<code class="fe ki kj kk kl b">undefined</code>，而不是抛出<code class="fe ki kj kk kl b">TypeError</code>，那么我们可以用可选的链接操作符<code class="fe ki kj kk kl b">?.</code>替换<code class="fe ki kj kk kl b">.</code>。</p><p id="428a" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">本质上，可选的链接操作符所做的是，如果在链的任何地方有一个断点——未定义或空属性——就返回<code class="fe ki kj kk kl b">undefined</code>。</p><pre class="kn ko kp kq gt lz kl ma mb aw mc bi"><span id="974e" class="md me it kl b gy mf mg l mh mi">const record = {<br/>  "first_name": "Jonathan",<br/>  "last_name": "Hsu",<br/>  "education": null<br/>};</span><span id="f85f" class="md me it kl b gy nm mg l mh mi">console.log(record.education.bachelors)   // TypeError<br/>console.log(record?.education?.bachelors) // undefined</span></pre><p id="ea90" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这使您能够消除对每个嵌套属性的逐步检查。当检查一个属性时，这可以节省很多额外的代码。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2b73" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">有效性</h1><p id="d64a" class="pw-post-body-paragraph ld le it lf b lg nh ju li lj ni jx ll lm nj lo lp lq nk ls lt lu nl lw lx ly im bi translated">这个新操作符是ECMAScript 2020规范的一部分。有关全部细节，请参考他们的<a class="ae lc" href="https://tc39.es/ecma262/" rel="noopener ugc nofollow" target="_blank">规格文件</a>。</p></div></div>    
</body>
</html>