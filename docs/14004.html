<html>
<head>
<title>Build a DevOps Pipeline for the Ethereum Blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为以太坊区块链搭建DevOps管道</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-devops-pipeline-for-the-ethereum-blockchain-3d30cba87ffb?source=collection_archive---------3-----------------------#2022-10-25">https://betterprogramming.pub/building-a-devops-pipeline-for-the-ethereum-blockchain-3d30cba87ffb?source=collection_archive---------3-----------------------#2022-10-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9eb3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Web3遇上DevOps</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e8efb5ba306ba43cb44080820125a89f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A7WI2u72Wo7LK_ujTpVt0w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="349f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在推特上发布了我为一个Web3项目创建的DevOps管道，它获得了比我预期的更多的参与。</p><p id="2ca8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些回复鼓励我完成这个项目，并创建一个博客系列，向其他人展示我的成果。</p><p id="3807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本指南中，我将展示如何为运行在以太坊区块链上的分布式应用程序(dApp)实现DevOps最佳实践。</p><p id="7a13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是对DevOps或Web3开发的介绍。网上有很多资源可以帮助你了解Web3和DevOps。因此，这两个主题的先验知识是假定的。这将简单地展示如何将DevOps应用于Web3开发。</p><p id="5450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/get-started/what-is-azure-pipelines?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure Pipelines </a>构建的最终管道将有一个开发、质量保证和生产环境。开发环境将使用运行在容器中的<a class="ae ky" href="https://next-stack.github.io/ganache/" rel="noopener ugc nofollow" target="_blank"> Ganache </a>将应用程序部署到个人以太坊区块链。QA将部署到<a class="ae ky" href="https://www.rinkeby.io/#stats" rel="noopener ugc nofollow" target="_blank"> Rinkeby testnet </a>，最后Prod将部署到<a class="ae ky" href="https://www.ethstats.net/" rel="noopener ugc nofollow" target="_blank">以太坊mainnet </a>。前端将托管在<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/static-web-apps/overview" rel="noopener ugc nofollow" target="_blank"> Azure静态Web Apps </a>中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/632fd186896196b8bdbe2e9b96b71a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Bnq0bbImCRizegof.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Web3项目的Azure DevOps管道</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="421b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">编译和测试</h1><p id="1296" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，我们需要一个项目。对于这个例子，我将使用<a class="ae ky" href="https://trufflesuite.com/" rel="noopener ugc nofollow" target="_blank"> Truffle </a>来搭建我的分布式应用程序(dApp)。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fc9b" class="nf me it nb b gy ng nh l ni nj">truffle unbox react myapp</span></pre><p id="654d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令创建了一个带有React前端和用<a class="ae ky" href="https://soliditylang.org/" rel="noopener ugc nofollow" target="_blank"> Solidity </a>编写的契约的项目。我用JavaScript编写了我的测试，所以我删除了测试文件夹中的<em class="nk"> TestSimpleStorage.sol </em>文件。我还用NPM代替了Yarn，所以我从<em class="nk">客户端</em>文件夹中删除了<em class="nk"> yarn.lock </em>文件。清理完项目后，我用git初始化并提交了我的代码。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b6fa" class="nf me it nb b gy ng nh l ni nj">git init<br/>git branch -m main<br/>git add -–all<br/>git commit -a -m “init”</span></pre><p id="3b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part1" rel="noopener ugc nofollow" target="_blank"> blog/part1 </a>的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="714b" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part1</span></pre><p id="8c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深入之前，我想确定如何使用Truffle在本地编译、测试和部署代码。我将在最终的管道中复制这些命令。</p><h2 id="3e6c" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">契约</h2><h2 id="5d7a" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">收集</h2><p id="9c03" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了编译合同，我运行了以下命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7a32" class="nf me it nb b gy ng nh l ni nj">truffle compile</span></pre><p id="3448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就在<code class="fe nw nx ny nb b">client/src</code> <em class="nk"> </em>文件夹下创建了一个新的<code class="fe nw nx ny nb b">contracts</code> <em class="nk"> </em>文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2da57662963ba59b20d87f3c2f0bc13d.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/0*gjCKpnBbd1ZErUMI.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户/src文件夹下的新合同文件夹</p></figure><p id="a01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我将在管道中编译这些文件，所以我将它们添加到客户端项目的<code class="fe nw nx ny nb b">.gitignore</code>文件中。在我的<code class="fe nw nx ny nb b">.gitignore</code>底部，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更改为。gitignore</p></figure><p id="38d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我知道如何编辑合同，我需要测试它们。</p><h2 id="d63d" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">测试</h2><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我使用以下命令对我的智能合约进行了测试:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4705" class="nf me it nb b gy ng nh l ni nj">truffle test</span></pre><p id="1cff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试运行并成功，但是我注意到没有结果文件。对于要在我的管道中显示的结果，测试结果必须位于可以在管道中发布的文件中。用Truffle运行的JavaScript测试使用了<a class="ae ky" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a>。我可以配置Mocha，通过更新项目根目录下的<em class="nk"> truffle- </em> <code class="fe nw nx ny nb b">config.js</code>文件来创建一个结果文件。在网络部分下面，我添加了以下代码块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">truffle-config.js的摩卡部分</p></figure><p id="e995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在运行truffle test命令，一个<code class="fe nw nx ny nb b">TEST-results.xml</code> <em class="nk"> </em>文件被创建在项目的根目录中。这将用于在我的管道中发布结果。git不应该跟踪这个文件，所以我添加了一个<em class="nk">。gitignore将</em>文件添加到项目的根目录，并将<code class="fe nw nx ny nb b">TEST-results.xml</code> <em class="nk">添加到文件中。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将TEST-results.xml添加到。gitignore</p></figure><h1 id="96cf" class="md me it bd mf mg oc mi mj mk od mm mn jz oe ka mp kc of kd mr kf og kg mt mu bi translated">前端</h1><h2 id="27b4" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">建筑物</h2><p id="65d2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">随着合同的编译和测试，我开始构建和测试前端。切换到<em class="nk">客户端</em>目录，运行以下命令构建前端:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6cf6" class="nf me it nb b gy ng nh l ni nj">npm run build</span></pre><h2 id="ae70" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">测试</h2><p id="c011" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">构建前端后，我使用以下工具运行测试:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="47f9" class="nf me it nb b gy ng nh l ni nj">npm test</span></pre><p id="d78b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在尝试运行测试时，我很快意识到我有一个问题。前端正在使用<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>运行测试，它提示我输入。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/7edb917bcf0acf99010869e75ff66228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*GIs-qI8YYTJ_nhvE.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jest提示输入</p></figure><p id="af6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在自动化管道中是行不通的。经过一些研究，我发现我可以通过设置一个环境变量来运行测试，因此让Jest知道它正在CI中运行。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4bed" class="nf me it nb b gy ng nh l ni nj">CI=true npm test</span></pre><p id="b338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很有效，但是现在我又回到了以前的问题上。我需要一份测试结果的文件。获得与我的管道兼容的结果文件需要jest-junit包。使用npm，我安装了它，并将其保存为一个开发依赖项。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4ef0" class="nf me it nb b gy ng nh l ni nj">npm install --save-dev jest-junit</span></pre><p id="36bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装了这个包之后，我需要向我的npm测试命令添加一些参数来生成这个文件。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="136a" class="nf me it nb b gy ng nh l ni nj">CI=true npm test -- --reporters=default --reporters=jest-junit</span></pre><p id="4ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这生成了一个<code class="fe nw nx ny nb b">junit.xml</code>文件。这个文件不应该被跟踪到我的<em class="nk">底部。gitignore </em>文件在<code class="fe nw nx ny nb b">client</code> <em class="nk"> </em>文件夹中我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="cb63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的编译和测试都解决了，我提交了所有的修改。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7533" class="nf me it nb b gy ng nh l ni nj">git commit -a -m "compile and test"</span></pre><p id="703f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我将我的修改合并到<code class="fe nw nx ny nb b">main</code>中。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c90a" class="nf me it nb b gy ng nh l ni nj">git checkout main<br/>git merge blog/part1</span></pre><p id="aa89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来要做的是部署我的智能合约，这是事情变得非常棘手的地方。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1102" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">部署合同</h1><p id="39e2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在是时候部署智能合约了，并向您展示如何部署它们而不需要重新编译前端。</p><p id="40c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part2" rel="noopener ugc nofollow" target="_blank"> blog/part2 </a>”的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6287" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part2</span></pre><p id="ad95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在本系列的上一篇文章中提到的，部署智能合约是这个过程变得棘手的地方。为了理解为什么，让我们来看看当一个契约被部署到一个网络时会发生什么。</p><p id="775a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<a class="ae ky" href="https://trufflesuite.com/ganache/" rel="noopener ugc nofollow" target="_blank"> Ganache </a>作为本地开发的测试网络，并将在我的管道的开发环境中使用它。要在本地启动Ganache，我输入了以下命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8799" class="nf me it nb b gy ng nh l ni nj">ganache</span></pre><p id="7df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在部署到Ganache之前，我必须通过在networks:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">truffle-config.js的开发部分</p></figure><p id="6e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加该部分后，我运行以下命令来部署我的合同:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="86af" class="nf me it nb b gy ng nh l ni nj">truffle migrate</span></pre><p id="e128" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将合同部署到网络时，会分配一个地址。前端需要此地址来与链上的合同进行通信。该地址被写入合同的JSON文件，该文件位于合同编译时创建的<code class="fe nw nx ny nb b">client/src/contracts</code>文件夹下。JSON文件有一个networks部分，其中填充了每个部署了契约的网络的地址。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有合同地址的JSON文件的网络部分</p></figure><p id="aa6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于与契约通信的前端，它必须在每次部署后构建。这意味着前端必须构建在开发、QA和生产环境中。<strong class="lb iu">多次重新构建代码是一种DevOps反模式。</strong>代码应该只编译一次，所产生的工件不加修改地部署到每个环境中。任何需要针对每个环境进行调整的值都必须从代码中具体化，并在运行时注入。</p><p id="0fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<code class="fe nw nx ny nb b">client/src</code>文件夹中的<code class="fe nw nx ny nb b">App.js</code>文件，我可以在第2行看到JSON文件的导入。第20行使用该信息来获取已部署契约的网络细节，包括地址。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前端默认代码</p></figure><p id="8366" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更改了这段代码，以便从外部来源读取地址。我仍然加载了JSON文件，因为它还包含应用程序二进制接口(ABI ),该接口不会改变，并且是部署代码所必需的。</p><p id="d9f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望代码能像最初用于本地开发时那样工作，但如果在JSON文件中找不到地址，代码也能工作。如果代码无法在JSON文件中找到地址，它将调用外部服务来获取该地址。因为我决定使用<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/static-web-apps/" rel="noopener ugc nofollow" target="_blank"> Azure Static Web Apps </a>来托管我的前端，所以我使用内置的<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/static-web-apps/add-api?tabs=vanilla-javascript" rel="noopener ugc nofollow" target="_blank"> Azure Function </a>支持来托管返回合同地址的服务。</p><p id="8270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我更新了代码来调用服务。包括第20行在内的所有内容都保持不变。我在创建契约实例之前添加了代码来定位地址。在第22行，我存储了从JSON文件返回的值。然后，在第26行，我测试了这个值，看它是否为空。如果地址返回为空，将在第28行调用服务，传递网络Id以返回该网络的合同地址。最后，在第33行，我使用ABI和计算出的地址构建了一个契约实例。文件的其余部分与原始文件保持不变。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的代码</p></figure><p id="fd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过外部化地址，前端只构建一次。从开发到QA，最后到生产，代码不会改变。在管道的第一阶段，我编译了契约和前端，并将结果文件作为构建的工件发布。那些工件将通过管道不加修改地移动。</p><p id="3faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了代码，我现在可以编写第28行调用的服务，Azure函数，我将在下一节中完成。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6c28" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">写地址服务</h1><p id="e9af" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这一节中，我将编写一个Azure函数向前端提供地址。</p><p id="2f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的优点是可以在运行时检索地址，并且可以在不改变前端的情况下动态地改变地址。</p><p id="94c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part3" rel="noopener ugc nofollow" target="_blank"> blog/part3 </a>的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ff60" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part3</span></pre><p id="fb1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用了<a class="ae ky" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>作为我的编辑器，并且安装了<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azurestaticwebapps" rel="noopener ugc nofollow" target="_blank"> Azure Static Web Apps扩展</a>。我使用Azure Static Web Apps:Create HTTP function…命令在项目根目录下的API文件夹中添加一个名为<code class="fe nw nx ny nb b">GetContractAddress</code>的JavaScript函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/26156d9d67b5fc753d2b32d897160b9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*uINLRoICO75s5Nv3.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API项目文件夹结构</p></figure><p id="7f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的服务，它返回从环境变量中读取的值。从我的管道中，我将获得契约地址，并将其存储在函数基础结构的环境变量中。</p><p id="4c63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能将使用<a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>作为测试框架(Jest也用于前端测试)。我为这个功能实现了测试驱动开发(TDD ),所以我首先编写了我的测试。因为我使用了Jest，所以我在函数项目的<code class="fe nw nx ny nb b">GetContractAddress</code>文件夹中的<code class="fe nw nx ny nb b">index.js</code>文件旁边创建了一个名为<code class="fe nw nx ny nb b">index.test.js</code>的新文件。</p><p id="6f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务的契约需要一个名为<code class="fe nw nx ny nb b">networkId</code>的查询参数。我写了两个测试。一个在提供了<code class="fe nw nx ny nb b">networkId</code>时返回值，一个在没有提供<code class="fe nw nx ny nb b">networkId </code>时返回错误。</p><p id="fa10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用<a class="ae ky" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>来管理环境变量，所以我将它与Jest和Jest-Junit一起安装，并将它们存储为开发依赖项。我确保并运行了API文件夹中的命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ed7a" class="nf me it nb b gy ng nh l ni nj">npm install --save-dev dotenv jest jest-junit</span></pre><p id="8aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装完依赖项后，我编写了我的测试。</p><p id="058d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传递给Azure Functions的第一个参数是公开日志函数的上下文对象。因此，我创建了一个模拟上下文对象，用于在API文件夹中名为TestMocks的文件夹中进行测试。我将文件命名为<code class="fe nw nx ny nb b">defaultContext.js</code>，并添加了以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">默认上下文. js</p></figure><p id="7bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个模拟让我跟踪调用，记录和检查消息。</p><p id="ac0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模拟就绪后，我编写了我的测试。首先，我需要dotenv，保存我的函数的索引文件和保存我的mock的<code class="fe nw nx ny nb b">defaultContext</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">索引.测试. js</p></figure><p id="4e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次测试后，我需要清除对任何模拟的调用，所以我添加了一个<code class="fe nw nx ny nb b">afterEach</code>函数并调用了<code class="fe nw nx ny nb b">clearAllMocks</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">索引.测试. js</p></figure><p id="0c75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个测试验证了快乐路径的有效性。如果调用者提供一个<code class="fe nw nx ny nb b">networkId</code>作为查询参数，那么应该从一个环境变量返回地址。在API文件夹的根目录下，我创建了一个. env文件来保存测试的环境变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">。包封/包围（动词envelop的简写）</p></figure><p id="9ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">的。dotenv将加载env文件，因此测试可以读取环境变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">索引.测试. js</p></figure><p id="fff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有提供<code class="fe nw nx ny nb b">networkId</code>，第二个测试将返回一个错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">索引.测试. js</p></figure><p id="b8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写完测试后，我在我的<code class="fe nw nx ny nb b">package.json</code>的第7行更新了测试脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">package.json</p></figure><p id="a29c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在真正的TDD方式中，我运行测试来查看它们是否失败。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2415" class="nf me it nb b gy ng nh l ni nj">npm test&gt; api@1.0.0 test<br/>&gt; jestFAIL  GetContractAddress/index.test.js<br/>  ✕ Should return address (3 ms)<br/>  ✕ Should return 400 error● Should return addressexpect(received).toBe(expected) // Object.is equalityExpected: 2<br/>Received: 1  16 |<br/>  17 |     // Assert<br/>&gt; 18 |     expect(context.log.mock.calls.length).toBe(2);<br/>     |                                           ^<br/>  19 |   expect(context.res.body).toEqual('0x7a063c7e4A0EC2fB4dC0F73103Fd45F17b46Ae52');<br/>  20 | });<br/>  21 |at Object.toBe (GetContractAddress/index.test.js:18:43)● Should return 400 errorexpect(received).toBe(expected) // Object.is equalityExpected: 1<br/>Received: 2  30 |<br/>  31 |     // Assert<br/>&gt; 32 |     expect(context.log.mock.calls.length).toBe(1);<br/>     |                                           ^<br/>  33 |     expect(context.res.status).toEqual(400);<br/>  34 | })at Object.toBe (GetContractAddress/index.test.js:32:43)Test Suites: 1 failed, 1 total<br/>Tests:       2 failed, 2 total<br/>Snapshots:   0 total<br/>Time:        0.224 s, estimated 1 s<br/>Ran all test suites.</span></pre><p id="8542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我更新了<code class="fe nw nx ny nb b">index.js</code>来匹配下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">索引. js</p></figure><p id="9140" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我使用jest-junit运行测试，以验证是否会创建一个结果文件用于我的管道。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c088" class="nf me it nb b gy ng nh l ni nj">CI=true npm test -- --reporters=default --reporters=jest-junit&gt; api@1.0.0 test<br/>&gt; jestPASS  GetContractAddress/index.test.js<br/>  ✓ Should return address (2 ms)<br/>  ✓ Should return 400 error (1 ms)Test Suites: 1 passed, 1 total<br/>Tests:       2 passed, 2 total<br/>Snapshots:   0 total<br/>Time:        0.279 s, estimated 1 s<br/>Ran all test suites.</span></pre><p id="f021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nw nx ny nb b">junit.xml</code>文件按预期创建。这个文件不必被跟踪，所以在我的底部。gitignore文件在API文件夹中我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="01de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我签入了我所有的更改。</p><p id="d4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着所有项目的到位，是时候开始建设我的管道了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="4db1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建管道的初始结构</h1><p id="1223" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在开始构建管道之前，我需要将我的更改发布到远程git服务。虽然我使用<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/get-started/what-is-azure-pipelines?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> Azure Pipelines </a>作为我的DevOps管道，但是我使用<a class="ae ky" href="https://github.com/" rel="noopener ugc nofollow" target="_blank"> GitHub </a>来存储我的源代码。Azure Pipelines和GitHub配合得非常好，我得到了两个世界的好处。</p><p id="c59b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要帮助创建Azure DevOps项目(以保存您的Azure管道)或创建您的代码并将其推送到GitHub存储库，您可以使用以下链接:</p><ul class=""><li id="0257" class="oj ok it lb b lc ld lf lg li ol lm om lq on lu oo op oq or bi translated"><a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/organizations/projects/create-project?view=azure-devops&amp;tabs=browser" rel="noopener ugc nofollow" target="_blank">在Azure DevOps中创建一个项目</a></li><li id="56f1" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated"><a class="ae ky" href="https://docs.github.com/en/get-started/quickstart/create-a-repo" rel="noopener ugc nofollow" target="_blank">在GitHub中创建一个回购</a></li></ul><p id="ba91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part4" rel="noopener ugc nofollow" target="_blank"> blog/part4 </a>”的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="46ea" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part4</span></pre><div class="kj kk kl km gt ab cb"><figure class="ox kn oy oz pa pb pc paragraph-image"><img src="../Images/6f1c673473f088410f9280e39187d6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/0*OrEk-6oJvNJ2fLe-.png"/></figure><figure class="ox kn pd oz pa pb pc paragraph-image"><img src="../Images/9ecce6ee72280e50e9ca571ae344ec36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/0*xt8PzwjevQXpv8rG.png"/><p class="ku kv gj gh gi kw kx bd b be z dk pe di pf pg translated">管道菜单和创建管道按钮</p></figure></div><p id="49d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将我的代码推送到GitHub后，我导航到Azure DevOps的Pipelines页面并点击了Create Pipeline按钮。</p><p id="324f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在被问到“你的代码在哪里”的时候我选择了GitHub。我用我的代码选择了回购，然后选择了启动管道。</p><p id="2448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Azure管道可以由<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages?view=azure-devops&amp;tabs=yaml" rel="noopener ugc nofollow" target="_blank">阶段、作业和</a>步骤组成。为了开始，我决定列出我的阶段和工作。这允许我定义阶段和作业之间的依赖关系，并查看我的整个管道。</p><h2 id="31c2" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">初始结构</h2><p id="40fb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用web编辑器，我更新了代码来定义我的管道结构。我的管道有六个阶段:</p><ol class=""><li id="d886" class="oj ok it lb b lc ld lf lg li ol lm om lq on lu ph op oq or bi translated"><code class="fe nw nx ny nb b">build</code>:编译、测试和打包工件</li><li id="2104" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated"><code class="fe nw nx ny nb b">dev</code>:部署基础设施、合同和前端</li><li id="35c4" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated"><code class="fe nw nx ny nb b">dev_validation</code>:等待手动验证开发并删除开发环境</li><li id="5828" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated"><code class="fe nw nx ny nb b">qa</code>:部署基础设施、合同和前端</li><li id="0625" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated"><code class="fe nw nx ny nb b">qa_validation</code>等待<code class="fe nw nx ny nb b">qa</code>的手动确认，删除<code class="fe nw nx ny nb b">qa</code>环境</li><li id="aaa9" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated"><code class="fe nw nx ny nb b">prod</code>:部署基础设施、合同和前端</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始管道结构</p></figure><p id="4c9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我保存并运行了我的管道，以确认一切都被正确构建并运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/aeb2b5a6d9a7e19869019723df0e02ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zpJeGUgh__3a7VBy.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管道的成功运行</p></figure><p id="2989" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在管道的初始运行之后，我将我的更改同步到我的本地开发机器上，以将<code class="fe nw nx ny nb b">azure-pipelines.yml</code>文件拉下来。这是包含我的管道定义的文件。</p><p id="3c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使我的管道更容易创建，我在我的项目的根目录中添加了一个包含Truffle依赖项的<code class="fe nw nx ny nb b">package.json</code>文件。Azure管道使用微软托管的代理来运行。它们包含最常见的包，我可以通过一个<code class="fe nw nx ny nb b">package.json</code>文件添加额外的包。</p><p id="d48b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我需要添加松露。此处列出了预安装的软件包<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted?view=azure-devops&amp;tabs=yaml" rel="noopener ugc nofollow" target="_blank">。必须安装Truffle来编译、测试和迁移合同。在根目录中安装Truffle将创建一个不需要被跟踪的<code class="fe nw nx ny nb b">node_modules</code>文件夹。所以，我把它添加到项目根目录下的<code class="fe nw nx ny nb b">.gitignore</code>文件中。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">向添加了node_modules。gitignore</p></figure><p id="0c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我运行了以下命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="9c47" class="nf me it nb b gy ng nh l ni nj">npm install --save-dev truffle</span></pre><p id="d8db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定创建一个<code class="fe nw nx ny nb b">package.json</code>文件，以防将来需要额外的包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">package.json</p></figure><p id="ca42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我提交了所有的更改。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="85ed" class="nf me it nb b gy ng nh l ni nj">git add package.json<br/>git add package-lock.json<br/>git commit -a -m "adding pipeline yaml"</span></pre><p id="0753" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我把我的改动合并到了<code class="fe nw nx ny nb b">main</code>。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="8a31" class="nf me it nb b gy ng nh l ni nj">git checkout main<br/>git merge blog/part4</span></pre><p id="d786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将完成管道的构建阶段。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0ee6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">管道，构建阶段</h1><p id="6637" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这一节中，我将完成编译、测试和打包工件的构建阶段。</p><p id="1df1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使编辑管道YAML更容易，我为VS代码安装了<a class="ae ky" href="https://marketplace.visualstudio.com/items?itemName=ms-azure-devops.azure-pipelines" rel="noopener ugc nofollow" target="_blank"> Azure管道扩展</a>。这增加了语法突出显示和自动完成功能。</p><p id="558d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part5" rel="noopener ugc nofollow" target="_blank"> blog/part5 </a>的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="fa82" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part5</span></pre><p id="aa3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了完成构建阶段，我在第11行的<code class="fe nw nx ny nb b">compile_test</code>作业下面添加了steps元素。第一步调用<code class="fe nw nx ny nb b">npm install</code>安装松露。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安装块菌的步骤</p></figure><p id="b2ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了一个<code class="fe nw nx ny nb b">displayName</code>，以便在管道日志中更容易识别这个步骤。</p><h2 id="a6ae" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">契约</h2><p id="1c17" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">安装了Truffle之后，我就可以编译和测试合同了。因为我按照<a class="ae ky" href="https://medium.com/@donovan.brown/web3-devops-part-1-compiling-and-testing-9188aa7a0209" rel="noopener"> Web3 DevOps: Part 1 —编译和测试</a>中的讨论配置了test命令来输出结果文件，所以我也发布了测试结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="48a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我决定签入我的代码，看看是否一切都如预期的那样工作。令我惊讶的是，测试步骤失败了！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/90ede0a316bb7f0c005d16ec484c9718.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/0*sfqYh8qXoz8j8fOR.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试合同失败</p></figure><p id="0e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的构建日志显示了以下信息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/7390f9eda69bb7b7e0a883668d25620b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*46sT3-vh_yKAx2-V.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">测试失败日志</p></figure><p id="2fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一些研究，我发现错误是由于将开发节点添加到了<strong class="lb iu">部署合同</strong>部分的<code class="fe nw nx ny nb b">truffle-config.js</code>文件中。默认情况下，<code class="fe nw nx ny nb b">truffle test</code>命令使用内置测试网络。</p><p id="256c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，一旦您定义了一个开发网络，它就会切换到使用该网络。这对于我在本地运行Ganache的本地开发来说很好，但是在管道的第一阶段，我想使用默认的测试网络来运行测试。</p><p id="8a2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我更新了<code class="fe nw nx ny nb b">truffle-config.js</code>文件。因为配置文件是执行JavaScript代码，所以如果设置了环境变量，我会更改逻辑来动态定义开发环境。在名为<code class="fe nw nx ny nb b">DEV_NETWORK</code>的环境变量中，我放置了Ganache实例的IP地址。</p><p id="384d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在本地运行它时，我将其设置为<code class="fe nw nx ny nb b">127.0.0.1</code>。当运行在管道的Dev环境中时，它将被设置为运行在云中的Ganache实例的IP。在管道的构建阶段，将不会设置这个环境变量，从而导致使用内置测试网络来执行测试。</p><p id="1f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我决定使用dotenv来读取环境变量，所以我安装了它，并将其作为一个依赖项保存在我的根文件夹中。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1742" class="nf me it nb b gy ng nh l ni nj">npm install --save-dev dotenv</span></pre><p id="8c90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了我的依赖项，我更新了<code class="fe nw nx ny nb b">truffle-config.js</code>文件以匹配下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="c2e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我更新了我的<code class="fe nw nx ny nb b">.gitignore</code>文件，忽略任何未来。我创建的env文件。我的根级<code class="fe nw nx ny nb b">.gitignore</code>文件现在看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4dd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我提交并推送我的代码来测试我的更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/e4711f89531b2baaad2cfcb5d5547987.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mgZ3kcpKTK5sR-L3.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合同测试结果</p></figure><p id="6710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我的测试通过，我继续将我的合同和合同测试打包并作为工件发布。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打包和发布工件的任务</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/3f141f20429a116fb4349f047fefa153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*ecZn8GEt_6mLg1qp.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">合同工件</p></figure><p id="d5cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将这些文件打包成工件将使它们对我的管道中的其他阶段可用。</p><h2 id="9ee2" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">前端</h2><p id="201e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">随着合同的结束，我搬到了前台。目标是相同的:作为工件编译、测试、打包和发布。注意，我将测试步骤中的CI环境变量设置为<code class="fe nw nx ny nb b">true</code>。或者，您可以为整个阶段或管道设置该变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">前端任务</p></figure><div class="kj kk kl km gt ab cb"><figure class="ox kn pk oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/0508e67346fbc0ee431c03b70b777bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/0*9IRXc_YpnKvXfaae.png"/></div></figure><figure class="ox kn pl oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/7da38f77d98e47719fa783b69e857db7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/0*PhqAt2pXiqt_cxUQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk pm di pn pg translated">前端测试结果和工件</p></figure></div><h2 id="b2cd" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">应用程序接口</h2><p id="33f7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最终的项目是Azure Function API。请注意，发布任务在安装依赖项之前运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">API的任务</p></figure><div class="kj kk kl km gt ab cb"><figure class="ox kn po oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/59cf6292f3787dc67c6454339f675ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/0*A4NIeNj7xwhohiBu.png"/></div></figure><figure class="ox kn pp oz pa pb pc paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/edeae637de5e602dc9cd3a77d639d33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/0*UZz3qByv32xoAvOF.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk pq di pr pg translated">API工件和测试结果</p></figure></div><p id="0215" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着所有项目被编译、测试并打包成工件，接下来我将开发代码形式的基础设施(IaC)。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="5651" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/web3-meets-devops-pipeline-iac-72f88e1d3d55">管道，IaC </a></h2><p id="13bb" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在，我将开发部署用于托管前端的<a class="ae ky" href="https://azure.microsoft.com/en-us/services/app-service/static/" rel="noopener ugc nofollow" target="_blank"> Azure静态Web应用</a>所需的基础设施代码(IaC)。</p><p id="c5d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IaC是DevOps的最佳实践，其中托管应用程序所需的基础设施被编码，存储在源代码控制中，并部署在管道中。为了托管我的分布式应用程序(dApp)的前端，我使用了Azure Static Web Apps (SWA)。为了部署SWA，我使用了<a class="ae ky" href="https://github.com/powershell/powershell" rel="noopener ugc nofollow" target="_blank"> PowerShell </a>和<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep" rel="noopener ugc nofollow" target="_blank">二头肌</a>的组合。PowerShell是跨平台的，安装在所有Azure DevOps代理上。我发现它比Bash更容易使用，也更强大。</p><p id="451c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的部署的开发环境将需要一个SWA来托管前端，并需要一个Ganache实例来托管智能合约。我使用Azure容器实例来运行Ganache，使用了我在自己的博客<a class="ae ky" href="https://www.donovanbrown.com/post/How-to-use-Azure-Container-Instances-to-host-Ganache" rel="noopener ugc nofollow" target="_blank">中记录的技术，即如何使用Azure容器实例来托管Ganache </a>。</p><p id="6341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为本文创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part6" rel="noopener ugc nofollow" target="_blank"> blog/part6 </a>”的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="1752" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part6</span></pre><p id="4d86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我首先在项目的根目录下创建了一个<em class="nk"> iac </em>文件夹，在那里我存储了部署基础设施的所有文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/8c8e396e4c719ca4877bcae5dea836a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/0*n38gwPap9NJNPdP2.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于保存PowerShell和Bicep文件的新iac文件夹</p></figure><h2 id="8234" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">二头肌</h2><p id="3364" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用Bicep，我将我的部署分成模块，这些模块处理我的Azure静态Web应用程序和Azure Contain实例的创建。我还创建了一个主模块，它调用其他模块，收集输出，并将它们提供给我的PowerShell脚本。对于这个部署，我需要三个文件:<em class="nk"> main.bicep、ganache.bicep、</em>和<em class="nk"> swa.bicep. </em></p><h2 id="d1fc" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">纳米比亚</h2><p id="abdc" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="nk"> swa.bicep </em>返回两个值:用于设置Azure函数返回的网络地址的静态web app的名称，以及我用来部署我的前端的AzureStaticWebApp任务所需的部署令牌。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">部署静态Web应用程序的Bicep文件</p></figure><h2 id="0ff3" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">加纳切</h2><p id="0a57" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">此模块返回分配给容器的IP地址，以便将网络添加到元掩码wallet中。我还支持传入一个<em class="nk"> fqdn </em>参数来设置一个完全限定的域名。因此，即使IP地址发生变化，元掩码网络也不必改变。我还传入了— wallet.deterministic标志，以确保它在每次创建时都生成相同的帐户。这消除了导入帐户来测试应用程序的需要。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="bbc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">command元素覆盖默认命令，将附加参数传递给Ganache。你可以在我的文章<a class="ae ky" href="https://www.donovanbrown.com/post/how-to-override-the-entrypoint-when-running-an-container-with-aci" rel="noopener ugc nofollow" target="_blank">如何在运行带有ACI的容器时覆盖入口点</a>中读到更多。</p><h2 id="b917" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">主要的</h2><p id="a528" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我使用了订阅级别的部署，因此资源组与我的所有资源一起创建。这允许我删除Dev和QA的整个资源组，并在下一次部署开始时创建它们。显然，我不会删除Prod，但是在发生灾难时，我会简单地启动一个部署，让一切重新创建，而无需进一步的人工干预。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="3ffb" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">PowerShell</h2><p id="08c7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在我的PowerShell脚本中，我使用Azure CLI来部署我的基础设施，捕获所有输出，并将它们暴露给管道。写主机调用的最后三行使这些值可供管道使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">deploy.ps1</p></figure><h2 id="6fdd" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">管道</h2><p id="e5d0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">最后，我更新了管道的构建阶段，将IaC文件打包并作为工件发布。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打包和发布IaC文件的任务</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/93d682f20fefd0fee2a1bcf1bedb6040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/0*hgQQauFNYQ_YQzdY.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">IaC伪影</p></figure><p id="163c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着所有项目被编译、测试并打包成工件，在下一节中，我将把所有东西部署到一个开发环境中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="a157" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">管道，部署基础设施</h1><p id="b147" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本节中，我将使用在这些任务中开发的基础设施代码(IaC)来部署基础设施。</p><p id="b1df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part7" rel="noopener ugc nofollow" target="_blank"> blog/part7 </a>”的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="63fe" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part7</span></pre><h2 id="fe52" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">服务连接</h2><p id="8f03" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了将基础设施部署到Azure中，我在Azure DevOps和Azure之间创建了一个服务连接。按照以下步骤为Azure管道创建服务连接:</p><ol class=""><li id="f1bb" class="oj ok it lb b lc ld lf lg li ol lm om lq on lu ph op oq or bi translated">登录您的组织(<code class="fe nw nx ny nb b">https://dev.azure.com/{yourorganization}</code>)，并选择您的项目。</li><li id="d701" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">单击项目设置，然后单击服务连接。</li><li id="c48c" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">单击新建服务连接。</li><li id="5789" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">选择Azure资源管理器。</li><li id="48ae" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">滚动到列表底部，然后单击下一步。</li><li id="b457" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">选择服务主体(自动)，然后单击下一步。</li><li id="1c3a" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">选择您的订阅。</li><li id="3c29" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">输入服务连接名称。</li><li id="b6f6" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">选中授予对所有管道的访问权限。</li><li id="2797" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu ph op oq or bi translated">单击保存创建服务连接。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/33fedccdd9312f7cedf2d7c822100d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/0*kXU4OnC9lRj_bLUB.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Azure的新服务连接</p></figure><h2 id="21b5" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">管道</h2><p id="a4a0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">随着服务连接的创建，我更新了<code class="fe nw nx ny nb b">azure-pipelines.yml</code>来部署基础设施。在文件的顶部，我定义了一个带有默认值的<code class="fe nw nx ny nb b">resourceGroup</code>变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="4a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在开发阶段的iac作业下，我添加了两个任务，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个任务下载在管道的前一阶段创建的iac工件。这个工件包含三个Bicep文件和一个PowerShell脚本。</p><p id="6b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个任务执行PowerShell脚本，该脚本使用三个Bicep文件来部署一个Azure静态Web应用程序和一个运行Ganache的Azure容器实例。注意，我之前创建的服务连接被用作inputs下azureSubscription的值。</p><p id="0658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着管道的更新，我进行了修改并运行了构建。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基础设施被部署到Azure。日志显示了可用于测试我的智能合约的Ganache服务器的IP地址。这项任务将所有需要的基础设施部署到我的Azure订阅中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/c25c991bc8e393dea907c1b99af275c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QJtD_PcdCXxY-ao3.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用IaC部署的Azure静态Web应用程序和Azure容器实例</p></figure><p id="124e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署好基础设施后，在下一节中，我将把我的单页面应用程序(SPA)部署到Azure Static Web应用程序中。我还将把我的智能合约部署到Azure容器实例中托管的Ganache中。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c7b8" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">管道，部署dApp</h1><p id="260c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在本节中，我将把我的智能合同和前端部署到该基础设施中。</p><p id="6a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part8" rel="noopener ugc nofollow" target="_blank"> blog/part8 </a>”的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="da6b" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part8</span></pre><h2 id="2bc9" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">契约</h2><p id="604e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这些契约被部署到在上一篇文章中部署的Azure容器实例中运行的Ganache实例中。在<code class="fe nw nx ny nb b">dev</code>阶段的<code class="fe nw nx ny nb b">deploy_contracts</code>工作下，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8180" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先定义这个工作需要的变量:<code class="fe nw nx ny nb b">ganacheIp</code>和<code class="fe nw nx ny nb b">ganacheName</code>。变量值是在我执行<code class="fe nw nx ny nb b">iac</code>任务中的<code class="fe nw nx ny nb b">deploy.ps1</code>脚本时设置的。如果我不定义它们，它们将不可用于此工作。</p><p id="3e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些步骤下，脚本下载了在前面的文章中创建的工件。为了部署合同，Truffle必须安装在代理上，这是我和<code class="fe nw nx ny nb b">npm install</code>一起做的。</p><p id="71a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦安装了Truffle，脚本就会重启运行Ganache的容器。当容器启动时，它显示帐户和私钥的列表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe nw nx ny nb b">iac</code>作业运行时，如果容器已经存在，则不会重新启动。随着时间的推移，如果运行了足够多的构建，日志将不再有帐户和私钥。通过在此作业中显式重新启动容器，它确保帐户和私钥在下面的作业中可用，因此它们被提取出来并可用于管道摘要以在元掩码中使用。</p><p id="4f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ganache重启后，我用<code class="fe nw nx ny nb b">truffle migrate</code>命令部署了契约。该命令将网络设置为开发，因此使用了Ganache。<code class="fe nw nx ny nb b">truffle migrate</code>命令执行了需要将<code class="fe nw nx ny nb b">DEV_NETWORK</code>环境变量设置为<code class="fe nw nx ny nb b">ganacheIp</code>的<code class="fe nw nx ny nb b">truffle-config.js</code>文件。</p><p id="a0b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，PowerShell任务获取网络ID和合同地址，并输出它们以用于部署前端。</p><h2 id="eee9" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">前端</h2><p id="3f19" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">前端将被部署到上一篇文章中部署的Azure Static Web App中。在<code class="fe nw nx ny nb b">dev</code>阶段的<code class="fe nw nx ny nb b">deploy_frontend</code>工作下，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与合同一样，我在这项工作中需要的变量首先被定义。在<code class="fe nw nx ny nb b">iac</code>任务中执行<code class="fe nw nx ny nb b">deploy.ps1</code>脚本时，设置了一些变量值。其他来自合同部署期间运行的PowerShell脚本。</p><p id="e84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下载工件后，AzureStaticWebApp任务部署前端和Azure功能。</p><p id="d7fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，调用Azure CLI任务来运行<code class="fe nw nx ny nb b">az staticwebapp appsettings set</code>命令。这设置了一个Azure函数将使用的环境变量。该功能在<strong class="lb iu">写地址服务</strong>部分描述。</p><p id="fa1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，more PowerShell提取配置MetaMask连接到我的dApp所需的所有重要信息。该脚本收集所有变量，并将它们格式化为Markdown。然后，降价被写入磁盘并附加到“管道扩展”选项卡。</p><p id="fe06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些信息，我可以在MetaMask中将Ganache添加为一个网络，导入一个帐户，并连接到dApp。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/18c8a6baba7ba3f9abde525c6b038750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KYrsprFYDPCFzhLK.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示连接元掩码信息的“扩展”选项卡</p></figure><p id="9869" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了省钱和测试我的IaC，我喜欢删除不再需要的回复。在删除开发环境之前，我希望有机会审查代码。为此，我使用手动验证作业。一旦我批准了验证步骤，下一个作业就会删除Azure中的Dev资源组，移除我的所有资源。在<code class="fe nw nx ny nb b">dev_validation</code>阶段，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="26e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我已经部署到我的开发环境中，在下一节中，我们将使用<a class="ae ky" href="https://www.rinkeby.io/#stats" rel="noopener ugc nofollow" target="_blank"> Rinkeby </a>作为我的QA环境。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="95b1" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">质量保证管道</h1><p id="38c4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这一节中，我将使用Rinkeby测试网络将所有东西部署到我的QA环境中。</p><p id="f2cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part9" rel="noopener ugc nofollow" target="_blank"> blog/part9 </a>的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3cdf" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part9</span></pre><p id="5f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了部署到Rinkeby测试网络，我需要一个Infura节点和一个test Ether帐户。我在<a class="ae ky" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://in fura . io</em></a>创建了一个免费账号和一个名为<em class="nk"> My1stEthProject </em>的项目。一旦我创建了项目，我就可以访问<em class="nk"> API密钥</em>和<em class="nk">网络端点</em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/25cc5142093b430e37bf141f0d8bd29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AxmfnxToIQP5a9iv.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Infura项目设置(Rinkeby Testnet)</p></figure><p id="3a23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还在网上搜索了“<em class="nk"> rinkeby水龙头</em>”，用一个给钱包加乙醚。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/236ef9a8c5b98f0529178290b6bfdf54.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/0*772d-kRD8pQXFrR8.png"/></div></figure><p id="b9dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要部署到Rinkeby，必须将网络添加到<em class="nk">Truffle-config . js。</em>添加网络的最佳资源是官方<a class="ae ky" href="https://trufflesuite.com/docs/truffle/reference/configuration/#networks" rel="noopener ugc nofollow" target="_blank"> Truffle套件文档</a>。查看文档后，我意识到我需要一个<code class="fe nw nx ny nb b">HDWalletProvider</code>。使用npm，我安装了它并将其保存为一个依赖项。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b7fe" class="nf me it nb b gy ng nh l ni nj">npm install --save truffle-hdwallet-provider</span></pre><p id="e2b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装了这个包之后，我需要更新<em class="nk"> truffle-config.js </em>。我添加了来自我的Infura项目的<em class="nk"> API键</em>作为环境变量，以及来自我的测试帐户的<em class="nk">助记符</em>。</p><p id="d9e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nw nx ny nb b">HDWalletProvider</code>，我将Rinkeby网络添加到<em class="nk">网络</em>部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="4b2f" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">基础设施</h2><p id="9533" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在<em class="nk"> qa </em>阶段的<em class="nk"> iac </em>作业下，在<code class="fe nw nx ny nb b">azure-pipelines.yml</code>中，我增加了两个任务，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="d92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个任务下载在管道的<em class="nk">构建</em>阶段创建的<em class="nk"> iac </em>工件。这个工件包含三个Bicep文件和一个PowerShell脚本。</p><p id="3245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个任务执行PowerShell脚本，该脚本使用三个Bicep文件来部署Azure静态Web应用程序。我使用<code class="fe nw nx ny nb b">-rgName $(resourceGroup)-qa</code>参数，它将我的QA环境的所有资源放在一个资源组中。注意，我之前创建的服务连接被用作inputs下的<em class="nk"> azureSubscription </em>的值。</p><h2 id="3b01" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">契约</h2><p id="c6be" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用Infura节点将合同部署到Rinkeby测试网络中。在<code class="fe nw nx ny nb b">qa</code>阶段的<code class="fe nw nx ny nb b">deploy_contracts</code>工作下，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0df4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意第12行，我将<em class="nk"> rinkeby </em>传递给<code class="fe nw nx ny nb b">--network</code>参数，并为<em class="nk"> API键</em>和<em class="nk">助记符</em>设置适当的环境变量。</p><h2 id="3537" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">前端</h2><p id="2c31" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">前端部署到部署在<code class="fe nw nx ny nb b">qa</code>阶段的<code class="fe nw nx ny nb b">iac</code>作业中的Azure静态Web应用程序中。在<code class="fe nw nx ny nb b">qa</code>阶段的<code class="fe nw nx ny nb b">deploy_frontend</code>作业下，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="07d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我对开发环境所做的那样，我想在完成之后删除QA环境。在删除QA环境之前，我希望有机会审查代码。为此，我使用了手动验证作业。一旦我批准了验证步骤，下一个作业就删除了Azure中的QA资源组，移除了我所有的资源。在<code class="fe nw nx ny nb b">qa_validation</code>阶段，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="b4f0" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">变量</h2><p id="92b2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">接下来，我通过<a class="ae ky" href="https://learn.microsoft.com/azure/devops/pipelines/process/set-secret-variables" rel="noopener ugc nofollow" target="_blank"> Azure DevOps UI </a>向我的管道添加了两个秘密变量。这些将设置我们在<em class="nk"> truffle-config.js </em>文件中使用的环境变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/d688ab3c8089f7645a42cda4a0c9386a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/0*qPkJkP-T-ViXEH00.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管道中增加了两个变量</p></figure><p id="794c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦管道完成了QA环境，信息就被添加到运行的<em class="nk">扩展</em>部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/ddf481922f69ec37e5180f287926962e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*6pUccVBNR7dvPD2m.png"/></div></figure><p id="a586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用提供的链接，我能够测试应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/7cc01eee8f67df4c0a1b007f04d98c41.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/0*cDQ-DJAk72MNyW60.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">连接到Rinkeby上运行的Dapp的Metamask wallet</p></figure><p id="d531" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我已经部署到了我的QA环境，在下一节中，我将展示如何部署到Mainnet。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="bd2e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">管道，产品</h1><p id="92f0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这最后一部分，我将介绍部署到以太坊主网需要做些什么。</p><p id="2354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为这个部分创建了一个名为“<a class="ae ky" href="https://github.com/DarqueWarrior/TruffleDevOps/tree/blog/part10" rel="noopener ugc nofollow" target="_blank"> blog/part10 </a>的新分支。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4b90" class="nf me it nb b gy ng nh l ni nj">git checkout -b blog/part10</span></pre><p id="2756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了部署到Mainnet，我需要一个Infura节点，就像我在Rinkeby中使用的那样。不像用Rinkeby，我需要一个用<strong class="lb iu"> <em class="nk">真实</em> </strong>以太的账号。使用我在上一篇文章中创建的同一个项目，我得到了Mainnet的<em class="nk">网络端点</em>。<em class="nk"> API密钥</em>对于所有网络都是相同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/5ed2bc8fa8c48470904d89c4041fde7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t4xu-p8RIy0vBQjB.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Infura项目设置(Mainnet)</p></figure><p id="190f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要部署到Mainnet，必须将网络添加到<em class="nk"> truffle-config.js中。</em>添加网络的最佳资源是官方的<a class="ae ky" href="https://trufflesuite.com/docs/truffle/reference/configuration/#networks" rel="noopener ugc nofollow" target="_blank"> Truffle套件文档</a>。</p><p id="302a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和Rinkeby一样，使用<code class="fe nw nx ny nb b">HDWalletProvider</code>，我将Mainnet添加到<em class="nk"> networks </em>部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="3772" class="md me it bd mf mg oc mi mj mk od mm mn jz oe ka mp kc of kd mr kf og kg mt mu bi translated">基础设施</h1><p id="f768" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在<em class="nk"> prod </em>阶段的<em class="nk"> iac </em>作业下，在<code class="fe nw nx ny nb b">azure-pipelines.yml</code>中，我增加了两个任务，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="ae65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个任务下载在管道的<em class="nk">构建</em>阶段创建的<em class="nk"> iac </em>工件。这个工件包含三个Bicep文件和一个PowerShell脚本。</p><p id="7081" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个任务执行PowerShell脚本，该脚本使用三个Bicep文件来部署Azure静态Web应用程序。我使用<code class="fe nw nx ny nb b">-rgName $(resourceGroup)-prod</code>参数，它将我的生产环境的所有资源放在一个资源组中。注意，我之前创建的服务连接被用作inputs下的<em class="nk"> azureSubscription </em>的值。</p><h2 id="8838" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">契约</h2><p id="5d92" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用Infura节点将合同部署到Mainnet中。在<code class="fe nw nx ny nb b">prod</code>阶段的<code class="fe nw nx ny nb b">deploy_contracts</code>工作下，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="9657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意第12行，我将<em class="nk"> mainnet </em>传递给<code class="fe nw nx ny nb b">--network</code>参数，并为<em class="nk"> API键</em>和<em class="nk">助记符</em>设置适当的环境变量。</p><p id="e47d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与开发和QA环境不同，不需要删除作为管道一部分的资源。因此，没有手动批准来删除资源组。</p><h2 id="eaec" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">前端</h2><p id="576b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">前端将被部署到部署在<code class="fe nw nx ny nb b">prod</code>阶段的<code class="fe nw nx ny nb b">iac</code>作业中的Azure静态Web App中。在<code class="fe nw nx ny nb b">prod</code>阶段的<code class="fe nw nx ny nb b">deploy_frontend</code>工作下，我添加了以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="56be" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">变量</h2><p id="eac6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">该阶段重复使用在第9部分的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/web3-meets-devops-pipeline-qa-d513d63ec0e">QA环境中创建的变量。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/dd7f67bcb539f94d9d3e08f26ec96c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/0*s1nHm7BoFc1Kc2ZF.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">管道中增加了两个变量</p></figure><p id="6f4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦管道完成，生产环境信息被添加到运行的<em class="nk">扩展</em>部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/057e476ca0ce4703fbe86b1d7460b742.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*0GQ02QW1V5lhHH-Z.png"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6722" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="0c8d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这篇文章记录了将DevOps最佳实践应用于Web3开发的过程。这可以通过添加额外的工具来扩展，例如代码和依赖扫描、静态代码分析和集成测试。</p><p id="e3c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管你开发的是什么类型的软件，实现DevOps最佳实践将会增加价值并提高你的团队的速度，同时减少错误。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h2 id="16e6" class="nf me it bd mf nl nm dn mj nn no dp mn li np nq mp lm nr ns mr lq nt nu mt nv bi translated">信用</h2><p id="a35f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">编辑:<a class="ae ky" href="https://cbrownauthor.com/" rel="noopener ugc nofollow" target="_blank">切尔西·布朗</a> <br/>技术回顾:<a class="ae ky" href="https://www.linkedin.com/in/brianbenz" rel="noopener ugc nofollow" target="_blank">布莱恩·本茨</a></p></div></div>    
</body>
</html>