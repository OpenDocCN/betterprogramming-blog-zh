<html>
<head>
<title>How To Leverage Encapsulation To Test the iOS Network Layer Properly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用封装来正确测试iOS网络层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-leverage-encapsulation-to-test-the-ios-network-layer-properly-7d09537dbc52?source=collection_archive---------6-----------------------#2021-09-01">https://betterprogramming.pub/how-to-leverage-encapsulation-to-test-the-ios-network-layer-properly-7d09537dbc52?source=collection_archive---------6-----------------------#2021-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松测试网络层</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/26999c3b0d6f00f48a48c729fbba0af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2W7kvdsiwMV9s16R"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@sickhews?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">韦斯·希克斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="7df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数应用程序都必须执行网络呼叫。我们需要它们从服务中检索数据、执行登录或者向远程服务器发送数据。</p><p id="114a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一天结束时，我们通常会在网络层上编写一个抽象，并且我们想要测试这一层。</p><p id="d0de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，测试网络层并不像看起来那么简单。网络固有地与外部依赖进行交互:后端。我们无法控制这种依赖性，如果我们依赖它，我们的测试就会变得缓慢、不可靠。</p><p id="8d6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望测试是<strong class="lb iu">快速</strong>、<strong class="lb iu">可靠、</strong>和<strong class="lb iu">可重复</strong>。为了实现这一点，我们需要隔离和排除这种外部依赖性。有不同的技术可以帮助我们实现这个目标，使测试更加可靠。最常见的方法是:</p><ul class=""><li id="3cdc" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">模仿后端的外部库(已知的几个有:<a class="ae ky" href="https://github.com/justeat/Shock" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">震撼</strong> </a>、<a class="ae ky" href="https://github.com/kylef/Mockingjay" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Mockingjay </strong> </a>、<a class="ae ky" href="https://github.com/WeTransfer/Mocker" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Mocker </strong> </a>)。</li><li id="0e5d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">定制机制来模仿像<code class="fe mj mk ml mm b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlprotocol" rel="noopener ugc nofollow" target="_blank">URLProtocol</a></code>这样的系统类(正如<a class="mn mo ep" href="https://medium.com/u/a7cfccf536da?source=post_page-----7d09537dbc52--------------------------------" rel="noopener" target="_blank">墨迹工程师</a>在这篇<a class="ae ky" href="https://www.theinkedengineer.com/articles/mocking-requests-using-url-protocol/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中所展示的)。</li></ul><p id="2db1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两种方法都是有效的，并在行业中广泛使用。我不喜欢这些方法的地方在于，它们引入了比我们实际需要的更多的复杂性。在前一种情况下，他们向我们的测试代码添加外部库。在这两种情况下，它们都需要大量样板代码来设置模拟和存根。最后，他们的速度没有想象中那么快。他们总是依赖于可能导致测试延迟的预期。没有它们我们也能进行测试。</p><p id="eac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天，我要提出一种不同的方法。它隐藏了这两种方法的复杂性，让我们更容易地测试我们真正需要的东西。</p><h1 id="5859" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">当前的解决方案</h1><p id="ccb3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了更好地理解所提出的方法的优点，我们应该首先看看测试通常是如何进行的。我将介绍一个标准网络层的简化接口和实现。然后，我将展示如何使用这种方法编写测试，强调各种复杂性。</p><p id="c9de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网络层有多种不同的实现方式。为了简单起见，让我们使用最广为人知的带有回调和<code class="fe mj mk ml mm b">Result</code>类型的<code class="fe mj mk ml mm b">Protocol</code>导向方法。我在这里介绍的一切都可以适用于<code class="fe mj mk ml mm b">Protocol Witnesses</code>和<strong class="lb iu">联合收割机。</strong></p><h2 id="55de" class="nm mq it bd mr nn no dn mv np nq dp mz li nr ns nb lm nt nu nd lq nv nw nf nx bi translated">界面</h2><p id="a1ce" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">所以，让我们为我们的<code class="fe mj mk ml mm b">NetworkClient</code>准备我们想要使用的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，我们有一个定义了<code class="fe mj mk ml mm b">NetworkClient</code>接口的协议。它为<code class="fe mj mk ml mm b">GET</code>提供了从<code class="fe mj mk ml mm b">URL</code>获取一些数据的可能性。</p><p id="4802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个接口是最基本的，但是我们可以将同样的推理应用于任何其他网络调用:<code class="fe mj mk ml mm b">POST</code>、<code class="fe mj mk ml mm b">PUT</code>、<code class="fe mj mk ml mm b">DELETE</code>等等。</p><h2 id="d743" class="nm mq it bd mr nn no dn mv np nq dp mz li nr ns nb lm nt nu nd lq nv nw nf nx bi translated">实施</h2><p id="9a4d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">为了实现这个接口，我们创建了一个<code class="fe mj mk ml mm b">LiveNetworkClient</code>类。为了执行网络调用，客户机接收一个<code class="fe mj mk ml mm b">URLSession</code>对象作为参数，利用<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8949" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用编号注释标记了代码的各个部分。有序列表中的每个数字对应于代码中的一个特定注释:</p><ol class=""><li id="61ca" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oa mb mc md bi translated">我们为我们的类型定义了一个自定义的<code class="fe mj mk ml mm b">NetworkError</code>。</li><li id="2bd9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们定义了一个注入到<code class="fe mj mk ml mm b">init</code>中的<code class="fe mj mk ml mm b">URLSession</code>属性。</li><li id="9066" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们协议的签字。</li><li id="b4ca" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们用我们的<code class="fe mj mk ml mm b">httpMethod</code>和<code class="fe mj mk ml mm b">headers</code>配置请求。</li><li id="262b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们开始<code class="fe mj mk ml mm b">dataTask</code>。别忘了第52行的<code class="fe mj mk ml mm b">.resume()</code>。</li><li id="87ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们处理错误(提前退出)。</li><li id="83e8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们提取了一些有用的信息。</li><li id="bf45" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们根据可能的选择来处理响应。</li></ol><p id="d939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码看起来不错:干净、可靠。现在是测试的时候了</p><h1 id="90ef" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">测试</h1><p id="9732" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们想测试一下，给定一组特定的参数(URL、标题等等)，我们从后端接收到一个特定的响应——数据或错误。</p><p id="9860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个障碍是如何控制<code class="fe mj mk ml mm b">URLSession</code>。最简单的方法是创建该类的模拟版本，以便我们可以覆盖它的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6af0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当涉及到测试时，我们可以编写如下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2347" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码中，我们首先为测试准备一些数据。我们有一个可解码的结构<code class="fe mj mk ml mm b">TestDecodable</code>,这是我们希望被(模仿的)后端接收的数据类型。而且我们有我们想要联系的<code class="fe mj mk ml mm b">URL</code>。</p><p id="f127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mj mk ml mm b">testGet_whenSucceeds()</code>方法中，我们初始化通过<code class="fe mj mk ml mm b">MockedURLSession</code>的<code class="fe mj mk ml mm b">LiveNetworkClient</code>。我们立即发现一些令人担忧的事情:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/50af5d329f28cdca42dbcba225f04f2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*yAuEP3ySy-ccifVTzqIAMQ.png"/></div></figure><p id="0de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不应该用默认的<code class="fe mj mk ml mm b">init</code>创建一个模拟会话:它已经被弃用，我们的测试可能会在未来的版本中中断。但目前这只是一个警告，我们可以接受。</p><p id="bb2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们带着期望完成测试，并处理结果。我们想测试快乐之路，成功了。如果出现网络错误或失败，我们决定失败，但最终，如果成功，我们将在变量中捕获接收到的对象。</p><p id="f7ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们必须断言接收到的数据与我们预期的数据相同。但是我们没有办法控制会话返回哪些数据。我们甚至不能检查我们实际上是在用正确的参数调用正确的URL！</p><p id="ca31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这些问题，我们可以尝试在<code class="fe mj mk ml mm b">MockURLSession</code>中覆盖<code class="fe mj mk ml mm b">dataTask</code>方法。归根结底，这就是我们创建该子类的原因。<code class="fe mj mk ml mm b">dataTask</code>签名如下:</p><pre class="kj kk kl km gt oc mm od oe aw of bi"><span id="15b3" class="nm mq it mm b gy og oh l oi oj">func dataTask(with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask</span></pre><p id="aff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这并不像看起来那么简单:</p><ol class=""><li id="e69f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oa mb mc md bi translated">该请求接收回调参数，但不会立即执行。</li><li id="9b32" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">该函数返回一个我们也必须返回的<code class="fe mj mk ml mm b">URLSessionDataTask</code>对象。</li><li id="d953" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">当在<code class="fe mj mk ml mm b">URLSessionDataTask</code>对象上调用<code class="fe mj mk ml mm b">resume</code>方法时，请求被执行。就在那时，回调被调用。</li></ol><p id="972e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些点意味着我们应该创建一个<code class="fe mj mk ml mm b">URLSessionDataTask</code>的子类并覆盖它的<code class="fe mj mk ml mm b">resume</code>方法。我们还应该找到一种方法，将调用<code class="fe mj mk ml mm b">resume </code>时必须调用的回调以及必须返回的数据传递给URLSessionDataTask。很可能，这需要将额外的数据传递给<code class="fe mj mk ml mm b">dataTask</code>方法，这样它就可以将数据传递给<code class="fe mj mk ml mm b">URLSessionDataTask</code>对象。</p><p id="fb30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们想要测试错误时，我们需要遵循与成功数据相同的路径。如果我们需要支持其他类型的任务，比如<code class="fe mj mk ml mm b">URLSessionUploadTask</code>，我们必须实现<code class="fe mj mk ml mm b">URLSessionTask</code>对象的许多子类，并复制代码来传递参数和调用回调。</p><p id="ca67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到，对于一个非常简单的测试，我们需要做多少工作。应该有更好的办法。</p><h1 id="3865" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">我们真正需要测试的是什么？</h1><p id="4f3d" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">回到问题的根源，我们对<code class="fe mj mk ml mm b">URLSession</code>如何工作的实现细节不感兴趣。</p><p id="db84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一种方法来模拟一个简单得多的行为:执行一个网络请求并调用一个回调，然后找到一种方法来实现这个行为。</p><h1 id="a0ff" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">解决方案</h1><p id="10a6" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们可以通过增加一个名为<code class="fe mj mk ml mm b">RequestExecutor</code>的新协议来做到这一点。我们可以让<code class="fe mj mk ml mm b">URLSession</code>符合协议，在生产中使用它。有了这个协议，我们可以创建一个我们完全控制的简单模拟实现。</p><p id="1bac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第一步，让我们创建<code class="fe mj mk ml mm b">RequestExecutor</code>协议，并让<code class="fe mj mk ml mm b">URLSession</code>符合它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，<code class="fe mj mk ml mm b">execute</code>方法的签名类似于<code class="fe mj mk ml mm b">dataTask</code>方法的签名。主要区别在于<code class="fe mj mk ml mm b">execute</code>方法返回的是<code class="fe mj mk ml mm b">Void</code>而不是自定义对象。</p><p id="bbc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使<code class="fe mj mk ml mm b">URLSession</code>符合协议，我们需要在扩展中实现<code class="fe mj mk ml mm b">execute</code>方法。该实现一个接一个地调用<code class="fe mj mk ml mm b">dataTask</code>和<code class="fe mj mk ml mm b">resume</code>方法。</p><p id="fb02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二步，我们可以修改我们的<code class="fe mj mk ml mm b">NetworkClient</code>类来使用这个新协议。代码更改如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6d9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">NetworkClient</code>没有太大变化。我们只是在第6、8和9行用<code class="fe mj mk ml mm b">requestExecutor</code>替换了所有对<code class="fe mj mk ml mm b">session</code>的引用。在这个方法中，我们使用了<code class="fe mj mk ml mm b">requestExecutor</code>而不是<code class="fe mj mk ml mm b">URLSession</code>对象，并且删除了对<code class="fe mj mk ml mm b">resume()</code>方法的调用。</p><p id="05f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将<code class="fe mj mk ml mm b">URLSession.shared</code>参考作为默认参数保留在<code class="fe mj mk ml mm b">init</code>中，以简化我们在生产中初始化<code class="fe mj mk ml mm b">NetworkClient</code>的方式。</p><p id="bc21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在产品代码中并不是一个大的改变，但是它极大地改进了我们的测试！</p><h1 id="eb31" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">测试</h1><p id="47ad" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">作为第一步，让我们为请求执行器创建一个模拟实现。我们想完全控制它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="26ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这个模拟，我们定义了两个属性:一个<code class="fe mj mk ml mm b">executeCount</code>和一个<code class="fe mj mk ml mm b">executeClosure</code>。计数器用于检查<code class="fe mj mk ml mm b">execute</code>函数被调用的次数。这可以防止我们忘记调用它的错误或者多次调用它的错误。</p><p id="c857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们有了<code class="fe mj mk ml mm b">executeClosure</code>。这是在我们的测试中控制模拟依赖的一种方法:我们可以在编写测试时注入我们需要的代码。默认值是一个失败的闭包:它允许我们检查我们没有在不应该的时候调用依赖项。如果一个组件在不应该的时候调用请求执行器，测试就会失败，因为我们不会在组件的测试中设置闭包。如果一个组件需要网络，而我们忘记设置闭包，测试就会失败。这是一种安全的方法，可以反复检查各种组件的方法是否如我们预期的那样运行。</p><p id="e668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">execute</code>的实现很简单:我们递增计数器，然后调用闭包。注意执行人是<strong class="lb iu">而不是</strong>直接调用回调；测试必须使用正确的参数在正确的时间调用它。</p><p id="22f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用下面的代码来看看我们的测试是如何变化的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><ol class=""><li id="03d5" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu oa mb mc md bi translated">我们定义了代表后端返回数据的<code class="fe mj mk ml mm b">TestDecodable</code>结构。</li><li id="6bec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们定义想要联系的URL。</li><li id="31db" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们定义后端返回的JSON，并且我们的代码应该解码。</li><li id="f6d7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">在<code class="fe mj mk ml mm b">testGet_whenSucceed()</code>方法中，我们准备了测试中需要使用的变量:<code class="fe mj mk ml mm b">mockRequestExecutor</code>和<code class="fe mj mk ml mm b">liveNetworkClient</code>。</li><li id="3c6f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们配置<code class="fe mj mk ml mm b">mockExecutor.executeClosure</code>。在这个闭包中，我们需要做两件事:断言参数正是我们期望的参数；向测试提供正确的数据，用正确的参数调用回调。</li><li id="9682" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们作用于<code class="fe mj mk ml mm b">liveNetworkClient</code>，执行网络请求。在回调中，我们处理结果。</li><li id="1bae" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu oa mb mc md bi translated">我们断言我们只执行一个网络请求:我们不想执行多个请求。</li></ol><p id="6b67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意另一件事:我们去除了所有的期望——以及它们的延迟！我们完全控制流程，可以同步执行所有代码。不再需要期待了。测试现在已经尽可能快了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a14cde8b77d37b6faf12bc38bbd7994f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*dpGuUfMTOPFje6rAzCEygg.png"/></div></figure><p id="f6db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以非常容易地编写所有其他测试用例——只需用不同的数据替换回调参数并相应地断言。</p><h1 id="0c71" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="3b5e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在今天的文章中，我们看到了如何在没有外部依赖或样板文件的情况下测试应用程序中的网络层。</p><p id="2e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的工作原理是对iOS中如何执行网络调用的实现细节进行抽象。我们正在应用一个可靠的原则，即<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置</a>:</p><blockquote class="ol om on"><p id="0290" class="kz la oo lb b lc ld ju le lf lg jx lh op lj lk ll oq ln lo lp or lr ls lt lu im bi translated">“抽象不应该依赖于细节。细节(具体实现)应该依赖于抽象。”</p></blockquote><p id="c14f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b">NetworkClient</code>是一个抽象，不应该依赖于<code class="fe mj mk ml mm b">URLSession</code>的实现细节。</p><p id="def4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能够去除所有的期望，完全控制我们的依赖。我们实现了<strong class="lb iu">快速</strong>、<strong class="lb iu">可靠、</strong>和<strong class="lb iu">可重复</strong>测试。</p><p id="9773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这也允许我们实施更严格的测试。我们不仅可以检查代码是否如我们预期的那样工作，还可以检查<code class="fe mj mk ml mm b">execute</code>方法被调用了多少次，我们是否用正确的参数调用了它，以及它是否用在了不应该用的地方。</p></div></div>    
</body>
</html>