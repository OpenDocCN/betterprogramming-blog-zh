<html>
<head>
<title>Build a Rock, Paper, Scissors Game With SwiftUI and Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SwiftUI和Combine构建一个石头、布、剪刀游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/combine-roshambo-a3ea27784e4e?source=collection_archive---------2-----------------------#2020-04-18">https://betterprogramming.pub/combine-roshambo-a3ea27784e4e?source=collection_archive---------2-----------------------#2020-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c09b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">反应式游戏编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7cfe8044e58da8617bfeaa2cdb453c6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rw6YUeACreeXd7Ah4aTGw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者恩佐克洛普——自己的作品，CC BY-SA 3.0，<a class="ae kv" href="https://commons.wikimedia.org/w/index.php?curid=27958688" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=27958688</a></p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ba20" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">介绍</h1><p id="30d7" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank"> Combine </a>是苹果版的函数式反应式编程。据苹果公司称，这是一个声明性的Swift API，用于处理随时间变化的值。函数式反应范式是函数式编程与反应式编程的结合。</p><p id="ac17" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在函数式编程中，一切都被建模为函数。当使用范例时，程序避免改变程序的状态或改变数据。这种范式与反应范式相结合。反应式编程支持异步数据流和事件流的处理。由于这个原因，当使用UI时，例如键盘输入或按钮点击，它工作得非常好。</p><p id="e5ff" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">将这两者结合起来创建了一种编程范式，在这种范式中，事件或异步调用用函数来处理。这是我第一次尝试使用Combine或任何类型的函数式反应式编程。我会做一个基本的Roshambo(石头，剪子，布)游戏。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="926a" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">出版者</h1><p id="4179" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">发布者是数据的提供者。在这个迷你应用程序中，第一个发布者将成为用户选择的输入。我将发布来自用户的事件。当用户打开应用程序时，我们将为他们提供三个选项:水，火和草。火战胜草。草战胜水。水战胜火。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/fce107023dc20ef3ac3cea9f2d46e503.png" data-original-src="https://miro.medium.com/v2/resize:fit:628/format:webp/1*GqN0mzp-_lb7X2xEsnkkuQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">内容视图. swift</p></figure><p id="d1c1" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">Roshambo的迷你应用程序的所有代码都可以在我的<a class="ae kv" href="https://github.com/thenerdassassin/CombineTutorial-Roshambo" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。<code class="fe mx my mz na b">ContentView</code>类有一个叫做<code class="fe mx my mz na b">App</code>的<code class="fe mx my mz na b">EnvironmentObject</code>，我用它来管理合并逻辑。当我完成本教程时，<code class="fe mx my mz na b">ContentView</code>将会是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="1555" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><code class="fe mx my mz na b">App</code>对象在<code class="fe mx my mz na b">SceneDelegate</code>内的场景函数中实例化，并设置为环境对象。当使用<code class="fe mx my mz na b">ObservableObject</code>协议时，创建一个发布者再容易不过了。唯一需要添加的是一个简单的注释，<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank">@Published</a>.</code>下面是第一个发布者:</p><pre class="kg kh ki kj gt nd na ne nf aw ng bi"><span id="e641" class="nh le iq na b gy ni nj l nk nl"><strong class="na ir">class</strong> App: ObservableObject {<br/>  @Published <strong class="na ir">var</strong> user: Player<br/>}</span></pre><p id="ff9d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在，每当<code class="fe mx my mz na b">Player</code>对象<code class="fe mx my mz na b">user</code>改变时，它将提供更新的数据。<code class="fe mx my mz na b">ChooseElementView</code>为用户提供能够选择选项的按钮。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3cbd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">当按下其中一个Roshambo按钮时，它将更新<code class="fe mx my mz na b">Player</code>对象中的元素。这是因为在创建元素视图时实例化的<code class="fe mx my mz na b">ChooseElementView</code>中的<code class="fe mx my mz na b">selectedElement</code>与<code class="fe mx my mz na b">ChooseElementView(selectedElement: $app.user.element</code>之间存在绑定</p><p id="4360" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><code class="fe mx my mz na b">Player</code>对象是另一个简单的<code class="fe mx my mz na b">ObservableObject</code>，它有一个发布的变量。</p><pre class="kg kh ki kj gt nd na ne nf aw ng bi"><span id="7d96" class="nh le iq na b gy ni nj l nk nl"><strong class="na ir">class</strong> Player: ObservableObject {<br/>  @Published <strong class="na ir">var</strong> element = Element.none<br/>}</span></pre><p id="28bd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在SwiftUI中，<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/observableobject" rel="noopener ugc nofollow" target="_blank">ObservableObject</a></code>协议是一个非常强大的概念。它使得创建发布者变得容易。<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/published" rel="noopener ugc nofollow" target="_blank">@Published annotation</a></code>内置于联合收割机中。发布者将在属性更改时触发。发行者的输出类型是从属性的类型推断出来的。在这种情况下，发布者类型是<code class="fe mx my mz na b">&lt;Element, Never&gt;</code>，这意味着数据类型是<code class="fe mx my mz na b">Element</code>，没有失败。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="3dea" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">订户</h1><p id="d301" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">没有订阅者的发布者没有多大价值。订阅方从发布方请求并接收数据。在发布服务器收到订阅请求之前，它不会发送任何数据。为了让订阅服务器从发布服务器请求数据，订阅服务器的输入类型必须与发布服务器的输出类型相匹配。</p><p id="7e8b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在我的Roshambo迷你app里，对手，<code class="fe mx my mz na b">CopyCatPlayer</code>，跟他对战真的很烦。她总是等着看我们怎么做，做出同样的选择！所以比赛结果总是平局。</p><p id="b5ca" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这将由订阅发布者的<code class="fe mx my mz na b">CopyCatPlayer</code>实现。当发布者发送一个新值时，另一个玩家会监听，等待一小段时间，然后做出相同的选择。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a9bc23e753edc8080ac63331eefb0bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*PN5fJCl2R7zabUahRQIHpQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">抄袭者</p></figure><p id="5ab0" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><code class="fe mx my mz na b">CopyCatPlayer</code>将由发布者初始化。当用户做出选择时，这将导致<code class="fe mx my mz na b">CopyCatPlayer</code>更新所选的<code class="fe mx my mz na b">Element</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7d71" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/currentvaluesubject/3235789-assign" rel="noopener ugc nofollow" target="_blank">Assign</a></code>是订户。它使用publisher，一旦对手做出选择，就将发布的值设置为自己的元素变量。参考存储在<code class="fe mx my mz na b">cancellableSet</code>中，因此用户将在<code class="fe mx my mz na b">CopyCatPlayer</code>的整个生命周期内操作。</p><p id="b4c7" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">然后将对手加入<code class="fe mx my mz na b">App.swift</code>类。对手也发表了所以<code class="fe mx my mz na b">ContentView</code>可以更新。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="8abe" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">当<code class="fe mx my mz na b">CopyCatPlayer</code>被实例化时，发布者使用<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/publisher/3241548-erasetoanypublisher" rel="noopener ugc nofollow" target="_blank">eraseToAnyPublisher</a></code>函数来提供一个更干净的类型。这可以在任何发布者上完成。它允许订户维护底层实现的抽象。</p><p id="9c53" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在有一个<code class="fe mx my mz na b">CopyCatPlaye</code> r将模仿用户的选择，这是使用<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/currentvaluesubject/3235789-assign" rel="noopener ugc nofollow" target="_blank">assign </a></code>s<a class="ae kv" href="https://developer.apple.com/documentation/combine/currentvaluesubject/3235789-assign" rel="noopener ugc nofollow" target="_blank">subscriber</a>完成的。为了让对手在复制之前有一个延迟，我需要引入一个新的概念:操作符。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="4c21" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">操作员</h1><p id="1fd1" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">操作符可以说是Combine最重要的元素之一。他们是出版商和订户之间的中介。操作符可以用于许多目的，包括但不限于改变事件的时间、转换数据、过滤，甚至将多个发布者组合成一个数据源。</p><p id="5275" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我要看的第一个操作符将改变<code class="fe mx my mz na b">CopyCatPlayer</code>的定时。这将使<code class="fe mx my mz na b">CopyCatPlayer</code>的选择延迟200毫秒。为了实现这一点，需要两个操作符:<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/passthroughsubject/3204599-debounce" rel="noopener ugc nofollow" target="_blank">debounce</a></code>和<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/publisher/3204743-receive" rel="noopener ugc nofollow" target="_blank">receive</a></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="15a4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><code class="fe mx my mz na b">debounce</code>操作符用于延迟事件。它需要两个参数:等待的时间和操作员交付事件的调度程序。<code class="fe mx my mz na b">receive</code>操作符用于接收指定调度程序上的事件。很容易想象这两个运算符是如何经常一起使用的。</p><p id="d5e9" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">为了展示使用操作符的更强大的方法，我们将创建一个新的对象<code class="fe mx my mz na b">Game</code>，来订阅我们玩家的元素，以便计算Roshambo游戏的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/668606a9b48799d1c6ad1abecd99bc90.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*Bfsm-Kq3eMj4NTYKwQGIKQ.png"/></div></figure><p id="2522" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><code class="fe mx my mz na b">Winner</code>枚举有三个选项。赢家可能是玩家一(我们的用户)，玩家二(对手)，或者都不是(平局)。</p><pre class="kg kh ki kj gt nd na ne nf aw ng bi"><span id="e0c5" class="nh le iq na b gy ni nj l nk nl"><strong class="na ir">enum</strong> Winner {<br/>  <strong class="na ir">case</strong> one, two, neither<br/>}</span></pre><p id="c25c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated"><code class="fe mx my mz na b">Game</code>对象将发布<code class="fe mx my mz na b">Winner</code>，这样我们的<code class="fe mx my mz na b">ContentView</code>就可以告诉用户谁赢了游戏。为了计算<code class="fe mx my mz na b">Winner</code>，它将由两个发布者初始化，每个发布者对应一个玩家。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="2515" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">使用名为<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/publishers/combinelatest" rel="noopener ugc nofollow" target="_blank">CombineLatest</a></code>的操作符将两个发布者组合在一起，该操作符将从每个发布者处获取最新的两个元素。因此输入是两个<code class="fe mx my mz na b">Element</code>对象，但是操作符将数据类型转换为一个元素元组— <code class="fe mx my mz na b">(Element, Element)</code>。然后使用一个大多数人都熟悉的新运算符，<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/publisher/3204718-map" rel="noopener ugc nofollow" target="_blank">map</a></code>。<code class="fe mx my mz na b">map</code>操作符使用闭包将数据类型从<code class="fe mx my mz na b">(Element, Element)</code>转换为<code class="fe mx my mz na b">Winner?</code>。这是闭包中使用的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="79af" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">来自<code class="fe mx my mz na b">map</code>操作符的返回类型被分配给获胜者变量。获胜者变量随后被发布，因此<code class="fe mx my mz na b">ContentView</code>可以基于获胜者进行更新。<code class="fe mx my mz na b">App</code>对象已更新，添加了<code class="fe mx my mz na b">Game</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="833c" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们的游戏还有一部分我需要添加。如果用户只能玩一次就不好玩了。我需要重新开始比赛。为了实现这个目标，我需要教授科目，一个新的联合课题。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0ac1" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">科目</h1><p id="0ab9" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">Combine有一个特殊类型的发布者，<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/subject" rel="noopener ugc nofollow" target="_blank">Subject</a></code>。这是一个发布者可以遵守的协议，它将添加一个方法:<code class="fe mx my mz na b">send()</code>。使用此发布程序是为了将项目注入到流中，并将值广播给订阅者。</p><p id="dbc6" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">联合收割机内置的<code class="fe mx my mz na b">Subject</code>有两种:<code class="fe mx my mz na b">PassthroughSubject</code>和<code class="fe mx my mz na b">CurrentValueSubject</code>。两者唯一不同的是<code class="fe mx my mz na b">CurrentValueSubject</code>需要一个初始值。两者都将发送更新的值。</p><p id="11c9" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我准备加一个<code class="fe mx my mz na b">Subject</code>重置。当复位按钮被按下时，我会发出一个<code class="fe mx my mz na b">Bool</code>。创建<code class="fe mx my mz na b">PassthroughSubject</code>几乎和任何其他发行商一样简单。所以<code class="fe mx my mz na b">App</code>对象的最终结果是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7e4d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">新的发布者将被添加到<code class="fe mx my mz na b">Player</code>类，这样用户和对手都可以处理重置。这将引入一个新订户<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.apple.com/documentation/combine/publisher/3343978-sink" rel="noopener ugc nofollow" target="_blank">sink</a></code>。它将简单地接收值并执行闭包。在这种情况下，将<code class="fe mx my mz na b">Player</code>的元素设置回<code class="fe mx my mz na b">none</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e1ed" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这使得重置具有极大的可扩展性。如果添加了新的UI元素，它只需要订阅reset主题。如果没有发布者，reset函数将必须包含要更新的对象或UI的所有逻辑。这个函数会变得非常脆弱。现在，如何重置的逻辑包含在需要更新的元素或类中。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="b0ac" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="a0c6" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">Combine非常强大，可以在整个Swift中使用。它是SwiftUI的核心特性，但也可以用于许多其他用例，包括网络请求、错误处理和异步操作。本教程通过介绍基本术语和概念仅仅触及了皮毛。我将继续探索用Combine还能做什么，以及如何开始用函数式反应式编程范式思考。</p><p id="6145" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果这个话题让你感兴趣，这里有优秀的免费信息，包括模式和食谱，由<a class="ae kv" href="https://heckj.github.io/swiftui-notes/" rel="noopener ugc nofollow" target="_blank"> Joseph Heck </a>和<a class="ae kv" href="https://developer.apple.com/documentation/combine/receiving_and_handling_events_with_combine" rel="noopener ugc nofollow" target="_blank"> Apple的文档</a>撰写。</p></div></div>    
</body>
</html>