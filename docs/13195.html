<html>
<head>
<title>Convert Kotlin Suspending Functions Into Swift’s async/await With Adapter Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Kotlin暂停功能转换为Swift的async/await With Adapter模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-suspending-functions-as-swift-async-await-with-adapter-pattern-a79aacaa5b1c?source=collection_archive---------5-----------------------#2022-08-05">https://betterprogramming.pub/kotlin-suspending-functions-as-swift-async-await-with-adapter-pattern-a79aacaa5b1c?source=collection_archive---------5-----------------------#2022-08-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9c3e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从Swift的角度来看，在使用Kotlin的共享代码时，充分利用最新的API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ae9a225b893940b1cfe0033ce18e769f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcziQR2opzadsEm5f7mqgQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">丹·丹尼斯在<a class="ae kv" href="https://unsplash.com/s/photos/ropes-knot?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="d096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，我不得不参与一个Kotlin多平台移动项目，在这个项目中，表示逻辑是特定于平台的，只有业务逻辑是共享的。</p><p id="5ff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序是在固定(并且很少)数量的用例上实现的——大多数用例在每个屏幕上都可用，但是在某种不同的调用上下文中。</p><p id="5200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin/Native与Swift/Objective-C的互操作性将Kotlin挂起函数呈现为iOS端带有完成处理程序的<em class="ls">函数。</em></p><p id="9a73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的完成处理程序API不是最令人愉快的API，尤其是当需要在iOS端以特定的顺序执行许多挂起函数(作为完成处理程序可用)时。这可能很快导致回调地狱。</p><h1 id="e183" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">什么是完成处理程序？</h1><p id="e514" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">完成处理程序是在未来某个时间调用的回调。它们可以交付已完成操作的结果，通知错误，或者只是在满足特定条件时被调用。</p><p id="a704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码片段包含一个演示示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">完成处理程序的示例</p></figure><p id="729a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于完成处理器的更多信息可以在<a class="ae kv" href="https://medium.com/@dhavalkansara51/swift-closures-with-completion-handler-de2d9f2fdd4f" rel="noopener">这里</a>找到。</p><h1 id="bf16" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">回调地狱的解决方案</h1><p id="11fa" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在某些情况下，回调地狱的一个解决方案被认为是足够好的，那就是实现一个适配器模式，使完成处理程序API适应异步/等待Swift API。</p><p id="6795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该解决方案提供了一种在iOS端有效使用挂起功能的简单方法。值得考虑的是，这种模式增加了一些样板文件，并且通常必须为每个功能手工实现。考虑到缺点，这个解决方案仍然值得一试。</p><p id="f62a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下部分将描述如何实现async/await适配器的完成处理程序的最基本版本。</p><p id="9abc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">本文中的示例只是一个演示性示例，展示了如何使用Swift continuation API将挂起函数的完成处理程序转换为async/await，这对处理Kotlin多平台代码的iOS开发人员非常有用。</em></p><h1 id="e444" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">什么是适配器设计模式？</h1><p id="e368" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一个<a class="ae kv" href="https://refactoring.guru/design-patterns/adapter" rel="noopener ugc nofollow" target="_blank">适配器设计模式</a>是一个流行的结构设计模式，它允许具有不兼容接口的对象一起工作。Android世界中流行的适配器模式实现之一是<code class="fe ms mt mu mv b"><a class="ae kv" href="https://developer.android.com/guide/topics/ui/layout/recyclerview" rel="noopener ugc nofollow" target="_blank">RecyclerView</a></code> adapter。</p><p id="1611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">async/await adapter的完成处理程序的以下实现并没有严格遵循adapter模式的实现，但它可以被视为adapter模式的实现，因为它解决了设计模式旨在解决的问题。</p><h1 id="3695" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">简单实现</h1><p id="388e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">将下面的例子看作是一个位于共享Kotlin多平台模块中的用例，它模拟了一些需要花费时间来完成的工作(比如一个API请求):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例使用案例</p></figure><p id="9338" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift语言在很多方面与Kotlin不同。</p><p id="c2e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个是<a class="ae kv" href="https://kotlinlang.org/docs/exceptions.html#checked-exceptions" rel="noopener ugc nofollow" target="_blank">检查异常</a>的概念Swift有而Kotlin没有。</p><p id="1b42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">挂起的<a class="ae kv" href="https://kotlinlang.org/docs/native-objc-interop.html#errors-and-exceptions" rel="noopener ugc nofollow" target="_blank">函数必须用</a> <code class="fe ms mt mu mv b"><a class="ae kv" href="https://kotlinlang.org/docs/native-objc-interop.html#errors-and-exceptions" rel="noopener ugc nofollow" target="_blank">@Throws </a></code>进行注释，后跟预期会发生的异常(它们的类)(其中一个当然是<code class="fe ms mt mu mv b">CancellationException</code>)。</p><p id="4fb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">得益于此，它们在完成处理程序的调用中作为<code class="fe ms mt mu mv b">NSError</code>传播，并且可以在iOS端轻松处理。</p><p id="a936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">ExampleUseCase</code>的API将作为下面的完成处理程序在iOS端可用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过完成处理器API使用Swift代码的暂停功能</p></figure><p id="8ad6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使它与async/await兼容，让我们创建一个作为适配器的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例用例适配器</p></figure><p id="be52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在创建一个函数来适应<code class="fe ms mt mu mv b">ExampleUseCaseAdapter</code>中<code class="fe ms mt mu mv b">ExampleUseCase</code>的行为。</p><p id="a4fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单的代表平台模型的<code class="fe ms mt mu mv b">struct</code>和一个示例错误<code class="fe ms mt mu mv b">enum</code>被添加来显示处理错误和执行一些映射的可能性(这里的映射不违反SRP原则吗？把你的想法写在评论区)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例UseCaseAdapter实现</p></figure><p id="78db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ms mt mu mv b">getSomeExampleData</code> —标有<code class="fe ms mt mu mv b">async throws</code> —函数<code class="fe ms mt mu mv b"><a class="ae kv" href="https://developer.apple.com/documentation/swift/withcheckedthrowingcontinuation(function:_:)" rel="noopener ugc nofollow" target="_blank">withCheckedThrowingContinuatio</a>n</code>(可以认为是类似于<code class="fe ms mt mu mv b"><a class="ae kv" href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html" rel="noopener ugc nofollow" target="_blank">suspendCancelableCoroutine</a>)</code>的东西)提供了<code class="fe ms mt mu mv b">continuation</code>，它根据完成处理程序中提供的结果恢复特定的数据。</p><ol class=""><li id="cd82" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">如果提供给closure的<code class="fe ms mt mu mv b">data</code>不是<code class="fe ms mt mu mv b">nil</code>，代码将恢复，并将<code class="fe ms mt mu mv b">data</code>的值映射到预期的返回类型。</li><li id="9d7a" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">如果来自<code class="fe ms mt mu mv b">@Throws</code>的异常发生(不是<code class="fe ms mt mu mv b">nil</code>)，代码将失败恢复。这里是处理错误的地方。控制可以被传递给一些通用的解决方案，例如，将区分<code class="fe ms mt mu mv b">CancelationException</code>和其他异常(其中一个是原因)，这例如将导致更多信息的失败原因。</li><li id="d42c" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">如果数据为<code class="fe ms mt mu mv b">nil</code>且错误也为<code class="fe ms mt mu mv b">nil</code>，则代码继续，并出现Swift错误(将由<code class="fe ms mt mu mv b">withCheckedThrowingContinuation</code>抛出)，在本例中，该错误是为该示例定义的<code class="fe ms mt mu mv b">ExampleAdapterError.errorWithAsync</code>。这种行为应该根据您的要求进行调整。</li></ol><p id="bea5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于上面的实现，在适配器的帮助下，用例代码可以使用async/await API来执行。</p><p id="3ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑以下发布某种数据元素的视图模型实现的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例视图模型实现</p></figure><p id="ee9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用async/await API，当调用<code class="fe ms mt mu mv b">fetchData</code>时，元素很容易被强制地和优雅地提供非初始值。</p><p id="9157" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子可能看起来微不足道，但是想象一下有许多<a class="ae kv" href="https://levelup.gitconnected.com/from-callbacks-to-async-await-in-swift-aebd38ab0f13" rel="noopener ugc nofollow" target="_blank">完成处理程序</a>——一个适配器可以很容易地避免平台表示中的回调地狱。</p><h1 id="e45a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">所有的工作都值得争论吗？</h1><p id="5d3f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如上所述，现在使用适配器包装的共享代码允许使用现代的<code class="fe ms mt mu mv b">async/await</code> API来处理iOS端的挂起功能。</p><p id="9767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的手动实现可以被认为是混合了样板文件的过度工程化。从另一个角度来看，当一个用例(或任何具有挂起功能的东西)在应用程序中的许多地方被广泛使用时，应用程序的其他部分以某种方式依赖于它的数据，或者有许多异步函数要同时或以特定顺序调用，那么手动适配器就值得考虑。</p><p id="65b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">适用于<code class="fe ms mt mu mv b">async/await</code>的作为完成处理程序的挂起函数更容易使用，更容易测试，并且降低了源代码的复杂性。</p><p id="3fa4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理可空结果和错误的样板代码可以提取到其他一些通用函数中，以便更好地处理它。此外，特定的适配器也可以重构为更通用的实现。由于这一点，样板文件可以减少。</p><h1 id="1857" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">取消怎么办？</h1><p id="d7e0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">正如Michał Klimczak在评论部分提到的，通常在处理暂停函数时，注意取消以防止内存泄漏和节省资源是很重要的。</p><p id="584e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">表示挂起函数的完成处理程序不支持取消，并且不能被取消。</p><p id="881e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在许多情况下，完成处理程序到<code class="fe ms mt mu mv b">async/await</code>的简单手动适配器已经足够好了。正确处理取消是一个好的做法，在特殊情况下，这是一个必须具备的机制。</p><p id="9a0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个典型的问题是挂起函数的自适应，它执行一些耗时的操作，同时使用回调无限地通知结果。以下面的代码为例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">暂停函数定期调用回调</p></figure><p id="b6c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Android端，可以简单地取消启动它的协程来停止回调，而iOS端的完成处理程序无法做到这一点。</p><p id="461a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里的一个解决方案是重构代码，将回调表示为将发出结果的<code class="fe ms mt mu mv b">Flow</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">流量周期性发射值</p></figure><p id="f21a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以很容易地调整<code class="fe ms mt mu mv b">Flow</code>来提供一个API，知道它是在哪个协程中启动的，并且还简化了iOS端的值收集。这里最大的问题是，<code class="fe ms mt mu mv b">Flow</code>是Kotlin中的一个接口，在转换为Swift后，它失去了它的泛型类型。这可以通过使用一个类作为adapter⁴来解决，该类保存由<code class="fe ms mt mu mv b">Flow</code>发出的一般类型的项目。考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">简单的流量适配器实施</p></figure><p id="296b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码位于一个共享模块中。subscribe函数为iOS提供了一个简单的基于回调的API和一个scope参数来启动其中的<code class="fe ms mt mu mv b">Flow</code>。当满足特定条件时，可以在以后取消该范围。</p><p id="9372" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，它可以很容易地适应iOS端，类似于以前的async/await适配器示例。</p><h1 id="7db8" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated"><strong class="ak">如何在iOS上取消流量？</strong></h1><p id="3bb7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">第一件事是提供一个作用域，它可以是一个实用程序类，根据特定的用例用足够的<code class="fe ms mt mu mv b">CoroutineContext</code>元素实现一个<code class="fe ms mt mu mv b">CoroutineScope</code>接口。请考虑下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e02f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码片段above⁴添加了一个关闭作用域的函数，这实际上取消了内部的<code class="fe ms mt mu mv b">job</code>。</p><p id="1a35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以在平台的<code class="fe ms mt mu mv b">Flow</code>适配器中添加范围取消逻辑，例如在iOS端使用<code class="fe ms mt mu mv b"><a class="ae kv" href="https://developer.apple.com/documentation/swift/withtaskcancellationhandler(handler:operation:)" rel="noopener ugc nofollow" target="_blank">withTaskCancellationHandler</a></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Swift中的异步流量适配器</p></figure><p id="bd23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当运行异步函数的任务将被取消时，作用域将被取消。</p><p id="ba03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">交付更新的逻辑只是一个信息示例，应根据需要进行调整。</em></p><p id="75fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的一件重要事情是，取消逻辑不需要这样做。</p><p id="c531" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据用例的不同，用于收集<code class="fe ms mt mu mv b">Flow</code>的范围可以与其他挂起操作共享。因此，取消可以在进行调用的对象(如平台<code class="fe ms mt mu mv b"><a class="ae kv" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank">ViewModel</a></code>)的反初始化时被调用，而不是单个任务的取消。这些只是手动改编Kotlin <code class="fe ms mt mu mv b">Flow</code>时必须考虑的一些实现细节。</p><p id="3a91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在实现如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">AsyncFlowAdapter的用法</p></figure><p id="b219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在ExampleViewModel内部，函数更新可以像下面这样使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ExampleUseCaseAdapter的用法</p></figure><p id="0169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的片段中给出的例子是一个无限冷流的适应过程，但是适配器实现对于热流也是类似的。</p><p id="2fa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将适配器移至共享代码，以便在运行于作为适配器参数公开的作用域中的协程主体内执行一些挂起操作，这是取消问题的解决方案。</p><p id="3438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe ms mt mu mv b">Flow</code>来说，编写一个通用的适配器很容易，但是并不是所有的东西都可以成为<code class="fe ms mt mu mv b">Flow</code>。仍然需要使用暂停功能以及提供取消机制。这些情况下的适配器需要为共享代码中的每个单个挂起函数手动编写，以便稍后在平台端进行调整。这使得在iOS中使用挂起功能所需的样板文件增加了一倍。记住所有的要求(易用性，取消处理)，这基本上是一个没有解决方案。</p><h1 id="919b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">样板文件的解决方案</h1><p id="895a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">好消息是，有一些库可以帮助减少需要手工编写的代码量。</p><p id="89f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中之一是一个名为<a class="ae kv" href="https://github.com/FutureMind/koru" rel="noopener ugc nofollow" target="_blank"> Koru </a>的库，由Michał Klimczak创建，它使用<a class="ae kv" href="https://kotlinlang.org/docs/ksp-overview.html" rel="noopener ugc nofollow" target="_blank"> KSP </a>来生成包装器，用于暂停某些类和接口中的函数，这些类和接口用注释标记，然后允许代码生成。所生成的包装器包含具有API的函数，这些函数具有作用域参数以及针对它们执行的操作的成功和失败的回调。这个API可以很容易地适应异步/等待。</p><p id="db5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在未来，Koru可能会为iOS提供基础适配器(包装器),这将使适配过程更加顺畅。</p><p id="cc27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个不基于注释处理器生成源代码的解决方案是<a class="ae kv" href="https://github.com/rickclephas/KMP-NativeCoroutines" rel="noopener ugc nofollow" target="_blank">KMP-本地例程</a>。这个库使用所谓的<a class="ae kv" href="https://kotlinlang.slack.com/archives/C3PQML5NU/p1659266993874829?thread_ts=1659099843.729999&amp;cid=C3PQML5NU" rel="noopener ugc nofollow" target="_blank">“编译器方法”</a>并利用Kotlin-ObjC互操作。该解决方案提供了通用类型的流实现，解决了取消支持的问题，并且不需要用注释来标记代码就可以正常工作(这里的注释用于禁止某些函数的生成)。</p><p id="fed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这种方法在编译过程中有一些递归错误的问题，但是，根据库作者Rick Clephas 的说法，库中有很多改进的计划。</p><p id="e936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当需要从iOS调用的挂起函数数量增加时，这两种解决方案都值得一试。同样的情况也适用于无法使用API的情况，API很容易手动调整，同时仍然能够感知取消。要记住的重要一点是，这两个库都是开源解决方案。这意味着它们需要由维护者和社区来更新，以便跟上快速发展的Kotlin环境和可能出现的潜在错误。</p><p id="f150" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于那些仍然对使用第三方库持怀疑态度的人来说，还有另一个主要适用于绿地项目的解决方案。那就是考虑需要调用的挂起函数的量是不是不能通过一些架构上的改变来减少。</p><p id="4a09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中一个变化可能是将表示逻辑(在许多情况下是使用基于挂起功能的共享业务逻辑)推到共享代码的重构。这可能导致暂停功能的数量减少到只有表示状态/副作用的可适应的流集合(MVVM，MVI ),或者导致在平台侧(MVP)使用完全没有暂停功能的同步视图接口(协议)实现。</p><h1 id="fdf6" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="c3a0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用适配器模式将完成处理程序转换为async/await使得代码可读性更好，使用起来也更愉快。</p><p id="e22c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好处包括对运行代码的更多控制、简单的测试和通用模式的封装(如错误处理)。</p><p id="0c5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在还没有在iOS端使用挂起功能的灵丹妙药。</p><p id="72f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">手动适配器实现的缺点主要包括样板文件和缺少取消功能，因此在手动实现之前，总是值得三思，以确保手动实现符合预期。本文中描述的替代解决方案和规避可能有助于提供满足预期需求的解决方案。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="2b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin/Native interoperability还提供了一个从挂起函数生成的async/await API，但是正如文档中提到的，<a class="ae kv" href="https://kotlinlang.org/docs/native-objc-interop.html#suspending-functions" rel="noopener ugc nofollow" target="_blank">它们只是为了好玩</a>。将来，可能不再需要适配器，但是现在，手动实现可能是一条出路。</p><p id="3985" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能不是处理数据的最佳逻辑。</p><p id="7821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用完成处理程序测试异步代码处理在操作的回调被触发后切换回同步上下文的问题。更多关于测试异步/等待代码<a class="ae kv" href="https://www.swiftbysundell.com/articles/unit-testing-code-that-uses-async-await/" rel="noopener ugc nofollow" target="_blank">的信息，请点击这里</a>。</p><p id="60ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">⁴I在约翰·奥莱利的《人类空间》中首次发现了这种模式</p></div></div>    
</body>
</html>