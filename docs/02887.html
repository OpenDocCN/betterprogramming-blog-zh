<html>
<head>
<title>Learn To Create Your Own useFetch() React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习创建自己的useFetch() React钩子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-to-create-your-own-usefetch-react-hook-9cc31b038e53?source=collection_archive---------8-----------------------#2020-01-07">https://betterprogramming.pub/learn-to-create-your-own-usefetch-react-hook-9cc31b038e53?source=collection_archive---------8-----------------------#2020-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f6a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仅仅五分钟后</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f58803a135a3c60ed46e1965e7f4d98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tUVdsySBzZ_-ZuXO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@adventure_yuki?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yuki Dog </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">钩子是React 16.8中增加的一个很好的工具。它们让你不用写类就能写有状态的组件。这是迄今为止我最喜欢React的一点。</p><p id="9094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React附带了很多这样的工具——已经内置在库中。这些包括，例如，<code class="fe lv lw lx ly b">useState</code>、<code class="fe lv lw lx ly b">useEffect</code>、<code class="fe lv lw lx ly b">useContext</code>和<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">更多的</a>。</p><p id="1f52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们非常适合许多一般用例，更棒的是，您可以为自己的项目需求创建自己的挂钩。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="efd8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">它们是如何工作的</h1><p id="fa3c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个<em class="nd">钩子</em>是一个简单的函数，它可以接受你需要的任意多的参数，并返回你想要它返回给你的组件的内容。</p><p id="bd0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是有史以来最简单的钩子的例子:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="8509" class="ni mh it ly b gy nj nk l nl nm">function useYear() {<br/>  return new Date().getFullYear();<br/>}</span><span id="7784" class="ni mh it ly b gy nn nk l nl nm">export default useYear;</span></pre><p id="b911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘣，就这样。看起来像一个常规函数，对吗？</p><p id="d3ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以按如下方式使用:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="d200" class="ni mh it ly b gy nj nk l nl nm">// ...</span><span id="efe5" class="ni mh it ly b gy nn nk l nl nm">import useYear from "./useYear";</span><span id="22d7" class="ni mh it ly b gy nn nk l nl nm">function App() {<br/>  const year = useYear();</span><span id="513c" class="ni mh it ly b gy nn nk l nl nm">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1&gt;Year: {year}&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="7ac2" class="ni mh it ly b gy nn nk l nl nm">// ...</span></pre><p id="18b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个伟大的钩子，但让我们现在工作在更有用的东西。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="637a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建一个useFetch挂钩</h1><p id="36e0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">钩子对于避免应用程序中的代码重复非常有用。我们经常做的事情是获取数据。</p><p id="6f05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何编写一个具有以下特征的钩子:</p><ul class=""><li id="5b5b" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">它可以获取数据</li><li id="83bd" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">它返回一个加载状态</li><li id="3e97" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">它返回一个错误状态</li></ul><h2 id="138e" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">1.创建一个获取数据的基本钩子</h2><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="0101" class="ni mh it ly b gy nj nk l nl nm">import React, { useState, useEffect } from "react";</span><span id="b697" class="ni mh it ly b gy nn nk l nl nm">const useFetch = (url, options) =&gt; {<br/>  const [response, setResponse] = useState(null);</span><span id="031e" class="ni mh it ly b gy nn nk l nl nm">  useEffect(() =&gt; {<br/>    const doFetch = async () =&gt; {<br/>      const res = await fetch(url, options);<br/>      const json = await res.json();<br/>      setResponse(json);<br/>    }<br/>    doFetch();<br/>  }, []);</span><span id="ab4e" class="ni mh it ly b gy nn nk l nl nm">  return response;<br/>};</span><span id="1703" class="ni mh it ly b gy nn nk l nl nm">export default <!-- -->useFetch<!-- -->;</span></pre><p id="da40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的钩子有两个参数:一个URL和一个options <strong class="lb iu"> </strong>对象。options参数可以包含本机<code class="fe lv lw lx ly b">fetch()</code> API用作第二个参数的任何内容。<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" rel="noopener ugc nofollow" target="_blank">点击这里查看选项的完整列表</a>。</p><p id="825c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用<code class="fe lv lw lx ly b">useEffect</code>获取数据并将数据设置为响应状态(使用<code class="fe lv lw lx ly b">useState</code>)。</p><p id="aa06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意作为<code class="fe lv lw lx ly b">useEffect</code>的第二个参数传递的空数组。根据设计，当组件安装和组件更新时会触发<code class="fe lv lw lx ly b">useEffect</code>。</p><p id="3b69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们只想让它执行一次呢？<code class="fe lv lw lx ly b">useEffect</code>接受第二个参数，我们可以将其设置为我们希望它观察的变量数组。通过传递一个空数组，我们确保<code class="fe lv lw lx ly b">useEffect</code>只会被触发一次——当它挂载时。</p><h2 id="0074" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">2.让它处理错误</h2><p id="e1b9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有时事情没有按计划进行，我们必须让我们的组件意识到这一点。</p><p id="d9d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将代码包装在一个<code class="fe lv lw lx ly b">Try… Catch</code>中，并使用<code class="fe lv lw lx ly b">useState</code>来存储一个潜在的错误:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="e331" class="ni mh it ly b gy nj nk l nl nm">import React, { useState, useEffect } from "react";</span><span id="7885" class="ni mh it ly b gy nn nk l nl nm">const useFetch = (url, options) =&gt; {<br/>  const [response, setResponse] = useState(null)<br/>  <strong class="ly iu">const [error, setError] = useState(null);</strong></span><span id="9521" class="ni mh it ly b gy nn nk l nl nm">  useEffect(() =&gt; {<br/>    const doFetch = async () =&gt; {<br/>      <strong class="ly iu">try {</strong><br/>        const res = await fetch(url, options);<br/>        const json = await res.json();<br/>        setResponse(json);<br/><strong class="ly iu">      } catch (e) {<br/>        setError(e);<br/>      }<br/></strong>    };<br/>      doFetch();<br/>  }, []);</span><span id="2f22" class="ni mh it ly b gy nn nk l nl nm">  return <strong class="ly iu">{ response, error }</strong>;<br/>};</span><span id="d104" class="ni mh it ly b gy nn nk l nl nm">export default <!-- -->useFetch<!-- -->;</span></pre><h2 id="f848" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">3.使其返回加载状态</h2><p id="e80a" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们希望在获取发生时在主组件中显示一个加载器。正如我们处理错误一样，让我们添加一个加载状态。</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="3fd4" class="ni mh it ly b gy nj nk l nl nm">import React, { useState, useEffect } from "react";</span><span id="29b4" class="ni mh it ly b gy nn nk l nl nm">const useFetch = (url, options) =&gt; {<br/>  const [response, setResponse] = useState(null)<br/>  const [error, setError] = useState(null);<br/>  <strong class="ly iu">const [loading, setLoading] = useState(false);</strong></span><span id="8ab8" class="ni mh it ly b gy nn nk l nl nm">  useEffect(() =&gt; {<br/>    const doFetch = async () =&gt; {<br/>      <strong class="ly iu">setLoading(true);</strong><br/>      try {<br/>        const res = await fetch(url, options);<br/>        const json = await res.json();<br/>        setResponse(json);<br/>      } catch (e) {<br/>        setError(e);<br/>      }<strong class="ly iu"> finally {</strong><br/>        <strong class="ly iu">setLoading(false);</strong><br/>      <strong class="ly iu">}</strong><br/>    };<br/>    doFetch();<br/>  }, []);</span><span id="6720" class="ni mh it ly b gy nn nk l nl nm">return { response, error, <strong class="ly iu">loading</strong> };<br/>};</span><span id="475b" class="ni mh it ly b gy nn nk l nl nm">export default <!-- -->useFetch<!-- -->;</span></pre><p id="a278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很多人忽略了这一点，但是<code class="fe lv lw lx ly b">Try… Catch</code>做了一个叫做<code class="fe lv lw lx ly b">finally</code>的总结。<strong class="lb iu"> </strong> <code class="fe lv lw lx ly b">finally</code>被执行，不管是否有错误——这正是我们想要的。</p><p id="84e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取完成后，将加载的状态设置为false。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="5c82" class="ni mh it bd mi oc od dn mm oe of dp mq li og oh ms lm oi oj mu lq ok ol mw om bi translated">4.清除</h2><p id="5b22" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果请求很慢，并且在异步请求完成时组件已经卸载了，该怎么办？您将得到以下错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/5fc119cee6c26c6f201285ebb45a6b97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uhvl04QIx4JbvZxlwmu-lg.png"/></div></div></figure><p id="c575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种内存泄漏的发生，一个解决方案是结合使用useEffect的清理函数和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" rel="noopener ugc nofollow" target="_blank"> AbortController </a>内置对象:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="6215" class="ni mh it ly b gy nj nk l nl nm">import React, { useState, useEffect } from "react";</span><span id="a65b" class="ni mh it ly b gy nn nk l nl nm">const useFetch = (url, options) =&gt; {<br/>  const [response, setResponse] = useState(null)<br/>  const [error, setError] = useState(null);<br/>  const [loading, setLoading] = useState(false);</span><span id="bf91" class="ni mh it ly b gy nn nk l nl nm">useEffect(() =&gt; {<br/>    <strong class="ly iu">const abortController = new AbortController();<br/>    const signal = abortController.signal;</strong><br/>    <!-- -->const doFetch = async () =&gt; {<br/>      setLoading(true);<br/>      try {<br/>        const res = await fetch(url, options);<br/>        const json = await res.json();<br/>        <strong class="ly iu">if (!signal.aborted) {</strong><br/>          setResponse(json);<br/>        <strong class="ly iu">}</strong><br/>      } catch (e) {<br/>        <strong class="ly iu">if (!signal.aborted) {<br/></strong>          setError(e);<br/>        <strong class="ly iu">}</strong><br/>      } finally {<br/><strong class="ly iu">        </strong><strong class="ly iu">if (!signal.aborted) {</strong><br/>          <!-- -->setLoading(false);<br/><strong class="ly iu">        }</strong><br/>      }<br/>    };<br/>    doFetch();</span><span id="d403" class="ni mh it ly b gy nn nk l nl nm"><strong class="ly iu">    return () =&gt; {<br/>      abortController.abort();<br/>    };</strong><br/>  <!-- -->}, []);</span><span id="eb2a" class="ni mh it ly b gy nn nk l nl nm">  return { response, error, loading };<br/>};</span><span id="5db1" class="ni mh it ly b gy nn nk l nl nm">export default <!-- -->useFetch<!-- -->;</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d5c9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用</h1><p id="1042" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们使用它的方式和使用其他钩子完全一样。</p><p id="dba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，它需要一个URL作为第一个参数，如果需要，您可以为它提供选项:</p><pre class="kj kk kl km gt ne ly nf ng aw nh bi"><span id="ae22" class="ni mh it ly b gy nj nk l nl nm">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import useFetch from "./useFetch";</span><span id="1cc0" class="ni mh it ly b gy nn nk l nl nm">function App() {<br/>  const { response, loading, error } = useFetch(<br/>    "https://jsonplaceholder.typicode.com/todos/1"<br/>  );</span><span id="9c5d" class="ni mh it ly b gy nn nk l nl nm">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;h1&gt;useFetch Usage&lt;/h1&gt;<br/>      {loading &amp;&amp; &lt;p&gt;Loading...&lt;/p&gt;}<br/>      {error &amp;&amp; &lt;p&gt;Something went wrong...&lt;/p&gt;}<br/>      {response &amp;&amp; &lt;p&gt;{response.title}&lt;/p&gt;}<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="2111" class="ni mh it ly b gy nn nk l nl nm">const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="58d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用这个<a class="ae ky" href="https://codesandbox.io/s/boring-currying-7dicl" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>进行现场测试。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ed84" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">如何改进？</h1><p id="1560" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在实际项目中，当我们获取数据时，我们可能想要做额外的事情。我们的钩子可以通过实现以下特性来改进:</p><ul class=""><li id="30f1" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">缓存:</strong>在获取之前，它会检查您选择的缓存中的数据是否已经被获取，以及是否需要(重新)获取</li><li id="0c28" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">记录错误</strong>:如果有错误，它会将错误分派给服务/第三方应用程序，这样开发人员就可以知道这些错误</li><li id="431d" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">React suspension:</strong><code class="fe lv lw lx ly b">&lt;Suspense&gt;</code>组件让您等待一些代码加载，并在等待时声明性地指定加载状态(像一个微调器)。这很好，但不推荐，因为它是一个实验性的功能。<a class="ae ky" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">此处查看更多</a>。</li><li id="787b" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><strong class="lb iu">效果:</strong>当它完成或接收到一个错误(一个通过<code class="fe lv lw lx ly b">onComplete</code>或<code class="fe lv lw lx ly b">onError</code>参数提供的动作)时，它可以向一个商店发送一个动作，比如Redux</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d070" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最后的想法</h1><p id="887f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有很多库在做我们在本文中所做的事情。</p><p id="0754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，创建我们自己的<code class="fe lv lw lx ly b">useFetch</code>挂钩非常容易。知道如何创建定制挂钩，除了将我们的项目从另一个依赖中拯救出来之外，还能让我们完全控制我们需要什么。</p><p id="8504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自己能做到的，就去做！(嗯，这取决于上下文，但以这句话结束这篇文章很酷。)</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="ec4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得这篇文章有用？下面是我最受欢迎的文章…</p><div class="oo op gp gr oq or"><a href="https://medium.com/better-programming/everyday-activities-to-become-a-better-developer-3d00ec8d14a5" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">帮助你成为更好的开发者的日常活动</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">每天都变得更好是许多开发人员的目标</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://medium.com/better-programming/build-your-very-own-react-component-library-and-publish-it-to-github-package-registry-192a688a51fd" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">构建您自己的React组件库，并将其发布到GitHub包注册表</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">当跨多个项目工作时，它总是很方便</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.com</p></div></div><div class="pa l"><div class="pg l pc pd pe pa pf ks or"/></div></div></a></div><div class="oo op gp gr oq or"><a href="https://medium.com/better-programming/create-a-chrome-extension-using-react-and-typescript-50e94e14320c" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">使用React和TypeScript创建一个Chrome扩展</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">在本文中，我们将使用Typescript创建一个Chrome扩展，并为弹出窗口使用React。你不…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.com</p></div></div><div class="pa l"><div class="ph l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>