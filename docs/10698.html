<html>
<head>
<title>Build a Flexible Picker With SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI构建灵活的拣选器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/flexible-picker-with-swiftui-5817ffe9fddf?source=collection_archive---------3-----------------------#2022-01-23">https://betterprogramming.pub/flexible-picker-with-swiftui-5817ffe9fddf?source=collection_archive---------3-----------------------#2022-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1da3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于可滴设计</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ed05ac72a97cbbcba97c9d19b2427567.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GngoW59XaWYPUeNgg0uVw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://previewed.app/template/78D6A989" rel="noopener ugc nofollow" target="_blank">https://previewed.app/template/78D6A989</a></p></figure><p id="2914" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近，当我致力于Dribbble上的一个设计的SwiftUI实现时，我想到了一个用一些很酷的过滤器来扩展该项目以缩小结果列表的想法。</p><p id="ade1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我决定过滤器视图将由两个独立的过滤器选项组成，它们都有一些选项可供选择。但是后来我遇到了一个问题。当我使用UIKit时，我总是用特定的<code class="fe ls lt lu lv b">UICollectionViewFlowLayout</code>来实现那种视图。但是我如何在SwiftUI中做到这一点？</p><p id="24e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看我用SwiftUI实现的灵活选取器！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9332" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">可选协议</h1><p id="4e82" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">选择器最重要的部分是我们可以通过视图组件选择一些需要的选项。这就是为什么在一开始我创建了一个<code class="fe ls lt lu lv b">Selectable</code>协议。</p><p id="0687" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">符合该协议的所有对象都必须实现两个属性:<code class="fe ls lt lu lv b">displayedName</code> —将显示在选择器中的名称，以及<code class="fe ls lt lu lv b">isSelected</code> —告诉给定选项是否被选中的布尔值。</p><p id="67c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，为了使仅通过映射字符串值数组来创建<code class="fe ls lt lu lv b">Selectable</code>对象成为可能，必须由符合Selectable的对象提供带有<code class="fe ls lt lu lv b">displayedName</code>作为参数的自定义<code class="fe ls lt lu lv b">init</code>。</p><p id="4881" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Identifiable</code>和<code class="fe ls lt lu lv b">Hashable</code>协议确保我们能够使用<code class="fe ls lt lu lv b">ForEach</code>循环轻松创建SwiftUI视图。此外，所有符合<code class="fe ls lt lu lv b">Selectable</code>协议的对象都将实现一个常量值<code class="fe ls lt lu lv b">id</code>来存储一个<code class="fe ls lt lu lv b">UUID</code>值。</p><p id="0b89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将故意省略符合<code class="fe ls lt lu lv b">Selectable</code>协议的对象的实现，因为我相信这是显而易见的。如果没有，那么您可以在本文末尾提到的我的GitHub资源库中查看它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">可选协议的代码片段。</p></figure><h1 id="5717" class="md me iq bd mf mg nc mi mj mk nd mm mn jw ne jx mp jz nf ka mr kc ng kd mt mu bi translated">用户化</h1><p id="da85" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我的目标不仅是创建一个灵活的选择器的实现，而且尽可能使它可定制。</p><p id="364e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么<code class="fe ls lt lu lv b">FlexiblePicker</code>将使用符合<code class="fe ls lt lu lv b">Selectable</code>协议的通用类型<code class="fe ls lt lu lv b">T</code>来创建。这样，以后重用该组件就更容易了，因为它是独立于类型的。</p><p id="b583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在实现选择器之前，我写下了所有可定制的属性。下一步是创建字符串扩展，用于计算特定字符串值的宽度和高度。</p><p id="77b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我的实现提供了改变字体大小和粗细的可能性，所以前面提到的两个扩展都以灵活选取器使用的参数<code class="fe ls lt lu lv b">UIFont</code>作为参数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">字符串扩展的代码段。</p></figure><p id="30b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为计算给定字符串大小的字符串扩展，将a <code class="fe ls lt lu lv b">UIFont</code>作为输入，我需要将所有的<code class="fe ls lt lu lv b">UIFont</code>权重转换成SwiftUI的等价物。</p><p id="b0fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我引入了一个<code class="fe ls lt lu lv b">FontWeight</code>枚举，由所有以<code class="fe ls lt lu lv b">UIFont</code>权重命名的可能情况组成。</p><p id="32b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，该枚举有两个属性，一个返回<code class="fe ls lt lu lv b">UIFont</code>权重，另一个返回SwiftUI字体权重。这样，我们只是为我们的<code class="fe ls lt lu lv b">FlexiblePicker</code>提供了<code class="fe ls lt lu lv b">FontWeight</code>枚举的一个特例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">FontWeight枚举的代码段。</p></figure><h1 id="fc78" class="md me iq bd mf mg nc mi mj mk nd mm mn jw ne jx mp jz nf ka mr kc ng kd mt mu bi translated">FlexiblePicker逻辑</h1><p id="bb92" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在那之后，我终于准备好开始进行<code class="fe ls lt lu lv b">FlexiblePicker</code>实现了。</p><p id="b83c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我需要一个函数来计算并返回作为输入传递的所有数据的宽度。我通过将所有输入值映射到由输入值和自身宽度组成的元组来实现。</p><p id="a716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在地图内部，我使用了reduce函数，总结了与给定输入值相关的所有宽度(文本宽度、边框宽度、文本填充、间距)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当计算宽度的函数准备好了，我们可以遍历所有输入数据，并把它们分成单独的数组。每个数组由能够放入同一个<code class="fe ls lt lu lv b">HStack</code>的项目组成。逻辑很简单。我们必须阵列:</p><ul class=""><li id="32fb" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated"><code class="fe ls lt lu lv b">singleLineResult</code>数组——负责存储适合特定行的项目</li><li id="6ca0" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated"><code class="fe ls lt lu lv b">allLinesResult</code>数组——负责存储项目的所有数组(每个数组相当于一行项目)</li></ul><p id="4369" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我们检查从<code class="fe ls lt lu lv b">HStack</code>的线宽中减去项目宽度的结果是否大于0。</p><p id="62d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果满足条件，我们将当前项目追加到<code class="fe ls lt lu lv b">singleLineResult</code>，更新可用的<code class="fe ls lt lu lv b">HStack</code>的线宽，并转到下一个元素。</p><p id="77ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果结果小于0，这意味着我们无法将下一个元素放入给定的行中，因此我们将<code class="fe ls lt lu lv b">singleLineResult</code>附加到<code class="fe ls lt lu lv b">allLinesResult</code>，将<code class="fe ls lt lu lv b">singleLineResult</code>设置为仅包含当前元素(无法放入前一行的元素)的数组，并通过减去当前项目的宽度来更新<code class="fe ls lt lu lv b">HStack</code>的行宽。</p><p id="5743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在经历了所有的元素之后，我们必须处理一个特定的极限情况。有可能<code class="fe ls lt lu lv b">singleLineResult</code>不会为空，也不会追加到<code class="fe ls lt lu lv b">allLinesResult</code>——因为我们只在减去项目宽度的结果小于0时追加<code class="fe ls lt lu lv b">singleLineResult</code>。在这种情况下，我们必须检查<code class="fe ls lt lu lv b">singleLineResult</code>是否为空，如果为真，我们返回<code class="fe ls lt lu lv b">allLinesResult</code>，如果不是，我们必须首先追加<code class="fe ls lt lu lv b">singleLineResult</code>，然后返回<code class="fe ls lt lu lv b">allLinesResult</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将项目分成单独行的函数的代码段。</p></figure><p id="3d3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，我们必须计算<code class="fe ls lt lu lv b">VStack</code>的高度，以使SwiftUI更容易解释我们的视图组件。<code class="fe ls lt lu lv b">VStack</code>的高度基于两个值计算:</p><ul class=""><li id="d27d" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">输入数据中任何项目的高度(计算方法与宽度相似，使用reduce函数，将与项目相关的所有高度相加)</li><li id="ac92" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">将在<code class="fe ls lt lu lv b">VStack</code>中显示的行数</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算VStack高度的函数的代码片段。</p></figure><p id="bab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个数字相乘的结果就是我们的<code class="fe ls lt lu lv b">VStack</code>的高度。很简单，是吧？</p><h1 id="a7e0" class="md me iq bd mf mg nc mi mj mk nd mm mn jw ne jx mp jz nf ka mr kc ng kd mt mu bi translated">FlexiblePicker视图</h1><p id="f4ec" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">最后，当整个逻辑准备就绪时，我们需要实现一个视图体。正如我之前提到的，视图将使用<code class="fe ls lt lu lv b">ForEach</code>循环创建，一个嵌套在另一个中。</p><p id="b31e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住<code class="fe ls lt lu lv b">ForEach</code>循环要求迭代集合的每个元素都必须符合<code class="fe ls lt lu lv b">Identifiable</code>协议，或者应该有一个唯一的标识符，这一点很重要。</p><p id="68e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我将被划分的行的结果映射到由每行和id(即<code class="fe ls lt lu lv b">UUID</code>值)组成的元组中。</p><p id="1c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我可以向<code class="fe ls lt lu lv b">ForEach</code>循环提供一个id参数。第二件要记住的事情是,<code class="fe ls lt lu lv b">ForEach</code>循环期望得到一些视图作为返回值。</p><p id="c588" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们只是在那里插入另一个<code class="fe ls lt lu lv b">ForEach</code>循环，我们的视图的正确功能将会有问题，因为<code class="fe ls lt lu lv b">ForEach</code>不是一个视图类型。</p><p id="b80f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我将整个<code class="fe ls lt lu lv b">ForEach</code>循环首先打包到<code class="fe ls lt lu lv b">HStack</code>，然后打包到<code class="fe ls lt lu lv b">Group</code>，以确保编译器能够正确解释一切。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">FlexiblePicker视图实现的代码段。</p></figure><p id="1f4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">几乎所有的工作都完成了，我们只需要添加一个功能来处理用户与按钮的交互。该函数只是切换特定数据的<code class="fe ls lt lu lv b">isSelected</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用户交互处理程序的代码片段。</p></figure><p id="bb45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码的其余部分很简单，它主要是所有属性的配置，如字体、颜色或边框。此外，在<code class="fe ls lt lu lv b">VStack</code>结束时，我们设置了一个框架，其宽度取自<code class="fe ls lt lu lv b">GeometryReader</code>，高度由之前创建的函数计算。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/6e8911ab140ebba6059c90f81f7f4faa.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/1*btodjU23lODmSpnCAvdflQ.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">FlexiblePicker实现的最终结果。</p></figure><p id="b820" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们准备好了！我们的FlexiblePicker已经完成，可以使用了！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="d53d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢它！像往常一样，整个实现可以在我的<a class="ae kv" href="https://github.com/jcholuj/FlexiblePickerExample" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上获得。非常感谢你的时间。</p></div></div>    
</body>
</html>