<html>
<head>
<title>Predict Your Future Medium Stats Using Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用深度学习预测你未来的中等统计数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/predict-your-future-medium-stats-using-deep-learning-ce49bb3361ea?source=collection_archive---------8-----------------------#2021-05-28">https://betterprogramming.pub/predict-your-future-medium-stats-using-deep-learning-ce49bb3361ea?source=collection_archive---------8-----------------------#2021-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="28dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用一个简单的多层感知器和中等API来预测你的中等统计数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/663186ac63f80a2206a1bdc7c7e1ad18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IZe_-b4E-LgOnGl0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">雷蒙·克拉文斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="2858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近几个月，我一直在努力提高我的深度学习知识——特别是掌握时间序列预测，我觉得这是所有分支中最有趣的一个。我是说，预测未来会发生什么似乎很酷。</p><p id="f668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试我刚刚学到的技能，我决定实现一个简单的多层感知器来预测我未来的视图。</p><p id="a389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我创建这个深度学习模型只是为了在学习MLPs时有一些真实世界的问题经验，所以这个模型真的很简单。尽管如此，它最终可以成为未来项目的一个良好开端。</p><p id="a8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将写下以下内容:</p><ol class=""><li id="f1d6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">问题概述</li><li id="c906" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据析取</li><li id="010b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">数据准备</li><li id="a548" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">构建模型</li><li id="74ab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">训练和预测</li><li id="a07f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">改进和未来工作</li></ol><p id="e7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，你可以在<a class="ae ky" href="https://github.com/hensis/MLP_predict_medium_stats" rel="noopener ugc nofollow" target="_blank">这个GitHub repo </a>里找到所有的代码。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2b19" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.问题概述</h1><p id="ff61" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">MLPs所做的基本上是近似一个从输入变量到输出变量的映射函数。由于MLP是一种神经网络，它不会对映射函数做出强有力的假设，因此是非线性关系的最佳选择。然而，不得不说的是，已经有很多研究投入到MLPs中，致力于解决时间序列问题，并取得了适度的结果。</p><p id="140d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正面临一个时间序列问题，因为我们希望能够使用某段时间内以前的视图数量来预测未来的视图。我们的数据集中有一个<em class="nn">时间依赖</em> <strong class="lb iu"> </strong>。</p><p id="4558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，由于这是一个非常简单的模型，我将只接受前一时间步的视图数作为输入，而不是，例如，我在那些时间步中写的文章数。所以，我们在讨论一个<em class="nn">单变量输入</em>。此外，我们希望能够预测尽可能长的时间。例如，我想对下一个<em class="nn">十个时间步</em>的视图进行预测。所以，假设每个时间步对应一天，我想预测接下来的十天。我们想要任意数量的输出，这也是一个<em class="nn">多步</em> <strong class="lb iu"> </strong>预测。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c7f2" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.数据析取</h1><p id="1bb2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在了解到我们想要的是一个<em class="nn">多步单变量预测</em>之后，我们可以继续从Medium API中提取构建数据集所需的数据。</p><p id="c923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是获得我们的历史数据。我将在<a class="ae ky" href="http://medium.com" rel="noopener">介质</a>上使用一个特殊的API端点来完成这项工作，因为官方的介质API <a class="ae ky" href="https://github.com/Medium/medium-api-docs" rel="noopener ugc nofollow" target="_blank">不允许</a> us检索这些数据。</p><p id="ff1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">端点看起来像这样:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="d5a1" class="nt mr it np b gy nu nv l nw nx">/@username/stats/total/{start_timestamp}/{end_timestamp} </span></pre><p id="1a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我想获得从2020年3月1日(时间戳中的<code class="fe ny nz oa np b">1583071962</code>)到撰写本文的当前时间(时间戳中的2021年5月25日— <code class="fe ny nz oa np b">1621955985</code> <em class="nn"> </em>)的统计数据，调用的URL如下:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="215f" class="nt mr it np b gy nu nv l nw nx">/@tdpdev/stats/total/158307196000/1621955985</span></pre><p id="fc31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长版是<a class="ae ky" href="https://medium.com/@tdpdev/stats/total/1558789962000/1621955453838" rel="noopener">https://medium . com/@ tdpdev/stats/total/1558789962000/1621955453838</a>。</p><p id="5861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，我需要先被认证。原始请求如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/99a52199b7c34e2d945ef557ee8602e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wD7nwamBgJDQbDVlsVCbpQ.png"/></div></div></figure><p id="66a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.我们从JSON加载数据，并将其存储为NumPy <code class="fe ny nz oa np b">Array</code>对象。</p><p id="630f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有多种方法可以做到这一点:使用python-requests，使用JavaScript的<code class="fe ny nz oa np b">fetch</code>方法，等等。然而，为了确保你真的明白到底在抓取什么数据，我将在Chrome开发者工具的帮助下手动<em class="nn">完成。</em></p><ol class=""><li id="aaea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">打开medium.com/@{username}/stats/total/{start_ts}/{end_ts}.如果您被认证为{用户名}，您将看到加载的JSON数据。</li><li id="a165" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">打开开发工具，使用JavaScript中的<code class="fe ny nz oa np b">for</code>循环，我们将构建一个所有视图的列表:</li></ol><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b4d7" class="nt mr it np b gy nu nv l nw nx">all_views = []<br/>for (i=0; i &lt; json.payload.value.length; i++) {<br/>    all_views.push(json.payload.value[i].reads)<br/>}</span></pre><p id="e784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将建立我们的列表。现在我们要复制它:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="463f" class="nt mr it np b gy nu nv l nw nx">copy(all_views)</span></pre><p id="cd1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们要将复制的数据转换成单行数据。我们可以使用<a class="ae ky" href="https://lingojam.com/TexttoOneLine" rel="noopener ugc nofollow" target="_blank">文本到一行</a>。</p><p id="6258" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们做到了这一点，我们就有了一个在<code class="fe ny nz oa np b">start_timestamp</code>和<code class="fe ny nz oa np b">end_timestamp</code>之间每小时的阅读列表。</p><p id="60ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.将其粘贴到Python文件中。</p><p id="c9e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我建议您使用另一种更简单、更快速的方法，比如python-requests或者甚至JavaScript <code class="fe ny nz oa np b">fetch</code> API。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="4dc3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.数据准备</h1><p id="d12a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们现在想为我们的MLP准备数据。为此，我们将构建一个如下所示的数据集:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2ec0" class="nt mr it np b gy nu nv l nw nx">X, y<br/>[ 2 10 10  7 12  6 11 30 10 19] [35 22 15 17]<br/>[10 10  7 12  6 11 30 10 19 35] [22 15 17 19]<br/>[10  7 12  6 11 30 10 19 35 22] [15 17 19 23]<br/>[ 7 12  6 11 30 10 19 35 22 15] [17 19 23 17]</span></pre><p id="9010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">诸如此类。</p><p id="4860" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们的MLP将使用过去十个小时的读数来预测未来四个小时的读数。当然，您可以将此更改为您喜欢的任何值(考虑到模型的准确性)。例如，您可以使用过去的48小时来预测未来的12小时。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="6bfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码将完成这项工作。我不会深入解释这段代码做了什么，因为它非常简单:我们得到了每小时所有视图的列表(<code class="fe ny nz oa np b">all_views</code>)，然后我们使用一个<code class="fe ny nz oa np b">for</code>循环将数据分成<em class="nn"> X </em>(用于预测<code class="fe ny nz oa np b">y</code>的输入)和<em class="nn"> y </em>(我们的输出)。注意这两个是NumPy数组。</p><p id="c005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经准备好了数据，我们就可以构建模型了。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a465" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.构建模型</h1><p id="f76e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们将创建一个非常简单的MLP。它只有一层(不包括输入和输出层):</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="fca5" class="nt mr it np b gy nu nv l nw nx">model = Sequential()<br/>model.add(Dense(100, <em class="nn">activation</em>='relu', <em class="nn">input_dim</em>=10))</span><span id="c22f" class="nt mr it np b gy oe nv l nw nx">model.add(Dense(200, <em class="nn">activation</em>='softmax'))<br/>model.add(Dense(4))<br/>model.compile(<em class="nn">optimizer</em>='adam', <em class="nn">loss</em>='mse')<br/></span></pre><p id="8aa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用Keras创建了一个<code class="fe ny nz oa np b">Sequential()</code>模型，然后添加了一个带有<code class="fe ny nz oa np b"><a class="ae ky" href="https://machinelearningmastery.com/rectified-linear-activation-function-for-deep-learning-neural-networks/" rel="noopener ugc nofollow" target="_blank">relu</a></code>激活的输入层(<a class="ae ky" href="https://machinelearningmastery.com/rectified-linear-activation-function-for-deep-learning-neural-networks/" rel="noopener ugc nofollow" target="_blank">整流线性单元</a>)。之后，我们添加了一个输入层，接受输入<code class="fe ny nz oa np b">10</code>的<em class="nn">形状</em>，这正是<code class="fe ny nz oa np b">X</code>数组的形状。在输入层之后，我们添加一个隐藏层，使用<a class="ae ky" href="https://towardsdatascience.com/softmax-function-simplified-714068bf8156" rel="noopener" target="_blank"> softmax </a>作为激活函数。然后我们直接添加了输出层，它将返回给我们<code class="fe ny nz oa np b">4</code>输出。最后，我们编译了模型。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1f75" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">5.训练和预测</h1><p id="5069" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在构建和编译模型之后，我们可能想要拟合它:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="eeb0" class="nt mr it np b gy nu nv l nw nx">model.fit(X, y, <em class="nn">epochs</em>=2000, <em class="nn">verbose</em>=2)</span></pre><p id="0d58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦模型经过训练，我们现在就可以根据过去十个小时的视图对未来四个小时进行预测。</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="12a2" class="nt mr it np b gy nu nv l nw nx">x_input = array([3, 5, 7, 2, 9, 10, 2, 6, 4, 9])<br/>x_input = x_input.reshape((1, 10))</span></pre><p id="acaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先构建一个数组，用于预测接下来四个小时的视图。然后我们重塑它，使它可以被我们的模型处理。</p><p id="d72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，使用MLP，我们计算这些视图在过去十个小时内的预测值(<code class="fe ny nz oa np b">[3, 5, 7, 2, 9, 10, 2, 6, 4, 9]</code>):</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="11a1" class="nt mr it np b gy nu nv l nw nx">yhat = model.predict(x_input, <em class="nn">verbose</em>=2)</span></pre><p id="30a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe ny nz oa np b">yhat</code>(回归中的预测(因变量)将是我们的<code class="fe ny nz oa np b">x_input</code>的预测。</p><p id="d308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您现在可以打印<code class="fe ny nz oa np b">yhat</code>，这样您就可以看到在接下来的四个小时里有多少视图被预测。</p><p id="cc03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是基于<code class="fe ny nz oa np b">x_input</code>预测的示例输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bcd197da9bc0722f497f4bb93680a91d.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/format:webp/1*aYDF8vUTjuqTm--EraS0fA.png"/></div></figure><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1608" class="nt mr it np b gy nu nv l nw nx">[[7.1713915 9.878436  7.0950937 8.4904175]]</span></pre><p id="e134" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">请注意，由于模型的性质，您的结果可能与我的不同。</em></p><h2 id="c2e4" class="nt mr it bd ms og oh dn mw oi oj dp na li ok ol nc lm om on ne lq oo op ng oq bi translated">完整代码</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="910d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">6.改进和未来工作</h1><p id="ba2e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">正如我最初所说，这是一个非常简单的模型。许多人的浏览量各不相同，但这有许多原因(例如，撰写文章的数量、在媒体上的份额数量等。).事实上，开发这个模型只是为了在时间序列上进行实践，本文将向您展示如何轻松地收集数据并将其转化为时间序列多步<strong class="lb iu"> </strong>数据集。然后，我向您展示了如何使用Keras轻松实现多层感知器并预测未来值。</p><p id="dd44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于改进和未来的工作，您当然可以花更多的时间来准备数据，因为我在本文中使用了原始数据。您还可以尝试为时间序列实现其他执行的nn(CNN、LSTMs)。你可能也想把它变成一个多变量<strong class="lb iu"> </strong>预测，这意味着这个模型不仅要考虑浏览量，还要考虑文章数、分享数和许多其他可能导致阅读数变化的变量。那会花很多时间，但可能是值得的！</p></div></div>    
</body>
</html>