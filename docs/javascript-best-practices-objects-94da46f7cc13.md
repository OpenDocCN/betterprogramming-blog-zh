# JavaScript 最佳实践:对象

> 原文：<https://betterprogramming.pub/javascript-best-practices-objects-94da46f7cc13>

## 我们在定义对象时会陷入的陷阱

![](img/6acaf2a6b36d9f81af2ad730582cdd93.png)

由 [Gissur Steinarsson](https://unsplash.com/@gissur1?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/puffin?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

像任何其他编程语言一样，JavaScript 有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript 有很多棘手的部分，所以有很多东西要避免。我们可以很容易地遵循一些最佳实践，使我们的 JavaScript 代码易于阅读。

在这篇文章中，我们看看如何以一种易于维护的方式处理对象。当我们定义对象的时候，我们会遇到一些陷阱。

# 对原始值使用文字

在 JavaScript 中，有多种方法来声明原始变量。原始变量包括除对象以外的任何类型的变量。

一种方法是像这样使用文字:

```
let x = 1;
let y = true;
let z = '';
```

在上面的代码中，我们为每个变量设置了数字、布尔和字符串的文字值。

或者，我们可以写:

```
let x = new Number(1);
let y = new Boolean(true);
let z = new String('');
```

我们也可以写:

```
let x = Number(1);
let y = Boolean(true);
let z = String('');
```

在上面声明原始变量的三种方法中，有些方法比其他的好。最好的方法是直接设置文字。另一种方法是使用第三个例子中的函数。

为什么我们不应该使用构造函数来创建具有原始值的变量？首先，用`new`操作符定义的任何东西都有类型‘object ’,即使它们有原始值。这使得这些对象之间的比较变得困难。

例如，如果我们写:

```
new String('foo') === new String('foo')
```

我们得到`false`,因为它们都是‘object’类型，如果两个对象在 JavaScript 中没有相同的引用，`===`将计算为`false`。这意味着比较是困难的。

与`==`对比也会因为同样的原因评估到`false`。

因为它们都是“object”类型，所以很难知道它们实际上是字符串、布尔值还是数字。

另外两种方法要好得多，因为它们会给我们找到合适的类型。例如，下面的代码将得到类型“number”:

```
let x = 2;
console.log(typeof x);
```

这也适用于其他原始数据类型。

没有理由使用`new`操作符来声明具有原始值的事物。这只会让生活更加艰难。

使用`new`也比较慢，因为 JavaScript 解释器必须比必要的多做一次操作来声明具有“object”类型原语的东西。

`Number`、`String`和`Boolean`函数对于将对象从一种类型转换为另一种类型很有用。例如，如果我们有:

```
let x = '2';
```

然后我们可以用`Number`函数把它转换成一个数字，如下:

```
let y = Number(x);
```

# 只要对象存在，就使用文本来声明它们

一些对象有相关的文字。例如，数组有`[...]`文字。正则表达式可以用带斜线的环绕模式来声明。函数可以用`function`关键字或粗箭头来声明。

用构造函数定义值有时会让人感到困惑。例如，数组有两个构造函数。一个有一个参数，参数是数组长度。另一个是逗号分隔的条目列表。

这意味着`Array(1)`将得到一个空数组，其中`length`为 1，没有内容。另一方面，`Array(1,2,3)`会得到我们`[1,2,3]`。

正如我们所看到的，使用构造函数来声明数组并不清楚。

对于函数，我们有`function`关键字或`Function`构造函数。

使用`Function`构造函数没有意义，因为我们必须传递包含函数代码的字符串和参数名称的字符串。它为代码注入攻击打开了方便之门，将代码写成字符串是一件痛苦的事情。

`function`关键字就清楚多了。它让我们能够编写被文本编辑器识别为功能代码的代码。没有理由用`Function`构造函数来声明一个函数，除非我们想定义一个有动态代码的函数。

同样，`RegExp`构造函数适合动态构造正则表达式对象，但在其他方面与正则表达式文字相同。对于静态正则表达式，正则表达式文字和构造函数是相同的，所以构造函数有一些用处。

`Object`构造函数只是让我们键入比对象文字更多的代码；否则，他们是一样的。这意味着用它来声明对象是没有意义的。

# 自动类型转换

对于原始值，JavaScript 可以根据上下文将事物转换为不同的类型。

例如，假设我们有:

```
1 == '1'
```

那么字符串 1 将被转换成一个数字。

假设我们有:

```
1 + '1'
```

然后数字 1 将被转换成一个字符串，这样我们就得到了`'11'`。JavaScript 只是假设我们在连接。

另一方面，假设我们写道:

```
1 - '1'
```

我们得到 0，因为它假设我们正在减去两个数字。

假设我们写道:

```
1 - 'a'
```

因为结果不是一个数字，我们得到`NaN`,因为我们不能用一个非数字字符串减去一个数字。

在计算结果为布尔值的表达式中，内部的变量或值被计算为它们的真值或假值。

Falsy 值包括:

*   0
*   `null`
*   `undefined`
*   空字符串
*   `false`
*   `NaN`

其他一切都是真实的。假设我们有以下内容:

```
0 || undefined || null || 1
```

我们得到 1。JavaScript 解释器评估所有的 falsy 值并返回 1，因为这是最后剩下的。

为了确保得到我们期望的类型，我们应该把所有东西都转换成我们实际期望的类型，或者我们应该检查类型。

要转换像数字、布尔值和字符串这样的原始值，我们可以分别使用`Number`、`Boolean`和`String`函数。我们只是将任何对象传递给这些函数。

我们也可以在某物前使用`+`符号将其转换为数字。

`!!`也根据事物的真值将它们转换成布尔型。第一个感叹号根据值的真值转换该值，然后对其求反。然后第二个感叹号将它转换回原始的真值。

为了检查原始值的类型，我们可以使用`typeof`操作符。但是，请注意`null`的类型是“object”。一切都有我们期待的类型。

在大多数情况下，对象文字是定义对象的最清晰的方式。唯一的例外是当我们需要动态生成代码的函数或动态生成的正则表达式时。我们不应该使用`new`关键字来声明具有原始值的事物。最后，我们应该小心自动类型转换，并检查类型或根据我们的需要进行转换。