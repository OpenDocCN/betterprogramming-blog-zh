<html>
<head>
<title>Factory Method and Abstract Factory in Swift and iOS Universe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift和iOS领域中的工厂方法和抽象工厂</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/factory-method-and-abstract-factory-in-swift-and-ios-universe-47c716667287?source=collection_archive---------3-----------------------#2019-05-31">https://betterprogramming.pub/factory-method-and-abstract-factory-in-swift-and-ios-universe-47c716667287?source=collection_archive---------3-----------------------#2019-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fa7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索创造性的设计模式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/919f9f026bc73746bb454c0382676930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8kEJ0TtaePcMjRPJw7c33Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">法比安·格罗斯在<a class="ae ky" href="https://unsplash.com/search/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论他们或其他人的程序时，<em class="lv">工厂</em>这个词无疑是程序员最常用的词之一。同时，它们的确切含义是不同的。它可能是一个生成对象类(多态或非多态)，一个返回对象方法(静态或非静态)，甚至是一个常规的<a class="ae ky" href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">构造函数</a>。</p><p id="aff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，并不是所有生成对象的东西都可以称为工厂。此外，这个词可以描述“四人帮”武器库中两种不同的创造性设计模式——<a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Abstract_factory_pattern" rel="noopener ugc nofollow" target="_blank">抽象工厂</a>。</p><p id="97e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想深入研究它们的细节，特别关注它们的经典实现和理解。</p><p id="3ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的灵感来自于<a class="ae ky" href="https://twitter.com/joshuakerievsky" rel="noopener ugc nofollow" target="_blank">Joshua Kerievsky</a>(<a class="ae ky" href="https://industriallogic.com/" rel="noopener ugc nofollow" target="_blank">工业逻辑</a>的负责人)，或者更确切地说，是他的书《重构模式》。这本书是在世纪之交马丁·福勒签名系列中发行的。福勒是现代编程经典著作《重构:改进现有软件的设计》的著名作者</p><p id="6389" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你没有读过克里耶夫斯基的书，或者没有听说过这本书，请毫不犹豫地把它加入你的阅读清单。这是“重构”和更经典的“设计模式:可重用面向对象软件的元素”的有价值的续篇除此之外，这本书还包含了几十种通过使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">设计模式</a>来消除不同<a class="ae ky" href="https://en.wikipedia.org/wiki/Code_smell" rel="noopener ugc nofollow" target="_blank">代码气味</a>的方法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c85c" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">抽象工厂</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/77615bd9bc805802e24b93d87c9b3450.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4XKiYMHIVYAE0G_YQUJ6tg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">抽象工厂UML</p></figure><p id="7a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在他的书中，Kerievsky给出了两个例子来说明这种模式何时变得有用。</p><ol class=""><li id="ef8f" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">通过公共接口绑定的具体类型的封装</a>。在这种情况下，这样的知识将属于一种类型，即工厂。工厂的公共<a class="ae ky" href="https://en.wikipedia.org/wiki/Application_programming_interface" rel="noopener ugc nofollow" target="_blank"> API </a>由方法集(静态或非静态)组成，该方法集返回公共接口类型的实例，并具有有意义的名称，因此我们知道为了特定的目的必须调用哪一个。</li><li id="f63d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">第二个与第一个相似，总的来说，我们使用的所有场景都或多或少相似。这是因为一种类型或一组类型的实例的创建发生在程序的不同部分。同样，工厂封装了创造性的代码，但它的动机不同。如果代码很复杂，并且不受初始化器调用的限制，这一点尤其重要。</li></ol><p id="7c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了跟上<a class="ae ky" href="https://apple.com/ru/ios/ios-12" rel="noopener ugc nofollow" target="_blank"> iOS </a>开发世界，使用<code class="fe nk nl nm nn b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uiviewcontroller" rel="noopener ugc nofollow" target="_blank">UIViewController</a></code>子类相当方便。事实上，它是iOS软件开发中最流行的类型之一，几乎总是在使用前被子类化。具体的类对于客户端代码来说通常并不重要。</p><p id="5117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">尽管现实世界中的代码可以以某种方式简化，但我会尽量让代码示例尽可能接近四人帮书中的经典模式实现。只有深刻理解基础中的原理，才能更自由地使用它。</em></p><h2 id="428b" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">详细示例</h2><p id="4365" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">假设我们的应用程序销售车辆，视图/演示依赖于它的类型。我们将为不同的车辆类型使用不同的<code class="fe nk nl nm nn b">UIViewController</code>子类。除此之外，所有车辆的状态都不一样——新车和二手车。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c70a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们有一个相同组的类型家族，它的实例根据条件在相似的地方被创建。例如，用户点击列表中的一个项目——根据点击的车辆类型，它会以不同的方式创建。视图控制器的初始化器有参数值，每次都必须传递。难道这些争论没有揭示创建工厂的优势吗？工厂是唯一知道所需的控制器创建细节的类型。</p><p id="772c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这个例子相当简单。在现实世界中，引入这个工厂将是<a class="ae ky" href="https://en.wikipedia.org/wiki/Overengineering" rel="noopener ugc nofollow" target="_blank">过度工程</a>。然而，人们可以想象更多的车辆类型在它们的初始化器中有不止一个参数，抽象工厂的优势变得更加明显。</p><p id="442d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们介绍一下我们的抽象工厂<a class="ae ky" href="https://en.wikipedia.org/wiki/Interface_(computing)" rel="noopener ugc nofollow" target="_blank">接口</a>:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="4f87" class="no me it nn b gy ol om l on oo"><strong class="nn iu">protocol</strong> VehicleViewControllerFactory {<br/>    <strong class="nn iu">func</strong> makeBicycleViewController() -&gt; UIViewController<br/>    <strong class="nn iu">func</strong> makeScooterViewController() -&gt; UIViewController<br/>}</span></pre><p id="5cc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">简介</em> <a class="ae ky" href="https://swift.org/documentation/api-design-guidelines" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Swift API编程指南</em> </a> <em class="lv">建议以“make”为前缀命名工厂方法</em></p><p id="0dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">四人帮的例子是用<a class="ae ky" href="https://en.wikipedia.org/wiki/C%2B%2B" rel="noopener ugc nofollow" target="_blank"> C++ </a>编写的，基于<a class="ae ky" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">继承</a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Virtual_function" rel="noopener ugc nofollow" target="_blank">虚函数</a>。在Swift中，我们更接近面向协议的编程技术。</p><p id="aac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Factory interface只包含两个方法，为自行车和踏板车创建视图控制器。这些方法返回公共父类的实例。因此，意识的区域传播受到真正需要它的地区的限制。</p><p id="e638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加两个实现抽象工厂接口的具体工厂:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在我们的情况下，混凝土工厂负责不同状况的车辆，新的和旧的。</p><p id="7ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今后，必要的视图控制器是这样创建的:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="c10b" class="no me it nn b gy ol om l on oo"><strong class="nn iu">let</strong> factory: VehicleViewControllerFactory <br/>    = NewVehicleViewControllerFactory()<br/><strong class="nn iu">let</strong> vc = factory.makeBicycleViewController()</span></pre><h2 id="a410" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">用工厂封装类</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi op"><img src="../Images/30ad1e5147392cd4c8fac23dd76665c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*1WMbfHjZqhcZMNkUfVIogw.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用工厂封装类</p></figure><p id="abe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们简短地考虑一下克里耶夫斯基的书中给出的例子。</p><p id="90ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是关于<a class="ae ky" href="https://industriallogic.com/xp/refactoring/classesWithFactory.html" rel="noopener ugc nofollow" target="_blank">具体类型</a>的封装。记住显示车辆数据的相同视图控制器子类:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="1168" class="no me it nn b gy ol om l on oo"><strong class="nn iu">final</strong> <strong class="nn iu">class</strong> BicycleViewController: UIViewController { }<br/><strong class="nn iu">final</strong> <strong class="nn iu">class</strong> ScooterViewController: UIViewController { }</span></pre><p id="6392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在处理一个单独的模块，例如一个库。在这种情况下，上面的视图控制器类保持<code class="fe nk nl nm nn b"><a class="ae ky" href="https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html" rel="noopener ugc nofollow" target="_blank">internal</a></code>(默认情况下)，工厂充当公共API。工厂的方法返回众所周知的视图控制器的父类实例。因此，关于具体类型的知识受到模块的限制:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="65be" class="no me it nn b gy ol om l on oo"><strong class="nn iu">public</strong> <strong class="nn iu">struct</strong> VehicleViewControllerFactory {<br/>    <strong class="nn iu">func</strong> makeBicycleViewController() -&gt; UIViewController {<br/>        <strong class="nn iu">return</strong> BicycleViewController()<br/>    }<br/>    <strong class="nn iu">func</strong> makeScooterViewController() -&gt; UIViewController {<br/>        <strong class="nn iu">return</strong> ScooterViewController()<br/>    }<br/>}</span></pre><h2 id="5b86" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">将创造知识转移到工厂</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/7156dc0e38815529b39b57aa50d7c09a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*eMQVYyEcBCyUpPfQBty_Vg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将创造知识转移到工厂</p></figure><p id="a405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个案例描述了<a class="ae ky" href="https://industriallogic.com/xp/refactoring/creationWithFactory.html" rel="noopener ugc nofollow" target="_blank">对象</a>的复杂初始化，为了简化代码和封装，Kerievsky提出用工厂类限制来约束进程的知识。</p><p id="7c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们也卖汽车。毫无疑问，这是一辆更复杂的车，有更多的参数和选择。让我们用燃料类型、传输类型和车轮直径的附加参数实现相应的视图控制器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c6a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图控制器的初始化方式如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="05e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以实现一个专门的工厂来处理初始化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="1fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…并像这样使用它:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="f161" class="no me it nn b gy ol om l on oo"><strong class="nn iu">let</strong> factory = UsedCarViewControllerFactory(<br/>    engineType: .gas, transmissionType: .manual, wheelDiameter: 17<br/>)<br/><strong class="nn iu">let</strong> vc = factory.makeCarViewController()</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="32a0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">工厂方法</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/3ad3f952c9cfe4a4d038260ee09e8896.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WSoFG6uBkq5fwX_WAEIrrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工厂方法UML</p></figure><p id="2a7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种单根模式也封装了关于具体类型的知识。它通过多态来实现这一点，而不是将实现细节隐藏在专门的类中。Kerievsky在他的书中提供了用<a class="ae ky" href="https://java.com/" rel="noopener ugc nofollow" target="_blank"> Java </a>编写的例子，并提议使用<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html" rel="noopener ugc nofollow" target="_blank">抽象类</a>，但是敏捷用户不知道它是什么。我们独立自主，我们有协议。</p><p id="d638" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">四人帮的书上说这种模式也被称为虚拟构造函数，这是有道理的。在C++中，如果函数被派生类重写，我们称之为虚函数。然而，人们不能将构造函数声明为虚拟的，并且可以推测，模式发明是由模拟所需行为的尝试引起的。</p><h2 id="8daa" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">多态创建</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/1750351620f3ac285a4dd580fdfc8601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wAy6ykK166FYS4ZTzm6DMQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">介绍Joshua Kerievsky用工厂方法创建多态</p></figure><p id="102a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为使用模式的经典例子，让我们考虑这样一种情况:除了在方法内部创建的对象实现之外，同一层次结构中的<a class="ae ky" href="https://industriallogic.com/xp/refactoring/polymorphicCreationFactory.html" rel="noopener ugc nofollow" target="_blank">不同类型具有相似的方法实现。让我们尝试通过将对象创建移到外部来改善这种情况，并通过将它在层次结构中向上移动一步来使类似的方法变得常见。</a></p><p id="6fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到我们的车辆视图控制器:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="f4c4" class="no me it nn b gy ol om l on oo"><strong class="nn iu">final</strong> <strong class="nn iu">class</strong> BicycleViewController: UIViewController { }<br/><strong class="nn iu">final</strong> <strong class="nn iu">class</strong> ScooterViewController: UIViewController { }</span></pre><p id="eb0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们考虑一下这个视图控制器演示，并声明一个<a class="ae ky" href="https://habr.com/ru/post/444038/" rel="noopener ugc nofollow" target="_blank">协调器</a>:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="a028" class="no me it nn b gy ol om l on oo"><strong class="nn iu">protocol</strong> Coordinator {<br/>    <strong class="nn iu">var</strong> presentingViewController: UIViewController? { <strong class="nn iu">get</strong> <strong class="nn iu">set</strong> }<br/>    <strong class="nn iu">func</strong> start()<br/>}</span></pre><p id="9b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑这些协调器实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="78e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法<code class="fe nk nl nm nn b">start()</code>有类似的实现，除了在内部创建的视图控制器。让我们将创作移至室外:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="07ca" class="no me it nn b gy ol om l on oo"><strong class="nn iu">protocol</strong> Coordinator {</span><span id="c63a" class="no me it nn b gy os om l on oo">    <strong class="nn iu">var</strong> presentingViewController: UIViewController? { <strong class="nn iu">get</strong> <strong class="nn iu">set</strong> }</span><span id="3fea" class="no me it nn b gy os om l on oo">    <strong class="nn iu">func</strong> start()<br/>    <strong class="nn iu">func</strong> makeViewController() -&gt; UIViewController</span><span id="902d" class="no me it nn b gy os om l on oo">}</span></pre><p id="6213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…并使用<code class="fe nk nl nm nn b">start()</code>方法的默认实现扩展协议:</p><pre class="kj kk kl km gt oh nn oi oj aw ok bi"><span id="f5cd" class="no me it nn b gy ol om l on oo"><strong class="nn iu">extension</strong> Coordinator {<br/>    <strong class="nn iu">func</strong> start() {<br/>        <strong class="nn iu">let</strong> vc = makeViewController()<br/>        presentingViewController?.present(vc, animated: true)<br/>    }<br/>}</span></pre><p id="e740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么实现将是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c346" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="a5ba" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">我试图通过结合三种方法来强调这个相当简单的主题:</p><ul class=""><li id="e0aa" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu ot nc nd ne bi translated">经典的宣言方法的存在受到了四人帮的书的鼓励。</li><li id="a50d" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu ot nc nd ne bi translated">使用由基里耶夫斯基的书赤裸裸地启发的动机。</li><li id="a540" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu ot nc nd ne bi translated">应用使用我所熟悉的软件工程分支。</li></ul><p id="80c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这样做的时候，我试图尽可能接近模式的教科书结构，不违反当代的iOS编程原则，并使用Swift语言的可能性(而不是更广泛的C++和Java)。</p><p id="b9ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，很难找到一个好的应用实例。与经典实现相比，大多数现有文章和指南仅包含肤浅的评论和减少的示例。</p><p id="775a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望，我达到了我的目标，你喜欢更新或刷新你的相关知识！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="632a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">更多关于设计模式的精选</strong></p><div class="ou ov gp gr ow ox"><a href="https://medium.com/devexperts/real-world-example-of-using-coordinator-pattern-in-an-ios-app-d13df10496a5" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">在iOS应用程序中使用协调模式的真实例子</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">当代编程世界充满了趋势，谈论iOS应用更是一个真理。希望…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://lazarevzubov.medium.com/composite-data-source-object-and-elements-of-functional-approach-b93356fdb49e" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">复合数据源和功能方法的要素</h2><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">lazarevzubov.medium.com</p></div></div><div class="pg l"><div class="pm l pi pj pk pg pl ks ox"/></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://lazarevzubov.medium.com/compatible-with-objective-c-swift-code-e7c3239d949" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">与Objective-C Swift代码兼容</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">尽管苹果已经向我们提供了关于如何在Objective-C中使用Swift代码的详细文档…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">lazarevzubov.medium.com</p></div></div><div class="pg l"><div class="pn l pi pj pk pg pl ks ox"/></div></div></a></div></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="a7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读我(和其他作者)在Medium上的博客，你可以<strong class="lb iu">成为正式的Medium成员</strong>(如果还没有)<a class="ae ky" href="https://lazarevzubov.medium.com/membership" rel="noopener"> <strong class="lb iu">这里</strong> </a>。这样做，你就支持了所有的媒体作者。🙏</p><p id="e918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…或者你可以给我买一杯咖啡！☕</p></div></div>    
</body>
</html>