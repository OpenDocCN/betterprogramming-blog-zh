<html>
<head>
<title>Laravel: Fail, Retry, or Delay a Queued Job From Itself</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:失败、重试或延迟排队作业本身</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/laravel-fail-retry-or-delay-a-queued-job-from-itself-41e0bb14440c?source=collection_archive---------2-----------------------#2019-10-21">https://betterprogramming.pub/laravel-fail-retry-or-delay-a-queued-job-from-itself-41e0bb14440c?source=collection_archive---------2-----------------------#2019-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你可能不知道你可以使用这些技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e552ae50212456efa2313118aecdf23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yNUHEw4Fe9Z-Aac9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Emile Guillemot 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8610" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建要推入队列的作业、侦听器或订阅者时，您可能会开始想，一旦被分派，队列工作器决定如何处理您的逻辑，您就只能靠自己了。</p><p id="881b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯…并不是说你<em class="lv">不能</em>从工作内部与队列工作人员互动，而是你通常不<em class="lv">需要</em>去…直到你这样做。</p><p id="193a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">神奇的事情发生是因为<code class="fe lw lx ly lz b">InteractsWithQueue</code>的特性。当排队的作业被从队列中取出时，<code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/laravel/framework/blob/5.8/src/Illuminate/Events/CallQueuedListener.php#L90-L104" rel="noopener ugc nofollow" target="_blank">CallQueuedListener</a></code>将检查它是否使用了<code class="fe lw lx ly lz b">InteractsWithQueue</code>特征，如果是，框架将<em class="lv">注入</em>内部的底层“作业”实例。</p><p id="3eef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个“job”实例就像是包装真正的<code class="fe lw lx ly lz b">Job</code>类的驱动程序，其中包含关于连接和尝试的信息。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="aac0" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">语境</h1><p id="a16a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我将用一个代码转换<code class="fe lw lx ly lz b">Job</code>作为例子。这是一项将播客音频文件转码为192kbps的MP3的工作。因为这是在免费转码队列中设置的，所以它的可用性有限。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2bc1" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">检查尝试</h1><p id="13d7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">第一种方法叫做<code class="fe lw lx ly lz b">attempts()</code>，顾名思义，返回尝试次数。总是从一次尝试开始。</p><p id="218f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法可以和其他方法一起使用，比如<code class="fe lw lx ly lz b">fail()</code>或<code class="fe lw lx ly lz b">release()</code>(延迟)。出于举例说明的目的，我们将通知用户第<em class="lv">n</em>次重试:每次我们试图转码空闲队列中的播客时，我们将通知用户我们将重试第<em class="lv">n</em>次，给他取消未来转码的选项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当逻辑已经失败时，告诉用户我们正在第<em class="lv">n</em>次重试是有用的，让用户(或开发人员)检查哪里出错了，但是当然你可以做得更多。</p><p id="b4ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，我喜欢在和<code class="fe lw lx ly lz b">Job</code>失败后做那个<em class="lv">，如果它还有重试时间，告诉他我们稍后会重试。当然，这个例子只是为了说明的目的。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0f77" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">删除作业</h1><p id="0f90" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">第二种方法是<code class="fe lw lx ly lz b">delete()</code>。您可以猜到，您可以从队列中删除当前的<code class="fe lw lx ly lz b">Job</code>。</p><p id="cf11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您由于多种原因而不应该处理队列中的作业或侦听器时，这可能会很方便。例如，考虑一下这个场景:上传播客的发布者在转码发生之前由于任何原因(比如违反TOS)被停用，我们应该<strong class="lb iu">而不是</strong>处理播客。</p><p id="0e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把这段代码添加到前面的例子中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="97aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要删除可能已被删除的模型上的作业，您可能希望<a class="ae ky" href="https://laravel.com/docs/5.8/queues#ignoring-missing-models" rel="noopener ugc nofollow" target="_blank">将</a> <code class="fe lw lx ly lz b"><a class="ae ky" href="https://laravel.com/docs/5.8/queues#ignoring-missing-models" rel="noopener ugc nofollow" target="_blank">$deleteWhenMissingModels</a></code> <a class="ae ky" href="https://laravel.com/docs/5.8/queues#ignoring-missing-models" rel="noopener ugc nofollow" target="_blank">设置为真</a>以避免处理不存在的东西。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="3bf5" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">工作失败</h1><p id="ad23" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当您需要控制逻辑的人为失败时，这非常非常方便，因为使用空的<code class="fe lw lx ly lz b">return</code>语句会将<code class="fe lw lx ly lz b">Job</code>标记为成功完成。您可以强制使排队的作业失败，希望出现异常，如果可能的话，允许处理程序稍后重试。</p><p id="1562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使您在作业失败时可以更好地控制。在任何情况下，您也可以使用<code class="fe lw lx ly lz b">failed()</code>方法，该方法允许您在失败后<a class="ae ky" href="https://laravel.com/docs/5.8/queues#cleaning-up-after-failed-jobs" rel="noopener ugc nofollow" target="_blank">执行任何清理，如通知用户或删除某些内容。</a></p><p id="4609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，如果由于某种原因无法从存储中检索到播客，比如当CDN关闭时，抛出一个自定义异常，那么我们的任务就会失败。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="50b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，进入最后一个方法。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="42f6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">释放(延迟)作业</h1><p id="4af3" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这可能是最有用的方法，因为它允许你把工作推向未来。此方法用于<a class="ae ky" href="https://laravel.com/docs/5.8/queues#rate-limiting" rel="noopener ugc nofollow" target="_blank">限制您的作业</a>的速率。</p><p id="965d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了速率限制之外，你还可以在某样东西不可用但你希望它在不久的将来可用的时候使用它。此外，为了避免先发制人的失败。</p><p id="bda6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后一个例子中，我们将延迟代码转换:如果代码转换器的使用量很大，我们将延迟代码转换五分钟，直到负载降低。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="83ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用一些魔法，例如，将一些插槽分配给代码转换器，如果代码转换器插槽已满，则延迟作业。</p><p id="2707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这几乎是您在排队作业中所能做的全部工作。排队愉快。</p></div></div>    
</body>
</html>