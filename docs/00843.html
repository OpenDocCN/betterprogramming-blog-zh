<html>
<head>
<title>Modeling Typescript Interfaces to Support Angular HTTP requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建模Typescript接口以支持角度HTTP请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modeling-typescript-interfaces-to-support-angular-http-requests-add452e15b7f?source=collection_archive---------0-----------------------#2019-07-21">https://betterprogramming.pub/modeling-typescript-interfaces-to-support-angular-http-requests-add452e15b7f?source=collection_archive---------0-----------------------#2019-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8837" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在AJAX中建模数据响应</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/accd2f2f5755e80ca45b17d2359c55bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nGtFD6t2hUIJUWaEZZdOg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/gray-laptop-computer-showing-html-codes-in-shallow-focus-photography-160107/" rel="noopener ugc nofollow" target="_blank">负空间</a>上的<a class="ae ky" href="https://www.pexels.com/photo/gray-laptop-computer-showing-html-codes-in-shallow-focus-photography-160107/" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</p></figure><p id="a52a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Angular单页应用程序使用大量Ajax请求与web服务器通信，并从数据库中检索数据。在本文中，我将给出一些关于如何管理数据响应的提示。这将帮助您为Ajax流建立一个良好的设计层。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/5510ed1603dd175f8ae205bc0930114e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrLU6ietENY20N_62MIDqA.jpeg"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="08a6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">基础知识:Observables和HttpClient</h1><p id="76be" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从Angular 4到Angular 8，框架开始大量使用Observables，并承诺处理从AJAX获取的数据。Angular的一些版本似乎更喜欢承诺，其他一些版本更喜欢观察，但目标基本上总是相同的。我们有一个服务方法，从我们的Angular组件调用，我们希望在服务器弹出数据时得到通知。</p><p id="aec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺和可观察是完全不同的。请记住，<strong class="lb iu">承诺是简单的对象</strong>，其中<em class="na">满足</em>和<em class="na">拒绝</em>可能的状态，而<strong class="lb iu">可观察值是请求的“流”</strong>。如果您需要控制这些请求，Observables的用途会更加广泛。我不会在承诺上花更多的时间，但是一定要在可观察到的和承诺之间小心选择。我们将集中讨论Observables的实现。我们之所以关注Observables，是因为Observables在当前官方的devs角度文档中是作为默认实现出现的。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="9314" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">HTTP JSON响应:非结构化版本</h1><p id="7b4a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当您的目标是从Angular服务中发出Ajax请求时，您可以开始编写如下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自Angular服务的基本HTTP请求，返回observable <any>。</any></p></figure><p id="d99c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的<code class="fe nd ne nf ng b">getCandies()</code>方法非常简单，没有结构。我们使用类型推断向调用者返回一个通用的可观察对象，因为它是HttpClient中<code class="fe nd ne nf ng b">get()</code>方法的返回类型。那么，这里的可观察对象处理的是什么类型呢？它只是一个打字稿“任何。”</p><p id="e4d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码可以工作，但是当组件订阅了<code class="fe nd ne nf ng b">getCandies()</code>方法后，它会从中获得什么呢？如果HTTP状态代码是500或任何其他错误，则肯定是一个错误。如果成功了呢？很简单，你得到一个“任何”对象。就像说我们要用Java里的Object类。当我们访问对象的字段时，我们不知道里面有什么。然后，我们很容易得到未定义的值(比如Java <code class="fe nd ne nf ng b">NullPointerException</code>)。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f4c9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">处理响应的可观察接口:第一种方法</h1><p id="b425" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">因此，我们的目标是使用Typescript接口来表示提取的数据的结构。假设我们想从JSON中获取糖果:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="de21" class="nl me it ng b gy nm nn l no np">[<br/> {<br/>    color : “yellow”,<br/>    flavour : “lemonade”,<br/>    calories : 24<br/> },<br/> {<br/>    color : “brown”,<br/>    flavour : “chocolate”,<br/>    calories : 89<br/> },<br/> <br/>  ...</span><span id="f478" class="nl me it ng b gy nq nn l no np">]</span></pre><p id="f4c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易编写这样的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="87cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并像这样更新服务方法实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个更好的实现，但仍然太松散。</p></figure><p id="8802" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，现在我们在第一次代码修改中获得了一些好处。现在我们有一个接口来映射字段和定义糖果结构。这很好，因为我们的组件现在将接收一个糖果，而不是一个通用的“任何”对象。组件将很高兴知道它得到什么和访问什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="c0bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我在几个Angular项目中见过的最流行的实现。它之所以好，是因为它编码快如闪电，易于理解，而且大多数时候我们不再需要它了。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="f9ac" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">为什么这还不够:最终方法</h1><p id="96ed" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当您的应用程序开始增长时，我们开始编写各种各样的接口，它们之间没有任何共享。Typescript不是Java，但它对OOP操作和层次结构提供了很好的支持。我们可以使用继承，假设有一个响应的泛型实现，然后子类化这个泛型类。这是个好主意，但我们可以做得更好。</p><p id="5417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你擅长类建模，你知道我们可以接近类似于Java集合的东西。这些结构可以处理和容纳几乎任何东西。唯一的要求是数据必须是对象子类。为了工作，Java SDK使用泛型。泛型是某种特定类的“占位符”。因此，如果我们定义一个泛型的数组列表，我们可以很容易地在数组列表声明中选择要处理的类。</p><p id="bb26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Angular HTTP请求中，泛型是处理与使用相同模型生成的JSON具有相同结构的数据的最佳选择。这种实现实际上取决于您的web服务规范，并且不是强制性的。但是如果你可以控制你的后端(或者你可以和后端开发者讨论和定义通用的响应结构)，你可以使用泛型来开发前端应用。假设您的后端希望在任何情况下对所有调用做出如下JSON响应:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="2480" class="nl me it ng b gy nm nn l no np">{<br/>    success : true,<br/>    errorMessage : "Something went wrong", // optional<br/>    data : [...] // changes according to WS specs<br/>}</span></pre><p id="a567" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为所有web服务调用建立一个公共的HTTP响应可能是一个好主意。它将代表一种对你的微服务的默认响应，并且很容易读写文档。</p><p id="e6b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，回到前端，我们如何在HttpClient Observables中处理它呢？这里的问题是数据——它有许多形式，并且与不同的模型相关。使用泛型来映射“数据”类型、布尔类型以及共享和公共字段的字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">好方法:我们的默认AjaxResponse接口。</p></figure><p id="ed38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我们定义了一个AjaxResponse接口，它将泛型类型反映到数据字段中。很百搭。您甚至可以考虑一个以上的通用实现，因此它非常适合各种用途。现在，每当我们需要生成一个包含糖果、饼干或其他任何东西的可观察对象时，我们只需指定一般类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nb nc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的更新<code class="fe nd ne nf ng b">getCandies()</code>方法</p></figure><p id="affc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">泛型非常有趣，并且提供了一种很好的方法来“概括”类型的实现。请记住，泛型是改变类型或适应特定环境的唯一方法——“任何”类型都不是一回事。方法中的“any”参数可以承载任何种类的参数类型，但它会使您的编译器丢失类型引用。这是因为对象转换为“任何”</p><p id="679d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JSON请求、参数和响应确实没有类型，因为JSON是一种不匹配的JavaScript类型。但是如果你想设计一个好的应用程序，如果你不想失去数据控制和管理，你就不能避免接口。</p><p id="d6c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">亲自尝试一下，您会喜欢Typescript泛型实现。</p></div></div>    
</body>
</html>