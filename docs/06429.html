<html>
<head>
<title>Plotting a Line Chart With Tooltips Using React and D3.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和D3.js绘制带有工具提示的折线图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-d3-plotting-a-line-chart-with-tooltips-ed41a4c31f4f?source=collection_archive---------2-----------------------#2020-10-01">https://betterprogramming.pub/react-d3-plotting-a-line-chart-with-tooltips-ed41a4c31f4f?source=collection_archive---------2-----------------------#2020-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="687d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">立即在您的应用中创建令人惊叹的数据可视化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d301e184a4488e328cd9505aa1b13ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ybtcWdZH_EUkcapQazG75Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="c552" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://d3js.org" rel="noopener ugc nofollow" target="_blank"> D3.js </a>是一个数据可视化库，用于使用HTML、CSS和SVG从数据中创建漂亮的图表和可视化表示。您可以绘制各种图表并从中进行选择，如树状图、饼图、旭日图、堆积面积图、条形图、箱线图、折线图、多折线图等等。你可以<a class="ae lr" href="https://observablehq.com/@d3/gallery" rel="noopener ugc nofollow" target="_blank">看看这里的画廊。</a></p><p id="0b1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将使用D3在React中创建一个简单(但是可爱)的带有工具提示的折线图。</p><h2 id="49ec" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">先决条件</h2><ol class=""><li id="0a37" class="ml mm iq kx b ky mn lb mo le mp li mq lm mr lq ms mt mu mv bi translated">如果您还没有React应用程序，请创建一个新的应用程序。</li><li id="5a33" class="ml mm iq kx b ky mw lb mx le my li mz lm na lq ms mt mu mv bi translated">添加D3 v5.16.0作为依赖项。</li></ol></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="f88b" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">我们开始吧</h1><p id="db8e" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">首先，我们创建一个新的组件，我们把它放在一个名为<code class="fe nw nx ny nz b">LineChart.js</code>的文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="5e6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nw nx ny nz b">&lt;LineChart /&gt;</code>将接受图表的三个道具——<code class="fe nw nx ny nz b">data</code>(图表上要绘图的数据)<code class="fe nw nx ny nz b">width</code><strong class="kx ir"/><code class="fe nw nx ny nz b">height</code><strong class="kx ir"/>。我们添加了一个<code class="fe nw nx ny nz b">useEffect</code>钩子来调用我们的<code class="fe nw nx ny nz b">drawChart()</code>函数。这个钩子将依赖于数据属性，因为我们希望每次数据改变时都重新绘制图表。</p><p id="acd8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们已经呈现了一个id设置为<code class="fe nw nx ny nz b">container</code>的<code class="fe nw nx ny nz b">&lt;div&gt;</code>元素，它将包含我们的SVG元素。</p><p id="1a7b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，让我们看看将要呈现这个折线图的组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0116" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nw nx ny nz b">regenerateData()</code>生成随机数据，并在首次安装时以及每次点击<code class="fe nw nx ny nz b">Change Data</code>按钮时设置组件数据状态。我们将<code class="fe nw nx ny nz b">height</code>、<code class="fe nw nx ny nz b">width</code>和<code class="fe nw nx ny nz b">data</code>作为道具传递给<code class="fe nw nx ny nz b">&lt;LineChart /&gt;</code>。</p><p id="a15f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数据对象包含一个<code class="fe nw nx ny nz b">label</code> (X轴)和一个<code class="fe nw nx ny nz b">value</code> (Y轴)以及一个我们想在图表上显示的<code class="fe nw nx ny nz b">tooltipContent</code>。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="5853" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">绘制图表</h1><p id="3f5d" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">我们现在将添加绘制图表的逻辑。让我们先在<code class="fe nw nx ny nz b">drawChart()</code>函数中定义一些常数。</p><pre class="kg kh ki kj gt oc nz od oe aw of bi"><span id="651e" class="ls lt iq nz b gy og oh l oi oj">const margin = { top: 50, right: 50, bottom: 50, left: 50 };</span><span id="ad28" class="ls lt iq nz b gy ok oh l oi oj">const yMinValue = d3.min(data, d =&gt; d.value);<br/>const yMaxValue = d3.max(data, d =&gt; d.value);</span><span id="f0c4" class="ls lt iq nz b gy ok oh l oi oj">const xMinValue = d3.min(data, d =&gt; d.label);<br/>const xMaxValue = d3.max(data, d =&gt; d.label);</span></pre><p id="5621" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们添加了SVG元素和tooltip元素:</p><pre class="kg kh ki kj gt oc nz od oe aw of bi"><span id="78a2" class="ls lt iq nz b gy og oh l oi oj">const svg = d3<br/>    .select('#container')<br/>    .append('svg')<br/>    .attr('width', width + margin.left + margin.right)<br/>    .attr('height', height + margin.top + margin.bottom)<br/>    .append('g')<br/>    .attr('transform', `translate(${margin.left},${margin.top})`);</span><span id="f083" class="ls lt iq nz b gy ok oh l oi oj">const tooltip = d3<br/>    .select('#container')<br/>    .append('div')<br/>    .attr('class', 'tooltip');</span></pre><p id="f1d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们选择<code class="fe nw nx ny nz b">#container</code>元素，并在其中添加一个SVG元素和一个<code class="fe nw nx ny nz b">g</code>元素来分组其他SVG元素，然后平移它，留下左边距和上边距。我们还添加了一个包含我们的<code class="fe nw nx ny nz b">tooltipContent</code>的<code class="fe nw nx ny nz b">div</code>元素。</p><p id="50b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来让我们定义轴比例和线/路径生成器:</p><pre class="kg kh ki kj gt oc nz od oe aw of bi"><span id="aafe" class="ls lt iq nz b gy og oh l oi oj">const xScale = d3<br/>    .scaleLinear()<br/>    .domain([xMinValue, xMaxValue])<br/>    .range([0, width]);</span><span id="41fb" class="ls lt iq nz b gy ok oh l oi oj">const yScale = d3<br/>    .scaleLinear()<br/>    .range([height, 0])<br/>    .domain([0, yMaxValue]);</span><span id="2c31" class="ls lt iq nz b gy ok oh l oi oj">const line = d3<br/>    .line()<br/>    .x(d =&gt; xScale(d.label))<br/>    .y(d =&gt; yScale(d.value))    <br/>    .curve(d3.curveMonotoneX);</span></pre><p id="7acf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nw nx ny nz b">d3.scaleLinear()</code>将给定域内的任意给定数映射到给定范围。这些刻度将帮助我们找到每个数据项在图上的位置/坐标。</p><p id="5ebf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们画出网格线(如果你愿意，可以跳过这一步)、X轴、Y轴以及数据线:</p><pre class="kg kh ki kj gt oc nz od oe aw of bi"><span id="9cba" class="ls lt iq nz b gy og oh l oi oj">svg<br/>    .append('g')<br/>    .attr('class', 'grid')<br/>    .attr('transform', `translate(0,${height})`)<br/>    .call(<br/>    d3.axisBottom(xScale)<br/>        .tickSize(-height)<br/>        .tickFormat(''),<br/>    );</span><span id="bd28" class="ls lt iq nz b gy ok oh l oi oj">svg<br/>    .append('g')<br/>    .attr('class', 'grid')<br/>    .call(<br/>        d3.axisLeft(yScale)<br/>        .tickSize(-width)<br/>        .tickFormat(''),<br/>    );</span><span id="184e" class="ls lt iq nz b gy ok oh l oi oj">svg<br/>    .append('g')<br/>    .attr('class', 'x-axis')<br/>    .attr('transform', `translate(0,${height})`)<br/>    .call(d3.axisBottom().scale(xScale).tickSize(15));</span><span id="9ea2" class="ls lt iq nz b gy ok oh l oi oj">svg<br/>    .append('g')<br/>    .attr('class', 'y-axis')<br/>    .call(d3.axisLeft(yScale));</span><span id="463a" class="ls lt iq nz b gy ok oh l oi oj">svg<br/>    .append('path')<br/>    .datum(data)<br/>    .attr('fill', 'none')<br/>    .attr('stroke', '#f6c3d0')<br/>    .attr('stroke-width', 4)<br/>    .attr('class', 'line') <br/>    .attr('d', line);</span></pre><p id="0741" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们添加另一组SVG元素，它们将包含Y轴上的网格线。我们将<code class="fe nw nx ny nz b">tickFormat</code>设置为空字符串，因为我们不想用它们绘制任何标签。这些网格线的高度被设置为等于图表的高度，但是我们添加了<code class="fe nw nx ny nz b">—</code>，以便它们被绘制在<code class="fe nw nx ny nz b">axisBottom</code>的上方，而不是下方。类似地，我们沿着X轴画网格线。</p><p id="7747" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们绘制实际的轴以及附加的线路径。此时，您已经创建了折线图！</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="6239" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">添加工具提示</h1><p id="b8be" class="pw-post-body-paragraph kv kw iq kx b ky mn jr la lb mo ju ld le nt lg lh li nu lk ll lm nv lo lp lq ij bi translated">我们将为我们悬停的点添加一个圆形标记和一个工具提示框。最初，工具提示的不透明度将被设置为0，并且圆圈标记也不会显示，除非发生了一些鼠标事件。</p><pre class="kg kh ki kj gt oc nz od oe aw of bi"><span id="d28e" class="ls lt iq nz b gy og oh l oi oj">const focus = svg<br/>    .append('g')<br/>    .attr('class', 'focus')<br/>    .style('display', 'none');</span><span id="5c53" class="ls lt iq nz b gy ok oh l oi oj">focus.append('circle').attr('r', 5).attr('class', 'circle');</span><span id="3489" class="ls lt iq nz b gy ok oh l oi oj">const tooltip = d3<br/>    .select('#container')<br/>    .append('div')<br/>    .attr('class', 'tooltip')<br/>    .style('opacity', 0);</span></pre><p id="5700" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们将在图表上追加一个<code class="fe nw nx ny nz b">rect</code>(它将不可见，所以我们将不透明度设置为0)来捕获鼠标事件:</p><pre class="kg kh ki kj gt oc nz od oe aw of bi"><span id="b38f" class="ls lt iq nz b gy og oh l oi oj">svg<br/>    .append('rect')<br/>    .attr('class', 'overlay')<br/>    .attr('width', width)<br/>    .attr('height', height)<br/>    .style('opacity', 0)<br/>    .on('mouseover', () =&gt; {<br/>        focus.style('display', null);<br/>    })<br/>    .on('mouseout', () =&gt; {<br/>        tooltip<br/>            .transition()<br/>            .duration(300)<br/>            .style('opacity', 0);<br/>    })<br/>   .on('mousemove', mousemove);</span><span id="26ac" class="ls lt iq nz b gy ok oh l oi oj">function mousemove(event) {<br/>    const bisect = d3.bisector(d =&gt; d.label).left;<br/>    const xPos = d3.mouse(this)[0]; <br/>    const x0 = bisect(data, xScale.invert(xPos));<br/>    const d0 = data[x0];<br/>    focus.attr(<br/>        'transform',<br/>        `translate(${xScale(d0.label)},${yScale(d0.value)})`,<br/>    );<br/>    tooltip<br/>        .transition()<br/>        .duration(300)<br/>        .style('opacity', 0.9);<br/>    tooltip<br/>        .html(d0.tooltipContent || d0.label)<br/>        .style(<br/>            'transform',<br/>            `translate(${xScale(d0.label) + 30}px,${yScale(d0.value) - 30}px)`,<br/>    );<br/>}</span></pre><p id="22df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们将鼠标移动到图表上时，<code class="fe nw nx ny nz b">mousemove()</code>函数将负责找出光标的位置，计算出最近的绘图点，并将工具提示和圆圈标记翻译到最近的点。</p><p id="f727" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nw nx ny nz b">xScale.invert</code>从刻度范围(即图表的宽度)中获取一个数字，并将其映射到刻度的域(即X轴上值之间的数字)。记住上面的<code class="fe nw nx ny nz b">scaleLinear()</code>反转是它的反转。<code class="fe nw nx ny nz b">bisect</code>帮助我们找到该反转点左侧最近的点。</p><p id="ba53" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们希望确保在用新数据绘制新图表之前清除旧图表。因此，将此添加到您的<code class="fe nw nx ny nz b">drawChart()</code>函数的顶部:</p><pre class="kg kh ki kj gt oc nz od oe aw of bi"><span id="347c" class="ls lt iq nz b gy og oh l oi oj">d3.select('#container')<br/>      .select('svg')<br/>      .remove();</span><span id="deac" class="ls lt iq nz b gy ok oh l oi oj">d3.select('#container')<br/>      .select('.tooltip')<br/>      .remove();</span></pre><p id="a931" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！我们的线图准备好了。显然，你会想给你的图表添加更多的样式，但是我会让你来决定。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="2677" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在GitHub 上找到上面的<a class="ae lr" href="https://github.com/ihsavru/d3-examples" rel="noopener ugc nofollow" target="_blank">代码。感谢阅读！</a></p></div></div>    
</body>
</html>