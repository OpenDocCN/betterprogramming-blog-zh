<html>
<head>
<title>RxSwift: Deep Inside FlatMap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift:深入平面地图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxswift-deep-inside-flatmap-1ca150c41b18?source=collection_archive---------5-----------------------#2021-01-25">https://betterprogramming.pub/rxswift-deep-inside-flatmap-1ca150c41b18?source=collection_archive---------5-----------------------#2021-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dc3a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解Combine和RxSwift中最强大(也最容易混淆)的运算符之一的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d9a789341d65dad9494b4fc64f7e9203.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S5HmTdap1R2D2FJuwPtHbA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">插图</a>通过ReactiveX文档</p></figure><p id="1dd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ReactiveX武器库中最强大的操作之一是<code class="fe lv lw lx ly b">FlatMap</code>。然而对许多人来说，这也是最难理解的操作之一。</p><p id="8025" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们将深入研究<code class="fe lv lw lx ly b">FlatMap</code>，当我们完成时，你将确切地知道它是如何工作的，何时使用它，以及如何避开它周围的一些陷阱。</p><p id="7694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将深入了解一些RxSwift运算符。一旦您理解了一些实现细节，其余的也就变得容易理解了。</p><p id="cf13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Combine的实现可能会有所不同，但一旦您理解了RxSwift版本背后的关键概念，您将能够在任何地方和任何平台上使用它。</p><p id="9f74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们开始吧。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="901e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">平面图函数签名</h1><p id="c763" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">函数签名帮助不大。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="230b" class="nh mh it ly b gy ni nj l nk nl">extension ObservableType {<br/>  func flatMap&lt;O:Observable&gt;(_ selector:(E) -&gt; O) -&gt; Observable&lt;O.E&gt;<br/>}</span></pre><p id="b740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了清晰起见，我对签名做了一点编辑，但是除非你是RxSwift和泛型方面的专家，否则它仍然非常密集。所以我们来试试官方的定义。</p><h2 id="3b47" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">官方定义</h2><p id="c426" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">引用ReactiveX网站上关于 <code class="fe lv lw lx ly b"><a class="ae ky" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">FlatMap</a></code>的<a class="ae ky" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">文档:</a></p><blockquote class="nx ny nz"><p id="268d" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">“<code class="fe lv lw lx ly b">FlatMap</code>运算符通过将您指定的函数应用到源可观察对象发出的每个项目来转换可观察对象，其中该函数返回一个自身发出项目的可观察对象。<code class="fe lv lw lx ly b">FlatMap</code>然后合并这些产生的可观测量的发射，发射这些合并的结果作为它自己的序列。</p><p id="b5b4" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">例如，当您有一个发出一系列项的可观察对象，这些项本身具有可观察成员或者可以通过其他方式转换为可观察对象时，此方法非常有用，这样您就可以创建一个新的可观察对象，它发出由这些项的子可观察对象发出的项的完整集合。"</p></blockquote><p id="1354" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次看到这个，读起来像古梵文，眼睛开始呆滞。再读一遍(第三遍、第四遍、第五遍)也无济于事。</p><p id="ece6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文开头展示的大理石图似乎也没有太多意义。三个事件进去了，六个事件出来了——但是它们都混在一起了。这是怎么回事？</p><p id="6496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，今天，我可以读他们两个，理解他们想说什么，当我们完成时，你也能。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="58f3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一些基本原则</h1><p id="1f97" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我将从今天讨论的几个重要基础开始。请通读它们，以确保你和我在同一页上，我们在讨论同样的事情。</p><p id="f4ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在RxSwift中，人们订阅可观测数据以接收未来事件。这和我们在iOS中使用<code class="fe lv lw lx ly b">NotificationCenter</code>真的没什么区别。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ff76" class="nh mh it ly b gy ni nj l nk nl">NotificationCenter.default<br/>    .addObserver(self, selector: #selector(onOrientationChange(_:)), name: UIDevice.orientationDidChangeNotification, object: nil)</span><span id="76da" class="nh mh it ly b gy oe nj l nk nl">func onOrientationChange(_ sender:AnyObject) {<br/>    // do something<br/>}</span></pre><p id="417a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们向<code class="fe lv lw lx ly b">orientationDidChangeNotification</code>添加了一个观察者，并告诉它我们希望在将来每当事件发生时得到通知。因此，每当用户旋转他们的设备时，我们的<code class="fe lv lw lx ly b">onOrientationChange</code>委托就会被调用。</p><p id="2d84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在RxSpeak中，我们订阅了一个可观察对象来接收未来事件。因此，当在RxSwift中完成时，这看起来相似也就不足为奇了。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e8b1" class="nh mh it ly b gy ni nj l nk nl">NotificationCenter.default<br/>    .rx<br/>    .notification(UIDevice.orientationDidChangeNotification)<br/>    .subscribe(onNext: { _ in<br/>        // do something<br/>    })<br/>    .disposed(by: disposeBag)</span></pre><p id="0549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一真正的区别是我们的订阅处理程序是一个闭包而不是一个委托函数，RxSwift使用了一个额外的<code class="fe lv lw lx ly b">disposed(by:)</code>操作符来取消我们不再需要的订阅。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="59d9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">卷你自己的</h1><p id="1370" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">那么，如果我告诉你我们需要一些代码来做类似于<code class="fe lv lw lx ly b">NotificationCenter</code>的事情，但是你实际上不能使用<code class="fe lv lw lx ly b">NotificationCenter </code>(或者Rx或者Combine)呢？</p><p id="9f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，如果你想一分钟，你可能会意识到在它的核心，<code class="fe lv lw lx ly b">NotificationCenter</code>实际上只不过是一个字典，它的关键字是通知名，它的值是一个观察器数组。也许让键字符串和订户闭包只是为了使实现更简单。</p><p id="a606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当发送一个通知时，send函数所做的就是在字典中查找该通知，获取订阅数组，然后遍历该数组，依次执行每个闭包。“哟，伙计们。是时候了。做你的事。”</p><p id="9be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大概是这样的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="214a" class="nh mh it ly b gy ni nj l nk nl">class MyNotificationCenter {</span><span id="e2d7" class="nh mh it ly b gy oe nj l nk nl">    static var subscriptions: [String:[() -&gt; Void]] = [:]</span><span id="7661" class="nh mh it ly b gy oe nj l nk nl">    static func subscribe(name: String, block: @escaping ()-&gt;Void) {<br/>        var subs = subscriptions[name] ?? []<br/>        subs.append(block)<br/>        subscriptions[name] = subs<br/>    }</span><span id="f42d" class="nh mh it ly b gy oe nj l nk nl">    static func send(name: String) {<br/>        subscriptions[name]?.forEach { $0() }<br/>    }<br/>    <br/>}</span></pre><p id="ea05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，你可以做:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="701a" class="nh mh it ly b gy ni nj l nk nl">MyNotificationCenter<br/>    .subscribe(name: "myEvent") {<br/>        // do something when myEvent occurs<br/>    }</span><span id="10cb" class="nh mh it ly b gy oe nj l nk nl">MyNotificationCenter.send(name: "myEvent")</span></pre><p id="4f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想说的是在所有花哨的术语背后，这些东西只是代码。</p><p id="e5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不是说代码不复杂。RxSwift对其<code class="fe lv lw lx ly b">Element</code>类型和锁定使用泛型，以确保它是线程安全的和可处理的，从而管理订阅生命周期。所有这些都增加了复杂性——毫无疑问。</p><p id="c4ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是核心概念足够简单。</p><p id="4cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<em class="oa">可观测的</em>是事件的来源。一个<em class="oa">订阅</em>订阅那些事件。发送事件可以简单到遍历一组订阅者，并告诉每个订阅者他们感兴趣的事件已经发生。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3faf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">事件</h1><p id="e1d5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在RxSwift中，我们谈论了很多关于事件的内容。下面是实际的定义:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="21f4" class="nh mh it ly b gy ni nj l nk nl">public enum Event&lt;Element&gt; {<br/>    /// Next element is produced.<br/>    case next(Element)<br/>    /// Sequence terminated with an error.<br/>    case error(Swift.Error)<br/>    /// Sequence completed successfully.<br/>    case completed<br/>}</span></pre><p id="f38c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">Event</code>只是列举了三种情况。</p><ol class=""><li id="aa26" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><code class="fe lv lw lx ly b">next(Element)</code>用来传递我们感兴趣的值。如果你创建了一个<code class="fe lv lw lx ly b">PublishSubject&lt;String&gt;</code>，那么<code class="fe lv lw lx ly b">Element</code>就是<code class="fe lv lw lx ly b">String</code>。</li><li id="d8a9" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe lv lw lx ly b">error(Swift.Error)</code>用来传递任何可能发生的错误。</li><li id="5858" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe lv lw lx ly b">completed</code>简单地告诉我们，我们完成了，不会再有新的事件发生。</li></ol><p id="f18e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果订阅链生成错误或完成事件，整个订阅链都会关闭。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c6ae" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">出版主题</h1><p id="908f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你可能已经注意到，在创建<code class="fe lv lw lx ly b">MyNotificationCenter</code>的过程中，我们基本上构建了自己的RxSwift的<code class="fe lv lw lx ly b">PublishSubject</code>的微缩版本。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0bb3" class="nh mh it ly b gy ni nj l nk nl">let publisher = PublishSubject&lt;Void&gt;()</span><span id="57c1" class="nh mh it ly b gy oe nj l nk nl">publisher<br/>    .subscribe(onNext: { _ in<br/>        print("We've got one!")<br/>    })<br/>    .disposed(by: disposeBag)</span><span id="66bb" class="nh mh it ly b gy oe nj l nk nl">publisher.onNext(())</span></pre><p id="5c73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在RxSwift中，发布者使用<code class="fe lv lw lx ly b">onNext</code>通过订阅链将下一个元素发送给订阅者(对应于前面提到的<code class="fe lv lw lx ly b">Event</code>枚举的<code class="fe lv lw lx ly b">next</code>部分)。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1b1f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">订阅链</h1><p id="1892" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">RxSwift和Combine都与<em class="oa">订阅链</em>打交道。通常你有某种类型的发行商，在链条的中间可能有一个或两个(或三个或15个)运营商，最后都以订阅或绑定结束。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="193c" class="nh mh it ly b gy ni nj l nk nl">let publisher = PublishSubject&lt;Int&gt;()</span><span id="951b" class="nh mh it ly b gy oe nj l nk nl">publisher<br/>    .map { $0 * 2.5 }<br/>    .filter { $0 &gt; 10 }<br/>    .subscribe(onNext: { n in<br/>        print("We've got number \(n)!")<br/>    })<br/>    .disposed(by: disposeBag)</span></pre><p id="c7e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你订阅或绑定到一个可观察或一个<em class="oa">可观察链</em>时，订阅链就建立了。换句话说，这就是可观测链。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e88d" class="nh mh it ly b gy ni nj l nk nl">let chain = publisher<br/>    .map { $0 * 3 }<br/>    .filter { $0 &gt; 10 }</span></pre><p id="2399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的代码订阅或绑定到订阅链时，订阅链就在幕后构建了。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ee86" class="nh mh it ly b gy ni nj l nk nl">chain<br/>    .subscribe(onNext: { n in<br/>        print("We've got number \(n)!")<br/>    })<br/>    .disposed(by: disposeBag)</span></pre><p id="2678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幕后发生的事情令人着迷。</p><p id="93be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，<code class="fe lv lw lx ly b">subscribe</code>函数隐藏闭包并订阅链中的最后一个可观察对象。这里它订阅了<code class="fe lv lw lx ly b">filter</code>，它基本上告诉它，“嘿，老伙计。每当你碰巧得到一个你想传递的事件，把它委托给我。”</p><p id="9678" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反过来，<code class="fe lv lw lx ly b">filter</code>操作符对其父操作符<code class="fe lv lw lx ly b">map</code>做同样的事情。“哟。把你收到的任何事件的结果发给我。当然，在那之后，你要对他们做什么就做什么。”</p><p id="f22a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe lv lw lx ly b">map</code>订阅了链中的父节点<code class="fe lv lw lx ly b">publisher</code>，正如我们已经看到的，它只是将订阅添加到订阅者列表中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a58a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">发送事件</h1><p id="15ee" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，如果我们告诉发布者发送一个事件给它的观察者…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5179" class="nh mh it ly b gy ni nj l nk nl">publisher.onNext(5)</span></pre><p id="01d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们触发以下事件序列:</p><ol class=""><li id="5479" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated"><code class="fe lv lw lx ly b">publisher</code>打开它的订阅代理列表，取出第一个，并向它发送一个<code class="fe lv lw lx ly b">5</code>。</li><li id="7288" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe lv lw lx ly b">map</code>操作符接收一个<code class="fe lv lw lx ly b">5</code>，将值传递给它的闭包，然后将结果发送给链中的下一个委托(<code class="fe lv lw lx ly b">3*5=15</code>)。</li><li id="381b" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated"><code class="fe lv lw lx ly b">filter</code>操作符接收<code class="fe lv lw lx ly b">15</code>并将该值传递给它的比较闭包，在这种情况下，比较闭包返回<code class="fe lv lw lx ly b">true</code>。因为是<code class="fe lv lw lx ly b">true</code>，所以<code class="fe lv lw lx ly b">filter</code>将继续发送当前值给它的代理。</li><li id="347c" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">订阅(<code class="fe lv lw lx ly b">subscribe</code>)接收<code class="fe lv lw lx ly b">15</code>并将其传递给<code class="fe lv lw lx ly b">onNext</code>处理程序，后者打印出“<code class="fe lv lw lx ly b">We’ve got number 15!</code>”</li><li id="7e0c" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">订阅链已经完成了。我们所有的嵌套调用都返回到发布者循环。</li><li id="ff79" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">现在，循环将<code class="fe lv lw lx ly b">onNext</code>值<code class="fe lv lw lx ly b">5</code>发送给列表中的下一个订阅者，依此类推，直到发布者知道的每个订阅链都被通知了新值。</li><li id="1da1" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">现在我们从<code class="fe lv lw lx ly b">onNext</code>语句中返回。</li></ol><p id="d868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次强调，这里的要点是Rx序列不是黑魔法。告诉发布者<code class="fe lv lw lx ly b">onNext(5)</code>开始一个调用委托的循环，委托调用闭包，闭包的值传递给链中的下一个委托。</p><p id="ee2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程不断重复，根据操作者的不同会有不同的铃声和哨声，直到我们完成。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cdbe" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">过滤器</h1><p id="a768" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这一点非常清楚，让我们看看过滤操作符的一个假想实现的内部。(这不是实际的RxSwift实现，但它演示了实际使用的机制。)</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="182c" class="nh mh it ly b gy ni nj l nk nl">class FilterOperator: Observable&lt;Element&gt; {</span><span id="0386" class="nh mh it ly b gy oe nj l nk nl">    var subscriber: Subscriber&lt;Element&gt;<br/>    var predicate: (_ value: Element) -&gt; Bool</span><span id="d182" class="nh mh it ly b gy oe nj l nk nl">    func on(_ event: Event&lt;Element&gt;) {<br/>        switch event {<br/>        case .next(let value):<br/>            if predicate(value) {<br/>                subscriber.on(.next(value))<br/>            }<br/>        default:<br/>            subscriber.on(event)<br/>        }<br/>    }</span><span id="79ae" class="nh mh it ly b gy oe nj l nk nl">    ...    <br/>}</span></pre><p id="b1f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，这个过程中令人惊讶的缺少黑魔法。</p><p id="d9dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">on(_ event: Event&lt;Element&gt;)</code>函数是委托协议，它由它的父级用序列中的下一个事件调用。</p><p id="312e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数开启事件类型。</p><p id="9175" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个<code class="fe lv lw lx ly b">next</code>事件中，存储的闭包(<code class="fe lv lw lx ly b">predicate</code>)用提取的值调用，如果闭包返回<code class="fe lv lw lx ly b">true</code>，相同的值被传递给链中的下一个订户。</p><p id="441a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果闭包返回<code class="fe lv lw lx ly b">false</code>，下面的委托就不会被调用，事件会被“神奇地”从链中过滤掉。</p><p id="d6db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意在这个实现中，<code class="fe lv lw lx ly b">completed</code>和<code class="fe lv lw lx ly b">error</code>事件只是沿着链向下转发，绕过了调用闭包的代码。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="43eb" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">地图</h1><p id="28ee" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们试试<code class="fe lv lw lx ly b">Map</code>操作符。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e314" class="nh mh it ly b gy ni nj l nk nl">class MapOperator: Observable&lt;Output&gt; {</span><span id="d995" class="nh mh it ly b gy oe nj l nk nl">    var subscriber: Subscriber&lt;Output&gt;<br/>    var transform: (_ value: Element) -&gt; Output</span><span id="0539" class="nh mh it ly b gy oe nj l nk nl">    func on(_ event: Event&lt;Element&gt;) {<br/>        switch event {<br/>        case .next(let value):<br/>            let newValue = transform(value)         <br/>            subscriber.on(.next(newValue))<br/>        default:<br/>            subscriber.on(event)<br/>        }<br/>    }</span><span id="52a5" class="nh mh it ly b gy oe nj l nk nl">    ...<br/>}</span></pre><p id="d168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再一次，<code class="fe lv lw lx ly b">on(_ event: Event&lt;Element&gt;)</code>函数是委托，它被它的父函数用一个值调用。</p><p id="d6f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数内部，用传递的值调用存储的转换闭包。该函数返回一个新的映射值，该值再次作为下一个值传递给链中的下一个订阅者。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8d05" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">执行流程</h1><p id="e519" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">filter</code>和<code class="fe lv lw lx ly b">map</code>都是以平稳、不间断的流程操纵和传递事件和价值的典型例子。</p><p id="2ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接收一个值。用那个值调用一个函数。得到结果。将结果传递给链中的下一个委托。</p><p id="a9c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常简单。</p><p id="f105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，对于我们拥有的代码，它根本不能以任何其他方式运行。在Swift中，你调用一个函数，这个函数必须返回值。</p><p id="cfa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">的确，函数可以循环增加160亿个数字，但是考虑到执行流程，我们调用的任何函数都必须带值退出。</p><p id="702a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们调用的任何函数都可以等待一些结果，但是这样做会阻塞当前线程——因为该函数必须返回值。我是说，这是函数的定义。</p><p id="2c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们现在没有这个值，并且我们真的，真的，真的不想阻塞正在等待它的当前线程，会发生什么呢？假设我们需要进行一个API调用，然后在服务器给我们一个API调用时返回结果？</p><p id="7159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，当我对发送和接收未来事件感兴趣时，我在RxSwift中做什么？</p><p id="68fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我创建了一个可观察对象并订阅它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0f03" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">平面地图</h1><p id="48cc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这又回到了我们为什么在这里。让我们再来看看<code class="fe lv lw lx ly b">FlatMap</code>的函数签名。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="575f" class="nh mh it ly b gy ni nj l nk nl">extension ObservableType {<br/>  func flatMap&lt;O:Observable&gt;(_ selector:(E) -&gt; O) -&gt; Observable&lt;O.E&gt;<br/>}</span></pre><p id="9147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在光线开始穿透迷雾。<code class="fe lv lw lx ly b">FlatMap</code>将一个函数作为参数，该函数接受一个值，然后返回一个<code class="fe lv lw lx ly b">E</code>类型的可观察值。</p><p id="b888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，你传递给<code class="fe lv lw lx ly b">flatMap</code>的闭包是在说，“好吧，我现在不想要你想要的东西。但是如果你观察可观察的，我将返回你感兴趣的值——它应该很快就会出现。”</p><p id="3bd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">收到之后，<code class="fe lv lw lx ly b">FlatMap</code>会将该值传递给链中的下一个订户。</p><p id="0d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">鉴于我们已经看到的和做的，我怀疑你可以自己编写基本的实现，但这里是我的例子。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2bbe" class="nh mh it ly b gy ni nj l nk nl">class FlatMapOperator: Observable&lt;Output&gt; {</span><span id="7b0d" class="nh mh it ly b gy oe nj l nk nl">    var subscriber: Subscriber&lt;Output&gt;<br/>    var transform: (_ value: Element) -&gt; Observable&lt;Output&gt;<br/>    var subscriptions: [Disposable]</span><span id="898e" class="nh mh it ly b gy oe nj l nk nl">    func on(_ event: Event&lt;Element&gt;) {<br/>        switch event {<br/>        case .next(let value):<br/>            let disposable = transform(value)<br/>                .subscribe(onNext: { newValue in<br/>                    self.subscriber.onNext(.next(newValue))<br/>                }, onError: { e in<br/>                    self.subscriber.onNext(.error(e))<br/>                ))<br/>            subscriptions.append(disposable)<br/>        default:<br/>            subscriber.onNext(event)<br/>        }<br/>    }<br/>    <br/>    ...<br/>}</span></pre><p id="63f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接收带有值的事件。将该值传递给函数，并通过调用<code class="fe lv lw lx ly b">transform</code>获得一个可观察的结果。在内部订阅可观察对象，并等待它给我们发送一些东西。</p><p id="e7f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当订阅收到一个值时，将它传递给我们的代理，就像我们过去对<code class="fe lv lw lx ly b">filter</code>和<code class="fe lv lw lx ly b">map</code>操作符所做的那样。</p><p id="ea39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">跟踪一次性订阅只是日常事务。当我们的运营商离开后，我们将会关闭我们一直在跟踪的所有订阅。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ee12" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">图表</h1><p id="2002" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在让我们看看我们的麻烦图是否有意义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1cb532e385c5b68da4da4352f87ea5b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3u7N3e6dhIE0iniDLlHQw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">插图</a>通过ReactiveX文档</p></figure><p id="bd7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于接收到的每个值，我们的闭包<code class="fe lv lw lx ly b">{ }</code>会将该值转换成一个可观察值，对于这个例子来说，这个可观察值会随时间返回两个值。(为了清楚起见，我给这些事件添加了数字。)</p><p id="24d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们得到一个红色值，并返回一个最终生成红色1和红色2的可观察值。这些值被发送到下游。然后，该可观察性完成，并且<code class="fe lv lw lx ly b">flatMap</code>取消订阅。</p><p id="e074" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到一个绿色值，它返回一个可观察值，这个可观察值又产生绿色1，但是在它设法产生第二个值之前，我们收到一个蓝色事件。它的可观测性很快产生蓝色1，它被发送到下游。</p><p id="c296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随后，我们的绿色和蓝色的可观测物分别产生它们自己的第二个事件，绿色2和蓝色2，并且这些事件被传递下去。已完成和已取消订阅。</p><p id="0209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们的输入Observable本身完成了，这关闭了整个订阅链。</p><p id="2338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们愿意，我们实际上可以在RxSwift中对这个序列进行编码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="36a0" class="nh mh it ly b gy ni nj l nk nl">let publisher = PublishSubject&lt;String&gt;()</span><span id="4c59" class="nh mh it ly b gy oe nj l nk nl">publisher<br/>    .flatMap { (color) -&gt; Observable&lt;String&gt; in<br/>        return .create { (observer) -&gt; Disposable in<br/>            observer.onNext("\(color) 1")<br/>            delay(0.1) {<br/>                observer.onNext("\(color) 2")<br/>                observer.onCompleted()<br/>            }<br/>            return Disposables.create()<br/>        }<br/>    }<br/>    .subscribe(onNext: { (color) in<br/>        print(color)<br/>    })<br/>    .disposed(by: disposeBag)</span><span id="b2ba" class="nh mh it ly b gy oe nj l nk nl">delay(0.10) { publisher.onNext("red") }<br/>delay(0.30) { publisher.onNext("green") }<br/>delay(0.35) { publisher.onNext("blue") }<br/>delay(0.90) { publisher.onCompleted() }</span></pre><p id="058e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数<code class="fe lv lw lx ly b">delay</code>只是一个帮助函数，设计用于在指定的延迟后给<code class="fe lv lw lx ly b">DispatchQueue</code>加上一个闭包。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b228" class="nh mh it ly b gy ni nj l nk nl">func delay( _ t: TimeInterval, f: <a class="ae ky" href="http://twitter.com/escaping" rel="noopener ugc nofollow" target="_blank">@escaping</a> ()-&gt;Void ) {<br/>    DispatchQueue.main.asyncAfter(deadline: .now() + t, execute: f)<br/>}</span></pre><p id="5c49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是您所期望的，并与上面的大理石图相匹配。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3332" class="nh mh it ly b gy ni nj l nk nl">red 1<br/>red 2<br/>green 1<br/>blue 1<br/>green 2<br/>blue 2</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d0b2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">定义</h1><p id="db90" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">而我们最初的定义呢？</p><blockquote class="nx ny nz"><p id="652e" class="kz la oa lb b lc ld ju le lf lg jx lh ob lj lk ll oc ln lo lp od lr ls lt lu im bi translated">“<code class="fe lv lw lx ly b">FlatMap</code>运算符通过将您指定的函数应用到源可观察对象发出的每个项目来转换可观察对象，其中该函数返回一个自身发出项目的可观察对象。<code class="fe lv lw lx ly b">FlatMap</code>然后合并这些结果可观测量的发射，将这些合并的结果作为它自己的序列发射。—<a class="ae ky" href="http://reactivex.io/documentation/operators/flatmap.html" rel="noopener ugc nofollow" target="_blank">react vex文档</a></p></blockquote><p id="17aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能需要一点精神体操，但是根据你现在所知道的，至少你的眼睛不应该呆滞。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b369" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用平面图</h1><p id="d437" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们到最后的时候，你可能会说，“这一切都很好，但是我实际上要用它做什么呢？”</p><p id="b88f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，<code class="fe lv lw lx ly b">FlatMap</code>的一个非常常见的用例是将API调用链接在一起。考虑:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4d60" class="nh mh it ly b gy ni nj l nk nl">func login(_ credentials: Credentials) -&gt; Observable&lt;User&gt; {<br/>    return SSO.knownEndpoint()<br/>        .flatMap { (endpoint) -&gt; Observable&lt;String&gt; in<br/>            return SSO.authenticate(credentials, endpoint: endpoint)<br/>        }<br/>        .flatMap { (token) -&gt; Observable&lt;User&gt; in<br/>            return Users.loadUser(forToken: token)<br/>        }<br/>}</span></pre><p id="00e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我调用一个API来获取一个授权端点，将我的凭证传递给我的身份验证API，然后将得到的令牌传递给另一个API来为我的当前用户加载信息。</p><p id="5b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个被调用的函数返回它自己的可观察值，这些值被简单地传递给<code class="fe lv lw lx ly b">FlatMap</code>。这里有一个调用<code class="fe lv lw lx ly b">Users.loadUser</code>的例子，也展示了RxSwift 6的新<code class="fe lv lw lx ly b">decode</code>操作符。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1cee" class="nh mh it ly b gy ni nj l nk nl">class Users {<br/>    static func loadUser(forToken t: String) -&gt; Observable&lt;User&gt; {<br/>        session.post(path: .user, parameters: ["token":t])<br/>            <!-- -->.decode(type: User.self, decoder: JSONDecoder())<br/> <!-- -->   }</span><span id="be91" class="nh mh it ly b gy oe nj l nk nl">    ...<br/>}</span></pre><p id="6bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如图所示，<code class="fe lv lw lx ly b">FlatMap</code>可以显著改善需要将API调用链接在一起的情况，简化代码并避免错误处理金字塔。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="244a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">处理错误</h1><p id="cbe8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后一点需要更多的解释。</p><p id="fb5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果<code class="fe lv lw lx ly b">FlatMap</code>中的<em class="oa">任何</em>订阅返回一个错误，该错误将被传播并发送到订阅链，最终终止对我们数据的任何订阅。事实上，我们在<code class="fe lv lw lx ly b">flatMap</code>订阅处理程序中看到了这种机制。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="73d1" class="nh mh it ly b gy ni nj l nk nl">.subscribe(onNext: { newValue in<br/>    self.subscriber.onNext(.next(newValue))<br/>}, onError: { e in<br/>    self.subscriber.onNext(.error(e))<br/>))</span></pre><p id="3754" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的<code class="fe lv lw lx ly b">login</code>例子中，这不是问题。我们的订阅链将在每次用户尝试登录时被重新构建和调用，实际上看到返回的错误正是我们想要的。</p><p id="adf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这可能不是你在所有情况下都想要的行为。那么，如何防止错误终止长期订阅呢？</p><p id="1d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，一个简单的解决方法是在<code class="fe lv lw lx ly b">FlatMap</code>订阅能够看到错误之前<em class="oa">捕捉并处理任何错误。</em></p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0b83" class="nh mh it ly b gy ni nj l nk nl">...<br/>.flatMap { _ in<br/>    service.loadArticles()<br/>        .catchErrorJustReturn([])<br/>}<br/>...</span></pre><p id="b6ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们试图加载一个文章列表，但是如果加载失败，我们就打住并返回一个空数组。</p><p id="367e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在以前的一篇文章“RxSwift:用CompactMap更好地处理错误”中写过关于在<code class="fe lv lw lx ly b">FlatMap</code>中处理错误的内容。</p><p id="a13b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一件值得强调的事情是，虽然错误会从<code class="fe lv lw lx ly b">FlatMap</code>中传播出去，但完成不会。将<code class="fe lv lw lx ly b">.completed</code>从闭包返回到包含的<code class="fe lv lw lx ly b">FlatMap</code>只是一个信号，表明该订阅已经完成，您不再需要监视它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d179" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们正在订阅，我们正在订阅…</h1><p id="2df6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">注意，<code class="fe lv lw lx ly b">FlatMap</code>为它接收的每个事件值生成一个新的可观察对象，并因此生成该可观察对象的新订阅。</p><p id="b928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是上面定义中的“<code class="fe lv lw lx ly b">FlatMap</code>然后合并这些产生的可观测量的排放”部分。那是它的标准行为。这可能正是您想要的，但您应该知道还有另一个常见版本的<code class="fe lv lw lx ly b">FlatMap</code>可用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="72ba" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">平面地图最新</h1><p id="fad9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">做得和它宣传的差不多，映射并返回最新生成的可观察结果。每次它接收到一个值，就会通过丢弃它来取消对之前的订阅(如果有的话),然后订阅闭包返回的最新可观察值。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9ae6" class="nh mh it ly b gy ni nj l nk nl">class FlatMapLatestOperator: Observable&lt;Output&gt; {</span><span id="52d5" class="nh mh it ly b gy oe nj l nk nl">    var subscriber: Subscriber&lt;Output&gt;<br/>    var transform: (_ value: Element) -&gt; Observable&lt;Output&gt;<br/>    var disposable: Disposable?</span><span id="5e61" class="nh mh it ly b gy oe nj l nk nl">    func on(_ event: Event&lt;Element&gt;) {<br/>        switch event {<br/>        case .next(let value):<br/>            disposable?.dispose()<br/>            disposable = transform(value)<br/>                .subscribe(onNext: { newValue in<br/>                    self.subscriber.onNext(.next(newValue))<br/>                }, onError: { e in<br/>                    self.subscriber.onNext(.error(e))<br/>                ))<br/>        default:<br/>            subscriber.onNext(event)<br/>        }<br/>    }</span><span id="b8d6" class="nh mh it ly b gy oe nj l nk nl">    ...    <br/>}</span></pre><p id="ddaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在上面的颜色生成示例中使用了<code class="fe lv lw lx ly b">.flatMapLatest</code>而不是<code class="fe lv lw lx ly b">.flatMap</code>，输出将如下所示。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d54d" class="nh mh it ly b gy ni nj l nk nl">red 1<br/>red 2<br/>green 1<br/>blue 1<br/>blue 2</span></pre><p id="a94f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，green 2已经不存在了，因为它的订阅在它的可观察对象可以生成它的第二个事件之前就被丢弃了。</p><p id="381f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的应用有一个持续很长时间的订阅链，你可以考虑使用<code class="fe lv lw lx ly b">.flatMapLatest</code>。</p><p id="9caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，如果您正在做类似预输入搜索字段的事情，并且不再关心先前的API请求可能返回的任何结果，那么它也会很方便。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1f10" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">用户交互</h1><p id="d8d1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">FlatMap</code>和<code class="fe lv lw lx ly b">FlatMapLatest</code>都等待事件发生并被传递，这不仅限于API调用。您还可以使用它们来处理用户交互，比如确认对话框。</p><p id="f954" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，<code class="fe lv lw lx ly b">FlatMapLatest</code>是一个更好的选择，因为我只关心最近的动作。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f5ab" class="nh mh it ly b gy ni nj l nk nl">button.rx.tap<br/>    .flatMapLatest { () -&gt; Observable&lt;Continue&gt; in<br/>        return Dialogs.confirmSaveDialog()<br/>    }<br/>    .filter { $0 == .continue }<br/>    ...</span></pre><p id="4ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击按钮后，<code class="fe lv lw lx ly b">flatMapLatest</code>会显示一个确认对话框，然后在继续序列前等待响应。在这种情况下，接收到的响应被过滤，只有当用户点击Continue时，序列的剩余部分才会被执行。</p><p id="15e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常强大的概念，我保证以后会在另一篇文章中讨论它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="be0a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">完成块</h1><p id="8cac" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">那就是<code class="fe lv lw lx ly b">FlatMap</code>和它的近亲<code class="fe lv lw lx ly b">FlatMapLatest</code>。</p><p id="7b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经尽了最大努力来消除围绕它的一些困惑，阐明它在内部是如何工作的，甚至还给出了一些如何在代码中使用它的例子。</p><p id="f950" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但主要是我试图提供我希望在第一次阅读ReactiveX定义时就能得到的定义和解释。</p><p id="4b03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">享受吧。</p></div></div>    
</body>
</html>