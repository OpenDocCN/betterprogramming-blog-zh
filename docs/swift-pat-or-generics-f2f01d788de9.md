# Swift — PAT 还是 Generics？

> 原文：<https://betterprogramming.pub/swift-pat-or-generics-f2f01d788de9>

![](img/d2b52d09c442c1c9d1ffe7d47ae966fc.png)

## 两者都做同样的工作，那么，用哪一个呢？

# 帕特？

在我们开始之前，让我解释一下这里的术语。PAT 表示具有相关类型的协议。pat 可以是通用的，这意味着您可以使用任何类型([您可以参考我之前写的这篇关于 Swift 中的协议如何用作通用类型的文章](https://shawonashraf.github.io/blog/swift-associated-type-generic/)，添加类型约束等等。让我们看一个例子:

这里我们有一个名为`PlayerDescriptorProtocol`的协议，它有一个名为`getSpeciality`的函数。符合此协议的类型必须提供此函数的实现，以描述播放器的特性。这在某种程度上是好的，但是我们应该问，什么类型的`Player`应该符合这个协议？是足球运动员还是网球运动员？还是板球运动员？你可以这样想:不同类型的玩家会有不同的特长，不是吗？

所以让我们把这个弄得不那么模糊。我们将在这里添加一个关联类型。

让我们检查一下符合的类型。在此之前，我们先做一个玩家类型。

现在让我们为我们的协议获取一个符合类型。

我们应该期待下面的输出— `All-Rounder`

一切都好了，对吧？我的意思是，现在扔一个`FootballPlayer`或者`TennisPlayer`也没什么坏处。但是等一下，亲爱的华生，我们有事情要讨论。

# 这里会出什么问题呢？

实际上没有什么，除非你真的关心你的应用程序的低级性能。你认为编译器是如何计算出 PAT 使用什么类型的？当然，泛型是这样工作的，编译器会想办法解决，但问题是什么时候。

## 输入动态调度

对于 pat，编译器必须在运行时计算出类型，这意味着它必须通过动态调度来完成。这个东西到底是什么？更简单地说，动态调度意味着将事情推迟到运行时再做决定，而不是在编译时将事情具体化。动态调度对于多态类型是必要的，因为编译器不知道在编译时使用哪种类型，所以它在运行时做出决定。

## 静态调度

静态调度正好相反。编译器已经知道该做什么，对正在使用的类型有一个清晰的概念，并且在编译时做所有的事情。

## 静态调度更快吗？

相比较而言，是的。但是比动态调度好吗？你必须明白这两者是针对不同的任务的，你的编译器已经被设计成让它们非常有效地工作。如果你有机会从两者中选择一个呢？

# 泛型和静态分派

让我们使用泛型重写相同的代码。

是时候测试一下了！

```
describePlayer(of: shaks)

// output : All-Rounder
```

# 两人做着同样的工作…

是的，他们做到了。那么，选择哪一个呢？动态还是静态？为了做出决定，我们必须考虑以下事实:

1.  虽然由于静态调度，泛型会更快，但与动态类型的 pat 相比，它也会占用更多内存。为什么？因为对于每种类型，编译器会将新函数压入堆栈，而对于 PAT，由于动态调度，只会创建所需的函数。
2.  如果您不希望`Player`类符合协议，并且还希望为每个描述符类保留单独的定义，该怎么办？你最终会写出更多的代码！

在我看来，挑一个你需要的。如果你不介意牺牲一点内存来获得编译器的额外性能，那么就选择泛型，否则就选择 PATs 的便利性。这更像是在`struct`和`class`之间做出选择，因为没有绝对的赢家，所以选择一个能做好你的工作的。

# 闲聊够了

让我们唱首歌凉快一下。

你也可以在我的博客上看到同样的文章。T8*)*