<html>
<head>
<title>Kotlin Multiplatform — How To Create an App for Android, Desktop, and Web With Kotlin in One Codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin多平台——如何用Kotlin在一个代码库中创建一个适用于Android、桌面和Web的应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-multiplatform-how-to-create-an-app-for-android-desktop-and-web-with-kotlin-in-one-10bbb565f477?source=collection_archive---------3-----------------------#2022-04-19">https://betterprogramming.pub/kotlin-multiplatform-how-to-create-an-app-for-android-desktop-and-web-with-kotlin-in-one-10bbb565f477?source=collection_archive---------3-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3c4b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JetBrains的Compose Multiplatform去年达到了测试版，使他们提供跨平台UI框架的雄心更近了一步</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0a446d2fd6cb254d348f61613d50b855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJu1I9PO_oyu1E6Zx-MOPA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">科特林多平台总体原则(来源:<a class="ae kv" href="https://kotlinlang.org/docs/multiplatform.html#how-kotlin-multiplatform-works" rel="noopener ugc nofollow" target="_blank">kotlinlang.org</a></p></figure><p id="a594" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还不知道什么是Compose Multiplatform，这里有一个直接从<a class="ae kv" href="https://www.jetbrains.com/lp/compose-mpp/" rel="noopener ugc nofollow" target="_blank"> JetBrains网站</a>复制的TLDR:</p><blockquote class="ls lt lu"><p id="d406" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">Kotlin的快速反应桌面和Web UI框架，基于谷歌的<a class="ae kv" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">现代工具包</a>，由JetBrains带给你。</p></blockquote><p id="abcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当与Jetpack Compose结合使用时，这意味着我们现在可以只使用Kotlin来制作针对移动、桌面和web的应用程序。</p><p id="e9ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是说像扑扑一样，但是和科特林在一起？</p><p id="6648" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了Dart和Kotlin的事情之外，Kotlin多平台(KMP)和Flutter之间有相当显著的区别。我发现最有趣的是他们如何处理跨平台架构。</p><p id="fec8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Flutter中，你编写你的业务逻辑，你的UI，它可以在任何地方运行。您仍然可以编写一些调整逻辑来调整UI以适应平台，但最终，无论您将其构建到移动、桌面还是web应用程序中，您的应用程序都是通过Flutter引擎(基于Skia图形库构建)呈现的。这对于可移植性来说很好，但是不容易提供原生UI体验。</p><p id="6799" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在KMP，您只需编写一次业务逻辑并将其放入共享库中，然后使用针对每个目标平台的本地库编写您的UI，例如针对Android的Jetpack Compose、针对iOS的Swift、针对桌面的Compose Multiplatform等。因此，你的应用程序最终会有一种更自然的感觉——以用户界面的平台适应性为代价。</p><p id="aba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">底线是这两种方法提供了不同的方法，您选择哪一种取决于您的用例。</p><p id="4be6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，KMP听起来很棒，帮我报名吧！</p><p id="b6bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，在花了相当多的时间进行试验后，我理解并分享你的热情！但是让我们暂时把理论放在一边，把注意力放在“如何”上</p><h1 id="603a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们的演示应用</h1><p id="e560" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">嗯，我们需要决定开发什么，这样我就可以向您展示所有的操作了。让我们从Flutter“Hello World”应用程序中获得灵感，制作一个计数器应用程序，允许用户增加和减少一个数值，并记录最近注册的动作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/df3491a1e9291643b523211ad8424410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*eKMeXxADh9biQdcLwWHkgA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">看起来够简单！</p></figure><p id="ab68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们现在用什么架构呢？</p><h2 id="3405" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">体系结构</h2><p id="34c6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将使用模型-视图-视图模型(MVVM)的干净架构，这是构建GUI应用程序(尤其是在Android上)的常见解决方案。对于本教程的其余部分，我将假设您对此很熟悉。如果你不是，你可以离开这一页和<a class="ae kv" href="https://www.raywenderlich.com/3595916-clean-architecture-tutorial-for-android-getting-started" rel="noopener ugc nofollow" target="_blank">阅读这个</a>之前。是的，我允许你这么做！:)</p><p id="df0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，那我们开始吧。这是我们构建应用的方式:</p><ul class=""><li id="edcd" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated">域:这将包含我们的应用程序的模型，在本例中只是我们的计数器的一个数据类(值和最后的动作消息)</li><li id="beea" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">数据:存储该计数器的抽象数据源</li><li id="878f" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">用例:我们的应用程序的所有用例类，即:递增计数器，递减它并获取它的值</li><li id="54e6" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">演示:该计数器视图的视图模型</li><li id="e254" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated">框架:数据源实现以及每个平台的UI</li></ul><p id="6ae3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的每个元素都可以跨所有平台共享，除了UI，它是“框架”的一部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/971d4a49ca296f540783332fca6386f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*jR4zfwRSONvRol2qKXT-vw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们不同的模块</p></figure><h1 id="9f62" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们编码这个</h1><p id="108d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">好吧，我们现在开始研究代码。我正在使用IntelliJ IDEA社区，所以请记住这一点。但是我相信你，因为你会在我们进行的过程中根据你最喜欢的IDE对它进行调整。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0176" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该从创建一个新项目开始，项目结构如上所述，然后一个接一个地创建每个类，直到我们覆盖所有平台。IDEA为我们可以使用的KMP应用程序提供了预制模板，但出于学习目的，让我们从头开始做吧。</p><p id="8f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开IDEA，然后导航到“文件”&gt;“新建项目”选择“Gradle”，然后在右边的面板上，除了“Kotlin DSL build script”之外，将所有内容留空。在这之后，我们用Kotlin DSL代替Gradle作为构建脚本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/1c2dfcffe8f39094eba088d782fb6d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mWtb9rQl15J04auX3mx3UQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建一个新项目，我将我的命名为“KmpDemo”。</p></figure><p id="0d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后命名项目并创建它。</p><h2 id="0711" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">模块</h2><p id="699e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">第一步是创建不同的模块:<code class="fe ob oc od oe b">common</code>、<code class="fe ob oc od oe b">android</code>、<code class="fe ob oc od oe b">desktop</code>和<code class="fe ob oc od oe b">web</code>。我们从<code class="fe ob oc od oe b">common</code>开始，因为所有其他模块都将依赖于它。</p><p id="a1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">右键单击项目根目录，然后单击“新建&gt;模块…”。你会看到一个熟悉的对话框。这一次，除了其他选项之外，请确保选中“kot Lin/多平台”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/e14005d1e3e4b22e287420188cd4ff83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dp5K91bD2PVhySFscLlzA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通用的新模块</p></figure><p id="3c0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确保将其命名为“common”创建后，您将收到一个构建同步错误:</p><blockquote class="ls lt lu"><p id="4dd2" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">请在“common (:common)”中至少初始化一个Kotlin目标。</p></blockquote><p id="0751" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">暂时忽略它；我们稍后会修理它。</p><p id="54d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用相同的方法，创建<code class="fe ob oc od oe b">desktop</code>、<code class="fe ob oc od oe b">android</code>和<code class="fe ob oc od oe b">web</code>模块。</p><p id="3943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在根目录下创建一个新文件，命名为<code class="fe ob oc od oe b">gradle.properties</code>，内容如下:</p><pre class="kg kh ki kj gt og oe oh oi aw oj bi"><span id="be8c" class="mx ma iq oe b gy ok ol l om on">kotlin.code.style=official<br/>android.useAndroidX=true<br/>kotlin.mpp.enableGranularSourceSetsMetadata=true<br/>kotlin.native.enableDependencyPropagation=false<br/>android.enableJetifier=true</span></pre><p id="e86e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">项目结构现在应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/0e1e087ca4262ea46d048b49d0ef105d.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*CwEEhNtsBuO1w_iILG1n-w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的顶级模块</p></figure><p id="7896" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还有一些工作要做，以最终确定项目结构；我们应该创建源集。</p><h2 id="8993" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">源集</h2><p id="b6b6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一个KMP项目通常根据其目标性质将其源文件组织在不同的集合中:common、JVM和JS。我们将遵循官方文件中详述的推荐结构<a class="ae kv" href="https://kotlinlang.org/docs/multiplatform-discover-project.html#source-sets" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="5b7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od oe b">common</code>下创建以下目录:</p><ul class=""><li id="2d93" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/androidMain/kotlin</code></li><li id="513d" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/androidTest/kotlin</code></li><li id="22b4" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/commonMain/kotlin</code></li><li id="693b" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/commonTest/kotlin</code></li><li id="9e16" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/desktopMain/kotlin</code></li><li id="5474" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/desktopTest/kotlin</code></li></ul><p id="afde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od oe b">desktop</code>下:</p><ul class=""><li id="1988" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/jvmMain/kotlin</code></li><li id="0b6b" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/jvmTest/kotlin</code></li></ul><p id="857e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od oe b">web</code>下:</p><ul class=""><li id="05a4" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/jsMain/kotlin</code></li><li id="db0a" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/jsTest/kotlin</code></li></ul><p id="8657" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od oe b">android</code>下:</p><ul class=""><li id="716b" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><code class="fe ob oc od oe b">src/main/java</code></li></ul><p id="082f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">等等，我以为通用模块将是独立于平台的？为什么我们有这些</em> <code class="fe ob oc od oe b"><em class="lv">desktopMain</em></code> <em class="lv">和</em> <code class="fe ob oc od oe b"><em class="lv">androidMain</em></code> <em class="lv">的东西在那里？</em></p><p id="3cef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好问题！</p><p id="b1be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们考虑这个(虚构的)用例:您正在开发一个多平台应用程序，但是您还需要访问一些特定于平台的API。这可能是检索某个操作系统版本，连接到某个日志系统，或者生成一个随机UUID。</p><p id="f129" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，您会利用<a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置</a>在公共模块中创建一个接口，并在特定于平台的模块中创建它的实现。然而，当功能非常简单时，例如生成UUID，这会导致一些样板代码。</p><p id="2e76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">KMP允许一种更简单的方法来实现这一点，使用<a class="ae kv" href="https://kotlinlang.org/docs/multiplatform-connect-to-apis.html" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a><em class="lv"/>机制和上面的结构。因此，您可以执行如下操作:</p><pre class="kg kh ki kj gt og oe oh oi aw oj bi"><span id="797d" class="mx ma iq oe b gy ok ol l om on">// Under Common<br/>expect fun randomUUID(): String</span><span id="e014" class="mx ma iq oe b gy op ol l om on">// Under Android<br/>import java.util.*<br/><br/>actual fun randomUUID() = UUID.randomUUID().toString()</span><span id="8c52" class="mx ma iq oe b gy op ol l om on">// And so on for all other platforms</span></pre><p id="266f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不会用于我们的计数器应用程序，但我们最好为未来做好准备。:)</p><p id="f4af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们的应用程序，您现在应该有以下结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/1e54b9caf1e0d6753cc6062f2da01814.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*YQmCuNimeimunBl0q7IEww.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">别担心，漂亮的颜色很快就会出现</p></figure><p id="5754" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是时候实现构建脚本了！</p><h2 id="5f64" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">构建脚本</h2><p id="960e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">每个模块加上根包含一个名为<code class="fe ob oc od oe b">build.gradle.kts</code>的构建脚本，有时包含名为<code class="fe ob oc od oe b">settings.gradle.kts</code>的设置。这些文件定义了我们的项目是如何构建的:模块、依赖项、框架等等。</p><p id="9ec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od oe b">settings.gradle.kts</code>里，写着:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="cd57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这简单地定义了哪些存储库将用于获取外部依赖项以及项目模块。</p><p id="dc50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od oe b">build.gradle.kts</code>中，写下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ab90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多的是相同的，但是这次我们对构建脚本和所有模块都这样做。</p><p id="4db2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ob oc od oe b">common/build.gradle.kts</code>里，写着:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="909b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有很多东西。让我们打开这个。</p><p id="f7c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，指定模块的<code class="fe ob oc od oe b">plugins</code>定义是一个Compose模块和一个Android库。然后，我们用一些选项指定JS和JVM目标。这是允许其他模块导入公共数据所必需的。这些选项是默认选项。</p><p id="8218" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们定义源集，即Kotlin源文件的位置，以及它们的类型和依赖关系。注意<code class="fe ob oc od oe b">commonMain</code>依赖于<code class="fe ob oc od oe b">kotlinx-coroutines-core</code>和<code class="fe ob oc od oe b">kodein-di-framework-compose</code>。最后，如果你以前使用过Android，我们以一种熟悉的方式定义Android目标选项。</p><p id="bc89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们为Android定义了一个清单，所以让我们将它添加到<code class="fe ob oc od oe b">common/src/androidMain/AndroidManifest.xml</code>中提到的路径:</p><pre class="kg kh ki kj gt og oe oh oi aw oj bi"><span id="79ec" class="mx ma iq oe b gy ok ol l om on">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="org.example.kmpdemo"/&gt;</span></pre><p id="9258" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们来关注一下<code class="fe ob oc od oe b">desktop/build.gradle.kts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2948" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多的是相同的，但是注意我们明确定义了对<code class="fe ob oc od oe b">common</code>的依赖。</p><p id="8272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网络时间！写入<code class="fe ob oc od oe b">web/build.gradle.kts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5554" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多的相同，但再次注意，我们明确定义了对common的依赖。</p><p id="1683" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在是<code class="fe ob oc od oe b">android/build.gradle.kts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c1c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经完成了构建脚本，现在让我们转到应用程序源代码！</p><h2 id="509c" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">公共源代码</h2><p id="bd5f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在<code class="fe ob oc od oe b">commonMain/kotlin</code>目录下，创建一个包<code class="fe ob oc od oe b">org.example.kmpdemo</code>。</p><p id="305a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个包中，用文件<code class="fe ob oc od oe b">Counter.kt</code>创建一个域包:</p><pre class="kg kh ki kj gt og oe oh oi aw oj bi"><span id="8f69" class="mx ma iq oe b gy ok ol l om on">package org.example.kmpdemo.domain<br/><br/>/**<br/> * Model for the number counter<br/> * @param value The counter value<br/> * @param message Additional context attached to the counter<br/> */<br/>data class Counter (<br/>    val value: Int = 0,<br/>    val message: String = "Init"<br/>)</span></pre><p id="d8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们柜台的模型。够简单！</p><p id="ecb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在在<code class="fe ob oc od oe b">org.example.kmpdemo</code>中，用文件创建一个<code class="fe ob oc od oe b">data</code>包:</p><p id="7373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ob oc od oe b">CounterDataSource.kt</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ob oc od oe b">CounterRepository.kt</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2e03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们将使用流来观察计数器值，为了同步的灵活性，递增和递减的方法被定义为<code class="fe ob oc od oe b">suspend</code>。</p><p id="496a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们来关注用例。在<code class="fe ob oc od oe b">org.example.kmpdemo</code>中，用文件创建一个<code class="fe ob oc od oe b">usecase</code>包:</p><p id="beba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ob oc od oe b">GetCounter.kt</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ad24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ob oc od oe b">DecrementCounter.kt</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b4d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ob oc od oe b">IncrementCounter.kt</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7dfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们来关注一下视图模型。在<code class="fe ob oc od oe b">org.example.kmpdemo</code>中，用文件<code class="fe ob oc od oe b">CounterViewModel.kt</code>创建一个演示包:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="c35f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，递增和递减操作是在协程中实现的。</p><p id="7281" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快到了！在<code class="fe ob oc od oe b">org.example.kmpdemo</code>中，用文件<code class="fe ob oc od oe b">InMemoryCounterDataSource.kt</code>创建一个框架包:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="212b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们数据源的实际(基本)实现，我们的计数器是存储在这个类中的一个单例。这意味着它的值将在每次应用程序重新启动时被重置，但现在这已经足够了！</p><p id="e8c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">依赖注入的时间。在<code class="fe ob oc od oe b">org.example.kmpdemo</code>下创建一个<code class="fe ob oc od oe b">file di/ServicesModule.kt</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="0c0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着视图模型现在可以在所有平台的应用视图中注入。整洁！</p><p id="86ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在已经完成了<code class="fe ob oc od oe b">common</code>模块！</p><h2 id="c60a" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated">桌面源代码</h2><p id="b701" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们实现桌面应用程序。我只在Linux上测试过，但这应该可以在Windows和Mac上以同样的方式工作。创建一个文件，<code class="fe ob oc od oe b">desktop/src/jvmMain/kotlin/Main.kt</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ab7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢我们对<code class="fe ob oc od oe b">common</code>的依赖；我们可以简单地检索我们的DI模块并将视图模型注入到我们的应用程序中。逆向流被转换成一种可以很好地处理Compose的状态，剩下的就很简单了。</p><p id="9ff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击主函数旁边的运行图标，这应该是你的奖励:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/a4b5f78a32a6f331a28f1b65d2c7a622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*RweaFbbU3UB7v-YSofsy1g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">点击按钮就可以了，耶！</p></figure><h1 id="fa17" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Android源代码</h1><p id="204c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">创建包含<code class="fe ob oc od oe b">MainActivity.kt</code>的包<code class="fe ob oc od oe b">org.example.kmpdemo.android</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a7eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感觉很熟悉？是时候运行它了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/df3491a1e9291643b523211ad8424410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*eKMeXxADh9biQdcLwWHkgA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安卓:检查！</p></figure><h2 id="efc2" class="mx ma iq bd mb my mz dn mf na nb dp mj lf nc nd ml lj ne nf mn ln ng nh mp ni bi translated"><strong class="ak">网页源代码</strong></h2><p id="f0ad" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，我们应该在<code class="fe ob oc od oe b">web/src/jsMain/resources/index.html</code>创建基础<code class="fe ob oc od oe b">index.html</code>文件:</p><pre class="kg kh ki kj gt og oe oh oi aw oj bi"><span id="432b" class="mx ma iq oe b gy ok ol l om on">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;title&gt;Counter app&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;div id="root"&gt;&lt;/div&gt;<br/>&lt;script src="web.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="c25a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，创建<code class="fe ob oc od oe b">web/src/jsMain/kotlin/Main.kt</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="70d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">点击主函数旁边的运行图标，这应该是你的奖励:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/72d19009c0743cc285bd130002855718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rMte9vlEoSuH8PZHPHNSPQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Web应用程序。如你所见，CSS是我的激情所在…</p></figure><p id="2922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lv">等等，这看起来很不一样。还有div，H1…我在写HTML吗？！</em></p><p id="ff9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">遗憾的是，Compose for Web在这方面略落后于其他平台:</p><blockquote class="ls lt lu"><p id="a13d" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">“Compose for Web目前不允许您直接重用现有的小部件(不像Jetpack Compose的Android和桌面目标，允许直接共享大多数开箱即用的小部件的代码)。”<a class="ae kv" href="https://blog.jetbrains.com/kotlin/2021/05/technology-preview-jetpack-compose-for-web/" rel="noopener ugc nofollow" target="_blank">来源</a></p></blockquote><p id="a04e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，DOM API是功能性的，并且当涉及到生成的HTML和CSS时，它具有相当可预测的优点。</p><h1 id="8e35" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">遗言</h1><p id="b090" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">谢谢你一直跟着我到最后！</p><p id="a2bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这个小例子能让你对KMP有更多的了解，并愿意在这种情况下尝试。该项目的完整代码可在这个<a class="ae kv" href="https://github.com/fcuringa/Compose-Multiplatform-Demo" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中获得。请随意尝试，并寻求问题和反馈！</p></div></div>    
</body>
</html>