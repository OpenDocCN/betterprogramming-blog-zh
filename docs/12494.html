<html>
<head>
<title>How To Solve the Data Consistency Issues Between Redis And MySQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决Redis和MySQL之间的数据一致性问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-solve-the-data-consistency-issues-between-redis-and-mysql-702f9ffa2452?source=collection_archive---------2-----------------------#2022-06-09">https://betterprogramming.pub/how-to-solve-the-data-consistency-issues-between-redis-and-mysql-702f9ffa2452?source=collection_archive---------2-----------------------#2022-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4663" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Redis和MySQL数据一致性解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/71a7f4d74e867f795b4c57327bfe8e02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*awj8i66QPGBJn7MQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安妮·斯普拉特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b5f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redis具有高性能的数据读写功能，广泛应用于缓存场景。首先，它可以提高业务系统的性能，其次，它可以抵抗对数据库的高并发流量请求。</p><p id="c54e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在使用过程中，经常会遇到一些场景，需要解决Redis和Mysql数据库之间的数据一致性问题。</p><p id="d837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我就分享一下自己的解决方案。</p><h1 id="1393" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是数据库和缓存一致性？</h1><p id="baee" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">数据一致性是指:</p><ul class=""><li id="18dd" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">缓存中有数据，缓存的数据值等于数据库中的值</li><li id="becd" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">数据不在缓存中，数据库中的值等于最新值。</li></ul><p id="152a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推回缓存与数据库不一致:</p><ul class=""><li id="a072" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">缓存的数据值不等于数据库中的值。</li><li id="4717" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">缓存或数据库中有旧数据，导致线程读取旧数据。</li></ul><h2 id="f8f9" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">为什么会出现数据一致性问题？</h2><p id="4dd6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在使用Redis作为缓存时，我们需要在数据发生变化时进行双写，以保证缓存与数据库中的数据一致。</p><p id="bffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库和缓存毕竟是两个系统。如果要保证强一致性，就需要引入分布式一致性协议如<code class="fe ns nt nu nv b">2PC</code>或<code class="fe ns nt nu nv b">Paxos</code>，或者分布式锁等。</p><p id="fb35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个很难执行，肯定会影响执行。性能有影响。</p><p id="c52f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对数据的一致性要求这么高，真的有必要引入缓存吗？</p><h1 id="365b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">缓存使用策略</h1><p id="fc9f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">使用缓存时，通常有以下缓存使用策略来提高系统性能:</p><ul class=""><li id="1577" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><code class="fe ns nt nu nv b">Cache-Aside Pattern</code></li><li id="240a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe ns nt nu nv b">Read-Through Pattern</code></li><li id="3656" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe ns nt nu nv b">Write-Through Pattern</code></li><li id="7b1b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><code class="fe ns nt nu nv b">Write-Behind Pattern</code></li></ul><h2 id="cc98" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak"> 1。备用缓存</strong></h2><p id="b333" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">所谓缓存靠边是指读取缓存、读取数据库、更新缓存的操作都在应用系统中完成，是业务系统最常用的缓存策略。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/fe66101cbe3efdb5fabd77aaf0b04845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ItQauS713sgkd4Rkm-4_Dg.png"/></div></div></figure><p id="525f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读取数据的逻辑如下:</p><ul class=""><li id="e492" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">当应用程序需要从数据库中读取数据时，它首先检查缓存的数据是否被命中。</li><li id="9a84" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如果缓存未命中，查询数据库获取数据，同时将数据写入缓存，这样后续对相同数据的读取就会命中缓存，最后将数据返回给调用者。</li><li id="541d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如果缓存命中，直接返回。</li></ul><p id="b23e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时序图如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/ee6b513130e5c8fb010ab994ce2cce56.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*11YAAuou4hsdFOg8JQNRCw.png"/></div></figure><p id="961b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优势</strong></p><ul class=""><li id="7d5d" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">只有应用程序实际请求的数据才会包含在缓存中，这有助于保持缓存大小的成本效益。</li><li id="f902" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">它实现起来很简单，并且可以提高性能。</li></ul><p id="c42c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现的伪代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6b71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><p id="8967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于数据仅在缓存未命中后才加载到缓存中，因此第一次调用的数据请求的响应时间会增加一些开销，因为需要额外的缓存填充和数据库查询时间。</p><h2 id="c0c0" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak">更新数据</strong></h2><p id="5161" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在缓存备用模式下写入数据时，过程如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/99cd69446aff8dadf2b17b3a1c0a421c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qObL-8vdyDoPYW3vk1TcBg.png"/></div></div></figure><ul class=""><li id="f44c" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">将数据写入数据库。</li><li id="0dd5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">使缓存中的数据无效或更新缓存的数据。</li></ul><p id="d995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用缓存备用时，最常见的写入策略是将数据直接写入数据库，但是缓存可能与数据库不一致。</p><p id="0362" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该为缓存设置一个到期时间，这是确保最终一致性的解决方案。</p><p id="60b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果过期时间太短，应用程序将不断从数据库中查询数据。同样，如果过期时间太长，并且更新没有使缓存失效，则缓存的数据很可能是脏的。</p><p id="a377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的方法是删除缓存以使缓存的数据无效。</p><h1 id="d1fd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">为什么不更新缓存？</strong></h1><p id="a08d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><em class="oa">第一:性能问题。</em></p><p id="c96a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当缓存的更新成本较高，需要访问多个表进行联合计算时，建议直接删除缓存，而不是更新缓存数据，以保证一致性。</p><p id="f05a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oa">第二:安全问题。</em></p><p id="0caa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在高并发情况下，查询找到的数据可能是旧值。</p><h2 id="4bc5" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak"> 2。通读</strong></h2><p id="659f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当缓存未命中时，数据也从数据库加载，写入缓存，同时返回给应用程序系统。</p><p id="695f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe ns nt nu nv b">read-through</code>与<code class="fe ns nt nu nv b">cache-aside</code>非常相似，但是在<code class="fe ns nt nu nv b">cache-aside</code>中，应用程序负责从数据库中获取数据并填充缓存。</p><p id="ff38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，<code class="fe ns nt nu nv b">Read-Through</code>将从数据存储获取值的责任转移给了缓存提供者。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/48e67f3de549a57df7bb6fb3387a5fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*aBa-Ll-NXM8mcAO9G9gk8A.png"/></div></figure><p id="8908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">Read-Through</code>实行关注点分离原则。代码只与缓存交互，缓存组件管理自身与数据库之间的数据同步。</p><h2 id="2fb3" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak"> 3。直写</strong></h2><p id="f82d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与<code class="fe ns nt nu nv b">Read-Through</code>类似，当发生写请求时，<code class="fe ns nt nu nv b">Write-Through</code>将写责任转移给缓存系统，缓存抽象层完成缓存数据和数据库数据的更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/08653568f5f41e8b610264584fee5734.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*wtiqKQAQwPbuqNQ0QfeSpg.png"/></div></figure><p id="627c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">Write-Through</code>的主要好处是应用系统不需要考虑故障处理和重试逻辑，交给缓存抽象层来管理实现。</p><p id="b85f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接使用这种策略是没有意义的，因为这种策略需要先写到缓存，再写到数据库，给写操作带来额外的延迟。</p><p id="c701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe ns nt nu nv b">Write-Through</code>与<code class="fe ns nt nu nv b">Read-Through</code>配合使用时，可以充分发挥读通的优势，同时保证数据一致性，无需考虑如何使缓存设置失效。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/a3613535965bf3fdc7d13ca6fea2f869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeJT2RtzIKMrg_1hhb7L4A.png"/></div></div></figure><p id="7105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该策略颠倒了<code class="fe ns nt nu nv b">Cache-Aside</code>填充缓存的顺序。不是在缓存未命中后延迟加载到缓存，而是首先将数据写入缓存，然后缓存组件将数据写入数据库。</p><p id="e8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">优势</strong></p><ul class=""><li id="0269" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">缓存和数据库数据总是最新的。</li><li id="67f7" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">查询性能最佳，因为要查询的数据可能已经写入缓存。</li></ul><p id="a1c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">缺点</strong></p><ul class=""><li id="9feb" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">不常请求的数据也会写入缓存，导致缓存更大、更昂贵。</li></ul><h2 id="902b" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak"> 4。后写</strong></h2><p id="c303" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">乍一看，这个图形看起来和<code class="fe ns nt nu nv b">Write-Through</code>一样，其实不然，不同的是最后一个箭头上的箭头:它从实线变成了直线。</p><p id="f926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着缓存系统将异步更新数据库数据，应用程序系统只与缓存系统进行交互。</p><p id="5f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序不必等待数据库更新完成，从而提高了应用程序的性能，因为数据库更新是最慢的操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2de87a197fd3182caa8f20c0dbe1a3df.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*cRWvvRXKiTtVmwWdABiisg.png"/></div></figure><p id="c262" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种策略下，缓存和数据库的一致性不强，不建议用于高一致性的系统。</p><h1 id="6fa7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">后备缓存一致性问题分析</strong></h1><p id="9ec1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">缓存备用策略是业务场景中最常用的策略。在这种策略下，客户端首先从缓存中读取数据，如果命中则返回。将数据写入缓存，因此读取操作不会导致缓存和数据库之间的不一致。</p><p id="3a69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重点是写操作。数据库和缓存都需要修改，两者之间会有先后顺序，可能导致数据不再一致。对于写作，我们需要考虑两个问题:</p><ul class=""><li id="5d04" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">先更新缓存还是更新数据库？</li><li id="6deb" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">当数据发生变化时，选择修改缓存(更新)还是删除缓存(删除)？</li></ul><p id="768a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结合这两个问题，出现了四种情况:</p><ul class=""><li id="1b75" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">首先更新缓存，然后更新数据库。</li><li id="e58a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">首先更新数据库，然后更新缓存。</li><li id="fa24" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">首先删除缓存，然后更新数据库。</li><li id="aa52" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">首先更新数据库，然后删除缓存。</li></ul><h2 id="0dbe" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">1.首先更新缓存，然后更新数据库。</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/5dea085cb7bb933c0d209da2cf5e680b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MjIomYwUaHgK4k_pfDJbew.png"/></div></div></figure><p id="d6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果先更新缓存，数据库写入失败，则缓存是最新数据，数据库是旧数据，缓存是脏数据。</p><p id="5168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此之后，其他查询在立即进入时将获得这些数据，但这些数据并不存在于数据库中。</p><p id="1f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库中不存在的数据缓存并返回给客户端是没有意义的。</p><p id="2963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序直接通过。</p><h2 id="4aec" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">2.首先更新数据库，然后更新缓存。</h2><p id="3eb6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一切正常，如下所示:</p><ul class=""><li id="6048" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">先写数据库，成功。</li><li id="3cc6" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">然后更新缓存，成功。</li></ul><p id="fa00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果更新缓存失败。</p><p id="f60e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这时，我们来推断一下，如果这两个操作的原子性被打破:如果第一步成功，第二步失败，会发生什么？</p><p id="291f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">会导致数据库是最新数据，缓存是旧数据，造成一致性问题。</p><p id="1943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会画这幅画。和上图差不多，只是换一下Redis和MySQL的位置。</p><p id="303d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在高并发的场景下，如果多个线程同时写数据，然后再写到缓存，缓存的旧值和数据库的最新值肯定会出现不一致的情况。</p><h1 id="8445" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">有哪些一致的解决方案？</strong></h1><h2 id="addf" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak"> <em class="of"> 1。缓存延迟双删除</em>T5】</strong></h2><ul class=""><li id="2f17" class="ms mt it lb b lc mn lf mo li og lm oh lq oi lu mx my mz na bi translated">请先删除缓存。</li><li id="f975" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">写数据库。</li><li id="e958" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">休眠500毫秒，然后删除缓存。</li></ul><p id="c9ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，最多只会有500毫秒的脏数据读取时间。关键是如何确定睡眠时间？</p><p id="a1a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">延迟时间的目的是确保读请求结束，写请求可以删除由读请求引起的缓存脏数据。</p><p id="5537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们需要自己评估项目的数据读取业务逻辑的耗时，在读取时间的基础上增加几百毫秒作为延迟时间。</p><h2 id="594e" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak"> <em class="of"> 2。移除缓存重试机制</em> </strong></h2><p id="8df4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">缓存删除失败怎么办？例如，如果延迟双重删除的第二次删除失败，则意味着脏数据无法删除。</p><p id="3ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用重试机制来确保缓存删除成功。</p><p id="74be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果它重试三次并失败三次，它会将日志记录到数据库中，并发送一个需要手动干预的警告。</p><p id="b9a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在高并发场景下，最好使用异步方法进行重试，比如向MQ中间件发送消息，实现异步解耦。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/af116d3130f04ede1a480e2a7dc2eb05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ntzTYp1NmX9H637gmU1DqA.png"/></div></div></figure><p id="8f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤(5)如果删除失败，且未达到最大重试次数，则该消息将重新排队，直到删除成功，否则将记录在数据库中，以便人工干预。</p><p id="6ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方案的缺点是造成对业务代码的侵入，于是有了下一种方案，启动一个专门订阅数据库bin-log的服务，读取要删除的数据，执行缓存删除操作。</p><h2 id="154f" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><strong class="ak"> <em class="of"> 3。异步删除</em>读取bin-log</strong></h2><ul class=""><li id="add4" class="ms mt it lb b lc mn lf mo li og lm oh lq oi lu mx my mz na bi translated">更新数据库。</li><li id="7684" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">数据库将在bin-log日志中记录操作信息。</li><li id="8c77" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">使用canal订阅bin-log日志以获取目标数据和密钥。</li><li id="e445" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">缓存删除系统获取通道数据，解析目标键，并尝试删除缓存。</li><li id="7dcb" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">如果删除失败，将消息发送到消息队列。</li><li id="996a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">缓存删除系统再次从消息队列中获取数据，并再次执行删除操作。</li></ul><h1 id="f4c1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">总结</strong></h1><p id="ec4c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">缓存策略的最佳实践是缓存备用模式。它们分为读取缓存最佳实践和写入缓存最佳实践。</p><p id="3779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">读缓存最佳实践:首先读取缓存，如果命中则返回。如果数据库未命中，则查询数据库，然后写入缓存。</p><p id="5d43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">写缓存最佳实践:</p><ul class=""><li id="d36a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">先写数据库，再操作缓存。</li><li id="9b87" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">直接删除缓存，而不是修改它。</li></ul><p id="8842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为当缓存的更新成本非常高，需要访问多个表进行联合计算时，建议直接删除缓存，而不是更新。</p><p id="ed09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，删除缓存的操作很简单，副作用只是增加了缓存未命中。建议您使用此策略。</p><p id="54b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上述最佳实践下，为了尽可能保证缓存和数据库的一致性，我们可以使用延迟双重删除。</p><p id="c9e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止删除失败，我们使用异步重试机制来确保正确删除。通过异步机制，我们可以向MQ消息中间件发送删除消息，或者使用一个通道来订阅MySQL bin-log日志，以监控删除相应缓存的写请求。</p><p id="de21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如果我必须保证绝对一致性，首先给出结论:</p><p id="2ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有办法做到绝对的一致，这是上限理论决定的。缓存系统的适用场景是非强一致性的场景，所以属于CAP中的AP。</p><p id="890c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们必须妥协，我们可以达到基础理论中提到的最终一致性。</p><p id="9263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，一旦在方案中使用了缓存，往往意味着我们放弃了数据的强一致性，但也意味着我们的系统可以在性能上得到一定的提升。</p><p id="a765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所谓权衡，也正是如此。</p></div><div class="ab cl ok ol hx om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="im in io ip iq"><p id="86dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oa">感谢您阅读本文。</em></p><p id="2173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="oa">敬请期待更多。</em></p></div></div>    
</body>
</html>