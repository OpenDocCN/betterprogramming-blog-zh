<html>
<head>
<title>Recursion… Recursion… Recursion… Made Simple</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归…递归…递归…变得简单</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/recursion-recursion-recursion-made-simple-6b10e641e680?source=collection_archive---------9-----------------------#2019-10-20">https://betterprogramming.pub/recursion-recursion-recursion-made-simple-6b10e641e680?source=collection_archive---------9-----------------------#2019-10-20</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="6697" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">当一个函数调用自己时会发生什么？</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ba58356394824166dbee336e330fc5d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_gkhHb7cQeWLNoylIUrqA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在<a class="ae kz" href="https://unsplash.com/s/photos/fibonacci?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kz" href="https://unsplash.com/@iramint?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ira Mint </a>拍摄的照片</p></figure><p id="4b10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在自身内部调用同一个函数是怎么回事，被调用函数开始时的返回是如何工作的？那不就是在函数之外返回吗？我真的花了一分钟的时间来完全理解它是如何工作的，但一旦我做到了，一切都变得有意义了。</p><p id="1744" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这篇文章的结尾，我们将会讲述递归是如何工作的，看了一些递归的例子，也看了一个流行的使用递归的编程算法。所以让我们开始吧。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="5e55" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">什么是递归？</h1><p id="42bc" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">首先，让我们检查一下递归的更好的定义:递归是一种迭代操作的技术，通过让一个函数重复调用它自己，直到它得到一个结果。</p><p id="1e0b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">好吧，这个解释其实还不错。比给出的大多数定义都简单。但是让我们更容易理解:一个调用自身的函数。</p><p id="c409" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">递归是指函数在同一个函数中调用自己。在我们看一个实际的例子之前，让我们先看看是什么构建了一个递归函数。递归函数主要由三部分组成。</p><ul class=""><li id="aae5" class="na nb iu lc b ld le lg lh lj nc ln nd lr ne lv nf ng nh ni bi translated"><strong class="lc iv">终止条件</strong>——这有点像你函数中内置的短路或安全检查。这是一个需要通过的条件，以确保您的函数不会中断。</li><li id="63cb" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated">基本情况 —这基本上是你想要的最终目标。当这个条件通过时，返回最终结果，函数结束。请注意，有时您可以将终止条件和基本条件结合起来。</li><li id="7308" class="na nb iu lc b ld nj lg nk lj nl ln nm lr nn lv nf ng nh ni bi translated"><strong class="lc iv">递归</strong> —这是函数中不断调用自身的部分。</li></ul></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7718" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">例子</h1><p id="1568" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">现在来看一个例子。当你看这个例子的时候，看看你是否能识别这个函数的各个部分。第一个函数非常简单。它只是从一个给定的数字开始倒数，直到它到达零，然后记录到控制台。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/f52eda3e0df1cd0fa00913afae8b2d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6U-Kw12d5ZqWEJO0GHjd7Q.jpeg"/></div></div></figure><p id="fd50" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你算出函数的每一部分了吗？</p><p id="3967" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们来看终止条件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj np"><img src="../Images/c8a625008350a460e7f9a60e7fbb7500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*6BrhU58PanRDP7zitjvO6w.jpeg"/></div></figure><p id="4a82" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这种情况下，我们检查以确保给定的参数是一个数字并且不小于零。如果这个条件通过，那么我们把函数向下移动到我们认为的基本情况。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/078bd26992d03ac083e925afc9915082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rpeQsDaxkHllL3hM71d7Q.jpeg"/></div></div></figure><p id="862a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果这个条件没有通过，那么我们知道这个函数还没有完成。我们转到函数的递归部分，再次调用函数。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/ac262b055775de2c13c48be466fde03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcHVhaFUUu1UbVUxCkCDnA.jpeg"/></div></div></figure><p id="f609" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的函数一直这样做，直到它到达它的基本情况，然后从函数中返回。</p><p id="4c5f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看不同输入的一些结果。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/ef3b77a7e53866f9b3eeff060fc61bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRiS3ogpSPxIaVIUu12SSg.jpeg"/></div></div></figure><p id="7bc6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">第一次用字符串调用<code class="fe nr ns nt nu b">recursion()</code>时，<code class="fe nr ns nt nu b">string</code>没有通过终止条件，所以它将<code class="fe nr ns nt nu b">input is either not a number or smaller than zero</code>记录到控制台。它对<code class="fe nr ns nt nu b">-1</code>记录相同的内容，因为它小于零。最后，我们使用输入<code class="fe nr ns nt nu b">4</code>。这一次它通过了conditional，我们看到记录的倒计时和记录到控制台的<code class="fe nr ns nt nu b">reached 0</code>的最终结果。</p><p id="af41" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">前两个例子非常简单。不过，我们会更多地讨论第三个例子。函数内部到底发生了什么？首先，我们将看一看调用的物理表示，然后讨论它。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/f5053c7515cb1b21590d297e254e46f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUwkM_rA1XhXa9TOGL9XUw.jpeg"/></div></div></figure><p id="afbe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本例中使用<code class="fe nr ns nt nu b">4</code>每次计数减少时调用<code class="fe nr ns nt nu b">recursion()</code>。当计数达到<code class="fe nr ns nt nu b">0</code>时，它将<code class="fe nr ns nt nu b">reached 0</code>记录到控制台。</p><p id="697d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你和我一样，那么<code class="fe nr ns nt nu b">recursion()</code>前面的<code class="fe nr ns nt nu b">return</code>会让你有点困惑。就我个人而言，我很难理解<code class="fe nr ns nt nu b">return</code>在这种情况下是如何工作的。我一直在想，如果在函数之外返回，那么用<code class="fe nr ns nt nu b">return</code>对函数的不断调用是如何工作的。但是<code class="fe nr ns nt nu b">return</code>实际上在递归本身中起着至关重要的作用。</p><p id="28f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们不把<code class="fe nr ns nt nu b">return</code>放在<code class="fe nr ns nt nu b">recursion()</code>前面，我们实际上永远不会记录或返回任何东西。添加<code class="fe nr ns nt nu b">return</code>导致众所周知的冒泡返回期望的结果。所以不要让这困扰你。</p><p id="cab7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看另一个例子，但这次比从一个给定的数字开始倒数要复杂一些。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/c30ee20c5fc867be995556b40b661ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WZdMjtjF7ND2MUs_L7VGvA.jpeg"/></div></div></figure><p id="caa3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">知道这个函数是做什么的吗？你想明白了吗？它——等等——反转一个字符串。如果你自己想出来的话，做得很好(虽然它在图像底部显示为输出)。</p><p id="a2f5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我在函数中包含了一个<code class="fe nr ns nt nu b">console.log</code>来显示函数重复时的<code class="fe nr ns nt nu b">str</code>参数值。让我们看看函数运行时的输出。如您所见，每次调用该函数时，它都会从初始字符串中删除一个字母。它一直这样做，直到我们得到一个空字符串。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/97d9d19e80b21122c19ee24928aaacec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQ2s9kyiRTS5hg3BU81KiQ.jpeg"/></div></div></figure><p id="1058" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦函数到达空字符串，终止/基本情况条件通过并返回<code class="fe nr ns nt nu b">str</code>。如前所述，一旦函数接收到空字符串，它就会冒泡返回到初始函数调用，并返回字符串结果。</p><p id="7a0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">终于到了看一个使用递归的流行编程算法的时候了。知道那会是什么吗？我给你一个提示。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nv nw l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://giphy.com/search/fibonacci" rel="noopener ugc nofollow" target="_blank">https://giphy.com/search/fibonacci</a></p></figure><p id="be6a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">是想通了，还是比以前更迷茫了？最后一个提示:0 1 1 2 3 5 8 13 21 34 55 89 144。如果你说<em class="nx">斐波那契</em>，那么你是正确的。如果你不确定，斐波纳契是一个数列。斐波纳契数列是一系列的数字，下一个数字是通过将前面的两个数字相加得到的。</p><p id="89ba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">斐波那契算法是一种非常著名的算法。让我们快速地看一个递归函数来寻找序列。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nq"><img src="../Images/963c3e2b257dad14d9de4eff8a68cf7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1dYuOr_ZjAfsT82n6X6Z6A.jpeg"/></div></div></figure><p id="263d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们不打算深入研究斐波那契数列和算法，尤其是如果这里有人是递归的新手。如果你有兴趣了解更多关于斐波那契的知识，在谷歌上快速搜索会给你带来很多结果。</p><p id="7d75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个函数不是实现它的最省时的方法。我们可以用一个实现记忆化的函数来改进大O符号。这里的主要收获是看看我们如何在函数中不断调用斐波那契本身。每次这样做，我们都要从初始值中减去。最终我们会达到我们的基本情况，这将是一个小于2的数字。一旦我们达到这个数字，函数调用栈就会冒泡并返回我们想要的值。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3543" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="2859" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">这就是递归的全部内容。我们看了一些例子，包括一个使用递归算法的真实例子。我希望这能对递归及其工作原理有更多的了解。尝试一下。试着用递归代替迭代，看看自己感觉如何。</p></div></div>    
</body>
</html>