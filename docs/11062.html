<html>
<head>
<title>What is Protobuf and Why You Should Use It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Protobuf，为什么要使用它</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-protobuf-and-why-you-should-use-it-14d52646f2a7?source=collection_archive---------3-----------------------#2022-02-15">https://betterprogramming.pub/what-is-protobuf-and-why-you-should-use-it-14d52646f2a7?source=collection_archive---------3-----------------------#2022-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa5e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JSON vs协议缓冲区。哪个更好？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45116eb96d11cf04a56529e4d5fcc96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nfg0GGZPEEao5mPwLhjjxA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卡罗琳娜·格拉博斯卡在<a class="ae kv" href="https://www.pexels.com/photo/notebook-mail-business-paper-5706001/" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><p id="7868" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在任何web服务中编写过大量代码，那么您很可能听说过术语JSON。</p><p id="d675" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种非常方便的数据格式，几乎随处可见。</p><p id="7b04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，协议缓冲区这个术语近年来越来越受欢迎。许多人声称它在功能和灵活性方面超过了JSON。</p><p id="f2f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我们许多人来说，协议缓冲区听起来令人生畏，也许一开始会令人困惑，但是深入研究之后，你会发现它非常方便。</p><p id="2f1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天就来说说协议缓冲吧！</p><h1 id="1e01" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是协议缓冲区？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/c98535f88424eb4257021dbc9e70b2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krvVn1hMJQvITuE1BQs06A.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://www.pexels.com/@olly" rel="noopener ugc nofollow" target="_blank">安德里亚·皮亚卡迪奥</a>在<a class="ae kv" href="https://www.pexels.com/photo/pensive-ethnic-man-listening-to-answer-in-paper-cup-phone-3760607/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="b48d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它从一个简单的问题开始。</p><p id="d7b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，在Python程序中有一个对象，如何将它发送给另一台计算机上运行的JavaScript应用程序？</p><p id="65c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">各种计算机系统中的不同语言可以不同地实现一个对象。这类似于不同的母语人士试图沟通。</p><p id="5045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们需要一种标准的、平台中立的数据格式。简而言之，共同语言。</p><p id="1d27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个应用程序同意相同的格式和编码类型。发送方以预定的格式序列化数据，而接收方相应地反序列化和解析数据。</p><p id="8aca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON和协议缓冲就是这样！</p><p id="fb65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一种标准的、平台无关的数据格式，简化了应用程序之间的数据传输。</p><h1 id="e2ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么是协议缓冲区？</h1><p id="3274" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果JSON做得这么好，为什么还要协议缓冲？</p><p id="2d89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON虽然方便，但也有几个缺点，</p><ol class=""><li id="db5d" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">这是一种无模式的数据格式</li><li id="0068" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">这是一种基于文本的编码数据格式，会产生更大的数据量</li><li id="c6fa" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">它没有在模式级别进行任何验证</li></ol><p id="43a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">无模式数据格式</strong>。数据可以以任何形式发送，使用任何键-值对。由接收者来验证数据。简而言之，对数据的发送方式没有限制。</p><p id="e061" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">基于文本的编码数据格式</strong>。数据在发送出去之前被转换成文本。例如，尽管本质上是相似的，但下面的数据在编码成字符串时消耗的字节数是不同的。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="364a" class="nj lt iq nf b gy nk nl l nm nn"><br/>json1 = {<br/>   "my_age_this_year": 4<br/>}<br/><br/>json2 = {<br/>   "age": 4<br/>}</span><span id="0ead" class="nj lt iq nf b gy no nl l nm nn">//json1 ~= 23 bytes<br/>//json2 ~= 10 bytes</span></pre><p id="2bf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">缺乏验证</strong>。由于JSON是无模式的，所以数据验证只能在代码级别完成。</p><p id="4ebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么协议缓冲区来救援！</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="64c6" class="ls lt iq bd lu lv nw lx ly lz nx mb mc jw ny jx me jz nz ka mg kc oa kd mi mj bi translated">关键特征</h1><p id="3035" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">协议缓冲区具有各种特性。在这篇文章中，我将重点介绍在您的日常应用中很重要的四个基本要素。</p><ul class=""><li id="a0ab" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ob mw mx my bi translated">原型文件</li><li id="b0c3" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">原始编译程序</li><li id="a452" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">Protobuf对象的序列化</li><li id="6fdf" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">二进制编码</li></ul><h2 id="f824" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">原型文件</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/9970c22aece795d4be04aa572601d9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lIZpO4Kqt3vGcWEvHTeOwQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@pavel-danilyuk" rel="noopener ugc nofollow" target="_blank"> Pavel Danilyuk </a>拍摄于<a class="ae kv" href="https://www.pexels.com/photo/close-up-photo-of-people-shaking-hands-8112172/" rel="noopener ugc nofollow" target="_blank"> Pexels </a></p></figure><p id="7efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了促进数据传输，应用程序需要同意标准的模式和格式，这就是<code class="fe oo op oq nf b">.proto</code>文件。</p><p id="c147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">被称为<code class="fe oo op oq nf b">message</code>的数据/对象被定义并存储在<code class="fe oo op oq nf b">.proto</code>文件中。然后文件被放在客户端和服务器端。</p><p id="a6a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，为了在客户机和服务器之间发送一个用户对象，我们以如下格式在一个<code class="fe oo op oq nf b">.proto</code>文件中定义了一个<code class="fe oo op oq nf b">User message</code></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c148" class="nj lt iq nf b gy nk nl l nm nn">syntax = "proto3";<br/><br/>package user;<br/><br/>message User {<br/>	string name = 1;<br/>	int32 age = 2;<br/>	int32 height = 3;<br/>	repeated Pet pets = 4;<br/>}<br/><br/>message Pet {<br/>	string name = 1;<br/>	string sound = 2;<br/>}<!-- --> </span></pre><p id="0f0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq nf b">.proto</code>文件独立于您使用的平台和语言。</p><p id="5a78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq nf b">User</code>消息指定了四个键值对。每个都包含</p><ul class=""><li id="e087" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ob mw mx my bi translated">字段类型- <code class="fe oo op oq nf b">string</code> / <code class="fe oo op oq nf b">int32</code> /...</li><li id="d140" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">键名- <code class="fe oo op oq nf b">name</code> / <code class="fe oo op oq nf b">age</code> /...</li><li id="d13b" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">字段编号- <code class="fe oo op oq nf b">1</code> / <code class="fe oo op oq nf b">2</code> /...</li></ul><p id="d4e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字段类型定义值类型，而术语<code class="fe oo op oq nf b">repeated</code>指定字段是相似类型的数组。</p><p id="5bcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字段编号作为二进制编码中的唯一标签,这也是Protobuf较小的原因，我们将在后面详细讨论。</p><p id="75a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户机和服务器都利用预定的<code class="fe oo op oq nf b">message</code>类型来序列化和去序列化数据，给ProtoBuf一个明确的模式。</p><h2 id="6653" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">协议</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/ad521a6c9aee63b6d9d60838540f6a11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*47XoXJ9J9trbTqMDqCVdgg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@tima-miroshnichenko" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>在<a class="ae kv" href="https://www.pexels.com/photo/man-person-people-industry-5846247/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="2955" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您创建第一个<code class="fe oo op oq nf b">.proto</code>文件时，随之而来的问题是，如何在您的应用程序中应用它？</p><p id="dfea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是协议编译器(又名Protocol)发挥作用的地方！</p><p id="574f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户在一个<code class="fe oo op oq nf b">.proto</code>文件中定义消息，协议编译器将它编译成你正在使用的任何语言的类</p><p id="550f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过下面的命令，协议编译器在<code class="fe oo op oq nf b">$DST_DIR</code>中生成一个<code class="fe oo op oq nf b">user_pb2.py</code>文件。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="7c12" class="nj lt iq nf b gy nk nl l nm nn">protoc -I=$SRC_DIR --python_out=$DST_DIR $SRC_DIR/user.proto</span></pre><ul class=""><li id="132a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ob mw mx my bi translated">$SRC_DIR:源代码所在的目录</li><li id="ad56" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">$DST_DIR:生成的<code class="fe oo op oq nf b">_pb2.py</code>文件所在的目录</li><li id="3240" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">$SRC_DIR:原始<code class="fe oo op oq nf b">user.proto</code>文件所在的目录</li><li id="a1a8" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">—python_out:用于指定所用语言的选项</li></ul><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="d56a" class="nj lt iq nf b gy nk nl l nm nn">....<br/>_USER = _descriptor.Descriptor(<br/>name='User',<br/>full_name='user.User',<br/>filename=None,<br/>file=DESCRIPTOR,<br/>containing_type=None,<br/>create_key=_descriptor._internal_create_key,<br/>....</span></pre><p id="da9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq nf b">user_pb2.py</code>文件的内容几乎不可读，但这无关紧要。您所需要关心的就是在您的应用程序中导入和应用这些类。</p><h2 id="134d" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">Protobuf对象的序列化</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/e466f399b4931a4b6508127295cf459f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G7ChxFm2soqViuwSUWeM0g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@cottonbro" rel="noopener ugc nofollow" target="_blank"> cottonbro </a>在<a class="ae kv" href="https://www.pexels.com/photo/photo-of-person-taking-down-notes-7319070/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="5aaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试使用我们的<code class="fe oo op oq nf b">user_pb2.py</code>文件中生成的类。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4e22" class="nj lt iq nf b gy nk nl l nm nn">from pb.proto import user_pb2</span><span id="8317" class="nj lt iq nf b gy no nl l nm nn">user = user_pb2.User()<br/>user.name = "Jason"<br/>user.age = 20<br/>user.height = 180</span><span id="d066" class="nj lt iq nf b gy no nl l nm nn">pet1 = user.pets.add()<br/>pet1.name = "Dog"<br/>pet1.sound = "Bark"</span><span id="ba50" class="nj lt iq nf b gy no nl l nm nn"># Attribute error<br/>user.friend = "Peter"</span><span id="3ebf" class="nj lt iq nf b gy no nl l nm nn"># Type error<br/>user.age = "twenty"</span><span id="3ad9" class="nj lt iq nf b gy no nl l nm nn">protoString = user.SerializeToString()</span><span id="fccd" class="nj lt iq nf b gy no nl l nm nn">parsedUserFromStr = user_pb2.User()<br/>parsedUserFromStr.ParseFromString(protoString)</span><span id="2e0e" class="nj lt iq nf b gy no nl l nm nn">print(protoString)<br/># b'\n\x05Jason\x10\x14\x18\xb4\x01"\x0b\n\x03Dog\x12\x04Bark'</span><span id="0774" class="nj lt iq nf b gy no nl l nm nn">print(parsedUserFromStr)<br/># name: "Jason"<br/># age: 20<br/># height: 180<br/># pets {<br/>#   name: "Dog"<br/>#   sound: "Bark"<br/># }</span></pre><p id="c4af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，数据赋值<strong class="ky ir">不仅仅是将任意字段</strong>添加到典型的Python对象中。</p><p id="ef7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你分配了一个没有在<code class="fe oo op oq nf b">.proto</code>文件中声明的字段或者一个与定义的值类型不兼容的值，将会产生一个错误。</p><p id="87eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过生成的类的内置方法，您可以将数据序列化为一个字符串，并将其发送到指定的应用程序。</p><p id="e69f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得强调的一点是序列化的字符串是二进制的<strong class="ky ir">，而不是文本</strong>。<code class="fe oo op oq nf b">str</code>只是作为一个方便的容器来传输数据。</p><h2 id="f3dd" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">二进制编码</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/17c495fdb718750a6008df9172c17c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlnHWYVnU8qVMhxzKLCTQA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Miguel A. Padrinan 在<a class="ae kv" href="https://www.pexels.com/photo/bike-chain-forming-1-and-0-1061133/" rel="noopener ugc nofollow" target="_blank"> Pexels </a>拍摄的照片</p></figure><p id="644d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么协议缓冲区比JSON对象更紧凑的原因。</p><p id="8ded" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看一个典型的JSON对象。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="6c32" class="nj lt iq nf b gy nk nl l nm nn">{<br/>	"name": "Jason",<br/>	"money": 300<br/>}</span><span id="75a8" class="nj lt iq nf b gy no nl l nm nn"># jsonString = '{"name": "Jason", "money": 300}'</span></pre><p id="6a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发送方必须向客户端提供密钥和值。</p><p id="6b9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JSON使用基于文本的编码，这意味着一个对象在发送出去之前被转换成一个文本字符串，数据大小随着键中字符数的增加而增加。</p><p id="3734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，协议缓冲区的工作方式不同。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="787c" class="nj lt iq nf b gy nk nl l nm nn">message Person {<br/>	string name = 1;<br/>	int money = 2;<br/>}</span></pre><p id="6645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">它用一个唯一的标签号</strong>代替了钥匙。上面显示的类似对象将在协议缓冲区中编码如下。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="959b" class="nj lt iq nf b gy nk nl l nm nn">125Jason20300</span></pre><p id="327d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oo op oq nf b">1</code>代表字段号，<code class="fe oo op oq nf b">2</code>是<a class="ae kv" href="https://developers.google.com/protocol-buffers/docs/encoding#structure" rel="noopener ugc nofollow" target="_blank">线类型</a>(值类型)<code class="fe oo op oq nf b">5</code>是指字符串的长度。注意，只有线类型<code class="fe oo op oq nf b">2</code>需要输入数据长度。</p><p id="c07f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，字符串中的第二个<code class="fe oo op oq nf b">2</code>是指字段编号，<code class="fe oo op oq nf b">0</code>是导线类型，<code class="fe oo op oq nf b">300</code>是指数据。</p><p id="0fdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过用一个唯一的字段号替换关键字，减少了总的数据量。</p><p id="1750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着<code class="fe oo op oq nf b">.proto</code>文件中字段的顺序并不重要。接收方根据字段编号解码数据。例如，接收方将<code class="fe oo op oq nf b">Jason</code>分配给字段编号<code class="fe oo op oq nf b">1</code>，而不考虑<code class="fe oo op oq nf b">.proto</code>文件中的字段顺序。</p><p id="2bcb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，更改字段编号是灾难性的。如果发送方将<code class="fe oo op oq nf b">name</code>的字段号改为<code class="fe oo op oq nf b">2</code>，数据接收方将尝试将<code class="fe oo op oq nf b">Jason</code>赋值给变量<code class="fe oo op oq nf b">money</code>而不是<code class="fe oo op oq nf b">name</code>。</p><p id="1d64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，由于JSON使用基于文本的编码，一个整数<code class="fe oo op oq nf b">300</code>携带三个字符，因此消耗三个字节。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8ef9" class="nj lt iq nf b gy nk nl l nm nn">00000011 00000000 00000000</span></pre><p id="6fcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，协议缓冲区使用二进制编码，将<code class="fe oo op oq nf b">300</code>编码到一个<code class="fe oo op oq nf b">varint</code>中，而不是消耗2个字节。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="1aac" class="nj lt iq nf b gy nk nl l nm nn">00000001 00101100</span></pre><p id="badf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这是编码字节串的简化版本，与实际版本没有任何相似之处。但是希望这能给你一个为什么协议缓冲区比JSON字符串小的要点。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="b7d6" class="ls lt iq bd lu lv nw lx ly lz nx mb mc jw ny jx me jz nz ka mg kc oa kd mi mj bi translated">优势</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/09b9b6fa656c06c304f638716bae255c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SjZm9YZIgIRINgTK4c50rw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://www.pexels.com/@cottonbro" rel="noopener ugc nofollow" target="_blank">在</a><a class="ae kv" href="https://www.pexels.com/photo/woman-in-white-and-black-striped-long-sleeve-shirt-and-red-knit-cap-4715329/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="4333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在结束本文之前，让我们强调一下协议缓冲区的一些主要优点。</p><ul class=""><li id="ebc0" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ob mw mx my bi translated">尺寸较小</li><li id="629a" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">向后兼容性</li><li id="93c9" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">(计划或理论的)纲要</li><li id="99ff" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">确认</li></ul><h2 id="28a6" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">尺寸较小</h2><p id="a61d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如前所述，与JSON中基于文本的编码相比，Protocol Buffer使用二进制编码，并且它用一个唯一的字段号来替换密钥。</p><p id="d2bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，与JSON相比，它消耗的字节数要少得多。</p><h2 id="aad2" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">向后兼容性</h2><p id="b606" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">通过利用唯一的字段号，协议缓冲区提供了极好的向后兼容性。</p><p id="0717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用户可以在发送方/接收方方便地添加或删除字段<strong class="ky ir"> </strong>，而不用担心兼容性问题。当接收者解码数据时，它将</p><ul class=""><li id="b009" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ob mw mx my bi translated">如果接收方没有发送的字段编号，则忽略</li><li id="849e" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated">如果所需的字段编号在传输的数据中不可用，则分配默认值</li></ul><h2 id="acd9" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">(计划或理论的)纲要</h2><p id="9f9d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">协议缓冲区为发送方和接收方提供了明确的模式。它允许开发人员准确地知道从消息中可以期待什么。</p><h2 id="83c9" class="nj lt iq bd lu oc od dn ly oe of dp mc lf og oh me lj oi oj mg ln ok ol mi om bi translated">数据有效性</h2><p id="2e7d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">协议缓冲区在编码和解码过程中验证给定数据的值类型，确保数据传输过程中的数据完整性。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="1356" class="ls lt iq bd lu lv nw lx ly lz nx mb mc jw ny jx me jz nz ka mg kc oa kd mi mj bi translated">结论</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/c8362b2386a6a690ef907e20b23bfc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_XKG3puEvSZaJRUyuWpjIw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.pexels.com/@ketut-subiyanto" rel="noopener ugc nofollow" target="_blank">赖爷苏比扬托</a>在<a class="ae kv" href="https://www.pexels.com/photo/crop-coffee-house-worker-serving-cup-of-freshly-brewed-espresso-4353573/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="9e14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于协议缓冲区就是这样！</p><p id="4e5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管本文省略了大量的细节和技术问题，但我希望我已经向您简要介绍了什么是协议缓冲区以及为什么每个人都在使用它！</p><p id="1fa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这样，我们今天到此为止。下次见，再见！</p><h1 id="43cc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><ul class=""><li id="eaba" class="mq mr iq ky b kz ml lc mm lf ow lj ox ln oy lr ob mw mx my bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/understanding-protocol-buffers-43c5bced0d47">Arun Mathew Kurian的《了解协议缓冲区》</a></li><li id="fb2d" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated"><a class="ae kv" href="https://medium.com/@yashschandra/an-inner-view-to-protobuf-encoding-e668f37847d5" rel="noopener">Yash Suresh Chandra的Protobuf编码内部视图</a></li><li id="e6bc" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr ob mw mx my bi translated"><a class="ae kv" href="https://www.datascienceblog.net/post/programming/essential-protobuf-guide-python/" rel="noopener ugc nofollow" target="_blank">Matthias Doring的Python基本Protobuf指南</a></li></ul></div></div>    
</body>
</html>