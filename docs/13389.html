<html>
<head>
<title>OpenAPI to gRPC With Quarkus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Quarkus从OpenAPI到gRPC</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/openapi-to-grpc-with-quarkus-61d87e353cbe?source=collection_archive---------2-----------------------#2022-08-23">https://betterprogramming.pub/openapi-to-grpc-with-quarkus-61d87e353cbe?source=collection_archive---------2-----------------------#2022-08-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2bf0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将REST服务实现为gRPC</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b5f8689e03c9b1c189c4424deaa0f51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LUFqotBIru2c6dpf"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Emile Perron 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="984a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="5437" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST </a> (OpenAPI)和<a class="ae kv" href="https://grpc.io/" rel="noopener ugc nofollow" target="_blank"> gRPC </a>是两种最流行的API格式。REST是大多数公共API选择的风格，gRPC是需要高效网络的内部API的流行替代。</p><p id="5be1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">OpenAPI规范定义了一个描述REST APIs及其功能的标准。</p><p id="48b6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">默认情况下，gRPC使用<a class="ae kv" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>，这是Google用于序列化结构化数据的开源机制。协议缓冲区模式也是一个API规范。</p><p id="090f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><a class="ae kv" href="https://www.tmforum.org/" rel="noopener ugc nofollow" target="_blank"> TM论坛</a>是电信行业组织的全球性协会。TM论坛已经开发了一套覆盖电信领域的<a class="ae kv" href="https://projects.tmforum.org/wiki/display/API/Open+API+Table" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>规范。</p><h1 id="43a2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用例</h1><p id="b630" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这篇文章的诞生是因为我想熟悉gRPC并理解它的好处和限制。然而，由于<a class="ae kv" href="https://swagger.io/resources/articles/adopting-an-api-first-approach/#:~:text=An%20API%2Dfirst%20approach%20means,be%20consumed%20by%20client%20applications." rel="noopener ugc nofollow" target="_blank"> API优先的方法</a>，现在OpenAPIs被广泛使用，我觉得不应该凭空创造一个简单的API。</p><p id="c157" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">相反，如果我们用gRPC实现一个成熟的OpenAPI会怎么样？TM论坛API非常适合我们的目的，因为它们很复杂，但是与实现无关。</p><h1 id="efda" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="241d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一个GRPC服务的POC，仅使用一个OpenAPI规范作为输入，其他的都是从它生成的。</p><div class="mp mq gp gr mr ms"><a href="https://github.com/Gorosc/openapi-to-grpc-quarkus" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">GitHub-go rosc/open API-to-grpc-quar kus</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">其概念是从给定的OpenAPI创建一个GRPC API，并生成所有模型。</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div></div></a></div><p id="8c82" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">邮差:<a class="ae kv" href="https://www.postman.com/galactic-shadow-579657/workspace/openapi-to-grpc-quarkus-workspace" rel="noopener ugc nofollow" target="_blank">https://www . postman . com/galactic-shadow-579657/workspace/open API-to-grpc-quar kus-workspace</a></p><h1 id="7187" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">设计选择</h1><p id="4945" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我选择了<a class="ae kv" href="https://github.com/tmforum-apis/TMF720_DigitalIdentity" rel="noopener ugc nofollow" target="_blank"> TMF 720数字身份API </a>，它是TMF API表中的最新成员之一。它提供了管理数字身份(凭证、密码、生物特征等)的能力。).在此POC的范围内，业务逻辑并不那么重要。它是一个成熟的API，但不像老的TMF API那样过于臃肿，我们将把它作为一个CRUD API来实现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/b259a12d3d9e599baab71b396bbafde3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1rAce23cYSs8S2bKwTr4Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的目标是将服务实现为REST</p></figure><p id="eca9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于实施，技术选择有:</p><ol class=""><li id="6bdc" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj nh ni nj nk bi translated"><a class="ae kv" href="https://quarkus.io/" rel="noopener ugc nofollow" target="_blank"> Quarkus框架</a>:我们可以使用普通Java和gRPC中包含的默认服务器来实现服务。然而，我选择了框架，因为我们必须管理配置和数据库连接。我不喜欢手工实现这些区域。Quarkus对<a class="ae kv" href="https://quarkus.io/guides/grpc-getting-started" rel="noopener ugc nofollow" target="_blank"> gRPC </a>有一流的支持。</li><li id="df24" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated">MongoDB :这个API有一个复杂的模式。它单独的实体本身没有太大的意义。因此，我们希望将整个模型保存为一个文档，MongoDB是第一个想到的。</li><li id="ecac" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj nh ni nj nk bi translated"><a class="ae kv" href="https://openapi-generator.tech/docs/generators/protobuf-schema" rel="noopener ugc nofollow" target="_blank"> OpenAPI生成器</a>用于从OpenAPI生成Protobuf模式。</li></ol><blockquote class="nq nr ns"><p id="a2f2" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated">解决方案1:在评估了google的工具gnostic之后，我决定使用OpenAPI生成器。OpenAPI生成器a)以maven插件的形式出现，可以在我们的构建链中使用b)将消息和服务分解成不同的原型文件。因此，gRPC生成器将生成更多可访问的文件，以便在我们的IDE中工作。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/eb2c65b1f0e000912a643b747b4a983f.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*ccT2oBB2qreRMQCnNzyIkg.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">软件体系结构</p></figure><blockquote class="nq nr ns"><p id="da02" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated">由于时间不够，此POC尚未准备好投入生产。缺少验证和正确的错误处理。但是，遵循测试驱动的开发方法，所有的主要流程都被覆盖了。</p></blockquote><h1 id="1f39" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">履行</h1><h2 id="6b7e" class="ny kx iq bd ky nz oa dn lc ob oc dp lg lx od oe li mb of og lk mf oh oi lm oj bi translated">设置</h2><p id="beb7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们的maven设置将包括Quarkus以及gRPC和Mongo的必要依赖项:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">OpenAPI对gRPC应用程序的依赖性</p></figure><p id="d010" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">OpenAPI生成器作为一个插件发挥作用。这将是我们构建链中的第一个插件。这个配置的关键部分是输出文件夹<code class="fe om on oo op b"><em class="nt">/src/main/proto</em></code>,因为这是Quarkus期望找到原型模式的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">用于protobuf模式生成的OpenAPI生成器maven插件配置</p></figure><p id="39cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的初始文件结构将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/fa24c5d41c776eac68c0bf1b3c7295fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*2T7F6IkifWUQIGeNg2Xkkg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">生成前的初始文件结构</p></figure><h1 id="d8b8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">产生</h1><p id="a023" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">让我们继续调用“mvn编译”插件将按顺序执行，结果如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/7f5822d37832fc7db7188200460bed30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*bGYkxXYFsblh_dc6Mpx7eQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">模式和代码生成后的文件结构</p></figure><p id="c7f5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">OpenAPI生成器插件已经用为服务和模型生成的protobuf模式填充了我们的<em class="nt"> </em> <code class="fe om on oo op b"><em class="nt">/src/main/proto</em></code> <em class="nt"> </em>文件夹。我们将使用<code class="fe om on oo op b"><em class="nt">digital_identity_service.proto</em></code> <em class="nt"> </em>作为我们的用例。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">gRPC服务</p></figure><p id="4bdd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将实现gRPC服务的每个方法。Quarkus已经为我们可以使用的服务生成了一个接口，自动使其对<a class="ae kv" href="https://quarkus.io/guides/mutiny-primer" rel="noopener ugc nofollow" target="_blank">兵变</a>做出反应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">gRPC兵变服务接口</p></figure><blockquote class="nq nr ns"><p id="907e" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated">我们可以使用默认的gRPC Java实现</p><p id="7cff" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated">数字标识服务Grpc。DigitalIdentityServiceImplBase</p><p id="f932" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated">然而，由于我们使用Quarkus，它有意义的去反应。这样，此POC更适合用作参考实施。</p></blockquote><h1 id="06fe" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创建数字身份</h1><p id="7b62" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于我们的第一个实现来说，Create是最好的选择，它可以为我们的后续操作提供一些数据。</p><p id="30ed" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">TMF规范利用不同的模型进行创建、读取和更新。结果，代码生成产生了多个gRPC模型类，它们彼此不能直接映射。</p><ul class=""><li id="0cc6" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj os ni nj nk bi translated"><code class="fe om on oo op b">DigitalIdentity</code></li><li id="8f73" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated"><code class="fe om on oo op b">DigitalIdentityCreate</code></li><li id="8387" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated"><code class="fe om on oo op b">DigitalIdentityUpdate</code></li></ul><blockquote class="nq nr ns"><p id="bd4a" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated">解决方案2:我们将使用“<a class="ae kv" href="https://developers.google.com/protocol-buffers/docs/reference/java/com/google/protobuf/util/JsonFormat" rel="noopener ugc nofollow" target="_blank">com . Google . proto buf . util . JSON format</a>”将gRPC模型序列化为JSON。这些模型的区别只是一些字段(id、状态、创建日期等。).因此，将JSON反序列化到不同的模型是一种有效的映射方法。这不是一个开销，因为我们还需要Mongo的JSON序列化(见下文)。</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">gRPC创建数字身份</p></figure><blockquote class="nq nr ns"><p id="b233" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/HATEOAS" rel="noopener ugc nofollow" target="_blank">超媒体</a>未在protobuf或gRPC中定义。</p><p id="558e" class="lo lp nt lq b lr mk jr lt lu ml ju lw nu mm lz ma nv mn md me nw mo mh mi mj ij bi translated">我仍然觉得用获取特定数字身份所需的方法和输入来填充href属性很有趣</p></blockquote><p id="ff4a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们不想让任何gRPC逻辑溢出到我们的DB域和Mongo连接器中。由于我们没有持久化的模型，我们的Mongo服务将接受JSON格式的字符串作为输入，返回作为输出。当然，这有一个不希望的效果，即在我们的数据库中有未验证和未类型化的输入。我们将接受此POC范围内的风险。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">mongo创造了数字身份</p></figure><h1 id="dd99" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">列出数字身份</h1><p id="3c45" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">类似地，我们从Mongo中检索结果，并使用JSONFormat将它们反序列化为gRPC模型。我们还将从数据库接收到的Multi映射到Uni。我们将所有结果收集到一个列表中，并将它们添加到<code class="fe om on oo op b">Uni</code>响应中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">gRPC列表数字身份</p></figure><p id="c805" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Mongo中，我们使用本地的ObjectId作为id。但是，由于这不是我们规范的一部分(因此，JSON反序列化将会失败)，我们用<code class="fe om on oo op b">id</code>代替它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Mongo列表数字身份</p></figure><h1 id="01ed" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">检索数字身份</h1><p id="76c5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">检索单个数字身份和映射与<code class="fe om on oo op b">List</code>相同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Mongo检索数字身份</p></figure><p id="2634" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当我们使用<code class="fe om on oo op b">_i</code> d进行搜索时，我们不期望有多于一个的结果。gRPC服务不需要知道Mongo在这种情况下仍然返回一个Multi的细节。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">mongo检索数字身份</p></figure><h1 id="1bb1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">删除数字身份</h1><p id="a573" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">gRPC中的Empty是我们需要创建并发回的对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">gRPC删除数字身份</p></figure><p id="d012" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">mongo删除操作返回一个void。我挑战自己让它返回文档或一个long(点击次数),但是用一个简单的void解决了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">mongo删除数字身份</p></figure><h1 id="c1bb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">修补数字身份</h1><p id="4d33" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Patch非常像Create，但是我们从请求中提取两个参数，mongo服务返回文档。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">gRPC补丁数字身份</p></figure><p id="4d2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了使更新成为操作指定的合并补丁，我们需要使用<code class="fe om on oo op b"><a class="ae kv" href="https://www.mongodb.com/docs/manual/reference/operator/update/set/" rel="noopener ugc nofollow" target="_blank">$set</a></code> <a class="ae kv" href="https://www.mongodb.com/docs/manual/reference/operator/update/set/" rel="noopener ugc nofollow" target="_blank">操作符。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">mongo更新数字身份</p></figure><h1 id="a08d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">包裹</h1><p id="eae0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们创建了服务，并且满足了我们的基本需求。所有与服务相关的代码都是根据OpenAPI规范生成的。我们实现了<a class="ae kv" href="https://en.wikipedia.org/wiki/Glue_code" rel="noopener ugc nofollow" target="_blank"> glue </a>代码。然而，它也可能是这一代人的一部分。</p><p id="b28d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我还得出了一些有价值的见解:</p><ul class=""><li id="f82a" class="nc nd iq lq b lr mk lu ml lx ne mb nf mf ng mj os ni nj nk bi translated">gRPC更像是一个框架，而不是一个规范</li><li id="e0a7" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated">Protobuff schema没有OpenAPI那么详细，它的生成遗漏了一些信息，比如业务错误和代码。</li><li id="af48" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated">Protobuf Util <code class="fe om on oo op b">JSONFormat</code>可以用来为Mongo DB存储创建JSON文档。</li><li id="fb62" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated"><code class="fe om on oo op b">JSONFormat</code>也可用于相似物体之间的映射。</li><li id="6a85" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated">由于我们的服务网络层有了更有效的消息格式，Mongo所需的JSON序列化让我觉得很奇怪。</li></ul><p id="29f6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有没有更有效的方法将我们的数据保存为文档格式？你觉得gRPC怎么样？请在评论中让我知道。</p><h1 id="2a92" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><ul class=""><li id="4dcc" class="nc nd iq lq b lr ls lu lv lx ot mb ou mf ov mj os ni nj nk bi translated">https://quarkus.io/guides/grpc-getting-started的夸库斯·GRPC</li><li id="f13d" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated">OpenAPI生成器:<a class="ae kv" href="https://openapi-generator.tech/docs/generators/protobuf-schema" rel="noopener ugc nofollow" target="_blank">https://open API-Generator . tech/docs/generators/proto buf-schema</a></li><li id="b3d2" class="nc nd iq lq b lr nl lu nm lx nn mb no mf np mj os ni nj nk bi translated">TMF开放API表:<a class="ae kv" href="https://projects.tmforum.org/wiki/display/API/Open+API+Table" rel="noopener ugc nofollow" target="_blank">https://projects . TM forum . org/wiki/display/API/Open+API+Table</a></li></ul></div></div>    
</body>
</html>