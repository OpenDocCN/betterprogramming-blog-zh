<html>
<head>
<title>The Definitive Guide for Creating Ruby Gems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打造红宝石的权威指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-definitive-guide-for-creating-ruby-gems-2663a3f581ce?source=collection_archive---------16-----------------------#2019-09-24">https://betterprogramming.pub/the-definitive-guide-for-creating-ruby-gems-2663a3f581ce?source=collection_archive---------16-----------------------#2019-09-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1623" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">毕竟，一个成功的gem让Ruby程序员的生活更加轻松</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d259f461c79b0cd385ed778eab921d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZA__tJ4qTgd-WafUhutv6w.jpeg"/></div></div></figure><p id="fce0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">探索Ruby语言的简单之美时，很难想到有什么改进可以让程序员的生活更轻松。然而，这种情况比您想象的要多，而且这些改进经常以Ruby gems的形式与他人分享。</p><p id="e4d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">gem是一个打包的库或应用程序，可以用一个叫做RubyGems的工具安装。只要你的Ruby版本至少是1.9，RubyGems就已经和Ruby一起安装了。</p><p id="8ba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一些最有用的宝石是Bundler、Rake和Minitest，它们都有数百万的下载量和同样多的快乐用户。gem的标志是它能够使Ruby程序员的生活变得更容易；如果一个想法有能力做到这一点，它应该与Ruby社区的其他人分享。</p><p id="9990" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于那些有想法但不知道从哪里开始的读者，这篇文章是为你准备的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="82f7" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">创造宝石</h1><p id="0364" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">首先，找到存放宝石的目录。在决定将它存储在哪里时，请记住将目录初始化为Git存储库是一个明智的想法。</p><p id="d3f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的电脑上，我会将该目录存储在我的文档文件夹中，并将其命名为<code class="fe mu mv mw mx b">hello_gem</code>。</p><p id="088f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在<code class="fe mu mv mw mx b">hello_gem</code>目录中导航并创建一个名为<code class="fe mu mv mw mx b">hello.gemspec</code>的文件。不要担心，我们很快就会检查并解释这个文件。</p><p id="1952" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建另一个名为<code class="fe mu mv mw mx b">lib</code>的目录，并在该目录中创建一个名为<code class="fe mu mv mw mx b">hello.rb</code>的文件。这是理解一个gem的结构的第一个关键部分:<code class="fe mu mv mw mx b">lib</code>目录是存储一个人的包的代码的地方。流行的惯例是只有一个与gem同名的Ruby文件。这个文件也负责你的gem的代码和API。</p><p id="2e9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一张我的目录的图片，用于双重检查:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5a515ffad5a815f93cc69a2191786e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*XUNU2vIEjzmJaYjZH6Wjsw.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">hello_gem目录</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/18536f6e062daa03aa88a75154777541.png" data-original-src="https://miro.medium.com/v2/resize:fit:912/format:webp/1*KzqjcVs0YqRj7VGidd2JFw.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">lib目录</p></figure><p id="bf07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">出于本指南的目的，Ruby gem中的代码很简单。一些关于文件路径的概念会变得复杂，所以保持尽可能简单的代码来弥补这一点是合理的。</p><p id="73f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开<code class="fe mu mv mw mx b">hello.rb</code>文件并创建一个<code class="fe mu mv mw mx b">Hello</code>类。这个类现在将有一个类方法<code class="fe mu mv mw mx b">greeting</code>，这个方法将调用<code class="fe mu mv mw mx b">puts</code>方法，并将<code class="fe mu mv mw mx b">“Hello world!”</code>作为它的参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">同学们好！</p></figure><p id="316c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">代码很简单，但它足以检查gem的功能。</p><p id="c456" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导航回我们目录的根目录并打开<code class="fe mu mv mw mx b">hello.gemspec</code>。</p><p id="7dc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">gemspec</code>储存了大量的数据。作者、版本、包含的文件，甚至更多都在其中定义。<code class="fe mu mv mw mx b">Gem</code>是Ruby类，<code class="fe mu mv mw mx b">Specification</code>是包含特定宝石信息的<a class="ae ng" href="https://docs.ruby-lang.org/en/2.5.0/Gem/Specification.html" rel="noopener ugc nofollow" target="_blank">类</a>。</p><p id="deb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">编辑<code class="fe mu mv mw mx b">hello.gemspec </code>以匹配下面的要点，尽管带有<code class="fe mu mv mw mx b">authors</code>、<code class="fe mu mv mw mx b">email</code>、<code class="fe mu mv mw mx b">homepage</code>和<code class="fe mu mv mw mx b">date</code>实例变量的正确信息。对于那些已经将这个项目初始化为Git存储库的人来说，主页也可以是一个GitHub链接。</p><p id="cf7c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">实例方法<code class="fe mu mv mw mx b">name</code>被赋予了字符串<code class="fe mu mv mw mx b">“hello_2019_unique”</code>。将字符串的<code class="fe mu mv mw mx b">unique</code>部分改为独特的，这样它就不会与另一个宝石同名，因为这将导致<code class="fe mu mv mw mx b">push</code>问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">多好的宝石啊！</p></figure><p id="a2c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们建造并安装<code class="fe mu mv mw mx b">Hello</code>宝石。在命令行中运行以下命令:<code class="fe mu mv mw mx b">gem build hello.gemspec</code></p><p id="7df1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">成功构建后，读者将会看到以下消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/4308599d1d8f35fe6d99e52aab0661ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVH2POzT1RlS2hKp-8qRzw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">你好宝石建成了。</p></figure><p id="a35a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">建好了，就该装宝石了。运行以下命令:</p><p id="1395" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">gem install hello_2019_unique-0.0.0.gem</code></p><p id="394e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">希望读者会看到下面的消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/146cb399a89d57ba856ef3eef1fbff86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfZFZjl1V_8be6Es1GEaBg.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">已成功安装。</p></figure><p id="d066" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">挑战就要结束了；让我们把<code class="fe mu mv mw mx b">irb</code>中的<code class="fe mu mv mw mx b">Hello</code>宝石<code class="fe mu mv mw mx b">require</code>出来，看看是否有效。下图包含了本文至此处应该看到的控制台输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/db5322d2d13437e1a72888e2a1378ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gfFgBMg5E7YM-7qcKX0YA.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">现在我们用油做饭！</p></figure><p id="96e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将<code class="fe mu mv mw mx b">require</code>更多的文件，仔细检查<code class="fe mu mv mw mx b">files</code>实例变量，并使用文件路径。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="63b2" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">需要更多文件</h1><p id="ae09" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">显然，你的宝石应该不仅仅包括说“你好”的能力为了创建和包含更多的文件，必须在<code class="fe mu mv mw mx b">lib</code>目录中创建一个与<code class="fe mu mv mw mx b">lib</code>目录中的Ruby文件名相匹配的新目录。导航到<code class="fe mu mv mw mx b">lib</code>目录并执行该操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/460ef1fc34d9c12ed97b6e99d950d2d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*UPTKTlgiO8EfMQ9K7OXesQ.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">hello目录在lib里面。</p></figure><p id="b5de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是RubyGems的另一个约定:用于gem的附加文件位于与<code class="fe mu mv mw mx b">lib</code>中的Ruby文件名相匹配的目录中。导航到<code class="fe mu mv mw mx b">hello</code>目录并创建一个名为<code class="fe mu mv mw mx b">goodbye.rb</code>的文件。</p><p id="e361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的要点包含了应该在他们的<code class="fe mu mv mw mx b">Goodbye</code>类中实现的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c8d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，要求<code class="fe mu mv mw mx b">hello.rb</code>中的<code class="fe mu mv mw mx b">goodbye.rb</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">现在hello.rb可以访问Goodbye类了。</p></figure><p id="feed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得如何在<code class="fe mu mv mw mx b">gemspec</code>中包含更多文件吗？再看一下要点，注意文件存储在什么数据结构中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cce3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不能追加到<code class="fe mu mv mw mx b">files</code>实例方法；相反，必须给它分配一个<code class="fe mu mv mw mx b">array</code>。另外，不要在这个列表中包含目录，因为在构建过程中目录会自动从gem中删除。</p><p id="ad4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大多数宝石都比这个例子大得多，也复杂得多。想象一下，一个gem有50多个Ruby文件分散在嵌套的目录中。如果不用手写，我们如何分配所有这些文件呢？</p><p id="9af3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">Dir[]</code>类方法就是最好的答案之一。使用<code class="fe mu mv mw mx b">Dir[]</code>类方法，可以使用文件模式来匹配和包含<code class="fe mu mv mw mx b">lib</code>的所需文件及其所有嵌套目录。<code class="fe mu mv mw mx b">Dir[]</code>的返回值是一个数组，这很好，因为我们需要给<code class="fe mu mv mw mx b">files</code>分配一个数组。<a class="ae ng" href="https://ruby-doc.org/core-2.6.4/Dir.html#M002316" rel="noopener ugc nofollow" target="_blank">使用前，请阅读更多关于<code class="fe mu mv mw mx b">Dir[]</code>的</a>。</p><p id="f21a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来看一些<a class="ae ng" href="https://ruby-doc.org/core-2.5.1/File.html" rel="noopener ugc nofollow" target="_blank">文件匹配模式</a>。</p><p id="7dbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据前面的链接，<code class="fe mu mv mw mx b">*</code>匹配任何文件。如果我们在<code class="fe mu mv mw mx b">*</code>后面包含一个文件扩展名，比如<code class="fe mu mv mw mx b">.rb</code>，那么这个模式现在匹配所有以<code class="fe mu mv mw mx b">.rb</code>结尾的文件。这个模式将用于匹配和收集我们想要的文件。</p><p id="5a65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">**</code>模式对于将正确的文件分配给<code class="fe mu mv mw mx b">files</code>也是至关重要的。这种模式递归地匹配目录，扩展地匹配文件，这意味着如果使用正确，我们可以在<code class="fe mu mv mw mx b">lib</code>的所有嵌套目录中搜索我们希望包含在gem中的文件。</p><p id="f58e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了测试<code class="fe mu mv mw mx b">**</code>的递归方面，导航到<code class="fe mu mv mw mx b">lib</code>中的<code class="fe mu mv mw mx b">hello</code>目录，并创建一个名为<code class="fe mu mv mw mx b">third_layer</code>的新目录。在<code class="fe mu mv mw mx b">third_layer</code>目录中，创建一个名为<code class="fe mu mv mw mx b">example.rb</code>的文件。不需要在这个文件中包含任何代码，因为它只是用于演示目的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/989eef4b5b66bd04bf2fe553c36951be.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*Uyv1Kfp364MDQtxFwx5d-A.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">这是在lib里面的hello目录中。</p></figure><p id="54fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次打开<code class="fe mu mv mw mx b">hello.gemspec</code>。导航到最后一行，向下输入到新的一行。让我们用一个<code class="fe mu mv mw mx b">p</code>方法调用来测试一下<code class="fe mu mv mw mx b">Dir[</code>。尝试从<code class="fe mu mv mw mx b">lib</code>输出我们想要包含的所有文件。如果任何读者希望自己尝试使用<code class="fe mu mv mw mx b">Dir[]</code>，不要向下滚动，因为下一段和图片包含了包含来自<code class="fe mu mv mw mx b">lib</code>的所有文件的解决方案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8ab0d145a04dd8c4c678019029400bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*ZjWccZCauhw4iDSau8uP9w.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">这是Dir[]之后的文件中包含的内容的输出。</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">读者可以通过调用“p”方法来测试这一点。</p></figure><p id="792a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如这个例子所示，<code class="fe mu mv mw mx b">Dir[]</code>是一个非常有用的类方法。为了进一步测试这个<code class="fe mu mv mw mx b">Dir[]</code>方法，创建一个扩展名为<code class="fe mu mv mw mx b">.txt</code>的文件，并将其与<code class="fe mu mv mw mx b">.rb</code>文件一起包含在<code class="fe mu mv mw mx b">files</code>中。有几种不同的方法可以做到这一点，即使使用<code class="fe mu mv mw mx b">Dir[]</code>。尽量具体一点！</p><p id="c3d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在所有正确的文件都包括在内了，是时候测试一下<code class="fe mu mv mw mx b">hello.rb</code>了。转到命令行，启动下面一行:<code class="fe mu mv mw mx b">irb -Ilib -rhello</code></p><p id="a17a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">稍微解释一下是合适的。<code class="fe mu mv mw mx b">-I</code>是指定<code class="fe mu mv mw mx b">$LOAD_PATH</code>目录的选项。在这种情况下，它使用<code class="fe mu mv mw mx b">lib</code>作为<code class="fe mu mv mw mx b">$LOAD_PATH</code>目录。<code class="fe mu mv mw mx b">-r</code>选项正在运行文件<code class="fe mu mv mw mx b">hello.rb</code>并要求当前<code class="fe mu mv mw mx b">irb</code>会话中的gem。有更多的选项可以用来修改<code class="fe mu mv mw mx b">irb</code>会话，如果感兴趣，请查看<code class="fe mu mv mw mx b">IRB</code>模块<a class="ae ng" href="https://docs.ruby-lang.org/en/2.2.0/IRB.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="2a90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">命令行的输出应该如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/a33cbcfa7a2b0f259758ba5449c49f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wCbC8dd3GEkxlTXP5kh4Rg.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">现在可以从irb中的Hello调用这些方法。</p></figure><p id="d3ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果任何读者想要这个更新版本的<code class="fe mu mv mw mx b">build</code>和<code class="fe mu mv mw mx b">install</code>，请务必在gemspec中更新<code class="fe mu mv mw mx b">version</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">版本号0.0.1！</p></figure><p id="ed77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将代码分离到不同的文件中，并添加逻辑有序的目录，对于创建一个代码对外人有意义的gem来说是不可或缺的。此外，理解应用程序中的路径有助于精心设计全面的测试。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4df9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">添加可执行文件</h1><p id="975c" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">类似于我们如何在命令行中编写<code class="fe mu mv mw mx b">irb</code>并执行该程序，我们可以在我们的gem中包含一个<code class="fe mu mv mw mx b">executable</code>文件，并用一条命令运行gem。Gems通过向外壳路径显示一个或多个可执行文件来做到这一点。</p><p id="49ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，导航至<code class="fe mu mv mw mx b">hello_gem</code>。然后，发出以下三个命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/b59cf48e4e269799aad586099128dfc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/format:webp/1*yI8hYeW2ifXrAYcior5OvQ.png"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">这些命令创建bin目录和我们的可执行文件。</p></figure><p id="7875" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这三个命令做了以下工作:创建目录<code class="fe mu mv mw mx b">bin</code>，其中包含可执行文件。然后，第二个命令在<code class="fe mu mv mw mx b">bin</code>中创建文件<code class="fe mu mv mw mx b">hello</code>。最后，<code class="fe mu mv mw mx b">chmod</code>代表更改模式，在这种情况下，使用<code class="fe mu mv mw mx b">+x</code>修饰符更改文件的操作。</p><p id="af1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在文本编辑器中打开<code class="fe mu mv mw mx b">hello</code>。为了让这个<code class="fe mu mv mw mx b">executable</code>真正工作，我们需要在它的顶部添加一个<code class="fe mu mv mw mx b">shebang</code>，它将指示一个特定语言的可执行shell脚本的开始。确保<code class="fe mu mv mw mx b">hello</code>与以下代码匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">这是bin目录中hello的代码。</p></figure><p id="a304" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关闭<code class="fe mu mv mw mx b">hello</code>并再次打开命令行。我们将在<code class="fe mu mv mw mx b">gemspec</code>中要求之前测试<code class="fe mu mv mw mx b">executable</code>。在命令行中运行以下命令:<code class="fe mu mv mw mx b">ruby -Ilib ./bin/hello</code></p><p id="1c2b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">或者，可以不使用<code class="fe mu mv mw mx b">-Ilib</code> : <code class="fe mu mv mw mx b">ruby ./bin/hello</code>来运行命令</p><p id="8253" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为可执行文件的名称是<code class="fe mu mv mw mx b">hello</code>，所以通过调用相同的名称来执行可执行文件。测试成功运行后，是时候将可执行文件包含在<code class="fe mu mv mw mx b">hello.gemspec</code>中了。数组<code class="fe mu mv mw mx b">executables</code>应该被附加到上，与数组<code class="fe mu mv mw mx b">files</code>形成鲜明对比，后者应该被赋值给。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div><p class="mz na gj gh gi nb nc bd b be z dk translated">更新了可执行文件hello的gemspec。</p></figure><p id="5b5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果任何读者希望<code class="fe mu mv mw mx b">build</code>和<code class="fe mu mv mw mx b">install</code>新的gem，不要忘记再次更改版本号。在安装新的gem之后，不要忘记在命令行中输入<code class="fe mu mv mw mx b">hello</code>来测试它。我们可以用一个词来称呼我们的程序，这有多酷？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/5f6343a85619347427b9817e046b4482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQvn5TvCisCtY9qyw3BNBg.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">你好世界！</p></figure></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="6a38" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">把宝石推给RubyGems</h1><p id="89a1" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">一旦gem处于可供他人使用的状态，你就可以<code class="fe mu mv mw mx b">push</code>将gem转到RubyGems供他人下载。</p><p id="c648" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，创建一个<a class="ae ng" href="https://rubygems.org/" rel="noopener ugc nofollow" target="_blank"> RubyGems </a>账户，注意:这听起来很疯狂，但是尽量不要包含特殊字符，如<em class="nq"> $、%、</em>或<em class="nq">！</em>密码中。RubyGems很难认证在命令行中使用这些字符的密码，所以一开始就不使用它们会更容易。还有其他方法可以获得安全的密码，比如改变大写和小写字母、拼写错误的单词等等。</p><p id="e1ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在命令行中运行以下命令。</p><p id="e771" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">curl -u your_username <a class="ae ng" href="https://rubygems.org/api/v1/api_key.yaml" rel="noopener ugc nofollow" target="_blank">https://rubygems.org/api/v1/api_key.yaml</a> &gt; ~/.gem/credentials; chmod 0600 ~/.gem/credentials</code></p><p id="4089" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此命令为帐户下载特定的API密钥。调用该命令的计算机随后与该特定帐户相关联。代替<code class="fe mu mv mw mx b">your_username</code>的应该是读者的用户名。</p><p id="1acc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦API设置完毕，<code class="fe mu mv mw mx b">push</code>gem向RubyGems发出以下命令:</p><p id="a2c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">gem push hello-0.0.your_version.gem</code></p><p id="a898" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！任何使用RubyGems的人都可以下载这个gem。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1fa6" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">包扎</h1><p id="08ea" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">这篇文章的目标是尽可能多地消除创建第一个宝石的常见障碍。制作一个坚固的宝石有许多固有的基本实践，比如<a class="ae ng" href="https://thoughtbot.com/playbook/developing/test-driven-development" rel="noopener ugc nofollow" target="_blank"> TDD </a>，使用Rakefile实现任务自动化，等等。这些都是较大的概念，不可能在一篇文章中涵盖。</p><p id="c550" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">学习如何创造东西的最好方法之一是对它进行逆向工程。在这种情况下，您可以通读一个gem的文件、类和方法，以获得对制作gem的逻辑和代码的绝对理解。此外，人们实际上可以重写和重构代码。</p><p id="e5a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我建议从逆向工程一个简单的应用程序开始，不要像Bundler或Rubocop那样。我最近创建了一个名为<a class="ae ng" href="https://github.com/jordanmoore753/EasyPortfolio" rel="noopener ugc nofollow" target="_blank"> EasyPortfolio </a>的gem，它为软件工程师求职者创建了一个Sinatra支持的Portfolio页面。对于第一次制作宝石的人来说，这种宝石很容易理解，但也很复杂，足以让你看到宝石所能展现的力量。</p><p id="d841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总之，记住一个成功的gem的标志:让Ruby程序员的生活变得更容易的能力。祝好运和成功，红宝石士兵。创造美好的东西！</p></div></div>    
</body>
</html>