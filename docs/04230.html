<html>
<head>
<title>Mutable Default Arguments in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中可变的默认参数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mutable-default-arguments-in-python-643ae2583e00?source=collection_archive---------5-----------------------#2020-03-31">https://betterprogramming.pub/mutable-default-arguments-in-python-643ae2583e00?source=collection_archive---------5-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0111" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给你的函数设置默认值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/336af0022b7baa54aee7b9e5c224800a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*36NkfkClAi239rOhsLc24g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mitchel3uo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">米切尔罗</a>在<a class="ae ky" href="https://unsplash.com/s/photos/python-programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="8e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">int</code>、<code class="fe lv lw lx ly b">float</code>、<code class="fe lv lw lx ly b">bool</code>、<code class="fe lv lw lx ly b">str</code>、<code class="fe lv lw lx ly b">tuple</code>、<code class="fe lv lw lx ly b">Unicode</code>等内置类型的对象是不可变的。像<code class="fe lv lw lx ly b">list</code>、<code class="fe lv lw lx ly b">set</code>和<code class="fe lv lw lx ly b">dict</code>这样的内置类型的对象是可变的。可变对象可以改变其状态或内容，而不可变对象则不能。</p><p id="39ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Python中可变和不可变对象的一个非常简单的定义。现在到了有趣的部分，它是函数定义中可变的默认对象。</p><p id="d6e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面我写了一个非常简单的函数:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4caa" class="md me it ly b gy mf mg l mh mi">def foobar(element, data=[]):<br/>    data.append(element)<br/>    return data</span></pre><p id="0452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个函数中，我将<code class="fe lv lw lx ly b">data</code>设置为一个列表(可变对象)作为默认参数。现在让我们执行这个函数:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6936" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; print(foobar(12))<br/>[12]</span></pre><p id="567b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出符合预期。现在执行多次:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3d70" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; print(foobar(22))<br/>[12, 22]<br/>&gt;&gt;&gt; print(foobar(32))<br/>[12, 22, 32]</span></pre><p id="7fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是怎么回事？正如您所看到的，第一次，函数返回的正是我们所期望的。在第二次和所有后续传递中，每次调用都使用相同的列表。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6c3b" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">为什么会这样？</h1><p id="3670" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">Python的默认参数在定义函数时计算一次，而不是在每次调用函数时计算。当Python遇到它时，它要做的第一件事就是编译它，以便为这个函数创建一个代码对象。当这个编译步骤完成时，Python会计算默认参数，然后将其存储在函数对象本身中。</p><p id="9809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们做一些反省。为了消除任何混淆，我突出显示了几行代码。</p><h2 id="e62f" class="md me it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">执行前的功能</h2><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="ee85" class="md me it ly b gy mf mg l mh mi">def foo(l=[]):<br/>    l.append(10)</span></pre><p id="4724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在函数执行这个定义之后，您可以使用<code class="fe lv lw lx ly b">__defaults__</code>来检查这个函数的默认属性。</p><p id="b208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">__defaults__</code>是一个元组，包含那些具有默认值的参数的默认参数值(如果没有参数具有默认值，则为<code class="fe lv lw lx ly b">None</code>)。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1c98" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; foo.__defaults__<br/>([],)</span></pre><p id="d6ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是一个空列表作为<code class="fe lv lw lx ly b">__defaults__</code>中的唯一条目。</p><h2 id="6b57" class="md me it bd mr nm nn dn mv no np dp mz li nq nr nb lm ns nt nd lq nu nv nf nw bi translated">执行后的功能</h2><p id="b025" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">现在让我们执行这个函数并检查默认值:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b354" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; foo()<br/>&gt;&gt;&gt; foo.__defaults__<br/>([10],)</span></pre><p id="2a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">惊讶吗？对象内部的值会发生变化。对该函数的连续调用现在将简单地追加到嵌入的列表对象中。</p><p id="cbfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们多次执行该函数:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="033e" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; foo()<br/>&gt;&gt;&gt; foo()<br/>&gt;&gt;&gt; foo()</span><span id="ac5b" class="md me it ly b gy nx mg l mh mi">&gt;&gt;&gt; foo.__defaults__<br/>([10, 10, 10, 10],)</span></pre><p id="4721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为默认参数值存储在函数对象中，而不是代码对象中(因为它们表示运行时计算的值)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8977" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">解决方案</h1><p id="cea1" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">现在，问题是如何编码<code class="fe lv lw lx ly b">foobar</code>以获得我们期望的行为。</p><p id="0d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，解决方案很简单。用作默认值的可变对象被替换为<code class="fe lv lw lx ly b">None</code>，然后测试参数的<code class="fe lv lw lx ly b">None</code>:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d637" class="md me it ly b gy mf mg l mh mi">def foobar(element, data=None):<br/>    if data is None:<br/>        data = []<br/>    data.append(element)<br/>    return data</span><span id="3d38" class="md me it ly b gy nx mg l mh mi">&gt;&gt;&gt; foobar(12)<br/>[12]</span></pre><p id="6758" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以用<code class="fe lv lw lx ly b">None</code>替换可变的默认参数解决了我们的问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="585c" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">善用可变默认参数</h1><p id="a968" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">然而，可变默认参数也有一些很好的用例:</p><ol class=""><li id="d10a" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">在回调中将局部变量绑定到外部变量的当前值。</li><li id="2467" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">缓存/记忆化。</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7387" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="fef3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我希望您喜欢Python中可变默认参数的解释。如果你有任何疑问或问题，请在下面的评论中告诉我。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7b6a" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">参考</h1><ul class=""><li id="13d1" class="ny nz it lb b lc nh lf ni li om lm on lq oo lu op oe of og bi translated"><a class="ae ky" href="https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/reference/data model . html # the-standard-type-hierarchy</a></li></ul></div></div>    
</body>
</html>