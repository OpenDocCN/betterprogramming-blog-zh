# 扔还是不扔？JavaScript 和 TypeScript 中的错误传播

> 原文：<https://betterprogramming.pub/to-throw-or-not-to-throw-error-propagation-in-js-and-ts-68aaabe30e30>

## 探索误差传播原理

![](img/4467ec40b1280de022ceeae6db41e679.png)

莎拉·基利安在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

JavaScript 和 TypeScript 中最有问题的概念之一是错误传播。问题的一部分是对异常和错误之间的区别的误解。

这篇文章旨在发现异常类型并定义错误传播原则。尽管本文强调了 JavaScript 和 TypeScript，但同样的错误传播原则也适用于许多其他语言。

# 异常和错误

错误是一个对象，它包含关于什么地方出错了以及在代码中什么地方出错的信息。异常不是错误； [*异常*](https://en.wikipedia.org/wiki/Exception_handling) 是需要特殊处理的异常或例外情况。这种情况有两种:*运行*和*非运行*。

输入验证错误为*操作*错误*。*失败的登录尝试是一种*操作*情况。这些用例是预期的，并得到相应的处理。每当出现这种情况时，应用程序都会照常运行。

不可操作的条件是应用程序不能自动解决错误，应该被终止。例如，应用程序应该将数据存储在数据库中。当无法连接到数据库时，应用程序的某些功能会丢失。如果该功能是关键的，则应用处于*非操作*状态。如果它不能自动恢复，应该终止它。

# 误差传播

一切都从错误传播开始。返回错误的方法决定了应用程序是继续运行还是最好停止。错误传播方法还定义了应该如何处理错误。

在 JavaScript 和 TypeScript 中有两种传播错误的方法:

*   [抛出](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw)异常。如果不处理，它将终止进程。当打算在出错时停止应用程序时，应该使用它。
*   返回一个错误。它表示预期的错误情况，不需要应用程序终止。

使用 *throw* 机制返回错误的危险在于，如果处理不当，它可能会终止应用程序。仅仅返回错误不会停止应用程序。但是忽略这样的错误会将应用程序带入一种意想不到的无序状态。

选择错误传播机制的另一个重要方面是文档。使用 TypeScript 时，语言服务会推断函数的输入和输出参数的类型。如果函数返回一个错误类型的参数，它在代码编辑器中是可见的，并降低了丢失错误处理的风险。当函数抛出异常时，情况就不同了——语言服务无法识别它。在 [TSDoc](https://tsdoc.org/) 中定义了 [*throws*](https://tsdoc.org/pages/tags/throws/) 标签，但是并没有广泛使用。发现函数抛出异常的唯一方法是阅读它的源代码。

# 异常处理

异常处理取决于错误的返回方式和返回错误的函数类型。对于同步函数来说相对容易。当被函数返回时，用 *if* 子句检查错误。如果一个函数抛出异常，它的调用通常由 *try/catch* 保护。

在异步函数的情况下，异常处理更加复杂。有几种方法可以处理异步操作:

*   使用回调函数
*   使用带有`.then`和`.catch`的承诺
*   用`await`来解决承诺

还有发电机，我就省略了。

回调中的异常处理非常简单。每当一个异步操作完成时，操作处理程序调用一个回调函数并返回错误(如果有的话)。按照惯例，回调函数的第一个参数是一个错误。如果错误不为空，回调函数调用将停止。这使得控制流易于理解。

这里有一些挑战。不清楚错误是由*操作*还是*非操作*异常引起的。另一个挑战是处理结果传播。将一个函数的输出传递给另一个函数的输入的需求产生了大量带有嵌套回调的代码，很难阅读和维护。

Promises 解决了编排函数的顺序调用(同步和异步)的问题。一系列的承诺可以和*的一个电话联系在一起。然后，*和数据可以在调用之间流动。但是承诺使用回调并继承了相同的异常处理挑战。

*Async/await* 消除了使用回调的需要，解决了编排问题。现在可以等待异步函数的结果了。它让代码更干净、更易读，至少是一条*快乐之路*。 *Try/catch* 取代了回调错误处理技术。一开始感觉像是赢了。事实上，新问题取代了旧问题:

*   当使用 *try/catch、*保护异步函数调用时，仍然不清楚错误是由*操作性*还是*非操作性*异常导致的。
*   在一个 *try/catch* 块中看到多个异步函数调用并不少见。在这种情况下， *catch* 子句处理所有函数的异常。在 *catch* 块中看到复杂的错误处理逻辑，试图理解什么函数调用是错误的来源，这种情况并不少见。
*   嵌套的 *try/catch* 块。它看起来甚至比嵌套回调更糟糕。

那么，我们如何在异步调用编排中利用 *async/await* 的优势，并最小化异常处理问题呢？

# 错误传播和处理原则

*   *操作*异常返回错误。
*   总是检查返回的错误。
*   对于*非操作性*异常抛出错误。
*   *试*语句块应该守护单个逻辑单元或一个调用。
*   避免在 *catch* 子句中使用复杂的逻辑。
*   不要嵌套*试/抓*块。
*   换行错误。

包装错误意味着接受一个错误值，并将另一个错误值放入其中。它允许用关于错误来自哪里或如何发生的附加信息来扩展错误，而不会丢失原始值。有几个[库](https://2ality.com/2021/06/error-cause.html#a-library)支持 JavaScript 中的错误包装。或者，您可以采用 ECMAScript2022，它内置了对`[error.cause](https://2ality.com/2022/06/ecmascript-2022.html#error.cause)` *的支持。*

以下部分显示了错误传播和处理的示例:

## 尝试捕捉方法

当 *try/catch* 守护单个语句时，很容易推断出代码。当需要处理多个异步调用时，情况会变得更糟。

## 包装尝试/捕捉方法

这种方法在函数中隐藏了 *try/catch* 。函数声明声明它可以返回一个错误或一个值。它允许使用一个 *if* 语句来控制逻辑流程。

下面的例子是概括错误处理的下一步。它使用 TypeScript 实用工具类型来推断函数参数和输出类型。

上面的例子使用了 [Deno](https://deno.land/) read file API。要运行它们，请使用以下命令:

```
$ FILE=hello.txt deno run --allow-env=FILE --allow-read main.ts
```

感谢阅读。