<html>
<head>
<title>Hello, Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你好，去吧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hello-go-6721933be560?source=collection_archive---------12-----------------------#2019-11-08">https://betterprogramming.pub/hello-go-6721933be560?source=collection_archive---------12-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7866" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">异想天开的围棋入门</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cf86e7970d8013df51a1639f98746b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WQDvzMwtNv2ywQwfcjoseA.png"/></div></div></figure><p id="8699" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我喜欢上了Go，主要原因是它是一种简单的语言。但是这让你，开发者，变聪明的选择更少了。如果你必须聪明地编写一个程序，你就必须加倍聪明地维护和调试它。</p><p id="df01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，为了展示围棋的美丽和简单，我们将演练一个经典的小“你好，世界！”程序。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="2f5a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">打招呼</h1><p id="8f38" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">有很多方法可以得到包含“Hello，world！”最好是在无服务器架构上包括区块链和神经网络，以获得最大宣传因素，但这样做完全是矫枉过正——更不用说像打印到标准输出这样简单的事情也会超出预算。</p><p id="f9c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我们将对输入字符串进行排列排序，直到得到所需的输出“Hello，world！”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/aa7591d810746d8b29aecb8b3582d1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*4OHsIByz7F9CSwOMqqD7vw.png"/></div></figure><p id="cc58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中实现这一点相当简单。</p><p id="41ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将从目标字符串中取出一部分，将其转换成符文，并使用<code class="fe mv mw mx my b">rand.Shuffle</code> <em class="mz"> </em>对其进行洗牌，直到它与目标字符串匹配。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="57a8" class="ne ly it my b gy nf ng l nh ni"><strong class="my iu">package</strong> main</span><span id="bdd7" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">import</strong> (<br/><em class="mz">  "fmt"<br/>  "math/rand"</em><br/>)</span><span id="b473" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">func</strong> main() {<br/>  t := <em class="mz">"Hello World!"</em><br/>  s := []<strong class="my iu">rune</strong>(t)<br/>  <br/>  <strong class="my iu">for</strong> {<br/>    rand.Shuffle(len(s), <strong class="my iu">func</strong>(i int, j int) {<br/>      s[i], s[j] = s[j], s[i]<br/>    })</span><span id="7cfd" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">    if</strong> <strong class="my iu">string</strong>(s) == t {<br/>      <strong class="my iu">break<br/>    </strong>}<br/>  }</span><span id="ac57" class="ne ly it my b gy nj ng l nh ni">  fmt.Println(string(s))<br/>}</span></pre><p id="e9a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用<code class="fe mv mw mx my b">go run hello.go</code>来运行这个。</p><p id="33e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了。我们得到了最小高效的“你好，世界”程序。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a8c2" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">跟踪进度</h1><p id="ec08" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们已经完成了基本的工作，但是最好有一些进度日志，包括排列计数和值。所以我们来补充一下。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="8b16" class="ne ly it my b gy nf ng l nh ni"><strong class="my iu">package</strong> main</span><span id="52c0" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">import</strong> (<br/>  <em class="mz">"fmt"<br/>  "math/rand"</em><br/>)</span><span id="8285" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">func</strong> main() {<br/>  t := <em class="mz">"Hello World!"</em><br/>  s := []<strong class="my iu">rune</strong>(t)</span><span id="77e9" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">  for</strong> {<br/>    rand.Shuffle(len(s), <strong class="my iu">func</strong>(i int, j int) {<br/>      s[i], s[j] = s[j], s[i]<br/>    })</span><span id="9124" class="ne ly it my b gy nj ng l nh ni">    fmt.Println(string(s))</span><span id="7a3e" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">    if</strong> <strong class="my iu">string</strong>(s) == t {<br/>      <strong class="my iu">break</strong><br/>    }<br/>  }<br/>}</span></pre><p id="4dcc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将用<code class="fe mv mw mx my b">go build hello.go</code>建造这个。</p><p id="5d8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了！我们有输出。</p><p id="cbc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于添加置换计数，没有必要将这种开销包含到我们的可执行文件中，因为我们可以将它放入一个外部命令中，比如<code class="fe mv mw mx my b">cat(1)</code>、<em class="mz">、</em>，其中有一个行号选项<em class="mz">。</em></p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="06cb" class="ne ly it my b gy nf ng l nh ni"><strong class="my iu">$</strong> hello | cat -n</span></pre><p id="ebce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用默认种子，我们需要38，528，967次迭代才能到达“Hello，world！”排列。</p><p id="3875" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:如果你使用的是微软的Windows操作系统，没有类似UNIX的环境，此时此刻你可能要重新评估你的人生选择。现在甚至还有Windows/Unix。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="d4aa" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">许多比一个多</h1><p id="7dd7" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">考虑到我们的程序需要做什么，它的计算速度已经相当快了。垃圾收集器也没有让我们陷入太多的困境，尽管我们在不断地创建新的字符串。</p><p id="54ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们仍然可以通过并行生成字符串来加快速度。反过来，这将使Go能够调度我们的计算在可能的情况下跨多个硬件线程并行运行。</p><p id="2751" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go的并发模型基于自包含的协程，它们通过通道传递消息进行通信，这通常用Gophers作为比喻来描述。</p><p id="4c8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们要做的是强迫一群可爱的小地鼠做所有的工作，试图猜测并通过频道<em class="mz"> </em>向我们喊出正确的排列，而我们只是坐在主要区域决定它是正确还是错误的答案。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/1e913f001000536563ef4d044010ab98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uytn4tsQx4GrArno8G4PlQ.png"/></div></div></figure><p id="b807" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的大部分实现将保持不变。</p><p id="dd9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将把置换重组提取到一个函数中，该函数向我们的通道发送消息。在我们的main函数中，我们迭代消息，测试它们与目标字符串的等价性。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="259e" class="ne ly it my b gy nf ng l nh ni"><strong class="my iu">package</strong> main</span><span id="dc38" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">import</strong> (<br/>  <em class="mz">"fmt"<br/></em>  <em class="mz">"math/rand"</em><br/>)</span><span id="2166" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">func</strong> main() {<br/>  t := <em class="mz">"Hello world!"</em><br/>  c := <strong class="my iu">make</strong>(<strong class="my iu">chan</strong> <strong class="my iu">string</strong>)</span><span id="b0b1" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">  for</strong> i := 0; i &lt; 32; i++ {<br/>    <strong class="my iu">go</strong> gopher(t, c)<br/>  }</span><span id="e40a" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">  for</strong> s := <strong class="my iu">range</strong> c {<br/>    fmt.Println(s)</span><span id="ab09" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">    if</strong> s == t {<br/>      <strong class="my iu">break</strong><br/>    }<br/>  }<br/>}</span><span id="3b9b" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">func</strong> gopher(t <strong class="my iu">string</strong>, c <strong class="my iu">chan</strong> <strong class="my iu">string</strong>) {<br/>  s := []<strong class="my iu">rune</strong>(t)</span><span id="5188" class="ne ly it my b gy nj ng l nh ni"><strong class="my iu">  for</strong> {<br/>    rand.Shuffle(<strong class="my iu">len</strong>(s), <strong class="my iu">func</strong>(i, j <strong class="my iu">int</strong>) {<br/>      s[i], s[j] = s[j], s[i]<br/>    })</span><span id="305e" class="ne ly it my b gy nj ng l nh ni">    c &lt;- <strong class="my iu">string</strong>(s)<br/>  }<br/>}</span></pre><p id="8aa9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">成功！我们让地鼠同时一起工作。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="70b1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">一群人有多少？</h1><p id="336e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们从中获得了什么样的性能提升？我们实际上降低了性能。</p><p id="99ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">越多并不总是越好，事实证明，本课没有最初计划的<a class="ae nl" href="https://amzn.to/2r7RyCr" rel="noopener ugc nofollow" target="_blank">螺纹开膛手</a>的预算。因此，让32个地鼠在四个线程上工作意味着它们可能需要在指定的队列中等待，然后才能被允许工作。</p><p id="e6b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么到底多少才算太多呢？传统观点认为每个硬件线程一个，但只有一种方法可以找到答案，那就是测量它。</p><p id="6c78" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将用time(1)来度量程序完成所需的时钟时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/e5d482eedacbc39461673dd9e14f3c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AcdzMYkevuqawJZGqEEM_w.png"/></div></div></figure><p id="b862" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不错！我们有明确的数据:六只无疑是地鼠的最佳数量。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="ff14" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="2001" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">地鼠可以很好地执行猴子排序——算法是种间兼容的！</p><p id="b4ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是对Go并发性的古怪看法。如果你不喜欢围棋，你应该喜欢。如果你想以不涉及排列排序和豆袋插图等可怕算法的方式学习围棋，我建议试试“<a class="ae nl" href="https://amzn.to/2HN2Ovj" rel="noopener ugc nofollow" target="_blank">的围棋编程语言</a>。</p></div></div>    
</body>
</html>