<html>
<head>
<title>Understanding Rust Ownership Model by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例了解Rust所有权模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-rust-ownership-model-by-example-5d586ec5e8e4?source=collection_archive---------6-----------------------#2022-06-05">https://betterprogramming.pub/understanding-rust-ownership-model-by-example-5d586ec5e8e4?source=collection_archive---------6-----------------------#2022-06-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1dc8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解作为Rust所有权体系基础的3条规则</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d2461217ccd58d283770a8e9d296da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coSUd-s1UxZa9SnH_KnKUQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Rust所有权模型封面</p></figure><p id="d9c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在过去的几个月里，我对Rust编程语言很感兴趣——尤其是它的内存模型和所有权。</p><p id="eeec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">起初，我认为它只是另一种系统编程语言，我可以通过编写一些示例应用程序在几周内学会。但是后来我在使用它的所有权模型时遇到了许多障碍。</p><p id="4ded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我花了几个星期才真正理解RUST编写的基本原理。现在我不能停止学习和尝试更多的东西。</p><p id="224a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我将用一个简单的例子来分享一些所有权原则。</p><p id="1c02" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子是一个交互式产品分析框架的一部分，我试图建立这个框架来学习Rust并从头开始编写一个分布式系统。</p><p id="fe64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要开始，请参考下面的数据结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="f588" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在数据分析领域，事件是由键值对组成的数据结构。这些是发送到数据收集服务的数据点。事件通常可以根据人类的可读性来命名。我们将在整个教程中使用这个事件结构，并理解Rust的所有权规则基础。</p><h1 id="ad85" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">没有垃圾收集器</h1><p id="ed6d" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在我们深入研究规则之前，理解Rust不像其他高级编程语言那样有垃圾收集器是很重要的。它也没有像C / C++那样对大部分部件进行手动内存管理。<em class="na">因此，当我们既需要性能又需要内存安全时，它是首选</em>。</p><p id="3ebf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">谈到栈/堆上的内存管理，Rust有一些简单的规则来管理对象和内存。Rust确保我们的程序在管理内存时不会出错——前提是我们遵守某些规则。</p><p id="3d2b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一开始，使用这种内存模型和所有权规则似乎非常令人生畏，但是一旦我们习惯了这种操作模型，它会使我们成为更好的程序员，并提供尽可能好的性能，而不必管理低级内存。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="8780" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是使用语言对象和变量时的规则。</p><h1 id="39de" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">每个变量都有一个所有者</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8508" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑上面显示的代码块。我们初始化三个变量，即事件名称、客户端ID和实际的事件对象。第一条规则非常简单——每个变量都有一个所有者。这意味着上面定义的三个值归三个变量所有。这些变量只能在此函数内访问，不允许超出此函数范围的访问。当我运行这个程序时，我们看到了预期的输出，这是我们配置的事件名称。</p><p id="54a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们看看另外两条规则。</p><h1 id="9976" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">只允许一个所有者</h1><p id="7e10" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">在任何给定的时间点，Rust只允许变量有一个所有者。通常，许多编程语言都有使用多个变量来引用同一个值的概念。例如，在JAVA中，可以写</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="2998" class="ng me it nc b gy nh ni l nj nk">String name = "Sam" ; <br/>String sam = name; <br/>System.out.println(name); <br/>System.out.println(sam);</span></pre><p id="a2b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这在Java中完全没问题。它打印出这两个值。</p><p id="c9c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们在Rust中尝试一个类似的东西。</p><p id="de67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们试图复制原始引用并将其存储在另一个变量中，以便在打印语句中使用它们。猜猜这会发生什么。</p><p id="5eb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是我们尝试运行时的输出。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8aab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在这里做的只是使用另一个变量名来引用同一个事件并打印它们。但是Rust一点都不喜欢这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="1400" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据我们的第二条规则，一个值只能有一个所有者。在我们的例子中，我们最初定义的事件属于<code class="fe nl nm nn nc b">new_event</code>变量。</p><p id="6ef6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从技术上讲，当我们试图创建一个新变量并引用原始事件时，我们打算创建两个指向相同数据的所有者。</p><p id="46cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据第一和第二条规则，这是不允许的。为了确保始终只有一个所有者，<em class="na"> rust将值移动到这个新变量</em>中，用<code class="fe nl nm nn nc b">new_event_copy_ref</code>表示。所以，只要我们把旧变量赋给新事件变量，这个新变量就指向原始事件的内存位置。</p><p id="b4a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从那时起，我们不能使用原始变量，因为它不存在。数据仍然存在，但有了新的所有者。RUST会立即删除原始变量并清理它。</p><p id="59c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，当我们试图使用变量<code class="fe nl nm nn nc b">new_event</code>打印原始事件名称时，我们会得到一条错误消息，明确指出<code class="fe nl nm nn nc b">Value borrowed after move.</code>，所有这些检查都发生在编译期间。所以，我们保证在程序运行时，没有指向无效内存位置的引用。</p><p id="1340" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们看看第三条规则。</p><h1 id="9956" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">超出范围的变量会被自动删除</h1><p id="ccd3" class="pw-post-body-paragraph ky kz it la b lb mv ju ld le mw jx lg lh mx lj lk ll my ln lo lp mz lr ls lt im bi translated">当一个变量超出范围时，rust会立即丢弃该变量并清理它。当我们谈到Rust没有垃圾收集器时，这就是没有垃圾收集器的情况。</p><p id="0877" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，只有当变量在作用域内时，才能使用变量并引用它的内存位置。让我们举个例子来理解这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="e0bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们先来理解一个‘作用域块’。(如果您来自另一种编程语言，上面的代码可能会有点不同)。</p><p id="1741" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作用域是由左大括号和右大括号表示的块。<code class="fe nl nm nn nc b">{}</code>。它可以嵌套在一个函数中，也可以是一个完全有自己作用域的新函数调用。在上面的例子中，我们在内部作用域中创建了一个事件。</p><p id="39cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第三条规则规定，一旦内部作用域结束，变量<code class="fe nl nm nn nc b">new_event</code>及其数据将立即被删除。</p><p id="d71a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">根据这个逻辑和我们第二个规则的例子，我们会猜测编译器在这种情况下会报错。这次我们是对的。下面是这个程序编译时出现的错误。</p><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="3587" class="ng me it nc b gy nh ni l nj nk">error[E0425]: cannot find value `new_event` in this scope<br/>  --&gt; analytix/core/src/models.rs:49:71<br/>   |<br/>49 |         println!("Original event name is {} . New Event Name is {}" , new_event.name , new_event_copy_ref.name)<br/>   |                                                                       ^^^^^^^^^ not found in this scope</span></pre><p id="b4a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不出所料，在作用域中没有找到这个变量。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="39db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这三条规则是Rust所有权系统的基础，也是理解共享状态、并发和内存管理等更复杂场景的良好起点。</p><p id="598b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">内存管理的复杂性留给了语言，我们作为开发人员遵循这些规则来编写干净、高效的代码(这在开始时并不容易，但会越来越好)。</p><p id="b817" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过遵循这些规则，rust不仅保证了开发人员的内存安全，还使他们成为更好的程序员。除此之外，它还使程序的性能提高到接近C++的水平，而没有复杂的内存管理。</p><p id="6c27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我使用Rust的几个月里，我在处理这些规则时遇到了很多障碍。最终，我找到了一种真正考虑简化内存模型和代码的方法(尽管我还有很长的路要走。)我还是会说我是个生锈的新手。但是我很喜欢！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nb nc nd ne aw nf bi"><span id="24d3" class="ng me it nc b gy nh ni l nj nk"><strong class="nc iu">Want to Connect?</strong></span><span id="fe45" class="ng me it nc b gy no ni l nj nk">Originally published at <a class="ae np" href="https://shanmukhsista.com/understanding-rust-ownership-model-by-example/" rel="noopener ugc nofollow" target="_blank">https://shanmukhsista.com</a></span></pre></div></div>    
</body>
</html>