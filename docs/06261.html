<html>
<head>
<title>Improve Your Node.js Performance With Promise Pools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用承诺池提高Node.js性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improve-your-node-js-performance-with-promise-pools-65615bee2adb?source=collection_archive---------2-----------------------#2020-09-15">https://betterprogramming.pub/improve-your-node-js-performance-with-promise-pools-65615bee2adb?source=collection_archive---------2-----------------------#2020-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="91f0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">停止使用Promise.all()</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dfbd7e184c83564fa177b1007a8873da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFON-YgJCak5CN2ooi13-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者通过<a class="ae ky" href="http://carbon.now.sh" rel="noopener ugc nofollow" target="_blank">碳</a>拍照。</p></figure><p id="68b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">先决条件:要理解这篇文章，你需要了解</em> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> <em class="lv">承诺</em> </a> <em class="lv">的基础知识。</em></p><p id="54a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>中，实现并发的典型方式是使用<code class="fe lw lx ly lz b">promise</code>方法之一——最常见的是<code class="fe lw lx ly lz b">Promise.all()</code>。</p><p id="467a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您想要查询一个带有用户列表ID列表的数据库，并且想要对返回的数据进行操作(例如，如果ID没有返回用户，则创建一个新用户)。</p><p id="2bef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种方法是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="271d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，注意每个<code class="fe lw lx ly lz b">findOrCreateUser</code>都被顺序调用。效率不是很高</p><p id="29e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过使用<code class="fe lw lx ly lz b">Promise.all()</code>来改进这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="88e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们不会等待每个<code class="fe lw lx ly lz b">findOrCreateUser</code>承诺转化为用户。相反，我们等待所有问题使用<code class="fe lw lx ly lz b">Promise.All()</code>解决。这具有允许它们并发运行的效果。</p><p id="918c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这里有一个问题:假设您想要控制并发性(例如，只允许四个承诺并发运行，以避免给数据库带来压力)。你会怎么做？</p><p id="4aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">Promise.all()</code>在这方面受到限制。</p><p id="8809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方法是使用承诺池。</p><p id="a9b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多promise pool库，但是<a class="ae ky" href="https://www.npmjs.com/package/@supercharge/promise-pool" rel="noopener ugc nofollow" target="_blank">@ super charge/promise-pool</a>提供了一个我喜欢的API。</p><p id="8829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是它的使用方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8faf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我已经指定了100的并发性，因此在任何给定的时间，最多只能解决承诺的数量。</p><p id="854d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们可以通过分别指定并发性1和<code class="fe lw lx ly lz b">idList.length</code>来模拟前面的例子。</p><p id="ae53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是否已经说服您从使用<code class="fe lw lx ly lz b">Promise.all</code>转向使用承诺池？如果没有，为什么？我很想知道你的意见。</p><p id="02f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>