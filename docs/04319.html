<html>
<head>
<title>Docker Best Practices and Anti-Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker最佳实践和反模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-best-practices-and-anti-patterns-e7cbccba4f19?source=collection_archive---------3-----------------------#2020-04-06">https://betterprogramming.pub/docker-best-practices-and-anti-patterns-e7cbccba4f19?source=collection_archive---------3-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7565" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何构建生产就绪容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fd96f2db4ce4f1f762f8d56dbf937f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vBPEQmji5XSKEMBq4I5GQA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@mattykwong1?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马修·邝</a>在<a class="ae ky" href="https://unsplash.com/s/photos/premier?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a7f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Docker的大部分时间，我们并没有关注它的内部工作方式。仅仅因为你启动了Docker容器并且你的应用程序正在运行，并不意味着你已经实现了一个好的解决方案。有时，由于时间限制，我们陷入了复制粘贴Docker图像的陷阱，而没有理解实现细节和它是如何构建的细微差别。</p><p id="efdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究Docker最佳实践和反模式。反模式是对一个重复出现的问题的常见反应——当我们实现无效且适得其反的解决方案时，会破坏我们的Docker堆栈。</p><p id="9cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们跳进去看看我们可能做错的一些事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9da6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">我们需要那些标签</h1><p id="5d99" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">标签是必须的，可以让你传达关于你的Docker图片的有用信息。将标签视为docker图像ID的别名。它们可以与Git标签相比较，后者指的是您历史中的一个特定提交，允许您在不同的时间点对Docker映像进行版本控制。忘记标记是一件小事，但也有一些缺点。也就是说，如果没有指定标签，默认图像将使用最新的标签。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="91e0" class="ne md it na b gy nf ng l nh ni">FROM your_image_name:latest</span></pre><p id="9fb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您经常这样做，您的图像可能实际上不是最新的，而可能引用的是旧版本。总是使用适当的标签并遵循版本化模式，比如<a class="ae ky" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>。这确保了Docker映像的用户可以保证兼容性，保持更新，并按预期使用正确的版本。</p><p id="d713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一件事你可能想避免。最新的默认标签是在Dockfile中使用<code class="fe nj nk nl na b">FROM python3:latest</code>从Docker注册表中获取最新的图像。乍一看，这似乎是一个好主意，但有一些意想不到的副作用——每次最新的拉可能会产生一个与前一次构建完全不同的Docker映像。试图解释是什么破坏了你的码头工人形象可能很难，因为从你的角度来看，你期望不变性。因此，有一个很好的例子来为一个图像使用一个特定的标签(例如:<code class="fe nj nk nl na b">python3:1.0.1</code>)。这将确保您的docker文件保持不变。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8074" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在同一个容器中运行多个服务</h1><p id="054b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">是的，无论如何，你可以做到这一点——很可能成功——但这是你可能不想走这条路的几个原因。当我们与码头服务公司合作时，单一责任是我们应该努力的目标。最佳实践是，组成您的应用程序的每个不同的服务都应该在它自己的容器中运行——无论如何，尝试将每个独立的功能打包到单独的独立容器映像中。</p><p id="e740" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">向一个Docker映像添加多个服务可能很诱人——但是也应该放弃将容器映像视为虚拟机的想法。在一个容器中包含多个服务会使应用程序难以水平扩展。Docker容器的一个核心概念是它们是瞬态的，并且是为分发而设计的，这是现代web应用程序的理想选择，在现代web应用程序中，瞬态特性简化了伸缩性和并发性。添加多个服务增加了管理这种分布的难度。</p><p id="5d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，单个容器上的多个服务增加了管理安全性的难度。膨胀的图像大小可能会降低CI/CD的速度，如果您担心这一点的话。Docker <a class="ae ky" href="https://docs.docker.com/config/containers/multi-service_container/" rel="noopener ugc nofollow" target="_blank">文档在进一步阐述这一点上做了很好的工作。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e3d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用<code class="fe nj nk nl na b">LABEL to Catalog your Images</code></h1><p id="64dc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这绝不是反模式，但我认为它值得一提。我在处理各种Docker图像时注意到的一件事是，有时这些图像的创建者没有<code class="fe nj nk nl na b">LABEL maintainer</code>标签。这个标签在事件中设置图像的<code class="fe nj nk nl na b">Author</code>字段——当事情出错或你需要澄清时，如果图像被公开共享，就更容易知道联系内部或外部的谁。</p><p id="adc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这绝不是你唯一可以用的标签。您可以根据需要定义各种标签，以对图像进行分类、记录许可信息或对自动化有用的标签。</p><p id="34a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除<code class="fe nj nk nl na b">maintainer</code>以外的多行标签:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2aa6" class="ne md it na b gy nf ng l nh ni"># Set one or more individual labels<br/>LABEL com.example.version="0.0.1-beta"<br/>LABEL vendor1="RBTSB Incorporated"<br/>LABEL vendor2=TIPTAPCODE\ Incorporated<br/>LABEL com.example.release-date="202-04-02"<br/>LABEL com.example.version.production="0.0.1"</span></pre><p id="a1d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker 1.10之前的单行标签会创建新的Docker层，因此如果您使用最新的Docker版本，您不必担心开销层。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4f3b" class="ne md it na b gy nf ng l nh ni">LABEL vendor=ACME\ Incorporated \<br/>      com.example.is-beta= \<br/>      com.example.is-production="" \<br/>      com.example.version="0.0.1-beta" \<br/>      com.example.release-date="2015-02-12"</span></pre><p id="9874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了可追溯性、可见性和可维护性，向不可变的Docker图像中添加尽可能多的元数据总是一个好的做法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b2f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">避免构建特定于环境的图像</h1><p id="a255" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们构建Docker图像时，我们应该始终牢记不变性。不要使用标记为开发、测试、试运行和生产的不同映像，这是一个很好的实践，因为这违反了单一真实来源的原则。另一个问题是，在不同的环境中执行验证或调试时，无法保证映像在本质上是相似的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5c9b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么使用非根容器？</h1><p id="57d8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">默认情况下，Docker容器作为<code class="fe nj nk nl na b">root</code>运行。以root用户身份运行的Docker容器可以完全控制主机系统。出于安全考虑，这是不希望的。使用非根运行的Docker容器映像增加了一层额外的安全性，通常推荐用于生产环境。然而，因为它们作为非根用户运行，特权任务通常是禁止的。如果需要利用<code class="fe nj nk nl na b">USER</code>指令来指定非root用户，您需要进行一些上下文切换，如下例所示。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4a6e" class="ne md it na b gy nf ng l nh ni">FROM python:3.6-slim-buster<br/>LABEL maintainer="Timothy Mugayi &lt;timothy.mugayi@gmail.com&gt;"</span><span id="0d6b" class="ne md it na b gy nm ng l nh ni">RUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \<br/>    wget &amp;&amp; rm -rf /var/lib/apt/lists/*</span><span id="bb19" class="ne md it na b gy nm ng l nh ni"># Dumb init<br/>RUN wget -O /usr/local/bin/dumb-init <a class="ae ky" href="https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64" rel="noopener ugc nofollow" target="_blank">https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64</a><br/>RUN chmod +x /usr/local/bin/dumb-init</span><span id="5315" class="ne md it na b gy nm ng l nh ni">RUN pip install --upgrade pip</span><span id="d2bb" class="ne md it na b gy nm ng l nh ni">WORKDIR /usr/src/app</span><span id="05ff" class="ne md it na b gy nm ng l nh ni">COPY requirements.txt .</span><span id="d114" class="ne md it na b gy nm ng l nh ni">RUN pip install -r requirements.txt</span><span id="8d9c" class="ne md it na b gy nm ng l nh ni">COPY helloworld.py .</span><span id="812e" class="ne md it na b gy nm ng l nh ni">USER 1001</span><span id="19b5" class="ne md it na b gy nm ng l nh ni">ENTRYPOINT ["/usr/local/bin/dumb-init", "python3", "-u", "./helloworld.py"]</span></pre><p id="d022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您使用的基本映像不是使用root生成的，并且您必须切换回来，您可以执行以下操作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="626a" class="ne md it na b gy nf ng l nh ni">FROM &lt;namespace&gt;/&lt;image&gt;:&lt;tag_version&gt;<br/>USER root</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="896f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要在一个容器中运行太多的进程</h1><p id="45da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">容器的美妙之处——也是容器相对于虚拟机的优势——在于为了组成一个完整的应用程序，很容易让多个容器相互交互。不需要在一个容器中运行完整的应用程序。相反，尽可能将您的应用程序分解成离散的服务，并将服务分布在多个容器中。这最大限度地提高了灵活性和可靠性。</p><p id="2859" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，在一个容器中安装和运行一个完整的Linux操作系统是可能的。但是你应该这样做吗？</p><p id="bcd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能不是个好主意。Docker图像是用层的概念构建的，所以你添加到图像中的东西越多，它就越臃肿。一个成熟的操作系统会使Docker的理想用例失效。理想情况下，只安装容器中必需的基本组件。</p><p id="e127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了充分利用容器，你希望每个容器都尽可能的精简。这最大限度地提高了性能，最小化了安全风险。因此，避免运行并非绝对必要的服务。例如，除非在容器内部运行SSH服务是绝对必要的，否则不要包含SSH服务，因为有其他方法可以登录到容器，比如Docker exec调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7097" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要在容器中运行不必要的服务</h1><p id="cb5d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用Docker时，有一种趋势是用sonar之类的工具来扩大我们的图像，以覆盖代码。</p><p id="5c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用构建器模式<a class="ae ky" href="https://docs.docker.com/engine/userguide/eng-image/multistage-build/" rel="noopener ugc nofollow" target="_blank"> Docker多阶段构建</a>——从Docker CE 17.05+开始，您现在能够在一个Docker文件中拥有多个<code class="fe nj nk nl na b">FROM</code>阶段。短暂的构建器阶段容器将被丢弃，因此最终的运行时容器映像将是精简的。一个实际的用例是，当你需要从源文件编译一些二进制文件，然后在第二个数据上，将这些精简的二进制文件复制到你的最终映像。</p><h2 id="2624" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><strong class="ak">衍生利益</strong></h2><ul class=""><li id="2224" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu od oe of og bi translated">构建速度更快，也就是说，您的CI/CD流程可以通过更精简的映像进行改进，并且通过网络传输所需的时间也更少。</li><li id="859d" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">需要更少的存储空间。</li><li id="fc4a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">冷启动(镜像拉动)更快。</li><li id="1d6f" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">潜在的攻击面更小。</li></ul><h2 id="f346" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><strong class="ak">弊端</strong></h2><ul class=""><li id="a85b" class="ny nz it lb b lc mu lf mv li oa lm ob lq oc lu od oe of og bi translated">容器内的工具更少，但保持容器精简的代价很小。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5b10" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在容器中包含Oberservablity工具</h1><p id="a74e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以在没有监控解决方案的情况下运行容器，但是您需要记住的是，您很难知道容器内部发生了什么——尤其是随着容器数量的增加。</p><p id="a5aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker开箱即用，通过Docker的远程API的/stats端点，展示了每个运行容器的CPU、内存、网络和I/O使用情况的非常详细的指标。举两个例子，App dynamics和Newrelic都有现成的代理，可以与您的Docker映像预先打包在一起，为您提供更多的可见性，包括应用程序级的可见性，以了解您的应用程序和容器的执行情况。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5840" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">爱恨随意的贱像</h1><blockquote class="om"><p id="8e88" class="on oo it bd op oq or os ot ou ov lu dk translated">“说真的，你知道是谁建立了这个图像，它被添加了什么吗？”</p></blockquote><p id="d09e" class="pw-post-body-paragraph kz la it lb b lc ow ju le lf ox jx lh li oy lk ll lm oz lo lp lq pa ls lt lu im bi translated">这都是关于可追溯性的。牢记安全性是所有软件开发人员都应该努力去做的事情。了解如何追踪Docker图像的来源并理解其内容。]</p><p id="c74e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几件事你需要记住:</p><ul class=""><li id="4939" class="ny nz it lb b lc ld lf lg li pb lm pc lq pd lu od oe of og bi translated">图像是如何创建的。</li><li id="783d" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">验证它在创建后没有被更改。</li><li id="167e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">验证图像的内容。</li><li id="2640" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">扫描安全漏洞。</li></ul><p id="b718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些工具可以对容器进行静态分析。它们非常全面，远远超出了本文的范围，但是我建议您花一些时间来了解它们是如何工作的。</p><p id="0657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/coreos/clair" rel="noopener ugc nofollow" target="_blank"> Clair </a>是一个有趣的工具，它为你的Docker应用程序提供自动的容器漏洞和安全扫描。扫描基于通用漏洞和暴露(CVE)数据库。如果你在本地运行Docker，你可以下载Postgres并链接Clair到它。下面是启动并运行该系统所需的最低配置:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a4b6" class="ne md it na b gy nf ng l nh ni">$ mkdir $PWD/clair_config</span><span id="6e75" class="ne md it na b gy nm ng l nh ni">$ curl -L <a class="ae ky" href="https://raw.githubusercontent.com/coreos/clair/master/config.yaml.sample" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/coreos/clair/master/config.yaml.sample</a> -o $PWD/clair_config/config.yaml</span><span id="cdbe" class="ne md it na b gy nm ng l nh ni">$ docker run -d -e POSTGRES_PASSWORD="" -p 5432:5432 postgres:9.6</span><span id="8291" class="ne md it na b gy nm ng l nh ni">$ docker run --net=host -d -p 6060-6061:6060-6061 -v PWD/clair_config:/config quay.io/coreos/clair:latest -config=/config/config.yaml</span></pre><p id="9452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您希望更改Postgres的端口，请确保您也更改了<code class="fe nj nk nl na b">config.yaml</code>文件。如果您的系统上已经运行了另一个<code class="fe nj nk nl na b">Postgres</code>，注意不要将docker端口改为5432以外的端口。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="48b7" class="ne md it na b gy nf ng l nh ni">clair:<br/>  database:<br/>    <em class="pe"># Database driver<br/>    </em>type: pgsql<br/>    options:<br/>      <em class="pe"># PostgreSQL Connection string<br/>      # </em><a class="ae ky" href="https://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING" rel="noopener ugc nofollow" target="_blank"><em class="pe">https://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-CONNSTRING</em></a><em class="pe"><br/>      </em>source: host=localhost port=5432 user=postgres password=123456 sslmode=disable statement_timeout=60000</span></pre><p id="0587" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您的映像启动并运行，您就可以运行Docker ps来确保您的容器启动并运行</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/6a0885021158b8817ce039c29ccc5e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nY88oT5rjCrMEe5DELix6Q.png"/></div></div></figure><p id="12f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经了解了这一点，您需要知道Clair没有web UI或CLI——使用它的唯一方法是通过它的REST API或第三方CLI工具。为了让你上路，在这里查看更多细节<a class="ae ky" href="https://www.nearform.com/blog/static-analysis-of-docker-image-vulnerabilities-with-clair/" rel="noopener ugc nofollow" target="_blank"/>——如何使用Clair超出了本文的范围。</p><p id="1bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bayan <a class="ae ky" href="https://github.com/banyanops/collector" rel="noopener ugc nofollow" target="_blank"> Collector </a>是一个轻量级应用程序，它允许您通过从注册表启动容器来执行<a class="ae ky" href="https://searchwindevelopment.techtarget.com/definition/static-analysis" rel="noopener ugc nofollow" target="_blank">静态分析</a>，运行任意脚本并收集有用的信息(例如，安装的包)，执行策略，验证映像中的不变量。更多细节请参见GitHub资源库。</p><p id="02b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/docker/docker-bench-security" rel="noopener ugc nofollow" target="_blank"> Docker Bench for Security </a>是Docker团队开发的一款工具，它可以在Docker主机上运行一份安全最佳实践清单，并标记它发现的任何问题。更多细节请参见GitHub资源库。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2fda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要在容器映像中存储敏感数据</h1><p id="2906" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是你想要避免的错误。如果您的Docker图像被公开共享，或者如果开发人员无意中将图像推送到公共Docker注册表，这可能会导致私人和敏感信息泄露给外界。你不应该在docker文件中对敏感信息使用<code class="fe nj nk nl na b">COPY</code>或<code class="fe nj nk nl na b">`</code>。</p><p id="39d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，请将敏感数据存储在容器可以连接的安全文件系统中。在大多数情况下，该文件系统将存在于容器主机上，或者通过块存储(如<a class="ae ky" href="https://cloudacademy.com/course/aws-storage-fundamentals-2016/amazon-elastic-block-store-ebs-1/" rel="noopener ugc nofollow" target="_blank"> AWS弹性块存储(EBS) </a>)或对象存储服务(如S3)可用。</p><p id="cb19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您应该避免在Docker映像中存储安全凭证。作为开发人员，我们有时倾向于走捷径，硬编码密码和密钥。养成在运行时使用e-arguments为Docker容器指定环境变量的习惯。</p><p id="54f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用<code class="fe nj nk nl na b">on — env-file</code>，它也可以用来从文件中读取环境变量。通过<code class="fe nj nk nl na b">CMD</code>或`从第三方来源获取凭证的定制脚本也可以用于获取docker容器所需的相关凭证。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="63e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要在容器中存储数据或日志</h1><p id="93fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">集装箱化改变了伐木的性质。容器是本质上短暂的无状态应用程序的理想选择，也就是短暂的。任何可能存储在运行中的容器中的数据本质上都是短暂的——正如您可能已经注意到的，当容器关闭时，您的数据就会丢失。因此将数据存储在Docker容器之外是有意义的。有一些工具可以帮助您提取Docker日志，并将其放入更永久的数据存储中。</p><p id="0b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论如何用Docker处理日志记录时要记住:一个Docker安装至少有三个不同的日志记录级别；即Docker容器、Docker服务和主机操作系统；您选择的日志记录方法应该能够提取所有层的日志。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2fcd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要写入容器的文件系统</h1><p id="d172" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每次你写东西到容器的文件系统，它激活<a class="ae ky" href="https://docs.docker.com/engine/userguide/storagedriver/imagesandcontainers/#container-and-layers" rel="noopener ugc nofollow" target="_blank">写时拷贝策略</a>。使用存储驱动程序(devicemapper、overlayfs或其他)创建新的存储层。在主动使用时，它会给存储驱动程序带来大量负载，尤其是在Devicemapper或BTRFS的情况下。</p><p id="381b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保您的容器只向卷写入数据。您可以对小的临时文件使用<code class="fe nj nk nl na b">tmpfs</code>—<code class="fe nj nk nl na b">tmpfs</code>是驻留在内存和/或交换分区中的临时文件系统。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4e08" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">不要运行PID 1</h1><p id="847b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个大多数人可能都不知道的普遍问题。</p><p id="6da3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker不在一个特殊的<a class="ae ky" href="http://en.wikipedia.org/wiki/Zombie_process" rel="noopener ugc nofollow" target="_blank"> init进程下运行进程，该进程正确地获取子进程</a>，所以容器可能以僵尸进程结束，这可能导致意想不到的问题出现。</p><h2 id="1264" class="ne md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">使用tini或哑初始化</h2><p id="142a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">PID 1在UNIX中很特殊，因此省略init系统通常会导致进程和信号的错误处理。这可能会导致一些问题，例如无法正常停止的容器，或者泄漏本应销毁的容器。</p><p id="aa1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">僵死进程是指已经停止运行但其进程表条目仍然存在的进程，因为父进程没有通过wait syscall检索它。从技术上讲，每个终止的进程在很短的时间内都是僵尸，但它们可以存活更长时间。</p><p id="014d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/krallin/tini" rel="noopener ugc nofollow" target="_blank"> Tini </a>或者<a class="ae ky" href="https://github.com/Yelp/dumb-init" rel="noopener ugc nofollow" target="_blank"> dumb-init </a>可以用在你有一个产生新进程的进程，但是没有实现好的信号处理程序来捕捉子信号并且在你的进程应该停止的时候停止你的子进程。例如，Bash脚本不能正确地处理和发出信号。</p><p id="b4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个如何运行哑init的示例，其中<code class="fe nj nk nl na b">prepare.sh</code>是一个shell脚本或命令来执行您的应用程序`:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="39c4" class="ne md it na b gy nf ng l nh ni">RUN wget -O /usr/local/bin/dumb-init <a class="ae ky" href="https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64" rel="noopener ugc nofollow" target="_blank">https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64</a></span><span id="eb20" class="ne md it na b gy nm ng l nh ni">RUN chmod +x /usr/local/bin/dumb-init</span><span id="9911" class="ne md it na b gy nm ng l nh ni">ENTRYPOINT ["/usr/local/bin/dumb-init", "/usr/bin/prepare.sh"]</span></pre><p id="e315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，如果您选择<code class="fe nj nk nl na b">tini</code>，下面是一个示例，说明如果您正在使用Python anaconda conda，如何设置它:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8ed3" class="ne md it na b gy nf ng l nh ni">RUN conda install --yes -c conda-forge tini</span><span id="a3ca" class="ne md it na b gy nm ng l nh ni">ENTRYPOINT<strong class="na iu"> </strong>["tini", "-g", "--", "/usr/bin/prepare.sh"]</span></pre><p id="a974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这里有一个不依赖于任何编程语言的更通用的方法:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="69d5" class="ne md it na b gy nf ng l nh ni">FROM node:13.12.0-slim<br/><br/>MAINTAINER Timothy Mugayi &lt;timothy.mugayi@gmail.com&gt;<br/><br/>ENV TINI_VERSION='v0.13.0'<br/><br/># Add tini init, see https://github.com/krallin/tini<br/>ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini<br/><br/>RUN chmod +x /tini<br/><br/># Set tini as entrypoint<br/>ENTRYPOINT ["/tini", "--"]</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a99c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将DockerFile林挺应用到您的配置项/CD中</h1><p id="d79e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">显然Docker也有短绒——就像你的编程语言一样。</p><p id="d09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用linters有很多好处，因为口头上实施最佳实践是困难的。将林挺应用到您的CI/CD可以帮助您的团队避免常见错误，并在构建生产Docker映像时建立最佳实践。一个很好的起点是利用<a class="ae ky" href="https://github.com/hadolint/hadolint" rel="noopener ugc nofollow" target="_blank"> hadolint </a>，这是一个Haskell Dockerfile Linter，它将您的docker文件解析成一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank"> AST </a>，并在AST之上执行规则。</p><p id="64c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。要使用Docker执行林挺，您可以执行以下操作:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="b1f5" class="ne md it na b gy nf ng l nh ni">$ docker run --rm -i hadolint/hadolint &lt; Dockerfile</span></pre><p id="170c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lint完成后，将显示以下结果，这些结果可能会因docker文件的性质而异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/183b7d761f223471bfed7d3703bf83cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajVYzflKLKgtlct8gNKOFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">hadolint lint结果</p></figure><p id="0ad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面说明的DL3008代码“在apt get install中锁定版本”基于hadolint代码描述声明。版本锁定强制构建检索特定的版本，而不管缓存中有什么。这种技术还可以减少由于所需包中的意外变化而导致的失败。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a9e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="f888" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经涵盖了很多—从安全性到简化您的Docker图像。</p><p id="1c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以做更多的事情来使您的Docker图像更好、更安全。希望这篇文章能让你对应该做或不应该做的事情有所了解，以及可以开始应用于内部或外部docker容器和图像的可能解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="c76b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读，如果您有任何其他建议，请在下面留下您的评论。如果你认为这些内容对下一个开发者有用，请分享。</p><p id="f9b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保持安全，快乐码头形象建设！</p></div></div>    
</body>
</html>