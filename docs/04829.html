<html>
<head>
<title>Enable Mutual TLS Authentication Between Your Kubernetes Workloads Using Istio</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Istio在您的Kubernetes工作负载之间启用相互TLS认证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/enable-mutual-tls-authentication-between-your-kubernetes-workloads-using-istio-65338c8adf82?source=collection_archive---------4-----------------------#2020-05-13">https://betterprogramming.pub/enable-mutual-tls-authentication-between-your-kubernetes-workloads-using-istio-65338c8adf82?source=collection_archive---------4-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="844a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Kubernetes上您的微服务之间的Istio认证和相互TLS指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0b96b2e79aaf31b6880adb68b33214e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_4OezvkEa-wVB20bvpjaA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">蓝菊·福托雷菲在<a class="ae ky" href="https://unsplash.com/s/photos/future?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在软件工程中，访问控制通常由两部分组成，认证和授权。认证是指了解请求者是否如其所声称的那样，而授权是指指定请求者被允许执行什么动作。</p><p id="c468" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是“<a class="ae ky" href="https://medium.com/better-programming/how-to-harden-your-microservices-on-kubernetes-using-istio-29c23dd90670" rel="noopener">如何使用Istio </a>在Kubernetes上强化您的微服务”的后续文章。今天，我们来讨论如何使用Istio在您的Kubernetes微服务之间启用相互TLS认证。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1937" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">先决条件</h1><p id="a06e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本文假设您了解Kubernetes和微服务，并且知道<a class="ae ky" href="https://istio.io" rel="noopener ugc nofollow" target="_blank"> Istio </a>。对于Istio的介绍，我建议您查看<a class="ae ky" href="https://medium.com/better-programming/how-to-manage-microservices-on-kubernetes-with-istio-c25e97a60a59" rel="noopener">如何使用Istio </a>管理Kubernetes上的微服务。关于Istio安全的快速介绍，请阅读<a class="ae ky" href="https://medium.com/better-programming/how-to-harden-your-microservices-on-kubernetes-using-istio-29c23dd90670" rel="noopener">如何使用Istio </a>在Kubernetes上强化您的微服务。</p><p id="5ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保您有一个正在运行的Kubernetes集群，以便进行实际操作演示。我在<a class="ae ky" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">谷歌Kubernetes引擎</a>上做了下图，但它在任何其他Kubernetes集群上的工作方式都是一样的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c051" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">默认情况下相互身份验证</h1><p id="b5a7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">缺省情况下，Istio支持注入了侧车的工作负载之间的TLS通信。这允许微服务之间的端到端加密，以防止中间人攻击。</p><p id="45ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是默认设置，并且可能适用于大多数情况，但它是在兼容模式下运行的。这意味着注入了侧车的两个服务之间的流量将发送加密流量，但没有插入侧车的工作负载可以通过明文HTTP与后端微服务进行交互。</p><p id="b529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着刚刚引入Istio的团队不必努力让所有源流量都启用TLS。</p><p id="c98d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过下面的实践演示来理解这种行为。</p><p id="ab5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按照Kubernetes上的Istio入门指南<a class="ae ky" href="https://medium.com/better-programming/getting-started-with-istio-on-kubernetes-e582800121ea" rel="noopener">在您的Kubernetes集群中安装Istio。对于此演示，您不需要安装图书信息应用程序。</a></p><p id="f369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建三个名称空间，<code class="fe mz na nb nc b">foo</code>、<code class="fe mz na nb nc b">bar</code>和<code class="fe mz na nb nc b">legacy</code>，在<code class="fe mz na nb nc b">foo</code>和<code class="fe mz na nb nc b">bar</code>名称空间上启用自动侧车注入。不要标记<code class="fe mz na nb nc b">legacy</code>名称空间，因为我们想要模拟来自不包含边车的工作负载的流量。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ded1" class="nh md it nc b gy ni nj l nk nl">$ kubectl create ns foo<br/>namespace/foo created<br/>$ kubectl create ns bar<br/>namespace/bar created<br/>$ kubectl create ns legacy<br/>namespace/legacy created<br/>$ kubectl label namespace foo istio-injection=enabled<br/>namespace/foo labeled<br/>$ kubectl label namespace bar istio-injection=enabled<br/>namespace/bar labeled</span></pre><p id="38df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们在所有三个名称空间上创建两个应用程序，<code class="fe mz na nb nc b">httpbin</code>和<code class="fe mz na nb nc b">sleep</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7e6f" class="nh md it nc b gy ni nj l nk nl">$ kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/istio/istio/release-1.5/samples/httpbin/httpbin.yaml" rel="noopener ugc nofollow" target="_blank">samples/httpbin/httpbin.yaml</a> -n foo<br/>$ kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/istio/istio/release-1.5/samples/sleep/sleep.yaml" rel="noopener ugc nofollow" target="_blank">samples/sleep/sleep.yaml</a> -n foo <br/>$ kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/istio/istio/release-1.5/samples/httpbin/httpbin.yaml" rel="noopener ugc nofollow" target="_blank">samples/httpbin/httpbin.yaml</a> -n bar<br/>$ kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/istio/istio/release-1.5/samples/sleep/sleep.yaml" rel="noopener ugc nofollow" target="_blank">samples/sleep/sleep.yaml</a> -n bar<br/>$ kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/istio/istio/release-1.5/samples/httpbin/httpbin.yaml" rel="noopener ugc nofollow" target="_blank">samples/httpbin/httpbin.yaml</a> -n legacy <br/>$ kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/istio/istio/release-1.5/samples/sleep/sleep.yaml" rel="noopener ugc nofollow" target="_blank">samples/sleep/sleep.yaml</a> -n legacy</span></pre><p id="0aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在列出所有三个名称空间的pod，看看我们得到了什么。</p><p id="85a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说<code class="fe mz na nb nc b">foo</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="dc78" class="nh md it nc b gy ni nj l nk nl">$ kubectl get pod -n foo<br/>NAME                       READY   STATUS    RESTARTS   AGE<br/>httpbin-654c6cbbb9-76dgp   2/2     Running   0          96s<br/>sleep-6bdb595bcb-vwh29     2/2     Running   0          86s</span></pre><p id="4ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那<code class="fe mz na nb nc b">bar</code>呢:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="287a" class="nh md it nc b gy ni nj l nk nl">$ kubectl get pod -n bar<br/>NAME                       READY   STATUS    RESTARTS   AGE<br/>httpbin-654c6cbbb9-rvxgv   2/2     Running   0          102s<br/>sleep-6bdb595bcb-rhf7g     2/2     Running   0          91s</span></pre><p id="a6b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe mz na nb nc b">legacy</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c9cb" class="nh md it nc b gy ni nj l nk nl">$ kubectl get pod -n legacy<br/>NAME                       READY   STATUS    RESTARTS   AGE<br/>httpbin-654c6cbbb9-xsmd9   1/1     Running   0          90s<br/>sleep-6bdb595bcb-t9bkx     1/1     Running   0          83s</span></pre><p id="aa52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你看出区别了吗？因为我们没有在<code class="fe mz na nb nc b">legacy</code>名称空间上启用自动侧车注入，所以我们在pod中只有一个容器。<code class="fe mz na nb nc b">foo</code>和<code class="fe mz na nb nc b">bar</code>名称空间在pod中有两个容器，我们对它们进行了适当的标记，以支持Istio侧车注入。</p><p id="35ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们生成从<code class="fe mz na nb nc b">sleep</code>微服务到<code class="fe mz na nb nc b">httpbin</code>微服务、从所有三个名称空间到所有三个名称空间的流量，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/05b31b06807c92c50ea6637572a6e038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q7rpRUNxIrhiBZGGDvDfWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">默认情况下相互授权</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fe61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看结果，您会看到所有请求都得到HTTP 200响应。Istio足够智能，能够理解它正在与谁交互，并根据目标选择发送TLS流量或明文流量。如果Istio使用相互TLS认证，它会向后端发送一个<code class="fe mz na nb nc b">X-Forwarded-Client-Cert</code> <em class="np"> </em>报头，这是一种<em class="np"/><em class="np"/>了解流量是否加密的极好方法。</p><p id="8944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建从<code class="fe mz na nb nc b">sleep.foo</code>到<code class="fe mz na nb nc b">httpbin.foo</code>的流量。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4d54" class="nh md it nc b gy ni nj l nk nl">$ kubectl exec $(kubectl get pod -l app=sleep -n foo -o jsonpath={.items..metadata.name}) -c sleep -n foo -- curl <a class="ae ky" href="http://httpbin.foo:8000/headers" rel="noopener ugc nofollow" target="_blank">http://httpbin.foo:8000/headers</a> -s | grep X-Forwarded-Client-Cert</span><span id="8ab8" class="nh md it nc b gy nq nj l nk nl">"X-Forwarded-Client-Cert": "By=spiffe://cluster.local/ns/foo/sa/httpbin;Hash=05b619f1ebd6d8e4f59158bb614e8cac558a4228ec7bda28a80c9ad1a2594bf1;Subject=\"\";URI=spiffe://cluster.local/ns/foo/sa/sleep"</span></pre><p id="6af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于源和目标都有侧车，我们看到了头。Istio对流量进行加密，如<code class="fe mz na nb nc b">X-Forwarded-Client-Cert</code>报头所示。</p><p id="9302" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建从<code class="fe mz na nb nc b">sleep.foo</code>到<code class="fe mz na nb nc b">httpbin.legacy</code>的流量。在这种情况下，源包含边车，但目标不包含。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bfc8" class="nh md it nc b gy ni nj l nk nl">$ kubectl exec $(kubectl get pod -l app=sleep -n foo -o jsonpath={.items..metadata.name}) -c sleep -n foo -- curl <a class="ae ky" href="http://httpbin.legacy:8000/headers" rel="noopener ugc nofollow" target="_blank">http://httpbin.legacy:8000/headers</a> -s | grep X-Forwarded-Client-Cert</span></pre><p id="61d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们没有看到这样的标题。这意味着源和目的地之间的流量是明文。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c173" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">启用严格的相互TLS</h1><p id="cc3f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用默认设置运行Istio可以提供一定程度的保护，但这并不是Istio所能做到的全部。</p><p id="0d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Istio提供了许多其他功能，例如只允许所需的流量传播和控制访问，以便只有相关的微服务才能相互交互。</p><p id="0e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能希望启用严格的TLS来完全禁用服务网格中的不安全流量，以确保安全性至关重要。</p><p id="aa13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在全局级别、命名空间级别或工作负载级别启用严格的相互TLS。</p><p id="67a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在全局级别启用严格的相互TLS，请运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="154e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这是在具有<code class="fe mz na nb nc b">mtls</code>模式<code class="fe mz na nb nc b">STRICT</code>的<code class="fe mz na nb nc b">istio-system</code>名称空间上应用<code class="fe mz na nb nc b">PeerAuthentication</code>策略。这意味着Kubernetes集群中的所有名称空间只允许安全的TLS流量。</p><p id="9105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们运行同样的例子，看看我们得到了什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，Istio拒绝了来自<code class="fe mz na nb nc b">legacy</code>名称空间的所有请求，退出代码为56。这意味着TLS握手不成功，因为服务网格只期待TLS流量。</p><p id="0902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们在名称空间级别上启用相互TLS。但在此之前，我们需要通过运行以下命令来清理现有策略:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fdb1" class="nh md it nc b gy ni nj l nk nl">$ kubectl delete peerauthentication -n istio-system default<br/>peerauthentication.security.istio.io "default" deleted</span></pre><p id="af83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在命名空间级别启用严格的相互TLS，请运行以下命令:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="91fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它只对<code class="fe mz na nb nc b">foo</code>名称空间执行严格的TLS检查。让我们重新进行测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="181f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，只有从<code class="fe mz na nb nc b">sleep.legacy</code>到<code class="fe mz na nb nc b">httpbin.foo</code>的请求失败了，这是意料之中的。</p><p id="18f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还可以以类似的方式在工作负载级别上启用严格TLS。但是首先，让我们清理一下名称空间策略。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d33c" class="nh md it nc b gy ni nj l nk nl">$ kubectl delete peerauthentication -n foo default<br/>peerauthentication.security.istio.io "default" deleted</span></pre><p id="7854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建一个<code class="fe mz na nb nc b">PeerAuthentication</code>策略和一个<code class="fe mz na nb nc b">DestinationRule</code>策略，在工作负载级别上实施严格的TLS:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重新运行测试，看看会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，只有从<code class="fe mz na nb nc b">sleep.legacy</code>到<code class="fe mz na nb nc b">httpbin.bar</code>的流量出现故障。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3333" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="fea4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p><p id="13e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一部分“<a class="ae ky" href="https://medium.com/better-programming/enable-access-control-between-your-kubernetes-workloads-using-istio-cf72a9f9bd5e" rel="noopener">使用Istio </a>启用Kubernetes工作负载之间的访问控制”中，我们将通过实际操作演示深入探讨Istio授权，敬请期待！</p></div></div>    
</body>
</html>