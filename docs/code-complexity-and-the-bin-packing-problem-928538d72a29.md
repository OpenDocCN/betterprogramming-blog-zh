# 代码复杂性和装箱问题

> 原文：<https://betterprogramming.pub/code-complexity-and-the-bin-packing-problem-928538d72a29>

## 软件系统设计的心理工具

![](img/bbdd1af2456122ae426a849a5607bc40.png)

在火锅. ai 生成，授权本人使用。对于所有围绕人工智能创造艺术的炒作，这看起来不太像提示“连续十个箱子”，不是吗？

我们都知道宁滨问题是 NP——确切地说是 NP 难的。如果这个问题也描述了创建软件的一个潜在问题呢？我想探讨这样一个观点，即装箱是研究导致代码复杂性的一些问题的一个很好的模型。这将需要硬数学和软类比的混合(硬是指“明确”，而不是困难)。这很危险，我欢迎评论区的任何反对意见。

首先，从[geeksforgeeks.org](https://www.geeksforgeeks.org/bin-packing-problem-minimize-number-of-used-bins/)快速总结一下箱柜包装问题:

> 给定不同重量的`n`件物品和每个容量为`c`的箱子，将每件物品分配到一个箱子中，以使使用的箱子总数最少。可以假设所有物品的重量都小于箱柜容量。”

好的，我们有几个变量来进行类比。

1.  `W`:从`1…N`开始需要装箱的砝码组。以至于`∑ W = w₁+w₂ + … + wₙ`。
2.  `c`:每个仓的容量。

因此，让我们从假设创建我们的系统所需的最少代码量开始。这在问题中表现为`*∑ W*` *。*让我们称之为箱柜模块。这可以保持非常通用。一个模块可能是微服务架构中的一个服务，一个`Actor`(有点像微服务)，一个 OOP 系统中的一个类，或者可能是一个大类(一个集合了许多小类来完成一个大目标的类)。

随着任何模块的增长，其内部复杂性也在增长，因此我们希望限制其大小。这个模块大小的限制是我们的变量`c`，因为我们已经用 bin 标识了模块。

原则上，一个模块可以与任何其他模块通信。因此，这些潜在交互的复杂性是`O(n!)`。

这留下了组成模块的更小的代码片段。这些是我们的小`w`(`w₁`到`wₙ`)。所以现在我们有了下面的模型。

1.  一个程序是其所有模块的总和，在变得太大和复杂之前，这些模块的大小受到`c`的限制。
2.  模块的子组件增加了模块的复杂性。
3.  如果一个模块的复杂度大于`c`，它必须被分解成更小的模块。
4.  模块越多，模块之间潜在的交互就越多。以因子的方式增加架构的复杂性。

如果我们接受这些假设，我们就把代码复杂性的问题映射到装箱问题上了。我们必须得出结论，设计一个最优的简单软件系统是 NP 问题。

显而易见，软件设计是困难的。你怀疑这一点，但现在你有数学来支持你的怀疑。

![](img/0f1a70a5066e0ca91925a077e34f519d.png)

照片由 [GVZ 42](https://unsplash.com/@gvz42?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄|图片被裁剪

# 那又怎样？

我们可以用宁滨问题来描述软件设计的问题。然后呢。我们当然不能用宁滨算法来设计我们的软件，那么这是怎么回事呢？

再看看上面我们做的工作。我们将复杂度分为模块间复杂度和模块内复杂度。我们还表明，这两种类型的复杂性是相互矛盾的。

为了降低模块内部的复杂性，我们可以通过缩小模块来简化我们的模块(减少`c`)。然而，模块的数量随之增加。如果我们增加我们的模块大小(增加`c`，我们得到相反的效果。

透过这个镜头来看系统设计，我们可以根据它们平衡这两个约束的程度来评估我们的设计决策。虽然这并没有涵盖系统设计的所有考虑因素，但它是一个必不可少的组成部分。

![](img/82a4f18824367eb0c70e128ffde36f44.png)

Stephen Kraakmo 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

这个镜头也告诉我们，我们应该警惕像坚实的原则这样的东西。将五条规则机械地应用到我们的设计中，不太可能产生令人满意的复杂性平衡的最佳解决方案。这并不是说他们不能成为像样的向导，而是过滤你两耳之间的一切。

# 应用模型

为了简单起见，让我们把上面的一切都称为“模型”我们可以看看不同的软件开发实践，看看他们如何试图处理模块内和模块间复杂性之间的紧张关系。这将是探索模型的一个健康的最后练习。

## **独石和模型**

单一的程序通常让人想起设计糟糕的旧程序。这种刻板印象甚至可能是真的。如果在谈论软件变更时，人们会提到某个功能或类的名字，那么你的公司可能是一个庞然大物。

当我们从模型的角度来审视独石时，我们看到它们是降低某种复杂性的一种方法。单片电路以模块内的复杂性为代价来减少模块的数量。按照模型的变量来说，独石使得`c`的值非常大。原则上，如果`c > ∑ W`，只有一个模块，装箱问题消失。你不必担心模块之间是如何相互作用的，但是理解一个模块的内部工作方式几乎是不可能的。

你可能真的写了独石。我写的大多数内部实用程序都没有考虑软件架构，因为代码总量很小，复杂性无关紧要。

## 微服务和模型

微服务采取与 Monoliths 相反的策略。它们保持你的 c 值很小，以减少模块内部的复杂性，同时让模块的数量变得很大。这似乎是一场灾难。正如我们在模型描述中所述，模块通信的复杂性随着模块数量的增加而增加。微服务通常有限制这种损害的规则。例如:

> 微服务可以回答内部或外部的请求。
> 
> 回答内部请求的微服务可能不会向其他微服务发出请求。
> 
> 回答外部请求的微服务可能只向处理内部请求的微服务发出请求。

如果你能遵循这个约束，它确实限制了你的模块级复杂度。给定`N`模块，你有内部或外部类型的模块。如果我们称这两组为`i`和`e`，那么`N = i+e`。交互次数限制为`i` 乘以`e`。由于`i`和`e`必须小于`N`，那么你的模块级复杂度以`N²`而不是`N!`的速率增长。

![](img/44bb55eff983d1f3b45595cb6fe1a8fb.png)

照片由 [Yassine Khalfalli](https://unsplash.com/@yassine_khalfalli?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 结论

这篇文章是实验性地写的。我想尝试证明软件设计从根本上来说是很难使用离散数学的。你可以决定我是否成功。然而，我有信心，我已经证明了离散数学可以用来获得对软件设计和架构的洞察力。这是我希望将来再次探讨的话题。

如果你想听更多我对软件设计的想法，请看看我关于[遗产代码](https://medium.com/codex/legacy-code-2cb94a33dcd0)的一篇读得很少的文章。

再次感谢您的阅读。