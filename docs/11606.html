<html>
<head>
<title>Demystifying Error Handling in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Rust中错误处理的神秘面纱</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/error-handling-in-rust-that-every-beginner-should-know-9efa59deb934?source=collection_archive---------3-----------------------#2022-04-03">https://betterprogramming.pub/error-handling-in-rust-that-every-beginner-should-know-9efa59deb934?source=collection_archive---------3-----------------------#2022-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3a2e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么时候该慌，什么时候不该慌！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84d6e9c083c127faeb41b22fe6be3615.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*znWOLtt7uGy0M0it2Jd4SA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@brett_jordan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae kv" href="https://unsplash.com/s/photos/error?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c32d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Rust有一个非常有效的错误处理机制，不会影响可读性。你将学会什么时候去<code class="fe ls lt lu lv b">panic!</code>以及如何以一种实用和平易近人的方式处理<code class="fe ls lt lu lv b"> Result&lt;T, E&gt;</code>的事情。</p><p id="59b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大约4年前，我写了关于Go中的错误处理的文章，它很受欢迎。本文将遵循那篇文章的思路，那篇文章侧重于语言特性和API的实用方面。</p><p id="c19f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我之所以写这篇文章，是因为当时我能找到的所有书籍和其他资源似乎都没有回答我的很多问题。</p><p id="b331" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我经历了许多尝试和错误，最后，我得到了我的问题的答案。我把我学到的东西整理成这篇文章。希望它能帮助其他Rust初学者理解Rust编程中很小但非常重要的部分——错误处理。</p><h1 id="e0c9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">生锈是安全的</h1><p id="b589" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Rust不仅仅是一种语言。这是原则。众所周知，编译器通过借用、移动和生存期来保证对数据的安全访问。</p><p id="a9b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是有代价的，因为语言变得更难写，但同时，也更难失败。对安全的思考跨越了语言的边界，延伸到了API。</p><p id="1278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多Rust APIs(主观上)难以使用。API非常明确地指出了每一个可能出错的步骤，并且您还必须对每一步做出决定。</p><p id="3f92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我比较两种不同框架/语言的两个API，你就会明白我想说什么了。</p><p id="48a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我想从HTTP header中获取一个头的值，头的名称是“Authorization”。</p><h2 id="40f0" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated"><strong class="ak"> Actix Web / Rust </strong></h2><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="0f52" class="mt lx iq lv b gy nj nk l nl nm">request.headers().get("Authorization").<strong class="lv ir">unwrap</strong>().to_str().<strong class="lv ir">unwrap</strong>();</span></pre><h2 id="ef89" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated"><strong class="ak"> Gin Gonic / Go </strong></h2><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="e14a" class="mt lx iq lv b gy nj nk l nl nm">context.GetHeader("Authorization")</span></pre><p id="fce0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果头文件不存在，Rust API将会死机，而Go API将返回一个空字符串。此时，你可能会觉得围棋更直观。为什么任何一个头脑正常的人都想破坏程序，只是因为头不见了，对吗？你可能没有错。但是，您如何知道头值实际上是否是一个空字符串呢？如何判断该值是否只包含可见的ASCII字符？有人可以尝试通过代码欺骗你的头的解析器吗？你怎么能确定一个字符串是可读的呢？这些问题都可以用Actix Web API来回答。</p><p id="d8c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的是，当预期的头文件不存在时，您不必中断程序。我用“打破”而不是“崩溃”这个词，因为它不是崩溃。你永远不会从Rust得到一个分段错误。</p><h1 id="8ac6" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">慌！</h1><p id="006e" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">搞笑的是实际API也是<code class="fe ls lt lu lv b">panic!</code>(带感叹号！).感叹号表示它是一个宏。编译器会在编译时重写这部分代码。</p><p id="13c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该尽可能避免使用<code class="fe ls lt lu lv b">panic!</code>。它应该被视为致命错误。例如，一个必需的输入丢失了，没有它程序就不能正常运行。终止一个程序是有意义的，这是你唯一可以考虑使用<code class="fe ls lt lu lv b">panic!</code>的情况。</p><p id="b514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与Go不同，在Go中，死机可以很容易地恢复，在任何代码库中看到死机/恢复都是很常见的。铁锈就不是这样了。</p><p id="e9f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理Rust中非致命错误的惯用方法是使用<code class="fe ls lt lu lv b">Result&lt;T, E&gt;</code>。我们一会儿会讨论这个问题。</p><h2 id="0dbb" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">展开与预期</h2><p id="2445" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">如果你是Rust新手，你会在书籍、在线教程和其他地方看到许多使用<code class="fe ls lt lu lv b">unwrap</code>函数的代码示例，有时使用<code class="fe ls lt lu lv b">expect</code>函数从<code class="fe ls lt lu lv b">Option&lt;T&gt;</code>或<code class="fe ls lt lu lv b">Result&lt;T, E&gt;</code> <strong class="ky ir"> </strong>枚举中解开或提取所需的输出。这两个函数实际上是相同的，除了<code class="fe ls lt lu lv b">expect</code>函数允许您使用定制的错误消息，而不是使用默认的错误消息。</p><p id="1fec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当没有结果时，这两个函数都会死机。当恐慌发生时，程序将被终止，除非您在一个特殊的闭包中捕捉到它(我们一会儿也会谈到这一点)。所以，如果你不能绝对肯定它不会死机，那么调用这些函数是没有意义的。</p><p id="9e16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下面的代码片段所示，您可以看到<code class="fe ls lt lu lv b">unwrap</code>和<code class="fe ls lt lu lv b">expect</code>函数是如何工作的。实现简单得可笑。我只是从Rust标准库中复制了代码。对于<code class="fe ls lt lu lv b">Option</code>，<code class="fe ls lt lu lv b">unwrap</code>函数进行模式匹配，当结果为空时会出现混乱。在其他一些语言中，这将是一个异常，就像Scala、Kotlin和Java中的<code class="fe ls lt lu lv b">NoSuchElementException</code>一样，可以通过<code class="fe ls lt lu lv b">try..catch</code>块恢复。铁锈里没有<code class="fe ls lt lu lv b">try..catch</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="84a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你看看<code class="fe ls lt lu lv b">Result&lt;T, E&gt;</code>枚举的<code class="fe ls lt lu lv b">unwrap</code>函数，你会发现它和<code class="fe ls lt lu lv b">Option&lt;T&gt;</code>很相似，除了我们匹配的是<code class="fe ls lt lu lv b">Ok</code>和<code class="fe ls lt lu lv b">Err</code>类型，而不是<code class="fe ls lt lu lv b">Some</code>和<code class="fe ls lt lu lv b">None</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="47b7" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">从恐慌中恢复过来！攻击</h2><p id="1297" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">虽然您应该避免使用<code class="fe ls lt lu lv b">panic!</code>(除非您真的想这么做)，但您仍然可能不得不处理来自库或其他人代码的<code class="fe ls lt lu lv b">panic!</code>。</p><p id="1b95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，这是不可能改变的，因为这可能超出了你的控制。</p><p id="db62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何从<code class="fe ls lt lu lv b">panic!</code>中恢复以避免终止申请流程？<code class="fe ls lt lu lv b">catch_unwind</code>前来救援。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="aa1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">catch_unwind</code>将panic转换为<code class="fe ls lt lu lv b">Result&lt;T, E&gt;</code> enum。这里需要注意的是，您必须执行在<code class="fe ls lt lu lv b">catch_unwind</code>的闭包内可能会出错的代码。铁锈封闭是棘手的。它不允许您访问(共享)闭包之外的数据，除非您移动和/或克隆您的值。这是出于安全原因，编译器会为您保证这一点。</p><p id="5800" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不需要GC，也不需要免费跟踪(双关语)。虽然有可能从<code class="fe ls lt lu lv b">panic</code>中恢复，但建议首先不要使用它。</p><p id="73e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的是，恐慌箱中还有其他有用的功能。我不是故意提到他们的。如果你对有什么感兴趣，你可以在这里查看:<a class="ae kv" href="https://doc.rust-lang.org/std/panic/index.html" rel="noopener ugc nofollow" target="_blank">https://doc.rust-lang.org/std/panic/index.html</a></p><h1 id="b2fb" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结果<t e=""/></h1><p id="0279" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">这是这个故事的主角。<code class="fe ls lt lu lv b">Result</code>是一个有两个可能值的枚举。如果你熟悉Scala或者Haskell，你会有家的感觉。</p><p id="a1c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ls lt lu lv b">Result</code>枚举类似于一元类型——<code class="fe ls lt lu lv b">Try&lt;T&gt;</code>和<code class="fe ls lt lu lv b">Either&lt;L, R&gt;</code>。Rust是一种系统编程语言，它有一种语法糖，使代码看起来更干净。你没看错:)</p><p id="e2a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要以为接近汇编的语言总是让你日子不好过。这不是铁锈！唯一接近汇编的是编译后的二进制文件。Rust代码可以是优雅的，也可以是华而不实的。我将向您展示Go、Scala和Rust如何处理结果——就像下面的代码练习一样。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="ed2a" class="mt lx iq lv b gy nj nk l nl nm"><strong class="lv ir">enum</strong> Result&lt;T, E&gt; {<br/> Ok(T),<br/> Err(E),<br/>}</span></pre><h2 id="31c6" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">练习1</h2><p id="1e9b" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">实现半径为r的圆的方程，圆心在原点(0，0)。</p><p id="a679" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将用3种不同的语言实现这个练习:Go、Scala和Rust。我知道这是铁锈的文章。但是，我认为在不同的语言中看到不同的方法是有用的。请注意，未来事情可能会发生变化，因为语言正在发展，它们喜欢相互启发(复制)。</p><h2 id="ddeb" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">去的方式</h2><p id="67d2" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Go支持多个返回值，按照惯例，错误是两个返回值中的第二个值。如果你想了解更多，<a class="ae kv" href="https://hussachai.medium.com/error-handling-in-go-a-quick-opinionated-guide-9199dd7c7f76" rel="noopener">请阅读同一个人(我)写的这篇很棒的文章。</a></p><p id="e698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Go代码通常简单得可笑，这个也不例外。对于错误处理来说，总是重复和枯燥的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一种类固醇叫做Go+<a class="ae kv" href="https://github.com/goplus/gop" rel="noopener ugc nofollow" target="_blank">https://github.com/goplus/gop</a><br/>上面的错误处理可以使用与Rust相同的语法重写。</p><h2 id="86be" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">Scala方式</h2><p id="7341" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">Scala是一种函数式语言，我们都知道它有多优雅。我们将使用<code class="fe ls lt lu lv b">scala.util.Try&lt;T&gt;</code>封装一个可能出错的结果(如果这令人困惑，请阅读<a class="ae kv" href="https://docs.scala-lang.org/overviews/scala-book/functional-error-handling.html" rel="noopener ugc nofollow" target="_blank">这个简短而有趣的Scala书籍章节</a>，并将返回<code class="fe ls lt lu lv b">Try&lt;T&gt;</code>的2个函数链接在一起，形成<code class="fe ls lt lu lv b">x² + y² = r²</code>方程。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="dfca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">for-yield理解是flatMap/map的语法糖，可以重写如下。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="a85d" class="mt lx iq lv b gy nj nk l nl nm"><em class="np">square</em>(x).flatMap { x2 =&gt; <br/>  <em class="np">square</em>(y).map { y2 =&gt;<br/>    Math.<em class="np">sqrt</em>(x2 + y2)<br/>  }<br/>}</span></pre><p id="d6d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你做这样的事情时，你会觉得自己很聪明。它们连在一起的方式就像是用英国口音说话，尤其是当你用for..屈服。你放弃了先生的头衔。</p><h2 id="f278" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">生锈的方法</h2><p id="2049" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">您在这里看到的代码是本机运行的。没有垃圾收集。这些值存储在一个堆栈中。没有多余的脂肪。最重要的是，它看起来很棒，易于阅读。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="be28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">？函数调用的最后是模式匹配的语法糖，如下所示。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="ea1b" class="mt lx iq lv b gy nj nk l nl nm"><strong class="lv ir">let</strong> x2 = <strong class="lv ir">match</strong> square(x) {<br/>    <em class="np">Ok</em>(i) =&gt; i,<br/>    err =&gt; <strong class="lv ir">return</strong> err<br/>};<br/><strong class="lv ir">let</strong> y2 = <strong class="lv ir">match</strong> square(y) {<br/>    <em class="np">Ok</em>(i) =&gt; i,<br/>    err =&gt; <strong class="lv ir">return</strong> err<br/>};</span></pre><p id="7bb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以将所有可能失败的函数链接在一个扁平的结构中，这种结构像Go一样非常易读。语法糖使代码看起来像Scala一样整洁。除此之外，你还可以做一些很酷的事情，比如像Scala一样使用函子和单子。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="ab0b" class="mt lx iq lv b gy nj nk l nl nm">square(x).<strong class="lv ir">and_then</strong>(|x2| square(y).<strong class="lv ir">map</strong> (|y2| {<br/>    (x2 + y2).sqrt()<br/>}))</span></pre><p id="579b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">and_then</code>与<code class="fe ls lt lu lv b">flatMap</code> <strong class="ky ir">相同，</strong>与<code class="fe ls lt lu lv b">map</code> <strong class="ky ir"> </strong>是耶..<strong class="ky ir"> </strong> <code class="fe ls lt lu lv b">map</code> <strong class="ky ir">。</strong><code class="fe ls lt lu lv b">and_then</code>和<code class="fe ls lt lu lv b">map</code>功能都使用引擎盖下的图案匹配。因此，上述所有解决方案应该给你相同的性能特征。归结为个人喜好。</p><h1 id="1d08" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">是时候面对现实了</h1><p id="e177" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">大家都喜欢句法糖？它以安全的方式展开结果，并在<code class="fe ls lt lu lv b">Result&lt;T, E&gt;</code>为<code class="fe ls lt lu lv b">Err&lt;E&gt;</code>时立即返回调用。它简洁而强大。</p><p id="e0ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在你学会了这个新语法之后，你迫不及待地想在你的小项目中使用它(实际上我不了解你。我指的是我自己)。然后，我面对现实，虽然书中的代码示例看起来很不错，但在我的小项目中并不适用。我稍后会对此进行详细说明。在此之前，我们再做一个练习。</p><h2 id="8a7f" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">练习2</h2><p id="40a4" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">?</code>打开Actix-web处理器中的结果。</p><p id="7f93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个队列，在使用队列之前，我们必须从一个连接创建一个通道。如果您熟悉RabbitMQ或任何其他队列中间件，您会知道这是让队列系统在您的项目中工作的基本步骤。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="2979" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第13行和第14行，我们将API调用从<code class="fe ls lt lu lv b"><strong class="ky ir">unwrap</strong></code>改为<code class="fe ls lt lu lv b">?</code> <strong class="ky ir">。现在看起来更好了，因为当它无法创建连接或通道时，我们不想惊慌，因为这些资源可以自行恢复。这个变化看起来非常简单，我感觉真的很好，直到我编译…</strong></p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="0f77" class="mt lx iq lv b gy nj nk l nl nm"><strong class="lv ir">let</strong> connection = pool.get().<strong class="lv ir">await</strong>?;<br/>    | ^ the trait `ResponseError` is not implemented for `deadpool::managed::errors::PoolError&lt;deadpool_lapin::lapin::Error&gt;`<br/><strong class="lv ir">let</strong> channel = connection.create_channel().<strong class="lv ir">await</strong>?;<br/>    | ^ the trait `ResponseError` is not implemented for `deadpool_lapin::lapin::Error`</span></pre><p id="2d91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等一下！</p><p id="7c13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它在书中的例子中工作得很好。为什么它没有编译？</p><p id="9c00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你仔细看看错误信息，你就会明白为什么编译器会抱怨。从API返回的错误类型没有实现<code class="fe ls lt lu lv b">ResponseError</code>特征。任何库都不可能实现HTTP特有的特性，它是<code class="fe ls lt lu lv b">Actix-web</code>框架的一部分。</p><p id="0ebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，dead pool Lapin(rabbit MQ连接池)不希望也不应该对Actix-web有具体的依赖。</p><p id="8dc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">?</code>并不总是有效，因为预期的类型是特定于库的，而不是像<code class="fe ls lt lu lv b">std::error::Error</code>那样的通用类型。</p><p id="1d22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">顺便说一下，这是有道理的。<code class="fe ls lt lu lv b">actix-web</code> API不想为你承担HTTP错误代码和错误内容。你必须自己指定它，这就是为什么处理函数期望<code class="fe ls lt lu lv b">Result&lt;HttpResponse, Error&gt;</code> <strong class="ky ir"> </strong>的原因，其中<code class="fe ls lt lu lv b">Error</code>在<code class="fe ls lt lu lv b">actix-web</code>箱中定义如下。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="bb55" class="mt lx iq lv b gy nj nk l nl nm"><strong class="lv ir">pub</strong> <strong class="lv ir">struct</strong> Error {<br/>  cause: Box&lt;dyn ResponseError&gt;,<br/>}</span><span id="7055" class="mt lx iq lv b gy nq nk l nl nm"><strong class="lv ir">impl</strong>&lt;T: ResponseError + <em class="np">'static</em>&gt; From&lt;T&gt; for Error {<br/>  ...<br/>}</span></pre><h2 id="7454" class="mt lx iq bd ly mu mv dn mc mw mx dp mg lf my mz mi lj na nb mk ln nc nd mm ne bi translated">如何解决这个问题？</h2><p id="c216" class="pw-post-body-paragraph kw kx iq ky b kz mo jr lb lc mp ju le lf mq lh li lj mr ll lm ln ms lp lq lr ij bi translated">简易柠檬榨汁机。你必须将误差从一种类型映射到另一种类型。</p><p id="1a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当无法建立连接时，正确的HTTP错误代码可能是500(内部服务器错误)，我们可以提供解释错误原因的消息。</p><pre class="kg kh ki kj gt nf lv ng nh aw ni bi"><span id="c767" class="mt lx iq lv b gy nj nk l nl nm"><strong class="lv ir">let</strong> connection = pool.get().<strong class="lv ir">await</strong>.map_err(|e| {<br/>  error::ErrorInternalServerError("Failed to get a connection")<br/>})?;</span><span id="2dac" class="mt lx iq lv b gy nq nk l nl nm"><strong class="lv ir">let</strong> channel = connection.create_channel().<strong class="lv ir">await</strong>.map_err(|e| {<br/>  error::ErrorInternalServerError("Failed to create a channel")<br/>})?;</span></pre><p id="8080" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以使用<code class="fe ls lt lu lv b"><strong class="ky ir">?</strong></code>魔法了，而且果然有效。</p><p id="7928" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢你的阅读，乡巴佬！</p></div></div>    
</body>
</html>