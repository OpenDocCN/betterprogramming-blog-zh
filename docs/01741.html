<html>
<head>
<title>Under Observation — Variable Scoping and How It Affects Your Program</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">观察中——变量作用域及其对程序的影响</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/under-observation-variable-scoping-and-how-it-affects-your-program-9bcdf1b870f1?source=collection_archive---------11-----------------------#2019-10-09">https://betterprogramming.pub/under-observation-variable-scoping-and-how-it-affects-your-program-9bcdf1b870f1?source=collection_archive---------11-----------------------#2019-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a151" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们来看一看</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16273a9fefbd893b9c5f5f2dfeb2bc69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMMRrHM1TfqAV6MJ-GbeCA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">保罗·斯科鲁普斯卡斯在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="5361" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当有人开始编程时，向他们介绍的一个基本概念是名称解析，也就是<em class="lv">作用域</em>。范围非常重要，因为它们决定了变量/方法是否可见。此外，作用域有助于创建一个整洁的全局名称空间，因为您可以在子作用域中“隐藏”变量。</p><p id="6503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在学习了编程的基础知识之后，作用域仍然非常重要，因为它们对于了解更高级的概念<em class="lv">元编程</em>中发生的事情是必不可少的。尤其是在Ruby中，许多元编程工具通过改变代码执行的范围来工作。例如，方法<code class="fe lw lx ly lz b">class_eval</code>或<code class="fe lw lx ly lz b">instance_eval</code>将把范围弯曲到另一个对象/类。</p><p id="2f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解这个概念，让我们仔细看看作用域。存在什么类型的作用域，通常使用什么级别的作用域？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f51c" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">什么是范围？</h1><p id="0e13" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">定义是:作用域是程序的一部分。</p><p id="5831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来很模糊。所以还是说清楚一点吧。作用域是程序中变量可见和可访问的部分。变量可见的部分可以嵌套在不同的层次中——稍后会详细介绍。</p><p id="4894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在计算机科学中，有两种类型的作用域:词法的和动态的。类型取决于您使用的编程语言。</p><h2 id="3983" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">词法范围</h2><p id="5bff" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这是所有现代语言实现的类型，据我所知。词法范围意味着源代码的上下文就是范围。例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="2295" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有变量都是在当前方法的上下文中定义的。在块内部，我们从上一级方法中访问变量。但是当你阅读代码时，根据上下文,<code class="fe lw lx ly lz b">method_variable</code>的值是什么就很清楚了。</p><h2 id="c16c" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">动态范围界定</h2><p id="3641" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这种实现在许多语言中已经不再使用了。一些仍在使用并以这种方式实现作用域的是<a class="ae ky" href="https://www.perl.org/" rel="noopener ugc nofollow" target="_blank"> Perl </a>(仅当用户选择加入时)<a class="ae ky" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"> Bash </a>、<a class="ae ky" href="https://www.emacswiki.org/emacs/EmacsLisp" rel="noopener ugc nofollow" target="_blank"> Emacs Lisp </a>和<a class="ae ky" href="https://www.latex-project.org/" rel="noopener ugc nofollow" target="_blank"> LaTeX </a>。</p><p id="4fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，动态范围是如何工作的呢？名称解析取决于运行时。<strong class="lb iu"> </strong>我们来调整一下上面的例子，这样就能看出区别了。(记住，Ruby不使用动态范围，所以这是一个伪Ruby代码，不会在您的控制台上工作)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/choallin/800ed8a7d966b260b020e0e3c54eaab2" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/choall in/800 ed 8 a7d 966 b 260 b 020 E0 e 3c 54 eaab 2</a></p></figure><p id="8630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在动态范围语言中，运行库在当前块中查找变量，然后在上面的调用堆栈中查找变量。在我们的例子中，方法<code class="fe lw lx ly lz b">multiply_by_two</code>的变量<code class="fe lw lx ly lz b">multiplicand</code>和<code class="fe lw lx ly lz b">2</code>被初始化，方法<code class="fe lw lx ly lz b">multiply_by_three</code>和<code class="fe lw lx ly lz b">3</code>被初始化。<code class="fe lw lx ly lz b">test_method</code>的结果实际上取决于它所调用的方法。</p><p id="df8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个例子，缺点就很明显了。动态作用域消除了引用透明性的好处，因为它依赖于调用堆栈/运行时，并且很难推断出变量的值。</p><p id="c99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通常有哪些层次的范围界定？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="86b8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">范围的级别</h1><h2 id="0626" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">全球的</h2><p id="92a8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">顾名思义，<em class="lv">全局作用域</em>是指一个变量或方法在整个应用程序中可见。这对于小脚本来说不一定是坏事，但是随着应用程序的增长，大量使用全局变量会使代码难以维护。</p><p id="ebda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当涉及到<a class="ae ky" href="https://medium.com/better-programming/multithreaded-ruby-synchronization-race-conditions-and-deadlocks-f1f1a7cddcea" rel="noopener">多线程</a>时，全局变量变得特别复杂。</p><h2 id="50ed" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">组件</h2><p id="368f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在<em class="lv">模块范围</em>中，变量在模块内部可见，但模块可以跨多个文件构建。</p><h2 id="e5d3" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">文件</h2><p id="0f2d" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在<em class="lv">文件范围</em>中，变量仅在文件内部可见。这个级别主要在C中使用(有时在C++中也是如此)。在C中，可以在文件中定义一个变量，但不能导出它，所以其他函数不能使用它。如果开发者想使用一个文件范围的变量，他们必须在文件的开始定义它，并且不能在函数中。</p><p id="185d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件是模块的特殊情况下，文件作用域与模块作用域非常相似。</p><h2 id="c135" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">功能</h2><p id="39e2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在<em class="lv">函数作用域</em>中，函数定义在一个变量中，并且可以在该函数的任何子块中访问。</p><p id="c8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们在词法范围示例中使用变量<code class="fe lw lx ly lz b">method_variable</code>的方式。</p><p id="2f7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript函数中，函数作用域是用<code class="fe lw lx ly lz b">var</code>关键字初始化的每个变量的默认作用域级别(如果变量在没有任何关键字的情况下被初始化，它默认成为全局变量)。为什么会这样呢？因为JavaScript将这些变量隐式地放在函数的顶部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://gist.github.com/choallin/6e17f8254f8c79f1f5a2245c13ac207e" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/choall in/6e 17 f 8254 F8 c 79 f1 F5 a 2245 c 13 AC 207 e</a></p></figure><p id="638c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里变量<code class="fe lw lx ly lz b">x</code>仍然可用，尽管它是在函数的子块中定义的。</p><p id="da9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe lw lx ly lz b">var</code>隐式改变变量的顺序是为了让一些有趣的代码工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="859c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最新的Chrome或Firefox不再这样工作，但仍然可以在整个函数中看到用<code class="fe lw lx ly lz b">var</code>定义的变量，而不仅仅是在一个块中。</p><h2 id="7b80" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">街区</h2><p id="dc03" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">一个功能可以分成多个子块。在许多类C语言中，一个<em class="lv">块</em>被<code class="fe lw lx ly lz b">{}</code>包围着——在Ruby中，我们更经常使用<code class="fe lw lx ly lz b">do end</code>。</p><h2 id="0c6e" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">表示</h2><p id="9082" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在许多函数式语言中，我们有一个额外的层次，即<em class="lv">表达式</em>层次。这意味着变量只在一个短表达式中定义。</p><p id="e3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能看起来像这样:</p><pre class="kj kk kl km gt ns lz nt nu aw nv bi"><span id="55e7" class="ne mi it lz b gy nw nx l ny nz">let val x = some_function() in x * x end</span></pre><p id="4d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用变量<code class="fe lw lx ly lz b">x</code>作为缓存，所以我们不必调用函数<code class="fe lw lx ly lz b">some_function()</code>两次。</p><p id="ba12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<code class="fe lw lx ly lz b">let</code>关键字也存在于非函数式语言中——例如在JavaScript或<a class="ae ky" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> Rust </a>中——但是在这些语言中，它与变量的作用域无关。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="dcfd" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">相关概念</h1><p id="e5d4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><em class="lv">动态分派</em>与作用域密切相关。这描述了如何为对象解析实例变量/方法(大多数时候)。</p><h2 id="bb03" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">关闭</h2><p id="b297" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有时候，当涉及到作用域时，<em class="lv">闭包</em>令人困惑。为什么会这样呢？因为一般来说，它们是在不同于编码的地方执行的。</p><p id="eaf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它们在词汇上是有作用域的，因为代码的上下文与名称解析有关，而与运行时无关。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="deb0" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="91ff" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果我们仔细考虑代码的作用域，并保持对代码执行环境的了解，我们将能够写出更好的代码，并且在使用特定于领域的语言(可以改变作用域)时不会感到困惑——这在Ruby社区中很常见，尤其是在<a class="ae ky" href="https://rubyonrails.org/" rel="noopener ugc nofollow" target="_blank"> Rails </a>中，但在JavaScript中也并不少见。</p></div></div>    
</body>
</html>