<html>
<head>
<title>Comparing Code Performance in .Net</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较中的代码性能。网</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/could-my-code-run-faster-80ca4da7ea29?source=collection_archive---------22-----------------------#2022-02-09">https://betterprogramming.pub/could-my-code-run-faster-80ca4da7ea29?source=collection_archive---------22-----------------------#2022-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e030" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你能写出更快的代码吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/97358d0d717cb1db6cc55c50167dd7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ALxfkdhw7dgo5QsduOx4g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://pixabay.com/pt/users/wildfaces-932734/" rel="noopener ugc nofollow" target="_blank">拍摄的照片</a>在<a class="ae ky" href="https://pixabay.com/pt/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></p></figure><p id="1da1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们编码时，我们通常在头脑中有一个特定的目标，通常是构建一些有用的东西或者修复一个现存的问题。</p><p id="4267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我们知道性能是需要考虑的一个关键点，但大多数时候我们把它作为次要目标。</p><p id="dea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，与其在解决问题后才开始关注解决方案的性能，不如在开发解决方案时将性能考虑在内。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="b432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个类似的情况是，有人要求你修改一段代码，因为这个人认为他的方法比你的方法有更好的性能。</p><p id="4c52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在确定建议的方法是否真的比我们的好之前，接受建议的情况并不少见。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><blockquote class="mc md me"><p id="4a94" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">幸好。net开发人员已经有了benchmarkdotnet，这是一个可以用来测量我们代码性能的工具，它非常容易使用和理解，在社区中非常有名</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="3454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我将解释如何建立一个简单的项目，比较不同的开发方法，并以一种非常吸引人和有效的方式导出信息。</p><p id="9bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实现真正的解决方案之前，您可以拥有这个项目并更改代码来测试您的方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3a4f" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">树立榜样</h2><p id="4f15" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">首先，让我们创建一个新的控制台应用程序，并安装<a class="ae ky" href="https://www.nuget.org/packages/BenchmarkDotNet/" rel="noopener ugc nofollow" target="_blank"> benchmarkdotnet依赖NuGet包。</a></p><p id="2efe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在终端中运行<code class="fe nh ni nj nk b">dotnet new console</code>，当if结束时运行<code class="fe nh ni nj nk b">dotnet add package BenchmarkDotNet</code>，如果您使用。net core 3.1你的<code class="fe nh ni nj nk b">.csproject</code>文件看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/5485914d328c101965e8ac837b906e67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*S1yvgSd330D60zj_8hfVcw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">csproj文件</p></figure><p id="1d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从测试<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/api/system.text.json?view=net-6.0" rel="noopener ugc nofollow" target="_blank">系统之间的反序列化性能开始。Text.Json </a>和<a class="ae ky" href="https://www.newtonsoft.com/json" rel="noopener ugc nofollow" target="_blank"> Newtonsoft。Json </a>，这是一个很容易做的测试，你可以在网上找到很多关于它们的比较。</p><p id="6598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据我所知，根据我们要反序列化的项目的复杂性，性能可能会有所不同，因此，我创建了两个模型，一个简单的模型稍微复杂一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d6d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我将创建<code class="fe nh ni nj nk b">DeserializationBenchmark</code>类，用于测试代码并生成性能结果</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="93ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，这个类非常简单，它有四个用于测试的方法，分别用<code class="fe nh ni nj nk b">[Benchmark]</code>属性、<code class="fe nh ni nj nk b">JTextSimple</code>、<code class="fe nh ni nj nk b">NewtonSimple</code>和<code class="fe nh ni nj nk b">NewtonComplex</code>修饰，它们只会反序列化在类构造函数中序列化的内容。</p><p id="bd6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还添加了两个私有方法来序列化名为<code class="fe nh ni nj nk b">SerializeSimpleModeList()</code>和<code class="fe nh ni nj nk b">SerializeComplexModelList()</code>的简单和复杂列表</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5d7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，这两种方法都是序列化一个列表，每个列表包含简单和复杂模型的五个项目。</p><p id="9f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是在方法<code class="fe nh ni nj nk b">Program.Main()</code>中设置基准流道:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样，我们完成了基准测试应用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="b596" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">运行并检查结果</h2><p id="860a" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在终端中键入<code class="fe nh ni nj nk b">dotnet run</code>,然后执行</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/7150c57b6aa600280b4760e016e4b763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TDix9YBG4OYCyp8N5jXkcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基准结果</p></figure><p id="1217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要注意的是列方法和均值，看一下数字，很明显反序列化简单和复杂模型之间有很大的差异</p><p id="f485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们没有添加任何导出器，所以结果没有被持久化，所以如果您在<code class="fe nh ni nj nk b">BenchmarkDotNet.Artifacts</code>文件夹中检查，您将只有<code class="fe nh ni nj nk b">.log</code>文件</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/233540ea5516ff4645c2ce3e1e72aa41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EE-BkjIECr0kalE_lCghVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解决方案文件</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="1de6" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">导出结果</h2><p id="aee5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">虽然结果在终端很容易解释，但是<code class="fe nh ni nj nk b">benchmarkdotnet</code>提供了其他出口商，因为我们可以在<a class="ae ky" href="https://benchmarkdotnet.org/articles/overview.html" rel="noopener ugc nofollow" target="_blank">文档</a>中查看。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/9df91b9a15734ac0c1d885fa61e78109.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVN9VGRd3_RbcjUKLsC6zQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">benchmarkdotnet文档中的出口商部分</p></figure><p id="3867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是它也说我们需要安装<code class="fe nh ni nj nk b">R</code>来允许<code class="fe nh ni nj nk b">RPlotExporter</code>产生许多好的情节。</p><blockquote class="mc md me"><p id="89f3" class="kz la mf lb b lc ld ju le lf lg jx lh mg lj lk ll mh ln lo lp mi lr ls lt lu im bi translated">R是一个用于统计计算和图形的自由软件环境。</p></blockquote><p id="2548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要安装它，首先在<a class="ae ky" href="https://cran.r-project.org/mirrors.html" rel="noopener ugc nofollow" target="_blank">列表镜像</a>中选择最近的国家，然后下载相应版本的<a class="ae ky" href="https://cran.radicaldevelop.com/" rel="noopener ugc nofollow" target="_blank">操作系统</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/f1aa46ec7bf5866ed07ed55ba3236cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MctkrkdqTG3hZaBnUOKcNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">r下载页面</p></figure><p id="8b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安装过程非常简单，对于macOS，它会在安装结束时显示一个这样的摘要</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/8bff53b86c93fc52d4747268e793c217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*2rq9ljmEWis-2bvvplh63Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安装摘要屏幕</p></figure><p id="3c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，现在我们需要定制代码，以便在运行解决方案后导出它，这样做非常简单，只需将这两个导出器添加到配置中，并用<code class="fe nh ni nj nk b">HtmlExporter</code>属性修饰基准类</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e29a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，下次运行控制台时，它将在<code class="fe nh ni nj nk b">BenchmarkDotNet.Artifacts</code>文件夹中生成图形。</p><p id="ae20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如这个:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/691808aaa93a42bc7a3ea9a7f1831fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMu_QRFTg4wbx1SBK3JC-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基准柱状图</p></figure><p id="1545" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及所有这些其他的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/2535613ead9d86a012550194fd13836b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wVWSo1fEPY5F2F3Nftcvg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JTextSimple方法执行的迭代索引</p></figure><p id="4376" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我没有太多的知识来评估这样的图形，但条形图是一个非常简单的例子，每个人都会理解，如果你想，你可以检查文档，以了解到底是什么和如何发生的神奇</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="42ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我只是解释了benchmarkDotNet工具的基础知识，你可以找到许多其他使用它的方法和许多自定义点。</p><p id="b089" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里查看<a class="ae ky" href="https://benchmarkdotnet.org/articles/overview.html" rel="noopener ugc nofollow" target="_blank"> benchmarkdotnet文档</a>，玩得开心。</p><p id="ee33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将让解决方案在链接上<a class="ae ky" href="https://github.com/edsondiasalves/deserializationbenchmark" rel="noopener ugc nofollow" target="_blank">可用，随意克隆并运行它，只需在终端上键入<code class="fe nh ni nj nk b">dotnet run </code>，看看会发生什么</a></p><p id="d416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望它能对你有用，谢谢你的阅读，下次见。</p></div></div>    
</body>
</html>