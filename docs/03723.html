<html>
<head>
<title>Let Angular Manage Your RxJS Subscriptions Better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让Angular更好地管理您的RxJS订阅</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/let-angular-manage-your-rxjs-subscriptions-better-9243073e94b0?source=collection_archive---------1-----------------------#2020-03-01">https://betterprogramming.pub/let-angular-manage-your-rxjs-subscriptions-better-9243073e94b0?source=collection_archive---------1-----------------------#2020-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b2e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">管理RxJS订阅的最干净的解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c8ca1ffd69db9c38a6e381218ad435a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOFZw374W-fm1YEdzZte9A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尼尔·托马斯在<a class="ae ky" href="https://unsplash.com/s/photos/solution?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="0a3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网上有很多如何在Angular应用中管理<a class="ae ky" href="https://rxjs-dev.firebaseapp.com/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>订阅的方法。在这篇文章中，我将与你分享我自己是如何处理的。为什么我相信这是最干净的方法之一。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/c0f41c8dd9ae0927d3fce91f0a9569a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSWCB0UBF9G-6byC28lbfQ.png"/></div></div></figure><p id="82b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，您会在一个角度组件中处理多个RxJS可观测量。你需要在某个地方订阅它们，更重要的是，当不再需要它们的时候，取消订阅。</p><p id="da87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网上有成千上万的文章解释总是退订是多么重要。内存泄漏、性能下降、疯狂的副作用——所有这些都可以由一个未退订的可观察事件触发。</p><p id="9a8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好，我们知道我们必须退订。现在我们需要知道如何…</p><p id="54ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有数以千计的其他文章解释如何正确退订。如何不让管理订阅的代码过载组件代码。</p><p id="fee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以使用RxJS操作符来帮助你自己，或者你可以使用<code class="fe lx ly lz ma b">ngOnDestroy</code>钩子，或者一个<code class="fe lx ly lz ma b">Subject</code>，或者一个组件基类。</p><p id="42ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然有很多方法。但是所有这些，不管他们多么努力不去做，都会让你的组件代码有点乱。然后，在组件中编码的应用程序逻辑与您添加的一些订阅管理代码混合在一起，以防止可怕的内存泄漏。</p><p id="e829" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于可读性来说，这肯定不是很好。即使非常简单的组件也开始看起来有点复杂和可怕…</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="f3cc" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">异步管道拯救世界？</h1><p id="9bed" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">好的。但是拜托，我只是想在组件创建时订阅一些可观察的东西，然后在组件销毁时取消订阅所有的东西。</p><p id="38dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我要为此写一行代码呢？这似乎是最常见的情况。为什么我要自己处理？框架不能帮我吗？</p><p id="8319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，可以的。在Angular中有异步管道。</p><p id="2ccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在组件模板中使用异步管道。你传递给它一个可观察对象，然后它订阅它，从它返回值，最后当组件被销毁时<em class="lw">它取消订阅</em>。我们需要的一切。至少，乍一看…</p><p id="4ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个<code class="fe lx ly lz ma b">lastComment$</code>可观察对象返回最后一个注释对象。并且，假设我们想要在模板中打印注释体。我们可以像这样轻松地做到:</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="f3cf" class="nj mj it ma b gy nk nl l nm nn">&lt;h1&gt;Last comment&lt;/h1&gt;<br/>&lt;div&gt;{{ (lastComment$ | async).body }}&lt;/div&gt;</span></pre><p id="8e39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止一切顺利。但是如果我们也想添加评论主题呢？</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="ac92" class="nj mj it ma b gy nk nl l nm nn">&lt;h1&gt;Last comment&lt;/h1&gt;<br/>&lt;h2&gt;{{ (lastComment$ | async).subject }}&lt;/h2&gt;<br/>&lt;div&gt;{{ (lastComment$ | async).body }}&lt;/div&gt;</span></pre><p id="855d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯…不再那么酷了。我们有两份订阅，而不是一份。每次使用异步管道都会创建一个单独的订阅(即使您使用相同的可观察对象)。</p><p id="1ab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，在<code class="fe lx ly lz ma b">lastComment$</code> observable下面，你隐藏了一个对API的HTTP请求或者一些复杂的数据处理。对于两个独立的订阅，您将执行这些操作两次，而不是一次。听起来不太好，是吗？那么，我们能做什么呢？</p><p id="967f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，我们可以通过使用<code class="fe lx ly lz ma b">*ngIf</code>指令来帮助自己。让我们把一切都包装在一个<code class="fe lx ly lz ma b">div</code>元素中。让我们添加<code class="fe lx ly lz ma b">*ngIf</code>到里面，订阅里面的<code class="fe lx ly lz ma b">lastComment$</code>。</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="636c" class="nj mj it ma b gy nk nl l nm nn">&lt;div *ngIf="lastComment$ | async"&gt;<br/>...<br/>&lt;/div&gt;</span></pre><p id="8343" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当有评论发出，就会显示<code class="fe lx ly lz ma b">div</code>内容。每当完全没有评论的时候，整个<code class="fe lx ly lz ma b">div</code>都会被隐藏。完美。</p><p id="282c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将异步管道结果保存在变量下，稍后在由<code class="fe lx ly lz ma b">*ngIf</code>显示的元素中使用它。你可能已经看过很多次了。姑且称我们的变量为<code class="fe lx ly lz ma b">comment</code> <em class="lw">。</em></p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="ffcf" class="nj mj it ma b gy nk nl l nm nn">&lt;div *ngIf="(lastComment$ | async) as comment"&gt;<br/>  &lt;h1&gt;Last comment&lt;/h1&gt;<br/>  &lt;h2&gt;{{ comment.subject }}&lt;/h2&gt;<br/>  &lt;div&gt;{{ comment.body }}&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="536c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，看来我们成功了，对吧？</p><p id="dc7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的…但是…</p><p id="a4d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象你的组件模板有点大。并且您在两个或更多的地方显示注释数据，由一些其他内容隔开。假设我们想打印评论作者的名字，然后是一篇博客文章，然后是所有的评论细节，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2ce1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯…再一次。如你所见，我们有多个订阅。</p><p id="57a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能对付他们吗？我们的技巧——包装<code class="fe lx ly lz ma b">div</code>——会再次奏效吗？让我们看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，不……它不再起作用了——至少不总是。</p><p id="6d31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意:当根本没有<code class="fe lx ly lz ma b">lastComment</code>时，异步管道返回<code class="fe lx ly lz ma b">null</code>。然后<code class="fe lx ly lz ma b">*ngIf</code>指令隐藏了整个<code class="fe lx ly lz ma b">div</code>及其所有内容，以及我们希望保持可见的无辜的<code class="fe lx ly lz ma b">blogPost</code>元素。</p><p id="b570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，异步管道在这样的场景中是没有用的吗？我们被迫手动管理订阅吗？或者我们需要接受模板中的多重订阅吗？</p><p id="8733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，您仍然可以使用异步管道！<strong class="lb iu"> </strong>你只需要知道如何。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="4877" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">像职业选手一样跳舞</h1><p id="e096" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们只需要从<code class="fe lx ly lz ma b">lastComment$</code>可观察值中创建一个新的可观察值，并确保它总是<em class="lw">返回一个真值</em>。让我们把我们的<code class="fe lx ly lz ma b">lastComment$</code>可观测值稍微转换一下，姑且称之为<code class="fe lx ly lz ma b">componentContext$</code>。</p><pre class="kj kk kl km gt nf ma ng nh aw ni bi"><span id="c3ed" class="nj mj it ma b gy nk nl l nm nn">let componentContext$ = this.lastComment$.pipe(<br/>  map(lastComment =&gt; ({ lastComment }))<br/>);</span></pre><p id="6f77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成了。请注意，我们的新observable总是返回一个真值(object ),即使<code class="fe lx ly lz ma b">lastComment$</code>发出null。如果为null，返回值将如下所示:<code class="fe lx ly lz ma b">{ lastComment: null }</code>。</p><p id="00f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们来看看它的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="78de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切正常。包装<code class="fe lx ly lz ma b">div</code>总是可见的，因为<code class="fe lx ly lz ma b">componentContext$</code>发出的值总是真实的。内部div的显示或隐藏取决于<code class="fe lx ly lz ma b">lastComment</code>值。</p><p id="aaf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们检查相应内部<code class="fe lx ly lz ma b">*ngIf</code>中的<code class="fe lx ly lz ma b">ctx.lastComment</code>属性，并做出适当的反应。</p><p id="ef03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看它有多干净。我们有一个异步管道、一个订阅和一个完全工作的组件。</p><p id="6699" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的是，<em class="lw">所有的订阅现在都由异步管道本身控制</em>，我们不必担心及时取消订阅，Angular为我们做到了这一点。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="044d" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">组件上下文可观察</h1><p id="869e" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我们上面创建的可观察对象——我喜欢称之为<em class="lw">组件上下文可观察对象。</em></p><p id="a67b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是由你的组件正在使用的所有可观察对象组成的单个可观察对象。它发出组件上下文对象，该对象包含组件需要正确呈现的所有数据。</p><p id="78be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保我们的上下文observable每次都发出，一旦它的一个源observable产生一个值，使用<code class="fe lx ly lz ma b">combineLatest</code>操作符创建它是很方便的。</p><p id="1bb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，可以这样创建:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bb76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配置完成后，它可以像这样使用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a8a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看这种方法如何构建您在组件中管理RxJS可观测量的方式。我们可以将此总结为以下三条规则，您可以在整个应用程序中遵守这些规则:</p><ol class=""><li id="8211" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">永远不要直接在组件代码中订阅观察值。如果您不需要管理他们的订阅，您将永远不需要管理他们的订阅。每当您需要订阅组件中的可观察对象时，请使用异步管道<strong class="lb iu"> </strong>。</li><li id="7a35" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">创建组件上下文可观察对象，它由您想要在组件中使用的可观察对象组成。确保它总是发出一个真值。</li><li id="f9a1" class="nq nr it lb b lc nz lf oa li ob lm oc lq od lu nv nw nx ny bi translated">使用异步管道和<code class="fe lx ly lz ma b">*ngIf</code>在组件模板的开头订阅上下文可观察对象，并通过变量将发出的上下文对象传递给模板的其余部分。一旦组件被销毁，所有的订阅都将被异步管道终止。</li></ol><p id="e16c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！</p></div></div>    
</body>
</html>