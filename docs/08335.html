<html>
<head>
<title>The ID Principle for Improving Any Software Design Solution</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进任何软件设计解决方案的ID原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-id-principle-for-improving-any-software-design-solution-b375db8cc823?source=collection_archive---------8-----------------------#2021-04-19">https://betterprogramming.pub/the-id-principle-for-improving-any-software-design-solution-b375db8cc823?source=collection_archive---------8-----------------------#2021-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4e5c" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">程序员世界</h2><div class=""/><div class=""><h2 id="1aa6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">导致其他伟大软件设计思想的单一原则</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/54da4ecfe89a335cecb40ffc72dd28f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qh_cKNppiSC7Zsu2yzbuBA.png"/></div></div><p class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@rohanmakhecha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rohan Makhecha </a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3081" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有许多软件解决方案原则。怎么才能全部学会？如果我们遇到一个软件设计问题，我们是否应该仔细检查我们的软件设计原则库，看看哪一个合适？</p><p id="925a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我试图找出伟大的软件原则之间的共同点时，我开始看到它们之间的共同特征。我来分享一下我所看到的，看看你是否也有同样的想法。</p><p id="0a11" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，让我们看看一些伟大的原则。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f4a4" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">依赖注入原理</h1><p id="a6bc" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">如果我们有一段代码，如下"</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="ef95" class="nn mm it nj b gy no np l nq nr">fun getPrices(): Prices {</span><span id="b914" class="nn mm it nj b gy ns np l nq nr">    val prices = LocalRepository().getPrices()</span><span id="d30b" class="nn mm it nj b gy ns np l nq nr">    if (prices == null) {<br/>        return NetworkRepository().getPrices() <br/>    }</span><span id="6840" class="nn mm it nj b gy ns np l nq nr">    return prices<br/>}</span></pre><p id="66a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">虽然上面的代码有效，但并不好。这是因为，<code class="fe nt nu nv nj b">getPrices()</code>完全依赖于<code class="fe nt nu nv nj b">LocalRepository</code>和<code class="fe nt nu nv nj b">NetworkRepository</code>。这意味着:</p><ul class=""><li id="c641" class="nw nx it lk b ll lm lo lp lr ny lv nz lz oa md ob oc od oe bi translated">测试<code class="fe nt nu nv nj b">getPrices</code>很难，因为我们不能轻易模仿<code class="fe nt nu nv nj b">LocalRepository</code>和<code class="fe nt nu nv nj b">NetworkRepository</code></li><li id="cd15" class="nw nx it lk b ll of lo og lr oh lv oi lz oj md ob oc od oe bi translated">如果我们改变到一个新的本地或网络存储库，我们必须改变这个功能内容。它不能轻易改变。</li></ul><p id="f23a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要解决这个问题，我们应该总是注入依赖项，而不是仅仅在函数中创建它们。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="d672" class="nn mm it nj b gy no np l nq nr">fun getPrices(<br/>   <strong class="nj jd">localRepositpory</strong>: LocalRepository,<br/>   <strong class="nj jd">networkRepositpory</strong>: networkRepository<br/>): Prices {</span><span id="f735" class="nn mm it nj b gy ns np l nq nr">   val prices = <strong class="nj jd">localRepositpory</strong>.getPrices()</span><span id="9dd4" class="nn mm it nj b gy ns np l nq nr">   if (prices == null) {<br/>        return <strong class="nj jd">networkRepositpory</strong>.getPrices() <br/>   }</span><span id="384a" class="nn mm it nj b gy ns np l nq nr">   return prices<br/>}</span></pre><p id="70f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们应该使该功能独立于本地和网络存储库。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="c2f8" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">依赖性倒置原则</h1><p id="d027" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这是第五个坚实的原则。它颠倒了依赖关系，以解耦两个对象的强关联关系。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ok"><img src="../Images/7665e37e3d00179062095566ccb541ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tHYcBf_xvuDGPrPy.png"/></div></div></figure><p id="ebae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如上图所示，对象A最初依赖于对象b。依赖反转原则使对象A不再直接依赖于对象b。</p><p id="71ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个简单的代码示例:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="13c0" class="nn mm it nj b gy no np l nq nr">fun calculate(operation: Add, v1: Int, v2: Int): Int {    <br/>   return operation.compute(value1, value2)<br/>}</span><span id="d1a0" class="nn mm it nj b gy ns np l nq nr">class Add {<br/>   fun compute(v1: Int, v2: Int) = v1 + v2<br/>}</span></pre><p id="6ef5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nt nu nv nj b">calculate</code>功能直接依赖于<code class="fe nt nu nv nj b">Add</code>。这使得<code class="fe nt nu nv nj b">calculate</code>在它可以执行的操作中非常不灵活。</p><p id="5dc8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，如果我们反过来，却引入了如下所示的接口:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="2bfb" class="nn mm it nj b gy no np l nq nr">fun calculate(operation: Operation, v1: Int, v2: Int): Int {    <br/>   return operation.compute(value1, value2)<br/>}</span><span id="4497" class="nn mm it nj b gy ns np l nq nr">interface Operation {<br/>   override fun compute(v1: Int, v2: Int): Int<br/>}</span><span id="94a0" class="nn mm it nj b gy ns np l nq nr">class Add: Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 + v2<br/>}</span></pre><p id="92c2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以让<code class="fe nt nu nv nj b">calculate</code> <em class="ol">独立依赖</em><code class="fe nt nu nv nj b">Add</code>。这也让我们可以很容易地添加<code class="fe nt nu nv nj b">Sub</code>函数，使函数更具可扩展性。</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="7e06" class="nn mm it nj b gy no np l nq nr">class Sub: Operation {<br/>   override fun compute(v1: Int, v2: Int) = v1 - v2<br/>}</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a832" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">偏好组合而非继承</h1><p id="0938" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">这是近来另一个经常被提倡的设计实践。</p><p id="0be9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">想象一下，如果我们有以下情况:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="22ae" class="nn mm it nj b gy no np l nq nr">interface Job {<br/>   fun work()<br/>}</span><span id="1f42" class="nn mm it nj b gy ns np l nq nr">class Programmer: Job {<br/>   override fun work() = "Code"<br/>}</span><span id="7572" class="nn mm it nj b gy ns np l nq nr">class John: Programmer</span></pre><p id="1a22" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">John是程序员，所以<code class="fe nt nu nv nj b">John</code>继承了<code class="fe nt nu nv nj b">Programmer</code>类。但是这种编程方式非常不灵活，因为约翰可能会换工作。如果我们从继承改为合成，如下:</p><pre class="ks kt ku kv gt ni nj nk nl aw nm bi"><span id="4886" class="nn mm it nj b gy no np l nq nr">interface Job {<br/>   fun work()<br/>}</span><span id="caa8" class="nn mm it nj b gy ns np l nq nr">class Programmer: Job {<br/>   override fun work() = "Code"<br/>}</span><span id="e938" class="nn mm it nj b gy ns np l nq nr">class John(val job: Job)</span></pre><p id="1bce" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">那么与其<code class="fe nt nu nv nj b">John</code>是个<code class="fe nt nu nv nj b">Programmer</code>，不如<code class="fe nt nu nv nj b">John</code>干脆有个<code class="fe nt nu nv nj b">Job</code>。这使得<code class="fe nt nu nv nj b">John</code> <em class="ol">独立依赖于特定的<code class="fe nt nu nv nj b">Job</code></em>。我们可以随时改变他的工作，而不需要改变它的继承性。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="5323" class="ml mm it bd mn mo mp mq mr ms mt mu mv ki mw kj mx kl my km mz ko na kp nb nc bi translated">独立自主原则</h1><p id="e647" class="pw-post-body-paragraph li lj it lk b ll nd kd ln lo ne kg lq lr nf lt lu lv ng lx ly lz nh mb mc md im bi translated">从上面的例子中，我们可以看到原始设计的一个共同挑战是对对方的强烈依赖。这种依赖性削弱了其改变和灵活的能力。</p><p id="1547" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">克服这一限制的解决方案是:</p><blockquote class="om on oo"><p id="b682" class="li lj ol lk b ll lm kd ln lo lp kg lq op ls lt lu oq lw lx ly or ma mb mc md im bi translated">通过使依赖关系间接依赖于特定的实体，找到一种放松依赖关系的方法。这将使它看起来独立，而实际上它仍然对实体有一些依赖。我称之为<strong class="lk jd">独立依赖</strong>。</p></blockquote><p id="f549" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法将使解决方案获得灵活性的好处，同时依赖于特定的实体，并改进软件设计的原始方法。</p><p id="bfda" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简而言之，让你的依赖不要像永久的直接父子关系，你不能动态地脱离，而是像雇主和雇员的关系，其中一方<em class="ol">独立依赖另一方</em>。人们需要它来谋生，但需要时可以随时改变。</p><p id="65b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个原则在任何方法中都是通用的，可以用来改进任何有局限性的现有软件设计解决方案。您可以在以下文章中找到更多示例:</p><div class="os ot gp gr ou ov"><a href="https://towardsdatascience.com/the-root-of-all-software-design-challenge-independent-or-dependent-31252051bf0e" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd jd gy z fp pa fr fs pb fu fw jc bi translated">所有软件设计挑战的根源:独立还是依赖</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">独立依赖设计:许多软件设计方案的蓝图</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">towardsdatascience.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj lb ov"/></div></div></a></div><p id="4495" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">试试吧，让我知道效果如何。</p></div></div>    
</body>
</html>