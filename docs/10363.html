<html>
<head>
<title>Why Spring is Faster Than Vert.x?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Spring比Vert.x快？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-spring-is-faster-than-vert-x-bc09b436021d?source=collection_archive---------1-----------------------#2022-01-02">https://betterprogramming.pub/why-spring-is-faster-than-vert-x-bc09b436021d?source=collection_archive---------1-----------------------#2022-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bfc1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过基准测试分析JVM框架之间的性能差异</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a112d0c891b22aa10d21890262de5f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*el_wUU1KY1AL--La"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">拉尔夫·布隆伯格在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1c7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题“为什么Spring比Vert.x快？”在不同的版本中，<a class="ae kv" href="https://stackoverflow.com/questions/70487928/why-i-cant-see-the-performance-difference-between-spring-boot-and-vert-x/70494122#70494122" rel="noopener ugc nofollow" target="_blank">平均每月被问一次StackOverflow </a>。毕竟，Spring仍然是目前最流行的JVM框架，所以很多公司都在使用它。但是Spring Framework并不以其性能著称。另一方面，Vert.x被认为是性能最好的JVM框架之一。因此，预计Vert.x在任何基准测试中都将优于Spring。但事实并非如此。</p><p id="c20d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我想解决这些违反直觉的结果的不同原因，并就如何改进您的基准测试方法提出一些建议。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="bcf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，当我们谈论一个框架或语言“快”的时候，我们指的是什么？就web服务而言，我们不谈获得响应的速度，也称为请求<em class="lz">延迟</em>。我们通常指的是另一个指标，叫做<em class="lz">吞吐量</em>。延迟是指返回对单个请求的响应所需的时间。吞吐量是指一台服务器在给定的时间范围内可以处理多少请求。通常:在一秒钟内。</p><p id="ccc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们来理解开发者从哪里得到Vert.x应该比Spring更快的概念。有一个针对由tech empowed支持的web框架的<a class="ae kv" href="https://www.techempower.com/benchmarks/" rel="noopener ugc nofollow" target="_blank">非常流行的基准，它试图使用一些场景来测量不同语言、运行时和框架的吞吐量。通常，Vert.x框架在那些基准测试中表现非常好。</a></p><p id="6219" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.techempower.com/benchmarks/#section=data-r20&amp;hw=ph&amp;test=db" rel="noopener ugc nofollow" target="_blank">例如，在第20轮</a>中，Vert.x以每秒572K的请求数排名第10，而Spring以每秒102K的请求数排名第219。这的确令人印象深刻。</p><p id="26b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，试图重现这些令人印象深刻的结果有时证明是具有挑战性的，因此从标题的问题。</p><p id="0390" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着去理解标杆管理策略的主要缺陷是什么。</p><p id="53d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">当谈到Spring时，我指的是具体的Spring Framework，而不是Spring WebFlux / Project Reactor，它们的操作方式不同。我还假设Spring应用程序运行在Tomcat容器中。</em></p><h1 id="be2b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Vert.x以I/O为中心</h1><p id="8372" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Vert.x framework的独创性很早就认识到大多数现实应用程序的瓶颈是等待I/O。这意味着应用程序写得有多好、JIT优化有多智能以及JVM GC有多先进都无关紧要。大多数情况下，应用程序会等待数据库的响应，或者等待10年前用Python或PHP编写的服务的响应。</p><p id="ab23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Vert.x解决这个问题的方式是将所有I/O工作放入一个队列中。由于将新任务放入队列并不是一个特别繁重的操作，Vert.x每秒能够处理成千上万个这样的任务。</p><p id="79ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，这是一个非常简单的解释。有多个队列、上下文切换、反应式驱动程序，还有一堆其他有趣的东西，我不会在这里介绍。不过，我希望大家记住的是，Vert.x针对I/O进行了优化。</p><p id="a304" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看通常如何测试Vert.x的性能:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7ec1" class="nc mb iq my b gy nd ne l nf ng">app.get("/json").handler(ctx -&gt; {      <br/>    ctx.response().end("Hello, World!"); <br/>});</span></pre><p id="6291" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将上面的例子与来自Vert.x基准测试的代码进行比较，vert . x基准测试的代码仍然表现很好，吞吐量为每秒400万个请求，但与其他一些语言和框架相比并不出色:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="4861" class="nc mb iq my b gy nd ne l nf ng">app.get("/json").handler(ctx -&gt; {      <br/>    ctx.response()<br/>        .putHeader(HttpHeaders.SERVER, SERVER)<br/>        .putHeader(HttpHeaders.DATE, date)<br/>        .putHeader(HttpHeaders.CONTENT_TYPE, "application/json")<br/>        .end(Json.encodeToBuffer(new Message("Hello, World!"))); <br/>    }<br/>);</span></pre><div class="nh ni gp gr nj nk"><a href="https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/Java/vertx-web/src/main/java/io/vertx/benchmark/App.java#L222-L228" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ir gy z fp np fr fs nq fu fw ip bi translated">master tech empower/framework benchmarks上的FrameworkBenchmarks/App.java</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny kp nk"/></div></div></a></div><p id="60ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你能看出区别吗？在大多数开发人员执行的基准测试中，I/O几乎为零。是的，有一些，因为获得请求和编写响应仍然是I/O，但与像与数据库或文件系统交互这样的事情相比并不多。</p><p id="23f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，像Vert.x这样的反应式框架为您提供的优势被该测试最小化了。</p><p id="2b6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">如果您想从Vert.x这样的反应式框架中看到真正的好处，那么就编写一个执行一些I/O工作的基准应用程序，比如写入数据库或从远程服务中读取数据。</em></p><h1 id="baa9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">低并发运行基准测试</h1><p id="6ae1" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">Spring Framework处理并发的方式是分配一个线程池，专门用于处理传入的请求。这也称为“每个请求的线程”模型。一旦线程用完，Spring应用程序的吞吐量就开始下降。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a409" class="nc mb iq my b gy nd ne l nf ng">ab -c 100 http://localhost:8080/</span></pre><p id="74d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们使用一个叫做<a class="ae kv" href="https://httpd.apache.org/docs/2.4/programs/ab.html" rel="noopener ugc nofollow" target="_blank"> Apache HTTP Benchmark </a>的工具来用请求轰炸我们的服务。<code class="fe nz oa ob my b">-c</code>标志指定同时运行100个并发请求。</p><p id="9d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您在两个服务上运行这个测试，一个是用Spring编写的，另一个是用Vert.x编写的，看不到任何性能差异。这是为什么呢？</p><p id="e48b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与Vert.x不同，Spring Framework不直接控制它使用的线程数量。相反，线程的数量是由容器控制的，在我们的例子中是Tomcat。默认情况下，Tomcat设置的最大线程数是200。这意味着，在您拥有至少200个并发请求之前，您应该看不到Spring和Vert.x应用程序之间的太大差异。你只是没有足够重视你的申请。</p><p id="a4ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想增加Spring应用程序的压力，请将并发请求的数量设置为高于线程池的最大大小。</p><h1 id="6a01" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">在同一台机器上运行基准测试</h1><p id="1f98" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们回到Vert.x是如何工作的。我已经提到过，Vert.x通过将所有传入请求放入队列来优化其性能。一旦响应到达，它也被放在同一个队列中。忙于处理该队列的线程数量非常有限，称为EventLoop线程。请求越多，EventLoop线程就越忙，消耗的CPU就越多。</p><p id="6f28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您在机器上运行基准测试时，现在会发生什么？例如:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="9cf7" class="nc mb iq my b gy nd ne l nf ng">ab -c 1000 http://localhost:8080/</span></pre><p id="6870" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来会发生的事情如下。基准测试工具将尝试创建尽可能多的请求，利用机器的所有CPU资源。Vert.x服务将尝试为所有这些请求提供服务，也尝试利用所有的资源。</p><p id="5c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="lz">为了在基准测试期间最大化Vert.x应用程序的性能，请确保在一台单独的机器上运行它，该机器不与运行基准测试的机器共享CPU。</em></p><p id="5194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就把我们带到了下一点。</p><h1 id="e816" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Spring框架性能很好</h1><p id="9d84" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">至少在过去的5年里，我一直是Vert.x的超级粉丝。但是，让我们在前面提到的基准中看看Spring应用程序的吞吐量。</p><ul class=""><li id="7cf5" class="oc od iq ky b kz la lc ld lf oe lj of ln og lr oh oi oj ok bi translated">明文:28K</li><li id="b66e" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">JSON序列化:20K</li><li id="077b" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">单个查询:14K</li><li id="6c10" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">财富:6K</li><li id="d00c" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">多个查询:1，8K</li><li id="e473" class="oc od iq ky b kz ol lc om lf on lj oo ln op lr oh oi oj ok bi translated">数据更新:0,8K</li></ul><p id="b741" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看着这些数字，并考虑到我们通常至少在3个实例的集群中运行我们的服务，您应该问自己:我的应用程序需要每秒处理2K次更新吗？</p><p id="401c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果答案是肯定的，那么您可能需要在多台机器上运行基准测试，以使Spring应用程序达到崩溃的边缘。</p><h1 id="fdda" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="5ad6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">作为软件工程师，我们喜欢将自己喜爱的语言或框架的性能与其他人进行比较。</p><p id="f01b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这样做的时候，使用客观的衡量标准是很重要的。使用基准来测量服务吞吐量是一个好的开始，但是应该正确地进行。</p><p id="8d76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">评估您正在运行的测试是否受限于CPU或I/O，或者是否有其他瓶颈。</p><p id="f28b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，要确保在不同于运行应用程序代码的机器上运行基准。否则，你可能不会对结果印象深刻。</p><p id="a8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我看到一些公司遇到了语言或框架的吞吐量瓶颈，甚至帮助解决了其中的一些问题。但是周围有许多成功的公司可能不需要所有的吞吐量，你可能正在为其中的一家工作。获得一个好的基准是很难的，而且要花很多时间才能做好。好好想想这是不是你应该解决的最关键的问题。</p></div></div>    
</body>
</html>