<html>
<head>
<title>An Intro to Events in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中事件的介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-intro-to-events-in-react-47a6a621b031?source=collection_archive---------7-----------------------#2019-08-06">https://betterprogramming.pub/an-intro-to-events-in-react-47a6a621b031?source=collection_archive---------7-----------------------#2019-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="df9b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用例子解释事件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/86132208a640b17de7456fd06247434d.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/1*RclhQUBEB0yOPKd1HavI8A.gif"/></div></figure><p id="0e01" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">用<a class="ae lj" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>处理事件与处理DOM元素上的事件非常相似。</p><p id="f278" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，不是像在<a class="ae lj" href="http://vanilla-js.com/" rel="noopener ugc nofollow" target="_blank">普通的</a> JavaScript中那样调用<code class="fe lk ll lm ln b">addEventListener</code>，而是在最初呈现元素时提供一个事件监听器。</p><p id="4907" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">此外，还有一些语法差异:</p><ul class=""><li id="2fd4" class="lo lp iq kp b kq kr kt ku kw lq la lr le ls li lt lu lv lw bi translated">React事件以<code class="fe lk ll lm ln b">camelCase</code>命名(像<code class="fe lk ll lm ln b">onClick</code>)，而不是全部小写。</li><li id="dd53" class="lo lp iq kp b kq lx kt ly kw lz la ma le mb li lt lu lv lw bi translated">使用JSX，您传递一个函数作为事件处理程序，而不是一个字符串。</li></ul><p id="0802" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">React利用自己的事件系统来提供跨浏览器兼容性。</p><p id="bdd2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">要做到这一点，React将本机浏览器事件包装在自己的名为<code class="fe lk ll lm ln b">SyntheticEvent</code>的结构中，并将它们传递给React事件处理程序。React根据W3C规范<a class="ae lj" href="https://www.w3.org/TR/DOM-Level-3-Events/" rel="noopener ugc nofollow" target="_blank">定义了这些合成事件，这为它们提供了跨浏览器兼容性。</a></p><p id="f775" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为React的<code class="fe lk ll lm ln b">SyntheticEvent</code>具有与原生浏览器事件相同的接口，所以您可以使用像<code class="fe lk ll lm ln b">preventDefault()</code>和<code class="fe lk ll lm ln b">stopPropagation()</code>这样的方法。</p><p id="044e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">每个<code class="fe lk ll lm ln b">SyntheticEvent</code>对象都有以下属性:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi mc"><img src="../Images/e0c02f43f849c4736d54a176f977fcbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQqAHyiNFjAVeNiEws-3TQ.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated"><a class="ae lj" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/events.html</a></p></figure><p id="c84a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当您定义基于类的组件时，一个常见的模式是事件处理程序是类上的一个方法。</p><p id="4708" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在下面的例子中，<code class="fe lk ll lm ln b">Toggle</code>组件呈现一个按钮，允许用户在“开”和“关”状态之间切换。</p><p id="e71f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">每当点击事件发生时，<code class="fe lk ll lm ln b">handleClick()</code>方法改变状态，而<code class="fe lk ll lm ln b">render()</code>方法显示DOM的当前状态:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="gh gi ml"><img src="../Images/6f9587ddf7e9d3d7582cb293112afee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyX7dqDzGePQ-QWrnse8qA.png"/></div></div><p class="mh mi gj gh gi mj mk bd b be z dk translated"><a class="ae lj" href="https://reactjs.org/docs/handling-events.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/handling-events.html</a></p></figure><p id="bdfb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">出于性能目的，React有一个内置特性，它“汇集”它的<code class="fe lk ll lm ln b">SyntheticEvents</code>。这意味着在一个事件处理程序被调用后，<code class="fe lk ll lm ln b">event.target</code>的所有属性都被重置为<code class="fe lk ll lm ln b">null</code>。</p><p id="c44f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通过在执行回调后使属性无效，React可以在应用程序的其他地方重用事件对象。</p><p id="177c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是React的任务是干燥、模块化和可重用的一个很好的例子。</p><p id="6241" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">借助事件池，浏览器不需要为每个事件实例的新对象分配内存。相反，它将在内存中为所有事件实例使用相同的事件对象。</p><p id="8826" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">事件处理程序完成执行后，事件对象的键保持不变，但每个键的值都被重置为null。这释放了内存空间，但也意味着已执行事件的值会丢失。</p><p id="c5f9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">由于这种无效化，不能异步访问这些属性。</p><p id="550d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当一个类似于<code class="fe lk ll lm ln b">setState()</code>的异步函数被执行时，它将试图访问事件的属性，比如<code class="fe lk ll lm ln b">event.currentTarget.value</code>，正如我们所看到的，所有事件对象的属性都被重置为<code class="fe lk ll lm ln b">null</code>，所以返回值将是...<code class="fe lk ll lm ln b">null</code>。哦不！</p><p id="7fa0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">你可能会遇到类似<code class="fe lk ll lm ln b">Uncaught TypeError: Cannot read property ‘data’ of null</code>的常见错误。</p><p id="c71c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了防止一个事件对象被池化，从而无效，我们在函数的开始调用<code class="fe lk ll lm ln b">event.persist()</code>。</p><p id="0613" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">调用此方法将从池中移除<code class="fe lk ll lm ln b">SyntheticEvent</code>,并且事件对象将不会被后面的DOM事件重用；这允许异步保留对事件的引用。</p><p id="cba6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">作为<code class="fe lk ll lm ln b">event.persist()</code>的替代，你可以将你需要的数据存储在一个变量中(例如。<code class="fe lk ll lm ln b">const pug = event.target</code>)。</p><p id="6206" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个例子中，<code class="fe lk ll lm ln b">pug</code>将包含对DOM对象的引用，它独立于对event对象的引用。通过将<code class="fe lk ll lm ln b">event.target</code>保存到一个变量，我们可以保留对该数据的访问，而不需要通过实际的事件对象访问目标。</p><p id="8d75" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>