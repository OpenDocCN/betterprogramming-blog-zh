<html>
<head>
<title>A Comprehensive Guide to TypeScript Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本接口综合指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-comprehensive-guide-to-typescript-interfaces-16c5749fac2b?source=collection_archive---------7-----------------------#2020-09-17">https://betterprogramming.pub/a-comprehensive-guide-to-typescript-interfaces-16c5749fac2b?source=collection_archive---------7-----------------------#2020-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="92c6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向您的代码库添加类型和类型安全</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e4a9e377a3b388d8c697cb1837e8f31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1VD0SANNsqpwH6r2xOafg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="d04c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢TypesScript有很多原因，因为它比JavaScript有很多优点。对大多数开发人员来说，主要的好处是类型安全的优势。类型安全在TypeScript中有多种实现方式，但最重要的方式之一是通过接口。</p><p id="6b46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口允许您验证您的函数是否拥有所有需要的数据，并且没有任何不需要的数据。TypeScript会在你的代码被编译之前告诉你这一切。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="32b7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">概观</h1><p id="2b4b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">以下是这篇文章将涵盖的内容的概述。</p><ul class=""><li id="6694" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">什么是TypeScript接口？</li><li id="4400" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">什么时候使用TypeScript接口？</li><li id="0c76" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">简单接口示例</li><li id="5a8e" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">向界面添加属性</li><li id="c8bc" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">从界面中删除属性和可选属性</li><li id="be96" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">处理多个JSON对象</li><li id="17d6" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">处理多个JSON对象的数组</li><li id="b09a" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">使用函数属性</li><li id="7007" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">结论和额外资源</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f7cd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是TypeScript接口？</h1><p id="6180" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">TypeScript接口的一个常见解释是，它们定义了一个<em class="nk">契约</em>，但这是什么意思呢？它基本上意味着一个接口将指定什么属性以及这些属性的类型应该是什么。</p><p id="6df2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对什么是接口有一个小的解释是很好的，但是理解接口的最好方法是通过例子和实际使用它们。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="10fb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么时候使用TypeScript接口？</h1><p id="9eb5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">使用接口有几种不同的方式，但是您将看到的两种主要方式是将接口用作函数的参数，以及通过类似API响应的方式来确定数据结构。</p><p id="934b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将主要讨论如何使用接口作为函数参数的一部分。绝大多数时候你使用一个接口，都是为了这个用例。</p><p id="8631" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文的后面，我们将使用<a class="ae kv" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>和用户端点。下面是一个使用我们的<code class="fe nl nm nn no b">User</code>接口作为API响应的一部分的例子。这是一个角度服务的小例子。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="7d6d" class="nt ma iq no b gy nu nv l nw nx">getUsers() {<br/>    return this.http.get&lt;User[]&gt;(`<a class="ae kv" href="https://jsonplaceholder.typicode.com/users`" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users`</a>);<br/>}</span></pre><p id="4ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码基本上只是说期望来自那个端点的数据符合在<code class="fe nl nm nn no b">User</code>接口中指定的属性和类型。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b8d3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">简单接口示例</h1><p id="9069" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在我们的简单示例中，我们将只使用四个字段:id、姓名、用户名和电子邮件。该接口声明所有四个字段都是必需的，并且<code class="fe nl nm nn no b">id</code>必须是类型<code class="fe nl nm nn no b">number</code>，而其他三个必须是类型<code class="fe nl nm nn no b">string</code>。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="6ccc" class="nt ma iq no b gy nu nv l nw nx">export interface User {<br/>  id: number;<br/>  name: string;<br/>  username: string;<br/>  email: string;<br/>}</span></pre><p id="fec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们在函数中使用这个接口。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="1f32" class="nt ma iq no b gy nu nv l nw nx">const getUser = (user: User) =&gt; {<br/>  console.log(`This user's name is:  ${user.name}`);<br/>};</span><span id="1f63" class="nt ma iq no b gy ny nv l nw nx">getUser({<br/>  id: 1,<br/>  name: 'Leanne Graham',<br/>  username: 'Bret',<br/>  email: '<a class="ae kv" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>',<br/>});</span><span id="4484" class="nt ma iq no b gy ny nv l nw nx">//This user's name is:  Leanne Graham</span></pre><p id="2894" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太好了！这一切都工作，很容易。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="effb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">向界面添加属性</h1><p id="70af" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果您试图添加一个未在接口中指定的附加属性，会发生什么情况？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/f3cb313a294a62ca0c1e32e6db4e390a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*uFfwtZVygt_8gPN1Nk1gkw.gif"/></div></figure><p id="af9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在上面看到的，我们做的第一件事是尝试给传递给<code class="fe nl nm nn no b">getUser</code>的对象添加一个<code class="fe nl nm nn no b">additionalProperty</code>字段。我们得到下面的错误。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="9684" class="nt ma iq no b gy nu nv l nw nx">Argument of type '{ id: number; name: string; username: string; email: string; additionalProperty: string; }' is not assignable to parameter of type 'User'.<br/>  Object literal may only specify known properties, and 'additionalProperty' does not exist in type 'User'.ts(2345)</span></pre><p id="3abb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个错误只是说明您添加了一个属性，方便地命名为<code class="fe nl nm nn no b">additionalProperty</code>，它没有在<code class="fe nl nm nn no b">User</code>接口中指定。</p><p id="4cc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你怎么解决这个问题？</p><p id="7ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢天谢地，你有两个选择来解决这个问题。</p><p id="3bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">1.您可以从传递给<code class="fe nl nm nn no b">getUser</code>函数的对象中移除<code class="fe nl nm nn no b">additionalProperty</code>。现在，这很可能不是您正在寻找的解决方案，因为您可能有意做出了这种改变，并且需要<code class="fe nl nm nn no b">additionalProperty</code>中的信息。也就是说，无意中向对象添加属性的情况确实会发生。例如，您可能打算将<code class="fe nl nm nn no b">additionalProperty</code>作为附加参数添加，<em class="nk"> </em>不是作为属性添加，其中<code class="fe nl nm nn no b">getUser</code>函数可能如下所示:</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="ae14" class="nt ma iq no b gy nu nv l nw nx">getUser(<br/>  {<br/>    id: 1,<br/>    name: 'Leanne Graham',<br/>    username: 'Bret',<br/>    email: '<a class="ae kv" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>',<br/>  },<br/>  { additionalProperty: 'Another one' }<br/>);</span></pre><p id="2c09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.另一个解决方案是更新<code class="fe nl nm nn no b">User</code>接口，用适当的类型来解释新的<code class="fe nl nm nn no b">additionalProperty</code>。通常，当出现此错误时，这就是您正在寻找的解决方案。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="63ee" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">从界面中删除属性和可选属性</h1><p id="cc68" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">那么，如果我们不再需要<code class="fe nl nm nn no b">email</code>属性，会怎么样呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/25993b97bc1843d354c502f58686bbea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*5U6vQg_IGqOfsPVQjLpsxg.gif"/></div></figure><p id="0543" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，如果您只是从传递给<code class="fe nl nm nn no b">getUser</code>的对象中移除<code class="fe nl nm nn no b">email</code>属性，您将会看到下面的错误。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="7e72" class="nt ma iq no b gy nu nv l nw nx">Argument of type ‘{ id: number; name: string; username: string; }’ is not assignable to parameter of type ‘User’.<br/> Property ‘email’ is missing in type ‘{ id: number; name: string; username: string; }’ but required in type ‘User’.ts(2345)</span><span id="7596" class="nt ma iq no b gy ny nv l nw nx">interfaces.ts(5, 3): ‘email’ is declared here.</span></pre><p id="9f69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个错误基本上是说<code class="fe nl nm nn no b">email</code>需要<em class="nk"> </em>作为<code class="fe nl nm nn no b">User</code>接口的一部分被传递。</p><p id="34e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你怎么解决这个问题？</p><p id="d65a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，您有两种选择来解决这个问题。</p><ol class=""><li id="80e1" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr oa nc nd ne bi translated">您可以从<code class="fe nl nm nn no b">User</code>接口中移除<code class="fe nl nm nn no b">email</code>。这个解决方案可能不错，但是您需要确定<code class="fe nl nm nn no b">email</code>属性永远不会作为传递给<code class="fe nl nm nn no b">getUser</code>的对象的属性被添加。</li><li id="ecfa" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr oa nc nd ne bi translated">您可能已经注意到了上面例子中的另一个解决方案，即在<code class="fe nl nm nn no b">email</code>之后添加一个<code class="fe nl nm nn no b">?</code>，使属性可选。<em class="nk"> </em>这是一个非常好的界面特性，允许添加或删除<code class="fe nl nm nn no b">email</code>属性。当然，您可能需要在<code class="fe nl nm nn no b">getUser</code>函数中进行修改，以处理<code class="fe nl nm nn no b">email</code>未通过的情况。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8ac2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">处理多个JSON对象</h1><p id="af03" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们在这个例子中做了一些改进，但是让我们看看JSONPlaceholder。对于软件开发中的许多事情来说，这是一个极好的资源，并且对于解释TypeScript接口也很有帮助。</p><p id="5d72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将引用users端点，现在我们只看这个端点上的第一个用户<code class="fe nl nm nn no b">https://jsonplaceholder.typicode.com/users/1</code>。您也可以在Chrom  e中查看这一点，您应该会看到下面的JSON结构。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="a84e" class="nt ma iq no b gy nu nv l nw nx">{<br/>  "id": 1,<br/>  "name": "Leanne Graham",<br/>  "username": "Bret",<br/>  "email": "<a class="ae kv" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>",<br/>  "address": {<br/>    "street": "Kulas Light",<br/>    "suite": "Apt. 556",<br/>    "city": "Gwenborough",<br/>    "zipcode": "92998-3874",<br/>    "geo": {<br/>      "lat": "-37.3159",<br/>      "lng": "81.1496"<br/>    }<br/>  },<br/>  "phone": "1-770-736-8031 x56442",<br/>  "website": "hildegard.org",<br/>  "company": {<br/>    "name": "Romaguera-Crona",<br/>    "catchPhrase": "Multi-layered client-server neural-net",<br/>    "bs": "harness real-time e-markets"<br/>  }<br/>}</span></pre><p id="8a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该如何着手为此创建一个界面呢？基于这个简单的例子，我们对如何做到这一点有一个基本的想法。</p><p id="3320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们忽略<code class="fe nl nm nn no b">address</code>和<code class="fe nl nm nn no b">company</code>对象。如果我们这样做，我们将会有一个类似下面的<code class="fe nl nm nn no b">User</code>界面。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="ce5c" class="nt ma iq no b gy nu nv l nw nx">export interface User {<br/>  id: number;<br/>  name: string;<br/>  username: string;<br/>  email: string;<br/>  phone: string;<br/>  website: string;<br/>}</span></pre><p id="5a0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如何容纳<code class="fe nl nm nn no b">address</code>和<code class="fe nl nm nn no b">company</code>对象呢？我们将首先为两者创建一个新的接口。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="43cb" class="nt ma iq no b gy nu nv l nw nx">export interface Address {<br/>  street: string;<br/>  suite: string;<br/>  city: string;<br/>  zipcode: string;<br/>  geo: {<br/>    lat: string;<br/>    lng: string;<br/>  };<br/>}</span><span id="400e" class="nt ma iq no b gy ny nv l nw nx">export interface Company {<br/>  name: string;<br/>  catchPhrase: string;<br/>  bs: string;<br/>}</span></pre><p id="89c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为每个对象创建一个新的接口通常被认为是最佳实践。你会注意到我们忽略了为<code class="fe nl nm nn no b">geo</code>对象做这件事。其原因是该信息可能总是伴随着地址信息。当然，如果您愿意，您可以创建一个<code class="fe nl nm nn no b">GeoCoordinates</code>接口并修改<code class="fe nl nm nn no b">Address</code>接口，如下所示:</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="c8c2" class="nt ma iq no b gy nu nv l nw nx">interface Address {<br/>  street: string;<br/>  suite: string;<br/>  city: string;<br/>  zipcode: string;<br/>  geo: GeoCoordinates;<br/>}</span><span id="7974" class="nt ma iq no b gy ny nv l nw nx">interface GeoCoordinates {<br/>  lat: string;<br/>  lng: string;<br/>}</span></pre><p id="a2f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在有了这两个新的<code class="fe nl nm nn no b">Address</code>和<code class="fe nl nm nn no b">Company</code>接口。我们如何将这些与<code class="fe nl nm nn no b">User</code>接口联系起来？</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="1cce" class="nt ma iq no b gy nu nv l nw nx">export interface User {<br/>  id: number;<br/>  name: string;<br/>  username: string;<br/>  email: string;<br/>  address: Address; // uses the new Address interface<br/>  phone: string;<br/>  website: string;<br/>  company: Company; // uses the new Company interface<br/>}</span></pre><p id="42c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们的<code class="fe nl nm nn no b">User</code>接口已经完全设置好了。来看看我们更新后的<code class="fe nl nm nn no b">getUser</code>功能。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="4b96" class="nt ma iq no b gy nu nv l nw nx">const logUserAddress = (userAddress: Address) =&gt; {<br/>  console.log(`The user's address is ${userAddress.street}      ${userAddress.suite}`);<br/>};</span><span id="d389" class="nt ma iq no b gy ny nv l nw nx">const getUser = (user: User) =&gt; {<br/>  console.log(`The user's name is ${user.name}`);<br/>  console.log(`The user's phone number is ${user.phone}`);<br/>  console.log(`The user's zipcode is ${user.address.zipcode}`);<br/>  logUserAddress(user.address);<br/>};</span><span id="407e" class="nt ma iq no b gy ny nv l nw nx">getUser({<br/>  id: 1,<br/>  name: 'Leanne Graham',<br/>  username: 'Bret',<br/>  email: '<a class="ae kv" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>',<br/>  address: {<br/>    street: 'Kulas Light',<br/>    suite: 'Apt. 556',<br/>    city: 'Gwenborough',<br/>    zipcode: '92998-3874',<br/>    geo: {<br/>      lat: '-37.3159',<br/>      lng: '81.1496',<br/>    },<br/>  },<br/>  phone: '1-770-736-8031 x56442',<br/>  website: 'hildegard.org',<br/>  company: {<br/>    name: 'Romaguera-Crona',<br/>    catchPhrase: 'Multi-layered client-server neural-net',<br/>    bs: 'harness real-time e-markets',<br/>  },<br/>});</span><span id="9e0a" class="nt ma iq no b gy ny nv l nw nx">//The user's name is Leanne Graham<br/>//The user's phone number is 1-770-736-8031 x56442<br/>//The user's zipcode is 92998-3874<br/>//The user's address is Kulas Light Apt. 556</span></pre><p id="87ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在<code class="fe nl nm nn no b">getUser</code>函数中看到的，传递的对象与您在<code class="fe nl nm nn no b"><a class="ae kv" href="https://jsonplaceholder.typicode.com/users/1" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users/1</a></code>中看到的完全一样。</p><p id="e80c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对<code class="fe nl nm nn no b">getUser</code>函数所做的一个额外的改变是有另一个名为<code class="fe nl nm nn no b">logUserAddress</code>的函数在其中被调用。这个新函数接受我们创建的新<code class="fe nl nm nn no b">Address</code>接口的一个参数。这样做很好的原因是，您只能传递用户的地址细节，并充分利用<code class="fe nl nm nn no b">Address</code>接口及其类型定义。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cdcd" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">处理多个JSON对象的数组</h1><p id="3368" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">因此，我们已经从JSONPlaceholder中增加了完整的用户对象，但是让我们通过添加一个对象数组来假装它甚至更复杂一些。</p><p id="4a8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们的用户很富有，有多所房子，每所房子的详细信息都存储在<code class="fe nl nm nn no b">address</code>数组中的一个对象中。您的用户对象将看起来像下面的对象。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="1de6" class="nt ma iq no b gy nu nv l nw nx">{<br/>  id: 1,<br/>  name: 'Leanne Graham',<br/>  username: 'Bret',<br/>  email: '<a class="ae kv" href="mailto:Sincere@april.biz" rel="noopener ugc nofollow" target="_blank">Sincere@april.biz</a>',<br/>  address: [<br/>    {<br/>      street: 'Kulas Light',<br/>      suite: 'Apt. 556',<br/>      city: 'Gwenborough',<br/>      zipcode: '92998-3874',<br/>      geo: {<br/>        lat: '-37.3159',<br/>        lng: '81.1496',<br/>      },<br/>    },<br/>    {<br/>      street: 'Random Street',<br/>      suite: 'Apt. 321',<br/>      city: 'Attenborough',<br/>      zipcode: '93187-4259',<br/>      geo: {<br/>        lat: '-37.9911',<br/>        lng: '82.0137',<br/>      },<br/>    },<br/>  ],<br/>  phone: '1-770-736-8031 x56442',<br/>  website: 'hildegard.org',<br/>  company: {<br/>    name: 'Romaguera-Crona',<br/>    catchPhrase: 'Multi-layered client-server neural-net',<br/>    bs: 'harness real-time e-markets',<br/>  },<br/>}</span></pre><p id="4b3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里唯一的变化是<code class="fe nl nm nn no b">address</code>是一个数组，并且有一个新的对象，该对象具有与<code class="fe nl nm nn no b">Address</code>接口中定义的所有必需属性相匹配的哑数据。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="99f9" class="nt ma iq no b gy nu nv l nw nx">{<br/>    street: 'Random Street',<br/>    suite: 'Apt. 321',<br/>    city: 'Attenborough',<br/>    zipcode: '93187-4259',<br/>    geo: {<br/>        lat: '-37.9911',<br/>        lng: '82.0137',<br/>    },<br/>},</span></pre><p id="f910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经定义了更高级的用户对象的样子，那么我们的<code class="fe nl nm nn no b">User</code>界面会有什么样的结果呢？</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="077f" class="nt ma iq no b gy nu nv l nw nx">export interface User {<br/>  id: number;<br/>  name: string;<br/>  username: string;<br/>  email: string;<br/>  address: Address | Address[];<br/>  phone: string;<br/>  website: string;<br/>  company: Company;<br/>}</span></pre><p id="6655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在TypeScript中，<code class="fe nl nm nn no b">|</code>是一个非常重要的部分，这里称为<em class="nk">联合类型</em>。这基本上就是说，<code class="fe nl nm nn no b">address</code>属性可以是一个单独的<code class="fe nl nm nn no b">Address</code>对象，也可以是一个包含一个或多个<code class="fe nl nm nn no b">Address</code>对象的数组。在我们的例子中，我们可以不使用联合类型，严格要求<code class="fe nl nm nn no b">address</code>属性是<code class="fe nl nm nn no b">Address</code>对象的数组。但是这种解决方案具有灵活性，并且仍然可以使用JSONPlaceholder提供的前一个用户JSON对象。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="689c" class="nt ma iq no b gy nu nv l nw nx">const logUserAddress = (userAddress: Address | Address[]) =&gt; {<br/>  if (Array.isArray(userAddress)) {<br/>    console.log(`The user has ${userAddress.length} addresses`);<br/>    for (const [index, address] of userAddress.entries()) {<br/>      console.log(`The user's address ${index + 1} is ${address.street} ${address.suite}`);<br/>    }<br/>  } else {<br/>    console.log(`The user's address is ${userAddress.street} ${userAddress.suite}`);<br/>  }<br/>};</span><span id="af85" class="nt ma iq no b gy ny nv l nw nx">const getUser = (user: User) =&gt; {<br/>  console.log(`The user's name is ${user.name}`);<br/>  console.log(`The user's phone number is ${user.phone}`);<br/>  logUserAddress(user.address);<br/>};</span></pre><p id="6128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在看了函数之后，这可能看起来很复杂，但是它比看起来简单。我们做一个简单的检查来确定<code class="fe nl nm nn no b">userAddress</code>是否是一个数组，如果是，我们可以遍历这个数组来获取地址信息。否则，<code class="fe nl nm nn no b">userAddress</code>将是一个对象，我们可以像以前一样访问属性。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0abf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">使用函数属性</h1><p id="1804" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">那么如果你需要在一个界面中增加一个功能呢？没问题。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="f5f5" class="nt ma iq no b gy nu nv l nw nx">{<br/>  id: 1,<br/>  name: 'Leanne Graham',<br/>  // ... removed to make it shorter / easier to read<br/>  company: {<br/>    name: 'Romaguera-Crona',<br/>    catchPhrase: 'Multi-layered client-server neural-net',<br/>    bs: 'harness real-time e-markets',<br/>  },<br/>  logCompany: (company) =&gt; {<br/>    console.log(company.name);<br/>  },<br/>}</span></pre><p id="c986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到这里有一个新的属性，名为<code class="fe nl nm nn no b">logCompany</code>，它是一个带有参数<code class="fe nl nm nn no b">company.</code>的函数。<code class="fe nl nm nn no b">logCompany</code>函数将记录所提供的<code class="fe nl nm nn no b">company</code>对象的<code class="fe nl nm nn no b">name</code>属性。</p><p id="aa68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这对<code class="fe nl nm nn no b">User</code>界面有什么影响？</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="9836" class="nt ma iq no b gy nu nv l nw nx">export interface User {<br/>  id: number;<br/>  name: string;<br/>  username: string;<br/>  email: string;<br/>  address: Address | Address[];<br/>  phone: string;<br/>  website: string;<br/>  company: Company;<br/>  logCompany?: (company: Company) =&gt; void;<br/>}</span></pre><p id="bcf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nl nm nn no b">User</code>接口具有可选的<code class="fe nl nm nn no b">logCompany</code>属性，该属性接受一个参数<code class="fe nl nm nn no b">company</code>，即<code class="fe nl nm nn no b">Company</code>接口。这是将对象分解到它们自己的接口的好处的另一个例子。<code class="fe nl nm nn no b">void</code>将是函数的返回类型。在我们的例子中，我们没有返回值，因为我们登录到控制台。如果你要返回一个类型为<code class="fe nl nm nn no b">string</code>或<code class="fe nl nm nn no b">boolean</code>的值，等等。，您需要在接口中指定返回类型。</p><p id="4c78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一下<code class="fe nl nm nn no b">getUser</code>函数，我们可以看到，作为函数的最后一行，我们有<code class="fe nl nm nn no b">user.logCompany?.(user.company);</code>，它本质上声明了如果我们有<code class="fe nl nm nn no b">logCompany</code>属性，我们需要将它作为带有<code class="fe nl nm nn no b">user.company</code>参数的函数来执行。这将会成功，因为<code class="fe nl nm nn no b">user.company</code>是在<code class="fe nl nm nn no b">Company</code>接口中指定的定义。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="6d22" class="nt ma iq no b gy nu nv l nw nx">const getUser = (user: User) =&gt; {<br/>    log.result(`The user's name is ${user.name}`);<br/>    log.result(`The user's phone number is ${user.phone}`);<br/>    logUserAddress(user.address);<br/>    user.logCompany?.(user.company);<br/>};</span></pre><h2 id="6790" class="nt ma iq bd mb ob oc dn mf od oe dp mj lf of og ml lj oh oi mn ln oj ok mp ol bi translated">异步函数</h2><p id="abc8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">同样，您完全可以使用异步函数作为接口的属性。举个例子，如果你为<code class="fe nl nm nn no b">logCompany</code>使用一个承诺，这个承诺将包装返回类型(在我们的例子中<code class="fe nl nm nn no b">void)</code>使接口看起来像:</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="2560" class="nt ma iq no b gy nu nv l nw nx">logCompany?: (company: Company) =&gt; Promise&lt;void&gt;;</span></pre><p id="bcf3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，当然，我们需要通过添加关键字<code class="fe nl nm nn no b">async</code>来使<code class="fe nl nm nn no b">getUser</code>函数异步。我们还需要在<code class="fe nl nm nn no b">user.logCompany?.(user.company);</code>行之前添加<code class="fe nl nm nn no b">await</code>关键字。</p><pre class="kg kh ki kj gt np no nq nr aw ns bi"><span id="c119" class="nt ma iq no b gy nu nv l nw nx">const getUser = async (user: User) =&gt; {<br/>  log.result(`The user's name is ${user.name}`);<br/>  log.result(`The user's phone number is ${user.phone}`);<br/>  logUserAddress(user.address);<br/>  await user.logCompany?.(user.company);<br/>};</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f95b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论和额外资源</h1><p id="df99" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">谢谢你能走到这一步。我真的希望这篇文章对您有用，并且这些例子提高了您对TypeScript接口的理解。</p><p id="a746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面我附上了GitHub的要点和我们在本文中讨论过的全部代码。这也可以复制并在<a class="ae kv" href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgKoGdrIN4ChnLAAmAXMiAK4C2ARtANz7lxURnphSgDmjBFmKCBZtkHLiF5MIVOMAA27Tjz7I4RIlAjp0ZAIIatO5AB9kBzdvQBtALqqADgAsA9iFHiVTAO4Qa6YEglCSkCBBcqBzgQAE8yAGEIqNjVeRduRMjomIB+MgAKcKzYhKTsgEpkAF4APmQANxdiRgBfXFxQSFhEFAsjdBwmcQgIMGCvAnQKQI9lSVUEQLixOdDkAC9gB3CiWZDVbggXMjwCAnk4MZX9pnPJcfmmFtb2zuh4JGRM5JjBgmFWA81ghLggnAAFJxQOCYIGqfxw3BtXDhEAcZBpbgYaB9KzVZD5AQ4wxWfQk4xmXE6OyVWp-QgwAl6KDQmIAOmA6GZrMJgip6HKlVOZ1R6Bc8ggbMx+QABgAVJwoIlQZBOGHIAAk2GV-KlEEkYCcLTU5Mw6Bl5VUBBgLhVhTc6OsoF2AA8ADQmyw6WzIFyMnWmtn65TafKC+lnZCi8WS6XyxXIZUAcgG6i9Ay1zogLuQAGpkABGY2czXYNP9NnDUbGrXlqyV6aQFoWq3INoEY0QeSYCNRh0xqXpWUKpWCFOe-qEDPavmBqtgGsz4nphszZuWp5Ixgoh1gZCHMDYlVVAnK3RoQQ06p1YU2u2ivfK33+wQC3vRiWD7jDhPJgYAlASy1ZU2QA9dWw-WMh3jUdoHHZw3BQShaCwIClygNkEPccDbgxdIj35XloDZOsdA3SMQMxb5shyNkiIwoofnItst3aA8j3yawmGFAhiDIAs3VwgCyCTAAZCBoncZAAHFoTVKgk0EijBGE5AkwAIS0MBFNwmQ5EUNSAGVQCQLQAAE4AcLh5DZGhgHWHTI1I88uMjAgeLc+cRIAaQoC4BlE4BuCcbSlLcyZG1EJM9AcMA2WQABWBKADZHPCqMlhE6TfBAGhbRcChgrS8LNm2FxdhEgBOAAmSrKoADgAWgAZnqgB2AAWYq3MOY5e3Ci4riTFq2rZZqCwSyruoG+41Pqgs2QLDrKtSsLwpaNazg23D3J2s4vLUgAlaIiAiZBDM4EZQr2iKZhEmK4uQZrqoLaaRUytS9DASBcvywqnDeghSp2KLKvG9rGo66rJsB-cjhOG6zkGkSRrZOqC1ezaZu4ET6uqtkAAYC2atrYe29bNtsTasKigtGratqCfp5rksa+qCfG5AXRSjqoe63x-DutSnAUXZuDgKAiDZW1uG6xjsgR8LVKTQ6IjgbgKGgOBGviKA3DgN6QTAMFIWhWE1IAWT8sBgEai4YmgCAiCjeRgGDRrBHqLB3AoaF5Ea9xrvChFhYl9xjC0OB-Zt1hkAgRrZCgABrUZ0G68mkfSaiSgJeXYlpG89sgr97WKdkAOYjswozjy+OQarNuVgBRKB6lAZAAAkXF8eR5G65Vlb0cBEO+iBur0hQRMMtUQGEMzWFdnQ4DZMB6m65zFc8y7RhEgA1YAEDAW1kHBC5QDTrGxEiqfIuQdqpsvxYwGWJMAHVORcJOYhoX2isv4HyqgwJilVmDM2qYz2r1TeA1Lgow6s1NGCUCYP0RvIWaw1modTZB1ZKBZ6pvQzlXXCNMRJEyZslGqjVkqTWalzZBBZob8z8AEIIalogwjADCYAy9A5yzKDnDy-wRAiQACIQAQEnbuOsuAcENqCCEUIYRRXBHrRANsvbICIMQNRB8+zgB4PqBAMQ3ohxTDEdwUBuD2RQOgEEFwaASivg4Bw8gYiNTBHINE6dq6CVsJaIAA" rel="noopener ugc nofollow" target="_blank"> TypeScript Playground </a>中使用。</p><p id="e41f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想要一些额外的资源来理解TypeScript接口，我推荐你看看<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/interfaces.html" rel="noopener ugc nofollow" target="_blank"> TypeScripts官方文档</a>。另一个优秀的资源是Udemy。我目前正在报名参加<a class="ae kv" href="https://www.udemy.com/course/understanding-typescript/" rel="noopener ugc nofollow" target="_blank">理解打字稿— 2020年版</a>，可以有把握地说，这是各种打字稿知识的绝佳资源，包括界面。</p><p id="c5f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还有一个<a class="ae kv" href="https://github.com/tengel92/Medium" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>，里面有我所有的JavaScript和类型脚本技巧和诀窍。您可以克隆这个repo，在安装了与<code class="fe nl nm nn no b">npm install</code>的依赖关系之后，您就可以运行<code class="fe nl nm nn no b">npm run ts:interfaces</code>了。你也可以修改<code class="fe nl nm nn no b">interfaces.ts</code>来满足你学习更多的渴望，并拥有一个本地的打字游戏场。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://gist.github.com/tengel92/a54c0d55cb2b5f314ac55d55065486a0" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/tengel 92/a 54c 0d 55 CB 2 b5 f 314 AC 55d 55065486 A0</a></p></figure></div></div>    
</body>
</html>