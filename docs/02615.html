<html>
<head>
<title>Predictive Modeling in R (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">R中的预测建模(上)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/predictive-modeling-in-r-part-1-64145669fb92?source=collection_archive---------10-----------------------#2019-12-12">https://betterprogramming.pub/predictive-modeling-in-r-part-1-64145669fb92?source=collection_archive---------10-----------------------#2019-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="536b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何开始使用ARIMA模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1ce14681c409bd28713a3c59cde501c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tz18n1AReRLLMtUbr0jR0A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chrisliverani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯·利维拉尼</a>在<a class="ae ky" href="https://unsplash.com/s/photos/statistics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约一年前，我们写了关于ARIMA模式的文章。我们想最终回到讨论使用ARIMA和/或ETS方法创建预测模型，而不是使用考虑许多变量的更复杂的基于驱动因素的模型。</p><p id="c16e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ARIMA模型只从过去的输出数据中寻找模式。</p><p id="201d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管这限制了ARIMA模型可以寻找的模式，但如果你理解ARIMA模型必须提供的各种参数，它仍然是相当健壮的，并允许许多修改。</p><p id="f7d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前观察的模式(也称为<em class="lv">滞后</em>)是开发该模型的关键因素，因为它决定了不同参数需要多少系数。</p><p id="8ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择正确数量的参数是很繁琐的，因为它可能需要您测试多个不同的组合。对于非季节性时间序列，ARIMA模型可以采用三个参数，在考虑季节性时，可以采用六个参数。</p><p id="5204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于非季节性数据，这些参数被引用为(<em class="lv"> p，D，q </em>);对于也包含季节性成分的时间序列，这些参数被引用为(<em class="lv"> P，D，Q </em>)。在本文中，我们不会过多关注这些参数。相反，我们将讨论在你开始操作这些参数之前，如何用R来理解你的数据。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7b5a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">使用auto.arima()</h1><p id="7b05" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">r允许你运行一个非常简单的脚本来自动创建你自己的ARIMA模型(<code class="fe na nb nc nd b">auto.arima()</code>)。它会运行它认为最适合你的组合，而且不需要了解ARIMA。这个函数有许多默认设置，所以唯一需要的输入是时间序列。</p><p id="472b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe na nb nc nd b">AirPassengers</code>数据集上使用它，代码可能如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f1602d6a23054f56287e33e68031afb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*xu3zhmZGXaer8UAFhUe9pA.png"/></div></figure><p id="c14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个预测实际上似乎非常接近。</p><p id="8e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，认识到<code class="fe na nb nc nd b">auto.arima()</code>功能并不总是像你想象的那样好是非常重要的。例如，让我们看看下面的图表。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/90123a368e28c74709182db25528f9c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*1XlvX9_VWrhEKAtXcxJ9Lw.png"/></div></figure><p id="0f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里使用<code class="fe na nb nc nd b">auto.arima()</code>功能似乎不太管用。该预测在视觉上与之前的数据不太吻合，而且它的置信区间非常大。</p><p id="5b62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能是因为总体模式每两年而不是一年相关一次。如果不了解各种参数，您将无法调整模型以更好地拟合数据。</p><p id="3399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，了解什么是ARIMA模型以及如何使用R来更好地理解时间序列中的模式非常重要(在我们的下一篇文章中，我们将讨论各种参数，并为上面的模型开发一个更好的模型)。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1a38" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">r编程和稳定性</h1><p id="3c81" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="lv">平稳性</em>是开发预测模型时的一个重要概念。</p><p id="3273" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">平稳时间序列是指具有一致的均值、方差和协方差的时间序列。简单地说，这意味着时间序列在某种程度上是可预测的。</p><p id="7fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">趋势和自相关等属性会影响时间序列，通常会导致它们不再具有平稳性。</p><p id="b7f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们看看<code class="fe na nb nc nd b">EuStockMarkets</code>数据集。该数据集包含主要欧洲股票指数的每日收盘价:德国DAX (IBIS)、瑞士SMI、法国CAC和英国FTSE。数据是在工作时间采样的，也就是说，周末和节假日被忽略(<a class="ae ky" href="https://www.rdocumentation.org/packages/datasets/versions/3.5.0/topics/EuStockMarkets" rel="noopener ugc nofollow" target="_blank"> R文档</a>)。</p><p id="714d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的数据集，可以用来理解有漂移的随机游走。请看下图，该数据集没有一致的平均值，这意味着它很可能是不稳定的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/31f7ca318aae072d8fa1b37d8469facc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*IFaTMqWqS9ZQF-ZQ2_LmLQ.png"/></div></figure><p id="ec0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以用R的几个函数来测试这个事实。这包括<code class="fe na nb nc nd b">acf()</code> <strong class="lb iu"> </strong>(自相关)函数和<code class="fe na nb nc nd b">adf.test()</code>函数。</p><p id="4bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">acf()</code>功能用于测试自相关。<em class="lv">自相关</em>是不同观测值(滞后)之间的相关性。这可能是先前的观察，甚至是几个滞后之前的观察。</p><p id="23a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数调用如下所示:</p><p id="6a94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">acf(StockData)</code></p><p id="2594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的输出描述了当前观测值和随后观测值之间的相关性。蓝色虚线代表95%的置信区间，每条实线代表与原始滞后的相关性。</p><p id="8a7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个稳定的数据集通常会有我们所说的指数相关性或不存在的相关性。这意味着原始观测值之后的一两个滞后可能会超出蓝色虚线，并显示出大量的相关性。</p><p id="fd45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">股票数据并非如此。相反，几乎每一个后续观察都与前一个观察相关。这是数据集不稳定的好迹象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ffa79f8a07a86e2d8ab0b3fc597ef34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*x8NLK9fQB2oWA6j-Ie0F3A.png"/></div></figure><p id="6491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种测试平稳性的方法是使用<code class="fe na nb nc nd b">adf.test()</code>。该函数使用扩展的Dicky-Fuller (ADF)检验。该测试分析单位根的数据集。单位根可以影响平稳性，因为单位根使过程不可预测。</p><p id="31b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以只使用引用的时间序列对象来调用函数调用，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="30db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出可能有点混乱，因为替代假设将总是读取稳定，一些人假设这意味着数据集是稳定的。事实并非如此。输出只是告诉你另一个假设是什么。</p><p id="5210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在这种情况下，我们将拒绝替代假设，因为<code class="fe na nb nc nd b">p-value</code>几乎是1，而它应该小于或等于0.05。如果<code class="fe na nb nc nd b">p-value</code>小于或等于0.05，那么你知道你的数据集可能是稳定的。</p><p id="8a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，股票数据是非平稳的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/e66b6e766f3917f2169aad7ff077430b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jreqRLzZOCUgGY05."/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0374" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">分解功能</h1><p id="6a0e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">ARIMA模型依赖于它可以从提供的数据中提取的各种特征。使用分解函数是查看数据集的一些特性的好方法。</p><p id="4bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解函数将数据过程分成三个部分:季节性、趋势和随机部分。在R中，您还可以调整分解函数来使用乘法模型或加法模型，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ea3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进一步理解分解函数中发生了什么，可以看看下面的变量。与其说它们代表数字，不如说它们代表函数。</p><p id="f633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> S </em></p><p id="ef96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">趋势</p><p id="f2ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> e </em> =随机(误差)</p><p id="e7de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用的加法模型为:<em class="lv"> Yt=Tt+St+et </em></p><p id="aa94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用的乘法模型为:<em class="lv"> Yt=Tt*St*et </em></p><p id="1e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数首先使用移动平均值确定趋势。然后，它引出一个季节性成分，其余的是随机成分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/be3d8552d8138c318cc1a3ad5243a31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*l2bMpvdOG20zdWcMzdG8iw.png"/></div></figure><p id="0927" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建ARIMA模型是为了考虑趋势。然而，了解如何使用移动平均(ma)函数提取趋势总是很方便的。</p><p id="9eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它进一步演示了如何将单个组件从数据集中取出并放回数据集中。</p><p id="071b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读关于使用<code class="fe na nb nc nd b">auto.arima()</code>功能的解释。我们希望它能帮助你设计你的下一个模型。</p></div></div>    
</body>
</html>