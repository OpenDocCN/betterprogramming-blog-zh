<html>
<head>
<title>useTransition() vs. useDeferredValue() in React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18中的useTransition()与useDeferredValue()</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/usetransition-vs-usedeferredvalue-3024f98e5443?source=collection_archive---------4-----------------------#2022-08-22">https://betterprogramming.pub/usetransition-vs-usedeferredvalue-3024f98e5443?source=collection_archive---------4-----------------------#2022-08-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cd1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们做什么以及何时使用它们，并有具体的例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1010886c88a39c9843f9a79e45ca19d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ehiqcppYzBj0fm5m"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/es/@joshstyle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔舒亚·柯尔曼</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="9618" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">React 18和并发渲染</h1><p id="2958" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">React 18于2022年3月发布，并附带了许多新工具，以帮助开发人员构建性能更高、响应更快的应用。</p><p id="01ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">其中一个显著的变化是渲染引擎采用了一个新的关键概念:并发渲染。</p><p id="5046" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并发使React能够同时准备应用程序UI的多个版本。更好的是，它可以开始渲染更新，中间暂停，稍后再回来…甚至放弃它。</p><p id="f2b7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我们将仔细研究两个新的钩子:<code class="fe ms mt mu mv b">useTransition()</code>和<code class="fe ms mt mu mv b">useDeferredValue()</code>。</p><p id="8afe" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这两个钩子赋予了您决定状态更新优先级的强大能力，或者更确切地说，指定一个更新是否不如其他更新重要，并将其放在一边以支持更紧急的更新。</p><h2 id="8dc7" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">什么更新可以算紧急更新，什么可以算琐碎更新？</h2><ul class=""><li id="13bf" class="ni nj it lt b lu lv lx ly ma nk me nl mi nm mm nn no np nq bi translated"><strong class="lt iu">紧急更新:</strong>反映直接交互，比如打字、点击、按压等等。所以，本质上来说，用户在与什么东西互动。当您在输入中键入文本时，您希望立即看到您键入的文本。不然会觉得拖沓。这就是我们要优先考虑的。</li><li id="eca6" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated"><strong class="lt iu">琐碎的更新:</strong>可能是UI从一个视图到另一个视图的转换。用户知道视图需要改变或更新。即使有一个小的延迟，这可以被视为预期，它不会被认为是应用程序的缓慢。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/2ea3c8403b9cfc5d9e30836e1acc09a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*weC6XRmdqqrbZaq9_1lLog.png"/></div></div></figure><p id="113b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">至此，让我们更深入地研究这两个新挂钩，解释它们何时可以使用，并查看如何实现它们的具体示例。</p><h1 id="3e8f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">useTransition()和startTransition</h1><p id="836a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在React 18之前，所有状态更新都被标记为“紧急”这意味着所有状态更新都被同等对待，具有相同的优先级。</p><p id="4da9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe ms mt mu mv b">useTransition()</code>，你现在可以将一些状态更新标记为不紧急。</p><h2 id="9c3d" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">何时使用它</h2><p id="3f47" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个例子是带有过滤选项的产品列表。</p><p id="e97b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当使用复选框来选择衣服的尺寸或颜色时，您希望复选框立即显示选中或未选中状态。就像你按下一个按钮。</p><p id="7dfc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">但是，需要用匹配产品更新的产品列表可以是一个单独的、不太紧急的转换。</p><h2 id="c7e8" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">如何使用它</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="17ee" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">useDeferredValue()</h1><p id="496b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe ms mt mu mv b">useDeferredValue()</code>与<code class="fe ms mt mu mv b">useTransition()</code>非常相似，它允许我们实现的是推迟非紧急状态更新，但这次应用于树的一部分。</p><p id="60e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">它与我们经常使用的延迟更新的现有方法类似，如去抖动或节流，其优点是React将在其他紧急更新完成后立即处理更新，而不是等待任意长的时间。</p><h2 id="2096" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">何时使用它</h2><p id="368b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe ms mt mu mv b">useTransition()</code>，您可以自己决定何时将特定的状态更新标记为不太紧急。但有时，您无法访问这段代码，因为状态更新来自于第三方库。</p><p id="5364" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这时候就可以考虑用<code class="fe ms mt mu mv b">useDeferredValue()</code>了。</p><p id="eeb6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用<code class="fe ms mt mu mv b">useDeferredValue()</code>，您可以包装一个值，并将其更改标记为不太重要，从而推迟它们触发的重新呈现。</p><p id="8017" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">只要有更紧急的更新需要完成，就会返回以前的值，并使用更新后的值来呈现树。</p><h2 id="8bdc" class="mw la it bd lb mx my dn lf mz na dp lj ma nb nc ll me nd ne ln mi nf ng lp nh bi translated">如何使用它</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h1 id="c51f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="18c8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们，开发人员，在构建应用程序时，应该始终把用户放在心上。</p><p id="460d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这两个新的挂钩使开发人员能够通过优先考虑对用户体验至关重要的更新并将其他一些更新标记为不太重要的更新，来尽可能地保持他们的界面响应速度，即使是在有大量重新呈现程序的复杂应用程序中。</p><p id="5bb9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这并不意味着你应该用这些钩子把所有的状态都包起来。如果你的应用程序或组件不能通过其他方式(延迟加载、be分页、web workers等)进行优化，那么它们应该作为最后的手段。).</p></div></div>    
</body>
</html>