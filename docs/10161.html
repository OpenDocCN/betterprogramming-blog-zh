<html>
<head>
<title>Analysis of Compiled Python Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分析已编译的Python文件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/analysis-of-compiled-python-files-629d8adbe787?source=collection_archive---------3-----------------------#2021-12-07">https://betterprogramming.pub/analysis-of-compiled-python-files-629d8adbe787?source=collection_archive---------3-----------------------#2021-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa52" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们看看Python脚本是如何工作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/32dfafbb978ea5eba7cc0a0fec41aa0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xrk90loKTMlnanFH"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">迈克尔·泽兹奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="4e46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译Python脚本时(。py)，最后你会得到一个编译好的Python(。pyc，。pyo)。这个文件不如它的前一个文件可读，因为它是一个字节码序列。不要担心，如果您知道方法，您可以将其还原为可读的Python脚本。</p><h1 id="12ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们的案例研究</h1><p id="c51e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这篇文章中，我们将分析一个名为<code class="fe mp mq mr ms b">demo_script.py</code>的简短脚本:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="776d" class="mx lt iq ms b gy my mz l na nb"># Imports<br/>from random import Random<br/>from sys import *<br/>import os</span><span id="e1e0" class="mx lt iq ms b gy nc mz l na nb"># Constants<br/>START_BANNER = "Hello you, have fun with this demo script!"<br/>END_BANNER = "Goodbye."</span><span id="55b2" class="mx lt iq ms b gy nc mz l na nb"># Get a random number between 1-6<br/>def new_num():<br/>    rnd_num = Random().randint(1,6)<br/>    return rnd_num</span><span id="9a36" class="mx lt iq ms b gy nc mz l na nb"># Rotate the input string by a random number (1-6)<br/>def rot(inp):</span><span id="8c48" class="mx lt iq ms b gy nc mz l na nb">    rotted = []<br/>        rot_num = 0<br/>        for i in inp:<br/>            rot_num = new_num()<br/>            rotted.append(chr(ord(i) + rot_num))<br/>    return rotted<br/>    <br/>def main():<br/>    print(START_BANNER)<br/>    inp = argv[1]<br/>    final = rot(inp)<br/>    final = "".join(final)<br/>    print(final)<br/>    print(END_BANNER)</span><span id="ef7a" class="mx lt iq ms b gy nc mz l na nb">if __name__ == "__main__":<br/>    main()</span></pre><p id="b733" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编译Python脚本的工具有几种，最常见的有<code class="fe mp mq mr ms b">PyInstaller</code> <em class="nd"> </em>和<code class="fe mp mq mr ms b">Py2Exe</code>。每种工具编译Python脚本的方式都不同，但总体来说是可以识别的。</p><h1 id="de50" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何识别编译的Python？</h1><p id="342e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">文件分析的第一步是识别其类型。幸运的是，使用下面的方法很容易发现一个可执行文件是否是一个编译过的Python:</p><ul class=""><li id="fc91" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">使用资源部分(PE文件格式的一部分)来定位编译后的Python标识符，比如广为人知的图标。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/e3782b6196cfc0703ed9a9faee2d3e26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_cl9hIf-i5SmlTkTKmJWQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用CFF浏览器查找图标</p></figure><ul class=""><li id="e8f0" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">使用<code class="fe mp mq mr ms b">strings</code>工具(来自<code class="fe mp mq mr ms b">SysInternals Suite</code>)包含Python信息，如:</li></ul><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="f9ae" class="mx lt iq ms b gy my mz l na nb">“Could not load python dll”<br/>PY2EXE_VERBOSE<br/>PyInstaller<br/>“PYTHONSCRIPT”</span><span id="5caa" class="mx lt iq ms b gy nc mz l na nb"><em class="nd">strings.exe -a “.\dist\demo_script.exe” &gt; strings.txt</em></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/639c2ebb4d184e0c9ea309c578e631c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*EZqPfKOoCygloyR-l8xM7Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">strings.txt内容</p></figure><ul class=""><li id="bcb0" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">检测文件是否被打包——例如，PyInstaller被认为是打包程序，因为它将源代码打包在新的可执行文件中。</li></ul><h2 id="8dfa" class="mx lt iq bd lu np nq dn ly nr ns dp mc lf nt nu me lj nv nw mg ln nx ny mi nz bi translated">如何确定使用的是哪个python版本？</h2><p id="236c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">每个Python版本都略有不同。这一点非常重要，因为不同版本之间存在许多差异</p><ul class=""><li id="52a1" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">在十六进制编辑器中打开可执行文件(如010Editor，HxD …)。</li><li id="a49f" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">向下滚动到文件的末尾。</li><li id="723e" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">定位标识Python版本的字符串:<code class="fe mp mq mr ms b">PythonXX.dll</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/aaf25676b93e8167a9b1c0bc8336917e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zPvocTEAoUFkt_11Fn8iXA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用XVI32十六进制编辑器查找python版本</p></figure><h2 id="1d47" class="mx lt iq bd lu np nq dn ly nr ns dp mc lf nt nu me lj nv nw mg ln nx ny mi nz bi translated">将EXE转换为PYC</h2><p id="081c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要从可执行文件恢复到Python脚本，需要按以下顺序进行转换:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/1beea30a28517379f27fc8df86cf8f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VG7W9xMBTRL_bkZhRrKOBQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">反向编译的Python文件</p></figure><p id="bc79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些工具将可执行文件反编译到。pyc文件:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0abc" class="mx lt iq ms b gy my mz l na nb"><em class="nd">python unpy2exe.py {file.exe}</em></span><span id="9d09" class="mx lt iq ms b gy nc mz l na nb"><em class="nd">python pyinstxtractor.py {file.exe}</em></span></pre><p id="3b09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些工具会输出几个文件，有些文件是工具自己用的，所以可以忽略。<br/>我们正在寻找的文件是与原始文件同名的文件，带有. pyc后缀。<br/>比如<code class="fe mp mq mr ms b">file.exe</code>的主文件是<code class="fe mp mq mr ms b">file.pyc</code>。</p><h2 id="6452" class="mx lt iq bd lu np nq dn ly nr ns dp mc lf nt nu me lj nv nw mg ln nx ny mi nz bi translated">自动反编译PYC</h2><p id="4a4b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，所有需要做的就是反编译<code class="fe mp mq mr ms b">pyc</code>文件，这就产生了原始的Python脚本。为此，我们将使用以下工具:</p><ul class=""><li id="ed04" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">非编译6-与Python版本2.6–3.8相关。</li><li id="b939" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">反编译3。</li><li id="0129" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">简单的Python反编译器。</li></ul><p id="8a9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在几种情况下，这些工具将无法正常工作。这可能是由于不兼容的Python版本或缺少依赖项。在这些和其他不可预见的情况下，我们需要自己去做！</p><h2 id="520f" class="mx lt iq bd lu np nq dn ly nr ns dp mc lf nt nu me lj nv nw mg ln nx ny mi nz bi translated">手动反编译PYC文件</h2><p id="0e7b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">提取主要部分后。pyc文件，我们将只使用默认模块把它转换成可读的Python脚本。</p><p id="e16f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模块<code class="fe mp mq mr ms b"><strong class="ky ir">dis</strong></code> <strong class="ky ir"> <em class="nd"> </em> </strong>通过将CPython字节码分解成一个代码对象，或者分解成一个可以从中获取代码对象的对象，比如函数或者模块，来支持对CPython字节码的分析。<br/>这个模块也包含了很多关于字节码指令的信息。</p><p id="8086" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模块<code class="fe mp mq mr ms b"><strong class="ky ir">marshal</strong></code>允许以二进制格式读写特定的Python值。还支持读取和编写的Python模块的“伪编译”代码。pyc文件。</p><p id="2711" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下脚本将字节码提取到一个可读结构中，该结构允许重写原始Python脚本:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="01eb" class="mx lt iq ms b gy my mz l na nb">import sys<br/>import dis, marshal<br/>pyc_path = sys.argv[1]<br/>with open(pyc_path, 'rb') as f:<br/>    # First 16 bytes comprise the pyc header (python 3.6+), else 8 bytes.<br/>    pyc_header = f.read(16)<br/>    code_obj = marshal.load(f) # Suite to code object<br/>dis.dis(code_obj)</span></pre><p id="d501" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了方便起见，将输出通过管道传输到一个文本文件:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="4a7a" class="mx lt iq ms b gy my mz l na nb"><em class="nd">manually_decompile.py demo_script.pyc &gt; dis.txt</em></span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/a81f1d504233d6a899b51eedae991795.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7FmDsUlGrcKGe7WVJ_iv-g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">dis.txt输出</p></figure><h1 id="9875" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">输出说明</h1><ul class=""><li id="5a5c" class="ne nf iq ky b kz mk lc ml lf oi lj oj ln ok lr nj nk nl nm bi translated">部分编号—每个部分都用空格键分隔，并将相应地进行编号。每个部分都是原始Python脚本中的一行。</li><li id="0530" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">当前部分中的行号—该行号将为每个函数重置。</li><li id="6fa2" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">指令—将被执行的指令。</li><li id="9c36" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">与条件相关—包含条件结束的行号。</li><li id="27ad" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated">参数——根据说明的相关参数。</li></ul><h2 id="9794" class="mx lt iq bd lu np nq dn ly nr ns dp mc lf nt nu me lj nv nw mg ln nx ny mi nz bi translated">指令信息</h2><p id="ec53" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">要理解反汇编输出，可以查看模块的文档。</p><p id="d6c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字节码分析API允许将Python代码片段包装在一个字节码对象中，该对象提供了对已编译代码细节的简单访问。</p><div class="ol om gp gr on oo"><a href="https://docs.python.org/3/library/dis.html" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">Python字节码的反汇编程序——Python 3 . 10 . 0文档</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">该模块通过反汇编来支持对CPython的分析。这个模块将CPython字节码作为…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">docs.python.org</p></div></div></div></a></div><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c682" class="mx lt iq ms b gy my mz l na nb">LOAD_FAST — load a local variable.<br/>BINARY_ADD — add the last value to the previous one.<br/>CALL_FUNCTION — call a function<br/>And so on…</span></pre><p id="7a7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要解析<code class="fe mp mq mr ms b">dis.txt</code>的输出并重写合法的。py脚本—这应该会产生一个与原始脚本相同的脚本。</p><h2 id="3a97" class="mx lt iq bd lu np nq dn ly nr ns dp mc lf nt nu me lj nv nw mg ln nx ny mi nz bi translated">从字节码中识别Python脚本结构</h2><p id="07eb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">导入<br/> </strong>导入的模块通常可以在代码的开头找到，因为它们在脚本的后面会用到。<br/>主要指令:<code class="fe mp mq mr ms b">IMPORT_STAR</code>、<code class="fe mp mq mr ms b">IMPORT_FROM</code>、<code class="fe mp mq mr ms b">IMPORT_NAME</code>。</p><ul class=""><li id="4c64" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe mp mq mr ms b">IMPORT_NAME</code> —导入模块。</li><li id="677c" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated"><code class="fe mp mq mr ms b">IMPORT_FROM</code> —结合前面的指令，从X导入y得到<em class="nd">。</em></li><li id="6d44" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated"><code class="fe mp mq mr ms b">IMPORT_STAR</code> —从模块导入*。</li></ul><p id="173c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，对于代码的以下部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/014a02b64b15d96c69b9ec04fe403370.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*fQj1wMcZlesNIWMUMHGHKg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从demo_script.pyc反汇编导入</p></figure><p id="54e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="5f25" class="mx lt iq ms b gy my mz l na nb">from random import Random<br/>from sys import *<br/>import os</span></pre><p id="14ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">常量</strong> <br/>常量变量通常紧跟在模块之后。<br/>主指令:<code class="fe mp mq mr ms b">LOAD_CONST</code>结合<code class="fe mp mq mr ms b">STORE_NAME</code>。</p><p id="67ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">LOAD_CONST</code> —加载一个全局变量。<br/> <code class="fe mp mq mr ms b">STORE_NAME</code> —存储输入值的变量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/d22fe36781f5ac4fdbbc04a03be8b7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gqy_0w-jWPHsAbm7stIfiQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">demo_script.pyc反汇编的常量</p></figure><p id="42fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">转换为:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c8da" class="mx lt iq ms b gy my mz l na nb">START_BANNER = "Hello you, have fun with this demo script!"<br/>END_BANNER = "Goodbye."</span></pre><p id="34ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">定义函数</strong> <br/>在本节中，只有函数的名称，没有内容和算法。因为与函数的关系就像与代码中的常量对象的关系一样。它可以帮助我们理解代码的流程。</p><p id="1aa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它可以通过字符串<code class="fe mp mq mr ms b">(&lt;code object <em class="nd">{FUNC_NAME}</em> at <em class="nd">{OFFSET}</em>, file “<em class="nd">{SCRIPT_NAME}</em>”, line <em class="nd">{LINE_NUMBER}</em>&gt;)</code>来识别。<br/>紧接着，指令<code class="fe mp mq mr ms b">MAKE_FUNCTION</code>与包含其名称的常量变量一起出现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/76bdff5b154895340439e899caaa6519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*je1VWbaL9KZN4lj-151-zQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">demo_script.pyc反汇编中函数的定义</p></figure><p id="7427" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">被转换为:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d007" class="mx lt iq ms b gy my mz l na nb">def new_num():</span><span id="05fc" class="mx lt iq ms b gy nc mz l na nb">def rot():</span><span id="4a7b" class="mx lt iq ms b gy nc mz l na nb">def main():</span></pre><p id="1640" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个函数的内容可以通过跳转到正确的偏移量来填充(行号将被重置，我们可以比较函数的名称)。该区域中的每个部分和指令都属于特定的函数(在原始脚本中缩进)。<br/>我们可以通过<code class="fe mp mq mr ms b">RETURN_VALUE</code>指令来识别函数的结束。因此，像堆栈一样，将被加载到前一条指令的值(像<code class="fe mp mq mr ms b">LOAD_CONST</code>)将是函数的返回值。</p><p id="86d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照Python惯例，函数的内容需要适当缩进。</p><p id="2425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，<code class="fe mp mq mr ms b">new_num</code>功能将如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/6f30a07ec03de94dc18d1c3c7c3d8802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RgdhKj9RT0kimtd4ZHnYg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">demo_script.pyc反汇编中的new_num函数</p></figure><p id="fbd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">条件</strong> <br/>我们可以用指令来识别if-else语句这样的条件:<code class="fe mp mq mr ms b">POP_JUMP_IF_ELSE</code>、<code class="fe mp mq mr ms b">POP_JUMP_IF_TRUE</code>等。注意指令的目的——真或假时跳转等等。另外，请注意指令旁边的数字，它指向执行条件时要跳转到的行。那条线标有符号'&gt; &gt;'。<br/>此外，指令<code class="fe mp mq mr ms b">COMPARE_OP</code>包含布尔条件的运算符，该段中的变量是要比较的变量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/d37f7b5fa8dbd18b8815d448a6fcfb12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*OCOnTtoYkRR7vzIQ_2xa1A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">demo_script.pyc反汇编中的条件</p></figure><p id="7234" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">明眼人会注意到这是已知的“主要”条件:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="c85a" class="mx lt iq ms b gy my mz l na nb">if __name__ == “__main__”:<br/>    main()</span></pre><p id="245c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">函数调用</strong> <br/>为了识别代码内部对函数的调用，我们会搜索相关的指令:<code class="fe mp mq mr ms b">CALL_METHOD</code>、<code class="fe mp mq mr ms b">CALL_FUNCTION</code>等。<br/>例如，结合指令<code class="fe mp mq mr ms b">LOAD_GLOBAL</code>，紧接着<code class="fe mp mq mr ms b">LOAD_METHOD</code>，最终<code class="fe mp mq mr ms b">CALL_METHOD</code>会指示到<code class="fe mp mq mr ms b">global.method()</code>。</p><ul class=""><li id="3436" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe mp mq mr ms b">LOAD_METHOD</code> — <code class="fe mp mq mr ms b">variable.method</code>。</li><li id="d424" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated"><code class="fe mp mq mr ms b">CALL_METHOD</code> —调用方法:<code class="fe mp mq mr ms b">()</code>。如果有更多的方法或参数，它们将被输入到基于堆栈的逻辑(LIFO)中。</li></ul><p id="a83b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们将从前面提到的<code class="fe mp mq mr ms b">new_num</code>函数中恢复一行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pb"><img src="../Images/b94a3283229482dfae234be69d1a7256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*1INu-HbLwWqNhAzJrK0qdg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">demo_script.pyc反汇编中new_num函数的一行</p></figure><p id="b66e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果将是:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="8661" class="mx lt iq ms b gy my mz l na nb">rnd_num = Random().randint(1,6)</span></pre><p id="19e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">循环</strong> <br/>知道如何处理代码中的循环是理解代码的关键。我们可以通过说明来识别它:</p><ul class=""><li id="cc56" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated"><code class="fe mp mq mr ms b">FOR_ITER</code> —结束于参数字段行的循环(至<em class="nd">行</em>)。</li><li id="309d" class="ne nf iq ky b kz oa lc ob lf oc lj od ln oe lr nj nk nl nm bi translated"><code class="fe mp mq mr ms b">GET_ITER</code> —来自不可改变变量的迭代变量。</li></ul><p id="8058" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下这部分代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/9c25f7a01aa89960c5fd70270f2cc6bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*0ww3HnAtq0Hdo83wiRVXxg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">demo_script.pyc反汇编中rot函数的For循环</p></figure><p id="b12e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到它变成了:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6c4a" class="mx lt iq ms b gy my mz l na nb">for i in inp:<br/>    rot_num = new_num()<br/>    rotted.append(chr(ord(i) + rot_num))<br/>return rotted</span></pre><p id="984a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变量<code class="fe mp mq mr ms b">i</code>是迭代器变量，而<code class="fe mp mq mr ms b"><em class="nd">inp</em></code>是循环所基于的可迭代变量。<code class="fe mp mq mr ms b">&gt;&gt;</code>符号内的所有内容在循环内缩进。</p><p id="0890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后可以看到变量腐烂的返回。</p><h1 id="8942" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="402b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这篇文章中，我们了解了如何使用开源工具以及仅使用默认Python语言“手动”逆向分析已编译的Python文件。我希望你能从这篇文章中学到一些东西。</p><p id="af7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>