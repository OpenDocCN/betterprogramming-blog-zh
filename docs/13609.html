<html>
<head>
<title>Custom Validation in Spring Boot Explained Through Cases, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过案例解释Spring Boot的自定义验证，第1部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-validation-in-spring-boot-best-explained-part-1-1105a8c2711?source=collection_archive---------4-----------------------#2022-09-12">https://betterprogramming.pub/custom-validation-in-spring-boot-best-explained-part-1-1105a8c2711?source=collection_archive---------4-----------------------#2022-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="85ea" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索用数组进行验证等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6c2c3782c085ee45b8e8043d5acb7b51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPgeDlCNKgPu_Zm14vKoRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ralf Skirr 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片|图像高度改变</p></figure><h1 id="1f68" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="b25a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>是一个成熟的框架，拥有过多的模块和特性。因此，在REST API应用程序中，不能错过JSON主体中的数据验证。所提供的可能性超越了丰富的“现成”注释集，允许我们定义自己的验证检查，这些检查也可以涉及字段的组合(JSON键)。</p><p id="8b7e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在本文中，我们关注一个常见的情况——当我们必须检查post请求主体中传递的JSON字段中的值是否是我们定义的数组中提供的值之一。想象一下，我们必须检查一个JSON字段中的城市是否真正属于那个国家的城市数组。如果城市与数组中的任何城市都不匹配，那么它就不属于那个国家，因此请求(例如POST请求)应该失败。</p><p id="3c0e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类似地，我们可以考虑如何根据产品来验证成分，根据它所属的主要类别来验证特定的子类别，等等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/6c5b3dd94bdea317ce498785d3c52f07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6aGBOIf-N5mUYvHq.png"/></div></div></figure><h2 id="b55c" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">先决条件</h2><p id="81f2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您应该熟悉以下内容:</p><ul class=""><li id="2589" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated"><a class="ae ky" href="https://spring.io/guides/gs/spring-boot/" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>发展</li><li id="15b6" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><a class="ae ky" href="https://spring.io/guides/tutorials/rest/" rel="noopener ugc nofollow" target="_blank">REST API</a></li><li id="47f6" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><a class="ae ky" href="https://maven.apache.org/what-is-maven.html" rel="noopener ugc nofollow" target="_blank"> Maven </a>依赖管理</li><li id="b408" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><a class="ae ky" href="https://maven.apache.org/guides/introduction/introduction-to-the-pom.html" rel="noopener ugc nofollow" target="_blank"> POM </a>文件</li><li id="9051" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><a class="ae ky" href="https://www.json.org/json-en.html" rel="noopener ugc nofollow" target="_blank"> JSON </a></li><li id="7cae" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">弹簧注释</li><li id="d490" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">DTO</li><li id="6752" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><a class="ae ky" href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html" rel="noopener ugc nofollow" target="_blank">应用属性</a></li><li id="bdf7" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">如何使用<a class="ae ky" href="https://spring.io/guides/gs/relational-data-access/" rel="noopener ugc nofollow" target="_blank"> JDBC </a>、<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html" rel="noopener ugc nofollow" target="_blank"> JdbcTemplate </a>等连接到数据库。</li></ul><p id="c249" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你愿意，你可以访问<a class="ae ky" href="https://www.devxperiences.com/pzwp1/2022/05/22/quick-intro-to-rest-api-development-with-spring-boot/#mysql-real-database-restapi" rel="noopener ugc nofollow" target="_blank">这篇文章</a>，它提供了关于如何开始使用Spring Boot、JDBC和MariaDB数据库来构建一个基本的REST API的非常基本的介绍。</p><p id="f488" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了您的方便，我们提供了GitHub repos。您可以将它们作为本文中每个案例的起点。</p><h1 id="fbc0" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">Hibernate验证程序依赖项</h1><p id="4014" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里我们将使用<a class="ae ky" href="https://hibernate.org/validator/documentation/getting-started/" rel="noopener ugc nofollow" target="_blank"> Hibernate Validator engine </a>依赖项(当我们使用<a class="ae ky" href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-validation" rel="noopener ugc nofollow" target="_blank">spring-boot-starter-validation</a>时，它也是一个编译的依赖项)。</p><p id="b68a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">因此，在我们的项目<code class="fe nt nu nv nw b">pom.xml</code>文件中，我们必须包含它，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="be8a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Hibernate validator为我们提供了一个很长的内置验证约束列表，由<a class="ae ky" href="https://beanvalidation.org/" rel="noopener ugc nofollow" target="_blank"> Jakarta Bean Validation </a>规范和其他附加约束定义。这些限制包括以下几类:</p><ul class=""><li id="a9e7" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">字段约束</li><li id="d7fd" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">属性约束</li><li id="4744" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">容器元素约束</li><li id="6458" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">类别约束</li></ul><p id="ea1b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">特别是对于内置的字段验证约束(所有字段约束都在Jakarta Bean验证API中指定)，您可以在这里找到完整的列表<a class="ae ky" href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-defineconstraints-spec" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="5bc1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">准备妥当</h1><h2 id="b661" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">自定义验证的简短介绍</h2><p id="0da0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">定义自定义约束验证主要包括为注释和验证器实现类创建一个自定义验证接口，它实际上实现了验证。</p><h2 id="daef" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">注释验证接口(约束注释)</h2><p id="6d07" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe nt nu nv nw b">@interface</code>关键字定义注释类型。注释接口的名称定义了注释本身，我们可以用它来进行验证(例如，在字段、bean或DTO中，或者在请求查询参数中)。在注释界面中，我们还可以定义一些其他参数:</p><ul class=""><li id="b04b" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated">目标(我们说过，<code class="fe nt nu nv nw b">FIELD</code>，<code class="fe nt nu nv nw b">PARAMETER</code>，<code class="fe nt nu nv nw b">CLASS</code>等)。)</li><li id="ef1b" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">保留策略</li><li id="6ac9" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">真正的行动——验证类</li><li id="f124" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">可以/应该与批注一起传递的值</li><li id="a5f9" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">验证失败时将返回的默认消息</li></ul><h2 id="249f" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">验证器实现类</h2><p id="01d8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">验证器实现类(按照惯例，通常与接口名同名)应该实现Jakarta Bean验证<a class="ae ky" href="https://docs.oracle.com/javaee/7/api/javax/validation/ConstraintValidator.html" rel="noopener ugc nofollow" target="_blank"> ConstraintValidator </a>接口。</p><p id="081c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nt nu nv nw b">ConstraintValidator</code>接口接受两个参数:注释接口和字段的类型(对象)或者它应该附加的参数。</p><p id="c084" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nt nu nv nw b">ConstraintValidator</code>接口的实现包括它定义的两个默认方法的实现:应该被覆盖的<code class="fe nt nu nv nw b"><a class="ae ky" href="https://docs.oracle.com/javaee/7/api/javax/validation/ConstraintValidator.html#initialize-A-" rel="noopener ugc nofollow" target="_blank">initialize()</a></code>和<code class="fe nt nu nv nw b"><a class="ae ky" href="https://docs.oracle.com/javaee/7/api/javax/validation/ConstraintValidator.html#:~:text=boolean-,isValid,-(T%C2%A0value%2C%20ConstraintValidatorContext" rel="noopener ugc nofollow" target="_blank">isValid()</a></code>方法。最后一个是做实际工作的，它返回一个布尔值，它应该总是返回:<code class="fe nt nu nv nw b">true</code>(验证成功)或<code class="fe nt nu nv nw b">false</code>(验证不成功)。</p><p id="036a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果你想更深入地创建自定义约束，你可以访问官方链接<a class="ae ky" href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-customconstraints" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="9933" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在是时候继续我们的实现案例了。</p><p id="e730" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在第1部分中，我们将看到一个用固定/静态数据创建自定义验证的例子(案例1)。我们将实际验证一个整数，它应该是一组预定义的整数值中的一个值(在一个整数数组中)。</p><p id="66c1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在下一部分(第2部分)，我们将继续一个例子(案例2)，为两个JSON字段(“master-details”)的组(组合)创建一个定制验证。但是这一次，我们将通过一个简单的存储库使用数据库表(MariaDB)提供的“动态数据”。注意，我们将只通过JdbcTemplate使用原始SQL和JDBC，而不使用任何ORM(没有JPA/Hibernate，等等)。).</p><h1 id="929a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">案例1:应该匹配给定数组中的一个值的整数自定义验证</h1><h2 id="b7f9" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">问题是</h2><p id="e54b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设您想要控制和验证一个特定的整数值，既不使用<code class="fe nt nu nv nw b">@Range</code>也不使用<code class="fe nt nu nv nw b">@Min</code> / <code class="fe nt nu nv nw b">@Max</code>内置的Hibernate约束验证器。但是你想要的是只允许一个，可以是数组中的任意整数。例如，您想检查JSON字段值中传递的整数是否是数组:<code class="fe nt nu nv nw b">{2, 17, 33, 5, 28}</code>中的整数之一。</p><h2 id="117c" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">项目回购</h2><p id="53e2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您可以随时使用您的Spring Boot项目，但是为了方便起见，您可以使用我的GitHub repo。所以，去GitHub抓取/克隆我的<a class="ae ky" href="https://github.com/zzpzaf/customvalidation1" rel="noopener ugc nofollow" target="_blank">开始回购</a>或者下载<a class="ae ky" href="https://github.com/zzpzaf/customvalidation1/archive/f2ba3dfc275999559342a3b8ef9cba7184b1f91d.zip" rel="noopener ugc nofollow" target="_blank">。zip </a>文件，然后在这里使用它。</p><p id="0921" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这只不过是一个非常简单的REST API，公开了一个名为“api/items”的端点，包含所有常用的CRUD操作:GET、POST、PUT、DELETE。这个项目只包含一个<code class="fe nt nu nv nw b">Controller</code>、一个<code class="fe nt nu nv nw b">Item</code>类和数据传输对象(DTO): <code class="fe nt nu nv nw b">ItemDTO</code>类。</p><p id="e912" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">文件夹结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/67e00d230f33769393aff5bb71f7f7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HVIJX8IqjyExUjy1.png"/></div></div></figure><p id="adff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">出于演示的目的，我们在<code class="fe nt nu nv nw b">Controller</code>中有一个<code class="fe nt nu nv nw b">Item</code>对象的预定义列表(<code class="fe nt nu nv nw b">ArrayList</code>)。为了简单起见，我们不使用单独的服务、存储库或持久数据库。</p><p id="40e2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们将继续使用<code class="fe nt nu nv nw b">ItemDTO</code>类来验证它的属性/字段，在这种情况下使用我们的自定义验证。</p><p id="6d2a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个<code class="fe nt nu nv nw b">Item</code>对象由几个属性/字段组成，ItemDTO拥有除<code class="fe nt nu nv nw b">itemId</code>之外的所有属性/字段。您可以自己浏览上述类中的简单代码。</p><p id="cfc1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如您在下面看到的，我们已经使用了一些内置的验证约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5511" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这些是:</p><p id="d656" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nt nu nv nw b">@NotNull</code>、<code class="fe nt nu nv nw b">@Range</code>、<code class="fe nt nu nv nw b">@Positive</code>和<code class="fe nt nu nv nw b">@Digits</code>分别用于属性<code class="fe nt nu nv nw b">itemName</code>、<code class="fe nt nu nv nw b">itemModelYear</code>和<code class="fe nt nu nv nw b">itemListPrice</code>。注意，Hibernate为每个注释提供了默认消息。然而在上面，我们用我们自己的。</p><p id="8cd8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们可以在任何请求中使用<code class="fe nt nu nv nw b">@Valid</code>注释来强制Spring验证它们。下面，我们用它来处理<code class="fe nt nu nv nw b">ProductsController</code>中的一个<code class="fe nt nu nv nw b">POST</code>请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="f7a3" class="mt la it bd lb mu mv dn lf mw mx dp lj ma my mz ll me na nb ln mi nc nd lp ne bi translated">测试到目前为止的验证</h2><p id="fff5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<a class="ae ky" href="https://learning.postman.com/docs/getting-started/introduction/" rel="noopener ugc nofollow" target="_blank"> Postman </a>，我们可以尝试发送一个带有空JSON主体的POST请求，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/ef1ebee9c57a83898389b1d675ead734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xajB1sKjhH45mad9.png"/></div></div></figure><p id="c038" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">并查看我们得到的所有错误消息，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><blockquote class="oa ob oc"><p id="9747" class="lr ls od lt b lu mn ju lw lx mo jx lz oe mp mc md of mq mg mh og mr mk ml mm im bi translated">请注意，消息的响应结构是默认提供的，因为我们在这里没有使用任何定制的错误处理。</p></blockquote><h1 id="c93b" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">自定义验证的实现</h1><p id="8668" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们还没有使用任何约束验证的唯一属性/字段是<code class="fe nt nu nv nw b">itemVendorId</code>，正如您所猜测的，这是我们这里自定义验证的目标。</p><p id="e89b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">让我们将我们的自定义注释命名为<code class="fe nt nu nv nw b">OneOfIntegers</code>。因为我们想保持我们的项目结构良好，我们可以创建一个新的项目文件夹/包，命名为"<code class="fe nt nu nv nw b">alidators",</code>，并在其中创建<code class="fe nt nu nv nw b">OneOfIntegers</code>注释接口。</p><p id="9678" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nt nu nv nw b">OneOfIntegers</code>约束标注界面如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="dd88" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">该接口可以用许多元注释进行注释。下面是我们在这里使用的内容的简短说明:</p><ul class=""><li id="a508" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated"><code class="fe nt nu nv nw b">@Target</code>元注释定义了注释目标将使用的元素类型。在我们的例子中，这个注释的目的是与字段(例如，dto的字段或属性)和/或参数(通过端点URL传递的字符串查询参数)一起使用。</li><li id="58fc" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe nt nu nv nw b">@Retention</code>元注释定义了我们的注释将通过反射在运行时可用。</li><li id="44f3" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe nt nu nv nw b">@Documented</code>元注释定义了我们的注释将包含在用它注释的元素的JavaDoc中。</li><li id="8a6e" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">并且<code class="fe nt nu nv nw b">@Constraint(validated by…)</code>元注释定义了应该用来执行验证的实际工作的类。在我们的例子中，这是<code class="fe nt nu nv nw b">OneOfIntegersValidator</code>类(下面，你会看到它的方法之一是<code class="fe nt nu nv nw b">isValid</code>布尔方法，它返回<code class="fe nt nu nv nw b">true</code>或<code class="fe nt nu nv nw b">false</code>)。</li></ul><p id="84d3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">除了上述内容，我们还必须提供以下三个强制属性:</p><ul class=""><li id="a354" class="nf ng it lt b lu mn lx mo ma nh me ni mi nj mm nk nl nm nn bi translated"><code class="fe nt nu nv nw b">Message</code>属性返回作为默认错误消息提供的字符串。如您所见，这里的消息是“整数值无效”我们还可以为注释字段提供一个定制消息，它可以像内置约束验证一样应用:<code class="fe nt nu nv nw b">itemName</code>、<code class="fe nt nu nv nw b">itemModelYear</code>和<code class="fe nt nu nv nw b">itemListPrice </code>字段。(我们稍后会看到)。</li><li id="fb63" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated"><code class="fe nt nu nv nw b">Group</code>属性，如果注释属于一组注释，我们可以定义这个属性。默认应该是一个类型为<code class="fe nt nu nv nw b">Class&lt;?&gt;</code>的空数组。</li><li id="8d26" class="nf ng it lt b lu no lx np ma nq me nr mi ns mm nk nl nm nn bi translated">属性可以用来为我们的约束定义定制的有效负载对象。默认也应该是一个类型为<code class="fe nt nu nv nw b">Class&lt;?&gt;</code>的空数组。</li></ul><p id="6237" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面也给出了<code class="fe nt nu nv nw b">OneOfIntegersValidator</code>约束验证器类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7e26" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">约束验证器应该实现<code class="fe nt nu nv nw b">ConstraintValidator</code>接口，并将约束注释接口— <code class="fe nt nu nv nw b">OneOfIntegers</code>作为参数传递给它。它还将使用这个接口作为将要应用约束的字段或参数的类型(在我们的例子中，这是一个整数)。</p><p id="2cdb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们要做的是覆盖/实现<code class="fe nt nu nv nw b">isValid()</code>方法，该方法返回一个布尔值，即<code class="fe nt nu nv nw b">true</code>表示验证成功，或者<code class="fe nt nu nv nw b">false</code>表示验证不成功。</p><p id="7c80" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们必须使用一个整数数组来保存我们可接受的值，在我们的例子中是<code class="fe nt nu nv nw b">{2, 17, 33, 5, 28}</code>。最后，我们检查传入的整数值是否包含在该数组中，并返回<code class="fe nt nu nv nw b">true</code>或<code class="fe nt nu nv nw b">false</code>。最后，我们准备在我们的DTO类(<code class="fe nt nu nv nw b">itemDTO.java</code>)中注释<code class="fe nt nu nv nw b">itemVendorId</code>字段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="7120" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样！让我们通过邮递员测试一下。这次我们在POST请求中使用JSON body对象。<code class="fe nt nu nv nw b">vendorId</code>的值为<code class="fe nt nu nv nw b">3</code>，因此我们预计验证不会成功。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/43afd2a90e9774a88a636375e12f0711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uRXRaB99c-AKr42N.png"/></div></div></figure><p id="aa06" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如你所见，这是不成功的。正如我们所料。</p><h1 id="08c2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">丰富</h1><p id="9a4e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，一切顺利。然而，在我们的自定义验证器中使用固定数组并不是一个好方法，因为我们总是针对同一个数组来验证任何DTO中的任何其他字段。幸运的是，我们可以尽快修好它。</p><p id="6ff0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先，我们必须通知我们的自定义验证接口，我们将在自定义注释中使用一个整数值数组。我们通过将名为<code class="fe nt nu nv nw b">Values</code>的属性定义为整数数组来实现这一点。</p><p id="8f9f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是我们的自定义注释界面的外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/66b671e9879a287a4a13e0f164e77c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v0VFSTsWrNiHpHYm.png"/></div></div></figure><p id="88a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">之后，我们必须将带有值的整数数组放入我们的自定义验证器。为此，我们必须覆盖/实现<code class="fe nt nu nv nw b">ConstraintValidator</code>接口的initialize()方法。这个方法将annotation接口作为一个参数，这样，我们就可以访问传入的值(整数数组)。</p><p id="de2b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">自定义验证程序发生变化，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/2637f246e7ac4a8cb020f04799b7b3d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kLeceXYB3zCO4QiB.png"/></div></div></figure><p id="394f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">干得好！现在我们可以在<code class="fe nt nu nv nw b">ItemDTO</code>的<code class="fe nt nu nv nw b">itemVendorId</code>字段上使用带有自定义注释的示例整数数组(或者我们想要的任何其他数组)。它看起来像下面这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/16b9287de0471a701cf515862d50118f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ooxJy5cFEv21-iIj.png"/></div></div></figure><p id="1d7c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">之后可以用Postman测试一下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/98f1b6afe6bbdb8da4f3cdce314f42b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aaZ4_6ApdaOZWAeX.png"/></div></div></figure><p id="3a1d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以做的最后一项改进是使用Hibernate提供的<a class="ae ky" href="https://beanvalidation.org/2.0/spec/#validationapi-message" rel="noopener ugc nofollow" target="_blank">消息插值</a>功能，并在我们的自定义消息中显示数组值。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="12d3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这是我们得到的(通过邮递员):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/53641bbdf24ce152bb28d83cf834d348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jEA0dq1E2yf2GrNM.png"/></div></div></figure><p id="f21e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当您决定使用自定义错误消息处理时，这可能会很有用。</p><p id="feb7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">就是这样！你可以在这里下载这个例子<a class="ae ky" href="https://github.com/zzpzaf/customvalidation1/archive/2582faf59bcafe850c2792941f28158e760966f3.zip" rel="noopener ugc nofollow" target="_blank">的最终代码。</a></p><p id="e3a1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以在这里找到第2部分:</p><div class="oh oi gp gr oj ok"><a rel="noopener  ugc nofollow" target="_blank" href="/custom-validation-in-spring-boot-best-explained-part-2-f99bfb4e66a4"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">通过案例解释Spring Boot的自定义验证，第2部分</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">案例2——使用数据库实现“主-细节”验证</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">better编程. pub</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>