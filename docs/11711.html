<html>
<head>
<title>Jetpack Compose with Lifecycle-Aware Composables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack由生命周期感知组件组成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/jetpack-compose-with-lifecycle-aware-composables-7bd5d6793e0?source=collection_archive---------4-----------------------#2022-04-11">https://betterprogramming.pub/jetpack-compose-with-lifecycle-aware-composables-7bd5d6793e0?source=collection_archive---------4-----------------------#2022-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eda1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">可组合和视图生命周期之间的桥梁</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e1572b2c3e3dad30b258bfc1f890e498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*c29nadJv0btwT0gX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@zakariahada?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Zakaria Ahada </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="eb00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有Android背景，你应该熟悉生命周期的概念。Jetpack Compose引入了一种新的范式来使用组件构建声明性UI。它们具有简化的生命周期，包括三个阶段:</p><ul class=""><li id="97bc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">进入阶段。</li><li id="b93a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">重组阶段。</li><li id="f845" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">退出阶段。</li></ul><p id="fbdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">官方文档详细描述了一个可组合组件在其整个生命周期中的行为。</p><p id="7e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可能会认为可组合组件的生命周期取代了视图的生命周期。尽管命名是一致的，但我们谈论的是两个不同的概念。</p><p id="7f92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，即使您构建了一个纯粹的组合应用程序，您的组合可能需要与视图的生命周期进行交互。如果当应用程序出现在前台时，您有一个刷新一些数据的可组合组件，就会出现这种情况。</p><p id="e411" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，可组合组件对视图的生命周期一无所知。你需要在这两个世界之间架起一座桥梁，将这种意识带给你的组件。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="3a2a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">恢复的可组合用例</h1><p id="161f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">让我们假设我们正在构建一个纯Compose应用程序。包括一个可组合的屏幕。这个屏幕注入一个视图模型——例如通过Hilt来获取产品。我们会有下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="69fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ViewModel在创建时启动一个协程，并将获取操作委托给存储库。</p><p id="0622" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们想在用户每次显示此屏幕时刷新我们的产品。当用户进入后台并重新进入前台时会发生这种情况——前提是系统没有关闭应用程序。或者，如果您想导航到不同的屏幕，则导航回<code class="fe nk nl nm nn b">ProductsScreen</code>。</p><p id="249a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您很快就会意识到我们的示例代码不能满足我们的需求。提取仅在可组合文件第一次出现时有效。这是因为当可组合组件退出组合树时，ViewModel取消了协程，但是当重新进入组合阶段时，ViewModel不会重新启动它。</p><p id="b06b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种解决方案是依靠可组合组件的进入阶段来获取您的产品。您可以从ViewModel中公开fetch方法，并从Composable中调用它。记住使用副作用调用这个方法。否则，您将不仅在可组合对象变得可见时获取您的产品，而且在它的状态将改变的每次重组时获取您的产品！</p><p id="5ebb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在可组合组件进入其组合阶段时调用它一次，您可以使用一个<code class="fe nk nl nm nn b">LaunchEffect</code>和<code class="fe nk nl nm nn b">Unit</code>作为键——或<code class="fe nk nl nm nn b">true</code>,只要它在组合期间不改变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="329d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，我们还没有检查所有的方框。使用进入阶段将帮助我们在导航回此屏幕时更新我们的产品。当用户将应用程序放在后台时，情况就不一样了。</p><p id="7b30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">区分Composable和View的生命周期是如何工作的很重要。但是理解你可以把它们结合起来也是很有价值的。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="69f1" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">将视图的生命周期带入一个组合世界</h1><p id="9ada" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在纯Compose应用程序中，您必须创建一个活动作为入口点。我们可以依靠它来获取视图的生命周期，并将其传递给我们的可组合组件。</p><p id="a14a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是将一些事件从持有活动传递到可组合活动变得很乏味。尤其是当你有几个父母的时候。幸运的是，我们可以直接让任何组件感知生命周期。</p><p id="3bf7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不熟悉Android中的生命周期感知组件，我已经在本文的<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/empowered-lifecycle-aware-viewmodel-for-android-f495de9a8170">中介绍了一个类似的用例。</a></p><p id="0755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似的配置适用于Jetpack Compose。但是有一种更聪明、更“像作曲”的方式来实现它。每个可组合组件公开了当前的生命周期所有者，您可以在其中检索视图的生命周期。使用一个<code class="fe nk nl nm nn b">DisposableEffect</code>副作用，您可以存储视图生命周期的最新事件并对其做出反应，同时在可组合组件退出组合树时安全地分离其观察者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="44e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果更多的组件能够感知生命周期，那么所有这些都会很快变成样板文件。我们可以编写一个可组合的扩展方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f64d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这种配置，您可以用几行额外的代码对视图的生命周期做出反应。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="fecc" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">Jetpack合成的生命周期感知视图模型</h1><p id="5d6f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在之前链接的文章中，我提到了ViewModel在应用程序可伸缩性中的重要作用。尤其是当一些业务逻辑与视图的生命周期紧密相关时。</p><p id="5cac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Compose并不能免除您这样做——即使它使关注点的分离更容易。</p><p id="fcc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用上面的解决方案，视图仍然负责对生命周期事件做出反应，并请求获取视图模型。理想情况下，ViewModel应该负责这个问题。</p><p id="1fa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用相同的技术，我们创建另一个可组合的扩展方法，让任何<code class="fe nk nl nm nn b">LifecycleOwner</code>观察视图的生命周期。然后，我们让ViewModel实现<code class="fe nk nl nm nn b">DefaultLifecycleObserver</code>接口。我们可以将所有的逻辑移到视图模型中！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="abbf" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">包扎</h1><p id="5d76" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们已经看到，对于一个简单的用例，仅仅依靠可组合组件的生命周期是不够的。使用生命周期感知组件库和一个<code class="fe nk nl nm nn b">DisposableEffect</code>，您可以将生命周期事件转移到视图模型。</p><p id="0f9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，与我之前的文章相比，测试过程保持不变。这意味着我们可以保持生命周期感知的视图模型逻辑，不管它是由视图还是可组合的组件注入的。只有生命周期绑定有所不同——用扩展方法组合更简单！</p><p id="0644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这将有助于您在迁移到Jetpack Compose的过程中减轻对代码的影响。编码快乐！</p></div></div>    
</body>
</html>