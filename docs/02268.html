<html>
<head>
<title>How To Run a Proxy Server Inside Your Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在浏览器中运行代理服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-run-a-proxy-server-inside-your-browser-8b96ea2ef1ea?source=collection_archive---------9-----------------------#2019-11-18">https://betterprogramming.pub/how-to-run-a-proxy-server-inside-your-browser-8b96ea2ef1ea?source=collection_archive---------9-----------------------#2019-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b531" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">您甚至不需要本地后端—只需要一名服务人员</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/00047f62313077e15579c4f0103bd59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lR29WBk9e578Qo_u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jannerboy62?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼克·费因斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="85ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我调试我最近开发的一个视频聊天应用程序时，我不得不在本地运行整个链条。这意味着在本地运行前端——以及与之通信的两个REST APIs，它们都是用Java编写的。</p><p id="33f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我不是Java开发人员，所以让这两个API在我的开发机器上运行是一个挑战。最重要的是，我在一个公司代理后面，这个客户要求我在他们提供的Windows机器上工作。</p><p id="424c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我太幸运了。</p><p id="78c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通常使用Node.js后端，它运行和配置起来要容易得多，但即使是这样，安装和运行起来也会很麻烦。运行一个本地web服务器来为您的前端服务是非常容易的，但是当涉及到代理甚至提供模拟响应时，事情很快就变得复杂了。</p><p id="297a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，如何在没有任何后端的情况下在浏览器中运行代理服务器呢？</p><p id="fdeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输入服务人员。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c20e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一场静悄悄的、被低估的革命</h1><p id="adef" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">出于某种原因，服务人员从来没有像React和Redux那样令人兴奋。它们并没有真正的联系，但是它们对前端开发的影响是深远的。</p><p id="b7b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务工作者通常与渐进式web应用程序结合使用，并允许拦截进出网站的所有网络流量。</p><p id="e123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着你可以拦截你的应用程序发出的任何请求，并以你想要的任何方式响应它。</p><p id="8d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务人员的主要用例是使网站离线工作，但是因为您可以拦截网络流量，所以您也可以使用它来运行代理服务器或提供模拟响应，就在您的浏览器中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e1b9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">它是如何工作的</h1><p id="579d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每当您的网站发出请求时，就会在服务人员上分派一个<code class="fe mz na nb nc b">fetch</code>事件。在其事件处理程序中，您可以检查请求并采取适当的措施:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="849c" class="nh md it nc b gy ni nj l nk nl">self.addEventListener('fetch', e =&gt; {<br/>  console.log('request: ', e.request);<br/>});</span></pre><p id="07c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">FetchEvent</code>的<code class="fe mz na nb nc b">request</code>属性包含制作的<code class="fe mz na nb nc b">Request</code>。您可以检查请求的URL和方法(也许还有标题),以确定它是哪种请求。基于此，您可以创建一个<code class="fe mz na nb nc b">Response</code>,并将其发送回用户。</p><p id="c12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将响应发送回用户，我们使用了<code class="fe mz na nb nc b">FetchEvent</code>的<code class="fe mz na nb nc b">respondWith</code>方法，该方法将一个<code class="fe mz na nb nc b">Promise</code>解析为一个<code class="fe mz na nb nc b">Response</code>。</p><p id="3d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您想在用户离线时为来自您网站的每个请求提供某种错误页面，您可以这样做:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="988d" class="nh md it nc b gy ni nj l nk nl">self.addEventListener('fetch', e =&gt; {<br/>  e.respondWith(Promise.resolve(<br/>    new Response('&lt;h1&gt;Offline&lt;/h1&gt;', {<br/>      status: 200,<br/>      statusText: 'OK',<br/>      headers: {<br/>        'Content-type': 'text/html'<br/>      }<br/>    })<br/>  ))<br/>});</span></pre><p id="da9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Response</code>构造函数将一个响应体作为它的第一个参数，它可以是字符串、blob或buffer等等，将一个<code class="fe mz na nb nc b">init</code>对象作为它的第二个参数，它可以包含一个<code class="fe mz na nb nc b">status</code>、<code class="fe mz na nb nc b">statusText</code>和<code class="fe mz na nb nc b">headers</code>对象。</p><p id="bee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让你有能力以任何你想要的方式回应来自你的网站的任何请求。</p><h2 id="c38d" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">服务工作者作为代理服务器</h2><p id="4ed7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您有一个调用位于<code class="fe mz na nb nc b">https://api.your.domain/api/v1/*</code>的REST API的应用程序，您需要将所有流量代理到位于<code class="fe mz na nb nc b">https://api.your.domain/api/<strong class="lb iu">v2</strong>/*</code>的新版本API。</p><p id="382e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用服务工作器来检查请求的URL，并在它是对旧版本API的调用时代理它:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3c19" class="nh md it nc b gy ni nj l nk nl">self.addEventListener('fetch', e =&gt; {<br/>  const {url} = e.request;</span><span id="8755" class="nh md it nc b gy nx nj l nk nl">  if(url.includes('https://api.your.domain/api/v1/') {<br/>    const newUrl = url.replace('/api/v1/', '/api/v2/');</span><span id="66db" class="nh md it nc b gy nx nj l nk nl">    e.respondWith(fetch(newUrl));<br/>  }<br/>});</span></pre><p id="4a6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们只是检查URL，看它是否包含旧版本API的路径，如果包含，我们用新路径替换旧路径，向新URL发出请求，并返回响应。</p><p id="bec8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用相同的方法将请求转发到完全不同的域，例如，将本地运行的API的请求转发到在测试环境中运行的API。</p><p id="f536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的代理服务器，但是您可以想象您可以创建一些非常复杂的逻辑来进行更高级的代理。</p><h2 id="e57a" class="nh md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">作为模拟服务器的服务工作者</h2><p id="11ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个更有趣的用例是使用一个服务工作者作为模拟服务器。这在用REST API测试前端时特别有用，因为REST API可能还不可用，甚至还没有完全开发出来，或者在运行单元测试时特别有用。服务工作者将再次拦截针对API的请求，并提供预定义的模拟响应。</p><p id="d5d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模仿响应可能特别麻烦，因为这意味着运行和维护某种后端只是为了获得正确的响应。当涉及到多个API时，这可能意味着在测试感兴趣的前端之前要运行多个终端窗口。</p><p id="bcd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一个服务人员作为模拟服务器意味着只需启动前端应用程序就可以得到您需要的一切。</p><p id="b007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你有一个博客，你从一个API获取帖子。然后你可以这样嘲笑对方的回答:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="95ef" class="nh md it nc b gy ni nj l nk nl">const postings = [<br/>  {<br/>    id: 12345, <br/>    title: '...', <br/>    body: '...'<br/>  },<br/>  {<br/>    id: 56789, <br/>    title: '...', <br/>    body: '...'<br/>  },<br/>  ...<br/>];</span><span id="6cb0" class="nh md it nc b gy nx nj l nk nl"><br/>self.addEventListener('fetch', e =&gt; {<br/>  const {url} = e.request;</span><span id="32ba" class="nh md it nc b gy nx nj l nk nl">  if(url.includes('/blogpostings') {<br/>    e.respondWith(<br/>     Promise.resolve(new Response(<br/>       JSON.stringify(postings), {<br/>         headers: {<br/>           'Content-Type': 'application/json'<br/>         }<br/>       }))</span><span id="b256" class="nh md it nc b gy nx nj l nk nl">    )<br/>  }<br/>});</span></pre><p id="22cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只需定义一个发布对象数组，并将其作为JSON响应。</p><p id="329b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的示例只是提供了一个预定义的响应，但是在实际的应用程序中，您可能会根据请求的URL和方法在配置文件中查找请求，然后决定将什么作为响应。</p><p id="d3e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这样的文件中指定所有类型的响应。例如:</p><ul class=""><li id="f1d6" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">JSON响应(如上例所示)</li><li id="563a" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">错误，如404或500</li><li id="1c62" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">文件—例如，模拟下载</li><li id="58ff" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">重新寄送</li><li id="5d95" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">延迟响应—例如，模拟延迟</li></ul><p id="3c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的好处是，您只需要维护一个包含从请求到响应的映射的配置文件。</p><p id="0f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不再需要运行和维护后端—只需添加服务人员，您就可以开展业务了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c86f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">如何实现这一切</h1><p id="c41d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://github.com/DannyMoerkerke/sw-proxy" rel="noopener ugc nofollow" target="_blank">我创建了一个repo，其中包含一个服务人员，负责处理所有这些事情</a>。它包含一个带有说明的自述文件和一个包含各种使用案例的演示页面。</p><p id="79a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这能鼓励你使用服务人员的全部能力，比如缓存、推送通知，甚至让你的网站离线工作。</p><p id="aa81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务工作者是对JavaScript的巨大补充，在所有主流浏览器中都得到支持。没有理由不在你的应用中使用。</p></div></div>    
</body>
</html>