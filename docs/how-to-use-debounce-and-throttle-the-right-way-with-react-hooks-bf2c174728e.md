# 如何使用反作用钩子去抖和节流

> 原文：<https://betterprogramming.pub/how-to-use-debounce-and-throttle-the-right-way-with-react-hooks-bf2c174728e>

## 小心点！你可能做错了

![](img/cdc34a778703fdc3898dfa341038ee15.png)

由[画框 Harirak](https://unsplash.com/@framemily?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照。

去抖动和节流是我们在试图优化函数调用时遇到的两个非常常见的术语。它们对于提高用户交互的性能非常有用。

在进入主实现之前，让我们了解一下`debounce`和`throttle`的基本概念以及它们的真实用例(如果您已经熟悉这些概念，请跳过)。

# **什么是去抖？**

去抖动强制在函数调用的两次连续调用之间存在最小时间间隔。

例如，500 毫秒的`debounce`间隔意味着如果从上一次调用尝试到现在还没有过 500 毫秒，我们就取消上一次调用，并安排在 500 毫秒后进行下一次调用。

`debounce`的一个常见应用是`Typeahead`。

# **什么是节流？**

节流是一种技术，无论用户尝试调用多少次，函数在给定的时间范围内最多被调用一次。

例如，给定一个 500ms 的`throttle`间隔，如果我们试图在 500ms 内调用一个函数 *n 次*，当从开始算起已经过去 500ms 时，这个函数只被调用一次。

`Throttle`常用于`resize`或`scroll`事件。

# 对类组件使用去抖和节流

在我们深入研究如何在带有钩子的功能组件中使用`throttle` / `debounce`之前，让我们快速地看一下如何在类组件中使用。

我们在构造函数中定义了函数的去抖/节流版本，这就是我们需要做的。

*注:我在本文中使用的是 lodash* `*debounce*` *和* `*throttle*` *函数。*

请查看下面 StackBlitz 中的示例演示:

# 在功能组件中使用去抖和节流

我们将尝试把基于类的实现转换成基于函数的方法。

首先想到的是在功能元件中直接定义去抖和节流功能。所以让我们先试试:

当我们这样做时，在组件的每个渲染周期，创建一个去抖动/节流功能的新实例。基本上我们不会在每次重新渲染后调用相同的函数，它不会像预期的那样工作，你可以在下面的 StackBlitz 演示中看到这一点:

在功能组件中直接定义去抖/节流

所以这绝对不是功能组件中使用`debounce` / `throttle`的正确方式。

# **根据我们的学习改进我们的实施**

既然我们知道我们不希望在每个渲染周期后都创建多个去抖或节流函数的实例，我们将尝试优化它。我们可以这样做的一个方法是使用`useCallback`钩。

根据上的[反应文件](https://reactjs.org/docs/hooks-reference.html#usecallback)`[useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)`:

> "传递一个内联回调和一组依赖项。`useCallback`将返回回调的记忆化版本，只有当其中一个依赖关系发生变化时，该版本才会发生变化

在上面的代码片段中，我们看到`onChange`处理程序利用了封闭状态`inputValue`。所以当我们用`useCallback`创建记忆去抖函数时，我们在`useCallback`的依赖数组中传递`inputValue`。否则，由于闭包，在函数调用中获得的值将是陈旧的值，而不是更新的值。

但是，我们有一个问题:只有当`inputValue`改变时，我们的函数的新引用才会被创建。然而，每次我们想调用函数时，输入值都会改变，所以我们仍然会面临创建新引用的问题。最终的结果是我们的函数仍然不能像预期的那样工作。

throttled 函数本身不使用任何状态或封闭变量，因此可以很好地处理空的依赖数组。

下面的 StackBlitz 显示了相同的行为:

将 useCallback 和 state 作为依赖项的去抖

# 进一步优化方法

我们现在知道，如果我们能够仅在初始渲染时创建去抖动或节流函数的实例，那么`useCallback`会有所帮助，那么我们是否可以在不添加对`useCallback`的依赖的情况下解决陈旧闭包的问题呢？

嗯，你很幸运。答案是肯定的。

我们至少有两种方法可以解决这个问题。

*   在`ref`中保存我们状态的副本:由于`refs`发生了变异，它们并没有真正受到闭包的影响，即使引用是旧的，我们仍然可以看到更新的值。所以每当我们更新状态时，我们也更新了`ref`。除非万不得已，否则我们不会走这条路，因为这有点麻烦，而且涉及大量的状态重复，这并不理想。
*   将值作为参数传递:我们可以将函数需要的所有必要值作为参数传递，而不是依赖闭包来使用值。

我们的代码如下所示:

正确使用带挂钩的油门和去抖

在上面的代码中，我们将`inputValue`作为一个参数传递给去抖函数，从而确保它拥有所需的所有最新值，并且能够顺利工作。

*注意:使用功能状态更新也有助于避免传递每个属性——尤其是如果它只需要更新状态的话。*

查看下面 StackBlitz 中的完整工作代码:

正确的方法来使用反作用钩去抖和油门

所以我们有它。我们的去抖和节流功能现在也可以很好地与功能组件一起工作，并且没有我们想象的那么复杂。

*注意:代替* `*useCallback*` *，我们也可以使用* `*useMemo*` *，但是主要的方法逻辑将保持不变。*

# 摘要

我们使用带有 React 钩子的`debounce`一步一步地将类组件转换成功能组件。这些是关键要点:

*   我们需要尽可能多地使用创建的函数的同一个实例。
*   使用`useCallback/useMemo`钩子来记忆我们创建的函数。
*   为了避免闭包问题并防止函数被重新创建，我们可以将函数所需的值作为参数传递。
*   需要先前值的状态更新可以使用`setState`的函数形式实现。