<html>
<head>
<title>A Practical Introduction to Big O</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大O实用介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-practical-introduction-to-big-o-a9f9c416aaaf?source=collection_archive---------5-----------------------#2019-08-19">https://betterprogramming.pub/a-practical-introduction-to-big-o-a9f9c416aaaf?source=collection_archive---------5-----------------------#2019-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c007" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不用数学术语来表达算法的效率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5dbe0501c990c17e47b1b37d344f85bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnR5t8cFAyjuxXFd_Viiqg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jeshoots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae ky" href="https://unsplash.com/search/photos/maths?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="dd16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当“大O”这个词被提起时，你可能会联想到你可能在大型科技公司遇到的算法测试。</p><p id="70db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是真的，但它不应该被用作完全跳过软件开发如此重要的一个方面——代码如何运行——的理由。</p><p id="11c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用通俗的话来说，我们将讨论大O实际上是什么，为什么您应该关心它，以及您如何着手评估某些代码段的大O是什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e64" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是大O？</h1><p id="9a10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大O是一个已经在编程世界中被接受的概念，在编程世界中，我们可以表达一个算法有多高效，而不必通过推导复杂的数学表达式的方式。</p><p id="d3cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们面对现实吧，并不是所有的开发人员都吃数学、睡数学、呼吸数学。</p><p id="fba3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会面临这样的问题:“为什么我不能看到我的本地机器处理代码需要多长时间？”</p><p id="fcce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查您的代码在您的机器上运行的速度并不是您的代码总体运行速度的最佳决定因素，因为不同的用户将处于不同的环境中。</p><p id="3491" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们需要一个指标来描述一个东西运行的有多快，不管它实际运行在什么环境中。这就是大O的用处。</p><p id="9503" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到大O，我们可以指代码的运行时复杂度，也可以指空间复杂度(内存)。哦，作为免责声明，我将互换使用复杂性和效率这两个词。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1537" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么要在乎大O？</h1><p id="18c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在日常场景中，过分关注您正在处理的代码的复杂性可能有点不现实。你的工作也可能不需要你知道这些信息。</p><p id="0cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，理解Big O允许您确定解决问题的不同方法的优点和缺点，并允许与其他开发人员创建对话来讨论这样的权衡。</p><p id="30cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着您继续研究不同的算法，您将会看到时间与空间的权衡。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b322" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">评估大O</h1><p id="aa46" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这里有一些你应该熟悉的常用术语。这些大O项按照从最快到最慢的顺序排列:</p><ol class=""><li id="dfd9" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">O(1) —常数</li><li id="b1e3" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">O(log n) —对数</li><li id="c5f1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">O(n) —线性</li><li id="c989" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">O(n log n) — n log n</li><li id="b862" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">O(n ) —二次</li><li id="3255" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">O(n ) —立方</li><li id="224a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">O(2^n) —指数</li><li id="81b0" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">O(n！)—阶乘</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/aeba87132bdccb721821f680de7eb486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06uXThuI9EaN8LnJvNWZWw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大O时间复杂度图—【https://www.bigocheatsheet.com/ T4】</p></figure><p id="9599" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大O运行时是高度一般化的。我们通常默认使用变量<code class="fe no np nq nr b">n</code>作为算法接收的输入。尽管我们永远不会确切知道输入的大小，但我们必须假设它非常大。</p><p id="8d44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们对一个代码块进行最昂贵的计算，并以此为基础提高算法的效率。</p><p id="cfb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文的结尾，我们将能够创建一个表达式，它包含某个代码块中大多数计算的运行时。</p><p id="54af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们可能会看到的示例表达式:</p><p id="f4e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">O(n) + O(n^2) + O(1)</code></p><p id="014f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个表达式中，我们取代价最大的运行时，称之为算法的大O运行时。在这个假想的例子中，运行时间是<code class="fe no np nq nr b">O(n²)</code>，因为在给定的表达式中，计算将花费最多的时间。</p><p id="88b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是等等…这个例子中的<code class="fe no np nq nr b">n</code>是什么？当指定一个运行时，澄清<code class="fe no np nq nr b">n</code>指的是什么同样重要。在这个例子中，我们可以这样说:“运行时间将是<code class="fe no np nq nr b">O(n²)</code>，其中<code class="fe no np nq nr b">n</code>是我们的输入数组的长度”。</p><p id="5adf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通俗地说，我们可以说那个大O是一种在给定<code class="fe no np nq nr b">N</code>输入的情况下衡量某物表现的方式。</p><p id="f7aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理大O的另一个经验法则是:我们在表达式中去掉常数。例如，<code class="fe no np nq nr b">O(n) + O(n) + O(n)</code>会变成<code class="fe no np nq nr b">O(3n)</code>，但我们实际上从未声称我们的运行时是<code class="fe no np nq nr b">O(3n)</code>。相反，我们简单地称它为<code class="fe no np nq nr b">O(n)</code>。</p><p id="7e1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们对不同的复杂性有了基本的了解，让我们检查一些常见的运行时，看看它们在代码中是什么样子的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b40c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(1)复杂度</h1><p id="d0da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这指的是持续的操作。换句话说，不管我们的输入<code class="fe no np nq nr b">N</code>有多大，这个操作仍然会做固定量的工作。考虑下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/07214ccc9e9593ec008355b0d9be7f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*1oyaURkFb0aXZHZFe4v2Bg.png"/></div></figure><p id="fe51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论我们的输入是大是小，我们仍然在做固定量的工作，占用固定量的内存。因此，该<code class="fe no np nq nr b">add()</code>函数将具有<code class="fe no np nq nr b">O(1)</code>的运行和空间复杂度。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d80f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(n)复杂度</h1><p id="4939" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这种复杂性指的是线性操作。因此，无论<code class="fe no np nq nr b">n</code>被定义为什么，我们的运行或空间复杂度都与<code class="fe no np nq nr b">n</code>成正比。让我们看一个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/e27f1031bf727c9b6764eb9d286f4b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QIBJ_eIgyW2uuvef3jaIDg.png"/></div></div></figure><p id="7aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个算法的时间和空间复杂度都是<code class="fe no np nq nr b">O(n)</code>，其中<code class="fe no np nq nr b">n</code>是我们的输入数组的大小。</p><p id="c317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？对于空间，我们在内存中创建一个新的数组，它与n的长度成正比。如果我们不创建这个数组，我们会有一个<code class="fe no np nq nr b">O(1)</code>空间复杂度。</p><p id="4ca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于时间，我们迭代<code class="fe no np nq nr b">n</code>元素。由于这不是一个固定的数量(与<code class="fe no np nq nr b">n</code>的大小成比例)，我们说它有一个<code class="fe no np nq nr b">O(n)</code>复杂度，因为这个for循环是我们最重的计算。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2999" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(n)复杂度</h1><p id="46b3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe no np nq nr b">O(n²)</code>算法最常见于两个嵌套的for循环中，我们迭代相同的长度。考虑下面的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/24d8e9c00683b9db82fd2c3478172aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gngAdovUAAD66fxINACGg.png"/></div></div></figure><p id="e98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了清楚起见，我们举一个简单的例子来定义<code class="fe no np nq nr b">n = [1,2,3,4,5]</code>。</p><p id="dc6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe no np nq nr b">i</code>中的每次迭代，我们在嵌套的For循环中遍历整个数组。使得当<code class="fe no np nq nr b">i = 0</code>和<code class="fe no np nq nr b">j = 0</code>时，<code class="fe no np nq nr b">j</code>将不得不在<code class="fe no np nq nr b">i</code>增加1之前迭代到<code class="fe no np nq nr b">n.length-1</code>。</p><p id="e7d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这也可以表示为<code class="fe no np nq nr b">O(n*n)</code>运行时。</p><p id="3a01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在剖析运行时时要遵循一个好的规则:每当我们有一个迭代<code class="fe no np nq nr b">n</code>次的for循环时，这个for循环中的任何额外工作都要乘以<code class="fe no np nq nr b">n</code>。</p><p id="d96f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，我们看到了正在进行的<code class="fe no np nq nr b">O(n*1)</code>工作。如果代码没有嵌套在for循环或类似的东西中，我们用一个<code class="fe no np nq nr b">+</code>符号分隔各个部分的运行时间。</p><p id="92c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/6547ea8ec0b3a6909f03f8f0828029c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msbuPalCoSkKSmakXuoedA.png"/></div></div></figure><p id="b9f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将这个运行时表示为:</p><p id="a6bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe no np nq nr b">O(n) + O(n)</code>只是简化为<code class="fe no np nq nr b">O(n)</code>——注意我们没有乘法<code class="fe no np nq nr b">n by n</code>，因为它们不是嵌套循环！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e12" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">O(log n)复杂度</h1><p id="105a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">乍一看，这似乎有点令人困惑，因为我有意避开数学。让我们考虑下面的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8150c4e8fe80de7b01ca32a0a1bae89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*WjpfhLsK7yCAlH6_CZsw-w.png"/></div></figure><p id="62df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最初定义一个变量<code class="fe no np nq nr b">i</code>等于<code class="fe no np nq nr b">n</code>(一个常量运算)。</p><p id="9f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe no np nq nr b">i</code>大于零时，在每次迭代中，我们将<code class="fe no np nq nr b">i</code>减半。这就是对数运行时的组成。如图所示，这是我们能得到的最接近恒定运行时间的结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5891" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="b02b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">大O符号是一个相当复杂的话题，但我希望你现在比以前有更好的理解。我们能够看到代码中存在常量、线性、二次和对数运行时的情况。</p><p id="19dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对符号有任何问题，请随意提问。</p></div></div>    
</body>
</html>