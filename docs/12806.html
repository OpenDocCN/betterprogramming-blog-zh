<html>
<head>
<title>What’s New in ES2022? 4 Latest JavaScript Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2022有什么新功能？4个最新的JavaScript特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/es2022-features-javascript-a9f8f5dcba5a?source=collection_archive---------0-----------------------#2022-07-04">https://betterprogramming.pub/es2022-features-javascript-a9f8f5dcba5a?source=collection_archive---------0-----------------------#2022-07-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ee7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">新ES13规格概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2bd7969f63cdb666178d7bcb780e9f65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*al7exOZVCn3RBkDxYDgi3A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="a8c6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的ES13规格终于发布了。规格？JavaScript确实不是开源语言。这是一种遵循ECMAScript标准规范编写的语言。TC39委员会负责讨论和批准新特性。他们是谁？</p><blockquote class="lu lv lw"><p id="4213" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated"><em class="it">“ECMA International的TC39是一个由JavaScript开发人员、实现人员、学者等组成的团体，他们与社区合作来维护和发展JavaScript的定义。”—</em><a class="ae mb" href="https://tc39.es/" rel="noopener ugc nofollow" target="_blank"><em class="it">tc39 . es</em></a></p></blockquote><p id="2c8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们的释放过程由五个阶段组成。自2015年以来，他们一直在进行年度发布。它们通常发生在春天。</p><p id="2be7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两种方法可以引用任何ECMAScript版本:</p><ul class=""><li id="0512" class="mc md it la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">按年份:这个新版本将是ES2022。</li><li id="804d" class="mc md it la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">根据它的迭代编号:这个新版本将是第13次迭代，所以它可以被称为ES13。</li></ul><p id="d4c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么这个版本中有什么新内容呢？哪些功能可以让我们感到兴奋？</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="9a94" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">正则表达式匹配索引</h1><p id="3ed7" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">目前，在JavaScript中使用JavaScript Regex API时，只返回匹配的<code class="fe nu nv nw nx b">start index</code>。但是，对于一些特殊的高级场景，这还不够。</p><p id="9e9a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为这些规格的一部分，添加了一个特殊的标志<code class="fe nu nv nw nx b">d</code>。通过使用它，regex API将返回一个二维数组作为名为<code class="fe nu nv nw nx b">indices</code>的键。它包含每场比赛的<code class="fe nu nv nw nx b">start</code>和<code class="fe nu nv nw nx b">end</code>指数。如果在正则表达式中捕获了任何命名的组，它将在<code class="fe nu nv nw nx b">indices.groups</code>对象中返回它们的开始/结束索引。命名的组名将是它的关键字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9d60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">见原提案<a class="ae mb" href="https://github.com/tc39/proposal-regexp-match-indices" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="0f04" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">顶级<code class="fe nu nv nw nx b">await</code></h1><p id="c3c5" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">在这个提议之前，不接受有<code class="fe nu nv nw nx b">top level awaits</code>。有一些变通办法来模拟这种行为，但都有其缺点。</p><p id="04b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">顶级的await特性让我们依靠模块来处理这些承诺。这是一个可以使用的直观特性。但是，请注意，这可能会改变模块的执行顺序。如果一个模块依赖于另一个具有顶级await调用的模块，那么该模块的执行将被暂停，直到承诺被履行。</p><p id="954c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8bbc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，引擎将在执行<code class="fe nu nv nw nx b">usage.js</code>模块上的代码之前等待<code class="fe nu nv nw nx b">users</code>完成。</p><p id="f2ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，这是一个很好的直观特性，需要小心使用。我们不想滥用它。</p><p id="75d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此处见原提案<a class="ae mb" href="https://github.com/tc39/proposal-top-level-await" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="7101" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">。在()</h1><p id="d079" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">长期以来，人们一直要求JavaScript提供一个类似于<code class="fe nu nv nw nx b">Python</code>的数组负索引访问器。而不是简单地做<code class="fe nu nv nw nx b">array[array.length-1]</code>去做<code class="fe nu nv nw nx b">array[-1]</code>。这是不可能的，因为JavaScript中的对象也使用了<code class="fe nu nv nw nx b">[]</code>符号。</p><p id="b637" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">被接受的建议采取了更实际的方法。<code class="fe nu nv nw nx b">Array</code>对象现在将拥有一个模仿上述行为的方法<code class="fe nu nv nw nx b">at</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="723f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">见原提案<a class="ae mb" href="https://github.com/tc39/proposal-relative-indexing-method" rel="noopener ugc nofollow" target="_blank">此处</a>。</p><p id="281c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Btw，现在我们在讨论数组，你知道你可以解构数组位置吗？👌</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="bf38" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">可访问的<code class="fe nu nv nw nx b">Object.prototype.hasOwnProperty</code></h1><p id="6299" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">以下只是一个很好的简化。已经有了<code class="fe nu nv nw nx b">hasOwnProperty</code>。然而，它需要在我们想要执行的查找的实例中被调用。因此，许多开发人员最终都会这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="70b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这些新的规范，一个<code class="fe nu nv nw nx b">hasOwn</code>方法被添加到了<code class="fe nu nv nw nx b">Object</code>原型中。现在，我们可以简单地做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a51c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">见原提案<a class="ae mb" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="febd" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">错误原因</h1><p id="f471" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">错误帮助我们识别应用程序的意外行为并做出反应。然而，理解深层嵌套错误的根本原因甚至正确处理它们会变得具有挑战性。在捕获和重新抛出它们时，我们会丢失堆栈跟踪信息。</p><p id="da11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在如何处理这个问题上没有明确的一致意见。对于任何错误处理，我们至少有3种选择:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5247" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为这些新规范的一部分，我们可以构造一个新的错误，并保留被捕获错误的引用。怎么会？只需将对象<code class="fe nu nv nw nx b">{cause: err}</code>传递给<code class="fe nu nv nw nx b">Error</code>构造函数。</p><p id="4b1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一切变得更加简单、标准，并且易于理解深层嵌套的错误。让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f237" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到更多关于提案的信息。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="7919" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">类别字段</h1><p id="d0e5" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">在这个版本之前，没有合适的方法来创建私有字段。有一些方法可以绕过提升，但这不是一个合适的私人领域。现在很简单了。我们只需要在变量声明前添加<code class="fe nu nv nw nx b">#</code>字符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6610" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拥有私有字段意味着我们有一个强大的封装边界。不可能从外部访问类变量。这表明<code class="fe nu nv nw nx b">class</code>关键字不再仅仅是糖语法。</p><p id="3469" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还可以创建私有方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4cfa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该功能与我们将在下面看到的<code class="fe nu nv nw nx b">Class Static Block</code>和<code class="fe nu nv nw nx b">Ergonomic checks for Private Classes</code>相关。</p><p id="4442" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到关于提案<a class="ae mb" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="5fc1" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">类静态块</h1><p id="368b" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">作为新规格的一部分，我们现在可以在任何<code class="fe nu nv nw nx b">Class</code>中包含<code class="fe nu nv nw nx b">static blocks</code>。它们将只运行一次，是修饰或执行类的静态端的某些按字段初始化的好方法。</p><p id="11bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不局限于使用一个块，我们需要多少就有多少。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="47b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们有丰厚的奖金。他们有特权进入<code class="fe nu nv nw nx b">private fields</code>。你可以用它们来做一些有趣的图案。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ba9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们试图从实例对象的外部访问私有变量，我们将得到<code class="fe nu nv nw nx b">Cannot read private member #privateField from an object whose class did not declare it</code>。</p><p id="fbcd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到关于提案<a class="ae mb" href="https://github.com/tc39/proposal-class-static-block" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="dfff" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">针对私人领域的人体工程学品牌检查</h1><p id="b3d9" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">新的<code class="fe nu nv nw nx b">private</code>字段是一个很棒的特性。然而，在某些<code class="fe nu nv nw nx b">static</code>方法中检查一个字段是否是<code class="fe nu nv nw nx b">private</code>可能会变得很方便。</p><p id="6fa8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">试图在类范围之外调用这个<code class="fe nu nv nw nx b">in</code>会导致我们之前看到的同样的错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b718" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在这里找到更多关于提案的信息。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="9fb7" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">最后的想法</h1><p id="d35f" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">这是一个有趣的版本，提供了许多小而有用的特性，如<code class="fe nu nv nw nx b">at</code>、<code class="fe nu nv nw nx b">private fields</code>和<code class="fe nu nv nw nx b">error cause</code>。当然<code class="fe nu nv nw nx b">error cause</code>会给我们日常的bug跟踪任务带来很多清晰性。</p><p id="2768" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些高级功能，如<code class="fe nu nv nw nx b">top-level await</code>，需要在使用前充分理解。它们可能会在您代码执行中产生不必要的副作用</p><p id="766d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章能让你像我一样对新的ES2022规格感到兴奋。</p></div></div>    
</body>
</html>