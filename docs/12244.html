<html>
<head>
<title>Fast Image Processing in Android With Halide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Halide的Android快速图像处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fast-image-processing-in-android-with-halide-53cf8f5fda65?source=collection_archive---------5-----------------------#2022-05-21">https://betterprogramming.pub/fast-image-processing-in-android-with-halide-53cf8f5fda65?source=collection_archive---------5-----------------------#2022-05-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3c81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我曾经写过Halide如何让我们编写快速且可维护的代码。这一款将在Android应用程序中展示其威力。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec8e564f9fd973a4a87221ce9e3b0637.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Yo50V9O0FyYS_wpF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@nadyeldems" rel="noopener ugc nofollow" target="_blank">丹·史沫特莱</a>在<a class="ae ky" href="https://unsplash.com/photos/76YvNs5gzLM" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="4cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Halide是一种开源的领域特定语言，旨在使在现代机器上编写和维护高性能图像处理或数组处理代码变得更加容易。</p><p id="05ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直在写一个关于卤化物的系列，这篇文章是这个系列的第三篇。在前两篇文章中，我谈到了</p><ul class=""><li id="401d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-the-general-concepts-4d865466bb8c">第2部分——理解Halide编程语言的一般概念</a></li><li id="cdd5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-part-1-6a5c3a519250">第1部分——用Halide编写快速且可维护的代码——试播集</a></li></ul><p id="f87f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将讲述如何在Android上使用Halide，以及它能给我们带来什么样的性能提升。</p><p id="f8e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了展示性能优势，我将重用<code class="fe mj mk ml mm b">YUV</code>到<code class="fe mj mk ml mm b">RGB</code>颜色格式转换的问题陈述。我过去写过几篇文章，用这个例子展示了在Android中进行图像处理的不同方法。</p><blockquote class="mn mo mp"><p id="92d6" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">免责声明:本文中的任何观点都是我个人的观点，并不反映我所工作的组织的观点或立场。</p><p id="d91d" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">我在谷歌的<a class="ae ky" href="https://developers.google.com/camera" rel="noopener ugc nofollow" target="_blank">相机中开发HDR模式和夜间模式等功能。这是一个困难的问题陈述——我们需要在资源受限的设备上用复杂的算法处理高分辨率图像。这才是Halide真正发光的地方！</a></p></blockquote></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="e21c" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">问题陈述:YUV到RGB转换</h1><p id="16f3" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">如果你纯粹是对学习如何在Android上使用Halide感兴趣，你可以跳过这一小节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1610f4791426a05a5698b36341dbe21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hFGbyewLySMR5rk9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Kir Simakov 在<a class="ae ky" href="https://unsplash.com/photos/wl6YjDpm8UQ" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="2ce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题陈述是将一个8MP(800万像素= ~ 8，000，000像素)图像转换为一种称为<a class="ae ky" href="https://developer.android.com/reference/android/graphics/ImageFormat#YUV_420_888" rel="noopener ugc nofollow" target="_blank"> YUV_420_888 </a>的特定格式，该格式具有一个平面<code class="fe mj mk ml mm b">Y</code>通道和两个半平面子采样<code class="fe mj mk ml mm b">UV</code>通道，该格式通常由Android中的<a class="ae ky" href="https://developer.android.com/reference/android/graphics/Bitmap" rel="noopener ugc nofollow" target="_blank">位图</a>支持。你可以在维基百科上阅读更多关于<a class="ae ky" href="https://en.wikipedia.org/wiki/YUV" rel="noopener ugc nofollow" target="_blank"> YUV格式的内容。此外，下面的文章对问题陈述有更好的描述。</a></p><p id="bcae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之所以选择这个作为问题陈述，是因为<code class="fe mj mk ml mm b">YUV_420_888</code>是Android相机API支持的最常见的输出格式之一，并且图像通常在Android中作为<code class="fe mj mk ml mm b">Bitmap</code>使用——因此这是一个需要解决的相当常见的问题陈述。</p><p id="4a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直在试验不同框架/技术的性能，以了解它们如何在Android上执行图像处理算法。我用了同样的问题陈述来相互比较。这里有一些我测试过的使用其他技术的例子</p><ul class=""><li id="31e1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/processing-images-fast-with-native-code-in-android-db8b21001fa9">使用Android中的原生代码快速处理图像</a></li><li id="327c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/computational-photography/fast-image-processing-in-android-with-renderscript-4bc6992ba48e" rel="noopener">如何使用RenderScript将YUV_420_888 YUV图像转换为位图</a></li><li id="92dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://blog.minhazav.dev/faster-image-processing-in-android-java-using-multi-threading/" rel="noopener ugc nofollow" target="_blank">使用多线程技术加快Android Java中的图像处理速度</a></li></ul><p id="dd4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我通过在像素4A设备上运行，用上面列出的不同解决方案为问题陈述记录了以下数字</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，基于<code class="fe mj mk ml mm b">RenderScript</code>的方法被认为是最快的。但是，从Android 12开始，RenderScript已被弃用。你可以在这里阅读更多相关信息<a class="ae ky" href="https://developer.android.com/guide/topics/renderscript/migrate" rel="noopener ugc nofollow" target="_blank">。开发团队分享了一些替代方案，这些方案有望在新硬件上获得更好的性能。</a></p><p id="514b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一节中，我将分享针对这个问题的基于卤化物的解决方案，然后查看使用这种方法的基准测试结果。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="0fd0" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">YUV到ARGB一代的卤化物代码</h1><p id="d166" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">正如在<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-part-1-6a5c3a519250">上一篇文章</a>中提到的，Halide允许我们将算法从调度中分离出来。所以首先让我们看看YUV到RGB转换的算法。</p><p id="6bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将假设输入图像格式为<a class="ae ky" href="https://developer.android.com/reference/android/graphics/ImageFormat#YUV_420_888" rel="noopener ugc nofollow" target="_blank"> YUV_420_888 </a>。这种图像格式的一些关键方面是</p><p id="1f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">亮度通道(Y通道)是全分辨率平面通道。</p><ul class=""><li id="2cc8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">这意味着Y平面保证不会与U/V平面交错。</li></ul><p id="20cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">色度通道(UV通道)是二次采样，可以交错。</p><ul class=""><li id="7f64" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">通过二次采样，这意味着四个Y像素对应一个UV像素。</li><li id="115e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过交错，这意味着UV数据可以在图像的每一行以<code class="fe mj mk ml mm b">UVUVUVUVUVUV</code>模式打包在存储器中。</li></ul><p id="11b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在到目前为止的示例中，<code class="fe mj mk ml mm b">ARGB</code>输出具有每个通道(<code class="fe mj mk ml mm b">R</code>或<code class="fe mj mk ml mm b">G</code>或<code class="fe mj mk ml mm b">B</code>或<code class="fe mj mk ml mm b">A = alpha</code>)，其中<code class="fe mj mk ml mm b">uint8</code>数据存储在单个<code class="fe mj mk ml mm b">int32</code>值中。我们会继续做同样的事情。</p><h1 id="311c" class="nb nc it bd nd ne oa ng nh ni ob nk nl jz oc ka nn kc od kd np kf oe kg nr ns bi translated">该算法</h1><p id="3832" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">卤化物发生器可能看起来像这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用于YUV到RGB颜色转换的卤化物发生器</p></figure><h1 id="f346" class="nb nc it bd nd ne oa ng nh ni ob nk nl jz oc ka nn kc od kd np kf oe kg nr ns bi translated">时间表</h1><p id="7d08" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">在Halide中，如果我们不写任何显式的时间表，一切都是内联计算的。编写时间表通常涉及卤化物、目标硬件和某种程度的反复试验的专业知识。在我看来，第一步应该是编写基准并在目标硬件上运行。为此，您可以在<a class="ae ky" href="https://github.com/google/benchmark" rel="noopener ugc nofollow" target="_blank"> google/benchmark </a>使用开源基准框架。</p><p id="721c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从第一个日程表开始</p><h2 id="b68d" class="of nc it bd nd og oh dn nh oi oj dp nl li ok ol nn lm om on np lq oo op nr oq bi translated">默认计划</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">YUV到RGB卤化物的默认时间表</p></figure><p id="cd6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将内联完成所有计算，即在每个像素的两个for循环内。</p><p id="5b21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在像素4A上运行它，我得到了上面提到的生成器的以下结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4c33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个数字类似于我们用标准本机代码得到的数字。但是我对卤化物能挤出的数字有更高的期望。</p><h2 id="fad5" class="of nc it bd nd og oh dn nh oi oj dp nl li ok ol nn lm om on np lq oo op nr oq bi translated">分割、并行化和矢量化</h2><p id="96b5" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">要了解关于这些原语的更多信息，您可以阅读本系列的第2篇文章— <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-the-general-concepts-4d865466bb8c">了解Halide编程语言的一般概念</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">YUV到RGB卤化物的优化时间表</p></figure><p id="cc0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该调度将循环分割成更多部分，对<code class="fe mj mk ml mm b">xi</code>循环中的指令进行矢量化，并对<code class="fe mj mk ml mm b">y</code>循环进行并行化。让我们看看基准测试的结果</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><blockquote class="mn mo mp"><p id="d81e" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated"><em class="it">嘣！你看到默认时间表的疯狂加速了吗？</em></p></blockquote><p id="6dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能会有进一步的优化，比如减少计算<code class="fe mj mk ml mm b">uv_centered</code>的次数，或者尝试不同的分裂因子，但到目前为止看起来还不错。</p><h1 id="eb13" class="nb nc it bd nd ne oa ng nh ni ob nk nl jz oc ka nn kc od kd np kf oe kg nr ns bi translated">用Android包装这个卤化物生成方法</h1><p id="d6ee" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated">上述生成器将生成一个C++方法，如下所示</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">YUV转RGB卤化物发生器的生成方法</p></figure><p id="d7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以直接从<code class="fe mj mk ml mm b">C++</code>库或JNI代码中使用。</p><blockquote class="mn mo mp"><p id="64f4" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">将来，如果需要的话，我会写关于如何在Android studio中设置Halide并端到端使用它。LMK，如果这将有助于超过评论。</p></blockquote><p id="de26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将所有东西连接在一起，我们需要将整个端到端的管道连接起来，这意味着</p><pre class="kj kk kl km gt or mm os ot aw ou bi"><span id="be55" class="of nc it mm b gy ov ow l ox oy">Java --&gt; JNI --&gt; Halide --&gt; Java --&gt; Bitmap</span></pre><p id="d014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这导致了<code class="fe mj mk ml mm b">~28ms</code>的整体延迟。所以如果我们看看目前为止考虑过不同方法的结果</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最新结果表明，与现有结果相比，卤化物的实施是最快的和最新的。</p></figure><blockquote class="mn mo mp"><p id="faef" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">这给了我们高性能+易于维护的代码！一个工程团队还想要什么？</p><p id="0b99" class="kz la mq lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">对于这个问题，我找到了另一个更快的解决方案(大约12毫秒的延迟)，但需要硬件特定的实现(利用NEON固有的)和处理并行化等等。它不容易编写或维护，但绝对值得以后发表一篇文章。</p></blockquote></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="bafc" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">结论和结束语</h1><blockquote class="oz"><p id="c669" class="pa pb it bd pc pd pe pf pg ph pi lu dk translated">写非常高效代码的人说他们花在优化代码上的时间至少是写代码的两倍。</p><p id="861f" class="pa pb it bd pc pd pe pf pg ph pi lu dk translated"><em class="pj"> —互联网上的某个人</em></p></blockquote><p id="7b48" class="pw-post-body-paragraph kz la it lb b lc pk ju le lf pl jx lh li pm lk ll lm pn lo lp lq po ls lt lu im bi translated">Halide使尝试和调整不同的时间表变得更加容易。比手动改变循环顺序、分割逻辑、线程等更容易。并且消除了编写和维护ABI特有的矢量化代码的痛苦。</p><blockquote class="oz"><p id="9ea6" class="pa pb it bd pc pd pe pf pg ph pi lu dk translated">像Halide、自动矢量化C++代码这样的方法是可移植的，并且更容易维护。</p></blockquote><ul class=""><li id="0b21" class="lv lw it lb b lc pk lf pl li pp lm pq lq pr lu ma mb mc md bi translated">与显式手动调整的CPU特定代码相比</li></ul><blockquote class="oz"><p id="a27e" class="pa pb it bd pc pd ps pt pu pv pw lu dk translated">在优化之前，请始终考虑您的用例</p></blockquote><ul class=""><li id="f554" class="lv lw it lb b lc pk lf pl li pp lm pq lq pr lu ma mb mc md bi translated">示例—库开发人员与应用程序开发人员</li><li id="30db" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">了解真正的瓶颈，比如如果完全运行需要2s，在<code class="fe mj mk ml mm b">28 ms</code>和<code class="fe mj mk ml mm b">12 ms </code>之间进行优化可能不会带来巨大的优势。</li></ul><p id="e6be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的应用程序对性能至关重要:基准测试→分解→优化(重复)</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="2944" class="nb nc it bd nd ne nf ng nh ni nj nk nl jz nm ka nn kc no kd np kf nq kg nr ns bi translated">参考</h1><ul class=""><li id="5bf1" class="lv lw it lb b lc nt lf nu li px lm py lq pz lu ma mb mc md bi translated"><a class="ae ky" href="https://halide-lang.org/" rel="noopener ugc nofollow" target="_blank">卤化物—halide-lang.org</a></li><li id="28c3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://halide-lang.org/tutorials/tutorial_introduction.html" rel="noopener ugc nofollow" target="_blank">卤化物教程</a></li></ul><h2 id="03a1" class="of nc it bd nd og oh dn nh oi oj dp nl li ok ol nn lm om on np lq oo op nr oq bi translated">系列文章</h2><ul class=""><li id="f26e" class="lv lw it lb b lc nt lf nu li px lm py lq pz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-the-general-concepts-4d865466bb8c">第2部分——理解Halide编程语言的一般概念</a></li><li id="0d14" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-part-1-6a5c3a519250">第一部分——用Halide编写快速且可维护的代码——试播集</a></li></ul><h2 id="6575" class="of nc it bd nd og oh dn nh oi oj dp nl li ok ol nn lm om on np lq oo op nr oq bi translated">我的一些相关文章</h2><ul class=""><li id="960b" class="lv lw it lb b lc nt lf nu li px lm py lq pz lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/processing-images-fast-with-native-code-in-android-db8b21001fa9">用安卓原生代码快速处理图像</a></li><li id="17a6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/computational-photography/fast-image-processing-in-android-with-renderscript-4bc6992ba48e" rel="noopener">如何使用RenderScript将YUV_420_888 YUV图像转换成位图</a></li><li id="d741" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://blog.minhazav.dev/faster-image-processing-in-android-java-using-multi-threading/" rel="noopener ugc nofollow" target="_blank">使用多线程技术加快Android Java中的图像处理速度</a></li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt or mm os ot aw ou bi"><span id="f09b" class="of nc it mm b gy ov ow l ox oy"><strong class="mm iu">Want to Connect?</strong></span><span id="32df" class="of nc it mm b gy qa ow l ox oy">This article was originally published at <a class="ae ky" href="https://blog.minhazav.dev/fast-and-maintanable-image-processing-in-android-with-halide-part-3/" rel="noopener ugc nofollow" target="_blank">blog.minhazav.dev</a>.</span></pre></div></div>    
</body>
</html>