<html>
<head>
<title>Improving Code Quality in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高Android中的代码质量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/improving-code-quality-in-android-part-1-96d68f1a9a4e?source=collection_archive---------5-----------------------#2022-03-28">https://betterprogramming.pub/improving-code-quality-in-android-part-1-96d68f1a9a4e?source=collection_archive---------5-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0cd8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">帮助您编写更简洁代码的提示</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/65b3bfc301235e7607f3daea3fdf95f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*JSavcSaTFcORUZB2w6BgrQ.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">乔舒亚·沃罗尼耶基在<a class="ae kr" href="https://unsplash.com/s/photos/improvement?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="828c" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这篇文章记录了我读到的东西，我收到的公关评论，以及我从同事那里学到的一些东西。如果你能对此补充更多，请不吝赐教。</p><h1 id="c328" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Val或Var</h1><p id="75ce" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">可变性与不可变性。如果让你选择，你会选择哪一个？我总是更喜欢不变性(<code class="fe ml mm mn mo b">val</code>而不是<code class="fe ml mm mn mo b">var</code>)。当一个变量变得可变时，你就打开了不确定性的大门。没有人能够预测该变量在该类中的某个点的值，并且该变量可以对整个类产生负面或正面的影响，因为它的不断进化的性质。只有当你确定<code class="fe ml mm mn mo b">val</code>在你的场景中无法工作时，才尝试使用<code class="fe ml mm mn mo b">var</code>。不要把奢侈给<code class="fe ml mm mn mo b">var</code>。使用<code class="fe ml mm mn mo b">val</code>将变量限制在某个范围内。</p><h1 id="747d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">可见性修改器</h1><p id="668c" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">Kotlin中有四种类型的可见性修改器:</p><ul class=""><li id="5a51" class="mp mq iq ku b kv kw ky kz lb mr lf ms lj mt ln mu mv mw mx bi translated"><code class="fe ml mm mn mo b">private</code></li><li id="9214" class="mp mq iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated"><code class="fe ml mm mn mo b">protected</code></li><li id="7279" class="mp mq iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated"><code class="fe ml mm mn mo b">internal</code></li><li id="7be9" class="mp mq iq ku b kv my ky mz lb na lf nb lj nc ln mu mv mw mx bi translated"><code class="fe ml mm mn mo b">public</code></li></ul><p id="f532" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你的代码架构不好，这些修饰符中的大部分将被限制为私有或公共的。当你的班级开始分享东西而不太依赖彼此时，它们就会发挥作用。或许，如果你写的是干净的代码。</p><p id="35f3" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们来看看下面的代码:</p><pre class="kg kh ki kj gt nd mo ne bn nf ng bi"><span id="26aa" class="nh lp iq mo b be ni nj l nk nl">abstract class Car {<br/><br/>    protected var name: String? = null<br/>    protected var year: Int = 0<br/>    private val welcomeMessage = "Hi, Welcome to your new car"<br/><br/>    abstract fun modelName()<br/>    abstract fun manufacturedYear()<br/><br/>    fun printWelcomeMessage() {<br/>        println(welcomeMessage)<br/>    }<br/><br/>}<br/><br/>class Chevrolet : Car() {<br/>    override fun modelName() {<br/>        name = "Beat"<br/>        printWelcomeMessage()<br/>    }<br/><br/>    override fun manufacturedYear() {<br/>        year = 2012<br/>    }<br/><br/>}<br/><br/>class Hyundai : Car() {<br/>    override fun modelName() {<br/>        name = "Jazz"<br/>        printWelcomeMessage()<br/>    }<br/><br/>    override fun manufacturedYear() {<br/>        year = 2015<br/>    }<br/>}</span></pre><p id="d5da" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们有一个基类叫做<code class="fe ml mm mn mo b">Car</code>。雪佛兰和现代将其延伸。他们可以访问姓名和年份，这是<code class="fe ml mm mn mo b">Car</code>的一部分，只是因为它是<code class="fe ml mm mn mo b">protected</code>。因此，<code class="fe ml mm mn mo b">protected</code>与<code class="fe ml mm mn mo b">private</code>具有相同的可见性。但是在子类中也是可见的。</p><p id="d4a7" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果将姓名或年份作为内部变量会怎样。？然后，您可以从同一个模块的任何地方访问它。我们不必扩展类本身。<code class="fe ml mm mn mo b">Car</code>类中的<code class="fe ml mm mn mo b">welcomeMessage</code>变量呢？它是私有的，只能在<code class="fe ml mm mn mo b">Car</code>类中访问。理解可见性修饰符之间的差异有助于您根据坚实的原则编写代码。</p><h1 id="0c4d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">减少参数中的Android对象</h1><p id="618f" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">稍有不慎，现在就有了不可测试的方法。或者，你必须加倍努力使它可测试。</p><pre class="kg kh ki kj gt nd mo nm nn aw no bi"><span id="6453" class="np lp iq mo b gy nq nr l ns nl">fun importantMethod(size: Size) {<br/>    // some logic using Size<br/>}</span></pre><p id="a340" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们已经传递了一个Android对象<code class="fe ml mm mn mo b">Size</code>作为这个方法的参数。当您试图创建一个相同的模拟时，问题就来了。为Android相关的东西构建模拟对象是一项挑战。相反，你可以将int的<code class="fe ml mm mn mo b">width</code>和<code class="fe ml mm mn mo b">height</code>作为参数传递。在Java/Kotlin对象中寻找替代对象。总是试图在方法参数中限制Android对象的使用。</p><h1 id="ace3" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">不要过度开发扩展函数</h1><p id="adf3" class="pw-post-body-paragraph ks kt iq ku b kv mg jr kx ky mh ju la lb mi ld le lf mj lh li lj mk ll lm ln ij bi translated">扩展功能是创新的。我们现在能够扩展一个类，而不实际继承它。此外，我们可以向它添加新的属性，使它看起来像是原始实现的一部分。</p><pre class="kg kh ki kj gt nd mo nm nn aw no bi"><span id="bfa9" class="np lp iq mo b gy nq nr l ns nl">fun Activity.showToast(message: String) {<br/> Toast.makeText(this, message, Toast.<em class="nt">LENGTH_SHORT</em>)<br/> .show()<br/>}</span></pre><p id="ac89" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这是一个很好的扩展功能。为什么？因为它是通用的。您正在扩展活动的上下文，并创建一些方便的东西。很多活动都可以利用这个扩展功能。</p><pre class="kg kh ki kj gt nd mo nm nn aw no bi"><span id="e65f" class="np lp iq mo b gy nq nr l ns nl">fun Activity.solvingAnIssueForActivityA() {<br/>    // some logic<br/>}</span></pre><p id="fe78" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这个怎么样？我们已经创建了一个扩展函数，而没有考虑好的设计。它将如何影响代码。？当有人在活动中使用点号时，这个函数会自动完成。开发人员会想我的活动是如何知道ActivityA内部的事情的。仅当您认为该代码是可重复的、其他人可以使用它、不涉及业务逻辑等等时，才创建扩展功能。明智地使用扩展函数。尽量不要虐待他们。</p><h1 id="5e24" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">Kotlin对象不是线程安全的</h1><pre class="kg kh ki kj gt nd mo ne bn nf ng bi"><span id="786e" class="nh lp iq mo b be ni nj l nk nl">object someCalculations {<br/><br/>    var value1 = 0 <br/>    var value2 = 0<br/><br/>    fun doingSomethingWithValue1() {<br/>    // some logic<br/>    }<br/><br/>    fun doingSomethingWithValue2() {<br/>    // some logic<br/>    }<br/>}</span></pre><p id="4f6d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">您可能已经知道，我们主要使用Kotlin对象来创建单例。在Kotlin中使用一个对象的主要优点是我们不必创建它的新实例。问题是我们有可能使用<code class="fe ml mm mn mo b">objects</code>在其他对象/类之间共享数据。</p><p id="c1c0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">让我们回顾一下上面的实现。我们设计它是为了让<code class="fe ml mm mn mo b">value1</code>和<code class="fe ml mm mn mo b">value2</code>可以从任何地方改变，并且使用这些属性的方法也可以从任何地方访问。如果您不走运，它们将被同时访问，您可能得不到您期望的更新结果。因此，如果出现这种情况，最好重构您的代码设计，让一些中间类可以帮助共享数据。或者，如果您计划继续处理该对象，请确保使用某种同步机制来确保您的字段得到更新。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="93ff" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我了解到，当你根据设计原则编写代码时，你的画布会扩大。不要局限于只从Android的角度思考。这将有助于所有相关人员。当我发现新的东西时，我会写更多。祝你愉快。😇</p><p id="3dfb" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">请随意看看我最近的文章:</p><p id="b334" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://clintpaul.medium.com/a-bitmap-story-a948bcd02acc" rel="noopener">一个位图故事</a></p><p id="5f84" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://clintpaul.medium.com/jni-on-android-how-callbacks-work-c350bf08157f" rel="noopener">Android上的JNI:回调是如何工作的</a></p><p id="b027" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><a class="ae kr" href="https://medium.com/codex/scheduling-tasks-with-workmanager-13c4ad62704d" rel="noopener">用工作管理器调度任务</a></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="db12" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">本文最初发表于clintpauldev.com<a class="ae kr" href="https://clintpauldev.com/improving-code-quality-in-android-part-1/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>