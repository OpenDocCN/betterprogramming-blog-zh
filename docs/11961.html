<html>
<head>
<title>Build a Custom Paint Flutter App Widget</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建自定义Paint Flutter应用程序小部件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custompaint-in-flutter-ff2e1d6f8309?source=collection_archive---------3-----------------------#2022-04-30">https://betterprogramming.pub/custompaint-in-flutter-ff2e1d6f8309?source=collection_archive---------3-----------------------#2022-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8181" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">想创建一个高度定制的用户界面和令人敬畏的动画吗？不用担心，Flutter CustomPaint小工具已经覆盖了你</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2b45e3bded8b352f58881f7f8fa2eb81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*B4DWmLCv4c4bwcyUOWEIjw.gif"/></div></div></figure><p id="98ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我们将讨论显式动画以及如何轻松使用<code class="fe ln lo lp lq b">CustomPaint</code>小部件。</p><p id="0e5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以从我的<a class="ae lr" href="https://github.com/gajendrapandeya/CustomPaint.git" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>查看代码示例。</p><blockquote class="ls lt lu"><p id="c5ec" class="kr ks lv kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated"><strong class="kt ir"> Custom Paint : </strong>一个小部件，提供一个画布，在绘制阶段可以在上面进行绘制。</p></blockquote><p id="5c02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只需将<code class="fe ln lo lp lq b">CustomPaint</code>小部件添加到您的小部件树中，并为其提供<code class="fe ln lo lp lq b"><strong class="kt ir">painter</strong></code> <strong class="kt ir"> <em class="lv"> </em> </strong>，这是<code class="fe ln lo lp lq b">CustomPainter</code>抽象类的子类。</p><p id="e01e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于<code class="fe ln lo lp lq b">CustomPainter</code>是一个抽象类，它迫使我们实现两个重要的方法，即<code class="fe ln lo lp lq b">paint()</code>和<code class="fe ln lo lp lq b">shouldRepaint()</code>。<code class="fe ln lo lp lq b">size</code> <strong class="kt ir"> <em class="lv"> </em> </strong>指定绘制的小工具的大小。让我们把手弄脏:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="e40d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">paint()</code>方法为我们提供了两个重要参数:</p><ol class=""><li id="228f" class="mb mc iq kt b ku kv kx ky la md le me li mf lm mg mh mi mj bi translated">Canvas是我们在屏幕上绘制小部件的区域。它有各种方法来绘制自定义小部件。其中有:<code class="fe ln lo lp lq b">canvas.drawLine()</code>、<code class="fe ln lo lp lq b"> canvas.drawCircle()</code>、<code class="fe ln lo lp lq b"> canvas.drawArc()</code>、<code class="fe ln lo lp lq b"> canvas.drawOval()</code>等。</li><li id="4f4a" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated"><code class="fe ln lo lp lq b">Size</code>:图纸应该有多大。默认情况下，它采用包装器小部件的大小，即包装我们的<code class="fe ln lo lp lq b">CustomPaint</code>小部件的小部件。此外，我们可以在我们的<code class="fe ln lo lp lq b">CustomPaint</code>小部件中提供尺寸参数。因为我们想画一个圆，所以我们为宽度和高度传递了相同的值。</li></ol><p id="d58a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每当需要重建<code class="fe ln lo lp lq b">CustomPainter</code>时，就会调用<code class="fe ln lo lp lq b">shouldRepaint()</code>方法。当我们实施我们的项目时，这一点会变得很清楚。</p><p id="66bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们了解了<code class="fe ln lo lp lq b">CustomPainter</code>类，让我们在画布上画些东西。我们的目标是画一个有一定笔画宽度的圆。</p><p id="cd1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看我们是如何做到这一点的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a452" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们想要画一个圆，所以我们使用了预建的<code class="fe ln lo lp lq b">canvas.drawCircle() the </code>方法，该方法需要三个参数，即圆心、圆的半径和一个绘画对象。我们从<code class="fe ln lo lp lq b">size</code><strong class="kt ir"><em class="lv"/></strong>参数计算出圆心和半径。<code class="fe ln lo lp lq b">Paint()</code>类为我们提供了各种属性，如<code class="fe ln lo lp lq b">paint</code>、<code class="fe ln lo lp lq b">storkeWidth</code>、<code class="fe ln lo lp lq b">style</code>的颜色，即是否应该描边或填充。当前的实施将导致以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/7240f5247c3d76410d60484ea32ca64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/format:webp/1*kIqpPe1jIp7PUKa2AZFAgg.png"/></div></figure><p id="d415" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的下一个目标是在同一个圆上画一条弧线，它将在笔画周围产生动画效果。为了实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8f8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们想要画一个圆弧，所以我们使用了期望五个参数的<code class="fe ln lo lp lq b">canvas.drawArc()</code>方法，即Rect <code class="fe ln lo lp lq b">object</code>、弧度中的<code class="fe ln lo lp lq b">startAngle</code>、<code class="fe ln lo lp lq b">radian</code>中的<code class="fe ln lo lp lq b">sweepAngle</code>、<code class="fe ln lo lp lq b">useCenter</code>布尔和绘制对象。</p><p id="6a57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，我们要围绕这个圆画圆弧，所以我们用<code class="fe ln lo lp lq b">Rect.fromCircle()</code>这个方法作为第一个参数。第二个参数是我们应用到-pi/2的开始角度，因为我们想从圆的顶部开始角度。</p><p id="de1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">扫描角度指定了弧的结束位置，我们应用了总角度的40%,即我们的弧将从-pi/2到总360弧度的40%绘制。</p><p id="e33a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe ln lo lp lq b">useCenter</code> <strong class="kt ir"> </strong>布尔为真，则圆弧闭合回圆心，形成一个扇形圆。否则，圆弧不闭合，形成一个圆段。最后一个参数是我们已经熟悉的绘画对象。</p><p id="e6e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">useCenter</code>设置为真的当前实施将导致以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/e7e70b031758249930382bd8b4cc9a56.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*C4427kqezZ2E0_up5ymFWg.png"/></div></figure><p id="8d97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是我们不想要那个圆形扇区，所以将它设置为false会导致如下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/59d7eae8451bcb83708c5d5e11225e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*KV_jhGVoa7GUcZ01JbAYxw.png"/></div></figure><p id="ce1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以调整<code class="fe ln lo lp lq b">startAngle</code>、<code class="fe ln lo lp lq b">endAngle</code>来查看各种效果。</p><p id="e4d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们几乎接近了我们想要实现的目标。唯一剩下的部分是动画的进展。为了做到这一点，我们必须使用显式动画，即我们必须创建<code class="fe ln lo lp lq b">AnimationController</code>并将其值传递给<code class="fe ln lo lp lq b">RingPainter</code>类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="8742" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在做的各种事情是:</p><ol class=""><li id="5102" class="mb mc iq kt b ku kv kx ky la md le me li mf lm mg mh mi mj bi translated">将我们的<code class="fe ln lo lp lq b">RingPainter</code> <code class="fe ln lo lp lq b">StatelessWidget</code>转换为有状态小部件，以便在动画值改变时重建UI。</li><li id="5ddf" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated">通过混合我们的<code class="fe ln lo lp lq b">_RingPainterState</code>类和<code class="fe ln lo lp lq b">SingleTickerProviderStateMixin</code>创建了<code class="fe ln lo lp lq b">AnimationController</code>控制器，并在<code class="fe ln lo lp lq b">initState()</code>方法中初始化了它。</li><li id="6508" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated">用<code class="fe ln lo lp lq b">_controller.forward()</code>开始动画</li><li id="a7c2" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated">在控制器中添加了监听器，并调用了一个<code class="fe ln lo lp lq b">setState((){})</code>，这样每当<code class="fe ln lo lp lq b">_controller</code>的值改变时，我们的整个UI都会重建。</li><li id="c33d" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated">现在我们的<code class="fe ln lo lp lq b">MyPainter</code> <strong class="kt ir"> </strong>类需要三个必需的参数:圆的笔画和填充颜色的<code class="fe ln lo lp lq b">progress</code>、<code class="fe ln lo lp lq b">defaultColor</code>。这样做是为了传递来自该类外部的各种值，并使该组件可重用。请注意，<code class="fe ln lo lp lq b">shouldRepaint()</code>方法已经更新，因此我们的<code class="fe ln lo lp lq b">Circle</code>应该只在进度值与之前的值不同时绘制。</li><li id="c4c3" class="mb mc iq kt b ku mk kx ml la mm le mn li mo lm mg mh mi mj bi translated">最后将这三个参数传递给<code class="fe ln lo lp lq b">MyPainter</code> <strong class="kt ir"> </strong>类，进度值是动画的当前值。</li></ol><p id="6548" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过当前的实施，我们成功实现了这一目标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/26cbdbbe1cddbbf4487a18a82a8486c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7Cw_N40IXk8IUCxUiTMFUg.gif"/></div></div></figure><p id="aa5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇，我们快到终点了！剩下唯一要做的就是在圆圈中间添加一个图标，并根据动画是否完成来改变它的颜色。</p><p id="2d7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实现这一点，请像这样更新您的构建方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="39dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下实现将导致这种情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/faa048f3e0216df0af5236343f227550.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IJ3k4iAr9xiZEBYxlB6YEw.gif"/></div></div></figure><p id="f94a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以现在成功地实现了我们的愿望。</p><p id="817f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望您已经了解了一些关于<code class="fe ln lo lp lq b">CustomPaint</code>小部件的知识。现在你可以自己探索实现各种其他效果。</p><p id="a9b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>