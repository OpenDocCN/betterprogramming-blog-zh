<html>
<head>
<title>Understanding the Node.js Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Node.js事件循环</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-node-js-event-loop-a4030f4b0716?source=collection_archive---------7-----------------------#2021-05-18">https://betterprogramming.pub/understanding-the-node-js-event-loop-a4030f4b0716?source=collection_archive---------7-----------------------#2021-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3eb9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">澄清事件循环概念的5个场景</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/44d72e06eaa16703c38f8db6ed06a8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ej59Xn1ozUSVoYP4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@jacday_alabaster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰奎琳·戴</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片。</p></figure><p id="b9e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是单线程的，那么当它等待一个动作完成时，如何处理异步代码而不阻塞主线程呢？理解JavaScript异步本质的关键是理解事件循环。</p><p id="748d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器中，<a class="ae ky" href="https://www.educative.io/edpresso/what-is-an-event-loop-in-javascript" rel="noopener ugc nofollow" target="_blank">事件循环</a>协调调用堆栈、web APIs和回调队列之间的代码执行。然而，Node.js实现了它自己的“<a class="ae ky" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank"> Node.js事件循环</a>，这不同于常规的“JavaScript事件循环”多么令人困惑！</p><p id="5aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Node.js事件循环遵循许多与JavaScript事件循环相同的模式，但工作方式略有不同，因为它不与DOM交互，但处理输入和输出(I/O)之类的事情。</p><p id="8e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将深入Node.js事件循环背后的理论，然后看几个使用<code class="fe lv lw lx ly b">setTimeout</code>、<code class="fe lv lw lx ly b">setImmediate</code>和<code class="fe lv lw lx ly b">process.nextTick</code>的例子。我们甚至会将一些工作代码部署到Heroku(一种快速部署应用程序的简单方法)上，来看看这一切是如何进行的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e184" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">Node.js事件循环</h1><p id="a4f3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Node.js事件循环协调来自计时器、回调和I/O事件的操作的执行。这就是Node.js在保持单线程的同时处理异步行为的方式。让我们看看下面的事件循环图，以便更好地理解操作顺序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/2f123120f34a664072d295b4b49083db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NdZ2nclFRYaHZ81r.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Node.js事件循环的操作顺序(来源:<a class="ae ky" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" rel="noopener ugc nofollow" target="_blank"> Node.js文档</a>)</p></figure><p id="287c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如你所见，Node.js事件循环中有六个主要阶段。让我们简单看一下每个阶段发生了什么:</p><ul class=""><li id="688f" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">定时器</strong>:由<code class="fe lv lw lx ly b">setTimeout</code>和<code class="fe lv lw lx ly b">setInterval</code>安排的回调在此阶段执行。</li><li id="7cfd" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">挂起的回调</strong>:之前被推迟到下一次循环迭代的I/O回调在这个阶段被执行。</li><li id="36a8" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">空闲，准备</strong>:此阶段仅供Node.js内部使用。</li><li id="1215" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu"> Poll </strong>:在此阶段检索新的I/O事件并执行I/O回调(由定时器调度的回调、<code class="fe lv lw lx ly b">setImmediate</code>调度的回调和关闭回调除外，因为它们都在不同的阶段处理)。</li><li id="dd04" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">检查</strong>:本阶段执行<code class="fe lv lw lx ly b">setImmediate</code>安排的回调。</li><li id="83ec" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><strong class="lb iu">关闭回调</strong>:关闭回调，就像套接字连接被破坏时一样，在这个阶段执行。</li></ul><p id="5987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，<code class="fe lv lw lx ly b">process.nextTick</code>在这些阶段都没有被提及。这是因为它是一个特殊的方法，从技术上讲，它不是Node.js事件循环的一部分。相反，无论何时调用<code class="fe lv lw lx ly b">process.nextTick</code>方法，它都会将其回调放入队列中。根据文档的说法，那些排队的回调“在当前操作完成后被处理，不管事件循环的当前阶段”</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3832" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">事件循环示例场景</h1><p id="cb06" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在，如果你和我一样，对Node.js事件循环的每个阶段的解释可能仍然有点抽象。我通过看和做来学习，所以我在Heroku 上创建了这个演示应用程序来运行各种代码片段示例。在应用程序中，单击任何示例按钮都会向服务器发送一个API请求。然后，Node.js在后端执行所选示例的代码片段，并通过API将响应返回给前端。你可以<a class="ae ky" href="https://github.com/thawkin3/nodejs-event-loop-demo" rel="noopener ugc nofollow" target="_blank">在GitHub </a>上查看完整代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/b833bf67fcd9bd0187fd31e6ae40e5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dzFRjNfP4vekIZvd.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Node.js事件循环演示应用程序</p></figure><p id="aebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些例子来更好地理解Node.js事件循环中的操作顺序。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="9187" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">示例1</h2><p id="2e45" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们从一个简单的开始:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/21ed50d61cc9befd8999cc0a587afef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6LCXrOMn_n5Yq18I.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例1 —同步代码</p></figure><p id="80f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有三个相继调用的同步函数。因为这些函数都是同步的，所以代码只是从上到下执行。因为我们按照<code class="fe lv lw lx ly b">first</code>、<code class="fe lv lw lx ly b">second</code>、<code class="fe lv lw lx ly b">third</code>的顺序调用函数，所以函数的执行顺序也是一样的:<code class="fe lv lw lx ly b">first</code>、<code class="fe lv lw lx ly b">second</code>、<code class="fe lv lw lx ly b">third</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="58e2" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">示例2</h2><p id="24ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来，我们将通过第二个例子介绍<code class="fe lv lw lx ly b">setTimeout</code>的概念:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f2686c4bb0af8e2d9b5621edb71bcc66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wmjCOMAoGAlNhE0c.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例2 —设置超时</p></figure><p id="d451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们调用我们的<code class="fe lv lw lx ly b">first</code>函数，使用<code class="fe lv lw lx ly b">setTimeout</code>调度我们的<code class="fe lv lw lx ly b">second</code>函数，延迟为零毫秒，然后调用我们的<code class="fe lv lw lx ly b">third</code>函数。这些功能按以下顺序执行:<code class="fe lv lw lx ly b">first</code>、<code class="fe lv lw lx ly b">third</code>、<code class="fe lv lw lx ly b">second</code>。这是为什么呢？为什么<code class="fe lv lw lx ly b">second</code>函数最后执行？</p><p id="edb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几个关键原则需要理解。第一个原则是，使用<code class="fe lv lw lx ly b">setTimeout</code>方法并提供延迟值<em class="oh">并不意味着</em>回调函数将在毫秒数之后<em class="oh">执行。更确切地说，该值表示在回调被执行之前需要经过的最小时间量。</em></p><p id="b425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要理解的第二个关键原则是使用<code class="fe lv lw lx ly b">setTimeout</code>将回调安排在稍后的时间执行，这将总是至少在事件循环的下一次迭代期间。因此，在事件循环的第一次迭代中，执行了<code class="fe lv lw lx ly b">first</code>函数，调度了<code class="fe lv lw lx ly b">second</code>函数，执行了<code class="fe lv lw lx ly b">third</code>函数。然后，在事件循环的第二次迭代期间，达到了零毫秒的最小延迟，因此在第二次迭代的“计时器”阶段执行了<code class="fe lv lw lx ly b">second</code>函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="7463" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">示例3</h2><p id="45a4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来，我们将通过第三个例子介绍<code class="fe lv lw lx ly b">setImmediate</code>的概念:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/6f857b5699f71488f00b40d0aff0c7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iOToh39qiIatWVSp.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例3 — setImmediate与setTimeout</p></figure><p id="f64f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们执行我们的<code class="fe lv lw lx ly b">first</code>函数，使用<code class="fe lv lw lx ly b">setTimeout</code>调度我们的<code class="fe lv lw lx ly b">second</code>函数，延迟为零毫秒，然后使用<code class="fe lv lw lx ly b">setImmediate</code>调度我们的<code class="fe lv lw lx ly b">third</code>函数。这个例子回避了下面的问题:在这个场景中，哪种类型的调度优先？<code class="fe lv lw lx ly b">setTimeout</code>还是<code class="fe lv lw lx ly b">setImmediate</code>？</p><p id="caed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经讨论了<code class="fe lv lw lx ly b">setTimeout</code>是如何工作的，所以我们应该简单介绍一下<code class="fe lv lw lx ly b">setImmediate</code>方法的背景。<code class="fe lv lw lx ly b">setImmediate</code>方法在事件循环下一次迭代的“检查”阶段执行其回调函数。所以如果<code class="fe lv lw lx ly b">setImmediate</code>在事件循环的第一次迭代中被调用，它的回调方法将被调度，然后在事件循环的第二次迭代中被执行。</p><p id="9184" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从输出中可以看到，本例中的函数是按以下顺序执行的:<code class="fe lv lw lx ly b">first</code>、<code class="fe lv lw lx ly b">third</code>、<code class="fe lv lw lx ly b">second</code>。所以在我们的例子中，<code class="fe lv lw lx ly b">setImmediate</code>调度的回调在<code class="fe lv lw lx ly b">setTimeout</code>调度的回调之前执行。</p><p id="f3d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，您看到的<code class="fe lv lw lx ly b">setImmediate</code>和<code class="fe lv lw lx ly b">setTimeout</code>的行为可能会因调用这些方法的上下文而异。当从Node.js脚本中的主模块直接调用这些方法时，<a class="ae ky" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#setimmediate-vs-settimeout" rel="noopener ugc nofollow" target="_blank">时间取决于进程的性能</a>，所以每次运行脚本时，回调实际上可以按任意顺序执行。然而，当这些方法在一个I/O周期内被调用时，<code class="fe lv lw lx ly b">setImmediate</code>回调总是在<code class="fe lv lw lx ly b">setTimeout</code>回调之前被调用。因为在我们的例子中，我们调用这些方法作为API端点响应的一部分，所以我们的<code class="fe lv lw lx ly b">setImmediate</code>回调总是在<code class="fe lv lw lx ly b">setTimeout</code>回调之前执行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="f244" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">实例4</h2><p id="42f9" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">作为快速检查，让我们使用<code class="fe lv lw lx ly b">setImmediate</code>和<code class="fe lv lw lx ly b">setTimeout</code>再运行一个例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/f9a2ef8e9607d7ad2ef6dbe2e5f90bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V_UCu5Gwy07G4yus.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例4 —再次是setImmediate与setTimeout</p></figure><p id="324e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们使用<code class="fe lv lw lx ly b">setImmediate</code>调度<code class="fe lv lw lx ly b">first</code>函数，执行<code class="fe lv lw lx ly b">second</code>函数，然后使用<code class="fe lv lw lx ly b">setTimeout</code>调度<code class="fe lv lw lx ly b">third</code>函数，延迟为零毫秒。你可能已经猜到了，函数是按照这个顺序执行的:<code class="fe lv lw lx ly b">second</code>、<code class="fe lv lw lx ly b">first</code>、<code class="fe lv lw lx ly b">third</code>。这是因为<code class="fe lv lw lx ly b">first</code>函数被调度，立即执行<code class="fe lv lw lx ly b">second</code>函数，然后调度<code class="fe lv lw lx ly b">third</code>函数。在事件循环的第二次迭代中，<code class="fe lv lw lx ly b">second</code>函数被执行，因为它是由<code class="fe lv lw lx ly b">setImmediate</code>调度的，并且我们处于I/O循环中，然后<code class="fe lv lw lx ly b">third</code>函数被执行，因为我们处于事件循环的第二次迭代中，并且指定的零毫秒延迟已经过去。</p><p id="c7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你开始掌握它的窍门了吗？</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h2 id="5933" class="nt mh it bd mi nu nv dn mm nw nx dp mq li ny nz ms lm oa ob mu lq oc od mw oe bi translated">实例5</h2><p id="67b2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们看最后一个例子。这一次，我们将介绍另一种叫做<code class="fe lv lw lx ly b">process.nextTick</code>的方法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/cd1d5d6fc591be184a251670afce45f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uYzDY15_GaoXwu1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例5 — process.nextTick</p></figure><p id="b5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们使用<code class="fe lv lw lx ly b">setImmediate</code>调度<code class="fe lv lw lx ly b">first</code>函数，使用<code class="fe lv lw lx ly b">process.nextTick</code>调度<code class="fe lv lw lx ly b">second</code>函数，使用<code class="fe lv lw lx ly b">setTimeout</code>调度<code class="fe lv lw lx ly b">third</code>函数，延迟为零毫秒，然后执行<code class="fe lv lw lx ly b">fourth</code>函数。这些函数最终按以下顺序被调用:<code class="fe lv lw lx ly b">fourth</code>、<code class="fe lv lw lx ly b">second</code>、<code class="fe lv lw lx ly b">first</code>、<code class="fe lv lw lx ly b">third</code>。</p><p id="d458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先执行<code class="fe lv lw lx ly b">fourth</code>函数的事实并不令人惊讶。这个函数被直接调用，没有被我们的任何其他方法调度。第二次执行<code class="fe lv lw lx ly b">second</code>功能。这是和<code class="fe lv lw lx ly b">process.nextTick</code>约好的。第三个执行的是<code class="fe lv lw lx ly b">first</code>函数，最后执行的是<code class="fe lv lw lx ly b">third</code>函数，这对于我们来说并不奇怪，因为我们已经知道在一个I/O周期内，由<code class="fe lv lw lx ly b">setImmediate</code>调度的回调在由<code class="fe lv lw lx ly b">setTimeout</code>调度的回调之前执行。</p><p id="da44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，为什么<code class="fe lv lw lx ly b">process.nextTick</code>调度的<code class="fe lv lw lx ly b">second</code>函数先于<code class="fe lv lw lx ly b">setImmediate</code>调度的<code class="fe lv lw lx ly b">first</code>函数被执行呢？这里的方法名有误导性！你可能会认为来自<code class="fe lv lw lx ly b">setImmediate</code>的回调会在立即执行<em class="oh">，而来自<code class="fe lv lw lx ly b">process.nextTick</code>的回调会在事件循环的下一个节拍</em>执行。然而，<a class="ae ky" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick-vs-setimmediate" rel="noopener ugc nofollow" target="_blank">其实反过来</a>。很困惑，对吧？</p><p id="9519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是，来自<code class="fe lv lw lx ly b">process.nextTick</code>的回调在<em class="oh">期间被立即执行，与调度的阶段</em>相同。来自<code class="fe lv lw lx ly b">setImmediate</code>的回调在事件循环的下一次迭代或滴答中执行。所以在我们的例子中，由<code class="fe lv lw lx ly b">process.nextTick</code>调度的<code class="fe lv lw lx ly b">second</code>函数在由<code class="fe lv lw lx ly b">setImmediate</code>调度的<code class="fe lv lw lx ly b">first</code>函数之前执行是有意义的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5c49" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="56a3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">到目前为止，您应该对Node.js事件循环以及像<code class="fe lv lw lx ly b">setTimeout</code>、<code class="fe lv lw lx ly b">setImmediate</code>和<code class="fe lv lw lx ly b">process.nextTick</code>这样的方法更加熟悉了。您当然可以不深入研究Node.js的内部结构和处理命令的操作顺序。然而，当您开始理解Node.js事件循环时，Node.js就不那么像一个黑盒了。</p><p id="b2fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想再次看到这些例子，你可以随时<a class="ae ky" href="https://nodejs-event-loop-demo.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">查看演示应用</a>或<a class="ae ky" href="https://github.com/thawkin3/nodejs-event-loop-demo" rel="noopener ugc nofollow" target="_blank">查看GitHub </a>上的代码。你甚至可以自己把代码部署到Heroku上。</p><p id="027e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>