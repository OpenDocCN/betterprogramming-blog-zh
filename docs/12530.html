<html>
<head>
<title>Working With JSON in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang与JSON合作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/working-with-json-in-golang-15e242a57b03?source=collection_archive---------4-----------------------#2022-06-11">https://betterprogramming.pub/working-with-json-in-golang-15e242a57b03?source=collection_archive---------4-----------------------#2022-06-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Go处理JSON数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b385d2ed2a127f1183f7a8bb59084775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o87ziJwBZPhBMVQ2DxXx_w.png"/></div></div></figure><p id="7e0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Golang的最大卖点之一是让开发者能够轻松有效地构建高性能、可伸缩的web服务。</p><p id="ece1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">众所周知，在与面向用户的web服务通信时，JSON是数据序列化的行业标准。幸运的是，Go使您能够以一种非常直接和高效的方式使用JSON。在本文中，我将:</p><ul class=""><li id="9f6d" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">演示如何使用内置于Go标准库中的<a class="ae lz" href="https://pkg.go.dev/encoding/json" rel="noopener ugc nofollow" target="_blank"> JSON模块</a></li><li id="cdd4" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">展示如何将JSON数据转换成Go对象，反之亦然</li><li id="0134" class="lq lr it kw b kx ma la mb ld mc lh md ll me lp lv lw lx ly bi translated">讨论一些可以加快JSON使用过程的简洁工具</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="227a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Go有非常强大的标准库。对于JSON数据的处理，我们不需要获取任何第三方库，因为内置的库包含了我们需要的所有内容。</p><p id="6483" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个代码片段，它使用JSON进行一些基本的操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="5b50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常基本的例子，在这个例子中，我们获取一部分Go结构(本例中是books)并将其序列化为JSON格式，这样我们就可以通过网络将它发送给请求该数据的客户机。</p><p id="7295" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经注意到的第一件事是我们定义Book struct的字段的方式。我们的struct的每个属性都定义了它在序列化为JSON时在反斜杠<code class="fe mo mp mq mr b">(json:”title”)</code>中的显示方式。</p><p id="78cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是Go的一个非常有用的特性，你可以通过将<code class="fe mo mp mq mr b">title</code>改为<code class="fe mo mp mq mr b">book_title</code>来轻松测试。当需要在REST API中更改JSON响应的格式时，这非常有用。</p><p id="78c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们看看我们实际转换数据的方式Marshal方法接受一个空接口(这意味着您可以传递您喜欢的任何Go数据结构),并尝试序列化数据。如果不能，您将得到一个错误。这就是为什么检查错误非常重要。如果序列化成功，它将返回准备通过网络传输的一部分字节。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="c3fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一下相反的情况，正在接收一个JSON数据流，需要将其转换为Go数据结构，以便Go程序可以操作数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a78f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很明显，我们在这里几乎颠倒了这个过程，但是有一件重要的事情需要注意——当解组数据时，我们需要传递一个指向<code class="fe mo mp mq mr b">Book</code>结构片的指针，而不是实际的片。这是因为与Java或Python不同，Go是一种按值传递的语言。这意味着如果我们想修改一个变量的状态，我们需要使用它的指针，否则只会传递那个变量的一个副本，而初始变量的状态不变。</p><p id="01f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了这些例子中使用的<code class="fe mo mp mq mr b">json.Marshal/json.Unmarshal</code>方法，JSON序列化的另一种方法是使用<code class="fe mo mp mq mr b">json.Decoder/json.Encoder</code>。</p><p id="e90f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主要的区别是这两个都希望从实现了<code class="fe mo mp mq mr b"><a class="ae lz" href="https://pkg.go.dev/io#Reader" rel="noopener ugc nofollow" target="_blank">io.Reader</a> </code>接口的Go结构中读取数据。传入HTTP请求的请求体就是其中之一。在不构建整个HTTP服务器的情况下，让我们看一下这种情况，我们接受一个HTTP客户端的请求，向我们的集合中添加一本新书:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ef80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在实现HTTP请求处理程序时，使用<code class="fe mo mp mq mr b">json.NewDecoder/json.NewEncoder</code>比使用<code class="fe mo mp mq mr b">json.Marshal/json.UnMarshal</code>更有意义。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="3d84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，使用这些简单的例子是一回事，但是在现实生活中，JSON请求/响应通常是一个充满嵌套对象的大型结构，那该怎么办呢？除了定义Go结构很容易变得令人头疼之外，实现还是差不多的。手动写出几次结构后，我发现了一个非常有用的工具来自动完成这项工作。这里可以找到<a class="ae lz" href="https://mholt.github.io/json-to-go/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="2f89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个来自rick和morty API的例子。您可以通过调用以下命令来查看HTTP响应:</p><p id="3b37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lz" href="https://rickandmortyapi.com/api/character/418" rel="noopener ugc nofollow" target="_blank">https://rickandmortyapi.com/api/character/418</a></p><p id="2d28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您将响应粘贴到JSON-to-Go工具中时，您会得到:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/79f984d507d0a8b73d2c0c0741b7cf13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fv8FnzGxiCaIRJOn3h_pWg.png"/></div></div></figure><p id="a907" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相当快速的转换！不需要手动输入结构，也不需要计算哪个嵌套的JSON对象需要转换成哪个Go结构。</p><p id="8e11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">等等，你说你并不真的需要Go struct，而是更喜欢Go map？不用担心，您可以在这里轻松地进行转换:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/4b8aa1b717826a650925c172ef7558d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D2D3J7GXmkXFxztQ870smQ.png"/></div></div></figure></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="a0cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文到此为止。希望你觉得有用。感谢阅读！</p></div></div>    
</body>
</html>