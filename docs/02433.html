<html>
<head>
<title>Which Is the Fastest: While, For, forEach(), For…of?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">While，For，forEach()，For…of哪个最快？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/which-is-the-fastest-while-for-foreach-for-of-9022902be15e?source=collection_archive---------2-----------------------#2019-12-01">https://betterprogramming.pub/which-is-the-fastest-while-for-foreach-for-of-9022902be15e?source=collection_archive---------2-----------------------#2019-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3577" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">比较JavaScript迭代结构的速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f3031cfa34a5bb17cb81e944000b4a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QkCQ7QSouyGlM84-q-Urpg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/photos/KXkgOigCqj0" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e838" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不是全职开发人员，所以我依靠我的基础知识来完成需要编写代码的项目。当我发现JavaScript的<a class="ae ky" href="https://medium.com/better-programming/stop-using-for-loops-to-iterate-over-arrays-5c46940e79d1" rel="noopener">时，我非常兴奋。forEach() </a>方法作为传统for循环的替代。然而，我因为没有及时更新JavaScript所提供的最新版本而受到了善意的斥责——参考循环的<a class="ae ky" href="https://medium.com/better-programming/use-for-of-to-loop-through-your-javascript-arrays-57ebb900ab5a" rel="noopener">for……。</a></p><p id="a868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据那些评论我上一篇文章的人所说，<code class="fe lv lw lx ly b">for...of</code>技术在速度和可读性上都优于<code class="fe lv lw lx ly b">.forEach()</code>。因为我不编写处理时间真正起作用的大规模应用程序，所以我很想发现一些东西。每种类型的迭代结构有多快(或多慢)？</p><p id="2012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我决定测试一下，并分享我的结果。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7e01" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">环形引物</h1><p id="68ea" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在我们开始之前，让我们对不同类型的迭代结构做一个30秒的回顾。</p><ul class=""><li id="43ff" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><strong class="lb iu"> While循环</strong>:最简单的循环机制。只要给定表达式的计算结果为<code class="fe lv lw lx ly b">true</code>，while循环就会执行。</li><li id="15a5" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu"> For循环</strong>:迭代次数已知时有用的迭代结构。for循环的声明有三个组成部分:变量的初始化，确定循环是否结束的表达式，以及在每次迭代结束时执行的语句。</li><li id="55c2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu">。forEach()方法</strong>:array类的一个方法，它采用单个参数，即一个函数，并对数组中的每个元素执行该函数。</li><li id="c318" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><strong class="lb iu"> For…of Loop </strong>:最近添加的迭代结构，该语句要求指定一个临时变量名，数组中的每个元素在迭代时都将被赋予这个临时变量名。</li></ul><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="e636" class="nv mh it ly b gy nw nx l ny nz">let arr = [];</span><span id="7c80" class="nv mh it ly b gy oa nx l ny nz">// while loop<br/>let i=0;<br/>while(i &lt; arr.length) {<br/>  // do stuff<br/>  i++;<br/>}</span><span id="d1ba" class="nv mh it ly b gy oa nx l ny nz">// for loop<br/>for(let i=0; i&lt;arr.length; i++) {<br/>  // do stuff<br/>}</span><span id="6123" class="nv mh it ly b gy oa nx l ny nz">// .forEach() method<br/>arr.forEach((element) =&gt; {<br/>  // do stuff<br/>});</span><span id="c7b5" class="nv mh it ly b gy oa nx l ny nz">// for...of loop<br/>for(const element of arr) {<br/>  // do stuff<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="357c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">测试场景</h1><p id="9583" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了测试每个循环的速度，我创建了10、100、1，000和1，000，000个整数的数组。<strong class="lb iu">在每个循环中，不执行任何计算</strong>。两种方法，<code class="fe lv lw lx ly b">console.time()</code>和<code class="fe lv lw lx ly b">console.timeEnd()</code>，用于报告每种技术的速度。</p><h2 id="d8b4" class="nv mh it bd mi ob oc dn mm od oe dp mq li of og ms lm oh oi mu lq oj ok mw ol bi translated">结果</h2><p id="48e1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">结果很有趣，不是我所期待的。所有时间都以毫秒为单位。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/0b698f98f71441da69b5f865844f57f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rc30xdezgXIw-YtoccCXPQ.png"/></div></div></figure><p id="95c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我从这个练习中得到的一些主要收获:</p><ul class=""><li id="9e5a" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">循环最适合大型数组。</li><li id="dbe8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">对于小型数据集，循环无疑是最快的，但是对于大型数据集，它们的伸缩性很差。</li><li id="4f1b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">.forEach()</code>和<code class="fe lv lw lx ly b">for...of</code>足够接近，任何一方都不应该在表现上孤立对方。</li><li id="dbb1" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><code class="fe lv lw lx ly b">.forEach()</code>的执行时间受到每次迭代中发生的事情的显著影响。</li><li id="bfaf" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">标准的<code class="fe lv lw lx ly b">for</code>循环普遍表现平平。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="978d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我确信改变测试用例将会提供更深的洞察力。然而，作为一个生死相隔不到一毫秒的人，这足以满足我的好奇心。</p><p id="2acc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在下面的评论中告诉我你的想法。你有一个用例，其中一种方法远远优于其他方法吗？如何决定使用哪种迭代结构？</p></div></div>    
</body>
</html>