<html>
<head>
<title>Introduction to Non-escaping Closures in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的非转义闭包介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-non-escaping-closures-in-swift-3d6e8c4c6350?source=collection_archive---------11-----------------------#2022-01-17">https://betterprogramming.pub/introduction-to-non-escaping-closures-in-swift-3d6e8c4c6350?source=collection_archive---------11-----------------------#2022-01-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4361" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们来谈谈Swift中的非转义闭包是什么，以及它们在内存方面是如何工作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b3cdef8bc7cdd72f4e0a6974f1305a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5SubztE9hj0ZdWP94Z9Wg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@lureofadventure?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Ali Kazal </a>在<a class="ae kv" href="https://unsplash.com/s/photos/escape?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="51b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Swift中，闭包是一个自包含的代码块，可以在声明它的环境或上下文中捕获变量。闭包在Swift中被视为一等公民:它们可以作为参数传递，分配给属性，或者由其他闭包返回。</p><h2 id="7eab" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">非逃逸与逃逸</h2><p id="9a27" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在Swift中，当处理网络请求或其他异步操作时，我们通常会看到<code class="fe mq mr ms mt b">@escaping</code>属性。转义闭包是指可以在使用它的范围内存活(转义)的闭包，也就是说，它甚至可以在函数体被执行之后被调用。</p><p id="5b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，一旦函数体被执行，非转义闭包就会超出作用域并停止存在于内存中。</p><p id="7d23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看一个代码示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="04e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong> : Online 17，由于<code class="fe mq mr ms mt b">self</code> <em class="mw"> </em>正在闭包内部使用，<em class="mw"> </em>我们需要使用一个<code class="fe mq mr ms mt b">[weak self]</code>捕获列表来避免任何内存泄漏。</p><p id="3f9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们特别注意第4行:我们将<code class="fe mq mr ms mt b">onClose</code>参数标记为转义。由于它是一个转义闭包，我们可以将它赋给存储属性。如果您试图删除<code class="fe mq mr ms mt b">@escaping</code>标记，您将面临以下编译错误:</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="970d" class="ls lt iq mt b gy nb nc l nd ne">Assigning non-escaping parameter 'onClose' to an @escaping closure</span></pre><p id="f10c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发生这种情况是因为非转义闭包不能被存储以供函数范围之外的进一步使用。</p><p id="36c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于非转义闭包，Apple将其用于大多数内置的高阶函数(接收一个或多个函数作为参数和/或返回一个函数作为结果的函数):</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="d026" class="ls lt iq mt b gy nb nc l nd ne">let mappedNumbers = numbers.map({ $0 * 2 })<br/>let filteredNumbers = numbers.filter({ $0 &gt; 100 })<br/>let summedNumbers = numbers.reduce(0, { x, y in x + y})</span></pre><p id="b55d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们三个接收一个闭包作为参数，这些参数没有被标记为转义。从Swift 3开始，闭包默认是不可转义的，如果不使用<code class="fe mq mr ms mt b">@escaping</code>属性，它们将被视为不可转义的:</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="251e" class="ls lt iq mt b gy nb nc l nd ne">func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T]</span><span id="3460" class="ls lt iq mt b gy nf nc l nd ne">func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; [Element]</span><span id="caae" class="ls lt iq mt b gy nf nc l nd ne">func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result</span></pre><h2 id="4ba0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">内存管理</h2><p id="c2b2" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">与转义闭包相反，非转义闭包不会被存储以供后续执行(一旦函数体被执行，它们就不再存在)。这意味着非转义闭包<strong class="ky ir">不能创建保持周期</strong>。</p><p id="c04d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您必须熟悉在闭包定义中使用<code class="fe mq mr ms mt b">[weak self]</code>或<code class="fe mq mr ms mt b">[unwoned self]</code>来捕获当前状态，以打破保持循环。在处理非转义闭包时，这两者都不是必需的:</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="495b" class="ls lt iq mt b gy nb nc l nd ne"><strong class="mt ir">// Unnecessary [weak self] capture list</strong><br/>let filteredNumbers = numbers.filter({ <strong class="mt ir">[weak self]</strong> number in <br/>    self.anyOtherMethod(number)<br/>})</span></pre><h2 id="5266" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用非转义闭包的过滤器实现</h2><p id="6271" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们来看看苹果的滤镜方法声明:</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="89b9" class="ls lt iq mt b gy nb nc l nd ne">func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; [Element]</span></pre><p id="f997" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，filter方法接收一个非转义闭包作为参数(如前所述，从Swift 3开始，默认情况下闭包是非转义的)。让我们试着想出这个方法的一个实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d55c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以这样使用它:</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="3378" class="ls lt iq mt b gy nb nc l nd ne"><strong class="mt ir">let</strong> items = [1, 0, 3, 4, 5]<br/>let nonZeroItems = items.filterReplica { item in item != 0 }</span></pre><p id="59bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们尝试创建一个额外的变量，以便更容易地看到传递给我们的filter方法的闭包:</p><pre class="kg kh ki kj gt mx mt my mz aw na bi"><span id="e0bb" class="ls lt iq mt b gy nb nc l nd ne"><strong class="mt ir">let</strong> closure = { item <strong class="mt ir">in<br/>    return</strong> item != 0<br/>}<br/><strong class="mt ir">let</strong> items = [1, 0, 3, 4, 5]<br/>let nonZeroItems = items.filterReplica(closure)</span></pre><p id="e425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设filter方法没有将接收到的闭包标记为转义闭包，那么一旦items迭代完成，它就会停止存在，所以根本不需要担心会产生不必要的保留循环。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="5268" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我希望这篇关于非转义闭包的简要介绍对您有用。</p></div></div>    
</body>
</html>