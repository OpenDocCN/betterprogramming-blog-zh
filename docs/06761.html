<html>
<head>
<title>Build a General Purpose API Kit With Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Combine构建一个通用API包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-general-purpose-api-kit-with-combine-9344cfcf5a1b?source=collection_archive---------13-----------------------#2020-11-02">https://betterprogramming.pub/build-a-general-purpose-api-kit-with-combine-9344cfcf5a1b?source=collection_archive---------13-----------------------#2020-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="558a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">无论远程主机、HTTP方法或响应类型如何，这种方法都可以满足您的应用程序可能需要的任何目的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36d2b640210fb1d0d0b7bfdcf56fc6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxqC8M0qWbERAqS5y8_O0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://bytenbit.com/best-guidelines-design-restful-api/" rel="noopener ugc nofollow" target="_blank"> Bytenbit </a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fb83" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="825b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">无论如何，99%的应用程序需要访问存储在远程服务器上的数据，因此有一个API客户端来处理HTTP请求/响应是必不可少的。现在，尽管这些数据通常来自单一来源，但有多个来源也并不罕见。例如，假设您希望通过使用<a class="ae ky" href="https://www.accuweather.com" rel="noopener ugc nofollow" target="_blank"> AccuWeather </a>在您的应用程序中显示天气信息，或者您希望通过使用<a class="ae ky" href="https://firebase.google.com/docs/reference/swift/firebasedatabase/api/reference/Classes" rel="noopener ugc nofollow" target="_blank"> Firebase </a>实现一个仅限移动设备的功能。</p><p id="d2c3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">此外，这些远程数据可能不总是像我们习惯的那样是JSON文件。它可以是JSON类型……也可以是图像、存折、XML、PDF……或者简单的纯文本！在这些场景中，我们倾向于创建一个不同的<code class="fe mz na nb nc b">Webservice/Repository/API Client</code>，但是这是完全必要的吗？</p><p id="b574" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在本教程中，我们将实现一个通用的API客户端，将所有这些方法统一到一个通用的解决方案中。我们将应用以下概念:</p><ul class=""><li id="e93a" class="nd ne it ma b mb mu me mv mh nf ml ng mp nh mt ni nj nk nl bi translated">关注点分离原则</li><li id="2471" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated">协议扩展</li><li id="df2b" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated">无商标消费品</li><li id="e71a" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated">一等职能或作为一等公民的职能</li></ul><p id="3b07" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们的目标是实现一个优雅且易于使用的API客户端，它允许我们发出任何类型的HTTP请求:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="4426" class="nv lh it nc b gy nw nx l ny nz">@Published var beers: [Beer] = []<br/>@Published var beerPassbook: PKPass?<br/>@Published var beersMenu: PDFDocument?</span><span id="6767" class="nv lh it nc b gy oa nx l ny nz">func fetchData() {<br/>    apiClient<br/>        .send(BeersRequest())<br/>        .json()<br/>        .replaceError(with: [])<br/>        .assign(to: \.beers, on: self)<br/>        .store(in: &amp;disposeBag)</span><span id="7fa2" class="nv lh it nc b gy oa nx l ny nz">    apiClient<br/>        .send(BeerPassbookRequest())<br/>        .passbook()<br/>        .replaceError(with: nil)<br/>        .assign(to: \.beerPassbook, on: self)<br/>        .store(in: &amp;disposeBag)</span><span id="b65f" class="nv lh it nc b gy oa nx l ny nz">    apiClient<br/>        .send(BeersMenuRequest())<br/>        .pdf()<br/>        .replaceError(with: nil)<br/>        .assign(to: \.beersMenu, on: self)<br/>        .store(in: &amp;disposeBag)<br/>}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="ea55" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">SRP和协议扩展:请求与API客户端</h1><p id="165d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当实现远程存储库时，我们有时倾向于将端点或URL耦合到存储库:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="6602" class="nv lh it nc b gy nw nx l ny nz">class MyRemoteRepository {<br/>    let usersURL = "https://api.example.com/users"</span><span id="ef0c" class="nv lh it nc b gy oa nx l ny nz">    func fetchUsers() -&gt; AnyPublisher&lt;[User], Never&gt; {<br/>        let url = URL(string: usersURL)!<br/>        URLSession.shared<br/>            .dataTaskPublisher(for: url)<br/>            .decode(type: [User].self, decoder: JSONDecoder())<br/>            .replaceError(with: [])<br/>            .eraseToAnyPublisher()<br/>    }</span><span id="8dd4" class="nv lh it nc b gy oa nx l ny nz">    func fetchUser(id: Int) -&gt; AnyPublisher&lt;User, Never&gt; {<br/>        ...<br/>    }</span><span id="4c35" class="nv lh it nc b gy oa nx l ny nz">}</span></pre><p id="3f5a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这个实现中，<code class="fe mz na nb nc b">MyRemoteRepository</code>服务于两个不同的目的:</p><ul class=""><li id="8129" class="nd ne it ma b mb mu me mv mh nf ml ng mp nh mt ni nj nk nl bi translated"><code class="fe mz na nb nc b">URLRequest</code>一代</li><li id="9608" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated">HTTP请求/响应处理</li></ul><p id="e061" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">当处理需要HTTP头、HTTP查询项和/或HTTP主体的请求时，这一点尤其明显。在这种情况下，方法实现开始变得有点混乱和不可维护:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="02a6" class="nv lh it nc b gy nw nx l ny nz">func fetchData() {<br/>    let headers = [<br/>        "Authorization": token,<br/>        "Content-Type": "application/json",<br/>        ...<br/>    ]</span><span id="8a2c" class="nv lh it nc b gy oa nx l ny nz">    let queryItems = [<br/>        URLQueryItem(name: "someKey", value: someValue),<br/>        ...<br/>    ]</span><span id="b96b" class="nv lh it nc b gy oa nx l ny nz">    let body = [...]<br/>    let bodyData = JSONSerialization.data(withJSONObject: data, options: .prettyPrinted)</span><span id="42d3" class="nv lh it nc b gy oa nx l ny nz">    // generate URLRequest</span><span id="0733" class="nv lh it nc b gy oa nx l ny nz">    // Handle HTTP request/response<br/>}</span></pre><p id="cfab" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">出于可重用性和关注点分离的考虑，我们为什么不创建一个<code class="fe mz na nb nc b">Request</code>协议，让我们的存储库只处理URL会话呢？</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="59a7" class="nv lh it nc b gy nw nx l ny nz">protocol Request {<br/>    // protocol "contract" here<br/>}</span><span id="a91a" class="nv lh it nc b gy oa nx l ny nz">class MyRemoteRepository {<br/>    func fetchUsers(request: UsersRequest) -&gt; AnyPublisher&lt;[User], Never&gt; {<br/>        guard let urlRequest = request.urlRequest else { <br/>             Just([User]()).eraseToAnyPublisher()<br/>        }</span><span id="65e3" class="nv lh it nc b gy oa nx l ny nz">        URLSession.shared<br/>            .dataTaskPublisher(for: request.urlRequest)<br/>            .decode(type: [User].self, decoder: JSONDecoder())<br/>            .replaceError(with: [])<br/>            .eraseToAnyPublisher()<br/>    }<br/>}</span></pre><p id="a17f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">太好了！通过这个简单的步骤，我们已经成功地从我们的存储库中提取出了所有的<code class="fe mz na nb nc b">URLRequest</code>生成逻辑。那么一个<code class="fe mz na nb nc b">Request</code>到底应该定义什么呢？这是任何HTTP请求都应该具有的基本结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d454" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在<code class="fe mz na nb nc b">Request</code>之上，我们可以创建<code class="fe mz na nb nc b">GetRequest</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2afb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">还有<code class="fe mz na nb nc b">JSONRequest</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="85f6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">通过扩展这些协议，我们为它们的所有实例提供了默认实现。此时，我们可以开始定义我们自己的API端点了:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="dc89" class="nv lh it nc b gy nw nx l ny nz">public enum ApiHosts: String, HTTPHost {<br/>    case punk = "https://api.punkapi.com"<br/>    case cats = "https://api.thecatapi.com"</span><span id="5e45" class="nv lh it nc b gy oa nx l ny nz">    public var url: String { rawValue }<br/>}</span><span id="dd4f" class="nv lh it nc b gy oa nx l ny nz">public struct BeersGetRequest: JSONGetRequest {<br/>    public typealias ResponseType = [Beer]<br/>    public var queryParameters = ["page": "\(page)"]<br/>    public let host: HTTPHost = Hosts.punkApi<br/>    public let path: String = "/v2/beers"<br/>    public let page: Int</span><span id="6187" class="nv lh it nc b gy oa nx l ny nz">    public init(page: Int = 1) {<br/>        self.page = page<br/>    }<br/>}</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5d7a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用泛型:通用客户端</h1><p id="4e3e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在上一节中，我们定义了一个协议<code class="fe mz na nb nc b">Request</code>,允许我们定义API请求，并将请求创建与请求/响应处理分开。然而，我们的存储库仍然使用请求实现，而不是抽象协议。这意味着我们需要一个函数来处理每种请求:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="b133" class="nv lh it nc b gy nw nx l ny nz">class MyRemoteRepository {</span><span id="1682" class="nv lh it nc b gy oa nx l ny nz">    func fetchUsers(request: UsersRequest) -&gt; AnyPublisher&lt;[User], Never&gt; { ... }</span><span id="0d93" class="nv lh it nc b gy oa nx l ny nz">    func fetchUserDetails(request: UserDetailsRequest) -&gt; AnyPublisher&lt;User, Never&gt; { ... }</span><span id="c838" class="nv lh it nc b gy oa nx l ny nz">    func updateUsers(request: UpdateUserRequest) -&gt; AnyPublisher&lt;User, Never&gt; { ... }</span><span id="66bc" class="nv lh it nc b gy oa nx l ny nz">}</span></pre><p id="238b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这看起来工作量很大，尤其是因为每个方法的实现看起来都非常相似。为什么不使用泛型并创建一个方法来“统治它们”？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="4cb3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">通过使用泛型，我们成功地用一种方法处理了所有的请求……但是我们真的做到了吗？注意<code class="fe mz na nb nc b">send</code>只处理<code class="fe mz na nb nc b">JSONRequest</code>。即使这是最常见的情况，可能对我们来说已经足够了，有人可能需要下载一些纯文本、XML、PDF……在这种情况下该怎么办？我们需要添加一个不同的<code class="fe mz na nb nc b">send</code>实现来接受不同类型的请求:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="882f" class="nv lh it nc b gy nw nx l ny nz">public typealias PlainTextGetRequest = PlainTextRequest &amp; GetRequest</span><span id="87c0" class="nv lh it nc b gy oa nx l ny nz">public protocol PlainTextRequest: GetRequest { }</span><span id="0ca2" class="nv lh it nc b gy oa nx l ny nz">extension PlainTextRequest {<br/>    public var headers: HTTPHeaders {<br/>        ["Content-Type": "text/plain"]<br/>    }<br/>}</span><span id="908f" class="nv lh it nc b gy oa nx l ny nz">extension ApiClient {<br/>    public func send&lt;T: PlainTextRequest&gt;(_ request: T) -&gt; AnyPublisher&lt;String, ApiClientError&gt; {<br/>        ...<br/>    }</span><span id="b8e5" class="nv lh it nc b gy oa nx l ny nz">    // More overloads to support PDF, UIImage, PKPass, XML, ...<br/>}</span></pre><p id="8100" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">然而，我们将再次重复不必要的代码。大多数实现看起来都是一样的；差异将出现在解码级别。</p><p id="3609" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">另一个选择是让<code class="fe mz na nb nc b">ApiClient</code>返回<code class="fe mz na nb nc b">Data</code>，每次我们使用这个类时，我们自己做解码部分:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="f1da" class="nv lh it nc b gy nw nx l ny nz">public func send&lt;T: PlainTextRequest&gt;(_ request: T) -&gt; AnyPublisher&lt;Data, ApiClientError&gt; {<br/>    // remove decode line<br/>}</span></pre><p id="99bd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是，同样，这个解决方案并不理想，因为我们会重新陷入代码重复。我们如何用一种可读性强又不失优雅的方式来解决这个问题呢？</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7596" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">APIClient。任务:一级功能</h1><p id="d12b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们已经完成了上一节，实现了API客户端。然而，我们在尝试解码不同类型时遇到了一些问题。为了解决这个问题，我们将改变<code class="fe mz na nb nc b">ApiClient</code>实现来返回一个<code class="fe mz na nb nc b">Task</code>。这个<code class="fe mz na nb nc b">Task</code>将允许我们通过使用函数作为<em class="od">一等公民</em>来解码多种类型，也就是函数作为自变量。</p><p id="2291" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这就是<code class="fe mz na nb nc b">send</code>的样子:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="f595" class="nv lh it nc b gy nw nx l ny nz">public func send&lt;T: Request&gt;(_ request: T) -&gt; Task&lt;T&gt; {<br/>    Task(session: session, request: request)<br/>}</span></pre><p id="e42d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意，我们在这里使用了一个通用的<code class="fe mz na nb nc b">Request</code>，而不是一个更具体的类型，比如<code class="fe mz na nb nc b">JSONRequest</code>。</p><p id="a535" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">那么什么是<code class="fe mz na nb nc b">Task</code>？<code class="fe mz na nb nc b">Task</code>是一个助手类，它将返回一个我们可以订阅的<code class="fe mz na nb nc b">publisher</code>。同样，通过使用泛型和使用不同的解码函数，我们将能够扩展它的功能，并能够解码我们感兴趣的任何类型:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="4496" class="nv lh it nc b gy nw nx l ny nz">extension ApiClient {<br/>    class Task {<br/>        var session: URLSession<br/>        var request: T</span><span id="c60b" class="nv lh it nc b gy oa nx l ny nz">        init(session: URLSession, request: T) {<br/>            // assign arguments<br/>        }</span><span id="8186" class="nv lh it nc b gy oa nx l ny nz">        private func publisher&lt;R&gt;(type: R.Type, decode: @escaping (Data) throws -&gt; R) -&gt; AnyPublisher&lt;R, ApiClientError&gt; {<br/>            // implementation here<br/>        }<br/>}</span></pre><p id="af4e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">漂亮！现在我们只需要用我们需要的类型来扩展<code class="fe mz na nb nc b">Task</code>。例如，纯文本:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="a184" class="nv lh it nc b gy nw nx l ny nz">extension ApiClient.Task {</span><span id="7467" class="nv lh it nc b gy oa nx l ny nz">    public func plainText() -&gt; AnyPublisher&lt;String, ApiClientError&gt; {<br/>        publisher(type: String.self) { data in<br/>            guard let string = String(data: data, encoding: .utf8) else {<br/>                throw ApiClientError.unknown("Couldn't decode response as plain text")<br/>            }<br/>            return string<br/>        }<br/>    }</span><span id="f72b" class="nv lh it nc b gy oa nx l ny nz">}</span></pre><p id="d32d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">JSON:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="486f" class="nv lh it nc b gy nw nx l ny nz">extension ApiClient.Task where T: JSONRequest {<br/><br/>    public func json() -&gt; AnyPublisher&lt;T.ResponseType, ApiClientError&gt; {<br/>        publisher(type: T.ResponseType.self) { (data) in<br/>            do {<br/>                let result = try JSONDecoder().decode(T.ResponseType.self, from: data)<br/>                return result<br/>            } catch let error {<br/>                 throw ApiClientError.decodingError(error)<br/>            }<br/>        }<br/>    }</span><span id="b389" class="nv lh it nc b gy oa nx l ny nz">}</span></pre><p id="398d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">或PDF:</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="6c77" class="nv lh it nc b gy nw nx l ny nz">import PDFKit</span><span id="5ce2" class="nv lh it nc b gy oa nx l ny nz">extension ApiClient.Task {</span><span id="e24a" class="nv lh it nc b gy oa nx l ny nz">    public func pdf() -&gt; AnyPublisher&lt;PDFDocument, ApiClientError&gt; {<br/>        publisher(type: PDFDocument.self) { data in<br/>            guard let pdf = String(data: data, encoding: .utf8) else {<br/>                throw ApiClientError.unknown("Couldn't decode response as pdf")<br/>            }<br/>            return pdf<br/>        }<br/>    }</span><span id="1841" class="nv lh it nc b gy oa nx l ny nz">}</span></pre><p id="32cc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这是不是很容易扩展？你能看到它所有的潜力吗？你可以解码任何类型的文字！</p><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="5426" class="nv lh it nc b gy nw nx l ny nz">// IMAGE<br/>UIImage(data: data)</span><span id="70cc" class="nv lh it nc b gy oa nx l ny nz">// Passbook<br/>try PKPass(data: data)</span><span id="9486" class="nv lh it nc b gy oa nx l ny nz">...</span></pre><p id="225d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下面是完整的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a05f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">后续步骤</h1><p id="0eed" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">下一步是什么？您可以尝试一下实现，并对以下内容进行一些小的修改:</p><ul class=""><li id="813a" class="nd ne it ma b mb mu me mv mh nf ml ng mp nh mt ni nj nk nl bi translated">重用<code class="fe mz na nb nc b">json()</code>实现并允许它解码一个<em class="od">属性列表</em></li><li id="5d37" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated">统一从<code class="fe mz na nb nc b">Data</code>开始初始化的<code class="fe mz na nb nc b">image()</code>、<code class="fe mz na nb nc b">passbook()</code>和其他类型。你甚至可以创建自己的<code class="fe mz na nb nc b">JSONDecodable</code>，并用使用<code class="fe mz na nb nc b">JSONDecoder()</code>的<code class="fe mz na nb nc b">init(data:) throws</code>来扩展它。</li><li id="44f9" class="nd ne it ma b mb nm me nn mh no ml np mp nq mt ni nj nk nl bi translated">将相关调用分组到<em class="od">存储库</em>中以增加详细程度:</li></ul><pre class="kj kk kl km gt nr nc ns nt aw nu bi"><span id="0410" class="nv lh it nc b gy nw nx l ny nz">class UsersRepository {<br/>    let webservice: Webservice</span><span id="190d" class="nv lh it nc b gy oa nx l ny nz">    init(webservice: Webservice = ApiClient()) {<br/>        self.webservice = webservice<br/>    }</span><span id="eb69" class="nv lh it nc b gy oa nx l ny nz">    func fetchUsers() -&gt; AnyPublisher&lt;[User], ApiClientError&gt; {<br/>        webservice.send(UsersRequest()).json()<br/>    }</span><span id="3bc0" class="nv lh it nc b gy oa nx l ny nz">    func fetchUserDetails(id: Int) -&gt; AnyPublisher&lt;User, ApiClientError&gt; {<br/>        let request = UserDetailsRequest(id: id)<br/>        return webservice.send(request).json()<br/>    }</span><span id="f115" class="nv lh it nc b gy oa nx l ny nz">    func updateUserDetails(user: User) AnyPublisher&lt;User, ApiClientError&gt; {<br/>        ...<br/>    }</span><span id="3f8f" class="nv lh it nc b gy oa nx l ny nz">}</span></pre><ul class=""><li id="a99c" class="nd ne it ma b mb mu me mv mh nf ml ng mp nh mt ni nj nk nl bi translated">通过一点重构，扩展了<code class="fe mz na nb nc b">ApiClient</code>的概念，并支持其他类型的请求，而不仅仅是HTTP，例如，对数据库的查询或来自<code class="fe mz na nb nc b">UserDefaults</code>或<code class="fe mz na nb nc b">FileManager</code>的搜索。<code class="fe mz na nb nc b">Task</code>的思想保持不变(从<code class="fe mz na nb nc b">Data</code>解码)，唯一的区别是我们构建请求/查询的方式。</li></ul></div></div>    
</body>
</html>