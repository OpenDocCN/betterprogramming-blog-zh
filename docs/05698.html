<html>
<head>
<title>How to Use JSX Without React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用JSX没有反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-jsx-without-react-21d23346e5dc?source=collection_archive---------1-----------------------#2020-07-29">https://betterprogramming.pub/how-to-use-jsx-without-react-21d23346e5dc?source=collection_archive---------1-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3737" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JSX为我们提供了一个在JavaScript中处理基于HTML的模板的好方法。你知道你可以毫无反应地使用它吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54854bf2de956cc6f3c6161f8844b4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWzDsiggx_KLn28WYwoZJQ.png"/></div></div></figure><p id="40e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我个人是JSX的忠实粉丝，喜欢它允许我拆分和组件化代码的方式。尽管JSX在React之前就已经出现了，但如果没有React，它也不会像现在这样受欢迎。然而，我们实际上可以在没有反应情况下使用JSX，这也不是很困难。</p><p id="2661" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React的工作方式是通过配置你的捆绑器将JSX转换成对一个<code class="fe lq lr ls lt b">createElement</code>函数的调用。比如说:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="7304" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，大多数捆绑器允许你选择你自己的JSX <em class="lw">杂注</em>(将代替<code class="fe lq lr ls lt b">React.createElement</code>的函数)。例如，如果您正在使用Babel，您可以通过一个简单的注释来指定使用什么功能，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="ac19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在巴贝尔会把这些参数传给<code class="fe lq lr ls lt b">myJsxFunction</code>。现在我们需要做的就是创建一个函数，它接受这些参数并创建真正的DOM节点，我们可以将这些节点添加到我们的DOM中。所以让我们开始吧。(如果你需要一个代码沙箱来玩，你可以使用这个静态模板。)</p><p id="c366" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DOM节点是使用<code class="fe lq lr ls lt b">document.createNode()</code>函数创建的。它只需要一个<code class="fe lq lr ls lt b">tag</code>的名字，所以一个好的开始就是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="6f29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了一个DOM节点，我们必须实际添加提供给我们的属性。这些可以是类似于<code class="fe lq lr ls lt b">class</code>或<code class="fe lq lr ls lt b">style</code>的任何东西。所以我们将遍历所有提供的属性(使用<code class="fe lq lr ls lt b">Object.entries</code>)并在DOM节点上设置它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="9ec8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不过，这种方法有一个问题。我们如何处理事件？例如，假设我有这个JSX:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="80ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的函数将把<code class="fe lq lr ls lt b">onClick</code>设置为普通属性，回调设置为实际文本。</p><p id="7956" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">相反，我们可以做的是检查我们的属性是否以<code class="fe lq lr ls lt b">on</code>开始，并且在窗口范围内。这会告诉我们这是不是一个事件。例如，<code class="fe lq lr ls lt b">onclick</code>在窗口范围内；然而，<code class="fe lq lr ls lt b">onfoo</code>不是。如果是，那么我们可以使用不带<code class="fe lq lr ls lt b">on</code>的名称部分在该节点上注册一个事件监听器。</p><p id="73e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="25a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不错！现在剩下要做的就是将所有的子元素添加到父元素中。但是，您不能将字符串追加到DOM节点，因此如果子节点不是节点，我们可以创建一个文本节点并追加它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="b7ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这很快会遇到深度嵌套元素以及使用数组映射创建的元素的问题。因此，让我们用一个递归的<code class="fe lq lr ls lt b">appendChild</code>方法来代替这一部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="0b7a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以用这个代替我们的老方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="286f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有用！试试看。我们现在可以将基本的JSX渲染到DOM:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4a76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该看到你的JSX完美地呈现出来。不过，我们还可以添加一些东西；例如，在React中，元素通常是函数。实现这个将允许我们嵌套组件并充分利用道具，这是JSX的一个重要特征。</p><p id="d529" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，实现起来非常简单。我们所要做的就是检查<code class="fe lq lr ls lt b">tag</code>名称是否是一个函数而不是一个字符串。如果是，我们不做任何其他的事情，而只是调用函数。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="b991" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们来试试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，实现它也允许我们使用道具！你可以说我们已经完成了，但是我还想实现一个特性:片段。对于那些不熟悉的人来说，<em class="lw">片段</em>是在JSX拥有空容器的一种方式，他们使用空标签。示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8fa8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是要做到这一点，我们需要一个接受这个片段的函数，而不是创建一个DOM元素，它只是返回它的子元素。它看起来是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="9a50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它开箱即用，因为我们的递归<code class="fe lq lr ls lt b">appendChild</code>方法。</p><p id="213a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！我们做到了。一个超级简单的JSX到DOM函数，让我们可以使用JSX的能力，而不必特别使用rReact。你可以在<a class="ae lx" href="https://codesandbox.io/s/jsx-in-the-browser-qd2hq" rel="noopener ugc nofollow" target="_blank">这个代码沙箱</a>中找到它的源代码。</p><p id="8d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这篇文章对你有所帮助，我也希望你能找到一些很酷的方法来使用JSX的力量。我实际上是在使用<a class="ae lx" href="https://github.com/kartiknair/dhow" rel="noopener ugc nofollow" target="_blank"> Dhow </a>时了解到这些的，这是一个JSX驱动的Node.js静态站点生成器。它基本上允许你编写Next.js风格的代码，但可以毫无顾虑地将其转换为静态HTML。</p></div></div>    
</body>
</html>