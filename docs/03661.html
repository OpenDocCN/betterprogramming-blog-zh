<html>
<head>
<title>Swift: Comparing Objects the Right Way With Equatable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift:用等价的正确方式比较对象</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-comparing-objects-the-right-way-with-equatable-cf484d07dfaf?source=collection_archive---------5-----------------------#2020-02-25">https://betterprogramming.pub/swift-comparing-objects-the-right-way-with-equatable-cf484d07dfaf?source=collection_archive---------5-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5610" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何实现等价协议来定制您的比较结果和行为</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69515e3470c7c88ceaeabcaf0c0fd904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h6LLXFd7_bjJ3T5C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@creativeexchange?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上创意交流</a>的照片。</p></figure><p id="87c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与任何OOP语言一样，有一种正确的方法来比较对象，并消除关于<code class="fe lv lw lx ly b"><em class="lz">==</em></code>和<code class="fe lv lw lx ly b">===</code>操作符的任何混淆。在这篇简短的指南中，我将解释那些操作符语义以及如何实现<code class="fe lv lw lx ly b">Equatable</code>协议来定制您的比较结果和行为。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="32b2" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">==运算符</h1><p id="a1cb" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在Swift中，<em class="lz">等于</em>操作符的目标几乎和它在其他面向对象编程语言中的目标一样:它通过引用来比较对象。首先，请记住，预期的布尔值取决于您要比较的是什么类型的东西。在Swift中，变量可以是值类型，也可以是引用类型。第一个变量“家族”保存值，而第二个保存内存引用。因此，如果使用由类模式实例化的对象，<code class="fe lv lw lx ly b">==</code>操作符比较的是引用而不是值。这就是为什么<code class="fe lv lw lx ly b">==</code>操作符不能进行“深度比较”,你也不应该假设或假装它会比较每个对象属性中的所有值。事实并非如此。这里有一小段代码来说明我的观点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="b675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意<code class="fe lv lw lx ly b">NSObject</code>类型指示。如果省略类型，LLVM甚至不会编译这段代码，因为它没有关于如何比较对象的指示。虽然包含了<code class="fe lv lw lx ly b">NSObject</code>类型，但是我们使用了默认的<code class="fe lv lw lx ly b">==</code>方法行为。这就是为什么两个打印给你<code class="fe lv lw lx ly b">false</code>和<code class="fe lv lw lx ly b">true</code>。</p><ol class=""><li id="fef8" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">print(a == b)</code>之所以是<code class="fe lv lw lx ly b">false</code>是因为<code class="fe lv lw lx ly b">a</code>和<code class="fe lv lw lx ly b">b</code>是指向内存中不同位置的两个截然不同的对象。</li><li id="181a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe lv lw lx ly b">print(c == a)</code>之所以是<code class="fe lv lw lx ly b">true</code>是因为当你把<code class="fe lv lw lx ly b">c</code>赋给<code class="fe lv lw lx ly b">a</code>的时候，<code class="fe lv lw lx ly b">c</code>并不会成为<code class="fe lv lw lx ly b">a</code>的深度副本。它变成了指向内存中相同位置的指针。这就是为什么改变<code class="fe lv lw lx ly b">a</code>实例值会改变<code class="fe lv lw lx ly b">c</code>中的镜像属性。只是同一个对象！</li></ol><p id="a71f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">==操作符的语义与Java、C#和其他OOP语言中的差别并不大，所以您应该对此充满信心，不要感到惊讶。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9abe" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">===运算符</h1><p id="7206" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">许多其他编程语言都提供了<code class="fe lv lw lx ly b">===</code>操作符的实现。但这是什么呢？它被称为身份算符。这个操作符只是假装两个对象是相同的，但是它们没有相同的值。<code class="fe lv lw lx ly b">===</code>操作符使用反射来比较和分析所提供的两个对象的类型，而不是值。它不会只比较价值。即使有…一个物体的“价值”是什么？你可能会认为一个对象的值就是其内部的内容，这对于整数或字符串来说很容易理解，但是汽车呢？看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="452a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和以前一样，但是现在我们知道为什么会这样了。最后一条语句给出了<code class="fe lv lw lx ly b">true</code>，因为<code class="fe lv lw lx ly b">c</code>和<code class="fe lv lw lx ly b">a</code>指向相同的内存分配值。让我们看看简单值会发生什么:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="9610" class="ny mi it ly b gy nz oa l ob oc">let x : Int = 3<br/>let y : Int8 = 3<br/>print(x == y)     // &lt;---- true<br/>print(x === y)    // &lt;---- won't compile</span></pre><p id="439a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里你会看到一个<em class="lz">二元运算符' === '不能应用于' Int '类型的操作数和' Int8' </em>错误。基本上，由于他们的类型不匹配，比较这两个家伙没有意义，编译器会说它不知道如何做。显然，第一次比较给出了<code class="fe lv lw lx ly b">true</code>，因为3的值等于存储在一个八位整数中的3的值。如果你试图比较<code class="fe lv lw lx ly b">Int</code>和<code class="fe lv lw lx ly b">Float</code>、<code class="fe lv lw lx ly b">Int</code>和<code class="fe lv lw lx ly b">Double</code>等等，Swift也会给你一个编译器错误。编译器将要求强制转换来证明值比较行为，而不是类型。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e031" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">那么我如何用我的方式比较对象呢？使用等价协议！</h1><p id="ca04" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">当您需要比较两个定制对象时，您必须通过<code class="fe lv lw lx ly b">Equatable</code>协议提供比较操作符的定制实现。在Java中，您应该重写<code class="fe lv lw lx ly b">equals</code>方法。让你的类符合<code class="fe lv lw lx ly b">Equatable</code>协议是通过值来比较两个对象的唯一方法。如果你只需要通过引用来比较它们，现在很明显你不需要编码协议实现…但是谁只需要通过引用来比较呢？</p><p id="0bf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，让您的类符合<code class="fe lv lw lx ly b">Equatable</code>非常容易:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ff9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<code class="fe lv lw lx ly b">Equatable</code>协议有趣的事情是，它强制类实现一个名为<code class="fe lv lw lx ly b">==</code>的方法。我只在Swift里见过这种诡异的命名约定，从发现开始就一直很喜欢。简单地将方法命名为<code class="fe lv lw lx ly b">==</code>而不是<code class="fe lv lw lx ly b">equals</code>,这使得您仍然能够使用标准符号而不是通过调用特定的方法来比较对象。应该听起来很暧昧吧？当我使用<code class="fe lv lw lx ly b">==</code>时，我是使用定制的<code class="fe lv lw lx ly b">Equatable</code>实现还是默认的参考实现？不要担心，Xcode会以两种不同的方式突出显示操作符，你可以随时用键盘上的alt键检查操作符，或者跳到实现，看看后面有什么。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="107a" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="c2a2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">比较对象几乎是开发人员的一项基本任务，如果您对这些运算符没有清晰的理解，它总是会给出意想不到的结果。更重要的是，使用<code class="fe lv lw lx ly b">Equatable</code>协议让您能够确定两个对象是否应该被视为相同或相等。在上面的例子中，我决定两辆车是一样的，只是因为它们有相同的车牌，忽略了引擎马力属性。<code class="fe lv lw lx ly b">Equatable</code>方法只是Swift中对象知识的基础。现在您可以无忧无虑地编写代码了。</p></div></div>    
</body>
</html>