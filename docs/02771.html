<html>
<head>
<title>How To Iterate Over Two (or More) Lists at the Same Time</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何同时迭代两个(或更多)列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-iterate-over-two-or-more-lists-at-the-same-time-5f70b5c822ad?source=collection_archive---------3-----------------------#2019-12-29">https://betterprogramming.pub/how-to-iterate-over-two-or-more-lists-at-the-same-time-5f70b5c822ad?source=collection_archive---------3-----------------------#2019-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d1b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用zip()而不是手动并行遍历列表</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b270f7c42b791b18ebccfd19b09fe3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdgkU9sQWvaZnuiGLyc5_g.jpeg"/></div></div></figure><p id="b0cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您有多个数据集需要联合计算或显示，那么您可能经历过并行迭代多个列表的痛苦。</p><p id="de51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是传统上的样子…</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="aae1" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">传统的方法</h1><p id="9eaf" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">取一个列表的长度，使用一个占位符索引变量，通常命名为<code class="fe mu mv mw mx b">i</code>，手动访问列表中的每个位置。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="3d3e" class="nc ly it mx b gy nd ne l nf ng">a = [1,2,3,4,5]<br/>b = [10,20,30,40,50]</span><span id="18f0" class="nc ly it mx b gy nh ne l nf ng">for i in range(len(a)):<br/>   print(a[i],b[i])</span><span id="369d" class="nc ly it mx b gy nh ne l nf ng">"""<br/>1 10<br/>2 20<br/>3 30<br/>4 40<br/>5 50<br/>"""</span></pre><p id="0565" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意每个列表中的<code class="fe mu mv mw mx b">[i]</code>。这看起来足够简单，并不复杂。</p><p id="b49a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，如果您有大量的列表或更复杂的数据需要嵌套循环，那么您就很容易犯错误。</p><p id="3f30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一定有更简单的方法…</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="8580" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">zip()函数</h1><p id="bb8e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated"><code class="fe mu mv mw mx b">zip()</code>功能消除了猜测，降低了出错的可能性。接受可变数量的iterable参数，该函数将返回一个zip对象，该对象根据索引对每个项目进行分组。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="9482" class="nc ly it mx b gy nd ne l nf ng">a = [1,2,3,4,5]<br/>b = [10,20,30,40,50]<br/>c = zip(a,b)</span><span id="834c" class="nc ly it mx b gy nh ne l nf ng">print(c)        # &lt;zip object at 0x7f0a064c4eb0&gt;</span></pre><p id="1a51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，该函数返回一个zip对象，这意味着您不能立即打印它。幸运的是，我们可以将它强制转换成我们想要的数据类型。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="5a6b" class="nc ly it mx b gy nd ne l nf ng">a = [1,2,3,4,5]<br/>b = [10,20,30,40,50]<br/>c = zip(a,b)</span><span id="8398" class="nc ly it mx b gy nh ne l nf ng">print(c)        # &lt;zip object at 0x7f0a064c4eb0&gt;</span><span id="61c1" class="nc ly it mx b gy nh ne l nf ng">print(list(c))  # [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50)]<br/>print(dict(c))  # {1: 10, 2: 20, 3: 30, 4: 40, 5: 50}<br/>print(tuple(c)) # ((1, 10), (2, 20), (3, 30), (4, 40), (5, 50))</span></pre><p id="d69b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将zip对象强制放入字典时要小心。正好需要两个参数，否则将会引发错误。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="a436" class="nc ly it mx b gy nd ne l nf ng">a = [1,2,3,4,5]<br/>b = [10,20,30,40,50]<br/>c = [100,200,300,400,500]<br/>d = zip(a,b,c)</span><span id="4a6d" class="nc ly it mx b gy nh ne l nf ng">print(dict(d))<br/># ValueError: dictionary update sequence element #0 has length 3; 2 is required</span></pre><p id="9d79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在一个<code class="fe mu mv mw mx b">for loop</code>中使用这个函数作为可迭代的值。下面是使用<code class="fe mu mv mw mx b">zip()</code>重构的传统并行索引技术。</p><pre class="kj kk kl km gt my mx mz na aw nb bi"><span id="1ad4" class="nc ly it mx b gy nd ne l nf ng">a = [1,2,3,4,5]<br/>b = [10,20,30,40,50]<br/>c = [100,200,300,400,500]<br/>for x,y,z in zip(a,b,c):<br/>   print(x,y,z)</span><span id="cf47" class="nc ly it mx b gy nh ne l nf ng">"""<br/>1 10 100<br/>2 20 200<br/>3 30 300<br/>4 40 400<br/>5 50 500<br/>"""</span></pre><p id="1bd0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你还发现了<code class="fe mu mv mw mx b">zip()</code>功能的其他用途吗？你有另一种方法可以同时遍历多个列表吗？在评论中分享你的经历吧！</p></div></div>    
</body>
</html>