<html>
<head>
<title>Test Data Creation Using the Power of Kotlin DSL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin DSL的强大功能创建测试数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-data-creation-using-the-power-of-kotlin-dsl-9526a1fad05b?source=collection_archive---------2-----------------------#2021-11-23">https://betterprogramming.pub/test-data-creation-using-the-power-of-kotlin-dsl-9526a1fad05b?source=collection_archive---------2-----------------------#2021-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2bf0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让测试代码再次变得简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4fc2f9906f061bbd37571c60237f0abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vNKK4LF0L_fOejn3fjP7jA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="18f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您发现自己有一个需要测试的复杂的领域模型，这可能是一件痛苦的事情。仅仅为了构建测试数据，测试就可能变成几百行，导致一堆无意识的测试数据的复制粘贴，在你知道之前，一个小的模型变化就是几个小时的工作来修正测试数据。如果有软件开发地狱的话，我确信那将是其中之一。</p><p id="46d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们在我的公司遇到了这个问题。我们有一个嵌套的域模型，为了测试简单的功能，我们必须构建一组复杂的对象来使它正确显示。当然，这很费力，而且更容易的是从另一个测试中复制，只填写与您相关的字段，潜在地将对象置于无效状态。有趣的时光…幸运的是我们使用科特林。Kotlin的(许多)好特性之一是它支持构建DSL(领域特定语言)，这使得它非常适合用于构造对象。</p><p id="8850" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过将DSL与一些创建模式相结合，我们可以减少测试数据创建的麻烦，并且更容易维护。该解决方案的基础是builder模式，它通常用于创建测试数据，但是它很容易变得冗长和难以阅读。然而，如果我们应用Kotlin的DSL功能，情况就不同了。为了防止复制，我们可以使用对象母模式在一个地方收集标准的测试数据实例，并从那里获取它们。同样，DSL功能可以使这种模式更加强大。</p><p id="dde4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们开始吧！</p><h1 id="e586" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">目标母模式</h1><p id="af1a" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">对象母模式是一种用于创建测试数据的创建模式。您可以将所有这些对象保存在“对象母亲”中，而不是为您构建的每个测试创建非常相似的测试数据。现在，您不太可能在许多测试中复制和粘贴相同的测试数据，因为您可以只使用来自对象母亲的数据。[1]</p><p id="c323" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，使用shipping域中的一个shipping示例，您可以创建一些默认的shipping数据。你可以从任何需要一个盒子的测试中调用它，你只需要调用这个方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="801f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一般的测试来说，这是一个非常有用的模式，因为它使你的单元测试变得很小，并且很容易获得所有可用测试数据的概览。然而，如果您想对其中一个属性做一个小的改变，您可能会复制非常相似的测试数据来使测试工作，或者您只是完全忽略对象母。</p><p id="9026" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是我们可以用Kotlin解决的问题，但在此之前，我们需要讨论一下构建器模式。</p><h1 id="c7b0" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">构建器模式</h1><p id="c767" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">构建器模式是一种创造性的设计模式，你猜对了，用来构建对象。这对于具有许多属性和嵌套类的复杂对象尤其有用。这是构建测试数据的常用方法，因为您可以设置默认值，并在必要时覆盖它们。</p><p id="a94d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如果我们以上面的例子为例，并使用builder模式，装运的创建将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="5cce" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mt">我们使用构建器类来设置对象的属性，然后通过调用</em> <code class="fe mu mv mw mx b"><em class="mt">build</em></code> <em class="mt">返回最终版本。在上面的例子中，我们使用三个不同的构建器来创建完整的shipment对象，这看起来很冗长，也很难理解。然而，如果我们要添加更多的属性，我们可以很容易地为它们设置默认值，即使Shipment类改变了，这个方法也不会改变。</em></p><p id="46d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Kotlin DSL，在保留设置默认值选项的同时，也可以去掉冗长。所以不再调侃，让我们进入DSL吧！</p><h1 id="f58d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">科特林DSL</h1><p id="64e8" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">特定于领域的语言专注于领域或特定的任务，忽略了所有不重要的东西。因此，DSL并没有试图囊括一切，而是提供了一套精简的功能。这使得代码更简洁，更易于阅读。另一个好处是DSL更倾向于声明性，这意味着您可以描述期望的结果，并将实现细节留给DSL的实现者。因此，描述如何构建测试数据是DSL的一个很好的用例。</p><p id="b8b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kotlin有一些很好的语言结构，允许我们创建简洁易读的DSL。我将讨论lambdas，如果你需要复习这些<a class="ae my" href="https://www.baeldung.com/kotlin/lambda-receiver" rel="noopener ugc nofollow" target="_blank">，这是一个很好的资源</a>。[2]</p><p id="eb0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">允许我们创建DSL的一个构造是一个名为<em class="mt"> lambda和接收器</em>的概念。它允许你调用lambda的一个参数作为接收者。这意味着您不必指定任何限定符，但是您可以直接调用它的方法或参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b89d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于接收器，lambda充当了<code class="fe mu mv mw mx b">StringBuilder</code>的扩展函数，它提供了对lambda内部的<code class="fe mu mv mw mx b">StringBuilder</code>的访问。如果你问我，我会觉得很酷。</p><p id="d419" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用带有接收器的lambdas将允许我们直接访问测试构建器类的属性，而不是必须从限定符中访问它们。这使得我们的测试数据创建不那么冗长。</p><p id="3cab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上面构建器模式部分的例子为例，这将是带有接收器的lambda替代方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b1e1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确定什么属性属于哪个父类要简洁和容易得多。当然，实际构建对象的实现隐藏在这里，所以让我们看看它是什么样子的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a410" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe mu mv mw mx b">buildShipment</code>函数是lambda的入口点，它创建一个发货测试数据构建器，然后在构建器上调用lambda。然后，这个lambda可以填充构建器上的属性，并将构建好的装运返回。</p><p id="3ed7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们也有一个嵌套盒子的列表，我们需要用shipment builder中的receiver做一个类似的lambda来将盒子添加到<code class="fe mu mv mw mx b">boxes</code>属性中。</p><p id="e697" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以看看随附的<a class="ae my" href="https://github.com/JohanneA/kotlin-test-data-builder-dsl-example" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a>的完整例子。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="2670" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">既然我们已经处理了数据创建的冗长部分，我们可以继续复制部分。object mother部分解决了这个问题，但是我们可以用DSL使它变得更好。我们想要为我们的测试创建定义一个预制测试数据的列表。但是我们仍然希望能够覆盖这些默认值，这样我们就不会复制具有几乎相同属性值的对象母代码。</p><p id="539d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免过度复制，我们可以构建一个覆盖函数来覆盖对象母体上的特定值，但保留其余的值。这是它看起来的样子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="a42e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们没有像在build函数中那样创建一个新的shipment builder，而是将lambda应用到我们想要覆盖其值的现有builder上。</p><p id="36d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着在母对象中我们必须返回ShipmentTestDataBuilder而不是Shipment。因此，当您获得测试数据时，您必须在测试中调用<code class="fe mu mv mw mx b">build</code>方法。您也可以在shipment builder中添加这一点，但是您必须维护更多的映射逻辑。</p><p id="b205" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们有嵌套的构建器，我们还需要确保它们被正确地覆盖。由于列表中的嵌套对象，这使得事情变得复杂。我们希望覆盖特定的对象，并让它们保持现有的属性值，而不是只暴露类的属性来覆盖。</p><p id="ab90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这需要一些逻辑来将构建器合并在一起。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="cea9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了用特定的id覆盖这个盒子，我们需要首先创建一个新的盒子构建器，用现有盒子中的属性填充它。</p><p id="b5f4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，我们需要在列表中找到现有的框，并将框中的属性“合并”到框生成器中。</p><p id="2598" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用与我们想要覆盖的盒子具有相同属性的盒子构建器，我们可以对它调用lambda函数，并提供对盒子属性的访问。</p><p id="387b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们从列表中删除旧的框，并添加新覆盖的框。</p><p id="585a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完整代码见<a class="ae my" href="https://github.com/JohanneA/kotlin-test-data-builder-dsl-example" rel="noopener ugc nofollow" target="_blank"> Github repo </a>。</p><h1 id="fb21" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">把所有的放在一起</h1><p id="2224" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">Kotlin DSL并不是这些问题的唯一解决方案，它也有自己的缺点。每当一个新的属性被添加到您想要测试的模型中时，您必须手动地将属性添加到测试数据构建器中，这意味着测试构建器可能会过时。如果您想全力以赴，您可以构建一个小程序，它将基于类为您创建DSL，但是如果您没有时间构建它，这可能是不可行的。</p><p id="9e7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个缺点是lambdas，它不是一件容易理解的事情，如果出现问题或行为异常，它会更难调试。</p><p id="5e46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，也有很多好处。你使你的单元测试变得更小，更具声明性，重用母对象更加容易和安全，而不需要到处复制构建器。另外，以我的经验来看，它只是让编写单元测试不那么耗时，而且更令人满意。</p><p id="ce6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是没有DSL时的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="7f95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想稍微修改一下 <code class="fe mu mv mw mx b"><em class="mt">getShipmentWithOneBox()</em></code> <em class="mt">，你必须做很多样板文件，把数据复制到你的测试中并在那里修改它可能会更容易。您必须指定所有的属性，并且每次添加更多的属性时，您都必须更改这个测试。</em></p><p id="8787" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是测试数据DSL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9ee1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了DSL，测试数据占用的空间更少，你不必每次添加属性时都改变测试，而且读起来更好。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="0e90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就是这样！我希望这篇文章能帮助你更好地理解Kotlin DSL，以及如何使用它进行测试。你可以自己尝试一下，或者在下一次单元测试重构时记住它，因为我们都知道会有一个单元测试重构；)</p><p id="45f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有任何反馈或建议，请在此评论或在<a class="ae my" href="https://twitter.com/Johanne_01" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上联系。感谢您的阅读。</p><p id="9e39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">参考文献:</strong></p><p id="5fd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[1]<a class="ae my" href="https://martinfowler.com/bliki/ObjectMother.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/bliki/ObjectMother.html</a></p><p id="81c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae my" href="https://www.baeldung.com/kotlin/lambda-receiver" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/kotlin/lambda-receiver</a></p><p id="634f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">[3]<a class="ae my" href="https://github.com/JohanneA/kotlin-test-data-builder-dsl-example" rel="noopener ugc nofollow" target="_blank">https://github . com/JohanneA/kot Lin-test-data-builder-DSL-example</a></p></div></div>    
</body>
</html>