<html>
<head>
<title>How to Get Docker to Play Nicely With Your Python Data Science Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让Docker很好地使用您的Python数据科学包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-get-docker-to-play-nicely-with-your-python-data-science-packages-81d16f1080d2?source=collection_archive---------8-----------------------#2020-03-06">https://betterprogramming.pub/how-to-get-docker-to-play-nicely-with-your-python-data-science-packages-81d16f1080d2?source=collection_archive---------8-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="474a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">数据科学项目分类指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94a17425f6c7c0711349dd5fd1cea1c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnc6XQfNbXR6QIX3tNVK8g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·利维拉尼在Unsplash<a class="ae ky" href="https://unsplash.com/s/photos/data-science?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">上的照片</a></p></figure><p id="a730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谈到Python包管理，您有两种选择来处理您的Python依赖项。最广泛使用的是Conda、pip和pyenv。</p><p id="a7b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将探讨在Docker容器中对数据科学应用程序进行Docker时可以使用的两种方法:默认情况下Python附带的传统pip和Conda方法。</p><p id="8350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了了解如何对您的数据科学项目进行分类，您需要了解Conda和pip之间的主要区别。尽早做出最佳决策将防止未来的返工。</p><h2 id="f81d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">下面的例子说明了什么</h2><p id="6f71" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">本文不是关于Docker如何工作，而是如何:</p><ul class=""><li id="733a" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">在探索pip和Conda之间的差异时，开始构建您的Docker形象。</li><li id="1d2d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">了解如何将Docker配置为从私有PyPI服务器拉取</li><li id="6625" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">探索在Docker中为数据科学Python应用程序切换Python版本的想法</li></ul></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="37f1" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">皮普是什么？</h1><p id="43c0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">pip是Python 3.4及更高版本中默认的标准包管理系统。由pip管理的包是使用<a class="ae ky" href="https://pypi.org/project/setuptools/" rel="noopener ugc nofollow" target="_blank"> Setuptools </a>构建的，Setuptools是一个包开发过程库，旨在方便打包Python项目。通常如果你浏览GitHub Python项目，你会注意到。一个位于项目根的<code class="fe nz oa ob oc b">setup.py</code>——比如这个位于<a class="ae ky" href="https://github.com/keras-team/keras/blob/master/setup.py" rel="noopener ugc nofollow" target="_blank"> Keras </a> Git仓库的例子。</p><p id="53b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pip安装Python包——通常，当您阅读任何在线文献时，都会遇到这种情况，但这并不意味着您不能将其他应用程序与pip捆绑在一起，并利用Python子进程来完成一些非Python安装。</p><p id="1507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我做了一个<a class="ae ky" href="https://www.gams.com/" rel="noopener ugc nofollow" target="_blank">GAMS</a>-包装器Python-installer包，允许在Windows、Linux和MAC上安装GAMS。这个包托管在一个私有的PyPI服务器上。MAC安装通过DMG映像执行，而Linux安装通过可执行的Linux二进制包执行。Windows安装通过无人值守安装来执行，还可以选择执行静默(或<em class="od">安静</em>)安装。这种进行pip安装的方法不是标准软件包过程的一部分，但是我决定通过pip来标准化我所有的软件包安装。</p><p id="0b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pip包通常托管在PyPI上。这可以是开源或私有Python包的私有或公共存储库。对于那些不熟悉Python包存储库的人来说，当你想到PyPI时，会想到RubyGems for Ruby、Packagist for PHP、Maven for Java、CPAN for Perl和npm for Node.js</p><p id="aa66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pip有局限性，比如缺少包隔离。这意味着开箱即用，您不能以孤立的方式运行多个Python版本。这就是<a class="ae ky" href="http://www.virtualenv.org/" rel="noopener ugc nofollow" target="_blank"> virtualenv </a>通过允许具有不同(并且经常<em class="od">冲突</em>)需求的多个Python项目在同一台计算机上共存来解决这个非常具体的问题的地方。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="d14b" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">什么是蟒蛇？</h1><p id="c62a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Anaconda是Python和R发行版。它旨在提供Python数据科学所需的一切。</p><p id="b277" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把它想象成你的瑞士军刀，把所有数据科学的东西都整合到一个地方。Anaconda有自己的包管理器，类似于名为conda的pip。</p><p id="bd8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然pip可以安装除Python包之外的其他东西，但这不是设计出来的，也不是pip构建方式的一部分。Conda通过允许Conda包支持非Python库依赖项来解决这个问题，如HDF5、MKL和LLVM，它们的源代码中没有<code class="fe nz oa ob oc b">setup.py</code>，也不将文件安装到Python的站点包目录中。</p><p id="541a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与pip相反，Conda通过设计提供了每个环境的隔离。不使用隔离很难使用康达。默认情况下，当您使用Conda时，它会附带一个安装它的基础环境。通常鼓励您根据自己的需要创建并激活一个新的特定于应用程序的环境。</p><p id="6418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在处理与数据科学相关的应用程序，Conda使它成为Python中理想的包管理器。通过康达YAML文件无缝切换Python环境的能力意味着，如果需要切换某些包甚至Python版本，您不必担心更改Docker配置。</p><p id="eabf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一个例子，使用Docker和几个数据科学包来设置Conda和pip</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="0e82" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">先决条件</h1><p id="420d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">通过在终端中执行以下命令，确保您安装了Docker:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="134e" class="lv lw it oc b gy oi oj l ok ol">$ docker --version</span></pre><p id="a15c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生以下输出:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="f50b" class="lv lw it oc b gy oi oj l ok ol">Docker version 19.03.5, build 633a0ea</span></pre><p id="1899" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了便于说明，让我们创建我们的示例<code class="fe nz oa ob oc b">helloworld.py</code>。在这个例子中，我们将展示一个使用Dask框架的简单程序，Dask框架是一个轻量级数据科学分布式计算框架，允许您执行比内存计算更大的计算。</p><p id="6cc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，我们可以用Dask并行化普通的Python代码或scale <a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a> NumPy库。或者我们可以在现有的Python工作流中增加并行性。可以把它想象成PySpark的轻量级版本，放在您喜欢的数据科学软件包之上。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">helloworld.py利用Dask框架进行数据科学并行计算</p></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="d004" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">pip方式</h1><p id="5d6d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">下面的例子说明了如何配置一个额外的私有PyPI服务器来处理Docker中的软件包安装，方法是将<code class="fe nz oa ob oc b">pip.config</code>配置为全局配置，允许pip读取其他PyPI软件包服务器。</p><p id="5b70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用的大多数Python包都是开源的外部包，但它们是需要使用私有服务器的实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile pip示例</p></figure><p id="d99d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们上面的Docker文件中，我们使用Python 3.6的<code class="fe nz oa ob oc b">slim-buster</code>。<code class="fe nz oa ob oc b">slim-buster</code> variant Docker图像缺少通用包的层，因此图像尺寸往往更小。</p><p id="ac77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，Docker的大小是受你的应用程序中有多少内容影响的。通常，如果构建速度很重要，但不一定等同于更好的应用程序性能，那么大小只对CI/CD有影响。</p><p id="8482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的Docker文件中，我们使用ARGs来定义变量，以免在Docker文件中暴露安全凭证。参数仅在构建Docker映像期间可用，在创建映像和启动容器之后不可用(<code class="fe nz oa ob oc b">ENTRYPOINT</code>、<code class="fe nz oa ob oc b">CMD</code>)。为了避免ARG的过渡性质，我们将ARG值赋给ENV值。在Docker构建期间，从引入ENV值的那一行开始，容器和<code class="fe nz oa ob oc b">RUN</code>命令都可以使用ENV值——在Docker容器的生命周期中也是如此。</p><p id="065e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是pip <code class="fe nz oa ob oc b">requirements.txt</code>，它由两个定制包和通用数据科学包组成。Pip不支持PyTorch和TensorFlow开箱即用之类的一些包——这正是康达擅长的地方。在对项目进行Dockerizing之前，最好在虚拟环境中模拟运行您的代码，以便按顺序获取依赖项，并使用以下命令将依赖项导出到文件中:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="c726" class="lv lw it oc b gy oi oj l ok ol">$ pip freeze &gt; requirements.txt</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">requirements.txt</p></figure><p id="2566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的命令允许您在传递附加构建参数的同时构建Docker映像。在这个例子中，我们传递了允许我们对私有PyPI服务器进行身份验证的凭证细节。如果没有，可以省略这些参数。</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="a31f" class="lv lw it oc b gy oi oj l ok ol">$ docker build \<br/>--build-arg ARTIFACTORY_USERNAME={YOUR_USERNAME} \<br/>--build-arg ARTIFACTORY_SECRET_TOKEN={YOUR_SECRET_TOKEN} \<br/>--no-cache  -t helloworld:latest .</span></pre><p id="55a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">docker build</code>将生成以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile构建pip</p></figure><p id="a584" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想尝试一下<code class="fe nz oa ob oc b">helloworld.py</code>示例，请确保您删除了r <code class="fe nz oa ob oc b">equirements.yml</code>或<code class="fe nz oa ob oc b">environment.yml</code>文件中的GAMS和CPLEX条目，因为这两个包用于演示如何从私有PyPI服务器安装pip。</p><p id="bd72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行<code class="fe nz oa ob oc b">run</code>命令让您的<code class="fe nz oa ob oc b">helloworld.py</code>运行起来:</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="c479" class="lv lw it oc b gy oi oj l ok ol">docker container run helloworld</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/513b6776201e4a778737d3ac3da9d906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*puiHWbziOD24RQNFUkw4Iw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行<code class="fe nz oa ob oc b">docker run helloworld</code>输出</p></figure></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="938f" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">康达之路</h1><p id="4799" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Conda的方式与pip的方式略有不同，尽管在内部，Conda将使用pip来解决它无法通过Conda包管理器解决的依赖关系。为了在Anaconda中使用Docker，我们将利用Miniconda Docker映像。</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="2e9f" class="lv lw it oc b gy oi oj l ok ol">FROM continuumio/miniconda3:4.7.12</span></pre><p id="d496" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Anaconda的最小版本，只包含conda及其依赖项。默认情况下，它包含Conda包管理器和Python 3.7。使用Miniconda，我们可以在同一个Docker映像中安装不同的Python版本。这在需要不同的数据科学微服务在不同版本的Python上工作的情况下是有意义的。让我们继续定义一个与pip <code class="fe nz oa ob oc b">requirements.txt</code>等价的<code class="fe nz oa ob oc b">environment.yml</code>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">environment.yml</p></figure><p id="1688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nz oa ob oc b">environment.yml</code>文件的pip部分可以包含一个私有的pip包或任何其他可能不受Conda支持的包。</p><p id="c5b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">pip将自动解析在私有PyPI服务器中定义的包，如果从我们在<code class="fe nz oa ob oc b">/etc/</code>文件夹中的<code class="fe nz oa ob oc b">pip.conf</code>文件中定义的<code class="fe nz oa ob oc b">extra-index-url</code>中找到的话。</p><p id="6263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Conda通过使用<a class="ae ky" href="https://docs.conda.io/projects/conda/en/latest/user-guide/configuration/use-condarc.html#config-channels" rel="noopener ugc nofollow" target="_blank">通道</a>也有类似的概念。Conda通道是存储包的位置——可以是解析为URL存储库的Conda定义的位置。它们是托管和管理包的基础。</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="6cb4" class="lv lw it oc b gy oi oj l ok ol">RUN echo "[global]<em class="od">\n</em>extra-index-url= https://$ARTIFACTORY_USERNAME:$ARTIFACTORY_SECRET_TOKEN@artifactory.com/api/pypi/simple" &gt;&gt; /etc/pip.conf</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Conda中的Dockerfile文件示例</p></figure><p id="01bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行我们之前在pip示例中使用的相同Docker <code class="fe nz oa ob oc b">build</code>命令将产生以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="5eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在Docker构建过程中遇到过以下警告…</p><blockquote class="op oq or"><p id="97ad" class="kz la od lb b lc ld ju le lf lg jx lh os lj lk ll ot ln lo lp ou lr ls lt lu im bi translated"><strong class="lb iu">"警告</strong>:您的环境文件中有pip安装的依赖项，但是您没有将pip本身列为您的conda依赖项之一。Conda可能不会使用正确的pip来安装您的软件包，它们可能会出现在错误的位置。请添加一个显式pip依赖项。我在给你加一个，还在唠叨你。”</p></blockquote><p id="e816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…那么这就是你如何去解决它。按照建议将pip添加到您的<code class="fe nz oa ob oc b">environment.yml</code>文件中。在Conda的最新版本中，pip被删除了——因此，您需要显式地添加它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将pip配置为依赖项的Conda environment.yml文件</p></figure><p id="aabe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行您的Docker实例，请执行下面的命令，这是我们之前的pip变体的一个小变体。注意标志<code class="fe nz oa ob oc b">-d</code>使您能够将Docker实例作为守护进程运行。如果忽略该标志，您的代码将不会触发并退出—因此，您需要通过按Ctrl+Z来中断正在运行的Python脚本，从而退出程序。</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="3cea" class="lv lw it oc b gy oi oj l ok ol">$ docker container run -d helloworld</span></pre><p id="189f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要使用其他Python包，可以使用Conda search命令，如下图所示。这假设您的Docker运行在守护进程状态。</p><pre class="kj kk kl km gt oe oc of og aw oh bi"><span id="bc0a" class="lv lw it oc b gy oi oj l ok ol">$ docker ps</span><span id="a6d9" class="lv lw it oc b gy ov oj l ok ol"># prints the list of running docker containers with their corresponding docker container ids</span><span id="c8b3" class="lv lw it oc b gy ov oj l ok ol">$ docker exec -it {CONTAINER_ID} /bin/bash</span><span id="a385" class="lv lw it oc b gy ov oj l ok ol"># command above allows you to enter the container by executing an interactive bash shell</span><span id="3012" class="lv lw it oc b gy ov oj l ok ol">$ conda search python</span><span id="04c3" class="lv lw it oc b gy ov oj l ok ol"># above command list out all available python versions <br/>you may proceed to exit the container by typing. if you wish to export your package such as how pip freeze works you can achieve the same thing with the below command </span><span id="3416" class="lv lw it oc b gy ov oj l ok ol">$ <!-- -->conda env export --from-history &gt; environment.yml</span><span id="d407" class="lv lw it oc b gy ov oj l ok ol"># --from-history allows exporting of top level dependencies. If you would like the full blown conda export remove this argument</span><span id="de4b" class="lv lw it oc b gy ov oj l ok ol">$ exit</span><span id="ebaf" class="lv lw it oc b gy ov oj l ok ol"># Followed by</span><span id="1067" class="lv lw it oc b gy ov oj l ok ol">$ docker stop {CONTAINER_ID}</span><span id="32a3" class="lv lw it oc b gy ov oj l ok ol"># which will terminate the executing docker instance.  <br/># Update the environment.yml with whichever python version you wish to use</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="41bb" class="no lw it bd lx np nq nr ma ns nt nu md jz nv ka mg kc nw kd mj kf nx kg mm ny bi translated">结论</h1><p id="d64e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我希望您发现Docker练习对开始使用Python数据科学包的Docker探索有用。有时让所有的包都正常运行需要一些耐心——因为一些包可能有相互冲突的依赖关系。永远记住只安装你需要的pip或conda软件包。如果不使用它，就扔掉它，以尽量减少docker图像的膨胀。</p><p id="16ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">有用的工具</strong></p><ul class=""><li id="9fbb" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><a class="ae ky" href="https://github.com/naiquevin/pipdeptree" rel="noopener ugc nofollow" target="_blank"> pipdeptree </a>:查看您环境中软件包的依赖树</li><li id="af95" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://github.com/dracos/check-pip-dependencies" rel="noopener ugc nofollow" target="_blank">检查-pip-依赖关系</a>或<a class="ae ky" href="https://github.com/ambitioninc/pip-conflict-checker" rel="noopener ugc nofollow" target="_blank">pip-冲突-检查</a> r:找到依赖关系冲突的根源</li><li id="500f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://pypi.org/project/pip-autoremove/" rel="noopener ugc nofollow" target="_blank"> pip-autoremove </a>:通过列出顶级需求，帮助您从环境中删除未使用的孤立依赖项</li><li id="7d42" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://github.com/omegacen/conda-depgraph" rel="noopener ugc nofollow" target="_blank"> conda-depgraph </a>:绘制conda依赖图的命令行实用程序</li><li id="53d0" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://github.com/erikrose/peep" rel="noopener ugc nofollow" target="_blank"> peep </a>:加密保证包，确保你总是得到相同的未经篡改的pip包，有助于确保你的docker镜像的安全性</li></ul><p id="7446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快乐编码。</p></div></div>    
</body>
</html>