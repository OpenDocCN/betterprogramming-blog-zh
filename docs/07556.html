<html>
<head>
<title>React: Use Redux To Control Modal Visibility States</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:使用Redux控制模态可见性状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-use-redux-to-control-modal-visibility-states-8953e44b71fd?source=collection_archive---------2-----------------------#2021-01-27">https://betterprogramming.pub/react-use-redux-to-control-modal-visibility-states-8953e44b71fd?source=collection_archive---------2-----------------------#2021-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8135" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">轻松管理对话框的打开和关闭状态</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d04e002acac198d4cf8b555fdbe3667a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NLsdv9JOL6wlx9jJ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ferenc Almasi </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="c3fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模态是位于应用程序主窗口之上的UI元素，帮助用户在不中断当前交互流的情况下做出决策。它们还可以为用户触发的操作提供反馈，并在不改变应用程序当前路径/页面的情况下呈现一些内容。</p><p id="fab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将介绍如何在React中使用<a class="ae kv" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>来控制模态是否可见。首先，让我们浏览一下应用程序示例，然后转到使用Redux的方法，以便节省我们大量的时间，并减少我们组件中大量的代码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6a51" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">应用程序</h1><p id="74d1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们将使用的应用程序是一个简单的按钮，它打开一个要求用户按“是”或“否”的模式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ffb436dcb4d813909b148d8cb1b6bc7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/1*j8hdFZB81Puu7uLEjpfovw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用示例</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="825c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种方法中，我们使用直接在<code class="fe mz na nb nc b">MainComponent</code>中定义的<code class="fe mz na nb nc b">isOpen</code>属性来控制模态可见性。如果<code class="fe mz na nb nc b">IsOpen</code>道具是<code class="fe mz na nb nc b">true</code>，会显示模态。否则，它将被隐藏。</p><p id="696a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们只在一个组件中使用这个模型，这种方法完全没有问题。如果我们试图在其他组件中使用这种模态，这就是<code class="fe mz na nb nc b">YesNoModal</code>的情况，这种方法会导致大量的代码重复。</p><p id="e419" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次我们使用这个模态，我们将不得不复制所有控制模态打开状态的代码。使用该模态的每个组件都必须通过定义<code class="fe mz na nb nc b">IsOpen</code>属性来控制状态。</p><p id="aab7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们可以调用一些动作来显示/隐藏这个模态并集中它的状态控制会怎么样？让我们使用Redux。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b8a1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Redux如何工作</h1><p id="3a4b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">全局管理状态可能非常复杂。Redux帮助我们更好地处理状态管理。简而言之，Redux是一个允许我们集中React应用程序的状态/逻辑的工具。这是个好消息，因为我们不想将模态状态控制委托给每个需要它的组件。</p><p id="57c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们深入使用Redux的例子之前，我想简单解释一下我认为Redux的三个主要支柱:动作、reducers和存储。</p><p id="498b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动作是我们的组件将调用的事件，以让应用程序的其余部分知道我们想要更新一些状态。在我们的例子中，将调用一些动作，告诉我们的状态我们需要显示/隐藏<code class="fe mz na nb nc b">YesNoModal</code>。</p><p id="7b1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Reducers是纯函数，它将接收一个初始状态和一个动作，基于这个动作执行一个逻辑，并返回一个新状态。</p><p id="a7f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后但同样重要的是，存储是存储应用程序整体全局状态的机制。我们通过调用我们的动作来更新这个状态，并在reducers中处理它们。</p><p id="2dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很难用几行文字解释Redux是如何工作的，但我向你保证，当我们看到一些代码时，它会变得清晰很多。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b60b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">安装Redux </strong></h1><p id="3ed0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们从安装Redux开始:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="7c3a" class="nh ma iq nc b gy ni nj l nk nl">npm install redux -s</span></pre><p id="2dac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了Redux本身，让我们也安装react-redux，react的一个官方绑定，它帮助我们的组件知道全局状态何时改变，并根据这种改变重新呈现它:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="652c" class="nh ma iq nc b gy ni nj l nk nl">npm install redux-react -s</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3127" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">模态减速器</h1><p id="a6a4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mz na nb nc b">modalsReducer</code>是我们根据组件触发的动作执行一些逻辑的地方。在这个例子中，我们只有一个模态，但是我们可以使用这个缩减器来管理任意多的模态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缩减器由一个初始状态对象和一个函数组成，当我们需要对状态进行一些更新时，这个函数将被调用。<code class="fe mz na nb nc b">modalsStore</code>函数接收状态和动作作为参数。这个动作告诉我们应该在我们的状态中做什么改变。</p><p id="165e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果动作的类型是<code class="fe mz na nb nc b">ShowYesNoModal</code>，我们返回一个新的状态，将<code class="fe mz na nb nc b">showYesNoModal</code>的值设置为<code class="fe mz na nb nc b">true</code>，表明我们想要显示模态。一旦模态打开，我们可以通过调度类型为<code class="fe mz na nb nc b">HideYesNoModal</code>的动作来关闭它，用属性<code class="fe mz na nb nc b">showYesNoModal = false</code>返回一个新的状态。</p><p id="8c20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将这个减速器连接到我们的组件，我们需要对<code class="fe mz na nb nc b">index.js</code>文件进行一些更改:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f7fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，我们通过用<code class="fe mz na nb nc b">Provider</code>组件包装我们的应用程序来创建商店并将其连接到我们的组件。我们的组件现在可以分派动作和订阅状态变化。注意，我们可以组合几个减速器。在这个例子中，我们只有<code class="fe mz na nb nc b">modalReducer</code>，但是我们可以有<code class="fe mz na nb nc b">notificationReducer</code>、<code class="fe mz na nb nc b">alertReducer</code>等等。</p><p id="a95a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以连接我们的<code class="fe mz na nb nc b">MainComponent</code> <em class="nm"> </em>并开始分派动作以显示<code class="fe mz na nb nc b">YesNoModal</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们在<code class="fe mz na nb nc b">MainComponent</code>中不再有模态打开状态。我们已经成功地移除了<code class="fe mz na nb nc b">MainComponent</code>管理模态状态的职责。相反，我们通过props接收函数<code class="fe mz na nb nc b">showYesNoModal</code>，当模态应该打开时，它将被调用。</p><p id="8f14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个<code class="fe mz na nb nc b">showYesNoModal</code>函数<em class="nm"> </em>从何而来？当我们在第36行将<code class="fe mz na nb nc b">mapDispatchtoProps</code>连接到我们的组件时，这个函数被传递给props。基本上，我们正在调度一个类型为<code class="fe mz na nb nc b">ShowYesNoModal</code>的动作，它将被我们的reducer捕获并触发一个状态变化。</p><p id="2b9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们只需要订阅<code class="fe mz na nb nc b">YesNoModal</code>本身的状态变化，以显示模态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="98ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们将状态映射到props(第33行)时，我们基本上只是订阅全局存储中的任何状态变化。<code class="fe mz na nb nc b">mapStateToProps</code> <em class="nm"> </em>函数接收全局状态对象，并将其映射到另一个包含管理模态可见性的属性的对象。</p><p id="8481" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<code class="fe mz na nb nc b">showModal</code>属性，组件还接收了一个名为<code class="fe mz na nb nc b">closeModal</code>的函数。一旦被调用，它将分派一个类型为<code class="fe mz na nb nc b">HideYesNoModal</code>的动作，该动作将被我们的reducer捕获并更新状态，将控制模态可见性的属性设置为<code class="fe mz na nb nc b">false</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/0d9439511038ece95be71d527c7f0e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itjNgb-V1e-cd4dgNEvQSA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">调度/状态更新流程</p></figure><p id="0275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样:我们现在通过使用Redux管理的全局状态来控制我们的模态。此时，您可能会问自己，“如果我最终编写了更多代码来实现基本相同的结果，我为什么要使用Redux？”</p><p id="cf4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们只有一个模态。如果我们有几个其他的模态呢？每当我们在组件中直接需要模态状态时，我们会想要管理它吗？大概不会。</p><p id="a75a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们编写了第一个reducer并将其连接到应用程序的其余部分，实现新的reducer将非常简单。我们只需要将它们导入到我们的<code class="fe mz na nb nc b">index.js</code>文件中，并在创建商店时组合它们。</p><p id="d22e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我想分享一个真实世界的减速器，这是我很久以前在我的一个项目中实现的。这正是我们在本文中讨论的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0f85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个示例的重点是处理模态，但是我们可以将这种方法扩展到许多需要在整个应用程序中共享这种状态控制的挑战，比如警报、通知、身份验证等。</p><p id="b25b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">各位，今天就到这里。希望这篇文章对你有所帮助。</p><p id="115a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保重，编码愉快！</p><p id="5dbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GitHub 上的<a class="ae kv" href="https://github.com/brunneus/react-redux-modal" rel="noopener ugc nofollow" target="_blank">提供了源代码。</a></p></div></div>    
</body>
</html>