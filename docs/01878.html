<html>
<head>
<title>Writing Your Own Changelog Generator with Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Git编写自己的Changelog生成器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-your-own-changelog-generator-with-git-aefda291ea93?source=collection_archive---------0-----------------------#2019-10-20">https://betterprogramming.pub/create-your-own-changelog-generator-with-git-aefda291ea93?source=collection_archive---------0-----------------------#2019-10-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将您的提交消息转化为面向用户的发布说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4abe2c4b7b85faefd09bf7ef0920814b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s1Kr_0A-w5ZCES9A"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@yancymin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扬西·敏</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="fd3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变更日志很棒。它们给了我们一个记录，记录了我们的项目在某个特定的时间做了哪些变更。如果你正在编写一个库，它也能让你的用户意识到发生了什么变化，并且给人一种你的库维护良好并且值得信赖的印象。像<a class="ae ky" href="https://github.com/conventional-changelog/conventional-changelog" rel="noopener ugc nofollow" target="_blank">conventi on-changelog</a>这样的工具允许我们轻松地生成一个非常简洁的changelog，只要我们遵守他们关于如何编写提交消息的约定。其中最流行的是<a class="ae ky" href="https://www.conventionalcommits.org/en/v1.0.0/" rel="noopener ugc nofollow" target="_blank">常规提交</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/a2b8ff753099b995576e5522574496e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2iVPZeYudHvIaIXRyT-WyQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://github.com/angular/angular/blob/master/CHANGELOG.md" rel="noopener ugc nofollow" target="_blank"> Angular的报告</a>中生成的变更日志示例</p></figure><p id="0a92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，这些工具使用Git来完成这项工作。在本文中，我们将通过一些步骤来编写我们自己的全功能的changelog生成器！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6dab" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Git是什么？</h1><p id="9916" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Git是真正强大的软件。这是一个协作软件开发的工具。世界上几乎每个开发人员都在使用它！尽管我也一直在使用Git，但我会第一个承认我对Git了解不多。我能做基本的事情，理解一些概念，这足以让我富有成效。但是对于使用Git可以做的更高级的事情呢？我还有很长很长的路要走。看到这样的推文让我感觉更好，因为这意味着其他开发者也在发现关于Git的新东西。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3326" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">建立我们的知识库</h1><p id="d367" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">让我们创建一个目录，并将其初始化为Git存储库。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9e91" class="nh me it nd b gy ni nj l nk nl">mkdir changelog-generator<br/>cd changelog-generator<br/>git init</span></pre><p id="78d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其中，我们将创建一个简单的package.json文件，它只包含<code class="fe nm nn no nd b">version</code>字段。可以把它想象成一个非常简单的JavaScript项目存储库。简单点说，我们就把<code class="fe nm nn no nd b">"1"</code>设为版本吧。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="4766" class="nh me it nd b gy ni nj l nk nl">{<br/>  "version": "1"<br/>}</span></pre><p id="060b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，让我们创建一个<code class="fe nm nn no nd b">CHANGELOG.md</code>文件。暂时空着吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/962654413533d6fb24ee2e9c1b64f5eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ErngtdWfvT3Uduh8hipG9Q.png"/></div></div></figure><p id="b44f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这应该是我们项目的样子；我们暂时提交这个。在常规提交中，每个提交消息都需要加上可用前缀中的一个前缀，如<code class="fe nm nn no nd b">feat</code> <em class="nq">、</em>、<code class="fe nm nn no nd b">fix</code>、<code class="fe nm nn no nd b">perf</code>、<code class="fe nm nn no nd b">refactor</code>、<code class="fe nm nn no nd b">chore</code>、<em class="nq">、</em>等。对于我们的存储库，假设我们必须使用两个前缀，<code class="fe nm nn no nd b">chore</code>和<code class="fe nm nn no nd b">feature</code>。对于我们的初始提交，让我们使用以下命令:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="965b" class="nh me it nd b gy ni nj l nk nl">git add .<br/>git commit -m "chore: Initial commit for changelog generator"</span></pre><p id="bc96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了让我们的repo中有两个提交，让我们创建一个名为<code class="fe nm nn no nd b">index.js</code>的文件。留空；稍后我们将在那里编写代码。进行另一次提交，对于这一次，将<code class="fe nm nn no nd b">feature: Added index.js script</code>设置为提交消息。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8e7b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">编写变更日志生成器</h1><p id="426f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">现在我们要进入主要部分了！如果我们在终端中键入<code class="fe nm nn no nd b">git log</code>，我们将看到<code class="fe nm nn no nd b">git</code>为我们提供了一个到目前为止我们在回购中所做的提交的列表。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="51e5" class="nh me it nd b gy ni nj l nk nl">commit 1c3ec7c03f2796790eaf7271ef47b2141b22cb63 (HEAD -&gt; master)<br/>Author: Jacky Efendi &lt;<a class="ae ky" href="mailto:not-a-real@email.com" rel="noopener ugc nofollow" target="_blank">not-a-real@email.com</a>&gt;<br/>Date:   Sun Oct 20 14:39:42 2019 +0700</span><span id="bc6f" class="nh me it nd b gy nr nj l nk nl">feature: Added index.js script</span><span id="c8f5" class="nh me it nd b gy nr nj l nk nl">commit 05fbe5c5eee29cc33065474800e5401370e7e929<br/>Author: Jacky Efendi &lt;<a class="ae ky" href="mailto:not-a-real@email.com" rel="noopener ugc nofollow" target="_blank">not-a-real@email.com</a>&gt;<br/>Date:   Sun Oct 20 14:39:37 2019 +0700</span><span id="ac8b" class="nh me it nd b gy nr nj l nk nl">chore: Initial commit for changelog generator</span></pre><p id="e1a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，好多东西啊！请记住，我们想要创建一个类似于<a class="ae ky" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>存储库中的CHANGELOG.md的changelog。这意味着对于每次提交，我们只需要提交消息和提交<code class="fe nm nn no nd b">SHA1</code>散列。幸运的是，<code class="fe nm nn no nd b"><a class="ae ky" href="https://git-scm.com/docs/git-log#Documentation/git-log.txt---formatltformatgt" rel="noopener ugc nofollow" target="_blank">git log</a></code>可以配置不同的格式。如果我们键入<code class="fe nm nn no nd b">git log --format=%B%H</code>，Git将只给我们原始的提交主体和散列。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="6501" class="nh me it nd b gy ni nj l nk nl">feature: Added index.js script<br/>1c3ec7c03f2796790eaf7271ef47b2141b22cb63<br/>chore: Initial commit for changelog generator<br/>05fbe5c5eee29cc33065474800e5401370e7e929</span></pre><p id="db67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以创建一个脚本来运行这个命令，获取字符串输出，然后将它转换成一个数组。让我们在<code class="fe nm nn no nd b">index.js</code>中写一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nb l"/></div></figure><p id="26f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们只是在运行<code class="fe nm nn no nd b">git log</code>的同时添加一个<code class="fe nm nn no nd b">—--—DELIMITER—--—</code>字符串来帮助我们分割字符串。我们还过滤掉了没有阿沙散列的提交。如果我们运行该脚本，我们将看到以下输出。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="db3b" class="nh me it nd b gy ni nj l nk nl">➜ node index.js<br/>{ commitsArray:<br/>   [ { sha: '1c3ec7c03f2796790eaf7271ef47b2141b22cb63',<br/>       message: 'feature: Added index.js script' },<br/>     { sha: '05fbe5c5eee29cc33065474800e5401370e7e929',<br/>       message: 'chore: Initial commit for changelog generator' } ] }</span></pre><p id="0c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很好，现在我们有了一个提交数组，它只是带有<code class="fe nm nn no nd b">sha</code>和<code class="fe nm nn no nd b">message</code>的对象。我们可以使用这个数组将东西写入我们的<code class="fe nm nn no nd b">CHANGELOG.md</code>。让我们现在做那件事。很多代码只是从文件中读取，操作字符串，然后将新字符串写入文件，所以我不会用细节来烦你。这是可以为我们生成变更日志的新代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nb l"/></div></figure><p id="9f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行我们的新代码，我们会看到一个不错的变更日志:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/a890fa60e6907dda9e34dbd2c35a50fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AlEd8JIHPxkQEW0QvpozDQ.png"/></div></div></figure><p id="af7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有用！让我们手动将<code class="fe nm nn no nd b">package.json</code>文件中的<code class="fe nm nn no nd b">version</code>移到<code class="fe nm nn no nd b">"2"</code>，并提交所有内容。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="00eb" class="nh me it nd b gy ni nj l nk nl">git commit -m "chore: Bump to version 2"</span></pre><p id="c476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，我们有一个问题。如果我们再次运行脚本，我们会看到列表中有重复的项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c91884eae98b3dae8ed71255dd57a137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yl3nwoQ4S3JDZkjDx6lEHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">版本2列表中的项目不应再次出现在版本3列表中…</p></figure><p id="c6ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我们只运行了<code class="fe nm nn no nd b">git log</code>，它将返回所有的提交。我们想要的是只获取特定提交的日志，直到当前状态。我们需要某种版本控制。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ee8d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">版本控制</h1><p id="afc1" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">使用Git实现版本控制最简单的方法是使用Git标签。基本上，Git标记的目的是标记特定的提交(duh)。让我们试着创建一个。再次在你的终端中运行<code class="fe nm nn no nd b">git log</code>:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fccf" class="nh me it nd b gy ni nj l nk nl">commit 50df6552c5e709b38dfd915aad3fa8e07e2b86e1 (HEAD -&gt; master)<br/>Author: Jacky Efendi &lt;<a class="ae ky" href="mailto:not-a-real@email.com" rel="noopener ugc nofollow" target="_blank">not-a-real@email.com</a>&gt;<br/>Date:   Sun Oct 20 15:27:36 2019 +0700</span><span id="eb9f" class="nh me it nd b gy nr nj l nk nl">chore: Bump to version 2</span><span id="82d3" class="nh me it nd b gy nr nj l nk nl">commit 1c3ec7c03f2796790eaf7271ef47b2141b22cb63<br/>Author: Jacky Efendi &lt;<a class="ae ky" href="mailto:not-a-real@email.com" rel="noopener ugc nofollow" target="_blank">not-a-real@email.com</a>&gt;<br/>Date:   Sun Oct 20 14:39:42 2019 +0700</span><span id="e343" class="nh me it nd b gy nr nj l nk nl">feature: Added index.js script</span><span id="b5ad" class="nh me it nd b gy nr nj l nk nl">commit 05fbe5c5eee29cc33065474800e5401370e7e929<br/>Author: Jacky Efendi &lt;<a class="ae ky" href="mailto:not-a-real@email.com" rel="noopener ugc nofollow" target="_blank">not-a-real@email.com</a>&gt;<br/>Date:   Sun Oct 20 14:39:37 2019 +0700</span><span id="a32d" class="nh me it nd b gy nr nj l nk nl">chore: Initial commit for changelog generator</span></pre><p id="8aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到我们的repo中的最新提交是带有hash <code class="fe nm nn no nd b">50df6552c5e709b38dfd915aad3fa8e07e2b86e1.</code>的提交，您的会有所不同，所以在您的机器上检查一下。让我们将这个最近的提交标记为<code class="fe nm nn no nd b">version2</code>。方法是使用以下命令:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="6f74" class="nh me it nd b gy ni nj l nk nl">git tag -a -m "Tag for version 2" version2</span></pre><p id="5b30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该命令将创建一个带注释的标记，用“Tag for version 2”作为注释，用<code class="fe nm nn no nd b">version2</code>作为标记名。现在，让我们再次尝试运行<code class="fe nm nn no nd b">git log</code>:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e624" class="nh me it nd b gy ni nj l nk nl">commit 50df6552c5e709b38dfd915aad3fa8e07e2b86e1 (HEAD -&gt; master, tag: version2)<br/>Author: Jacky Efendi &lt;<a class="ae ky" href="mailto:not-a-real@email.com" rel="noopener ugc nofollow" target="_blank">not-a-real@email.com</a>&gt;<br/>Date:   Sun Oct 20 15:27:36 2019 +0700</span><span id="264a" class="nh me it nd b gy nr nj l nk nl">chore: Bump to version 2<br/>(...)</span></pre><p id="c245" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，我们的提交现在旁边写有<code class="fe nm nn no nd b">tag: version2</code>。这意味着标签<code class="fe nm nn no nd b">version2</code>现在引用了这个特定的提交，就像我们当前的<code class="fe nm nn no nd b">HEAD</code>一样。现在，我们可以运行<code class="fe nm nn no nd b">git describe --long</code>，Git将告诉我们在我们的Git存储库中的最新标签。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5cb9" class="nh me it nd b gy ni nj l nk nl">➜ git describe --long<br/>version2-0-g50df655</span></pre><p id="09c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出可能看起来有点神秘，但实际上非常简单。该字符串由三部分组成，都由字符<code class="fe nm nn no nd b">—</code>分隔。以下是对每个部分的解释:</p><ol class=""><li id="6ca5" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe nm nn no nd b">version2</code>:在这个Git提交历史中找到的最新标签</li><li id="19c1" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe nm nn no nd b">0</code>:最新标签和当前标签之间的参照数<code class="fe nm nn no nd b">HEAD</code></li><li id="d573" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated"><code class="fe nm nn no nd b">g50df655</code>:当前<code class="fe nm nn no nd b">HEAD</code>的缩写提交<code class="fe nm nn no nd b">SHA</code>，前缀为<code class="fe nm nn no nd b">g</code>。</li></ol><p id="bdc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们关心的是最新标签的名称。我们可以把这个信息传递给<code class="fe nm nn no nd b">git log</code>。<code class="fe nm nn no nd b">git log</code>命令可以接受两个Git引用，并且只返回这两个引用之间的日志。比如，我们可以做<code class="fe nm nn no nd b">git log version2..HEAD</code>。Git将不返回任何东西，因为<code class="fe nm nn no nd b">version2</code>和<code class="fe nm nn no nd b">HEAD</code>当前引用同一个Git提交。让我们尝试添加一个<code class="fe nm nn no nd b">dummy.txt</code>文件并提交它。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="d526" class="nh me it nd b gy ni nj l nk nl">touch dummy.txt<br/>git add .<br/>git commit -m "chore: Added dummy.txt file"</span></pre><p id="736f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们再次运行<code class="fe nm nn no nd b">git log version2..HEAD</code>，我们将只看到一次提交。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="67ea" class="nh me it nd b gy ni nj l nk nl">commit b9491e3c9a22bddff528e48fd599b08c0eafcce1 (HEAD -&gt; master)<br/>Author: Jacky Efendi &lt;<a class="ae ky" href="mailto:not-a-real@email.com" rel="noopener ugc nofollow" target="_blank">not-a-real@email.com</a>&gt;<br/>Date:   Sun Oct 20 15:45:19 2019 +0700</span><span id="4a7b" class="nh me it nd b gy nr nj l nk nl">chore: Added dummy.txt file</span></pre><p id="7945" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望现在您已经知道我们要用这些命令做什么了；让我们回到编码上来！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="68e2" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">编写变更日志生成器(续)</h1><p id="3072" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在代码的第一部分，我们现在想运行<code class="fe nm nn no nd b">git describe --long</code>来获取最新的标签，并且只从那个标签运行<code class="fe nm nn no nd b">git log</code>直到我们当前的<code class="fe nm nn no nd b">HEAD</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nb l"/></div></figure><p id="4626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码的最后一部分，我们现在想自动更新<code class="fe nm nn no nd b">package.json</code>文件中的版本号，创建一个提交，并将该提交标记为新版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nb l"/></div></figure><p id="cc79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们提交新的变更日志生成器:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1fe6" class="nh me it nd b gy ni nj l nk nl">git commit -m "feature: Implemented versioning for the changelog generator"</span></pre><p id="157e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次运行脚本来生成另一个changelog:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/4bf1a43c88a35831c5ce4656b195b4c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68TJKmn1IW2pIkdcDlQI6Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">有用！</p></figure><p id="b426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有了一个全功能的变更日志生成器，并且支持版本控制。</p><p id="c342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了看看这是否真的有效，让我们将一些文本放入<code class="fe nm nn no nd b">dummy.txt</code>文件并提交它。然后，我们将再次运行脚本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f37e7cb8ce10afbef78976a25907424a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzV9qVZSuQF1Pkw2dDG9Rw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">是的，一切都还正常！</p></figure><p id="5fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以将所有标签推送到您的远程存储库，这样它们也会出现在那里。只需运行<code class="fe nm nn no nd b">git push --tags</code>即可。在GitHub web中，你可以在<a class="ae ky" href="https://github.com/jackyef/changelog-generator/tags" rel="noopener ugc nofollow" target="_blank">标签页</a>看到标签列表。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="dfd4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">摘要</h1><p id="91c7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我们基本上只需要<code class="fe nm nn no nd b">git log</code>、<code class="fe nm nn no nd b">git describe</code>和<code class="fe nm nn no nd b">git tag</code>结合一些脚本就可以完成这项工作。这实际上非常类似于像<code class="fe nm nn no nd b">conventional-changelog</code>这样的工具所做的，给你一个简单的生成的变更日志。当然，我们的生成器<em class="nq">非常</em>简单，肯定不会像<code class="fe nm nn no nd b">conventional-changelog</code>那样处理那么多情况，但是核心思想是相似的。通过强制执行特定的提交消息格式，我们可以自动生成变更日志。</p><p id="49b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在处理monorepo时，事情变得更加困难。管理monorepo的工具<code class="fe nm nn no nd b">lerna</code>有自己的脚本，结合<code class="fe nm nn no nd b">conventional-changelog</code>处理monorepo用例。如果您很好奇并想了解更多，请尝试改进这个生成器，使其也能处理monorepo。我相信在这个过程中你会学到更多！</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="005d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="d293" class="nv nw it lb b lc mv lf mw li ol lm om lq on lu oo ob oc od bi translated"><a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener ugc nofollow" target="_blank"> Git标签</a></li><li id="3844" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oo ob oc od bi translated"><a class="ae ky" href="https://git-scm.com/docs/git-log#Documentation/git-log.txt---formatltformatgt" rel="noopener ugc nofollow" target="_blank"> Git日志文档</a></li><li id="054f" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oo ob oc od bi translated"><a class="ae ky" href="https://git-scm.com/docs/git-describe" rel="noopener ugc nofollow" target="_blank"> Git描述文档</a></li><li id="aa70" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oo ob oc od bi translated"><a class="ae ky" href="https://www.conventionalcommits.org/en/v1.0.0/" rel="noopener ugc nofollow" target="_blank">常规提交</a></li><li id="7d46" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oo ob oc od bi translated"><a class="ae ky" href="https://github.com/conventional-changelog/conventional-changelog" rel="noopener ugc nofollow" target="_blank">传统变更日志存储库</a></li></ul></div></div>    
</body>
</html>