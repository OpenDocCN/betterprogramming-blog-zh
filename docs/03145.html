<html>
<head>
<title>Android: How to Fix a Serious Problem in LiveData</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android:如何修复LiveData中的一个严重问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-fix-a-serious-problem-in-livedata-android-594a3f18e981?source=collection_archive---------3-----------------------#2020-01-23">https://betterprogramming.pub/how-to-fix-a-serious-problem-in-livedata-android-594a3f18e981?source=collection_archive---------3-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e753" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每当组件生命周期改变时，避免观察相同的数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68f6322f1fa2fea780c337e807ad4814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GPi32ezWKzIpE4bi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@clark_fransa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿诺·弗朗西斯卡</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c72a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="70dd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">LiveData</code>出自<code class="fe mn mo mp mq b">JetPack</code>家族。它主要用于将数据从视图模型交付给最新架构中的片段和活动，如<code class="fe mn mo mp mq b">MVVM</code>和<code class="fe mn mo mp mq b">clean</code>。</p><p id="3c94" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated"><code class="fe mn mo mp mq b">LiveData</code>是一个可观察的数据持有者类。与其他数据保存器不同，<code class="fe mn mo mp mq b">LiveData</code>是一个生命周期，能够识别各个组件，如<code class="fe mn mo mp mq b">Activities</code>、<code class="fe mn mo mp mq b">Fragments</code>、<code class="fe mn mo mp mq b">services</code>等等。由于它是生命周期感知的，<code class="fe mn mo mp mq b">LiveData</code>确保它只将数据发布给那些在活动时观察它的人，这意味着当他们处于前台时。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="eeb4" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">问题</h1><p id="b8e6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果目标组件<em class="ni">在前台，则<code class="fe mn mo mp mq b">LiveData</code>将数据发布到目标组件<em class="ni">。</em>如果不是，它可能会保存数据，并在特定组件返回到前台时传递数据，就像在<code class="fe mn mo mp mq b">onResume</code> <strong class="lt iu"> </strong>状态中一样。</em></p><p id="45e4" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在我们知道了它是如何工作的，假设我们有一个<code class="fe mn mo mp mq b">livedata</code>，它有多个观察者和三个片段——F1、F2和F3——它们在堆栈中。所有三个片段共享一个<code class="fe mn mo mp mq b">ViewModel</code>并观察一个T类型的<code class="fe mn mo mp mq b">liveData</code>来显示一条消息。</p><p id="75e6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">现在，当我们通过<code class="fe mn mo mp mq b">liveData</code>发布类型T的数据时，因为片段F3在前台，所以消息首先显示在F3中。这很好——但是当我们点击返回时会发生什么呢？片段F2被恢复，因为F2是其订户之一。<code class="fe mn mo mp mq b">LiveData</code>再次传递数据，因此消息显示两次，片段F1重复相同的内容。</p><p id="2fcd" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这就是<code class="fe mn mo mp mq b">livedata</code>的工作方式，但是，在实时情况下，可能会出现一旦观察到数据，就不应该再观察的情况。以下部分包含解决方案。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="6a8d" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">解决办法</h1><h2 id="d493" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">第一步</h2><p id="840d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我们需要创建一个名为<code class="fe mn mo mp mq b">Event</code>的类来包装<code class="fe mn mo mp mq b">livedata</code>公开的数据。看看如何创建一个<code class="fe mn mo mp mq b">Event</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4e1e" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">在这个类中，我们维护一个标志<code class="fe mn mo mp mq b">hasBeenHandled </code>来检查数据是否至少被观察了一次。</p><h2 id="569a" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated"><strong class="ak">第二步</strong></h2><p id="1ed7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在我们需要创建另一个名为<code class="fe mn mo mp mq b">EventObserver </code>的类来扩展<code class="fe mn mo mp mq b">Observer</code>。只是为了让使用过程简单一点，看看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="3ce3" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">当发布新数据时，<code class="fe mn mo mp mq b">onChanged</code>功能被触发，标志<code class="fe mn mo mp mq b">hasBeenHandled </code>被设置为假。一旦第一个订户观察到数据，标志<code class="fe mn mo mp mq b">hasBeenHandled </code>将为真，使得其余订户不会接收到数据，并且每次发布新数据时循环重复。</p><h2 id="1d95" class="nj la it bd lb nk nl dn lf nm nn dp lj ma no np ll me nq nr ln mi ns nt lp nu bi translated">第三步</h2><p id="b0fd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在观察<code class="fe mn mo mp mq b">livedata</code>时，我们需要使用<code class="fe mn mo mp mq b">EventObserver </code>而不是常规的<code class="fe mn mo mp mq b">Observer </code>，以便简化操作。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><p id="d917" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">这是我从2020 AndroidDev峰会app源代码中找到的解决方案。</p><p id="63d6" class="pw-post-body-paragraph lr ls it lt b lu mr ju lw lx ms jx lz ma mt mc md me mu mg mh mi mv mk ml mm im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>