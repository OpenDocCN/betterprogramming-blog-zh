# 研究 Go 中的函数式编程概念

> 原文：<https://betterprogramming.pub/investigate-functional-programming-concepts-in-go-1dada09bc913>

## 应用概念

![](img/f59903cde36a814d94e134ac9fb9b5dc.png)

[Vino Li](https://unsplash.com/@vinomamba24?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

在本文中，我们将研究如何在 [Go](https://go.dev/) 中利用函数式编程概念。

我们将触及 go 1.18 中[泛型的引入所带来的可能性和一些限制。函数式编程风格帮助我们编写易于理解、可维护和可测试的代码。](https://tip.golang.org/doc/go1.18#generics)

许多底层概念已经在广泛使用的语言的最新版本中找到了自己的方式，特别是 [map/reduce](https://docs.oracle.com/javase/tutorial/collections/streams/reduction.html) 模式或[可选](https://doc.rust-lang.org/std/option/enum.Option.html)值的概念。

# 指导原则

我想强调以下原则，它们是函数式编程风格的基础:

## 纯函数

顾名思义，函数式编程就是写函数。如果一个函数的输出只依赖于它的输入，并且没有任何副作用[的话，这个函数被认为是](https://en.wikipedia.org/wiki/Side_effect_(computer_science))[纯](https://en.wikipedia.org/wiki/Pure_function)。这种功能有几个好处:

*   通常很容易理解这个函数在做什么，因为根据定义，您知道它没有任何副作用
*   该功能可以进行单元测试，而不必设置复杂的模拟
*   纯函数很容易在多线程环境中使用。因为它们没有副作用，所以也不需要外部数据结构的同步

有副作用的函数被认为是不纯的。这种意义上的副作用是非本地状态的任何修改(即改变全局变量、改变输入参数)或任何形式的 I/O(从流或文件中读取/写入、打印到控制台等)。).

另一方面，副作用是程序的一个关键特征，因此函数式编程提供了将它们与纯函数结合的机制，例如 [I/O Monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad) 。在这篇文章中，我们将不再赘述。

## 不变

不可变数据结构背后的关键思想是，如果一个函数不能改变任何数据，那么这个函数的行为更容易预测。这与纯函数的概念密切相关，纯函数意味着一个纯函数不能改变它的任何输入。我们不是更改数据，而是制作稍微修改过的数据拷贝。

## 作文

拥有纯函数的一个好处是，我们可以使用这些函数，并将它们组合成更复杂(纯)的函数。由于这种组合的每一个构件都可以作为一个单元来测试，所以我们可以满怀信心地派生出更高级的功能，直到我们最终达到所需程序的水平。

事实证明，有可能提出一组对许多情况都有用的组合函数，因此我们可以一般地实现它们。这反过来又提高了可读性，因为同一组复合函数反复出现，并且总是具有相同的语义。

# 申请外带

让我们研究一下前面提到的概念是如何应用于 Go 语言的。我们用一个简单的例子来说明。编写一个执行以下操作的函数:

*   取一个未知物体的`map`作为输入
*   阅读这张地图的一个条目
*   如果条目是一个字符串，尝试将其转换成一个`int`
*   如果任何一项失败，则返回默认值

在惯用的 Go 中，这段代码可能如下所示:

在 Go 中，可能失败的操作将其返回值建模为一个元组，在第一个元素中有实际值，在第二个元素中有一个标志或错误。然而，这个元组在 Go 中并不表示为顶级类型，也就是说，我们只能将其析构为两个变量，但我们不能编写一个接受元组作为输入的函数来将各个步骤组合在一起。

让我们引入一个`Option`的概念来解决这个问题。`Option`是一种数据类型，它携带一个值或无值的概念:

使用这种数据类型，我们可以编写表示原始操作的可组合函数:

注意助手函数中泛型的使用。`Lookup`方法是完全通用的，它适用于任何类型的`map`，因此它是实用程序库的一个很好的候选。`ToString`和`ParseToInt`方法为它们的用例专门化了一般的`Options`类型。

将原语操作分离到它们自己的函数中的第一个好处是，我们现在可以为这些函数编写单元测试，包括完整的边界检查。当我们将这些结合在一起时，真正的优势就体现出来了。为此，我们定义了可重用的组合操作:

请特别注意`Chain`方法。它将可能包装一种类型`A`的`Option`转换成可能包装另一种类型`B`的`Option`。类型之间的关系由转换函数给出。我们所有的帮助函数都是这种特殊的数据类型，它们接受一个普通类型作为输入，返回另一种类型的`Option`作为输出。因此，他们立即与我们新的`Chain`运营部门合作。让我们看看如何将它应用到我们最初的问题中:

这个例子比惯用的例子有优势，因为它避免了重复使用`if`子句进行错误处理。它显示了操作的逻辑顺序流，并将错误处理转移到组合功能的实现中。尽管如此，代码看起来还是有点复杂。

我们注意到这段代码中的两个方面:

*   每一行都有相同的结构。首先，我们创建一个描述期望操作的函数，例如`Chain(ToString)`，然后我们将这个函数应用于一个值
*   每个函数的参数是前一个函数的返回值，形式上我们不需要任何中间值

那么，我们如何以一种更易读、更紧凑的方式将这些函数组合在一起呢？

在第一次尝试中，我们可以简单地尝试将函数链接在一起作为嵌套函数。这是可行的，但是严重缺乏可读性，主要是因为函数的读取顺序与执行顺序不匹配。我们首先读取`O.GetOrElse`，但它实际上是最后一个被调用的函数。此外，我们添加的步骤越多，阅读体验就越差。

让我们通过引入另一个效用函数`Pipe`来解决这个问题，该函数接受初始值，然后接受一系列连续应用于前一个函数输出的函数:

这段代码看起来干净多了，它按照逻辑顺序显示了操作，易于理解，并且没有因为显式的错误处理而使代码混乱。我们还可以做得更好一点，因为我们注意到除了作为第一个函数的种子之外，输入变量`data`并不是显式需要的。

因此，我们不使用`Pipe`辅助函数，而是引入一个带有这个签名`func Flow(f1, f2, ...) func(T)R`的`Flow`输入函数，也就是说，它创建一个新函数，其输入与作为第一个参数接收的函数相同，返回值与上一个函数的返回值相同。然后我们的例子最终看起来像这样:

## 单子

在开发最后一个函数的过程中，我们发现了`Options`类型及其关键操作`Of`和`Chain`的用处。在函数式编程中，这就是我们所说的[单子](https://en.wikipedia.org/wiki/Monad_(functional_programming))，事实证明底层模式可以应用于更多的用例。

在我们的实现中，`Of`方法有时被称为`unit`、`return`或`just`，它的意思是将一个值包装到一个装箱的值中，这个装箱能够实现通用的操作。`Chain`方法也被称为`bind`、`flatMap`或`mergeMap`，它允许将函数应用于包装的值，同时让通用代码在结果上运行。

# Golang 特征

Go 1.18 中[泛型](https://tip.golang.org/doc/go1.18#generics)的引入，使得为多种数据类型编写代码成为可能。使用语法`type Option[A any] interface`我们告诉大家，我们打算为任何类型的数据表示一个包装器，而无需在编码时指定这种类型。

函数式编程方法的另一个关键方面是将函数组合在一起的能力。事实证明，定义只有一个输入参数和一个输出的函数是有帮助的，因为这样我们就可以轻松地将一个函数的输出作为下一个函数的输入进行传递，并创建管道。为了使用这个特性，我们利用 go 的能力来创建[高阶函数](https://www.golangprograms.com/higher-order-functions-in-golang.html)。

我们的`Chain`方法被声明为`func Chain[A, B any](f func(A)Option[B])func(Option[A])Option[B]`，即它是一个接受一个输入的函数，一个转换函数`f`，它返回另一个函数作为输出。这个函数依次接受一个输入，一个`Option[A]`并返回一个输出，一个`Option[B]`。这种结构允许高效的功能组合。

纯函数的函数式编程概念很好地匹配了 Go 语言的特性。尽管 Go 并不强制执行这种模式，但它允许实现这种模式。

加上对高阶函数的良好支持，编写纯函数是程序员的准则。

# 限制

虽然可以用函数式风格实现程序，但存在一些语言限制:

## 类型差异

Go 不支持不可变数据结构的概念。如果需要，程序员可以确保数据结构在函数调用过程中保持不变。

然而，这种缺乏概念的结果是所有的数据类型，尤其是容器类型，都被认为是[不变的](https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science))。如果语言支持不可变类型，我们更喜欢纯函数的协变类型的概念。

考虑下面的例子:

我们可以很容易地用一个`int`作为输入来调用`TakeAny`函数，尽管它接受一个`any`。

但是我们不能进行第二次调用，在第二次调用中，`TakeAnyArray`接受了一个`[]any`，我们试图用一个`[]int`调用它。

这完全有意义，因为`[]int`是可修改的，如果我们允许它被传递到一个带`[]any`的函数中，那么这个函数可能会尝试将一个`float`或任何其他数据类型添加到数组中，这当然是行不通的。如果我们有办法告诉我们只打算从数组中读取，那么传入`int`数组是可以接受的，但这是[而不是](https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#no-way-to-express-convertibility)的情况。

注意，原语`int`本质上是不可变的，这是我们可以毫无问题地调用`TakeAny`的原因。

该问题适用于所有容器类型，包括我们的`Option[A]`。我们知道`Option`本质上是不可变的，但是没有办法告诉编译器。

因此，如果我们有一个函数返回一个`Option[*File]`(例如[打开](https://pkg.go.dev/os#Open))，我们不能在没有显式类型转换的情况下将它直接链接到一个接受`Reader`的函数。

## 函数重载

Go 不支持重载函数，即定义一个同名但参数不同的函数。

最接近重载的是[变量函数](https://gobyexample.com/variadic-functions)，但是这些函数要求变量函数的参数是相同类型的。

这个限制直接适用于我们的`Pipe`函数。理想情况下，我们希望为任意数量的输入定义该函数，同时保持类型安全。

但是，由于缺少函数重载，我们需要为每个参数明确定义不同的函数。我们需要记住在添加和删除管道步骤时使用正确的数字后缀。但至少这给了我们类型安全，如果我们用错误数量的参数调用函数，编译器会让我们知道。

## 方法的类型参数

在前面的例子中，您可能想知道为什么我们要编写复杂的`Pipe`函数，而不是使用链接方法。

在上面虚构的例子中，如果`Optional`类型包含`Chain`和其他操作作为实例方法，我们就不需要`Pipe`。

然而，这是不可能的，因为`Chain`需要两个类型参数，一个用于它所操作的`Option`，另一个用于返回值的类型，因为我们使用转换函数来改变类型。这需要`Chain`携带自己的类型参数，这是[泛型规范](https://github.com/golang/go/issues/49085)所禁止的。

# 结论

函数式编程风格提供了一个非常吸引人的编程模型，但同时，它与 Go 语言一起使用也暴露了一些缺点，特别是因为(临时？)语言限制和对惯用编码风格的偏离。还值得用吗？

对我来说，答案是肯定的。纯函数、不可变的数据结构和函数组合几乎会自动产生可测试的干净代码。如果编写测试很容易，那么同时编写测试代码和函数就成了第二天性，而且随着时间的推移，这是值得的。

函数组合允许将大量样板代码转移到实用程序库中。这些只需编写和测试一次，就可以在许多项目中重用。

由于相同的组合函数`Chain`、`Map`、`Reduce`……反复出现，即使在`Monads`中，代码也易于阅读，尽管它偏离了惯用的编码风格。这是一个习惯的问题，但这只是我经验中很浅的学习曲线。

但是为什么不使用一种对函数模式有更好内置支持的语言，比如 [Rust](https://www.rust-lang.org/) ？语言的选择不仅取决于语法和语言特性，还取决于生态系统。今天，Go 是基于云的应用程序的通用语言，所以如果你想与图书馆的庞大生态系统集成，Go 是一个不错的选择。工具和 IDE 支持也非常好，所以我们可以轻松地跨平台编译。

因此，让我们结合两个世界的优点来编写令人敬畏的代码！