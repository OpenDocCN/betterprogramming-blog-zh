<html>
<head>
<title>The Complete Guide to Using GraphQL in Node.js With Apollo Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Node.js中的GraphQL用于Apollo Server的完整指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-using-graphql-in-node-js-with-apollo-server-aef347a7a0ee?source=collection_archive---------5-----------------------#2021-01-15">https://betterprogramming.pub/the-complete-guide-to-using-graphql-in-node-js-with-apollo-server-aef347a7a0ee?source=collection_archive---------5-----------------------#2021-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d3a6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将GraphQL集成到Node.js应用程序中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b780a6857f065ffafcb9ab188162d5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eKl9PTrqKmztXC9T"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://unsplash.com/photos/BHlaVh6-An0" rel="noopener ugc nofollow" target="_blank">安吉拉·孔波尼</a>对<a class="ae ky" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7e31" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">本文的目标</h1><p id="8ed5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本文中，我们将了解以下内容:</p><ul class=""><li id="49b9" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">什么是GraphQL</li><li id="2e92" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">何时使用它，它相对于REST的优势是什么</li><li id="9ba8" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">Apollo服务器的基本GraphQL功能</li><li id="8216" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">高级GraphQL功能，如GraphQL中的解析器链和突变</li><li id="0d95" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">使用GraphQL时需要记住的重要事项</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="81cc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="7000" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">GraphQL的流行使得许多开发者从REST转向在他们的新应用中使用GraphQL。如果您是一名新手或有学习热情的开发人员，您可能会认为GraphQL是一种非常难以使用的技术。</p><p id="ad68" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">对此我的回答是否定的。GraphQL已经成为最热门的学习技术之一，这是有充分理由的。我们先来了解一下GraphQL是什么。</p><h2 id="78f3" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">什么是GraphQL</h2><p id="ea1f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">简单来说，就是从API查询数据的一种方式。此外，GraphQL允许程序员请求将数据从服务器拉至客户机。所有这些似乎都类似于使用REST方法，那么它们之间的区别是什么，为什么要使用GraphQL呢？<a class="ae ky" href="https://graphql.org/users/" rel="noopener ugc nofollow" target="_blank">包括GitHub和Twitter在内的90多家公司都在使用它</a>，所以它一定有什么不同之处。</p><h2 id="6d09" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">为什么使用它</h2><p id="5cd9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当使用REST获取数据时，您有多个端点和其他请求，如<code class="fe nz oa ob oc b">POST</code>、<code class="fe nz oa ob oc b">DELETE</code>、<code class="fe nz oa ob oc b">GET</code>和<code class="fe nz oa ob oc b">PUT</code>。此外，您可以通过从多个端点获取所需的数据。另一方面，GraphQL去掉了不同的端点，只给你一个端点。您需要的数据取决于您发送到这个单一端点的查询。</p><p id="5cb6" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">让我用一个例子来说明这一点。假设您正在构建一个应用程序，它只显示来自这个<a class="ae ky" href="https://sampleapis.com/api-list/coffee" rel="noopener ugc nofollow" target="_blank"> Coffee API </a>的咖啡名称。</p><p id="1cb9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">休息时，你会先要热咖啡，然后要冷咖啡。最后，您只想显示返回响应中的<code class="fe nz oa ob oc b">title</code>字段。它会这样做:</p><ul class=""><li id="f303" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">首先，您将看到所有可用的数据及其字段:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/bae2e51e52877d9b7bffe61b870c330f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMFz0w-sOD1FHx7TGoG2yQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">获取REST中所有可用的数据</p></figure><p id="23af" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将为您提供如下所示的输出:</p><div class="kj kk kl km gt ab cb"><figure class="oe kn of og oh oi oj paragraph-image"><img src="../Images/b93847f0f7a3d3af885d37b7015c4c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*xglgsnObtQanufIBZ2hGJQ.png"/></figure><figure class="oe kn ok og oh oi oj paragraph-image"><img src="../Images/eefa259beb520c00ec27e2b421d5cce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*bm6GU6KaBZYNs9B8U6vnJA.png"/><p class="ku kv gj gh gi kw kx bd b be z dk ol di om on translated">代码的输出</p></figure></div><ul class=""><li id="6e94" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">所有这些数据对我们来说都是不必要的。为了只获取<code class="fe nz oa ob oc b">title</code>字段，我们需要像这样重写我们的代码:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/3fb4b3be213a2e364fbbdc5cb86571f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2iCuA_ZPEHXyS5AuhNFww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在休息中得到唯一的标题</p></figure><p id="3581" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将产生以下输出:</p><div class="kj kk kl km gt ab cb"><figure class="oe kn op og oh oi oj paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/815ed1ec4673b4d0ae880fd6df72f3f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*0NF6xKxJejAWz6lgUL_RCg.png"/></div></figure><figure class="oe kn oq og oh oi oj paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/2f6138bdc1db101751560ad53c4dfe0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*3eN3nn7MbNDEtT1tCT4QJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk or di os on translated">代码的输出</p></figure></div><p id="2417" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">如你所见，这相当容易。但是请注意，当我们的响应出现时，不需要的字段也出现了，例如，<code class="fe nz oa ob oc b">description</code>和<code class="fe nz oa ob oc b">ingredients</code>。我们只需要<code class="fe nz oa ob oc b">title</code>，其他什么都不需要。注意，我们还执行了几次<code class="fe nz oa ob oc b">GET</code>请求。在某些情况下，<code class="fe nz oa ob oc b">GET</code>请求也会被执行超过必要的次数。这被称为<em class="ot">过取</em>。那么，我们如何在只接收我们想要的数据的同时防止这种情况呢？</p><p id="d8a1" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这就是GraphQL介入的地方。您向API指定您需要什么数据(在本例中，只有<code class="fe nz oa ob oc b">title</code>)，结果，您得到的响应过滤掉了不需要的数据，只返回过滤后的数据(在这里，这只是每个对象的<code class="fe nz oa ob oc b">title</code>字段)。</p><p id="2550" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">让我们用GraphQL复制这个。您也可以<a class="ae ky" href="https://api.sampleapis.com/coffee/graphql" rel="noopener ugc nofollow" target="_blank">自己运行查询</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/42027765721122012e0f1be12a7759ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*2_i4hk2lq972bLVrJLCfXw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询以获取GraphQL中的数据</p></figure><ul class=""><li id="c53f" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第2–4行:我们首先进行查询，以获得冰咖啡的<code class="fe nz oa ob oc b">title</code>。</li><li id="d32f" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第5–7行:然后我们进行另一个查询来获取冷咖啡的<code class="fe nz oa ob oc b">title</code>。</li></ul><p id="57d5" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这就是事情的全部。当我们运行查询时，输出如下:</p><div class="kj kk kl km gt ab cb"><figure class="oe kn ov og oh oi oj paragraph-image"><img src="../Images/7331fafc0c1e872fefd79826b667e539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*ez8DjoMDqXEklx1xsXjhwQ.png"/></figure><figure class="oe kn ow og oh oi oj paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/2bdfdcab05d8aca557ddbfd6a6a0f494.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*mlDjDwY4c4Moa7n4cBHSGg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk ox di oy on translated">GraphQL查询的输出</p></figure></div><p id="1e0b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">如您所见，我们成功地获得了一个响应，而没有收到我们不需要的其他字段。没有必要筛选出不需要的字段。在编程领域，这是一个游戏改变者。</p><p id="7cc2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">既然已经谈了GraphQL的结果，那就来写点代码吧！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3063" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">开始</h1><p id="a6ef" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">首先，使用以下终端命令初始化项目的存储库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/bb7c881da25f7c7ea66e2962ba1a8d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXxbjO704kleVFnuxo7fSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">初始化我们的项目</p></figure><p id="fafa" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">完成后，现在让我们安装项目所需的库。</p><h2 id="62f3" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">安装库和依赖项</h2><p id="0f73" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们将使用以下库:</p><ul class=""><li id="ab53" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">这是阿波罗服务器的核心库。Apollo服务器技术将允许我们在Node.js应用程序中使用GraphQL。</li><li id="1315" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated"><code class="fe nz oa ob oc b">graphql</code>:这个库将用于构建GraphQL模式。此外，<code class="fe nz oa ob oc b">graphql </code>也是<code class="fe nz oa ob oc b">apollo-server</code>模块的依赖项。我们将在本教程的后面详细讨论模式。</li></ul><p id="a547" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们现在已经完成了这一部分。在下一节中，我们将学习GraphQL的基础知识。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="30a4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">GraphQL:使用Apollo服务器的基本查询</h1><p id="b6e2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本节中，我们将学习GraphQL的基础，并使用一个简单的数据集。此外，我们还将学习GraphQL查询语言的基础知识。</p><h2 id="7238" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">设置</h2><p id="69f1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在您的项目目录中，创建一个名为<code class="fe nz oa ob oc b">basic-server.js</code>的文件。这将是我们项目的主要文件。</p><p id="e7b4" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">basic-server.js</code>中，我们将从<code class="fe nz oa ob oc b">apollo-server</code>模块中导入以下依赖项:</p><ul class=""><li id="f365" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated"><code class="fe nz oa ob oc b">gql</code>:这是为了创建我们的模式。</li><li id="11f0" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated"><code class="fe nz oa ob oc b">ApolloServer</code>:这将构建并运行我们的GraphQL服务器。</li></ul><p id="0214" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">转到<code class="fe nz oa ob oc b">basic-server.js</code>，像这样导入这些:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/48f48691fe95d182df400404244fdcb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ppa2czxXsMH4fue6fwh1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在basic-server.js中编写的代码</p></figure><p id="6532" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">完成后，现在让我们来处理我们的模式。</p><h2 id="6d6d" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">定义我们的模式</h2><p id="afbf" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">什么是<em class="ot">模式</em>？根据<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/getting-started/#step-3-define-your-graphql-schema" rel="noopener ugc nofollow" target="_blank"> Apollo的文档</a>，模式本质上是通知GraphQL关于客户端可以查询的数据的结构或形状<em class="ot"> </em>。换句话说，这个模式是客户端可以从GraphQL API请求的数据的描述。</p><p id="9491" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">basic-server.js</code>中，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/9dde7b2ececd1cea08135cc7d02b9f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tSugSq3yZaY_JOa-qmXFuQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在basic-server.js中编写的代码</p></figure><ul class=""><li id="94a4" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第2–4行:这里我们告诉GraphQL，<code class="fe nz oa ob oc b">HelloWorld</code>是一个对象类型，它有一个名为<code class="fe nz oa ob oc b">message</code>的字段。<code class="fe nz oa ob oc b">message</code>字段将包含字符串数据。</li><li id="258b" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第5-7行:这里我们告诉GraphQL，客户端可以执行一个名为<code class="fe nz oa ob oc b">helloworld</code>的查询，结果，返回的数据将是类型<code class="fe nz oa ob oc b">HelloWorld</code>。</li></ul><p id="cc95" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这里，<code class="fe nz oa ob oc b">String</code>是一个<em class="ot">标量类型。标量类型类似于您在其他编程语言中使用的数据类型，例如Int、Boolean等等。关于标量类型的更多细节，请参考<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/schema/schema/#scalar-types" rel="noopener ugc nofollow" target="_blank"> Apollo服务器的文档</a>。</em></p><p id="1a41" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">另一方面，<code class="fe nz oa ob oc b">HelloWorld</code>和<code class="fe nz oa ob oc b">Query</code>被称为<em class="ot">对象类型。</em>一个对象类型包含一个字段集合，每个字段可以是标量类型，也可以是另一个对象类型。这类似于您在其他编程语言中使用的对象。</p><p id="d6aa" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated"><strong class="ma iu">重要提示</strong> : <code class="fe nz oa ob oc b">Query</code>是一个特殊的对象类型，它定义了客户端可以根据我们的GraphQL API查询的所有数据。</p><p id="e0a9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">既然我们已经通知了GraphQL我们的模式，现在让我们开始实际创建我们的数据集。</p><h2 id="a5d3" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">定义我们的数据集</h2><p id="0c4a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这里我们将简单地创建一个对象，它的字段名为<code class="fe nz oa ob oc b">message</code>。</p><p id="c44e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">basic-server.js</code>中，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/7a77bfdb156074a2ccce7587aae6fa49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYoTqzu7EhoRWqyoAk_t8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在basic-server.js中编写的代码</p></figure><p id="4291" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">如您所见，<code class="fe nz oa ob oc b">message</code>字段包含单词“来自GraphQL的Hello World！”。</p><p id="da09" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在已经完成了，让我们来研究解析器。</p><h2 id="519d" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">使用解析器获取数据</h2><p id="a360" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">简单地说，<em class="ot">解析器</em>是一个告诉GraphQL从哪里获取信息的函数。换句话说，它告诉GraphQL如果用户执行查询，返回什么数据。例如，如果用户在<code class="fe nz oa ob oc b">helloworld</code>上执行一个查询，GraphQL将参考resolver函数返回什么数据作为响应。</p><p id="a68b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在我们的例子中，我们希望解析器返回<code class="fe nz oa ob oc b">message</code>字段的值(即“来自GraphQL的Hello World！”)在<code class="fe nz oa ob oc b">HelloWorld</code>对象中，如果用户对<code class="fe nz oa ob oc b">helloworld</code>进行查询。</p><p id="57ee" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">basic-server.js</code>中，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/1edc389ccc34897960d728b4efc790ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H7raGWsmrMJ6IMJz2F9OUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在basic-server.js中编写的代码</p></figure><ul class=""><li id="2a94" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第3–4行:这里我们创建了一个解析器，它告诉GraphQL如果用户查询名称<code class="fe nz oa ob oc b">helloworld</code>，那么返回的结果将是我们定义为数据的<code class="fe nz oa ob oc b">HelloWorld</code>对象。</li></ul><p id="4c94" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">完成后，作为我们的最后一步，我们将运行我们的GraphQL服务器。</p><h2 id="db46" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">运行服务器</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/23350451d7ebae4c13cb061dea9341df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6Z8s6wAjalr8PJPQyj-5UQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在basic-server.js中编写的代码</p></figure><ul class=""><li id="3b3a" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第1行:这里我们创建了一个<code class="fe nz oa ob oc b">ApolloServer</code>的实例，并通知GraphQL使用我们最近定义的模式和解析器。</li><li id="d1cb" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第2-4行:启动我们的服务器。</li></ul><p id="1094" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在运行代码。要查看输出，请转到<code class="fe nz oa ob oc b">localhost:4000</code>。</p><p id="60f9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">然后，您将看到一个如下所示的页面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/003813d810f9ed4707762e1408ad3400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G6m21_x1VxHOTIa8DKTCgg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="fee9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在您的应用程序右侧，点击<code class="fe nz oa ob oc b">Docs</code>按钮。这将为您提供可以查询的数据的摘要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/abf73043cd9f96951e6bd25455053cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*vUJaiPt-ymjWyyE_Kd0f0w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apollo服务器中的文档部分</p></figure><p id="9fd8" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">正如我们所看到的，这正是我们在模式中定义的。我们可以执行一个名为<code class="fe nz oa ob oc b">helloworld</code>的查询。此外，文档菜单证明<code class="fe nz oa ob oc b">helloworld</code>属于类型<code class="fe nz oa ob oc b">HelloWorld</code>。</p><p id="de33" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">接下来，点击列表中的<code class="fe nz oa ob oc b">helloworld</code>项，这样我们可以获得关于<code class="fe nz oa ob oc b">HelloWorld</code>对象类型中字段的更多信息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/078a86188fab5b8ce9b370ae4625c3a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*FQ-ciRGfAzUSTt5Onm9iCg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们helloworld查询的详细信息</p></figure><p id="3a2d" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们现在可以看到出现在<code class="fe nz oa ob oc b">HelloWorld</code>对象类型中的字段。此外，注意到<code class="fe nz oa ob oc b">HelloWorld</code>有一个名为<code class="fe nz oa ob oc b">message</code>的字段，其标量类型为<code class="fe nz oa ob oc b">String</code>。我们需要执行一个查询来获取这个字段的值。</p><p id="8021" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在跳回GraphQL的查询编辑器，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/5562c6ae6223c84fee9a146f11baf469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QwIpmmpof5Pq7RViugsXQQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><ul class=""><li id="3925" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第1行:这告诉GraphQL我们正在执行一个查询。</li><li id="4dad" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第二行:这里我们从<code class="fe nz oa ob oc b">helloworld</code>查询。</li></ul><p id="e93b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在按播放键。这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/dc4b5d4e1328f8bb25916afd7fac558e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3KcAK1hengx19x3HVFHHkg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="f159" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们出错了。这是为什么呢？我们只是请求GraphQL给我们关于<code class="fe nz oa ob oc b">HelloWorld</code>对象的数据。它应该给我们一个对象作为回应，对吗？</p><p id="358b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们得到的不是我们想要的响应，而是一个错误，因为<strong class="ma iu">我们不够具体</strong>。我们需要明确地告诉GraphQL我们想要什么。</p><p id="f08b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在这种情况下，我们希望<code class="fe nz oa ob oc b">message</code>字段的值出现在<code class="fe nz oa ob oc b">HelloWorld</code>对象中。在查询编辑器中，将代码更改为以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/26d98feb1c07df4733d08f3be648f2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qf4nKYdbDve9JIpwUC2Yw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><ul class=""><li id="777a" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第3行:这里我们查询位于<code class="fe nz oa ob oc b">helloworld</code>中的<code class="fe nz oa ob oc b">message</code>字段的值。</li></ul><p id="9bd2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">当您按下播放按钮时，这将是返回的响应:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/6d4bbe5958ba1c84caff95f0afb86d3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ri1ivuZNEKsd4_NO7qo8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="3f9e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">太好了！如您所见，我们得到了想要的数据。回想一下，我们在数据集中定义了这个<code class="fe nz oa ob oc b">message</code>字段的值。</p><p id="513e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">此外，注意GraphQL的查询语言类似于JSON。如果你懂Javascript，那么JSON对你来说并不陌生。因此，它的学习曲线变得更浅。</p><p id="d4b7" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们现在已经完成了这一部分。在下一篇文章中，我们将通过使用解析函数和变异等概念来提升我们的GraphQL游戏。</p><p id="dd19" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">最后，<code class="fe nz oa ob oc b">basic-server.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="d8b7" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这是获取我们想要的数据的查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/26d98feb1c07df4733d08f3be648f2d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qf4nKYdbDve9JIpwUC2Yw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2e5b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">GraphQL:使用解析器链和执行变异</h1><p id="dbcc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在本节中，我们将使用中等复杂的数据集，甚至学习如何将两个数据集链接在一起，例如，一个作者数据库和一个图书数据库。此外，我们还将在GraphQL中编辑我们的数据库。</p><p id="018f" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">创建一个名为<code class="fe nz oa ob oc b">advanced-server.js</code>的文件。该文件的设置与<code class="fe nz oa ob oc b">basic-server.js</code>类似。</p><p id="b59e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">设置完成后，让我们首先处理模式。</p><h2 id="0685" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">定义我们的模式</h2><p id="c6e2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在我们的模式中，我们将定义两种对象类型:</p><ul class=""><li id="bb46" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">这将链接到我们包含图书列表的数据库。</li><li id="7265" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">这将链接到我们包含作者名单的数据库。</li></ul><p id="1d4f" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">basic-server.js</code>中，编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="d1f2" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第2-6行:这里我们定义了我们的<code class="fe nz oa ob oc b">Book</code>对象类型。它将有一个类型为<code class="fe nz oa ob oc b">String</code>的<code class="fe nz oa ob oc b">name</code>字段和一个类型为<code class="fe nz oa ob oc b">ID</code>的<code class="fe nz oa ob oc b">id</code>字段。此外，我们还有一个<code class="fe nz oa ob oc b">authorId</code>字段，它将帮助我们将图书数据库链接到作者数据库。第5行的<code class="fe nz oa ob oc b">!</code>表示这个字段在我们的数据库中是强制性的。</li><li id="92e7" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第7-10行:这里我们定义了我们的<code class="fe nz oa ob oc b">Author</code>对象类型。它将有一个类型为<code class="fe nz oa ob oc b">ID</code>的<code class="fe nz oa ob oc b">id</code>字段和一个类型为<code class="fe nz oa ob oc b">String</code>的<code class="fe nz oa ob oc b">name</code>字段。</li><li id="3388" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第12行:<code class="fe nz oa ob oc b">[Book]</code>表示如果客户查询书籍，那么他们将收到一个由<code class="fe nz oa ob oc b">Book</code>对象组成的数组作为响应。</li><li id="1ece" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第13行:<code class="fe nz oa ob oc b">[Author]</code>表示如果客户机查询作者，那么它们将收到一个由<code class="fe nz oa ob oc b">Author</code>对象组成的数组作为响应。</li></ul><p id="5b14" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在我们已经定义了我们的模式，让我们继续定义我们的数据集。</p><h2 id="2dc3" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">创建我们的数据集</h2><p id="fb87" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这里我们将创建两个对象数组。一个将有关于书籍的信息，另一个将有关于作者的数据。</p><p id="a59e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">advanced-server.js</code>中，复制并粘贴以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="7489" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">如您所见，我们有一个包含三个作者信息的<code class="fe nz oa ob oc b">authors</code>数组。另一方面，我们有一个包含八本书信息的<code class="fe nz oa ob oc b">books</code>数组。</p><p id="5571" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在让我们继续创建我们的解析器。</p><h2 id="6cdb" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">定义我们的解决方案</h2><p id="1074" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，我们将定义两个解析器函数:</p><ul class=""><li id="d568" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated"><code class="fe nz oa ob oc b">books</code>:这将返回<code class="fe nz oa ob oc b">books</code>数据集。</li><li id="d232" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated"><code class="fe nz oa ob oc b">authors</code>:这将返回<code class="fe nz oa ob oc b">authors</code>数据集。</li></ul><p id="5d45" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">advanced-server.js</code>中，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/447b9b45f39a4848e22cd0254cb9bc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94mGUdPIURwzox3BOEkj5g.png"/></div></div></figure><ul class=""><li id="9ed7" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第3行:<code class="fe nz oa ob oc b">books</code>解析器将返回图书数据库。</li><li id="b029" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第6行:<code class="fe nz oa ob oc b">authors</code>解析器将返回作者数据库。</li></ul><p id="9c33" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在让我们像这样运行我们的服务器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/87558c39af262907481297c0eca34797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ob062RrSjgx4ZdwGZw3nQA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在advanced-server.js中运行服务器的代码</p></figure><p id="80ec" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在运行代码。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/8c26848d757e43dc95f2fe77675209f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qcAXZWyRkj6itwRyVqiyKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="4205" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在，在查询编辑器中编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="76b0" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第2–5行:这里我们查询作者并从<code class="fe nz oa ob oc b">authors</code>对象中获取<code class="fe nz oa ob oc b">name</code>和<code class="fe nz oa ob oc b">id</code>字段。</li><li id="a699" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第6-10行:这里我们查询书籍并从<code class="fe nz oa ob oc b">books</code>对象获取<code class="fe nz oa ob oc b">name</code>、<code class="fe nz oa ob oc b">id</code>和<code class="fe nz oa ob oc b">authorId</code>字段。</li></ul><p id="caee" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">当您按下播放按钮时，输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/5bdab3f64d71fb7f29d67110bbaab54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*I-u3qSWLT32sxXrUCV8wsA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="9517" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">维奥拉。我们的代码是成功的。我们得到了想要的数据。我们学习了如何返回一个对象数组作为响应。</p><p id="2f90" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在，让我们继续学习旋变器链。</p><p id="db3a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">最后，<code class="fe nz oa ob oc b">advanced-server.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="256d" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">分解器链</h2><p id="f282" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在某些情况下，我们希望链接两个数据集。例如，我们可以通过比较我们<code class="fe nz oa ob oc b">Books</code>的<code class="fe nz oa ob oc b">authorId</code>和我们<code class="fe nz oa ob oc b">Authors</code>的<code class="fe nz oa ob oc b">id</code>来链接我们的<code class="fe nz oa ob oc b">Books</code>数据库和<code class="fe nz oa ob oc b">Authors</code>数据库。</p><p id="b4da" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">为了实现这一点，转到<code class="fe nz oa ob oc b">advanced-server.js</code>并找到以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="d680" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在把它改成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="393a" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第6行:我们添加了另一个字段，它的类型是<code class="fe nz oa ob oc b">Author</code>。这将有助于<code class="fe nz oa ob oc b">Book</code>和<code class="fe nz oa ob oc b">Author</code>之间的连接过程。</li><li id="89d2" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第11行:我们向<code class="fe nz oa ob oc b">Author</code>添加了另一个字段，它的类型是<code class="fe nz oa ob oc b">[Book]</code>。这是因为一个作者可以有多本书。</li></ul><p id="3a9b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">运行代码。在查询编辑器中，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/8381baa4be41b02d7aeeae7e0176773e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipcqTavVCYJgb7ICKKZyqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><ul class=""><li id="5ef9" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第4–6行:由于<code class="fe nz oa ob oc b">Author</code>对象类型也有一个<code class="fe nz oa ob oc b">Book</code>对象作为它的字段之一，我们可以进一步对嵌入的<code class="fe nz oa ob oc b">Book</code>对象的字段运行另一个查询。这里我们查询的是书名。</li></ul><p id="87f6" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/7a7f27dc9ffeeb3ca60e23e9a27672c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*MrfxfXtgy2qCvcolUCS3_A.png"/></div></div></figure><p id="ee68" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">正如您可以在我们的响应中看到的，我们在<code class="fe nz oa ob oc b">books</code>数组中获得了<code class="fe nz oa ob oc b">null</code>。这是因为我们还没有为此编写解析函数。</p><p id="9583" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">完成后，我们的第二步是编写一个解析器函数。在<code class="fe nz oa ob oc b">advanced-server.js</code>中，找到下面这段代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/447b9b45f39a4848e22cd0254cb9bc93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94mGUdPIURwzox3BOEkj5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在advanced-server.js中编写的代码</p></figure><p id="f697" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在像这样替换它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="5d0a" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第11行:当客户端查询<code class="fe nz oa ob oc b">Book</code>对象类型中嵌入的<code class="fe nz oa ob oc b">author</code>字段时，我们在这里处理查询。<code class="fe nz oa ob oc b">parent</code>参数也包含附加数据。为了找出<code class="fe nz oa ob oc b">parent</code>的值，我们现在只是注销<code class="fe nz oa ob oc b">parent</code>的值。</li><li id="5a66" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第17行:同样，我们在<code class="fe nz oa ob oc b">Author</code>对象上实现了相同的过程。这一次，我们处理的是当客户端查询<code class="fe nz oa ob oc b">Author</code>对象字段中嵌入的<code class="fe nz oa ob oc b">books</code>字段时的查询。</li></ul><p id="8ed9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">运行代码并执行以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/8381baa4be41b02d7aeeae7e0176773e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipcqTavVCYJgb7ICKKZyqg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="f824" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这与之前的查询相同。但是，这次请查看控制台中的日志。这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/bb279d71ac9f2bb217eada5bc951a0cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*xYg3hesCYZHeLpvN2XkI7g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="dab4" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">如您所见，<code class="fe nz oa ob oc b">parent</code>包含了这个字段的父字段的解析器的返回值。在这种情况下，<code class="fe nz oa ob oc b">books</code>字段的父字段是<code class="fe nz oa ob oc b">authors</code>，这就是为什么我们得到了<code class="fe nz oa ob oc b">authors</code>的返回值。</p><p id="0de7" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在转到查询编辑器，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/2edd871a39369f6b0fc1373d80ce7f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bSBeskTX6QV_cWZajYL7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><ul class=""><li id="b0ff" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第4-5行:这里我们对<code class="fe nz oa ob oc b">author</code>字段执行查询，它是<code class="fe nz oa ob oc b">books</code>对象的子字段。</li></ul><p id="9598" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是您的控制台中的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/51ccee998d0ae707eb97a1b4bd5c5936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jfLFzz7dMiMbmybhs8B9Rw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="7ba3" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">太好了！可以看到，我们又一次得到了父对象的返回值(<code class="fe nz oa ob oc b">books</code>)。</p><p id="58fa" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">要链接这两个数据库，我们可以这样做:</p><ul class=""><li id="2755" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">在<code class="fe nz oa ob oc b">authors</code>数据库中，找到图书<code class="fe nz oa ob oc b">authorId</code>字段和作者<code class="fe nz oa ob oc b">authorId</code>字段匹配的作者。我们将使用数组<code class="fe nz oa ob oc b">find</code>方法来实现这一点。</li><li id="0de1" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">在<code class="fe nz oa ob oc b">books</code>数据库中，提取作者<code class="fe nz oa ob oc b">id</code>字段和图书<code class="fe nz oa ob oc b">authorId</code>字段匹配的图书。我们将使用数组<code class="fe nz oa ob oc b">filter</code>方法来实现这一点。</li></ul><p id="26e8" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">让我们用代码实现它。为此，在<code class="fe nz oa ob oc b">advanced-server.js</code>中找到您的解析器功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="483f" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在把它改成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="62bd" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第12行:调用数组<code class="fe nz oa ob oc b">find</code>方法，获取<code class="fe nz oa ob oc b">id</code>字段与图书<code class="fe nz oa ob oc b">authorID</code>匹配的作者。找到作者后，将返回该作者的信息。</li><li id="f5ef" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第17行:调用数组<code class="fe nz oa ob oc b">filter</code>方法来获取书籍列表，其中的<code class="fe nz oa ob oc b">authorId</code>字段与作者<code class="fe nz oa ob oc b">id</code>字段相匹配。找到图书列表后，将返回一个过滤后的图书数组。</li></ul><p id="1aaa" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在运行代码。在查询编辑器中，执行以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/2edd871a39369f6b0fc1373d80ce7f53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8bSBeskTX6QV_cWZajYL7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="999e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这个查询告诉GraphQL获取图书列表，然后打印出每本书的作者姓名。</p><p id="2eed" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/0af04572ce9bf9c8fc245eae147f6acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNc6mPgWgnp5PhC5P4PCPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="3686" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">瞧啊。我们得到了我们想要的产量。现在让我们来看看作者名单和他们各自的书。在查询编辑器中，运行以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/97b1e32c889f59fd6b51611d8e0c0be5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGkvGDun8GnByS_4vi2cLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="ad4a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这个查询告诉GraphQL打印出作者列表，还打印出每个作者的图书列表。</p><p id="9a4e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是代码的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/238b9190efc1b81e45b646af8943041f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*iFaRVm4bqkEOL4eXjNymVg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="0dd4" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">厉害！我们得到了想要的产量。正如你所看到的，我们终于把两个数据库连接起来了。</p><p id="07eb" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在下一节中，我们将在模式中使用参数。</p><h2 id="67fd" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">模式中的参数</h2><p id="fc33" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在某些情况下，我们只想要单个作者或单本书的信息。在休息时，这些将是终点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/326c3b4183c015c95310cd27be9afc48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhT4sIjCi5mTB4CdiHWn5w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">休息时的样本终点</p></figure><p id="efa2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">目前在我们的GraphQL代码中，我们只能获得书籍或作者的整个数据集。</p><p id="d8fa" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">为了只查询关于单本书或数据的信息，我们需要修改我们的模式，使我们的查询可以接受一个参数<code class="fe nz oa ob oc b">id</code>，这样GraphQL将只返回包含那个特定的<code class="fe nz oa ob oc b">id</code>的数据。</p><p id="e9a0" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">advanced-server.js</code>中，找到您的模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="a3d8" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在把它改成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="fe1a" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第16行:在这里，我们告诉GraphQL，如果客户端针对<code class="fe nz oa ob oc b">bookById</code>执行查询，那么他们还必须指定一个名为<code class="fe nz oa ob oc b">id</code>的参数，该参数应该总是一个整数值(<code class="fe nz oa ob oc b">Int</code>)。该查询返回的值应该总是类型<code class="fe nz oa ob oc b">Book</code>。</li><li id="c3ea" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第17行:这里我们告诉GraphQL，如果客户机对<code class="fe nz oa ob oc b">authorById</code>执行查询，那么它们还必须指定一个名为<code class="fe nz oa ob oc b">id</code>的参数，这个参数应该总是一个整数值(<code class="fe nz oa ob oc b">Int</code>)。该查询返回的值应该总是类型<code class="fe nz oa ob oc b">Book</code>。</li></ul><p id="0b1d" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们还没有为这些查询定义解析器。在<code class="fe nz oa ob oc b">advanced-server.js</code>中，找到您的解析器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="6ff1" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在像这样编辑它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="f036" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第9–11行:如果用户针对<code class="fe nz oa ob oc b">bookById</code>进行查询，我们将处理该查询。Apollo服务器提供了多个参数。在本教程中，我们只关心<code class="fe nz oa ob oc b">args</code>参数。<code class="fe nz oa ob oc b">args</code>参数包含一个对象的值，该对象包含该字段中提供的所有GraphQL参数。目前，我们正在注销<code class="fe nz oa ob oc b">args</code>的值。</li><li id="a191" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第12–14行:我们正在处理对<code class="fe nz oa ob oc b">authorById</code>的查询。这里我们也记录了<code class="fe nz oa ob oc b">args</code>的值。</li></ul><p id="c365" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在运行代码。在查询编辑器中，执行以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/684413f8eaa94ca5d71186c992e4e59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*fNMH_wungnR9PlUGCmaD0A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><ul class=""><li id="20ec" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第2行:这里我们查询<code class="fe nz oa ob oc b">bookById</code>并传入<code class="fe nz oa ob oc b">id</code>的参数。</li><li id="4ae2" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第3行:获取还书的<code class="fe nz oa ob oc b">name</code>字段。</li></ul><p id="7b5a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/9a402f7b1806344082f545d5fe2deaf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*u5uA99SACtS5y_CHjgwdVA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="dc8d" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们没有得到有效的响应，因为我们只注销了<code class="fe nz oa ob oc b">args</code>的值。这应该是您的控制台中的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/699c36f2e5fb73cb735fbf218ad9e6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*FQLdw-ZXY-zk0iHxdET3zQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="3f0e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">太好了！所以我们知道<code class="fe nz oa ob oc b">args</code>是一个包含传递到字段中的参数的对象。</p><p id="ea16" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在在查询编辑器中执行这个查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/dec2cacf1d4927bfea7a8a5b09cad650.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*KeqbMBKm2SASt7qQ10vFMA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="3200" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">控制台中的输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/2dbe51d78dd3052d377c01b371bf5ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*hlNtb5IMOL6jSGCML0gUYA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码的输出</p></figure><p id="4340" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这确保了我们得到一个包含参数和值的对象。现在让我们使用<code class="fe nz oa ob oc b">args</code>参数来获取单本书或作者的数据。在<code class="fe nz oa ob oc b">advanced-server.js</code>中，找到您的解析器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="e68a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在像这样编辑它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="9ef3" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这些变化出现在第10行和第13行。</p><ul class=""><li id="b197" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第10行:调用一个数组<code class="fe nz oa ob oc b">find</code>函数，该函数查找带有与传入查询的<code class="fe nz oa ob oc b">id</code>参数相匹配的<code class="fe nz oa ob oc b">id</code>字段的图书。</li><li id="6bd8" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第13行:与前面相同的操作正在进行。不过，这次我们要找的是作者。</li></ul><p id="c80a" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">完成后，调用以下查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/684413f8eaa94ca5d71186c992e4e59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*fNMH_wungnR9PlUGCmaD0A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="29c7" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/0344d0970fcaa095f40a06ae3f39f489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*XjAgtT-DplidIlcuLdAAfA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="d41b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">太好了！现在执行这个查询，查找带有<code class="fe nz oa ob oc b">3</code>的<code class="fe nz oa ob oc b">id</code>的作者:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/dec2cacf1d4927bfea7a8a5b09cad650.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*KeqbMBKm2SASt7qQ10vFMA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="2785" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi px"><img src="../Images/9c43c62157d2bfc73059dd2ce501fdc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*H7HJujz8vZtp1eXn_9HxHQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="9cfe" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">太好了！这意味着我们的代码有效。</p><p id="81cf" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">回想一下，在我们的模式中，我们也说过<code class="fe nz oa ob oc b">Book</code>有一个字段<code class="fe nz oa ob oc b">Author</code>，而<code class="fe nz oa ob oc b">Author</code>也有自己的子字段。这意味着我们可以执行下面的查询来查找由<code class="fe nz oa ob oc b">id</code>甚至链接的作者写的书:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/9073995c4c535da5fd1ad501be96abf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*a2BDEEETAy21oIGkgyrh2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="6ec8" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi py"><img src="../Images/a8546245d03e5ec517ae467565bb7614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*w2GihmqKLAr4PaAIqXSeeg.png"/></div></figure><p id="28a5" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在一切都联系起来了，这样做真的很简单。由此可见GraphQL的能力有多强。</p><p id="3343" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">或者，我们也可以运行这个查询，通过<code class="fe nz oa ob oc b">id</code>获取作者并获取他们的书籍:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/be80f3f6c352505633a78a0216ff40b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*NGLUUVE69Bcl9iY9oUyLhg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="81b2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/21af23779f3dd619ee622b8d08e12953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*GBiMkMmtqsZ2YQ24pnTTJw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="fd15" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">维奥拉。我们的代码有效。</p><p id="48be" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在下一节中，我们将了解突变。</p><p id="3b62" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">最后，<code class="fe nz oa ob oc b">advanced-server.js</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="3aaa" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">编辑有突变的数据</h2><p id="2307" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">假设您想要编辑一本书的信息或更改作者的姓名。在休息时，您可以像这样执行一个<code class="fe nz oa ob oc b">POST</code>或<code class="fe nz oa ob oc b">PUT</code>请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qa"><img src="../Images/59dd57876e6ab1ce05c7862535215f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J0w9UGxjPzYMHQmbhuIx8g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例POST和PUT请求处于静止状态</p></figure><p id="9b74" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们可以在GraphQL中使用叫做<em class="ot">突变</em>的东西来完成同样的过程。在GraphQL中，你没有<code class="fe nz oa ob oc b">POST</code>或<code class="fe nz oa ob oc b">PUT</code>数据，而是用<em class="ot">对其进行变异</em>。</p><p id="36ce" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">作为第一步，我们必须在模式中定义一个突变。在<code class="fe nz oa ob oc b">advanced-server.js</code>中，找到您的模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="5f94" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">将<code class="fe nz oa ob oc b">Mutation</code>类型添加到模式定义中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="5816" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这些变化出现在第20行和第2行。</p><ul class=""><li id="53c1" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第20行:这意味着客户端现在可以执行<code class="fe nz oa ob oc b">addBook</code>的变异。该函数接受两个参数:一个是<code class="fe nz oa ob oc b">String</code>数据的<code class="fe nz oa ob oc b">name</code>字段，一个是<code class="fe nz oa ob oc b">Int</code>数据的<code class="fe nz oa ob oc b">authorId</code>。该函数返回一个类型为<code class="fe nz oa ob oc b">Book</code>的响应。</li><li id="4a9e" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第21行:这一行代码意味着用户现在可以执行一个<code class="fe nz oa ob oc b">addAuthor</code>突变。它接受一个名为<code class="fe nz oa ob oc b">name</code>的参数，该参数属于<code class="fe nz oa ob oc b">String</code>类型。这个突变将会给我们一个类型为<code class="fe nz oa ob oc b">Author</code>的结果。</li></ul><p id="6af3" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">剩下的工作就是为这些突变定义一个解析器。</p><p id="a489" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">在<code class="fe nz oa ob oc b">advanced-server.js</code>中找到你的突变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><p id="84a7" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在像这样编辑它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="64cb" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第27行:这里，当客户端执行变异时，我们处理解析器。位于这个<code class="fe nz oa ob oc b">Mutation</code>对象中的所有函数将处理它们在模式中定义的相应突变。</li><li id="282c" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第28–33行:当用户执行<code class="fe nz oa ob oc b">addBook</code>突变时，这个函数将被调用。<code class="fe nz oa ob oc b">name</code>和<code class="fe nz oa ob oc b">authorId</code>字段将由<code class="fe nz oa ob oc b">args</code>参数提供的自变量赋值。稍后，这个新的<code class="fe nz oa ob oc b">book</code>对象将被推送到<code class="fe nz oa ob oc b">books</code>数据库。最后会返回这个结果。</li><li id="8439" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第34-41行:当客户端执行<code class="fe nz oa ob oc b">addAuthor</code>突变时，将<code class="fe nz oa ob oc b">name</code>字段分配给客户端参数提供的字段。然后，新的<code class="fe nz oa ob oc b">author</code>对象将被推送到<code class="fe nz oa ob oc b">authors</code>数据集。最后，这个<code class="fe nz oa ob oc b">author</code>对象将被返回。</li></ul><p id="b8af" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们现在完成了。让我们来测试一下。转到Apollo Server中的Docs工具栏，您会发现出现了一个新标题，名为<code class="fe nz oa ob oc b">Mutations</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/52675b44488c27ee9c4e68e6fa6075b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*fPJLOXw1WSPOTnENkfd0EA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Apollo服务器中的文档菜单</p></figure><p id="8843" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在，在查询编辑器中键入以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/d3aa40c82f3b1c3fb81174f14181c4dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BURlhfxzAqueDEfj20gw7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><ul class=""><li id="9a6e" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated">第1行:告诉GraphQL我们要发出一个突变请求。</li><li id="26da" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第2行:用<code class="fe nz oa ob oc b">name</code>和<code class="fe nz oa ob oc b">authorId</code>需求调用<code class="fe nz oa ob oc b">addBook</code>函数。</li><li id="b402" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated">第3-5行:获取新的<code class="fe nz oa ob oc b">Book</code>对象的所有字段。</li></ul><p id="49fc" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/e76552f9ca9a03f00239a96ea41fea80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*9tp8N6dCbzbCAOoOR5Is-Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="ea75" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">太好了！我们的代码有效。现在让我们查询数据集中所有可用的书籍:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qe"><img src="../Images/580cf62858dcc4685d75e6e76bca773a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*iJjpWeNe1_ItHGKifLcTVQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="549f" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">如您所见，该书已成功添加。因为所有这些<code class="fe nz oa ob oc b">Book</code>对象都链接到它们的<code class="fe nz oa ob oc b">Author</code>对象，所以我们甚至可以执行一个变异，并且还可以接收其相应的作者数据，就像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/84213a51b60aa2332611dac1d15845dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tfl6dWgLY7Q8n71foypFrQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="543e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qf"><img src="../Images/0a26b179b4d92ad50ac01dd37d11d4b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*h-SA5HY-h0G67jzCh_lqaw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="e9f2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">现在让我们执行一个<code class="fe nz oa ob oc b">addAuthor</code>突变。转到查询编辑器，编写以下代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/3d0d60898788f96563261eab23c0780c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KopFy3nSf1_Ug469nK7VwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="1d27" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">运行该查询将产生以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qg"><img src="../Images/a328e433676d7553f98623b16ea828ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*HpsuiUYo01pgrt4eDJohZQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="14c2" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">我们得到回应了！现在，让我们使用以下查询来确认它是否已被添加到我们的数据库中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/57e51d044e80344410efcf2b10b8cd24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZWICFXhxrmjVNwFbMM8fw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">要在查询编辑器中编写的查询</p></figure><p id="9da3" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这将是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi qd"><img src="../Images/8be97929cc04b797a692ebcb410e87e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*YlZ6xGjHUOmhaVCWAq94vg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询的输出</p></figure><p id="e87b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这太棒了！我们的代码工作，我们得到了我们想要的输出。</p><p id="6264" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">然而，使用GraphQL有一些规则可以确保您的应用程序完美运行。在下一节中，我们将讨论这些规则。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="fc03" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">使用GraphQL时需要记住的事项</h1><h2 id="bf06" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">数据集的字段应与架构的字段相匹配</h2><p id="89cb" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">例如，如果您对<code class="fe nz oa ob oc b">Author</code>的模式定义如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/e33d8ae99c06c7c0cac2b03cb1ddde2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-bLtOataqtmcYpTsu9kiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例模式定义</p></figure><p id="6cd0" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">你的数据集看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/dfd756d49dcdc47c79a23d7fe761cf6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTAUlyGG_ZGlvfmOWoIe0w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样本数据集</p></figure><p id="2c2e" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">那么您的代码应该不会产生错误。</p><p id="4899" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">另一方面，如果您的模式如下所示，则它是不正确的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qc"><img src="../Images/e4d54b941790b11f20c6efe2817d80f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dgEVp6Yv49MVjkoRbXGBg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误的模式</p></figure><p id="d5f9" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">请注意，其中一个字段是<code class="fe nz oa ob oc b">iD</code>。GraphQL的语言区分大小写。如果是<code class="fe nz oa ob oc b">id</code>，那么应该没有问题。</p><p id="ca3b" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">总之，<strong class="ma iu">模式和数据集的所有字段都应该匹配</strong>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="1757" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">代码和其他资源</h1><h2 id="d307" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">最终代码</h2><ul class=""><li id="ad9f" class="mu mv it ma b mb mc me mf mh qh ml qi mp qj mt nb nc nd ne bi translated"><code class="fe nz oa ob oc b">basic-server.js</code>应该是这样的:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><ul class=""><li id="9220" class="mu mv it ma b mb mw me mx mh my ml mz mp na mt nb nc nd ne bi translated"><code class="fe nz oa ob oc b">advanced-server.js</code>应该是这样的:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h2 id="8165" class="nn lh it bd li no np dn lm nq nr dp lq mh ns nt ls ml nu nv lu mp nw nx lw ny bi translated">其他阅读资源</h2><ul class=""><li id="6b71" class="mu mv it ma b mb mc me mf mh qh ml qi mp qj mt nb nc nd ne bi translated"><a class="ae ky" href="https://www.apollographql.com/docs/tutorial/introduction/" rel="noopener ugc nofollow" target="_blank">阿波罗GraphQL简介</a>(涵盖基础知识)</li><li id="739d" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated"><a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/" rel="noopener ugc nofollow" target="_blank">阿波罗服务器GraphQL简介</a></li><li id="c7e2" class="mu mv it ma b mb nf me ng mh nh ml ni mp nj mt nb nc nd ne bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=ZQL7tL2S0oQ" rel="noopener ugc nofollow" target="_blank">40分钟学会graph QL:Web Dev简化版</a></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="effb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="d26a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">看看GraphQL是多么易用和强大，我们可以承认，GraphQL无疑将成为通过外部数据库或API获取数据的事实上的标准。虽然还是新技术，但它已经巩固了作为一项极其强大的技术的地位。</p><p id="1d0f" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">这个教程真的很长。如果您遇到任何问题，建议您解构代码并广泛研究GraphQL及其与Node.js的集成。不要放弃！</p><p id="df07" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">非常感谢您的阅读！</p><p id="28e0" class="pw-post-body-paragraph ly lz it ma b mb mw ju md me mx jx mg mh nk mj mk ml nl mn mo mp nm mr ms mt im bi translated">下一篇:<a class="ae ky" href="https://medium.com/better-programming/create-amazing-animations-in-react-using-framer-motion-34c803f60c6f" rel="noopener">在React中创建动画与帧运动</a> <br/>上一篇:<a class="ae ky" href="https://medium.com/better-programming/react-routers-explained-ff89153a6405" rel="noopener"> React路由器，已解释</a></p></div></div>    
</body>
</html>