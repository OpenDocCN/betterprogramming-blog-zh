<html>
<head>
<title>How to Implement HyperLog With Kotlin in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Android中用Kotlin实现HyperLog</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-implement-hyperlog-with-kotlin-in-android-21f34a950c83?source=collection_archive---------7-----------------------#2020-07-07">https://betterprogramming.pub/how-to-implement-hyperlog-with-kotlin-in-android-21f34a950c83?source=collection_archive---------7-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e04e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于如何使用Kotlin实现HyperTrack/HyperLog并将数据记录到远程服务器的详细指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/efc0dc87a958bbe7d6b621220affa64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3uJCSQm_X5U4YW1T"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@euwars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法扎德·纳兹菲</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="6d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开发人员需要在代码的任何部分调试问题时，记录是必要的。在Android中，我们有<a class="ae ky" href="https://developer.android.com/reference/android/util/Log" rel="noopener ugc nofollow" target="_blank">日志</a>，这在查找代码中的错误时非常有用。如果你想远程查看或保存日志到你的服务器，那么<a class="ae ky" href="https://github.com/hypertrack/hyperlog-android" rel="noopener ugc nofollow" target="_blank">HyperLog</a><strong class="lb iu"><em class="lv"/></strong>是一个流行的选项，因为它是建立在Log之上的。</p><p id="41c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，有许多博客文章可以帮助你理解什么是HyperLog，以及它是如何使用Java工作的(比如<a class="ae ky" href="https://android.jlelse.eu/android-remote-logger-library-for-debugging-343443bd38b7" rel="noopener ugc nofollow" target="_blank">这个</a>)。今天的文章是使用Kotlin实现它的详细指南，并探索了它的特性，所以如果您正在努力理解它或者将Java代码转换成Kotlin，那么这应该会把事情搞清楚。</p><p id="e14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦将库添加到应用程序的<em class="lv"/><code class="fe lw lx ly lz b">build.gradle</code>文件的依赖项中，您就可以开始记录日志消息，并通过以下代码片段将它们推送到远程服务器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ma mb l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用Kotlin实现HyperLog的示例代码片段</p></figure><p id="2540" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段来自一个应用程序的启动器活动，HyperLog已在该应用程序中初始化。日志级别设置为显示将进一步执行哪种类型的日志记录。在使用标签和消息指定日志类型之后，URL已经被设置为验证日志向远程服务器的推送(在本例中是<a class="ae ky" href="https://requestbin.com/" rel="noopener ugc nofollow" target="_blank"> RequestBin </a>)。在通过文件或纯文本推送日志之后，回调方法success和error完成任务。</p><p id="e324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是Kotlin的HyperLog图书馆的详细指南。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="029d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">初始化</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="3f03" class="nf mk it lz b gy ng nh l ni nj">HyperLog.initialize(context: Context, expiryTimeInSecond: Int, logFormat: LogFormat)</span></pre><p id="c07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将初始化应用程序中的超级日志功能。默认情况下，七天或七天以上的日志会被自动删除。因此，在这段时间内或立即将它们推送到远程服务器。上下文是该方法的强制参数。其他的可以在初始化的时候删除。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d102" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">记录结构</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="7b6a" class="nf mk it lz b gy ng nh l ni nj">HyperLog.setLogFormat(logFormat: LogFormat)</span></pre><p id="af85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这定义了自定义日志消息格式。自定义日志消息非常有用。开发人员可以选择他们在日志中需要的细节以及日志的结构。</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="7975" class="nf mk it lz b gy ng nh l ni nj">HyperLog.setLogLevel(logLevel: Int)</span></pre><p id="00ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="http://parseplatform.org/Parse-SDK-Android/api/com/parse/PLog.html" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="nk nl nm"><p id="9ab2" class="kz la lv lb b lc ld ju le lf lg jx lh nn lj lk ll no ln lo lp np lr ls lt lu im bi translated">"设置要显示的日志记录级别，其中每个级别包括它下面的所有级别。默认级别是LOG_LEVEL_NONE。请确保在部署您的应用程序之前将其设置为<code class="fe lw lx ly lz b">Log.ERROR</code>或<code class="fe lw lx ly lz b">LOG_LEVEL_NONE</code>，以确保不会记录敏感信息。”</p></blockquote><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="f15c" class="nf mk it lz b gy ng nh l ni nj">HyperLog.d(tag: String, message: String)</span></pre><p id="18ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像其他日志级别一样，如果使用了debug，那么<code class="fe lw lx ly lz b">d</code>就是用来调试的。同样，根据<code class="fe lw lx ly lz b">Log.ASSERT</code>、<code class="fe lw lx ly lz b">Log.VERBOSE</code>、<code class="fe lw lx ly lz b">Log.DEBUG</code>、<code class="fe lw lx ly lz b">Log.INFO</code>、<code class="fe lw lx ly lz b">Log.WARN</code>、<code class="fe lw lx ly lz b">Log.ERROR</code>中指定的日志级别，分别使用<code class="fe lw lx ly lz b">a</code>、<code class="fe lw lx ly lz b">v</code>、<code class="fe lw lx ly lz b">d</code>、<code class="fe lw lx ly lz b">i</code>、<code class="fe lw lx ly lz b">w</code>、<code class="fe lw lx ly lz b">e</code>和异常。异常也使用了throwable。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d2fe" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">设置和获取URL</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="8f24" class="nf mk it lz b gy ng nh l ni nj">HyperLog.setUrl(url: String)</span></pre><p id="22bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法设置需要将日志推送到的有效URL端点。如果它是空的或null，它抛出一个非法的参数异常。</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="16b5" class="nf mk it lz b gy ng nh l ni nj">HyperLog.getUrl()</span></pre><p id="3265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当通过<code class="fe lw lx ly lz b">HyperLog.setUrl()</code> <strong class="lb iu">、</strong>设置URL时，它可用于整个应用程序。如果应用程序的其他部分需要这个URL，那么<code class="fe lw lx ly lz b">HyperLog.getUrl()</code>从库中保存的变量中获取这个URL。此方法以字符串形式返回。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ed3c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">获取到期时间</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="2fd8" class="nf mk it lz b gy ng nh l ni nj">HyperLog.getExpiryTime()</span></pre><p id="8dd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果为日志设置了任何过期时间，此方法将返回以秒为单位的时间长度。否则，它返回默认到期时间(即604800)。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="5e88" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">获取设备日志</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="ac5b" class="nf mk it lz b gy ng nh l ni nj">HyperLog.getDeviceLogs(deleteLogs: Boolean, batchNumber: Int)</span></pre><p id="e7ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法根据批号获取设备中存储的日志。如果另有规定，默认批号为1。此外，如果<code class="fe lw lx ly lz b">deleteLogs</code>设置为<code class="fe lw lx ly lz b">true</code>，则在获取后删除日志。因为默认设置为<code class="fe lw lx ly lz b">true</code>，所以在不需要删除日志的情况下，必须设置<code class="fe lw lx ly lz b">false</code>。</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="39d8" class="nf mk it lz b gy ng nh l ni nj">HyperLog.getDeviceLogsAsStringList(deleteLogs: Boolean, batchNumber: Int)</span></pre><p id="56a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法以字符串列表的形式获取存储的日志，而不是如上所述的设备日志模型(在<code class="fe lw lx ly lz b">getDeviceLogs</code>方法中)。此方法的其余功能与前面的方法相同。</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="2539" class="nf mk it lz b gy ng nh l ni nj">HyperLog.getDeviceLogsInFile(context: Context, fileName: String, deleteLogs: Boolean)</span></pre><p id="ddb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法使用提供的文件名将存储的日志作为文件对象获取，或者根据自己的时间戳创建文件名。删除日志的方式与上面的其他两种方法相同。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="7e01" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">日志可用性</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="98dd" class="nf mk it lz b gy ng nh l ni nj">HyperLog.hasPendingDeviceLogs()</span></pre><p id="efd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果设备中有任何可用的日志，该方法将返回<code class="fe lw lx ly lz b">true</code>,以防有任何挂起的日志可用。否则返回<code class="fe lw lx ly lz b">false</code>。</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="8dfd" class="nf mk it lz b gy ng nh l ni nj">HyperLog.getDeviceLogsCount()</span></pre><p id="568c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法返回存储的设备日志的数量(如果有)。否则，它返回<code class="fe lw lx ly lz b">0</code>。</p><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="02d7" class="nf mk it lz b gy ng nh l ni nj">HyperLog.getDeviceLogBatchCount()</span></pre><p id="d283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法返回存储的设备日志批次的数量(如果有)。否则返回<code class="fe lw lx ly lz b">0</code>。每批包含5，000个设备日志。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3b09" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">将日志推送到服务器</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="e764" class="nf mk it lz b gy ng nh l ni nj">HyperLog.pushLogs(context: Context, filename:String, additionalHeaders: HashMap&lt;String, String&gt;, compress: Boolean, hlCallback: HLCallback) </span></pre><p id="d71f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe lw lx ly lz b">compress</code>为<code class="fe lw lx ly lz b">true</code>，该方法将日志以文本文件或gzip压缩文件的形式从设备推送到服务器。否则也可以推送简单的文字，保持<code class="fe lw lx ly lz b">false</code>。推送日志后，它们会自动从设备中删除。HyperLog的一个好处是，如果日志计数大于设备的日志查询限制，那么它会被批量推送。此外，如果没有包含文件，就不需要在方法中包含文件名或额外的头，但是它们的存在使方法变得完美。该方法提供了<code class="fe lw lx ly lz b">onSuccess</code>和<code class="fe lw lx ly lz b">onError callback</code>函数，可以根据需要处理成功和错误。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3b2a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">删除日志</h1><pre class="kj kk kl km gt nb lz nc nd aw ne bi"><span id="a531" class="nf mk it lz b gy ng nh l ni nj">HyperLog.deleteLogs()</span></pre><p id="822d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法有助于从设备中删除所有日志。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="ca3a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="9c66" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">我希望这能让你对这个库提供的功能有更多的了解。</p><p id="4ffa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。伐木快乐！</p></div></div>    
</body>
</html>