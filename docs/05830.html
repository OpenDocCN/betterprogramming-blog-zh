<html>
<head>
<title>Is the _id Property in MongoDB 100% Unique?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB中的_id属性是100%唯一的吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-the-id-property-in-mongodb-100-unique-f1eaa19522ba?source=collection_archive---------8-----------------------#2020-08-10">https://betterprogramming.pub/is-the-id-property-in-mongodb-100-unique-f1eaa19522ba?source=collection_archive---------8-----------------------#2020-08-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a3d1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">MongoDB对象id背后的科学</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/15e830f8814814e94b2621d7416dd2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wL_hwThGW7sPItH3xq0G3w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@maumascaro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">毛里西奥·马斯卡罗</a>从<a class="ae ky" href="https://www.pexels.com/photo/person-holding-magnifying-glass-712786/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</p></figure><p id="bb18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MongoDB 是一个NoSQL数据库，处理集合和文档。在MongoDB上创建的每个文档都有一个惟一的对象ID属性。因此，当创建一个没有输入ID的文档时，该文档将使用自动生成的ID来创建。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="92c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">谁生成ID？</h1><p id="bd02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当填写文档的属性时，我们不一定需要输入对象ID。但是当我们在创建文档后引用MongoDB时，它会有一个如下所示的对象ID:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6336" class="ne md it na b gy nf ng l nh ni">{ <br/>   “_id”: “5f1819229fdf8a0c7c2d8c36”<br/>}</span></pre><p id="14e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得我们在MongoDB中创建文档变得更加容易，并节省了我们大量的时间。MongoDB中文档中的对象ID是由MongoDB驱动程序创建的，它与MongoDB对话。因此，这带来了很多好处:</p><ul class=""><li id="37c0" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">您不需要等待MongoDB创建新的惟一标识符。</li><li id="7052" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">MongoDB的应用程序是高度可伸缩的。</li><li id="1547" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">您可以创建几个MongoDB实例。</li><li id="8c41" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">不需要与中心位置交谈来获得唯一的标识符。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="83a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对象ID的属性</h1><p id="ee99" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一个对象ID有24个字符长，其中两个字符占用一个字节，因此总共包含12个字节。这是12个字节的对象ID告诉我们的内容。</p><h2 id="b1d9" class="ne md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">时间戳</h2><p id="a1fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对象ID的前四个字节表示文档创建时的时间戳。我们不需要在文档中创建一个单独的属性，比如<code class="fe oi oj ok na b">created-at</code>，这样可以节省时间并优化代码行。</p><p id="29c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于时间戳对对象ID的贡献，我们可以通过专门引用ID来获得文档的创建时间。因此，在查询数据时，我们不需要不同的方法来根据时间戳对文档进行排序。</p><p id="8cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下命令获取对象的时间戳:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="de7b" class="ne md it na b gy nf ng l nh ni">const mongoose = require('mongoose');</span><span id="8342" class="ne md it na b gy ol ng l nh ni">// Create object Id on memory<br/>const id = new mongoose.Types.ObjectId();</span><span id="4e51" class="ne md it na b gy ol ng l nh ni">// Get timestamp<br/>console.log(id.getTimestamp());</span></pre><h2 id="983e" class="ne md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">机器标识符</h2><p id="66ce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来的三个字节代表机器标识符(即创建文档的机器)。假设在不同的机器上同时创建了两个文档。这三个字节是不同的，增加了对象ID的唯一性。</p><h2 id="b6ce" class="ne md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">进程标识符</h2><p id="446e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来的两个字节表示进程标识符(即在其上创建文档的机器中的进程)。假设在同一台机器上用不同的过程同时创建了两个文档。这两个字节是不同的，增加了对象ID的唯一性。</p><h2 id="7e9b" class="ne md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">计数器</h2><p id="65d1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后三个字节代表一个计数器。此计数器是一个自动递增的数字，类似于SQL和NoSQL数据库中的其他计数器变量，使对象ID唯一(在SQL中，这可能会妨碍可伸缩性)。假设两个文档同时在同一台机器上以相同的流程创建。计数器字节将是不同的，这有助于对象ID的唯一性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dd87" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">对象ID问题</h1><p id="4fa1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在MongoDB中，对象ID中的计数器出现了一个问题，可能会限制它的唯一性。</p><p id="3137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要计数器不溢出，对象ID就是唯一的！</p><p id="4889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="om">计数器溢出</em>问题是当计数器达到其最大容量时，导致文档具有相同的对象ID。因此，对象ID几乎是唯一的，但不是100%唯一的！</p><p id="2865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原因如下:计数器被分配了三个字节。这意味着它有能力代表多达1600万个<strong class="lb iu"> <em class="om"> </em> </strong>数字。如果在同一时间，在同一台机器上，用同一过程生成那么多文档，那么两个文档可以共享同一个对象ID。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5243" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使用猫鼬</h1><p id="d20d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当使用Node.js和Express.js构建应用程序时，我们使用<a class="ae ky" href="https://mongoosejs.com/" rel="noopener ugc nofollow" target="_blank">mongose</a>。Mongoose是MongoDB驱动程序的抽象。因此，在创建文档时，mongose<em class="om">与MongoDB驱动程序对话</em>来创建一个新的对象ID。</p><h2 id="0d7b" class="ne md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">创建对象ID</h2><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e232" class="ne md it na b gy nf ng l nh ni">// create an object id on memory - Not on DB!</span><span id="13a6" class="ne md it na b gy ol ng l nh ni">const mongoose = require('mongoose');</span><span id="3ce1" class="ne md it na b gy ol ng l nh ni">const id = mongoose.Types.ObjectId();<br/>console.log(id);</span><span id="f987" class="ne md it na b gy ol ng l nh ni">// output -&gt; 5f1819229fdf8a0c7c2d8c36</span></pre><h2 id="c2de" class="ne md it bd me nx ny dn mi nz oa dp mm li ob oc mo lm od oe mq lq of og ms oh bi translated">正在验证对象ID</h2><p id="61f7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用mongoose，您还可以使用<code class="fe oi oj ok na b">isValid</code>属性静态验证对象ID:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="01dd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="6939" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">MongoDB对象ID是惟一的，除非达到了特定的场景(如上所述)。因此，作为软件开发人员，我们应该考虑系统的<em class="om">大小</em>和<em class="om">复杂度</em>，在自动生成的ID和自定义对象ID之间进行权衡。</p><p id="d894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法完全由你决定。关于MongoDB对象ID的更多信息，可以参考<a class="ae ky" href="https://docs.mongodb.com/manual/indexes/#default-id-index" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>和<a class="ae ky" href="https://mongoosejs.com/docs/guide.html#_id" rel="noopener ugc nofollow" target="_blank">mongose</a>的官方文档。</p><p id="6e90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个故事让您了解了MongoDB中对象ID的唯一性和可靠性。享受学习和编码的乐趣！</p></div></div>    
</body>
</html>