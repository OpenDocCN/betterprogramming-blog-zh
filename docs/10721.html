<html>
<head>
<title>Hasura, GraphQL, and Auto Code Generation With Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Hasura、GraphQL和带Angular的自动代码生成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/hasura-graphql-and-auto-code-generation-with-angular-2e6321e4d532?source=collection_archive---------16-----------------------#2022-01-24">https://betterprogramming.pub/hasura-graphql-and-auto-code-generation-with-angular-2e6321e4d532?source=collection_archive---------16-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为GraphQL客户端设置代码生成</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b10e7c6fdd8fbe34f6694a864bff7dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FYuSMILt2VY_UuIq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@writecodenow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Boitumelo Phetla </a>拍摄的照片</p></figure><p id="0a2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我目前的长期项目中，我面临的问题是快速建立一个GraphQL网关，以便与数据库和后端进行有效的通信。</p><p id="c077" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一些研究，我遇到了<a class="ae ky" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"> Hasura </a>，这是一个网关服务，它能够为您的SQL数据库和其他受支持的端点自动生成一个包罗万象的GraphQL模式。不仅如此，它还具有许多其他方便的附加功能，如授权、webhooks、事件，甚至CI/CD集成，以便将对数据库的更改迁移到生产环境中。最好自己去看，因为他们也有一个很棒的网站。</p><p id="8fb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉用<a class="ae ky" href="https://www.apollographql.com/docs/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>设置GraphQL服务器，你可能会知道，这需要相当多的工作。你必须手工编写一个<a class="ae ky" href="https://www.apollographql.com/docs/tutorial/schema/" rel="noopener ugc nofollow" target="_blank">模式</a>并自己定义你的<a class="ae ky" href="https://www.apollographql.com/docs/tutorial/resolvers/" rel="noopener ugc nofollow" target="_blank">查询、变异和订阅</a>。现在，如果这些都可以自动完成，你会怎么说？只需在SQL数据库中设置一些表，所有可能的查询、变更和订阅都由Hasura自动生成。太棒了，对吧？</p><p id="b4d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更进一步，我们想定义一个客户机，它可以调用和订阅所有那些自动生成的GraphQL查询。不要用Apollo手动设置<a class="ae ky" href="https://apollo-angular.com/docs/" rel="noopener ugc nofollow" target="_blank">客户端</a>，在代码中没有静态类型和用于查询的大<a class="ae ky" href="https://en.wikipedia.org/wiki/Magic_string" rel="noopener ugc nofollow" target="_blank">神奇字符串</a>，让我们自动生成一切。您只需在<em class="lv">中定义您的查询。graphql </em>文档，您就可以开始了。</p><p id="47d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们建立一个展示来更深入地探讨这个话题。</p><h1 id="d1ae" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">概观</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/14f9a1e02f65951f56f4fbf70291f808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CsOadhELW-waa8k2iD0cVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">架构概述</p></figure><p id="0315" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本次展示中，我们将搭建一个服务器-客户端应用程序，其中Angular作为我们的前端，Hasura+PostgreSQL作为我们的后端。在Angular中，我们将受益于Apollo客户机的自动代码生成，而Hasura将负责将SQL“翻译”成GraphQL。</p><p id="b49d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住:自动代码生成并不特定于Hasura。您可以对任何兼容Apollo的GraphQL后端使用这种方法。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="bdb0" class="lw lx it bd ly lz mw mb mc md mx mf mg jz my ka mi kc mz kd mk kf na kg mm mn bi translated">用Postgres设置Hasura</h1><p id="0456" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这个展示中，我们将创建一个PostgreSQL数据库和一个Hasura云实例，全部免费。</p><ol class=""><li id="0aaf" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">登录<a class="ae ky" href="https://cloud.hasura.io/" rel="noopener ugc nofollow" target="_blank">哈苏拉云</a>并创建一个自由层项目。这将创建网关，我们稍后将连接到该网关。</li><li id="d230" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">点击<strong class="lb iu">发射控制台</strong>切换到哈苏拉控制台。在这里，您可以编辑整个数据库，设置动作、事件，还可以用GraphQL语言生成所有的查询、变异和订阅。</li><li id="4c9b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在<strong class="lb iu">数据→创建Heroku数据库</strong>你可以免费创建并连接一个PostgreSQL数据库。或者，您也可以连接到现有的数据库。</li></ol><h1 id="e77c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">建立数据结构</h1><p id="d77b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当数据库建立时。让我们创建一个样本数据结构。对于这个例子，我选择了一个简单的聊天应用程序结构。单击您的数据库(<strong class="lb iu">default</strong>default)并单击<strong class="lb iu"> public </strong>模式。在右侧点击<strong class="lb iu">创建表格</strong>。</p><p id="6d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将设置两个表:</p><ul class=""><li id="2666" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">包含唯一的<strong class="lb iu"> id </strong>和<strong class="lb iu">名称</strong>的<em class="lv">用户</em>表:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/f156768700a2caa4d5b2278150492554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9bSqLxrSImrElTINXgZ2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加表<strong class="bd nw">用户</strong></p></figure><p id="6450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">顺便说一下，我强烈推荐使用UUID作为您的标识符/主键，因为客户端可以安全地生成唯一的UUID。因此，您不需要额外调用服务器，只需要为每个对象安排一个新的id，而不是用一个自动增加的数字作为主键。</em></p><ul class=""><li id="131f" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">以及一个<em class="lv">消息</em>表，包含<strong class="lb iu">发送方</strong>和<strong class="lb iu">接收方</strong>的id、<strong class="lb iu">消息、</strong>和<strong class="lb iu">时间戳</strong>:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/23d444a7ab269274021dd850402637da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RlDkYtRxMd7_-dWYmfxfg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加表<strong class="bd nw">消息</strong></p></figure><p id="f3ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们还将设置外键关系，这将使我们能够使用GraphQL进行嵌套查询(例如，获取来自特定发件人的所有消息)。</p><p id="1bb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">我强烈推荐所有的表和字段使用一致的命名方案，因为自动代码生成器将使用规则从它们中生成类名和属性名。这里最好的做法是</em><strong class="lb iu"><em class="lv"/></strong><code class="fe ny nz oa ob b">snake_case</code><em class="lv">。</em></p><p id="e82a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">添加完表后，我们将设置它们之间的关系。单击表message → Relationships <strong class="lb iu"> </strong>，您将看到基于上述外键的建议关系:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/82822d85e9a4f4621e935746adfa3993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u4BsDtpZkcHuQ_YN7Xcy9g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为<strong class="bd nw">消息</strong>设置关系</p></figure><p id="a929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象关系是一对一的关系，这意味着每条消息只有一个发件人和一个收件人。不要忘记将建议的姓名分别更改为收件人和发件人<strong class="lb iu"> </strong>。</p><p id="4a3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于用户表，我们建议使用数组关系，这意味着每个用户可能有多个发送的消息和多个接收的消息。添加为<code class="fe ny nz oa ob b">received_messages</code>和<code class="fe ny nz oa ob b">sent_messages</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/82ebe8d5a1f8ec8030a95606e712611a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*UzbEoCJ0vFM5EMLR57MPUw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为<strong class="bd nw">用户</strong>设置关系</p></figure><p id="da27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完全建立了表格，让我们添加一些测试数据。</p><h1 id="fae3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">手动添加数据</h1><p id="f643" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">点击用户→插入行，添加用户简和鸢。如果您在用户表的设置中选择了<code class="fe ny nz oa ob b">gen_random_uuid()</code>，您可以将id字段留空。否则使用UUID生成器在线，生成一个自定义的UUID。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/c32c43d1d6f35aaff8f38a4ba2aa4287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQxRGNViqbDDpOnCMQpR5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加新的<strong class="bd nw">用户</strong></p></figure><p id="2331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，单击<strong class="lb iu">浏览行</strong>检查您的数据并查看新生成的UUIDs:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/d9ffb698bad6055d077df1fbfc4ebae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhvHzv7NFuqLCznq3y3D9Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些示例用户</p></figure><p id="b3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在向消息表中添加一些示例消息。将您的用户的UUIDs用于<code class="fe ny nz oa ob b">sender_id</code>和<code class="fe ny nz oa ob b">recipient_id</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c6e317e363c7bf7778285e476ddb70d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRg41pT3NcR4ki0NWuKFag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些示例消息</p></figure><p id="21d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在我们已经设置了测试数据，可以继续检查一些查询结果。</p><h1 id="f367" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">查询、变异和订阅</h1><p id="502b" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">此时，Hasura已经创建了您可以在后台想象的所有查询、突变和订阅的模式。您可以通过选择上面的<strong class="lb iu"> API </strong>选项卡来检查它们。</p><p id="dbc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在左边，您将看到Explorer，在这里您可以通过选择您想要查询的复选框来组装您的查询、突变和订阅。通过选中以下框继续操作:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/c20f37140aca34f86fb7d3cb62729671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSqtxdN1_VHaDLgJfH7Byg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图形资源管理器示例</p></figure><p id="47a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在中间窗口中，您将看到我们刚刚一起点击的查询的GraphQL代码，在右侧，在您按下<strong class="lb iu">播放</strong>按钮后，您将看到该查询的结果。</p><p id="8c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们请求:</p><ul class=""><li id="fad8" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">每个用户</li><li id="f1f4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">他们的身份证和姓名</li><li id="8b0d" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">每条发送的消息(嵌套在<code class="fe ny nz oa ob b">user</code>内)</li><li id="f8f2" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">收件人的姓名和文本(嵌套在<code class="fe ny nz oa ob b">sent_messages</code>中)</li></ul><p id="9986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意可请求字段是如何嵌套的(例如，用户→已发送消息→收件人→姓名)。这要归功于我们在上面配置的外键和关系。</p><p id="8bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在资源管理器窗格中向下滚动，还可以选择突变和订阅:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/55c0c696f002e1ea985db308b901f057.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*eSX8SMm0o0gtn6rBCYoXSA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">GraphQL调用的三种类型</p></figure><p id="6eb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需选择其中一个，然后单击+来配置它们。</p><p id="f53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">请记住，这个GraphiQL Explorer仅供参考。所有查询、变更和订阅的模式都已经生成。我们只需要在客户端应用程序中一起单击这些查询，然后将它们复制/粘贴到我们的。graphql文件。</em></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="7f90" class="lw lx it bd ly lz mw mb mc md mx mf mg jz my ka mi kc mz kd mk kf na kg mm mn bi translated">为角度设置GraphQL Codegen</h1><p id="1c24" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在让我们用<a class="ae ky" href="https://apollo-angular.com/docs/get-started/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>和<a class="ae ky" href="https://www.graphql-code-generator.com/plugins/typescript-apollo-angular" rel="noopener ugc nofollow" target="_blank"> GraphQl Codegen </a>来设置我们的Angular客户端应用程序。为了不超出这个展示的范围，我创建了一个小的Angular应用程序，可以在这里找到<a class="ae ky" href="https://github.com/TobiStr/angular-hasura-graphql-codegen" rel="noopener ugc nofollow" target="_blank"/>。在下一节中，我将只展示如何设置Apollo、自动代码生成和用法。</p><p id="0d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要向我们的Angular项目添加所有必需的包。对于npm，请使用以下命令:</p><pre class="kj kk kl km gt oj ob ok ol aw om bi"><span id="b5f3" class="on lx it ob b gy oo op l oq or"># The base requirements are the following packages:</span><span id="6885" class="on lx it ob b gy os op l oq or">&gt; npm install apollo-angular @apollo/client graphql<br/>&gt; npm install --save @graphql-codegen/cli</span><span id="34ee" class="on lx it ob b gy os op l oq or"># Additionally we will need these packages:</span><span id="1643" class="on lx it ob b gy os op l oq or">&gt; npm install @graphql-codegen/introspection @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-apollo-angular</span></pre><p id="ac9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">检查您的package.json，如果已经安装了所有这些模块。</p><p id="497d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要在Angular项目的<strong class="lb iu"> src </strong>文件夹中创建<strong class="lb iu"> codegen.yml </strong>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">graphql-codegen的codegen.yml配置文件</p></figure><p id="e631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我已经添加了一些配置，我觉得很有用:</p><ul class=""><li id="96e2" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">模式URL和管理密码可通过环境变量(或一个<a class="ae ky" href="https://www.graphql-code-generator.com/docs/config-reference/codegen-config#environment-variables" rel="noopener ugc nofollow" target="_blank">)进行配置。env </a>文件)，这对于不将秘密推送到源代码控制是有用的。</li><li id="d24a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">代码生成器将在<code class="fe ny nz oa ob b">src/**/*.graphql</code> (= All)下搜索GraphQL定义。所有子目录中的graphql文件)。</li><li id="60d6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">代码生成器将生成文件<code class="fe ny nz oa ob b">src/app/@graphql/_generated.ts</code>，该文件将包含所有静态类型的类型、查询、变异、订阅，甚至它们的响应。</li><li id="75d5" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">已经添加了所需的插件。</li><li id="6f4c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">一些配置。参见<a class="ae ky" href="https://www.graphql-code-generator.com/plugins/typescript-operations" rel="noopener ugc nofollow" target="_blank">此处</a>供参考。</li></ul><p id="a305" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们现在可以添加一些GraphQL定义。</p><h1 id="50d9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">添加GraphQL定义</h1><p id="e94e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">移动到您选择的子文件夹，在那里您想要GraphQL定义并创建文件<code class="fe ny nz oa ob b">definitions.graphql</code>。我的情况是<code class="fe ny nz oa ob b">src/app/@graphql/definitions.graphql</code>。</p><p id="12a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件中，让我们添加我们在上面的GraphQL Explorer中定义的查询、一个变体和一个订阅:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三个示例调用的GraphQL定义</p></figure><p id="02dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，您还可以看到如何在GraphQL定义中使用变量。</p><p id="5402" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！我们现在准备自动生成几百行代码，这将节省我们大量的时间和精力。</p><h1 id="5545" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">生成您的代码</h1><p id="6778" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果您尚未将环境变量添加到CLI、主机或<em class="lv">中。env </em>文件，现在请这样做。您将需要:</p><ul class=""><li id="c8f2" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated"><code class="fe ny nz oa ob b">HASURA_SCHEMA_URL</code> : <code class="fe ny nz oa ob b">https://&lt;your-server&gt;/v1/graphql</code></li><li id="95d4" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated"><code class="fe ny nz oa ob b">HASURA_ADMIN_SECRET</code> : <code class="fe ny nz oa ob b">&lt;your-admin-secret&gt;</code></li></ul><p id="80d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在将下面的脚本行添加到您的<code class="fe ny nz oa ob b">package.json</code>中:</p><pre class="kj kk kl km gt oj ob ok ol aw om bi"><span id="7c8c" class="on lx it ob b gy oo op l oq or">"codegen": "graphql-codegen --config codegen.yml"</span><span id="6606" class="on lx it ob b gy os op l oq or"># Or in case of a .env file (install the package dotenv first):<br/>"codegen": "graphql-codegen --config codegen.yml -r dotenv/config"</span></pre><p id="bcd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以在CLI甚至CI/CD管道中调用以下内容:</p><pre class="kj kk kl km gt oj ob ok ol aw om bi"><span id="d15a" class="on lx it ob b gy oo op l oq or">&gt; npm run codegen</span></pre><p id="4b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将从Hasura中提取当前模式，并生成<code class="fe ny nz oa ob b">src/app/@graphql/_generated.ts</code> <em class="lv">下的所有类。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/65b5317e3784565b8f1578ce92f77454.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*7IAHQRUbfE317qTlf7F-6A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">成功代码生成的控制台输出</p></figure><h1 id="2404" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">从Angular调用查询、突变和订阅</h1><p id="f0f6" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通过检查您的<code class="fe ny nz oa ob b">package.json</code>，确保您已经安装了<a class="ae ky" href="https://apollo-angular.com/docs/get-started" rel="noopener ugc nofollow" target="_blank"> apollo-angular </a>。</p><p id="252f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们需要初始化Apollo客户机。这很容易做到，只需向您添加以下内容<code class="fe ny nz oa ob b">app.module.ts</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅使用Websocket为Angular实现Apollo客户端</p></figure><p id="2fe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看自动生成的<code class="fe ny nz oa ob b">_generated.ts</code>文件。如果您滚动到底部，您会发现生成的静态类型的查询、变异和订阅。它们像你在<code class="fe ny nz oa ob b">definitions.graphql</code>中定义的那样命名，以'<em class="lv"> GQL' </em>为后缀，例如<code class="fe ny nz oa ob b">SendMessageMutationGQL</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/7945f27fa371710390ac96bed04905c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9HKZF1cVbLPQkdKwFNPDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动生成的GraphQL调用</p></figure><p id="6de5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要处理这些类型，只需将它们导入到任何组件的构造函数中。我们现在有三种不同类型的GraphQL调用，每种调用的用法都略有不同。</p><p id="da1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">都是<a class="ae ky" href="https://angular.io/guide/observables" rel="noopener ugc nofollow" target="_blank">可观测的</a>。要执行它们，您需要订阅它们。在subscribe调用或Observable管道中，您可以处理每个调用的静态类型结果。</p><p id="7b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此<code class="fe ny nz oa ob b">subscriptions</code>将连续发出新的结果，而<code class="fe ny nz oa ob b">queries</code>和<code class="fe ny nz oa ob b">mutations</code>将在完成前发出一个结果。</p><p id="18b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何用自动生成的代码实现每种类型的GraphQL调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个示例服务的实现，包括所有三种GraphQL调用类型</p></figure><p id="d3d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不同类型的语法如下:</p><ul class=""><li id="c5ae" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">对于查询:<code class="fe ny nz oa ob b">QueryName.watch({&lt;arguments&gt;}).valueChanges.subscribe(…)</code></li><li id="dda7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">对于突变:<code class="fe ny nz oa ob b">MutationName.mutate({&lt;arguments&gt;}).subscribe(…)</code></li><li id="121c" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">对于订阅:<code class="fe ny nz oa ob b">SubscriptionName.subscribe({&lt;arguments&gt;}).subscribe(…)</code></li></ul><p id="e744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将得到一个<code class="fe ny nz oa ob b">ApolloQueryResult&lt;TResult&gt;</code>或一个<code class="fe ny nz oa ob b">SubscriptionResult&lt;TResult&gt;</code>，其中也可能包含错误。因此，建议在您的可观察管道中检查这些错误。</p><h1 id="81a0" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实现组件</h1><p id="f73a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">最后一步，我们实现一个基本组件作为用户界面。在这种情况下，我使用的是<code class="fe ny nz oa ob b">AppComponent</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">聊天的组成部分</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">聊天的HTML</p></figure><p id="3c5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧，我们有一个非常简单的聊天应用程序，简可以通过它给鸢发信息！因为我们将消息的接收实现为一个<code class="fe ny nz oa ob b">subscription</code>，所以当请求的值在Hasura上改变时，我们总是会得到一个更新。作为发送消息的结果，订阅被触发，我们得到一个新的消息数组。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/9342327af8e4279904644e9cc8782c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*Xft7Gnckyqzu_21DrY7_7A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工作聊天</p></figure><h1 id="d20e" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="3218" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">使用这些方法节省了我们的时间、精力，以及服务器端和客户端大量不可读的代码。</p><p id="f005" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该服务器实际上是无代码的，甚至可以扩展，具有以下特性:</p><ul class=""><li id="557d" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">自定义身份验证</li><li id="efb7" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">最多单行和单行字段的授权</li><li id="e80f" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">事件挂钩</li><li id="5181" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">自定义操作(用于业务逻辑)</li><li id="596b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">远程模式</li><li id="074b" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">以及更多，这些将在我接下来的文章中介绍。</li></ul><p id="e26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端现在拥有尽可能少的(不可维护的)样板代码。如果你感兴趣，你可以在这里查看实现阿波罗客户端<a class="ae ky" href="https://apollo-angular.com/docs/data/queries" rel="noopener ugc nofollow" target="_blank">的“正常”方式</a>。在我看来，这是不可维护的，原因如下:</p><ul class=""><li id="73f3" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nu nm nn no bi translated">GraphQL定义是神奇的字符串，这意味着您没有linter支持，即使在运行时，您也不会得到任何异常，直到您尝试执行查询。</li><li id="3200" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nu nm nn no bi translated">查询、结果和参数没有被键入，这再次导致不可预测的异常和非常困难的维护。</li></ul><p id="ce73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此相反，现在有了静态类型，甚至有了GraphQL代码的linter(可安装在VSCode中)。此外，当您尝试运行代码生成时，如果您的。graphql文件，这意味着您有一个预运行时错误检查，这对于CI/CD管道也很有用。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="2c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想亲自体验一下，可以在这里查看我的Github知识库:<a class="ae ky" href="https://github.com/TobiStr/angular-hasura-graphql-codegen" rel="noopener ugc nofollow" target="_blank">https://github.com/TobiStr/angular-hasura-graphql-codegen</a></p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你有美好的一天！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="lv">加入中现</em> </a></p><p id="cb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>