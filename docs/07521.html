<html>
<head>
<title>A Step-by-Step Guide to Regression Modeling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">回归建模分步指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/step-by-step-regression-modeling-7940bdce070e?source=collection_archive---------2-----------------------#2021-01-24">https://betterprogramming.pub/step-by-step-regression-modeling-7940bdce070e?source=collection_archive---------2-----------------------#2021-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2cb6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何创建树和集成回归模型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2bcd802a618dff4ed4d7cca4abd2f24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aSC3odScNMyz7Y6MZvqJ1Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://tadviser.com/index.php/Product:Professional_Machine_Learning_Engineer_(certificate_of_Google)" rel="noopener ugc nofollow" target="_blank"> TADVISER </a>。</p></figure><p id="264f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回归分析是一组统计过程，旨在估计因变量(目标、结果变量、<code class="fe lv lw lx ly b">y</code>)和自变量(预测因子、特征、<code class="fe lv lw lx ly b">X</code>)之间的关系。</p><p id="f3fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://scikit-learn.org/stable/user_guide.html" rel="noopener ugc nofollow" target="_blank"> Scikit-learn </a>提供内置的监督和非监督学习方法来解决回归问题。在本教程中，我们将研究决策树和集成方法的建模。</p><p id="7c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始进行任何分析之前，首先要做的是清理数据集并执行探索性数据分析:</p><ul class=""><li id="eed8" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">检查空值</li><li id="2e44" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">数据类型转换</li><li id="f012" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">占位符</li><li id="ea29" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">检查异常值</li><li id="8402" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">特征工程</li><li id="dad8" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">绘制有意义的图形</li></ul><p id="fa8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的数据没有标准化或者数据集中有分类值，请不要担心。我将向您展示如何使用必备的数据科学工具来使用方法。我将创建一个模型，通过它我们将转换分类变量，应用标准化，创建<code class="fe lv lw lx ly b">GridSearchCV</code>，训练和测试模型，并创建特征重要性图。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="34ce" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">1.训练测试数据集</h1><h2 id="5beb" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">确定目标变量和预测值</h2><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在列车试运行前，确定因变量<code class="fe lv lw lx ly b">y</code>和自变量<code class="fe lv lw lx ly b">X</code>:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="6eef" class="nm mv it ly b gy oh oi l oj ok">y = df['target']</span><span id="2000" class="nm mv it ly b gy ol oi l oj ok">X = df.drop('target', axis=1)</span></pre><h2 id="9ecb" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">列车测试分离</h2><p id="22df" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">训练测试分割是任何建模中最重要的步骤之一。这一步将允许您测试您的结果并观察您的准确性。在训练集上训练该模型，然后将结果与测试集进行比较。训练测试分割有助于避免过度适应或适应不足。</p><p id="0be7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Sklearn有一个内置的函数叫做<code class="fe lv lw lx ly b">train_test_split</code>。训练模型时，必须设置<code class="fe lv lw lx ly b">random_state</code>参数，以获得相同的训练和测试数据集。</p><p id="9fe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个包含因变量和自变量的训练测试分割。存在70/30的分流比，并且<code class="fe lv lw lx ly b">random_state</code>被设置为<code class="fe lv lw lx ly b">123</code>:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="a669" class="nm mv it ly b gy oh oi l oj ok">X_train, X_test, y_train, y_test = train_test_split(X, y,  test_size=.3, random_state=123)</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="4fb4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">2.预处理数据</h1><p id="2b85" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">将预处理步骤分别应用于训练和测试数据集，以避免数据泄漏。</p><h2 id="44f8" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">OneHotEncoder()</h2><p id="00d1" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">如果用于回归模型的数据集包括分类和/或布尔型列，使用<code class="fe lv lw lx ly b">OneHotEncoder</code>将其转换为数字数组。</p><p id="3394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，确定分类列并启动<code class="fe lv lw lx ly b">OneHotEncoder</code>:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="020a" class="nm mv it ly b gy oh oi l oj ok">categorical_columns = df.select_dtypes(include=[‘object’,        ‘bool’]).columns</span><span id="07a5" class="nm mv it ly b gy ol oi l oj ok">ohe = OneHotEncoder(handle_unknown=’ignore’)</span></pre><h2 id="cd96" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">数据标准化</h2><p id="bb6e" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">如果数据集具有不同比例的数字要素，请标准化数据以在相同比例内创建数据集。</p><p id="b0e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">StandardScaler</code>和<code class="fe lv lw lx ly b">MinMaxScaler</code>是非常流行的数据归一化方法:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="54a2" class="nm mv it ly b gy oh oi l oj ok">numerical_columns = df.select_dtypes(include=[‘int64’,             ‘float64’]).columns</span><span id="6374" class="nm mv it ly b gy ol oi l oj ok">scaler = StandardScaler()</span></pre><h2 id="3aa8" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">列变压器()</h2><p id="0c99" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">这会将转换器应用于数组或pandas数据帧的列。</p><p id="767b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更多信息参见<a class="ae ky" href="https://scikit-learn.org/stable/modules/generated/sklearn.compose.ColumnTransformer.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="ca8c" class="nm mv it ly b gy oh oi l oj ok">preprocessor = ColumnTransformer(<br/>               transformers =[<br/>                          ('num', 'scaler', 'numeric_columns),<br/>                          ('cat', 'ohe', 'categorical_columns')])</span></pre><h2 id="2abd" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">递归特征消除</h2><p id="ef87" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">预测目标变量时，递归要素消除(简称RFE)可确定数据集中最重要的要素。如果您的数据集中有太多的预测值，您可以使用此方法。</p><p id="0790" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面，用选择的<em class="om"> n </em>个特征来演示RFE算法的启动:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="1261" class="nm mv it ly b gy oh oi l oj ok">rfe = RFE(estimator = DecisionTreeRegressor(), <br/>          n_features_to_select = n)</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="5ad0" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">3.建模</h1><h2 id="8079" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">实例化回归算法</h2><p id="75bf" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">实例化你的回归算法。例如，我将选择随机森林回归。要应用<code class="fe lv lw lx ly b">gridsearch</code>，首先要决定你想用作回归变量估计量的超参数。你可以在sklearn的网站上找到每个回归变量参数的详细信息。不要忘记将您的<code class="fe lv lw lx ly b">random_state</code>设置为超参数，以避免收到不同的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="5dbf" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">创建管道</h2><p id="492f" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">在实例化<code class="fe lv lw lx ly b">GridSearchCV</code>之后，您需要创建一个管道。该管道将允许您同时进行数据转换(一个热编码器和数据标准化)、特征选择和<code class="fe lv lw lx ly b">GridSearchCV</code>。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="1803" class="nm mv it ly b gy oh oi l oj ok">pipeline = Pipeline(steps=[('preprocessor', preprocessor),<br/>                           ('s', rfe), <br/>                           ('m', rf_gridsearch)])</span></pre><h2 id="f924" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">拟合模型</h2><p id="ea68" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">记得在训练集上安装模型。使用测试数据集进行预测:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="672c" class="nm mv it ly b gy oh oi l oj ok">pipeline.fit(X_train, y_train)</span></pre><p id="5c68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">.score</code>方法控制训练和测试数据集分数。接近<code class="fe lv lw lx ly b">1</code>的分数表明我们的模型做得很好。需要进一步评估以确定模型是否可信:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="d83c" class="nm mv it ly b gy oh oi l oj ok">Train Score: <br/>pipeline.score(X_train, y_train)</span><span id="9134" class="nm mv it ly b gy ol oi l oj ok">Test Score:<br/>pipeline.score(X_test, y_test))</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="dec4" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">4.模型检查</h1><h2 id="e404" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">模型预测和残差</h2><p id="7fdb" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe lv lw lx ly b">.predict</code>方法将提供模型预测器:</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="b3f3" class="nm mv it ly b gy oh oi l oj ok">y_hat_train = pipeline.predict(X_train)</span><span id="1715" class="nm mv it ly b gy ol oi l oj ok">y_hat_test = pipeline.predict(X_test)</span></pre><p id="cfad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过从原始值中减去预测值来计算残差，即<code class="fe lv lw lx ly b">y_train</code>和<code class="fe lv lw lx ly b">y_test</code>。</p><h2 id="ee90" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">均方误差</h2><p id="8a26" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">使用sklearn的<code class="fe lv lw lx ly b">mean_squared_error</code>方法功能。该函数将计算均方误差回归损失。误差越小，模型越好。您的目标是降低模型的MSE值。</p><pre class="kj kk kl km gt od ly oe of aw og bi"><span id="ab92" class="nm mv it ly b gy oh oi l oj ok">mse_train = mean_squared_error(y_train, y_hat_train)</span><span id="dd3c" class="nm mv it ly b gy ol oi l oj ok">mse_test = mean_squared_error(y_test, y_hat_test)</span></pre><h2 id="41d9" class="nm mv it bd mw nn no dn na np nq dp ne li nr ns ng lm nt nu ni lq nv nw nk nx bi translated">特征重要性</h2><p id="6a5d" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated"><code class="fe lv lw lx ly b">feature_importances_</code>是树的属性和集合回归量。如果您的模型没有<code class="fe lv lw lx ly b">feature_importances_</code>属性，您可以使用<code class="fe lv lw lx ly b">coef_</code>来代替。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="b84c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的函数将为您提供预测要素重要性的条形图和要素重要性数据框。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/4ae4b9321237fca3b7f0cd2e408c47ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bpB_L5fbEnGULSblEuM1Cg.png"/></div></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0ed7" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">5.模型调整</h1><p id="7ae0" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">如果您的回归模型结果不令人满意，下一步就是模型调整。根据数据集和所选的回归算法，每个问题需要不同的解决方案。你可以尝试改变预测器的数量(这可能会消除RFE)，通过特征工程创建新的特征，改变超参数，或改变标准化方法。</p><p id="ccc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢做的一件事是特征工程，因为对于相同的数据集，你可以将你的MSE值提高到某一点。下面，我将分享一些我喜欢做的事情:</p><ul class=""><li id="9345" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">分别分析数据集中的所有列。有时，有些列以数字形式出现，但它们可以用作分类变量。</li><li id="8bcb" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如果我们有太多具有许多唯一值的分类变量，为这些列创建一个方框图，看看是否有任何相似之处。你可以把相似的放在一起。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9809324944c9cccf47a49ee5bbd7a28c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*xFX5cdwgxN0KLqvYtTyBcw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">相似箱线图分组</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/6c14786dc009e44fc4709e5bc97c611e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*TGsqaRLbLZkpyYtnzQu6OQ.png"/></div></figure><ul class=""><li id="16ef" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">观察目标和预测值之间的关系。假设你用回归法预测房子的卖出价值(这是你的目标),你的预测值中有买入价值。可以想象，这两者的关联度会极高。相反，你把你的目标改为买入价值和卖出价值之间的差额。</li></ul><p id="53e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">特征工程需要一定的灵活性和尽可能多的不同数据处理方法。非常了解你的数据是很重要的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="fa2f" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="4082" class="pw-post-body-paragraph kz la it lb b lc ny ju le lf nz jx lh li oa lk ll lm ob lo lp lq oc ls lt lu im bi translated">这些只是我喜欢在我的模型中使用的一些方法。如果我将执行重复的模型，比如当尝试不同的回归模型时，我喜欢创建以有序的方式运行我的模型的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div></div>    
</body>
</html>