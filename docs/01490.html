<html>
<head>
<title>Debounce With Vanilla JavaScript or RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用普通JavaScript或RxJS去抖</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/debounce-with-vanilla-javascript-or-rxjs-70f29c58ca80?source=collection_archive---------4-----------------------#2019-09-18">https://betterprogramming.pub/debounce-with-vanilla-javascript-or-rxjs-70f29c58ca80?source=collection_archive---------4-----------------------#2019-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="66ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">去抖动去神秘化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c2994aae4c8eda0f226c26624c435ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*710b8KhbLG3vPrV2cL-3dw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@barnabartis?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拜尔娜·巴蒂斯</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5f66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近不得不清理我们在<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>中使用的代码。值得注意的是，我不得不将单例方法重构为无状态函数。其中一个给了我一段更艰难的时间，这就是我写这篇文章的想法！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="373d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是去抖？</h1><p id="c48b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设您已经在应用程序中实现了一个<code class="fe mz na nb nc b">&lt;input/&gt;</code>,它会在每次数据库内容改变时触发数据库更新。出于性能原因，甚至可能出于成本原因(例如，如果您正在使用<a class="ae ky" href="https://cloud.google.com/firestore/pricing" rel="noopener ugc nofollow" target="_blank"> Google Firestore </a>)，您可能不希望每次按下键盘按键时都触发数据库更新，而是仅在需要时执行保存。例如，您可能希望仅当用户标记暂停时，或者当她/他已经完成了与组件的交互时，才执行保存。</p><p id="d18d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您的应用程序中可能有一个函数，它可能会被连续调用多次，您更愿意只考虑最后一次调用。</p><p id="5e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是去抖对我的意义——确保一个方法不会被调用得太频繁。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3718" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">去抖时间</h1><p id="18c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通常，为了检测哪些功能应该被有效地触发，观察调用之间的延迟。例如，如果我们对一个函数进行去抖，去抖时间为300毫秒，一旦观察到两次调用之间有300毫秒或更长时间，该函数就会被触发。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e855" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">普通Javascript</h1><p id="c188" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">目前没有跨浏览器支持的标准“去抖动功能”的平台实现(当然，如果我错了，请纠正我！).幸运的是，Javascript提供了使用<code class="fe mz na nb nc b">setTimeout</code>延迟函数调用和使用<code class="fe mz na nb nc b">clearTimeout</code>取消函数调用的能力。我们可以将这些结合起来实施我们自己的解决方案:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6e24" class="nh md it nc b gy ni nj l nk nl">export function debounce(func: Function, timeout?: number) {<br/>    let timer: number | undefined;</span><span id="a187" class="nh md it nc b gy nm nj l nk nl">    return (...args: any[]) =&gt; {<br/>        const next = () =&gt; func(...args);</span><span id="8214" class="nh md it nc b gy nm nj l nk nl">        if (timer) {<br/>            clearTimeout(timer);<br/>        }</span><span id="07e9" class="nh md it nc b gy nm nj l nk nl">        timer = setTimeout(next, timeout &gt; 0 ? timeout : 300);<br/>    };<br/>}</span></pre><p id="c100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们的函数(我们实际上想要执行的函数，作为参数<code class="fe mz na nb nc b">func</code>传递)将被延迟(<code class="fe mz na nb nc b">setTimeout</code>)。在这样做之前，我们首先检查它之前是否已经被调用过(使用<code class="fe mz na nb nc b">timer</code>引用之前的调用)。如果之前已经调用过，我们在有效延迟我们的目标之前取消之前的调用(<code class="fe mz na nb nc b">clearTimeout</code>)。</p><p id="622b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用一个简单的测试来验证这个实现。我们可以调用一个函数，将一个字符串连续多次记录到控制台。如果一切正常，输出应该只出现一次:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ec9d" class="nh md it nc b gy ni nj l nk nl">const myFunction: Function = debounce(() =&gt; {<br/>  console.log('Triggered only once');<br/>});</span><span id="4ba1" class="nh md it nc b gy nm nj l nk nl">myFunction(); // Cleared<br/>myFunction(); // Cleared<br/>myFunction(); // Cleared<br/>myFunction(); // Cleared<br/>myFunction(); // Performed and will output: Triggered only once</span></pre><p id="37ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想观察和测试这一点，试试这个<a class="ae ky" href="https://codepen.io/peterpeterparker/pen/WNegLNb" rel="noopener ugc nofollow" target="_blank">笔</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="227a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RxJS</h1><p id="ce39" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">上述使用普通Javascript的解决方案很酷，但是使用<a class="ae ky" href="https://rxjs-dev.firebaseapp.com" rel="noopener ugc nofollow" target="_blank">RxJS</a>(Javascript的反应式扩展库)达到同样的结果怎么样呢？那会很巧妙，不是吗？幸运的是，RxJS提供了一个开箱即用的解决方案，使用可观测量轻松实现去抖功能。此外，这个解决方案更简洁，可读性更好。</p><p id="aa2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要用的RxJS函数是<code class="fe mz na nb nc b"><a class="ae ky" href="https://rxjs-dev.firebaseapp.com/api/operators/debounceTime" rel="noopener ugc nofollow" target="_blank">debounceTime</a></code>。如文档中所解释的，它延迟由源可观测值发出的值，但是如果新的值到达源可观测值，则丢弃先前未决的延迟发射。为了重现上面的例子并创建一个可观察的，我们可以使用一个<code class="fe mz na nb nc b">Subject</code>并连续多次触发<code class="fe mz na nb nc b">next()</code>。如果一切都按计划进行，我们应该在控制台中只看到一个输出。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1778" class="nh md it nc b gy ni nj l nk nl">const mySubject: Subject&lt;void&gt; = new Subject();</span><span id="2c6d" class="nh md it nc b gy nm nj l nk nl">subject.pipe(debounceTime(300)).subscribe(() =&gt; {<br/>  console.log('Triggered only once');<br/>});</span><span id="e15c" class="nh md it nc b gy nm nj l nk nl">mySubject.next(); // Cleared<br/>mySubject.next(); // Cleared<br/>mySubject.next(); // Cleared<br/>mySubject.next(); // Cleared<br/>mySubject.next(); // Performed and will output: Triggered only once</span></pre><p id="562d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。不用写自定义函数，RxJS只是为我们解决了去抖。</p><p id="f304" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你也想在行动中尝试一下，看看另一个<a class="ae ky" href="https://codepen.io/peterpeterparker/pen/ZEzqXPw" rel="noopener ugc nofollow" target="_blank"> Codepen </a>。</p><p id="c76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">注意:在上面的例子中，为了简单起见，我没有考虑取消订阅可观察对象。显然，如果您想在实际应用中使用这种解决方案，请小心谨慎。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f898" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">蛋糕上的樱桃🍒🎂</h1><p id="cffa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们的开源项目<a class="ae ky" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>中，我们在我们的应用程序和组件中使用了一个名为<code class="fe mz na nb nc b">deckdeckgo/utils</code>的小utils包(发布给<a class="ae ky" href="https://www.npmjs.com/package/@deckdeckgo/utils" rel="noopener ugc nofollow" target="_blank"> npm </a>)，它提供了各种实用程序，其中一个是普通的Javascript <code class="fe mz na nb nc b">debounce</code>函数。因此，如果您需要一个快速和肮脏的解决方案，请成为我们的客人，并尝试一下！</p><div class="no np gp gr nq nr"><a href="https://github.com/deckgo/deckdeckgo/tree/master/webcomponents/utils" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">deckgo/deckdeckgo</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">在DeckDeckGo的应用程序和组件中开发和使用的utils方法和函数的集合。如果你愿意…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div></div></a></div><p id="6546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到无限和更远🚀</p><p id="6dc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>