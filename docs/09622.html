<html>
<head>
<title>Save Up Computation Time in JavaScript Using Memoized Wrapper Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用记忆包装函数节省JavaScript中的计算时间</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/save-up-computation-time-in-javascript-using-memoized-wrapper-functions-ae85f28d8087?source=collection_archive---------4-----------------------#2021-09-17">https://betterprogramming.pub/save-up-computation-time-in-javascript-using-memoized-wrapper-functions-ae85f28d8087?source=collection_archive---------4-----------------------#2021-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3bf4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建包装器来记忆预先存在的函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c1f4333c850617fbe98c58197a58f9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sM00-N7-TGSVuULk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@bradneathery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布拉德·奈瑟里</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一下，由于一个函数导致大量处理阻塞所有其他执行，您必须等待大约15秒才能继续使用您的程序。</p><p id="11a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae ky" href="http://seekoapp.io/61445d337c08ca0009305f9a" rel="noopener ugc nofollow" target="_blank"> Leetcode </a>、<a class="ae ky" href="http://seekoapp.io/61445d347c08ca0009305f9c" rel="noopener ugc nofollow" target="_blank"> Hackerrank </a>和co这样的编码挑战网站的存在是有特定原因的。例如，斐波纳契数列可以用巨大的数量来计算一个值。如果你使用递归并处理中间结果，你不应该重复地重新计算现有的结果并记住<a class="ae ky" href="http://seekoapp.io/61445d367c08ca0009305f9e" rel="noopener ugc nofollow" target="_blank">大O符号</a>。</p><p id="f19b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，尤其是用户，这是不可接受的，所以你必须找到一种更好的方法来记忆，并学习如何用一个<a class="ae ky" href="http://seekoapp.io/61445d377c08ca0009305fa0" rel="noopener ugc nofollow" target="_blank">记忆化的</a>函数包装任何函数。</p><p id="0ca2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这些例子是用JavaScript编写的，但是该技术适用于任何支持所示结构的语言。</p><h1 id="c6e5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">柠檬榨汁机</h1><p id="6dac" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我想用一个简单的例子让你进入这个主题:取一个Fibonacci函数，它接收一个参数(数值)并返回元素的和，直到<code class="fe ms mt mu mv b">n</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想向您展示如何在这个函数中实现一个缓存来更快地计算结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:您可以测试高数字的计算时间，您将看到不同之处。或者你可以继续读下去，看看我的测试:)</p><p id="db3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个<code class="fe ms mt mu mv b">cachedFibonacci</code>做得很好，但它不符合功能性的要求。它也不符合编码原则的特定法则(<em class="my">全局空间，改变现有代码</em>)。</p><p id="348e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">cachedFibonacci</code>解决方案在概念上是通用的，但特别是在实现上。这意味着你或我不得不直接修改函数的代码来利用记忆化。</p><p id="63d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以做得更好。</p><p id="d428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，你应该考虑一种自动完成事情的方法。</p><p id="bba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以与<a class="ae ky" href="http://seekoapp.io/61445d387c08ca0009305fa2" rel="noopener ugc nofollow" target="_blank">相同的方式，我对其他包装函数</a>做了同样的处理。</p><p id="ca68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案将是一个<code class="fe ms mt mu mv b">memoize()</code>函数，它包装任何其他函数来应用记忆:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my">这是怎么回事？</em></p><p id="d385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回的函数检查对于任何给定的参数，参数是否已经被接收。要么它是数组<code class="fe ms mt mu mv b">cache</code>的一部分，可以用适当的键找到，要么不能。</p><p id="4da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果是，就不需要计算，返回缓存的值。</p><p id="42c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，您需要计算缺失值并将其存储在缓存中。</p><p id="52c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my"/><code class="fe ms mt mu mv b"><em class="my">cache</em></code><em class="my">是闭包的一部分，用于隐藏缓存，防止外部访问。我在这里使用闭包是因为假设memoized函数只接收一个参数(</em> <code class="fe ms mt mu mv b"><em class="my">x</em></code> <em class="my">)并且是一个原始值。然后，它可以直接用作缓存对象的键值。</em></p><h1 id="3ae2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">启动计时器测试</h1><p id="5f64" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了验证这种方法是否工作正常，您必须对这些函数进行计时。我将使用以下计时功能来验证我的创作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="63fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从最初的<code class="fe ms mt mu mv b">fibonacci()</code>功能开始。我将对整个计算进行计时，而不是每次递归调用，所以我创建了一个辅助的<code class="fe ms mt mu mv b">testFibonacci()</code>函数，并将从文件<code class="fe ms mt mu mv b">simpleFibonacci.js</code>中测试原始的<code class="fe ms mt mu mv b">fibonacci()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="aab2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:这个练习不是获得实际计算时间的正确方法。一个普通的测试是合适的。但我想确认记忆起作用了。</p><p id="b26b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你用你的机器重复测试时，你的时间会有所不同。这取决于您的具体CPU、RAM等。</p><p id="5751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，结果似乎是合乎逻辑的:指数似乎存在，时间增长很快。</p><p id="6c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们纪念一下<code class="fe ms mt mu mv b">testFibonacciMemoized()</code>。结果我应该找到更短的时间…不是吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b8d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看时间，您会看到第3行和第4行之间的显著变化。<strong class="lb iu"> <em class="my">哇！</em> </strong>从2.7s降到几乎0…那看起来棒极了！<em class="my">但这是什么？！</em></p><p id="aa7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之前用了一个新的数字(第4行到第5行)，我又回到了之前的数字。同样，从第5行到第6行的转换也证明了这一点。</p><blockquote class="mz na nb"><p id="b440" class="kz la my lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated">“你看到了，但你没有观察。”——阿瑟·柯南道尔，<a class="ae ky" href="http://www.bookbub.com/books/the-adventures-of-sherlock-holmes-by-arthur-conan-doyle" rel="noopener ugc nofollow" target="_blank"> <em class="it">波希米亚的一桩丑闻</em> </a></p></blockquote><p id="534a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经计时了<code class="fe ms mt mu mv b">testFibionacciMemoized()</code>，但是代码没有调用那个函数，除了计时，计时只发生一次！</p><p id="f7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my">在内部，所有的递归调用都是对</em> <code class="fe ms mt mu mv b"><em class="my">fibonacci()</em></code> <em class="my">的，没有被记忆。</em></p><p id="d4c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以同一个号码的两次通话实际上是被记忆的。但其余的就不是了。这就是毫秒数再次上升的原因。要获得正确的结果，您必须将代码更改为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="241d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码与众不同的地方在于，您将<code class="fe ms mt mu mv b">memoize()</code>包装在<code class="fe ms mt mu mv b">fibonacci</code>周围，并将其保存到自身中。它不再是一个只被<code class="fe ms mt mu mv b">addTiming</code>函数调用的变量。你已经成功地绕过了<code class="fe ms mt mu mv b">memoize()</code>。</p><p id="9477" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着在计算<code class="fe ms mt mu mv b">fibonacci(42)</code>时，所有的中间斐波那契值(从0到42)都被存储，所以未来的调用实际上不用计算。他们查找这些值，这就是大幅降低计算时间所证明的。</p><blockquote class="mz na nb"><p id="2bc3" class="kz la my lb b lc ld ju le lf lg jx lh nc lj lk ll nd ln lo lp ne lr ls lt lu im bi translated">记忆化是一种降低函数的<strong class="lb iu">时间</strong>成本以换取<strong class="lb iu">空间</strong>成本的方法。—维基百科</p></blockquote><p id="23d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在已经掌握了记忆的基础。让我们转向更复杂的世界。</p><h1 id="35a0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">争论越多，乐趣越多！</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/6097c94977e15512b2a864d295b0aca9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DCNGgmL0RLSJAM9M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·迪斯-梅莱什在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一个函数接受不止一个参数，你该怎么办？不要想象它也可以接受数组或对象。</p><p id="34cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我介绍这个函数的解决方案之前，您可以从一个只包装一元的函数开始，剩下的就不管了。</p><p id="9e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做意味着通过使用if表达式实际访问函数的<code class="fe ms mt mu mv b">.length</code>来检查函数的arity:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ce5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你的函数不是一元的，它会直接返回函数而不做任何记忆。</p><p id="e0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想记住<em class="my">任何函数</em>，你必须想办法生成缓存键。换句话说:</p><p id="3865" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你必须找到一种方法将任何参数转换成字符串。</p><p id="585f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不能直接用非原语作为缓存键。您可以尝试用类似<code class="fe ms mt mu mv b">str = String(x)</code>的东西将值转换成字符串，但是会有问题。</p><p id="fc06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，对于数组，它似乎工作得很好，不是吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">String()</code>函数在任何时候都会产生精确的扁平字符串。嵌套数组被转换成一个字符串。这对我们想要的记忆行为是不利的。当不同的数组产生相同的密钥时，这是一个问题。</p><p id="c72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您必须接收对象作为参数，事情会变得更糟，因为任何对象的<code class="fe ms mt mu mv b">String()</code>表示都是<code class="fe ms mt mu mv b">[object, Object]</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ca90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你该怎么办？最简单的解决方案是使用<code class="fe ms mt mu mv b">JSON.stringify()</code>将我们收到的任何参数转换成有用的、独特的字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="e67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你所要考虑的就是获得更好的性能:如果你要记忆的函数接收到一个参数，它就是一个原始值。因此，您可以将它直接用作缓存键。</p><p id="7be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有其他情况下，您必须使用应用于参数数组的<code class="fe ms mt mu mv b">JSON.stringify()</code>的结果。</p><p id="b0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循这种区别导致记忆<a class="ae ky" href="http://seekoapp.io/61445d3a7c08ca0009305fa4" rel="noopener ugc nofollow" target="_blank">高阶函数</a>的改进版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="105e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从通用性来说，这是最安全的版本。</p><p id="391f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当你明确知道函数中参数的类型时，第一个记忆函数会更快。</p><p id="5868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据您的意愿，您可能还希望代码更简单，因此在您看来更好。然后，用这个版本的更简单也更通用的记忆功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:这一次，更简单的代码会浪费一些CPU周期。Ciao Gondim编写了世界上最快的记忆库。自从JSON之后。Stringify()执行得不是很好<a class="ae ky" href="https://community.risingstack.com/the-worlds-fastest-javascript-memoization-library/" rel="noopener ugc nofollow" target="_blank">你可以在这里查看最快的方法</a>。</p><p id="830c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我介意你现在已经记够了。<em class="my">这部分做完了。</em></p><p id="084b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的就是测试了。测试记忆化高阶函数提出了一个有趣的问题——你会怎么做？</p><h1 id="ee43" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">记忆测试</strong></h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/af2810f77f4af59fa5fb1cdeeb3c0b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sLKOIQu1Md1o5JlO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@scienceinhd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">科学高清照片</a>上<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="f38d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有什么新想法吗？没有吗？</p><p id="246b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，那我先说:查看藏宝阁可能是一种方法。但这是隐私。重写使用全局缓存的函数也不是一个有效的选择。</p><p id="3cb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你想过用更直接的方式来分析吗？比如统计实际通话的次数？</p><p id="ca7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个非记忆的、原始的<code class="fe ms mt mu mv b">fibonacci()</code>，你可以测试这个函数是否正常工作，并检查调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没什么特别的。只是检查原始的<code class="fe ms mt mu mv b">fibonacci()</code>函数，测试调用和产生的值。以<code class="fe ms mt mu mv b">fibonacci(6)</code>等于<code class="fe ms mt mu mv b">8</code>为例，你可以很容易地验证这一点。</p><p id="890b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my">但是你怎么发现函数被调用</em> <code class="fe ms mt mu mv b"><em class="my">25</em></code> <em class="my">次呢？</em></p><p id="5ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要得到答案，请看一下计算<code class="fe ms mt mu mv b">fibonacci(6)</code>所需的所有递归调用的图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/3e5cbeb081a63decfd78ff5a7cc3f23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1D1SqTprdtz3iQL4.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图斐波纳契(6)通过<a class="ae ky" href="https://medium.com/launch-school/recursive-fibonnaci-method-explained-d82215c5498e" rel="noopener">发射学校</a></p></figure><p id="b27a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个节点代表对我们函数的一次调用。通过计数，可以看到为了计算<code class="fe ms mt mu mv b">fibonacci(6)</code>，已经进行了<code class="fe ms mt mu mv b">25</code>次调用。</p><p id="2dae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们来看看这个函数的记忆版本，并测试它是否仍然产生相同的结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="my">你能猜出为什么计算</em> <code class="fe ms mt mu mv b"><em class="my">fibonacci(6)</em></code> <em class="my">要调用11次，然后计算</em><code class="fe ms mt mu mv b"><em class="my">fibonacci(5)</em></code><em class="my"/><code class="fe ms mt mu mv b"><em class="my">fibonacci(4)</em></code><em class="my"/><code class="fe ms mt mu mv b"><em class="my">fibonacci(3)</em></code><em class="my">后才多三次(14的总和)？</em></p><p id="a188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了回答这个问题的第一部分，让我们分析前面的图(Fibonacci(6)通过<a class="ae ky" href="http://seekoapp.io/61445d3b7c08ca0009305fa6" rel="noopener ugc nofollow" target="_blank"> LaunchSchool </a>)并沿着左边的分支。</p><ul class=""><li id="5565" class="ni nj it lb b lc ld lf lg li nk lm nl lq nm lu nn no np nq bi translated">第一个调用到<code class="fe ms mt mu mv b">fibonacci(6)</code>，调用<code class="fe ms mt mu mv b">fibonacci(5)</code>，<code class="fe ms mt mu mv b">fibonacci(4)</code> = 3个调用。</li><li id="cef0" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">要计算<code class="fe ms mt mu mv b">fibonacci(5)</code>，必须调用<code class="fe ms mt mu mv b">fibonacci(4)</code>和<code class="fe ms mt mu mv b">fibonacci(3)</code>；+2= 5次呼叫。</li><li id="4f0f" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">要计算<code class="fe ms mt mu mv b">fibonacci(4)</code>，必须调用<code class="fe ms mt mu mv b">fibonacci(3)</code>和<code class="fe ms mt mu mv b">fibonacci(2)</code>；+2= 7次呼叫。</li><li id="702c" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">要算<code class="fe ms mt mu mv b">fibonacci(3)</code>，<code class="fe ms mt mu mv b">fibonacci(2)</code>，<code class="fe ms mt mu mv b">fibonacci(1)</code>都得叫；+2= 9次呼叫。</li><li id="ddd2" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">要计算<code class="fe ms mt mu mv b">fibonacci(2)</code>，就得调用<code class="fe ms mt mu mv b">fibonacci(1)</code>和<code class="fe ms mt mu mv b">fibonacci(0)</code>；+2= 11次呼叫。</li><li id="7e3a" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated">整个右分支已经被缓存，所以计算<code class="fe ms mt mu mv b">fibonacci(6)</code>的调用计数是11。</li></ul><p id="0dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回答这个问题的第二部分:因为您缓存了所有以前的<code class="fe ms mt mu mv b">fibonacci(n)</code>到<code class="fe ms mt mu mv b">fibonacci(6)</code>的值，所以很容易理解为什么计算<code class="fe ms mt mu mv b">fibonacci(5)</code>、<code class="fe ms mt mu mv b">fibonacci(4)</code>和<code class="fe ms mt mu mv b">fibonacci(3)</code>只增加了三个调用(实际上每个调用一个来获得新的结果)。</p><p id="724b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有其他必需的值都已经被计算和缓存，</p><h1 id="c613" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="1eb8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">您已经学习了如何处理几个包装函数来记忆已经存在的包装函数。</p><p id="bfcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数的arity无关紧要；现在，您已经拥有了找到合适解决方案所需的所有工具。</p><p id="3264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要目标是通过不接触现有的和工作的代码来继续扩展您的应用程序。</p><p id="2ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，另一种情况是当你想改变一个函数的工作方式时。但这是我下一篇文章的内容。</p><p id="f5b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取26份备忘单，只研究你真正需要的东西，以获得你的第一份网络开发工作！ </p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/227a060a3bfa55f41fa795d5990e6032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Nqyiu4c6K-mCxE9e.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> Arnold Code Academy 26 Web开发人员备忘单</a></p></figure><h1 id="8d3e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="f287" class="ni nj it lb b lc mn lf mo li nx lm ny lq nz lu nn no np nq bi translated"><a class="ae ky" href="https://codeburst.io/understanding-memoization-in-3-minutes-2e58daf33a19" rel="noopener" target="_blank">3分钟了解JavaScript记忆化</a></li><li id="4380" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/understanding-memoize-in-javascript-51d07d19430e/" rel="noopener ugc nofollow" target="_blank">如何使用Memoize缓存JavaScript函数结果，加速你的代码</a></li><li id="13f3" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆化</a></li><li id="401a" class="ni nj it lb b lc nr lf ns li nt lm nu lq nv lu nn no np nq bi translated"><a class="ae ky" href="https://amzn.to/3ziF8cL" rel="noopener ugc nofollow" target="_blank">掌握JavaScript函数式编程</a></li></ul></div></div>    
</body>
</html>