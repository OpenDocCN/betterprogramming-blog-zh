<html>
<head>
<title>Exploring Use Cases of Core ML Tools</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索核心ML工具的用例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-use-cases-of-core-ml-tools-9fbc0fde72e7?source=collection_archive---------6-----------------------#2019-11-21">https://betterprogramming.pub/exploring-use-cases-of-core-ml-tools-9fbc0fde72e7?source=collection_archive---------6-----------------------#2019-11-21</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="0466" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">评估、转换、可更新模型等等</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/46de4c7ea1bd62e3a1524314f2c617a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7vnYpILSk4MraEXB"/></div></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">照片由<a class="ae kw" href="https://unsplash.com/@roum?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Elena Rouame </a>在<a class="ae kw" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5b97" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">苹果的Core ML是一个强大的机器学习框架，具有易于使用的拖放界面。最新的迭代<a class="ae kw" href="https://heartbeat.comet.ml/whats-new-in-core-ml-3-d108d352e50a" rel="noopener ugc nofollow" target="_blank"> Core ML 3 </a>引入了许多新的层，并产生了<a class="ae kw" href="https://medium.com/better-programming/how-to-create-updatable-models-using-core-ml-3-cc7decd517d5" rel="noopener">可更新的模型</a>。</p><p id="08c7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">随着这么多特性的发布，有一件事经常被忽略，那就是你可以用Xcode之外的模型做的事情。甚至在应用程序中部署核心ML模型之前，就有很多功能可以进行微调、定制和模型测试。</p><p id="8e4a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用<code class="fe lt lu lv lw b">coremltools</code> Python包，您不仅可以转换模型，还可以使用实用程序类来调试图层、修改要素形状、设置超参数，甚至运行预测。</p><p id="e1e7" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">随着<code class="fe lt lu lv lw b">coremltools 3.0</code>的出现，与Core ML 2相比，已经增加了大约100层。此外，现在可以将图层标记为可更新，以便进行设备上训练。</p><p id="42ef" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在接下来的章节中，我们将浏览不同的用例以及场景，在这些场景中<code class="fe lt lu lv lw b">coremltools</code>对我们和我们的ML模型很方便。</p><p id="49a1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在我们开始之前，继续使用以下命令安装<code class="fe lt lu lv lw b">coremltools 3.0</code>:</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="0e9a" class="mb mc ir lw b gz md me l mf mg">pip install -U coremltools</span></pre><h1 id="f22f" class="mh mc ir bd mi mj mk ml mm mn mo mp mq jx mr jy ms ka mt kb mu kd mv ke mw mx bi translated">预处理和模型转换</h1><p id="63ff" class="pw-post-body-paragraph kx ky ir kz b la my js lc ld mz jv lf lg na li lj lk nb lm ln lo nc lq lr ls ik bi translated">Core ML Tools提供了转换器，可以将流行的机器学习库(如Keras、Caffe、scikit-learn、LIBSVM和XGBoost)中的模型转换为Core ML。</p><p id="8375" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，<a class="ae kw" href="https://github.com/onnx/onnx-coreml" rel="noopener ugc nofollow" target="_blank"> onnx-coreml </a>和<a class="ae kw" href="https://github.com/tf-coreml/tf-coreml" rel="noopener ugc nofollow" target="_blank"> tf-coreml </a>神经网络转换器建立在<code class="fe lt lu lv lw b">coremltools</code>之上。</p><p id="4abe" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">tf-coreml</code>需要在<code class="fe lt lu lv lw b">convert</code>功能中设置最小展开目标标志。这是因为iOS 13部署模型的底层实现与旧版本不同。</p><p id="9363" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于iOS 13及以上版本，需要在参数<code class="fe lt lu lv lw b">input_name_shape_dict</code>中传递节点名称——而不是张量形状。</p><p id="fd50" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下代码片段展示了如何将Keras模型转换为核心ML:</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="nd ne l"/></div></figure><p id="f95d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">使用上面显示的Python脚本，我们可以做各种事情，比如更改输入和输出名称、预处理等。</p><p id="e2a5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">image_input_names</code>参数表明输入类型可以被认为是一个图像。否则，默认情况下，输入由Core ML创建为多维数组。</p><p id="5553" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">image_scale</code>用于指定输入缩放的数值。像素乘以这个数字。仅当设置了<code class="fe lt lu lv lw b">image_input_names</code>时，此参数才适用。</p><p id="c00f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe lt lu lv lw b">red_bias</code>、<code class="fe lt lu lv lw b">green_bias</code>、<code class="fe lt lu lv lw b">blue_bias</code>和<code class="fe lt lu lv lw b">gray_bias</code>:这些值将R、G、B或灰度颜色值加到像素上。</p><p id="0326" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">对于分类器模型，我们可以传递一个参数<code class="fe lt lu lv lw b">class_labels</code>，该参数带有一个包含类标签的数组或文件，这些标签被映射到神经网络的输出索引。</p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><h1 id="dcb1" class="mh mc ir bd mi mj nm ml mm mn nn mp mq jx no jy ms ka np kb mu kd nq ke mw mx bi translated">修改输入和输出类型</h1><p id="2e99" class="pw-post-body-paragraph kx ky ir kz b la my js lc ld mz jv lf lg na li lj lk nb lm ln lo nc lq lr ls ik bi translated">如果您手头有一个核心ML模型，但是没有想要的输入约束，<code class="fe lt lu lv lw b">coremltools</code>是一个方便的工具。它不仅允许调整输入和输出的大小，还允许您更改类型。例如，如果您需要将输入类型<code class="fe lt lu lv lw b">MLMultiArray</code>转换为具有特定颜色空间的图像类型，下面这段代码将为您完成这项工作:</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="a01a" class="mb mc ir lw b gz md me l mf mg">import coremltools<br/>import coremltools.proto.FeatureTypes_pb2 as ft <br/><br/>spec = coremltools.utils.load_spec("OldModel.mlmodel")<br/><br/>input = spec.description.input[0]<br/>input.type.imageType.colorSpace = ft.ImageFeatureType.RGB<br/>input.type.imageType.height = 224 <br/>input.type.imageType.width = 224<br/><br/>coremltools.utils.save_spec(spec, "NewModel.mlmodel")</span></pre><blockquote class="nr ns nt"><p id="1710" class="kx ky nu kz b la lb js lc ld le jv lf nv lh li lj nw ll lm ln nx lp lq lr ls ik bi translated">使用<code class="fe lt lu lv lw b">coremltools</code>中的<code class="fe lt lu lv lw b">flexible_shape_utils</code>，我们可以进一步指定形状范围，甚至设置多个输入和输出形状。</p></blockquote><h1 id="4b9b" class="mh mc ir bd mi mj mk ml mm mn mo mp mq jx mr jy ms ka mt kb mu kd mv ke mw mx bi translated">量化</h1><p id="e885" class="pw-post-body-paragraph kx ky ir kz b la my js lc ld mz jv lf lg na li lj lk nb lm ln lo nc lq lr ls ik bi translated">应用程序的大小很重要，某些核心ML模型会占用大量的存储空间。量化有助于减小模型大小，而不会显著降低精度。当减小模型的尺寸时，我们降低了权重的精度。</p><p id="e9d5" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">下面的代码展示了一个量化核心ML模型的例子。</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="0a09" class="mb mc ir lw b gz md me l mf mg">from coremltools.models.neural_network.quantization_utils import quantize_weights<br/><br/>model = coremltools.models.MLModel('model.mlmodel')<br/>quantized_model = quantize_weights(model, nbits=8, quantization_mode="linear")</span></pre><p id="9a77" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前支持的一些量化模式有<code class="fe lt lu lv lw b">linear</code>、<code class="fe lt lu lv lw b">kmeans</code>、<code class="fe lt lu lv lw b">linear_symmetric</code>和<code class="fe lt lu lv lw b">linear_lut</code>。</p><p id="3022" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前，Caffe和Keras转换器支持全精度和半精度量化。这可以在转换器功能的<code class="fe lt lu lv lw b">model_precision</code>参数中设置。默认为<code class="fe lt lu lv lw b">float32</code>。</p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><h1 id="06ed" class="mh mc ir bd mi mj nm ml mm mn nn mp mq jx no jy ms ka np kb mu kd nq ke mw mx bi translated">修改图层</h1><p id="b201" class="pw-post-body-paragraph kx ky ir kz b la my js lc ld mz jv lf lg na li lj lk nb lm ln lo nc lq lr ls ik bi translated">核心ML工具允许我们检查、添加、删除或修改层。对于<code class="fe lt lu lv lw b">coremltools</code>无法转换的图层，我们可以通过在convert函数中将参数<code class="fe lt lu lv lw b">add_custom_layers</code>设置为<code class="fe lt lu lv lw b">true</code>来设置一个占位符图层:</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="45d1" class="mb mc ir lw b gz md me l mf mg">coreml_model = keras_converter.convert(keras_model, add_custom_layers=True)</span></pre><p id="fcf2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，我们可以通过调用神经网络构建器实例上的<code class="fe lt lu lv lw b">inspect_layers</code>来检查许多层。</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="f2bc" class="mb mc ir lw b gz md me l mf mg">spec = coremltools.utils.load_spec(MyModel.mlmodel) builder=coremltools.models.neural_network.NeuralNetworkBuilder(spec=spec)<br/>builder.inspect_layers(last=2)<br/>builder.inspect_input_features()</span></pre><p id="4081" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下代码显示了在构建器规范中添加或删除图层的示例:</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="3df0" class="mb mc ir lw b gz md me l mf mg">new_layer = neuralNetworkClassifier.layers.add()<br/>new_layer.name = 'my_new_layer'</span><span id="4b10" class="mb mc ir lw b gz ny me l mf mg">//delete<br/>del nn.layers[-1]</span></pre><blockquote class="nr ns nt"><p id="98ba" class="kx ky nu kz b la lb js lc ld le jv lf nv lh li lj nw ll lm ln nx lp lq lr ls ik bi translated">为了删除一系列层，您可以使用<code class="fe lt lu lv lw b">layers[a:b]</code></p></blockquote></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><h1 id="da45" class="mh mc ir bd mi mj nm ml mm mn nn mp mq jx no jy ms ka np kb mu kd nq ke mw mx bi translated">允许设备上的模型训练</h1><p id="a1df" class="pw-post-body-paragraph kx ky ir kz b la my js lc ld mz jv lf lg na li lj lk nb lm ln lo nc lq lr ls ik bi translated">设备上模型训练是Core ML 3最大的进步之一。它允许我们从设备本身个性化模型，而不必在服务器端重新训练。为了允许在设备上更新ML模型，我们需要:</p><ul class=""><li id="bb6a" class="nz oa ir kz b la lb ld le lg ob lk oc lo od ls oe of og oh bi translated">将某些图层标记为可更新</li><li id="7120" class="nz oa ir kz b la oi ld oj lg ok lk ol lo om ls oe of og oh bi translated">设置损失函数和超参数</li><li id="6654" class="nz oa ir kz b la oi ld oj lg ok lk ol lo om ls oe of og oh bi translated">在构建器规格中添加培训输入规格。</li></ul><p id="9241" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在另一个场景中，如果您希望直接构建可更新的核心ML模型，而不是在以后修改它们，那么您可以在模型转换期间将<code class="fe lt lu lv lw b">respect_trainable=True</code>参数传递给<code class="fe lt lu lv lw b">coremltools.converters.keras.convert()</code>。</p><p id="6ba1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">目前，只有神经网络和KNN模型可以使用<code class="fe lt lu lv lw b">coremltools</code>进行更新。</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="d2a3" class="mb mc ir lw b gz md me l mf mg">builder.make_updatable(['layer_name_1', 'layer_name_2'])<br/></span><span id="7b18" class="mb mc ir lw b gz ny me l mf mg">model_spec.description.trainingInput[0].shortDescription = 'Image for training and updating the model'<br/>model_spec.description.trainingInput[1].shortDescription = 'Set the class label here'</span></pre><p id="43e4" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，我们需要为可更新模型设置超参数，如epochs、<a class="ae kw" href="https://heartbeat.comet.ml/introduction-to-learning-rates-in-machine-learning-6ed685c16506" rel="noopener ugc nofollow" target="_blank">学习率</a>和训练样本的批量，如下所示:</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="a4c5" class="mb mc ir lw b gz md me l mf mg">builder.set_sgd_optimizer(SgdParams(lr=0.01, batch=12))<br/>builder.set_epochs(20)<br/>builder.set_categorical_cross_entropy_loss(name='lossLayer', input='output')</span></pre><p id="5163" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">模型内部的损失函数就像层一样。目前，<code class="fe lt lu lv lw b">binary_entropy</code>和<code class="fe lt lu lv lw b">categorical_cross_entropy</code>(针对多个标签类别)是少数几个受支持的损失函数。</p><p id="178d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">最后，您需要在模型规范的最低规范版本旁边设置<code class="fe lt lu lv lw b">isUpdatable</code>标志(Core ML有v4)，如下所示:</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="138e" class="mb mc ir lw b gz md me l mf mg">model_spec.isUpdatable = True<br/>model_spec.specificationVersion = coremltools._MINIMUM_UPDATABLE_SPEC_VERSION</span></pre><blockquote class="nr ns nt"><p id="3b91" class="kx ky nu kz b la lb js lc ld le jv lf nv lh li lj nw ll lm ln nx lp lq lr ls ik bi translated">注意:除了SGD，你也可以使用Adam优化器。</p></blockquote><h1 id="d306" class="mh mc ir bd mi mj mk ml mm mn mo mp mq jx mr jy ms ka mt kb mu kd mv ke mw mx bi translated">运行预测</h1><p id="b99f" class="pw-post-body-paragraph kx ky ir kz b la my js lc ld mz jv lf lg na li lj lk nb lm ln lo nc lq lr ls ik bi translated">从<code class="fe lt lu lv lw b">coremltools</code> Python脚本本身运行预测很容易。首先，您需要使用<code class="fe lt lu lv lw b">coremltools</code>加载您的<code class="fe lt lu lv lw b">.mlmodel</code>。</p><p id="d8e8" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">以下代码加载图像分类<code class="fe lt lu lv lw b">.mlmodel</code>并对其运行预测:</p><pre class="kh ki kj kk gu lx lw ly lz aw ma bi"><span id="08be" class="mb mc ir lw b gz md me l mf mg">import coremltools<br/>import PIL.Image</span><span id="fe8a" class="mb mc ir lw b gz ny me l mf mg">def load_image(path, resize_to=None):<br/>    # resize_to: (Width, Height)<br/>    img = PIL.Image.open(path)<br/>    if resize_to is not None:<br/>        img = img.resize(resize_to, PIL.Image.ANTIALIAS)<br/>    return img</span><span id="5d66" class="mb mc ir lw b gz ny me l mf mg">model = coremltools.models.MLModel('catDogModel.mlmodel')<br/>img = load_image('./test-image.jpeg', resize_to=(150, 150))</span><span id="2f4b" class="mb mc ir lw b gz ny me l mf mg">result = model.predict({'image': img})<br/>print(result)</span></pre><p id="8b2b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">在上面的代码中，我们在<code class="fe lt lu lv lw b">.mlmodel</code>类构造函数中传递模型名。或者，您可以通过在构造函数中设置布尔参数<code class="fe lt lu lv lw b">useCPUOnly=True</code>来限制模型仅在CPU上运行。</p><p id="6168" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">接下来，我们使用<code class="fe lt lu lv lw b">PIL</code>(枕形封装)将图像加载到我们的<a class="ae kw" href="https://github.com/anupamchugh/iowncode/blob/master/iOSCoreMLOnDeviceTraining/iOSCoreMLTrainModelOnDevice/iOSCoreMLTrainModelOnDevice/CatDogUpdatable.mlmodel" rel="noopener ugc nofollow" target="_blank">定制的Core ML模型</a>中，并调整其大小以适应输入约束(该模型为150x150)。</p><p id="ed25" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们使用下面的图片运行了上面的Python脚本，并获得了作为<code class="fe lt lu lv lw b">cat</code>的输出(确切的输出在图片标题中)。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj on"><img src="../Images/3a31d3ab81217d04c04aeb47b282f18b.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*v_BbWD0l6O75efEp_rf7aw.jpeg"/></div><p class="ks kt gk gi gj ku kv bd b be z dk translated">{u'classLabel': u'Cat '，u'output': {u'Dog': 0.0，u'Cat': 1.0}}</p></figure><p id="04f0" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">除了像上面那样测试你的模型的准确性，你还可以调试你的模型层并打印出规格、概要，或者你可以通过调用<code class="fe lt lu lv lw b">.mlmodel</code>上的<code class="fe lt lu lv lw b">visualize_spec()</code>来可视化你的模型。</p></div><div class="ab cl nf ng hv nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ik il im in io"><h1 id="827d" class="mh mc ir bd mi mj nm ml mm mn nn mp mq jx no jy ms ka np kb mu kd nq ke mw mx bi translated">结论</h1><p id="1303" class="pw-post-body-paragraph kx ky ir kz b la my js lc ld mz jv lf lg na li lj lk nb lm ln lo nc lq lr ls ik bi translated">Core ML 3引入了许多新的控制流层，可以使用神经网络生成器以编程方式构建不同的神经网络Core ML模型。这里有一个<a class="ae kw" href="https://github.com/apple/coremltools/blob/master/examples/neural_network_inference/Neural_network_control_flow_power_iteration.ipynb" rel="noopener ugc nofollow" target="_blank">的例子</a>来自文档。</p><p id="e305" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">此外，<code class="fe lt lu lv lw b">coremltools</code>的新版本也带来了对TensorFlow 2.0转换器的支持。接下来，您可以尝试向模型添加激活层，量化和评估模型，然后再将它们部署到您的应用程序中。</p><p id="acf2" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这就结束了。我希望你喜欢阅读。</p></div></div>    
</body>
</html>