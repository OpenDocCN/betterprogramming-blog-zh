<html>
<head>
<title>The Minuscule Docker Images That Could</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微小的Docker图像可以</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-minuscule-docker-images-that-could-22bac9ed950b?source=collection_archive---------4-----------------------#2019-07-26">https://betterprogramming.pub/the-minuscule-docker-images-that-could-22bac9ed950b?source=collection_archive---------4-----------------------#2019-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8420" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">根据您的需求自动创建微型docker图像</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0633716f0d2d5850b37df1177917b81c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9n8TVjkesFxTqhC2m7sUrg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ksharkovski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Kirill Sharkovski </a>在<a class="ae kv" href="https://unsplash.com/search/photos/different-sizes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="d169" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">一种奇怪的痴迷</h1><p id="1198" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在过去的几个月里，我发现自己被一个简单的问题困扰着。在运行我们的应用程序的同时，我们可以把Docker映像做得多小？</p><p id="9f69" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我知道，这是一件很奇怪的事情。</p><p id="de23" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在我们深入讨论细节和技术问题之前，我想解释一下为什么我对这个问题感兴趣，以及它与你有什么关系。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="cd36" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">为什么尺寸很重要</h1><p id="e9dc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通过减少我们放在Docker映像中的东西的数量，我们正在减少Docker容器中可能存在的安全漏洞的数量。此外，它使图像更加清晰，只包含应用程序运行所需的内容。</p><p id="42e2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有一个小优点是图片下载速度更快，但在我看来，这并不太重要。</p><p id="40bf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意:阿尔卑斯山的图像已经很小了，如果你在意大小的话，可能就足够了。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="32ff" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">分布式图像</h1><p id="43c8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><a class="ae kv" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank"> Distroless项目</a>提供了一个“Distroless”基础映像的集合，其中不包含任何包管理器、shells或其他您通常会在命令行中看到的实用程序。因此，我们不能使用像<code class="fe nc nd ne nf b">pip</code> <em class="nb"> </em>和<em class="nb"> </em> <code class="fe nc nd ne nf b">apt</code>这样的包管理器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Python 3发行版映像的Dockerfile文件</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图像中不存在画中画</p></figure><p id="a67b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通常，这个问题可以通过多阶段构建来解决:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用多阶段构建</p></figure><p id="8907" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">结果图像的大小为130MB。不算太差！作为比较，默认的Python图像是929MB，精简后的版本<code class="fe nc nd ne nf b">3.7-slim</code>是179MB，alpine图像<code class="fe nc nd ne nf b">3.7-alpine</code>是98.6MB，最后，示例中使用的distroless基本图像是50.9MB</p><p id="1bf7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，人们可能会正确地指出，在前面的例子中，我们复制了整个<code class="fe nc nd ne nf b">/usr/local/lib/python3.7/site-packages</code>目录，其中可能包含我们不需要的依赖项。但是，很明显，所有现有Python基础图像的大小差异是不同的。</p><p id="34c2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">写这篇文章的时候，Google distroless还不支持很多图像:Java和Python是实验性的，Python只支持2.7和3.5。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="882c" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">微小的图像</h1><p id="e13f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">回到我对创造小图像的痴迷。</p><p id="2c89" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最初，我想看看这些发行版映像是如何构建的。distroless项目利用了谷歌的<code class="fe nc nd ne nf b">bazel</code>构建工具。然而，设置Bazel和编写我自己的图像需要一些工作(老实说，重新发明轮子非常有趣，也很有教育意义)。我希望能够更容易地创建更小的图像，创建图像的行为应该非常简单，应该是微不足道的。没有配置文件，终端里只有一行:<code class="fe nc nd ne nf b">just build an image for &lt;application&gt;</code>。</p><p id="e0fc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，如果你想建立自己的形象，你应该知道一个独特的码头工人形象:<code class="fe nc nd ne nf b">scratch</code>。Scratch是一个“空”映像，它不包含任何文件(尽管默认情况下它有77个字节)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">刮痕图像</p></figure><p id="3ed3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">临时映像的想法是，我们可以从我们的主机复制任何依赖项，并在Docker文件中使用这些依赖项(比如在<code class="fe nc nd ne nf b">apt</code>中复制并从头开始安装依赖项),或者在Docker映像具体化后使用。这给了我们<em class="nb">完全</em>控制我们在Docker容器中放入的内容，因此，也完全控制了图像的大小。</p><p id="9a79" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，我们需要一些方法来收集这些依赖关系。像<code class="fe nc nd ne nf b">apt</code>这样的现有工具允许你下载软件包，但它们只限于你当前的机器，毕竟不支持Windows或MacOS。</p><p id="01b5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">因此，我开始构建自己的工具，它能够自动构建最小的基础映像来运行任何应用程序。我会使用Ubuntu/Debian包，获取它们(直接访问包服务器)，并递归地找到它们的依赖项。该工具应该总是下载软件包的最新版本稳定版本，尽可能减少安全风险。</p><p id="a9c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我把这个工具叫做<code class="fe nc nd ne nf b">fetchy</code>，因为…它获取…东西…这个工具通过命令行界面工作，尽管它也提供了一个API。</p><p id="769b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了用<code class="fe nc nd ne nf b">fetchy</code>(这里就拿Python来说吧)构建一个镜像，你要做的就是如下使用CLI:<code class="fe nc nd ne nf b">fetchy dockerize python</code>。你可能会被提示目标操作系统和代码名称，因为<code class="fe nc nd ne nf b">fetchy</code>目前只能使用基于Debian和Ubuntu的包。</p><p id="f2b3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，可选地，一些依赖项可能根本不使用(在我们的上下文中)，我们也可以排除它们。例如:Python依赖于perl，但是，Python在没有安装Perl的情况下也能运行良好。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="eb33" class="kw kx iq bd ky kz mw lb lc ld mx lf lg jw my jx li jz mz ka lk kc na kd lm ln bi translated">结果</h1><p id="81a4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">运行<code class="fe nc nd ne nf b">fetchy dockerize python3.5</code>时产生的Python映像只有35MB(我相信它可以进一步精简，也许是为了未来？)，看起来我们已经设法从distroless映像中删除了15MB。</p><p id="aa06" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以在这里查看到目前为止制作的所有图像:<a class="ae kv" href="https://hub.docker.com/r/fetchy/python" rel="noopener ugc nofollow" target="_blank">https://hub.docker.com/r/fetchy/</a></p><p id="e5c3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">项目可以在这里找到:<a class="ae kv" href="https://github.com/ThomasKluiters/fetchy" rel="noopener ugc nofollow" target="_blank">https://github.com/ThomasKluiters/fetchy</a></p><p id="f220" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您缺少功能，只需创建一个问题，我很乐意帮助您:)。此外——我目前正致力于将其他包管理器集成到fetchy中——这样就不再需要多阶段构建了。</p></div></div>    
</body>
</html>