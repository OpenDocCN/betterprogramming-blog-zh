<html>
<head>
<title>The Best Way to Bundle Dependencies in Android Using Kotlin DSL Scripts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin DSL脚本在Android中捆绑依赖关系的最佳方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-way-to-bundle-dependencies-in-android-using-kotlin-dsl-scripts-dc3478cff820?source=collection_archive---------11-----------------------#2019-10-17">https://betterprogramming.pub/best-way-to-bundle-dependencies-in-android-using-kotlin-dsl-scripts-dc3478cff820?source=collection_archive---------11-----------------------#2019-10-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0c35" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过单一的事实来源在一个地方维护所有的依赖关系。多模块项目的依赖管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a48e4708ef07b5919a4f46cae05ec2f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S5ciqV19_748mIj9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@javchz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈维·加西亚·查维斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3f98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将解释我们从祖先到现在维护依赖关系所遵循的模式。主要目标是维护一个关于依赖关系的真实的单一来源，这样就很容易维护和更新它们，而不需要深入到单独的<code class="fe lv lw lx ly b">build.gradle</code>文件中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2213" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">老办法</h1><p id="3258" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最初，我们用来声明依赖关系和其他属性，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app level @build.gradle</p></figure><p id="d173" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述声明依赖关系的方式并不是处理事情的最佳方式。</p><p id="ec8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有多个模块，比方说，我们有一些跨模块使用的公共依赖关系。在这种情况下，如果我们遵循上面的方法，我们需要在多个<code class="fe lv lw lx ly b">build.gradle</code>文件中声明它。</p><p id="cb86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，如果有更新，那么我们需要挖掘每一个包含这种依赖的<code class="fe lv lw lx ly b">build.gradle</code>，并需要在多个点更新版本。</p><p id="9f96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在维护大型项目时，这给我带来了许多问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a77b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">中间道路</h1><p id="8f22" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">解决上述问题的简单方法是使用项目级的<code class="fe lv lw lx ly b">build.gradle</code>来维护依赖项的版本，并在多个点上使用它们，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">项目级别@build.gradle</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app level @build.gradle</p></figure><p id="60cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题在某种程度上得到了解决，但是这种方法也有其缺点。其中之一是我们需要挖掘单个的<code class="fe lv lw lx ly b">build.gradle</code>文件来声明依赖关系，这不是一个好方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="53a9" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决办法</h1><p id="d764" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个解决方案，我们需要在一个文件中维护所有的依赖关系，并在多个模块中访问您想要的任何内容，遵循一个真实的来源。</p><p id="de3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得维护和更新依赖关系集合变得容易。</p><p id="5e7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个新人加入你的团队时，它也很有帮助，它提供了一个概览，一眼就能看到你正在使用的所有依赖项，而不是在模块级别挖掘单个的<a class="ae ky" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>文件。</p><ol class=""><li id="1353" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">创建一个<a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a> DSL脚本文件，如下所示。(我们把它命名为<code class="fe lv lw lx ly b">dependencies.gradle</code>，因为它包含了所有的应用依赖项。你可以给它起任何名字。)</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/9c0c2f8f0eb6dcd1ac2d0a176c1f2516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*mKG8rcjpkMyMQNcqN5FAEg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">dependencies.gradle</p></figure><p id="5b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.将所有依赖项和版本添加到这个文件中，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基本实现示例@dependencies.gradle</p></figure><p id="5e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.现在，为了让单个模块访问这个文件，我们需要在项目级<code class="fe lv lw lx ly b">build.gradle</code>中指定它的地址，如下所示。</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="cd9c" class="nt mh it ly b gy nu nv l nw nx">apply from: 'dependencies.gradle'</span></pre><p id="3f90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.一切都设置好了，现在我们可以单独访问依赖项了。模块如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">app level @build.gradle</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3e40" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">最佳实践</h1><p id="37df" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设我们有一个带有<code class="fe lv lw lx ly b">app</code>、<code class="fe lv lw lx ly b">device</code>、<code class="fe lv lw lx ly b">data</code>和<code class="fe lv lw lx ly b">library</code>模块的应用程序。为模块级依赖关系维护一个单独的数组，如下所示，以获得干净的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">模块级别@dependencies.gradle</p></figure><p id="f1b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们想将<code class="fe lv lw lx ly b">dependencies.gradle</code>文件中的<code class="fe lv lw lx ly b">deviceDependencies</code>访问到<code class="fe lv lw lx ly b">device</code> <strong class="lb iu"> </strong>模块的<code class="fe lv lw lx ly b">build.gradle</code> <strong class="lb iu"> </strong>文件中，我们只需如下调用一行代码:</p><pre class="kj kk kl km gt np ly nq nr aw ns bi"><span id="a1cb" class="nt mh it ly b gy nu nv l nw nx">implementation rootProject.ext.deviceDependencies.values()</span></pre><p id="22d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似地，我们在它们各自的<code class="fe lv lw lx ly b">build.gradle</code>文件中用上面的一行代码访问其他模块依赖关系。</p><p id="cf5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这解决了挖掘单个<code class="fe lv lw lx ly b">build.gradle</code>文件来检查和更新依赖关系的模糊性问题。这将是维护依赖关系的一种更好、更干净的方式。</p><p id="3a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有任何疑问或建议，请随时评论。</p><p id="eeee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>