# 如何在 Node.js 中编写回调

> 原文：<https://betterprogramming.pub/callbacks-in-node-js-how-why-when-ac293f0403ca>

## 它们听起来很难，但是让我们花点时间来解释为什么它们不难

![](img/184de42d5c6d79205e210b0dc361431a.png)

她在打电话，这完全相关。

如果你从 Node.js 开始，你会很快遇到回调。它们是如此流行的一个概念，以至于你已经听说过它们，但是可能还没有想太多。哦，现在你来了——嗨！

在我们定义回调之前，我们需要理解它们为什么存在。它们的存在是因为**节点的** **的异步性质。众所周知，异步编程“更好”但“更难”。**

# 好吧，最后一句有点过于简单了

让我们更深入一点，比较以同步方式编写的代码和异步方式编写的代码。

你马上会注意到的是**异步**版本是……丑陋的。看起来我们确实在为一点点收益把事情变得不必要的复杂，所以在你决定打包 JS 回到 PHP 之前，让我们马上讨论一下收益吧！

关于**异步**编程很酷的一点是，当你的代码等待某件事情被完成时(比如一个 API 调用或者来自一个神秘而遥远的数据库的响应),它可以做别的事情。换句话说，当一个进程花费很长时间时，你的代码不会被阻塞。这实际上是创建 **Node.js** 的主要原因:运行同步代码的服务器花费大量时间等待。如果服务器可以在等待 **I/O** 的同时处理请求，那么事情就会做得更快*(****I/O****代表* ***输入/输出*** *顺便说一下！)*

对于异步编程来说，事情确实有点复杂，尤其是当你开始的时候，但是这并不是一个很难理解的概念，而且好处是值得的。

对“**异步编程**”和“**无阻塞**”这样的术语有了更好的理解，我们来回答一个简单的问题。

# 什么是回调？

> **回调只是一个作为参数传递给另一个函数的函数，该函数将使用它(回调它)。**

下面是一个简单而又大胆的回调函数**的例子。**

```
fs.readFile(funFileName, **function(err, file)** **{
    if(err)
        handleError(err);
    console.log("file: ", file)
}**)
```

当`fs.readFile`完成获取文件`funFileName`时，它执行回调函数，如果抛出错误，该函数将处理错误，并将检索到的文件记录到控制台。

注意回调函数有两个参数:`err`和`file`。按照惯例，回调函数的第一个参数是一个错误。如果父函数抛出一个错误，它会在那里等待你去处理，如果没有抛出错误——这种情况时有发生——那么第一个参数应该是`null`。同样按照惯例，以下参数是响应数据。查阅 [**Error-First 回调**](https://nodejs.org/api/errors.html#errors_error_first_callbacks) 了解更多相关信息。

这一切都很好，但为什么不简单地将上面的内容写成这样:

```
let file = fs.readFile(fooFileName);console.log("file: ", file);
```

总之，*因为异步。*

在第二个例子中，当我们试图记录时，`file`将是未定义的，因为在到达`console.log()`之前，`fs.readFile`不会完成获取。

让我向你保证:

```
let file = 1+1;console.log("file: ", file);
```

会管用的。

对于只和同步编程打过交道的新人来说，感觉有点混乱；你过着充满爱和逻辑的幸福生活，突然，第 3 行可以在第 2 行之前执行！？为了确保万无一失，你应该在任何地方都使用回调吗？号码

当我们*不知道*什么时候会完成某件事的时候，就会使用回调。再一次，考虑类似 API 调用的东西，从数据库或硬盘驱动器的 I/O 获取数据。所有这些都需要时间，所以我们希望在我们等待的事件完成时调用我们的回调。因此有了术语**事件驱动编程。**

如果你觉得你只有*种*懂了，不要觉得孤独。像生活中的许多事情一样，需要一点实践经验才能真正明白。

在您获得实际操作经验之前，让我向您介绍一下您将遇到的下一个难题。

# 回调地狱

下面的代码不用研究的太透彻，看看就知道了:

恶。这可能不是你想要的代码，除非你真的喜欢三角形。

看起来像上面的代码被命名为**回调地狱**。Async JS 不需要*需要*这样，但是很容易不小心写了几个函数就意识到自己深陷回调地狱。又来了。

解释可以用来编写更干净的异步代码的许多策略超出了这篇介绍性文章的范围，但是当你准备好的时候，这里有一个甜蜜的链接可以让你得到一些想法:[callbackhell.com](http://callbackhell.com/)。

# TL；速度三角形定位法(dead reckoning)

回调是函数。您将它们传递给其他函数，这样它们就可以在适当的时候执行，也就是回调所需的事件发生的时候。这种做事方式是异步编程自带的，没那么难，值得。

# 即将推出…

如果你从回电开始，你会很快遇到承诺，你应该在承诺之前确保你真的得到了回电，但是你也应该有一天去了解承诺。因此，请继续关注更好的编程，以确保您了解即将发布的关于承诺的文章！