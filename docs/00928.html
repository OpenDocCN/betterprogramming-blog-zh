<html>
<head>
<title>Angular: Inheritance Without Effort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">棱角分明:不劳而获的传承</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-inheritance-without-effort-8200c8d87972?source=collection_archive---------2-----------------------#2019-07-29">https://betterprogramming.pub/angular-inheritance-without-effort-8200c8d87972?source=collection_archive---------2-----------------------#2019-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="10e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在我们的应用程序中使用继承的好方法，无需维护</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0b2a450859773b1fa6bc4574e9b00a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UCl98ol2h01vDIcPhbrHw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cinegeek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jakub Gorajek </a>在<a class="ae ky" href="https://unsplash.com/search/photos/app?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bc94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<a class="ae ky" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">打字稿</a>写的<a class="ae ky" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>使得在我们的组件中使用继承的概念成为可能。</p><p id="f9dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们需要子组件中的服务时，我们面临一个问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5436" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="2f04" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们从创建我们的<code class="fe mz na nb nc b">BaseComponent</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意装饰器<code class="fe mz na nb nc b">Component</code>不是必需的——我们不必在模块中声明这个类，因为它不是一个组件。我们也可以将它声明为一个抽象类，就像我们在常规OOP语言中所做的那样。</p><p id="ce48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建由<code class="fe mz na nb nc b">BaseComponent</code>扩展的两个组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们从一个组件导航到另一个组件时，日志会正确地打印在控制台中。</p><p id="7f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的子组件现在已经准备好了！</p><p id="062a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，在<code class="fe mz na nb nc b">AComponent</code>中，我想访问它的<code class="fe mz na nb nc b">ElementRef</code>(或其他服务):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fb6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们的问题。当我想在那个组件中注入<code class="fe mz na nb nc b">ElementRef</code>时，我必须调用方法<code class="fe mz na nb nc b">super()</code>并传递我们的另外两个类。试想一下，如果你在<code class="fe mz na nb nc b">BaseComponent</code>里有其他服务，那就很难管孩子了。</p><p id="7b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我在<code class="fe mz na nb nc b">BaseComponent</code>中添加或删除一个服务，我必须在它扩展的每个子组件中反映这些变化。</p><p id="f434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，有一个容易实现的解决方案。我们将手动将我们的服务注入到<code class="fe mz na nb nc b">BaseComponent</code>中。</p><p id="22b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，我将创建另一个包含我们的<code class="fe mz na nb nc b">Injector</code>的<code class="fe mz na nb nc b">BaseComponent</code>——姑且称之为<code class="fe mz na nb nc b">BaseWithInjectorComponent</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="3f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">主要变化在<code class="fe mz na nb nc b">constructor</code>中。我们没有使用它来让Angular注入我们的服务，而是手动执行这个操作。</p><p id="341e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把<code class="fe mz na nb nc b">Injector</code>放进去，然后我把每一个注射剂绑定到它相应的属性上。就是这样！</p><p id="8a3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以通过移除<code class="fe mz na nb nc b">constructor</code>中不必要的参数来重构我们的子组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切都像魔咒一样管用。但是，我们仍然必须注入<code class="fe mz na nb nc b">Injector</code> …我们可以做得更好！</p><p id="faac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是从基本构造函数中移除注入器，但是如果不在构造函数中实例化它，我们就不能访问<code class="fe mz na nb nc b">Injector</code>的实例。</p><p id="2c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们可以创建自己的<code class="fe mz na nb nc b">Injector</code>,当我们引导我们的应用程序，并把它作为一个单体。我们开始吧！</p><p id="1dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe mz na nb nc b">/src</code>中创建<code class="fe mz na nb nc b">app-injector.service.ts</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="afc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将使我们的定制注入器作为单例可用。我们在<code class="fe mz na nb nc b">AppModule</code>构造函数中设置了一次:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以在基本组件中安全地使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="efe6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试是否一切正常，我将修改<code class="fe mz na nb nc b">CComponent</code>和<code class="fe mz na nb nc b">DComponent</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，我们还有结构相同但没有<code class="fe mz na nb nc b">ActivatedRoute</code>的<code class="fe mz na nb nc b">DComponent</code>。</p><p id="94cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我从一个组件导航到另一个组件时，下面的结果演示了工作示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/ee7e72a78e7404d852e995b9c47fd2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTqqWtV7Z_mXy21IHo2XAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一切都在按预期运行！</p></figure><p id="f66f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">super()</code>方法中，我们的孩子现在没有这些依赖了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8700" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">继承的例外</h1><h2 id="35d4" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">ActivatedRoute</h2><p id="9fca" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你想在你的<code class="fe mz na nb nc b">BaseComponent</code>里注射<code class="fe mz na nb nc b">ActivatedRoute</code>就不能正常工作了。该类需要注入到组件中才能正确实例化。</p><p id="565a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果你想要路由状态，我推荐你看一看<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>模式，而不是使用继承，这会让你的生活更轻松。</p><p id="079c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是NGXS 的一个<a class="ae ky" href="https://ngxs.gitbook.io/ngxs/plugins/router#custom-router-state-serializer" rel="noopener ugc nofollow" target="_blank">例子。</a></p><p id="49de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以选择另一个状态管理库比如<a class="ae ky" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> NgRx </a>或者<a class="ae ky" href="https://netbasal.gitbook.io/akita/" rel="noopener ugc nofollow" target="_blank"> Akita </a>，或者用<a class="ae ky" href="https://angular.io/guide/rx-library" rel="noopener ugc nofollow" target="_blank"> RxJS </a>创建自己的。</p><h2 id="f75e" class="ng md it bd me nh ni dn mi nj nk dp mm li nl nm mo lm nn no mq lq np nq ms nr bi translated">ElementRef</h2><p id="6806" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在组件的<code class="fe mz na nb nc b">constructor</code>中声明的<code class="fe mz na nb nc b">ElementRef</code>提供了主机元素。在抽象的组件中，它是不可用的——即使你使用你的注入器，你也会得到<code class="fe mz na nb nc b">No provider for ElementRef</code>。</p><p id="bacf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，如果你需要它，你必须在你的子构造函数中传递它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0afb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">警告:小心使用</h1><p id="f0e2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">本例中使用的模式称为ServiceLocator模式。</p><p id="4ef0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它被称为反模式，所以请记住只有<strong class="lb iu">在基本组件中使用它。例如，FormBaseComponent、BaseComponent、… UI组件不关心这些依赖关系。</strong></p><p id="b641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于ServiceLocator模式的更多信息:【https://en.wikipedia.org/wiki/Service_locator_pattern T2】</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cf9d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4f1f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在有了一个在我们的应用程序中使用继承的好方法，不需要维护。继承对于避免组件中的重复动作非常重要，如果我们明智地使用它，我们可以构建一个智能组件。</p><p id="6eda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，它可能不是所有事情的最佳解决方案——在设计您的层次结构之前请三思。</p><p id="4963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝您愉快！</p></div></div>    
</body>
</html>