<html>
<head>
<title>TypeScript Functions: The ‘this’ Object and Overloads</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript函数:“this”对象和重载</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-typescript-functions-this-object-and-overloads-6d03a90f1821?source=collection_archive---------5-----------------------#2020-02-07">https://betterprogramming.pub/introduction-to-typescript-functions-this-object-and-overloads-6d03a90f1821?source=collection_archive---------5-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbd1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看JavaScript常量“this”以及如何在TypeScript中使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2506c1dab5dcc66fe16316c9a2ac4580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcjI9ASxo9cvQ6HgEOtZYA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@marvelous?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Marvin Meyer </a>在<a class="ae ky" href="https://unsplash.com/s/photos/tech?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数是一些小的代码块，它们接受一个输入，或者返回一个输出，或者有副作用，这意味着<code class="fe lv lw lx ly b">if</code>在函数之外修改变量。我们需要函数将代码组织成可重用的小块。如果没有函数，如果我们想重新运行一段代码，我们必须将它复制到不同的地方。函数对于任何类型脚本程序都是至关重要的。在本系列的这一部分中，我们继续研究TypeScript函数的不同部分，包括如何用TypeScript处理<code class="fe lv lw lx ly b">this</code>对象，以及重载函数。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a323" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">这个物体</h1><p id="15f6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果<code class="fe lv lw lx ly b">this</code>在用<code class="fe lv lw lx ly b">function</code>关键字声明的常规函数中被引用，那么<code class="fe lv lw lx ly b">this</code>对象不会被设置在包含<code class="fe lv lw lx ly b">this</code>的函数的箭头函数中。如果一个箭头函数在一个构造函数中，那么<code class="fe lv lw lx ly b">this</code>被设置为新的对象。如果它不在对象内部，那么箭头函数内部的<code class="fe lv lw lx ly b">this</code>在严格模式下就是<code class="fe lv lw lx ly b">undefined</code>。<code class="fe lv lw lx ly b">this</code>如果箭头功能在对象内部，将被设置为基础对象。然而，如果我们在一个箭头函数中引用<code class="fe lv lw lx ly b">this</code>，我们总是得到<code class="fe lv lw lx ly b">window </code>对象。例如，下面的代码无法编译和运行，因为TypeScript不允许我们的代码将全局变量作为<code class="fe lv lw lx ly b">this</code>的值:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fa58" class="nh mh it ly b gy ni nj l nk nl">const fn = () =&gt; this<br/>console.log(fn());</span></pre><p id="a5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">console.log</code>运行时，我们记录了<code class="fe lv lw lx ly b">window</code>对象。同样，如果我们运行这个:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4597" class="nh mh it ly b gy ni nj l nk nl">let obj = {}<br/>obj.f = () =&gt; {<br/>  return this;<br/>};<br/>console.log(obj.f());</span></pre><p id="952d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到和以前一样的东西。这与用<code class="fe lv lw lx ly b">function</code>关键字声明的传统函数形成对比。让我们看看如果我们用上面代码中的传统函数替换上面的函数会发生什么，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1336" class="nh mh it ly b gy ni nj l nk nl">const fn = function() {<br/>  return this<br/>};<br/>console.log(fn);</span></pre><p id="5a8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果在我们的<code class="fe lv lw lx ly b">tsconfig.json</code>中有<code class="fe lv lw lx ly b">noImplicitThis</code>标志，我们会从TypeScript编译器那里得到下面的错误:<code class="fe lv lw lx ly b">'this' implicitly has type ‘any’ because it does not have a type annotation.(2683)</code></p><p id="57b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们离让代码工作更近了，但它仍然无法编译。要修复这个错误，我们需要在函数签名中放一个假参数<code class="fe lv lw lx ly b">this: void</code>，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="858b" class="nh mh it ly b gy ni nj l nk nl">const fn = function(this: void) {<br/>    return this;<br/>};<br/>console.log(fn);</span></pre><p id="0000" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用上面的代码，我们使<code class="fe lv lw lx ly b">this</code>变量不可用。如果我们想用它做点什么，我们可以为<code class="fe lv lw lx ly b">this</code>而不是<code class="fe lv lw lx ly b">void</code>添加一个显式类型，让它做点什么。例如，如果我们想创建一个构造函数对象，我们可以编写类似下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们创建了一个名为<code class="fe lv lw lx ly b">Person</code>的接口，向<code class="fe lv lw lx ly b">person</code>对象的<code class="fe lv lw lx ly b">greet</code>函数中的<code class="fe lv lw lx ly b">this</code>对象添加数据类型。当我们调用<code class="fe lv lw lx ly b">greet</code>函数时，<code class="fe lv lw lx ly b">this</code>参数被忽略，因为我们将它作为第一个参数。TypeScript只查看参数中<code class="fe lv lw lx ly b">this</code>的类型，不会期望我们通过传入<code class="fe lv lw lx ly b">this</code>的参数来调用<code class="fe lv lw lx ly b">greet</code>函数。在定义了<code class="fe lv lw lx ly b">person</code>对象之后，我们就可以给它外部的<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">age</code>属性赋值了。当我们定义<code class="fe lv lw lx ly b">person</code>对象时，我们已经满足了接口中列出的要求，但是我们还应该给它分配一些有意义的值，这样我们就可以使用<code class="fe lv lw lx ly b">greet</code>函数。</p><p id="540d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们运行上面例子最后一行中的<code class="fe lv lw lx ly b">console.log</code>，我们得到<code class="fe lv lw lx ly b">Hi Jane. You’re 20 years old</code>。我们已经成功地为<code class="fe lv lw lx ly b">this</code>创建了一个数据类型，所以对于<code class="fe lv lw lx ly b">this</code>的值不会有任何歧义。这有助于开发人员理解<code class="fe lv lw lx ly b">this</code>在代码中有什么，因为这是JavaScript中比较令人困惑的方面之一。在普通JavaScript中，<code class="fe lv lw lx ly b">this</code>可以根据<code class="fe lv lw lx ly b">this</code>关键字在代码中的位置取不同的值。在传统函数中，<code class="fe lv lw lx ly b">this</code>的值就是函数本身。箭头函数不会改变<code class="fe lv lw lx ly b">this</code>的值，所以无论它在外面还是在箭头函数里面都是一样的。</p><p id="1ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用TypeScript，我们不能使用<code class="fe lv lw lx ly b">this</code>和传统函数来创建类。例如，如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="13eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们会得到错误<code class="fe lv lw lx ly b">Cannot find name ‘Person’. Did you mean ‘person’?(2552)</code>并且代码不会被编译。TypeScript不允许我们使用传统的函数作为类。要使用make类，我们必须使用<code class="fe lv lw lx ly b">class</code>语法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/01178c7f862619e06d579de6f8a5e70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ChueBDJNNgZ21JsT"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fe00" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">回调中的“this”参数</h1><p id="41f7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于用于事件侦听器的回调函数，我们传入的回调函数应该在接口中键入。例如，为了设置自定义输入控件组件的类型，我们可以编写如下代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d34a" class="nh mh it ly b gy ni nj l nk nl">interface InputElement {<br/>  addKeyUpListener(onclick: (this: void, e: Event) =&gt; void): void;<br/>}</span></pre><p id="3a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当人们使用这个控件时，他们可以写这样的东西让它运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用该库的开发人员试图引用<code class="fe lv lw lx ly b">this</code>，如下面的代码所示，该怎么办？：</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，TypeScript编译器将抛出一个错误，因为在<code class="fe lv lw lx ly b">InputElement</code>接口中<code class="fe lv lw lx ly b">this</code>被标记为<code class="fe lv lw lx ly b">void</code>类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d60c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">函数重载</h1><p id="ac97" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">重载一个函数就是用相同的名字创建不同签名的函数。这在JavaScript中是不允许的，因为函数是对象，我们不能多次重复声明同一个对象。然而，由于TypeScript是强类型的，这与JavaScript的动态性质相反，因此它必须找到一种方法来适应JavaScript的动态方面。为此，TypeScript为我们提供了一种用不同的签名重载函数的方法。要用TypeScript重载函数，我们只需在用相同的名称定义实际函数之前，用相同的名称编写多个函数签名。例如，我们可以这样写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fca3" class="nh mh it ly b gy ni nj l nk nl">function getPerson(person: { name: string, age: number }): { name: string, age: number };<br/>function getPerson(person: { name: string }): { name: string };<br/>function getPerson(person: any): any {<br/>  return person;<br/>}</span></pre><p id="513b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了上面的代码，我们有了一个<code class="fe lv lw lx ly b">getPerson</code>函数，它可以接受一个具有属性<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">age</code>的对象，或者只接受属性<code class="fe lv lw lx ly b">name</code>。冒号后面的返回类型可以是同时具有<code class="fe lv lw lx ly b">name</code>和<code class="fe lv lw lx ly b">age</code>属性的对象，也可以是只有<code class="fe lv lw lx ly b">name</code>属性的对象。这就是我们在上面的代码示例的前三行中所拥有的，在这里我们只是为我们的<code class="fe lv lw lx ly b">getPerson</code>函数定义了我们想要的签名。</p><p id="605b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在实际的<code class="fe lv lw lx ly b">getPerson</code>函数定义中，我们有了实际的函数定义。我们将参数和返回的类型标注为<code class="fe lv lw lx ly b">any</code>，这是可以的，因为我们已经定义了<code class="fe lv lw lx ly b">getPerson</code>分别接受和返回的参数和返回类型。我们可以调用<code class="fe lv lw lx ly b">getPerson</code>，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d5df" class="nh mh it ly b gy ni nj l nk nl">console.log(getPerson({ name: 'Jane', age: 20 }));<br/>console.log(getPerson({ name: 'Jane' }));</span></pre><p id="2ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的<code class="fe lv lw lx ly b">console.log</code>陈述中，我们得到:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e4a0" class="nh mh it ly b gy ni nj l nk nl">{name: "Jane", age: 20}<br/>{name: "Jane"}</span></pre><p id="0683" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图用一个我们没有在签名中定义的参数调用它，比如:<code class="fe lv lw lx ly b">console.log(getPerson({}))</code>我们会得到一个<code class="fe lv lw lx ly b">No overload matches this call</code>错误。</p><p id="d83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在传统函数中处理<code class="fe lv lw lx ly b">this</code>对象的主要方式是将它作为函数的第一个参数传入，然后通过为该类型定义一个接口来为其设置一个类型。TypeScript将忽略<code class="fe lv lw lx ly b">this</code>参数，并将其视为不存在。仅用于设置<code class="fe lv lw lx ly b">this</code>的数据类型。我们可以在TypeScript中重载函数，这在JavaScript中是不允许的。为此，我们只需为函数定义不同的签名并赋予它们相同的名称，然后在定义了函数将接受的签名后，用相同的名称定义函数。</p></div></div>    
</body>
</html>