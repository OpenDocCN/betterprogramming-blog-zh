<html>
<head>
<title>A Brief Intro to Multi-Threaded Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多线程编程简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-brief-intro-to-multi-threaded-programming-28abbc7e0e16?source=collection_archive---------7-----------------------#2019-07-11">https://betterprogramming.pub/a-brief-intro-to-multi-threaded-programming-28abbc7e0e16?source=collection_archive---------7-----------------------#2019-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6bb8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">别引用我的话</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c993986f3ed76f61950d30bc02d79e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j-pYvSqCrYbzKcea"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">赫克托·j·里瓦斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="3c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在我们开始讨论多线程程序之前，我们需要一些背景信息。尽管有很多关于这个概念的背景信息，我们将只讨论最基本的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b44d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">什么是线？</strong></h1><p id="2c5d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">线程是程序中连续的控制流。因此，它本质上是一系列程序指令，由调度程序管理，以便执行。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f84c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">什么是调度程序？</strong></h1><p id="e42b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在不要担心它。只要知道它是操作系统的一部分。如果您想了解更多信息，请参见此处的<a class="ae ky" href="https://en.wikipedia.org/wiki/Scheduling_(computing)" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="da5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您在一个超线程环境中使用一个具有多个物理内核或多个虚拟内核的系统。多线程是一种告诉操作系统这些是你想要运行的不同线程或指令块的方式。操作系统(调度程序)负责选择哪个线程获得CPU内核的时间，无论它们是物理的还是虚拟的。因此，如果您有一个运行在多线程上的程序，这将导致一些有趣的问题和一些非常强大的优势。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="af0c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">问题</h1><p id="0f9e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">以下面的代码为例。</p><h2 id="73e2" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">错误的多线程代码</strong></h2><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1299" class="mz md it nm b gy nq nr l ns nt"># include &lt;stdio.h&gt;<br/># include &lt;stdlib.h&gt;<br/># include &lt;pthread.h&gt;<br/># include &lt;unistd.h&gt;</span><span id="5e74" class="mz md it nm b gy nu nr l ns nt">volatile long int a = 0;</span><span id="d2f5" class="mz md it nm b gy nu nr l ns nt">void threadOne(void *arg) {<br/>  int i;</span><span id="627e" class="mz md it nm b gy nu nr l ns nt">  for (i = 1; i &lt; 500000; i++) {<br/>    a = a + i;<br/>  }<br/>}</span><span id="7e8e" class="mz md it nm b gy nu nr l ns nt">void threadTwo(void *arg) {<br/>  int i;</span><span id="82f4" class="mz md it nm b gy nu nr l ns nt">  for (i = 500000; i &lt;= 1000000; i++) {<br/>    a = a + i;<br/>  }<br/>}</span><span id="b9d4" class="mz md it nm b gy nu nr l ns nt">int main (int argc, char **argv) {<br/>  pthread_t one, two;<br/>  int i;</span><span id="5930" class="mz md it nm b gy nu nr l ns nt">  pthread_create(&amp;one, NULL, (void*)&amp;threadOne, NULL);<br/>  pthread_create(&amp;two, NULL, (void*)&amp;threadTwo, NULL);</span><span id="da33" class="mz md it nm b gy nu nr l ns nt">  pthread_join(one, NULL);<br/>  pthread_join(two, NULL);</span><span id="c6b1" class="mz md it nm b gy nu nr l ns nt">  printf("%ld\n", a);</span><span id="11d6" class="mz md it nm b gy nu nr l ns nt">}</span></pre><p id="2d77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序所做的就是把从1到190009000的所有数字相加。但是问题是它使用了两个执行线程。因此，一个线程将从1到500，000的数字相加，另一个线程将从500，000到1，000，000的数字相加。</p><p id="1060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们多次运行这段代码并观察。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="b50a" class="mz md it nm b gy nq nr l ns nt">Run #1 Output - 370752617319<br/>Run #2 Output - 336751282108<br/>Run #3 Output - 250846382315<br/>Run #4 Output - 314774608001</span></pre><p id="ee4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯…为什么我们每次运行这段代码都会得到不同的答案？理论上，与使用单线程相比，我们应该在一半的时间内得到正确的答案。</p><p id="3ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是另一个程序，它做同样的事情，但是只使用了一个线程。</p><h2 id="a7c6" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">单线程</strong></h2><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="1eb0" class="mz md it nm b gy nq nr l ns nt"># include &lt;stdio.h&gt;<br/># include &lt;stdlib.h&gt;<br/># include &lt;unistd.h&gt;</span><span id="50ce" class="mz md it nm b gy nu nr l ns nt">volatile long int a;</span><span id="0214" class="mz md it nm b gy nu nr l ns nt">int main (int argc, char **argv) {<br/>  int i;<br/>  a = 0;</span><span id="f6cc" class="mz md it nm b gy nu nr l ns nt">  for (i = 1; i &lt;= 1000000; i++) {<br/>    a = a + i;<br/>  } </span><span id="2b26" class="mz md it nm b gy nu nr l ns nt">  printf("%ld\n", a);<br/>}</span></pre><p id="d235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们运行这段代码几次。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0556" class="mz md it nm b gy nq nr l ns nt">Run #1 Output - 500000500000<br/>Run #2 Output - 500000500000<br/>Run #3 Output - 500000500000<br/>Run #4 Output - 500000500000</span></pre><p id="f1ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，我们每次都得到相同的值。那么多线程程序在做什么让它产生不同的不正确答案呢？</p><p id="40ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个线程从内存中加载变量<code class="fe nv nw nx nm b">A</code>，创建一个本地副本，给它添加一个值，然后将它存储回<code class="fe nv nw nx nm b">A</code>。问题是两个线程都使用全局变量<code class="fe nv nw nx nm b">A</code> <strong class="lb iu"> </strong>来增加它们的数量，但是它们并不同步工作。他们可以同时加载变量<code class="fe nv nw nx nm b">A</code>，给它加一个值，然后把它存储回<code class="fe nv nw nx nm b">A</code>。<strong class="lb iu"> </strong>取决于哪一个先将值存储回<code class="fe nv nw nx nm b">A</code>，一个更新会覆盖另一个。</p><p id="6923" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是同步这两个线程，这样它们就不会试图同时操作/访问<code class="fe nv nw nx nm b">A</code>。一种方法是使用互斥体(互斥)。你可以用代币做类比。假设现在每个线程只有拥有令牌才能访问<code class="fe nv nw nx nm b">A</code>。这意味着，如果线程一拥有令牌并且正在与<code class="fe nv nw nx nm b">A</code>一起工作，线程二就不能访问<code class="fe nv nw nx nm b">A</code> <strong class="lb iu"> </strong>，并且被迫等待，直到线程一释放令牌。</p><p id="62ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些代码。</p><h2 id="f915" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">更好但仍然不好的多线程代码</strong></h2><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="63a1" class="mz md it nm b gy nq nr l ns nt"># include &lt;stdio.h&gt;<br/># include &lt;stdlib.h&gt;<br/># include &lt;pthread.h&gt;<br/># include &lt;unistd.h&gt;</span><span id="e1ab" class="mz md it nm b gy nu nr l ns nt">pthread_mutex_t a_mutex = PTHREAD_MUTEX_INITIALIZER;<br/>volatile long int a = 0;</span><span id="bd44" class="mz md it nm b gy nu nr l ns nt">void threadOne(void *arg) {<br/>  int i;</span><span id="9d13" class="mz md it nm b gy nu nr l ns nt">for (i = 1; i &lt; 500000; i++) {<br/>    pthread_mutex_lock(&amp;a_mutex);<br/>    a = a + i;<br/>    pthread_mutex_unlock(&amp;a_mutex);<br/>  }<br/>}</span><span id="5106" class="mz md it nm b gy nu nr l ns nt">void threadTwo(void *arg) {<br/>  int i;</span><span id="a566" class="mz md it nm b gy nu nr l ns nt">  for (i = 500000; i &lt;= 1000000; i++) {<br/>    pthread_mutex_lock(&amp;a_mutex);<br/>    a = a + i;<br/>    pthread_mutex_unlock(&amp;a_mutex);<br/>  } <br/>}</span><span id="c2a0" class="mz md it nm b gy nu nr l ns nt">int main (int argc, char **argv) {<br/>  pthread_t one, two;<br/>  int i;</span><span id="f6af" class="mz md it nm b gy nu nr l ns nt">  pthread_create(&amp;one, NULL, (void*)&amp;threadOne, NULL);<br/>  pthread_create(&amp;two, NULL, (void*)&amp;threadTwo, NULL);</span><span id="c4f2" class="mz md it nm b gy nu nr l ns nt">  pthread_join(one, NULL);<br/>  pthread_join(two, NULL);</span><span id="c147" class="mz md it nm b gy nu nr l ns nt">  printf("%ld\n", a);</span><span id="8116" class="mz md it nm b gy nu nr l ns nt">}</span><span id="fd3d" class="mz md it nm b gy nu nr l ns nt">Run #1 Output - 500000500000<br/>Run #2 Output - 500000500000<br/>Run #3 Output - 500000500000<br/>Run #4 Output - 500000500000</span></pre><p id="13a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到有一些新的行锁定和解锁资源，防止被访问。现在我们得到了正确的输出！但是仍然有一个问题，因为这样使用线程是没有意义的。这是没有意义的，因为当线程一正在处理<code class="fe nv nw nx nm b">A</code>，<strong class="lb iu"> </strong>时，线程二被迫等待，直到线程一释放资源。理论上，这和使用单线程一样慢。</p><p id="5527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是时候解决它了！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="de45" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">解决办法</h1><h2 id="2988" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">好的多线程代码</strong></h2><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="d426" class="mz md it nm b gy nq nr l ns nt"># include &lt;stdio.h&gt;<br/># include &lt;stdlib.h&gt;<br/># include &lt;pthread.h&gt;<br/># include &lt;unistd.h&gt;</span><span id="ba76" class="mz md it nm b gy nu nr l ns nt">pthread_mutex_t a_mutex = PTHREAD_MUTEX_INITIALIZER;<br/>volatile long int a = 0;</span><span id="b126" class="mz md it nm b gy nu nr l ns nt">void threadOne(void *arg) {<br/>  int i;<br/>  long int localA = 0;</span><span id="44cc" class="mz md it nm b gy nu nr l ns nt">  for (i = 1; i &lt; 500000; i++) {<br/>    localA = localA + i;<br/>  }</span><span id="6933" class="mz md it nm b gy nu nr l ns nt">  pthread_mutex_lock(&amp;a_mutex);<br/>  a = a + localA;<br/>  pthread_mutex_unlock(&amp;a_mutex);<br/>}</span><span id="7161" class="mz md it nm b gy nu nr l ns nt">void threadTwo(void *arg) {<br/>  int i;<br/>  long int localA = 0;</span><span id="0872" class="mz md it nm b gy nu nr l ns nt">  for (i = 500000; i &lt;= 1000000; i++) {<br/>    localA = localA + i;<br/>  }</span><span id="f756" class="mz md it nm b gy nu nr l ns nt">  pthread_mutex_lock(&amp;a_mutex);<br/>  a = a + localA;<br/>  pthread_mutex_unlock(&amp;a_mutex);<br/>}</span><span id="128a" class="mz md it nm b gy nu nr l ns nt">int main (int argc, char **argv) {<br/>  pthread_t one, two;<br/>  int i;</span><span id="29f5" class="mz md it nm b gy nu nr l ns nt">  pthread_create(&amp;one, NULL, (void*)&amp;threadOne, NULL);<br/>  pthread_create(&amp;two, NULL, (void*)&amp;threadTwo, NULL);</span><span id="02a3" class="mz md it nm b gy nu nr l ns nt">  pthread_join(one, NULL);<br/>  pthread_join(two, NULL);</span><span id="82ac" class="mz md it nm b gy nu nr l ns nt">  printf("%ld\n", a);</span><span id="ebdd" class="mz md it nm b gy nu nr l ns nt">}</span></pre><p id="cdf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我们在每个函数中都使用了一个名为<code class="fe nv nw nx nm b">localA</code>的局部变量。我们这样做是为了让线程一将从1到500，000的数字添加到它自己的<code class="fe nv nw nx nm b">localA</code>中，同时，线程二将从500，000到1，000，000的数字添加到它自己的<code class="fe nv nw nx nm b">localA</code>中。在一个线程完成添加后，它将锁定<code class="fe nv nw nx nm b">A</code>，更新它，然后解锁它，以便下一个线程可以使用它。所以现在我们已经大大减少了一个线程等待另一个线程的时间。理论上，这应该比使用单线程快一倍。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e2f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><p id="0d93" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个博客是基于电脑爱好者的一个很棒的YouTube视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另请参见<a class="ae ky" href="https://pdfs.semanticscholar.org/a23b/22fb7bc0286101bdf4794e1e61bcad2fa896.pdf" rel="noopener ugc nofollow" target="_blank">多核处理器技术——优势与挑战</a>。</p></div></div>    
</body>
</html>