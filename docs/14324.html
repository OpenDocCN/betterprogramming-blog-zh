<html>
<head>
<title>How to Setup Data Classes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中设置数据类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-setup-data-classes-in-python-ffd85549523c?source=collection_archive---------5-----------------------#2022-11-29">https://betterprogramming.pub/how-to-setup-data-classes-in-python-ffd85549523c?source=collection_archive---------5-----------------------#2022-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b2f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用冻结和属性的Python数据类的高效数据管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ab613dc5277407ab9fdc08a8cde4e434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aQHX-MuSIXngmE6D"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aaron Burden </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2b94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在之前的帖子中，我介绍了Python <a class="ae ky" href="https://medium.com/@hrmnmichaels/python-decorators-816236066ed8" rel="noopener"> decorators </a>。今天我们将仔细看看一些内置的装饰器——特别是那些可以用于“管理数据”这个广泛主题的装饰器。这里，我指的是设计用来包含和存储数据的类(<code class="fe lv lw lx ly b">@dataclass</code>)，以及通过在Python中应用面向对象编程(OOP)风格来简化属性访问的类(<code class="fe lv lw lx ly b">@property</code>)。</p><h1 id="24b9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">数据类</h1><p id="3404" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Python中的<code class="fe lv lw lx ly b">dataclass</code>装饰器为一个类配备了存储数据的助手功能——比如自动添加构造函数、重载<code class="fe lv lw lx ly b">__eq__</code>操作符和<code class="fe lv lw lx ly b">repr</code>函数。</p><p id="afd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从一个例子开始:我们将设计一个简单的存储公司雇员的类。他们有一个名字，一份薪水，还有一个描述他们在公司工作年限的属性。</p><p id="f301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在传统Python中，您可能会按照以下代码行来实现这一点:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="8ff8" class="na ma it ly b be nb nc l nd ne">class Employee:<br/>    def __init__(self, name: str, salary: int, years_with_company: int = 0):<br/>        self.name = name<br/>        self.salary = salary<br/>        self.years_with_company = years_with_company<br/><br/>    def __eq__(self, other: "Employee"):<br/>        return (self.name == other.name and self.salary == other.salary and self.years_with_company == other.years_with_company)<br/><br/>first_employee = Employee("First", 80000)<br/>second_employee = Employee("First", 80000)<br/><br/>print(first_employee)<br/>print(first_employee == second_employee)</span></pre><p id="f2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码实现了一个具有前面描述的属性的类，并重载了equals ( <code class="fe lv lw lx ly b">__eq__</code>)操作符:如果没有这个操作符，检查<code class="fe lv lw lx ly b">first_employee == second_employee</code>将会失败，因为Python不知道如何有意义地比较这个特定的类，并退回到检查两个实例是否是相同的对象。</p><p id="a204" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们进一步注意到，字符串表示(<code class="fe lv lw lx ly b">print(first_employee)</code>)并没有给出太多信息，相反，它只是打印出类似于<code class="fe lv lw lx ly b">&lt;__main__.Employee object at 0x7f402e682670&gt;</code>的内容。</p><p id="df42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让Python来完成我们的工作，用<code class="fe lv lw lx ly b">dataclass</code>装饰器来装饰我们的类！</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="3be9" class="na ma it ly b be nb nc l nd ne">from dataclasses import dataclass<br/><br/>@dataclass<br/>class Employee:<br/>    name: str<br/>    salary: int<br/>    years_with_company: int = 0<br/><br/>first_employee = Employee("First", 80000)<br/>second_employee = Employee("First", 80000)<br/><br/>print(first_employee)<br/>print(first_employee == second_employee)</span></pre><p id="0232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这个装饰器使得Python自动为我们实现了一个构造函数，它的工作方式与我们之前实现的一样:它根据传递的参数分配实例属性，并且还可以处理可选参数。</p><p id="6322" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，在一个<code class="fe lv lw lx ly b">dataclass</code>中，equals操作符被覆盖以检查所有类属性的相等性，这与我们在上面手工实现的相同——在这个相等检查中正确地返回<code class="fe lv lw lx ly b">true</code>。</p><p id="05aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，类实例的字符串表示现在看起来更好了(例如，<code class="fe lv lw lx ly b">__repr__</code>被有意义地覆盖了)，产生了:<code class="fe lv lw lx ly b">Employee(name=’First’, salary=80000, years_with_company=0)</code>。</p><p id="ae6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">dataclass</code>装饰者做的<a class="ae ky" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank">甚至更多</a>——但是我们现在将关注这三个，可能是最常用的效果。</p><h1 id="cd6e" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">冻结数据类</h1><p id="57da" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">由于decorators实际上是函数，所以它们也可以带参数:<code class="fe lv lw lx ly b">frozen</code>是这里可能的参数之一。表示<code class="fe lv lw lx ly b">dataclass</code>建造后不能修改。特别是，以下内容将会失败:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="3693" class="na ma it ly b be nb nc l nd ne">from dataclasses import dataclass<br/><br/>@dataclass(frozen=True)<br/>class Employee:<br/>    name: str<br/>    salary: int<br/>    years_with_company: int = 0<br/><br/>employee = Employee("First", 80000)<br/><br/>employee.name = "Test"</span></pre><p id="71bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在很多情况下是有意义的。例如，<code class="fe lv lw lx ly b">dataclasses</code>用来纯粹表示不可变的数据集。</p><h1 id="4ab9" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">性能</h1><p id="828d" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">让我们恢复上面的<code class="fe lv lw lx ly b">frozen</code>更改，改为进行更细粒度的访问控制——全面实现访问实例属性的常用方式。</p><p id="e4e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个帖子不会是对OOP的介绍，简单来说:我们从来不想直接公开实例属性。相反，我们将有意义地把函数/变量分成<code class="fe lv lw lx ly b">public</code>、<code class="fe lv lw lx ly b">private</code>或<code class="fe lv lw lx ly b">protected</code>(我可能会偏离C++，但仅此而已)，并通过getter和setter方法公开公共变量——简而言之:属性。</p><p id="fe8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">getter方法负责返回变量值，setter用于设置变量值。这有助于更好地控制变量(例如，我们不希望将除数设置为0)。</p><p id="2c96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这次我将跳过实现getter/setter的繁琐示例，而是直接使用Python的<code class="fe lv lw lx ly b">property</code>装饰器展示解决方案:</p><pre class="kj kk kl km gt mw ly mx bn my mz bi"><span id="6f2f" class="na ma it ly b be nb nc l nd ne">from dataclasses import dataclass<br/><br/>@dataclass()<br/>class Employee:<br/>    _name: str<br/>    _salary: int<br/>    _years_with_company: int = 0<br/><br/>    @property<br/>    def name(self):<br/>        return self._name<br/><br/>    @property<br/>    def salary(self):<br/>        return self._salary<br/><br/>    @salary.setter<br/>    def salary(self, new_salary: int):<br/>        if new_salary &gt; self.salary:<br/>            self._salary = new_salary<br/>        else:<br/>            print("New salary must be greater than previous!")<br/><br/><br/>employee = Employee("First", 80000)<br/><br/>employee.salary = 75000<br/>employee.salary = 85000<br/>print(employee)<br/>employee.name = "this will fail"</span></pre><p id="000a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意变量的重命名。我们现在使用前导下划线(<code class="fe lv lw lx ly b">_</code>):按照Python惯例。这个变量被理解为<code class="fe lv lw lx ly b">protected</code>——这意味着您不应该直接访问它。</p><p id="046b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，请注意<code class="fe lv lw lx ly b">@property</code>和<code class="fe lv lw lx ly b">@salary.setter</code>以及修饰函数是如何用于定义getter和setter的，并且<code class="fe lv lw lx ly b">employee.salary</code>可以用作任何其他变量(在本例中，我们假设一个慷慨的HR部门，它只允许加薪)。我们还跳过了为<code class="fe lv lw lx ly b">name</code>实现一个setter，使这个变量成为只读的(同样，这不是一个非常现实的假设，尽管名称在将来可能会改变)。</p><p id="759d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我没有为<code class="fe lv lw lx ly b">years_with_company</code>实现类似的东西，但是它看起来是一样的。</p><p id="3054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们完成了“数据管理”这一主题。感谢收听，希望不久能看到你的另一篇文章！</p></div></div>    
</body>
</html>