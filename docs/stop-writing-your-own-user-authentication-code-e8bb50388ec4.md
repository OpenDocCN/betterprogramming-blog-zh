# 请停止编写您自己的用户验证代码

> 原文：<https://betterprogramming.pub/stop-writing-your-own-user-authentication-code-e8bb50388ec4>

## 是时候采用更安全的解决方案，节省时间和金钱了

![](img/1b4b53ca7f59ec0963bf17124ff5f5be.png)

凯尔·格伦在 [Unsplash](https://unsplash.com/s/photos/identity?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

大多数应用程序都需要某种认证。您可能是一名为大公司开发业务线应用程序的开发人员，这需要限制授权员工的访问权限并检查他们的权限。或者，您可能正在构建一个新的 SaaS 应用程序，并且希望用户创建和维护他们的个人资料。

在这两种情况下以及更多情况下，构建应用程序的第一步可能是创建身份验证和用户管理工作流。也就是说，至少创建一个注册表单和一个登录页面。身份验证是开发 web 应用程序的开发人员被要求实现的最常见的功能之一，但也是最容易被忽视的功能之一。

构建一个安全的认证系统是一项非常艰巨的任务，比你想象的要困难得多，而且很容易出错。更糟糕的是，错误会带来灾难性的后果。就其核心而言，用户管理和身份验证只需要几个 web 表单，看起来似乎是一项非常简单的任务。然而，细节决定成败，安全地构建这些东西(如果可能或者甚至需要的话，以一种有隐私意识的方式)并不是一件容易的事。

# 身份即服务

好消息是，您不需要部署自己的用户管理和身份验证逻辑。现在是 2020 年，我们有大量有效的身份即服务解决方案，可以非常容易地将身份安全地添加到您的应用程序中。

举几个比较热门的选项(按字母顺序排列): [Auth0](https://auth0.com/) 、 [Azure AD](https://azure.microsoft.com/en-ca/services/active-directory/) 、 [Google 身份平台](https://developers.google.com/identity)、 [Okta](https://www.okta.com/) 。

此外，还有社交网络的身份提供者，比如苹果的[、](https://developer.apple.com/sign-in-with-apple/)[脸书的](https://developers.facebook.com/docs/facebook-login/)、 [GitHub 的](https://developer.github.com/v3/guides/basics-of-authentication/)、 [Twitter 的](https://developer.twitter.com/en/docs/twitter-for-websites/log-in-with-twitter/login-in-with-twitter)等。这些对消费者来说非常容易使用，并为应用程序提供了对潜在大量数据的即时访问，但有时可能会对用户的隐私产生负面影响。

你没有理由不使用身份提供商服务。它们将为您节省大量开发时间，您可以将这些时间投入到构建实际的应用程序中，而且它们开箱即用，功能非常强大。然而，最重要的是，它们比开发自己的解决方案要安全得多。

# 安全是大量的

大多数身份提供者服务提供高级安全功能，例如支持多因素身份认证(MFA)，或安全证书或密钥(包括 U2F、FIDO2、 [WebAuthn](https://www.yubico.com/wp-content/uploads/2019/10/WebAuthn-Why-it-Matters-How-it-Works.pdf) 等)。

不要低估这一点的重要性:根据微软的一份[报告，启用 MFA 可以阻止 99.9%的账户泄露攻击。](https://www.microsoft.com/security/blog/2019/08/20/one-simple-action-you-can-take-to-prevent-99-9-percent-of-account-attacks/)

然而，还有另一个鲜为人知的方面，使使用身份提供商服务比使用自己的解决方案更安全:由于他们有大量的用户，他们可以更容易地看到模式并防止攻击。

通过拥有每天执行数百万次身份认证的数百万用户，这些大型身份提供商获得了足够的数据来构建人工智能模型，从而更好地识别可疑模式。

例如，假设您在加拿大的一个用户在家登录，两个小时后同一帐户在乌克兰成功使用。身份提供者服务会将其标记为可疑，并直接拒绝登录，或者至少要求另一种形式的验证(例如，MFA 令牌)。他们还可以通知受影响的用户和/或管理员。

# 常见异议

## 构建用户管理和认证逻辑并不难

注册和登录表单只是问题的一个方面。您需要处理的不仅仅是构建一个允许用户创建帐户并输入凭据的表单。

首先，您需要实现其他业务逻辑，例如强制执行密码安全规则(但是请听听 NIST 和[不要强制让密码定期过期](https://pages.nist.gov/800-63-FAQ/#q-b05)和[不要强加创造性的规则](https://pages.nist.gov/800-63-FAQ/#q-b06)，例如要求大小写字母和符号等等)，验证电子邮件地址和/或电话号码，并为用户提供重置密码的方法(安全地)。

在设计这些系统时，有许多细节需要记住，而且犯错误非常容易:非常大的公司被发现没有在他们的数据库中散列密码(或没有正确散列密码)，意外地在日志文件中以明文形式转储密码，拥有密码重置表单，这些表单很容易被社会工程利用，等等。

正确管理密码并不容易，这不应该让任何人感到惊讶。但是，您知道用户名也很难吗？例如，仅仅因为两个用户名看起来一模一样，[并不意味着他们比较的是同一个](https://medium.com/@italypaleale/when-zo%C3%AB-zo%C3%AB-or-why-you-need-to-normalize-unicode-strings-658866c02754)。詹姆斯·贝内特 2018 谈 [*嗨！我的名字是…*](https://www.youtube.com/watch?v=NIebelIpdYk) 对于用户名这样“简单”的东西可能会出什么问题，我有其他非常有趣的见解。

最后，应用程序可以极大地受益于许多提供商已经提供的高级安全功能，包括对多因素身份验证和安全令牌的支持。

## 这些服务认证服务并不总是免费的，尤其是当我的应用程序增长的时候

你知道还有什么不是免费的吗？遭到黑客攻击并不得不支付损害赔偿，包括直接补救成本(如果有的话)，紧急修复应用程序所花费的时间，以及失去用户的信任。

甚至在此之前，实现安全认证系统并维护，操作用户数据库等。，所有这些都是以开发和运营的时间和资源为代价的。

## 我是一个非常资深的开发人员，我知道如何建立一个安全的认证系统

首先，恭喜你，因为真正知道如何安全地构建这些东西并不像你想象的那么普遍。

然而，如果你真的是一个非常有经验的开发者，那么你的时间最好花在为用户提供更多价值的应用程序的其他部分上。

或者如果你真的想做 auth 系统，可以考虑加入微软、Auth0、脸书等公司。，并致力于改善他们的身份平台。

## 我想保持对我的用户的控制

首先，让我问你:为什么？除非你正在建设新的脸书——在这种情况下，是的，数据将是你最大的资产，你收集得越多越好——你可能真的不需要它。

此外，收集更多的用户数据甚至可能会增加您遵守 GDPR 等法规的成本。这也将使违规行为潜在的危害更大，代价更高。

我上面列出的大多数解决方案仍然可以让你深入了解你的用户和他们在做什么。

托管服务往往有点棘手，因此如果您担心将来迁移到其他地方的能力，您可能会考虑使用自托管身份服务器。但是请记住:这些系统维护起来更加复杂，并且由于数量的原因，通常缺乏可能的高级安全特性。

# 如何开始

我希望我说服你转而使用身份提供商。现在，让我们看看如何开始。

好消息是，我上面列出的所有四个提供商(Auth0、Azure AD、Google Identity Platform、Okta)和许多其他提供商都利用了相同的协议:OpenID Connect / OAuth 2.0。两者都是现代的行业标准协议，都有针对每种编程语言和框架的客户端库。

概括地说，这些步骤包括:

1.  向身份提供者注册您的应用程序。他们会给你一个应用程序 ID(或客户端 ID)和一个密钥(或客户端机密)。
2.  定义应用程序需要的权限。除了返回用户的个人资料，根据身份服务，您还可以访问更多数据，包括用户的电子邮件收件箱、云存储等。(例如，通过 Office 365 或 G 套件)
3.  在您的应用程序中包含客户端库。

我不会试图详细解释 OpenID Connect 是如何工作的，但总的流程包括应用程序将用户重定向到身份提供商服务器上的页面。用户将在那里完成身份验证流程，然后被重定向到您的应用程序，同时还有一个 JWT 令牌。

这个 JWT 令牌是加密签名的，并且有时间限制，可以用来为您的用户维护一个会话。也就是说，只要令牌有效，当它呈现给应用程序时，您就可以将请求视为来自令牌所属的用户。

同一个 JWT 令牌还包括关于用户的声明。这些信息因服务而异，但通常包括用户名、电子邮件地址和/或 ID。

您的应用程序可以使用这些声明来标识用户，并且您可以使用相同的用户 ID 来引用存储在您的应用程序中的数据。

如上所述，JWT 令牌是加密签名的，因此当您验证令牌的签名时，可以保证没有人篡改声明。

## 在客户端-服务器应用程序中使用 OpenID Connect

这些说明在很大程度上取决于你用来构建应用程序的语言或框架。

jwt.io 网站有一个全面的库列表来验证 jwt 代币。

对于一些栈，你也可以利用更高级的解决方案，比如 Node.js/Express.的 [express-jwt](https://github.com/auth0/express-jwt) 或 [passport](https://github.com/jaredhanson/passport)

## 在静态 web 应用或本地应用中使用 OpenID Connect

静态 web 应用程序(也称为 *JAMstack 应用程序*)和本地应用程序(例如，桌面或移动)使用 OpenID Connect 的方式略有不同。在 OAuth 2.0 规范中，这被称为 OAuth 2.0 规范中的*隐式流*。

隐式流不需要使用客户端机密:因为您的应用程序在客户端上运行，所以没有办法安全地分发它。

1.  您的应用程序将用户重定向到身份验证端点，确保查询字符串包含`scope=id_token`。
2.  用户通过身份提供者完成身份认证流程。
3.  用户被重定向到您的应用程序，JWT 会话令牌作为一个片段附加到页面的 URL 上(这个片段跟在`#`符号后面)。它位于一个叫做`id_token`的领域。
4.  您的应用程序从 URL 的片段中获取 JWT，然后验证它。如果它有效，您的用户就通过了身份验证，您可以使用 JWT 中的声明来获取用户的信息。

要在静态 web 应用程序中验证 JWT，您可以使用 [idtoken-verifier](https://github.com/auth0/idtoken-verifier) 模块。桌面和移动应用程序可以使用类似的库来开发它们。

当构建客户端应用程序时，如静态 web 应用程序或本机应用程序，确保使用 RSA-SHA256(在 JWT 标头中，`alg`必须是`RS256`)对令牌进行签名是很重要的，这是不对称的:令牌使用身份提供者中的秘密密钥进行签名，您的应用程序可以使用公共密钥来验证它们。另一种常见算法 HMAC-SHA256(或`HS256`)使用对称密钥来签署和验证令牌，这种算法不能安全地分发到客户端应用程序。

然后，您的客户端应用程序可以在向后端 API 服务器发出的每个请求中使用这个 JWT，通常在`Authorization`头或 cookie 中传递。在这种情况下，JWT 的行为就像任何其他会话令牌一样，但是具有独立的声明。

API 服务器将检查 JWT 是否存在，并再次进行验证；如果验证成功(并且令牌尚未过期)，它可以认为用户已经过身份验证，并从 JWT 内的声明中读取其用户 ID。