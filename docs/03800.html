<html>
<head>
<title>Build a Movie Tracking System Using React and Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React和Java构建一个电影跟踪系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-movie-tracking-system-using-react-and-java-522388965c55?source=collection_archive---------3-----------------------#2020-03-05">https://betterprogramming.pub/build-a-movie-tracking-system-using-react-and-java-522388965c55?source=collection_archive---------3-----------------------#2020-03-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">尽管普遍存在误解，React和Java可以成为很好的搭档</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c41e91b680930a840f22cbf61797ee49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HUMj6S512dXe6Db9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Avel Chuklanov 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2ac5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java已经出现有一段时间了。随着时间的推移，它不断适应和发展，Java社区仍然推出令人兴奋和有趣的项目。其中一个项目是Vert.x，这是一个用于在JVM上构建反应式应用程序的工具包。我从事企业Java系统的时间比我愿意承认的要长，我发现Vert.x是开发各种应用程序的一种有趣的方式。</p><p id="c02e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后是JavaScript，它几乎和Java一样存在了很长时间。它也随着时间的推移而增长。</p><p id="d92e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名不久前不再喜欢JavaScript的Java工程师，我最近开始喜欢使用Java家族的新成员React.js构建基于web的ui。</p><p id="06d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以当我决定整合一个网站来跟踪我想看的电影时，我决定同时使用两个框架:前端的React.js和后端的Vert.x。结果是一个既容易又令人愉快的项目。我会告诉你我是怎么做的。</p><h2 id="3234" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">项目的绘图摘要</h2><p id="f8ac" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，简单介绍一下这个项目。我和我的家人喜欢一起看电影，但是到了电影之夜，我们经常很难想出一个我们都同意的电影。这并不是说缺少这样的电影——只是我们总是在<em class="mt">其他</em>时间想起它们，而不记下它们。所以，这个项目的目的是记录我们没有看过的有趣的电影。</p><p id="f04b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在本文中，我将保持简单。我将省略许多可能构成一部电影的属性，只限于<em class="mt">名称</em>和<em class="mt">类型</em>。我还将省去后台数据存储—这里的示例将只在内存中存储电影。</p><p id="fd32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在创建React应用程序时，也可以使用各种快捷方式。我将有意绕过这些快捷方式，以免它们有损初学者对React的理解。</p><p id="64ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，虽然我白天处理微服务架构，但这个项目不会那样。相反，它将是一个简单的、自包含的web应用程序。如果你自己是一个面向微服务的程序员，你可以把这个项目想象成代表一个顶级服务，它反过来可以与一个较低级别的数据服务对话。</p><p id="eed2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是该应用程序的一个表示。我们将有一个React应用程序显示我们的用户界面。该应用程序与Vert.x应用程序进行对话，后者反过来将验证和保存我们的数据。这两个应用程序被捆绑到一个可执行文件中(技术上来说，是一个<em class="mt"> Java归档</em>或<em class="mt"> JAR </em>文件)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/eab8d163ae8c82dbafdab3e39c2d2a7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/0*I41dXUE0po9jrxzu"/></div></figure><h2 id="556c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">见见演员</h2><p id="bb6b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">大多数读者可能熟悉Java或Node.js，以及它们的生态系统。尽管如此，我们还是在这里简单总结一下。</p><ul class=""><li id="d8bd" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Node.js </strong> </a>是一个Javascript运行时环境，建立在Chrome的V8 Javascript引擎之上。它通常用于增强服务器端JavaScript webapps，但这并不是它的全部功能。我们也可以在Node.js上运行与web无关的软件。在本教程中，我们将只使用Node.js来帮助我们打包和测试我们的Web UI。</li><li id="916f" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> npm </strong> </a>(表面上代表<em class="mt">节点包管理器</em>)是Node使用的主包管理器。npm是一个安装在Node.js旁边的工具，它与npm软件包存储库进行通信。</li><li id="b9a0" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://www.java.com/en/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Java </strong> </a>，在这个上下文中，是两个东西。它是一种编程语言，但也是一个平台，主要由编译器和运行时环境(Java虚拟机，或JVM)组成。目前，Java主要有两个发行版:Oracle Java和OpenJDK。由于Oracle发行版的潜在许可问题，大多数开发人员现在选择OpenJDK。</li><li id="f8b3" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Maven </strong> </a>是Java生态系统中最常用的包管理器和构建系统。Maven可以通过名为mvn的命令行工具来使用。它还可以与大多数常见的Java IDEs很好地集成。<a class="ae ky" href="https://www.tutorialspoint.com/maven/maven_repositories.htm" rel="noopener ugc nofollow" target="_blank"> Maven Central </a>是存储Maven包的中央存储库。</li></ul><p id="1166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，关于React.js和Vert.x的文章也很多，但我们将在这里简单总结一下:</p><ul class=""><li id="97d8" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> React.js </strong> </a>是一个用于构建丰富的交互式用户界面的库。它通常被描述为MVC(模型/视图/控制器)应用程序中的“V”。</li><li id="488f" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Vert.x </strong> </a>是一个在JVM (Java虚拟机)上构建反应式应用的工具包。和Node.js一样，它是基于事件循环的<a class="ae ky" href="https://medium.com/@alexey.soshin/understanding-vert-x-event-loop-46373115fb3e" rel="noopener">,因此，它提供了一些工具来简化非阻塞代码的编写。它提供了额外的好处，比如它的</a><a class="ae ky" href="https://vertx.io/docs/vertx-core/java/#_verticles" rel="noopener ugc nofollow" target="_blank">角色模型</a>和<a class="ae ky" href="https://medium.com/@alexey.soshin/understanding-vert-x-event-bus-c31759757ce8" rel="noopener">事件总线</a>，以及多语言开发环境。</li></ul><p id="f9e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下表比较了每个生态系统的组成部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/a2c1a525968ac44ec93d4e20bb2c3d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Viy6MR9o9w3m-4BPtumyjA.png"/></div></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="a596" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">组装演员阵容</h1><h2 id="aeb2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Node.js和npm</h2><p id="b196" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们首先需要安装Node.js和npm。大多数Javascript开发人员已经安装了这些，可以跳到下一节。否则，要验证您是否安装了Node.js和npm，请转到命令行并键入<code class="fe oc od oe of b">node -v</code>。</p><p id="d8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果那不起作用，让我们安装它们。只需转到<a class="ae ky" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank"> Node.js安装页面，</a>找到您的平台的最新安装程序，并运行它。再次尝试<code class="fe oc od oe of b">node -v </code>和<code class="fe oc od oe of b">npm -v</code>。</p><p id="071e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，每个人都应该打印出自己的版本。(版本号可能不同，这没关系)。</p><p id="497b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt">注意:第三个二进制，</em><a class="ae ky" href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" rel="noopener"><em class="mt">npx</em></a><em class="mt">，也被安装。npx的目的是使运行托管在npm repo上的命令行工具变得更加容易。</em></p><h2 id="d888" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">Java和Maven</h2><p id="ccdc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们还需要安装Java和Maven。让我们首先验证是否安装了Java。在命令行中输入<code class="fe oc od oe of b">java -version</code>。如果成功了，恭喜你。如果没有，您需要安装它。</p><p id="98fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，如今OpenJDK比Oracle的Java发行版更受青睐。安装OpenJDK最简单的方法是转到<a class="ae ky" href="https://adoptopenjdk.net/index.html?variant=openjdk13&amp;jvmVariant=hotspot" rel="noopener ugc nofollow" target="_blank"> AdoptOpenJDK </a>。选择你想要的Java版本(一般是最新版本)和JVM口味(HotSpot就可以)。然后点击蓝色的下载按钮下载安装程序。启动安装程序并按照说明进行操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/4ae57eb445ab43bf9704f7eb2aab46ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pMLesypdtbx-qBDRiVPkg.png"/></div></div></figure><p id="a774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们检查一个Maven安装:<code class="fe oc od oe of b">mvn -v</code></p><p id="246b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个命令不起作用，您需要安装Maven。去<a class="ae ky" href="https://maven.apache.org/download.cgi" rel="noopener ugc nofollow" target="_blank"> Maven下载网站</a>下载<code class="fe oc od oe of b">.tar.gz</code>或者<code class="fe oc od oe of b">.zip</code>二进制文件(注意:不同的操作系统没有不同的包)。然后按照<a class="ae ky" href="https://maven.apache.org/install.html" rel="noopener ugc nofollow" target="_blank"> Maven安装页面</a>上的安装说明进行操作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/b64bcc9feb6f68d8bf4ddf5c7c1304a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NymFr7BsfgdJ3dqajNvAdw.png"/></div></div></figure><p id="587d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你完成后，<code class="fe oc od oe of b">mvn -v</code>应该打印版本号。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="7b7c" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">创建我们的React项目</h1><p id="2a1e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们开始有趣的事情吧。首先，我们需要一个地方来放置React应用程序。我们的目录结构将如下所示:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="fe82" class="lv lw it of b gy om on l oo op">movies/<br/>      react-app/<br/>      vertx/</span></pre><p id="1270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以从一个合适的位置开始(比如你的<em class="mt">目录下的</em>或<em class="mt">文件下的</em>目录)，创建一个<code class="fe oc od oe of b">movies/</code>目录，然后光盘放入其中。例如，在OS X:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="6cbe" class="lv lw it of b gy om on l oo op">$ cd ~/Documents<br/>$ mkdir movies<br/>$ cd movies</span></pre><h2 id="5384" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">创建-反应-应用</h2><p id="67ed" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在来创建我们的React应用程序。为此，我们使用一个叫做<a class="ae ky" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank">的工具来创建React App </a>。该工具由脸书创建，托管在国家预防机制上。我们将使用我前面提到的<code class="fe oc od oe of b">npx</code>库来执行它:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="db87" class="lv lw it of b gy om on l oo op">npx create-react-app react-app</span></pre><p id="3455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约一分钟后，您应该会有一个新的<code class="fe oc od oe of b">react-app/</code>子目录，其中包含一个skeletal React应用程序:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="c81e" class="lv lw it of b gy om on l oo op">$ cd react-app<br/>$ ls<br/>README.md   node_modules   package.json   public   src   yarn.lock</span></pre><p id="f314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最有趣的项目是<code class="fe oc od oe of b">public/</code>目录，其中包含HTML页面和图标等静态资产，以及<code class="fe oc od oe of b">src/</code>目录，其中包含应用程序的JavaScript和CSS。我们很快会检查内容。现在，让我们启动为我们创建的应用程序。</p><p id="9c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oc od oe of b">react-app/</code>目录中，运行<code class="fe oc od oe of b">$ npm start</code>。npm将在其默认端口3000下运行我们的代码，并为我们打开一个浏览器。几秒钟后，我们应该会看到这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/f62d03c00ec1427c5108f10bc399c013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFAawgQHFZ-AMhqZyofDmg.png"/></div></div></figure><p id="7ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，让我们对<code class="fe oc od oe of b">src/App.js</code>文件做一个快速编辑(如渲染应用程序本身所建议的)。例如，将<code class="fe oc od oe of b">&lt;p&gt;</code>内容修改如下:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="c12c" class="lv lw it of b gy om on l oo op">&lt;p&gt;<br/> I have edited &lt;code&gt;src/App.js&lt;/code&gt; and will save to reload.<br/>&lt;/p&gt;</span></pre><p id="4b73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存文件，然后不做任何其他事情，返回浏览器。您应该会看到您的更改自动反映出来:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/75364035694360e561dc041ba41e40f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3s8DNN0rnj6WeAEn3MN6A.png"/></div></div></figure><p id="7e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<em class="mt"> control-C </em>来停止您的npm进程。</p><h2 id="5a01" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">创建我们的基本文件</h2><p id="dfee" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将创建自己的文件，而不是浏览提供的样板文件。在这些目录中，我们必须做的第一件事是删除大部分文件。这是你在使用<code class="fe oc od oe of b">create-react-app</code>时会遵循的一个常见模式:首先，创建你的应用程序；接下来，删除大部分结果样板文件。</p><p id="5594" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从<code class="fe oc od oe of b">src/</code>目录开始。在那里，删除除了<code class="fe oc od oe of b">index.css</code>和<code class="fe oc od oe of b">index.js</code>之外的所有文件。接下来，<code class="fe oc od oe of b">cd</code>进入<code class="fe oc od oe of b">public/</code>目录，并删除除了<code class="fe oc od oe of b">index.html</code>文件之外的所有文件。</p><p id="dd81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将打开剩余的<code class="fe oc od oe of b">public/index.html</code>文件。将其内容替换为以下内容:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="7d98" class="lv lw it of b gy om on l oo op">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;title&gt;Movies&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将关注<code class="fe oc od oe of b">src/</code>目录。从那里，打开<code class="fe oc od oe of b">index.js</code>文件，并将其内容替换为</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="e848" class="lv lw it of b gy om on l oo op">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import './index.css';<br/>import App from './App';</span><span id="2e56" class="lv lw it of b gy or on l oo op">ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span></pre><p id="db67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们停下来看看这里发生了什么。当npm编译并运行一个像我们这样通过<code class="fe oc od oe of b">create-react-app</code>的应用程序时，它会寻找两个文件:<code class="fe oc od oe of b">index.html</code>和<code class="fe oc od oe of b">index.js</code>——一切都从那里开始。我们的<code class="fe oc od oe of b">index.html</code>文件非常简单——最有趣的部分是标识React应用程序的主要部分的那一行:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="5556" class="lv lw it of b gy om on l oo op">&lt;div id="root"&gt;&lt;/div&gt;</span></pre><p id="dcb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">反过来，<code class="fe oc od oe of b">index.js</code>是有效引导应用程序的文件。这发生在这一行:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="344c" class="lv lw it of b gy om on l oo op">ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span></pre><p id="f625" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在那里，我们调用<code class="fe oc od oe of b">ReactDOM.render()</code>，首先告诉它<em class="mt">渲染什么</em>，然后<em class="mt">在哪里渲染</em>。<em class="mt"> what </em>是一个<code class="fe oc od oe of b">App</code>组件的实例，我们接下来将讨论它。<em class="mt">其中</em>是由所提供的选择器(<code class="fe oc od oe of b">document.getElementById('root')</code>，我们已经在<code class="fe oc od oe of b">index.html</code>中定义了)标识的HTML元素。</p><p id="1ca7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还会注意到在<code class="fe oc od oe of b">index.js</code>之上有一些导入。使用导入是我们的应用程序的剩余组件(或<em class="mt">模块</em>)被有效吸收的方式。前两个，<code class="fe oc od oe of b">React</code>和<code class="fe oc od oe of b">ReactDOM</code>，显然是从框架本身导入模块。<code class="fe oc od oe of b">index.css</code>是下一个导入，所以让我们打开该文件，并用以下内容填充它:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="7947" class="lv lw it of b gy om on l oo op">body {<br/> margin: 0;<br/> font-family: 'Helvetica Neue', sans-serif;<br/> -webkit-font-smoothing: antialiased;<br/> -moz-osx-font-smoothing: grayscale;<br/>}</span></pre><p id="7878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，有这样一句台词:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="1cc1" class="lv lw it of b gy om on l oo op">import App from './App'’';</span></pre><p id="8b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉我们从同一个目录下的名为<code class="fe oc od oe of b">App.js</code>的文件中导入一个名为<em class="mt"> App </em>的模块(文件扩展名为<code class="fe oc od oe of b">.js</code>)。记住——我们的<code class="fe oc od oe of b">index.js</code>文件已经指定了一个<em class="mt"> App </em>组件实例来代替HTML文件中的<code class="fe oc od oe of b">document.getElementById(‘root’)</code>元素。</p><p id="dc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件是任何React应用程序的主要构建块。您可以将组件视为UI元素，它可以在屏幕上显示自身，对底层模型的更改做出反应，并导致该模型的更改。组件也有可以利用的生命周期挂钩。如您所料，组件可以嵌入到其他组件中。</p><p id="da1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过打开<code class="fe oc od oe of b">App.js</code>文件并用以下内容填充它来定义我们的<code class="fe oc od oe of b">App</code>组件:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="9ad2" class="lv lw it of b gy om on l oo op">import React, { Component } from "react";<br/>import './App.css';</span><span id="5a95" class="lv lw it of b gy or on l oo op">class App extends Component {</span><span id="23ea" class="lv lw it of b gy or on l oo op">  render() {<br/>    return (<br/>      &lt;div className="App"&gt;<br/>          &lt;h1&gt;<br/>            Movies<br/>          &lt;/h1&gt;<br/>      &lt;/div&gt;<br/>      )<br/>    }<br/>  }</span><span id="ffb5" class="lv lw it of b gy or on l oo op">export default App;</span></pre><p id="f8b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些需要注意的事情。首先，这个文件导入一个<code class="fe oc od oe of b">App.css</code>模块(它包含<a class="ae ky" href="https://www.w3.org/Style/CSS/Overview.en.html" rel="noopener ugc nofollow" target="_blank">级联样式表</a>，或者CSS，样式)。组件逻辑和样式通常以这种方式与React应用程序配对。因此任何<code class="fe oc od oe of b">Foo</code>组件都将在<code class="fe oc od oe of b">Foo.js</code>文件中定义其行为，在<code class="fe oc od oe of b">Foo.css</code>文件中定义其样式。</p><p id="aebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在<code class="fe oc od oe of b">App.css</code>中为我们的应用组件创建一个简单的样式:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="0cfa" class="lv lw it of b gy om on l oo op">.App {<br/>  text-align: center;<br/>  background-color: #fff;<br/>  min-height: 100vh;<br/>  display: flex;<br/>  flex-direction: column;<br/>  align-items: center;<br/>  justify-content: center;<br/>  font-size: calc(10px + 2vmin);<br/>}</span><span id="2e2a" class="lv lw it of b gy or on l oo op">h1 {<br/>  color: #666666;<br/>}</span><span id="62d8" class="lv lw it of b gy or on l oo op">.App-link {<br/>  color: #61dafb;<br/>}</span></pre><p id="2189" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了导入之外，<code class="fe oc od oe of b">App.js</code>的大部分都涉及声明一个扩展<code class="fe oc od oe of b">react.Component</code>的<code class="fe oc od oe of b">App</code>对象。通过扩展这个类，我们可以覆盖许多函数。也许其中最重要的是<code class="fe oc od oe of b">render()</code>函数。这里，我们返回定义组件如何呈现到屏幕上的标记。我们的<code class="fe oc od oe of b">App</code>组件返回以下标记:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="7b15" class="lv lw it of b gy om on l oo op">&lt;div className="App"&gt;<br/>  &lt;h1&gt;<br/>    Movies<br/>  &lt;/h1&gt;<br/>&lt;/div&gt;</span></pre><p id="265a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有前端经验的读者可能会认为他们将该标记识别为HTML。他们可能错了。虽然它看起来像HTML，但它实际上是另一种叫做<em class="mt"> JSX的语言。</em> JSX允许我们轻松地将标记与JavaScript混合起来创建UI元素。</p><p id="c8ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然JSX在很大程度上看起来像HTML，但还是有细微的差别。事实上，在上面的片段中有一个线索表明我们没有使用传统的HTML——我们的<code class="fe oc od oe of b">div</code>中的<code class="fe oc od oe of b">className</code>标签。如果这是纯HTML，我们会将<code class="fe oc od oe of b">App</code>声明为<code class="fe oc od oe of b">class</code>，但是因为<code class="fe oc od oe of b">class</code>是一个Javascript关键字，所以我们使用<code class="fe oc od oe of b">className</code>标签。</p><p id="4d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再次启动我们的应用程序，看看我们在哪里:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="55c0" class="lv lw it of b gy om on l oo op">$ npm start</span></pre><p id="e9cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到一个简单的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/e26e695c6c5a56899c5188080f18533c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTOfOO3X-UfzoFEeHVoWWQ.png"/></div></div></figure><p id="776b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来不错。现在让我们展示一些电影吧！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="3acb" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">显示电影</h1><p id="9ecd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，让我们概述一下我们将要构建的组件。我们将有三个，每个都用各自的颜色描绘如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/81b8f3b0027855142018ca86f20acaf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/0*Jdvvo7KjI7R5eBzJ"/></div></figure><p id="9b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">蓝色组件代表我们已经构建的<code class="fe oc od oe of b">App</code>组件。在<code class="fe oc od oe of b">App</code>中，我们将再添加两个组件:</p><ul class=""><li id="611b" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated"><code class="fe oc od oe of b">MovieForm</code>:橙色表示，这个组件允许我们在列表中加入新电影。</li><li id="80b4" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><code class="fe oc od oe of b">MovieList</code>:绿色表示，该组件将显示我们列表中的电影。</li></ul><h2 id="8dd9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">添加电影列表显示</h2><p id="1a75" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们首先在<code class="fe oc od oe of b">src/</code>目录下创建两个文件:<code class="fe oc od oe of b">MovieList.js</code>和<code class="fe oc od oe of b">MovieList.css</code>。后者应包含以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="94e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">MovieList.js</code>应该包含这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h2 id="9409" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">构造器</h2><p id="de9d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您会注意到的第一件有趣的事情是<code class="fe oc od oe of b">MovieList</code>覆盖了<code class="fe oc od oe of b">Component</code>的默认构造函数。名为<code class="fe oc od oe of b">props</code>的参数被传递给构造函数。我们一会儿将检查这个参数，但是注意它被传递给了超类的构造函数。这将设置一个<code class="fe oc od oe of b">props</code>类级变量的值。</p><p id="7d5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您还会看到一个绑定到当前<code class="fe oc od oe of b">App</code>实例的函数——例如<br/> <code class="fe oc od oe of b">this.toMovie = this.toMovie.bind(this);</code>。这允许从任何上下文中调用<code class="fe oc od oe of b">toMovie</code>函数(比如从UI事件中)。在开发React应用程序的过程中，你会经常这样使用你的函数。</p><h2 id="93d9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">呈现用户界面</h2><p id="bcf8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">和大多数组件一样，<code class="fe oc od oe of b">render()</code>函数是有趣的事情发生的地方。每当React确定需要在UI中重新显示任何组件时，都会调用每个组件的<code class="fe oc od oe of b">render()</code>函数。</p><p id="b986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oc od oe of b">MovieDisplay</code>的<code class="fe oc od oe of b">render()</code>函数中，我们创建了一个表格。记住，虽然看起来我们在使用HTML，但我们实际上是在写JSX。这意味着需要注意一些差异(例如前面提到的<code class="fe oc od oe of b">className</code>标签)。这也意味着我们可以很容易地混合JavaScript。让我们看一个例子:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="4e71" class="lv lw it of b gy om on l oo op">{this.props.movies.map(this.toMovie)}</span></pre><p id="69dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经创建了一个表，但是如何用数据行填充它呢？为此，我们可以使用JavaScript。</p><p id="0a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面，我们提到了传递给这个组件的构造函数的<code class="fe oc od oe of b">props</code>对象。我们很快就会看到，作为道具对象的一部分，我们提供了一系列电影。所以我们使用<code class="fe oc od oe of b">map()</code>迭代数组，并将<code class="fe oc od oe of b">toMovie</code>作为映射函数传递给它。(<a class="ae ky" href="https://en.wikipedia.org/wiki/Map_(higher-order_function)" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">这里</a>是一些解释映射函数的资源，如果你需要的话)。反过来，<code class="fe oc od oe of b">toMovie</code>接受一个电影对象并返回显示表格行所需的JSX标记:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="2a89" class="lv lw it of b gy om on l oo op">toMovie(m) {<br/>  var g = "?";<br/>  for (var i = 0; i &lt; this.props.genres.length; i++) { <br/>      if (this.props.genres[i].value == m.genre) {<br/>          g = this.props.genres[i].label;<br/>          break;<br/>      }<br/>  } <br/>  return (&lt;tbody key={m.guid}&gt;&lt;tr&gt;&lt;td&gt;{m.title}&lt;/td&gt;&lt;td&gt;{g}&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;)<br/> }</span></pre><p id="a912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="mt">注意:那个</em> <code class="fe oc od oe of b"><em class="mt">key</em></code> <em class="mt">标签是一个React需求。列表中每个唯一的UI项都必须有自己的键来唯一标识它。我们将为我们的电影分配GUIDs，因此我们将使用它们作为唯一的键。</em></p><p id="39e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将这个组件添加到<code class="fe oc od oe of b">App</code>组件中，看看我们得到了什么。在<code class="fe oc od oe of b">App.js</code>内，我们首先导入<code class="fe oc od oe of b">MovieList</code>:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="31d2" class="lv lw it of b gy om on l oo op">import MovieList from "./MovieList"</span></pre><p id="a194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就在导入语句下面，我们将创建一系列电影类型:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="d296" class="lv lw it of b gy om on l oo op">const genres = [ <br/>  {value: 'action', label: 'Action'}, <br/>  {value: 'comedy', label: 'Comedy'}, <br/>  {value: 'drama', label: 'Drama'}, <br/>  {value: 'thriller', label: 'Thriller'}, <br/>  {value: 'musical', label: 'Musical'} <br/>]</span></pre><p id="2ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后显示一组示例电影:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="2151" class="lv lw it of b gy om on l oo op">const movies = [ <br/>  {genre: 'action', title: 'Captain Marvel', guid: '6530b64b-0753-4629-a1bb-6716109b964b'}, <br/>  {genre: 'comedy', title: 'Groundhog Day', guid: 'ba5b9881-7128-485f-84d5-afc50f199b23'}, <br/>  {genre: 'action', title: 'Midway', guid: '2e93da48-d451-4df0-b77c-41dddde428ad'}, <br/>  {genre: 'drama', title: 'Dances With Wolves', guid: 'f207c1a0-3bef-48f1-a596-29b84887e94d'}, <br/>  {genre: 'thriller', title: 'Scream', guid: '3733f942-6a44-4eb9-af54-586d9d15eb67'} <br/>]</span></pre><p id="19ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在<code class="fe oc od oe of b">render()</code>函数中，在“Movies”标题下，我们将添加一个<code class="fe oc od oe of b">MovieList</code>的实例，将类型和电影传递给<code class="fe oc od oe of b">props</code>参数，然后传递给<code class="fe oc od oe of b">MovieList</code>的构造函数:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="595a" class="lv lw it of b gy om on l oo op">&lt;h1&gt;<br/>  Movies<br/>&lt;/h1&gt;<br/>&lt;div&gt;<br/>  &lt;MovieList movies={movies} genres={genres} /&gt;<br/>&lt;/div&gt;</span></pre><p id="7256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，让我们返回浏览器，看看我们得到了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/8517edf8dc3b10e6b37a34d91658b148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayaumBHAdQCoIKxSSfB0rg.png"/></div></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="ed84" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">添加电影入口表单</h1><p id="73d7" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在让我们添加创建电影的能力。我们首先在<code class="fe oc od oe of b">src/</code>目录中创建两个文件:<code class="fe oc od oe of b">MovieForm.js</code>和<code class="fe oc od oe of b">MovieForm.css</code>。后者应包含以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="9c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">MovieForm.js</code>应该包含这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h2 id="dc35" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">保持状态</h2><p id="48b3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">就像<code class="fe oc od oe of b">MovieList</code>，<code class="fe oc od oe of b">MovieForm</code>覆盖默认的构造函数并接受一个<code class="fe oc od oe of b">props</code>参数。它还将许多函数绑定到当前的<code class="fe oc od oe of b">MovieForm</code>实例——例如<br/> <code class="fe oc od oe of b">this.handleChangeTitle = this.handleChangeTitle.bind(this);</code></p><p id="a1fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，与<code class="fe oc od oe of b">MovieList</code>不同，在<code class="fe oc od oe of b">MovieForm</code>的构造函数中，我们为组件创建了一个<code class="fe oc od oe of b">state</code>对象。在这里，<code class="fe oc od oe of b">state</code>简单地表示我们当前正在创建的电影——当这个组件第一次加载时，它的状态将是一个对象，表示一部具有空白标题和空白类型的电影。</p><p id="1b63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在任何成分中，<code class="fe oc od oe of b">state</code>都是一种特殊的变量。它不仅维护组件的状态，而且在重新分配时，调用组件在UI中的重新呈现。</p><p id="a6c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，分配给<code class="fe oc od oe of b">state</code>变量的对象是不可变的。也就是说，虽然我们在技术上可以称之为<br/> <code class="fe oc od oe of b">this.state.title = 'Dances With Wolves'</code>，但我们强烈反对这样做。这样做意味着UI不会更新以反映新的状态。</p><p id="dbd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们应该这样称呼它:</p><p id="1368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">this.setState({ title: 'Dances With Wolves', genre: this.state.genre })</code></p><p id="1b44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们调用了<code class="fe oc od oe of b">setState</code>，UI将重新呈现组件以反映新的标题。</p><p id="c976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能认为以这种方式重新创建<code class="fe oc od oe of b">state</code>对象可能会很乏味。你是对的——尤其是对于更大的物体。这就是我们创建<code class="fe oc od oe of b">changeState()</code>函数的原因:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="0105" class="lv lw it of b gy om on l oo op">changeState(keyVal) {<br/>  this.setState( Object.assign({}, this.state, keyVal) ) <br/>}</span></pre><p id="5514" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法利用了<code class="fe oc od oe of b">Object.assign()</code>函数，该函数本质上合并了传递给它的所有参数(一个空对象、组件的当前状态以及我们想要对状态进行的更改),并返回一个表示新状态的新对象。例如，如果我们当前的状态看起来像这样:</p><p id="c38c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">{ title: 'Dances With Wolves', genre: 'Action' }</code></p><p id="26cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而我们调用<code class="fe oc od oe of b">changeState({ genre: 'Drama' })</code>，那么我们的新状态将会是这样的:</p><p id="6f6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">{ title: 'Dances With Wolves', genre: 'Drama' }</code></p><p id="01e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有两个利用<code class="fe oc od oe of b">changeState()</code>功能的事件处理程序:<code class="fe oc od oe of b">handleChangeGenre()</code>和<code class="fe oc od oe of b">handleChangeTitle()</code>。</p><h2 id="54ca" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">UI的连接状态</h2><p id="0e10" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们来看看<code class="fe oc od oe of b">render()</code>函数。正如我们之前讨论的，使用JSX可以很容易地将JavaScript混合到你的布局中。让我们看一个例子:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="fdd8" class="lv lw it of b gy om on l oo op">&lt;input type="text" value={this.state.title} onChange={this.handleChangeTitle} /&gt;</span></pre><p id="9c8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们创建了一个简单的文本字段。但是我们可以很容易地连接<code class="fe oc od oe of b">MovieForm</code>组件的状态来提供文本字段的值。我们可以很容易地将一个事件处理程序(前面提到的<code class="fe oc od oe of b">handleChangeTitle</code>)附加到文本字段。换句话说，每次这个文本域渲染时，它的值都会匹配<code class="fe oc od oe of b">state.title</code>。每当值发生变化时(例如，用户在文本字段中键入一个字符)，就会调用<code class="fe oc od oe of b">handleChangeTitle</code>事件处理程序，并更新状态。</p><p id="a108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还使用JavaScript创建一个<code class="fe oc od oe of b">select</code>小部件，从中选择流派，在这个块中:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="f484" class="lv lw it of b gy om on l oo op">&lt;select value={this.state.genre} onChange={this.handleChangeGenre}&gt;<br/>  {this.props.genres.map(this.toGenreOption)} <br/>&lt;/select&gt;</span></pre><p id="fc66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们创建一个标准的HTML select小部件，并使用Javascript来提供选项。正如我们对MovieList所做的那样，我们将为传递给该组件的构造函数的props对象提供一个流派数组。所以我们使用<code class="fe oc od oe of b">map()</code>迭代数组，然后将<code class="fe oc od oe of b">toGenreOption</code>函数作为映射函数传递。反过来，<code class="fe oc od oe of b">toGenreOption</code>接受一个流派对象并返回显示<code class="fe oc od oe of b">select</code>项目所需的JSX标记:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="d064" class="lv lw it of b gy om on l oo op">return (&lt;option key={g.value} value={g.value}&gt;{g.label}&lt;/option&gt;)</span></pre><p id="8810" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将这个组件添加到<code class="fe oc od oe of b">App</code>组件中，看看我们得到了什么。在<code class="fe oc od oe of b">App.js</code>中，我们首先导入<code class="fe oc od oe of b">MovieForm</code>:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="b7ef" class="lv lw it of b gy om on l oo op">import MovieForm from "./MovieForm"</span></pre><p id="73fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在<code class="fe oc od oe of b">render()</code>函数中，在“Movies”标题下，我们将添加一个<code class="fe oc od oe of b">MovieForm</code>的实例，将流派传递给<code class="fe oc od oe of b">MovieForm</code>的构造函数的props参数:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="4dce" class="lv lw it of b gy om on l oo op">&lt;h1&gt;<br/>  Movies<br/>&lt;/h1&gt;<br/>&lt;div&gt;<br/>  &lt;MovieForm genres={genres} /&gt;<br/>&lt;/div&gt;</span></pre><p id="53ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到浏览器，看看我们得到了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/4988ea09a64ba10157aca7d9819490ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUpx27Dkl87NGFCFcsK4_g.png"/></div></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="e4ba" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">创建我们的后端电影服务</h1><p id="a60e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">截至目前，我们的电影形式并没有真正服务于任何目的。这将会改变，但首先，让我们创建我们的Vert.x电影服务。</p><h2 id="9f12" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">垂直x结构</h2><p id="4b90" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">是时候设置我们的Vert.x应用程序了。如果您使用IntelliJ或Eclipse之类的IDE，您可以使用它来自动生成Maven项目。在这里，我们只是用手来做。在我们的顶级目录中，我们将在<code class="fe oc od oe of b">react-app</code>目录旁边创建一个<code class="fe oc od oe of b">vertx</code>目录。在其中，我们将创建以下结构:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="e4e2" class="lv lw it of b gy om on l oo op">├── pom.xml<br/>├── src/<br/>│   ├── main/<br/>│   │   └── java/<br/>│   │   └── resources/</span></pre><p id="cdaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是最小Maven项目的默认目录结构。正如您所猜测的，包含了项目的Java源代码。<code class="fe oc od oe of b">src/main/resources</code>包含要打包到Java应用程序中的资源(配置文件、图像等)。通常，我们也会有<code class="fe oc od oe of b">src/test/java</code>和<code class="fe oc od oe of b">src/test/resources</code>目录，但是为了简洁起见(并且<em class="mt">而不是</em>不喜欢测试！)我们在这里省略了那些。</p><p id="f735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">pom.xml</code>是告诉Maven项目是如何构建的文件。我们的大部分文件将用于配置Vert.x。将以下文件的内容复制到您的<code class="fe oc od oe of b">pom.xml</code>中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="8c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您愿意，您可以更改<code class="fe oc od oe of b">groupId</code>(例如，更改为您自己的反向域名)、<code class="fe oc od oe of b">artifactId</code>和/或<code class="fe oc od oe of b">version</code>。其余的应该基本保持不变。</p><h2 id="7744" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">垂直x垂直和控制器</h2><p id="4a45" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在让我们写一些代码。Vert.x提供了一种actor模型，由称为<a class="ae ky" href="https://vertx.io/docs/vertx-core/java/#_verticles" rel="noopener ugc nofollow" target="_blank">vertices</a>的独立组件组成。这是一个强大的工具，我们可以根据自己的意愿选择使用多少。这里，我们将创建一个verticle作为应用程序的启动点。</p><p id="1fa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oc od oe of b">src/main/java</code>目录中，我们将创建一个名为<code class="fe oc od oe of b">com.me</code>的包(或者，如果您愿意，您可以使用自己的反向域名)。这意味着我们将创建子文件夹<code class="fe oc od oe of b">com/me</code>。</p><p id="c06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们停下来检查一下我们的总体目录结构，它应该是这样的:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="213d" class="lv lw it of b gy om on l oo op">├── react-app<br/>│   <em class="mt">(stuff)</em><br/>├── vertx<br/>│   ├── pom.xml<br/>│   ├── src/<br/>│   │   ├── main/<br/>│   │   │   ├── java/<br/>│   │   │   │   ├── com/<br/>│   │   │   │   │   └── me/<br/>│   │   │   └── resources/</span></pre><p id="713e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在新的<code class="fe oc od oe of b">me/</code>目录中，我们将添加一个包含以下内容的<code class="fe oc od oe of b">Main.java</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="14c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在同一个目录中，我们将创建一个包含以下内容的<code class="fe oc od oe of b">AppServer.java</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="38b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们做了什么？Vert.x期望一个verticle实例作为应用程序的入口点，所以我们在<code class="fe oc od oe of b">Main</code>类中创建了一个。这个类实际上只是用来实现<code class="fe oc od oe of b">io.vertx.core.AbstractVerticle</code>并覆盖那个类的<code class="fe oc od oe of b">start()</code>生命周期方法。在<code class="fe oc od oe of b">start()</code>中，我们简单地创建了一个<code class="fe oc od oe of b">AppServer</code>类的实例并运行它。注意，我们将一个<code class="fe oc od oe of b">vertx</code>参数传递给了<code class="fe oc od oe of b">AppServer</code>的<code class="fe oc od oe of b">run()</code>方法。这是<code class="fe oc od oe of b">io.vertx.core.Vertx</code>的一个实例，在<code class="fe oc od oe of b">AbstractVerticle</code>中定义。</p><p id="d327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道Vert.x如何知道使用<code class="fe oc od oe of b">Main</code>作为程序的入口点。很简单——我们之前在<code class="fe oc od oe of b">pom.xml</code>文件中将其定义为<code class="fe oc od oe of b">properties : main.verticle</code>值。</p><p id="3232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">AppServer</code>类本质上是我们的webapp的控制器。从技术上来说，它只是一个普通的老类，从<code class="fe oc od oe of b">java.lang.Object</code>直接延伸而来。我们已经创建了一个方法，<code class="fe oc od oe of b">run()</code>，它完成了所有的工作。</p><p id="e485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oc od oe of b">run()</code>中，我们首先创建一个<code class="fe oc od oe of b">io.vertx.core.http.HttpServer</code>的实例(如前所述，它利用了底层的Jetty)。接下来，我们创建一个<code class="fe oc od oe of b">io.vertx.ext.web.Router</code>实例，它将HTTP请求路由到处理程序。处理程序实际上是<code class="fe oc od oe of b">io.vertx.coreHandler&lt;RoutingContext&gt;</code>类的实例(它定义了一个<code class="fe oc od oe of b">void handle(RoutingContext ctx)</code>方法)，但是我们利用Java 8 lambdas来实现这些处理程序。例如，这个块定义了对<em class="mt"> </em> <code class="fe oc od oe of b"><em class="mt">/movies</em></code>路径的GET请求的处理程序:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="0b33" class="lv lw it of b gy om on l oo op">router.get("/movies").handler(…)</span></pre><p id="2c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而<code class="fe oc od oe of b">router.post("/movies").handler(…)</code>为相同路径的POST请求定义了一个处理程序。</p><h2 id="de87" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">经理人</h2><p id="8996" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">处理程序本身很简单。它们只是向调用者返回一个纯文本响应。但是，请注意，我们并不是从一个方法中直接返回文本。因为Vert.x是一个反应式框架，运行在一个<a class="ae ky" href="https://medium.com/@alexey.soshin/understanding-vert-x-event-loop-46373115fb3e" rel="noopener">事件循环</a>上，所以我们需要明确说明何时准备好将响应发送回调用者。</p><p id="30b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以首先，<code class="fe oc od oe of b">handler()</code>方法被传递了一个<code class="fe oc od oe of b">RoutingContext</code>实例，从这个实例中它可以派生出要使用的<code class="fe oc od oe of b">HttpServerResponse</code>。然后，我们简单地调用<code class="fe oc od oe of b">HttpServerResponse</code>的<code class="fe oc od oe of b">end()</code>方法将响应发送回调用者。</p><p id="80c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们把所有东西粘在一起，告诉<code class="fe oc od oe of b">HttpServer</code>使用<code class="fe oc od oe of b">Router</code>作为它的请求处理器，然后启动并监听端口80。我们提供了一个lambda，在服务器尝试启动后调用，告诉我们启动是否成功。我们使用这种回调方法，因为我们不想在任何事情上阻塞Vert.x的线程——包括等待服务器启动。</p><p id="d97b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们测试一下我们有什么。从我们项目的<code class="fe oc od oe of b">vertx/</code>目录中的命令行，我们将通过运行<code class="fe oc od oe of b">mvn clean install</code>来编译和构建应用程序。</p><p id="559d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦完成，在目录中运行一个<code class="fe oc od oe of b">ls</code>来看看我们得到了什么。您应该注意到一个新的<code class="fe oc od oe of b">target/</code>子目录。里面有我们刚刚生成的所有构建工件。最重要的是<code class="fe oc od oe of b">movies-app-1.0.0-SNAPSHOT-fat.jar</code>。这是一个完整的、自包含的服务器端应用程序，包括一个基于Netty的嵌入式web服务器。</p><p id="5c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们现在运行它。在示例目录中，运行以下命令:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="e9c9" class="lv lw it of b gy om on l oo op">java -jar target/movies-app-1.0.0-SNAPSHOT-fat.jar</span></pre><p id="17b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该会看到类似这样的内容:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="057d" class="lv lw it of b gy om on l oo op">Movie app starting…<br/>Feb 27, 2020 7:23:37 AM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer<br/>INFO: Succeeded in deploying verticle<br/>Feb 27, 2020 7:23:37 AM com.me.AppServer<br/>INFO: MovieApp HTTP server started on port 80</span></pre><p id="39c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到web浏览器，输入<code class="fe oc od oe of b">http://localhost/movies</code>(这将向端口80发出GET请求)。您应该会看到类似这样的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/8ba9fc7827430bff73fbe955ee972005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qmLQQq-t2zpRr4EaUbxNA.png"/></div></div></figure><h2 id="b2a9" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">保存电影实例</h2><p id="bc7e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了简洁起见，我们实际上不会将我们的电影保存到数据库中(在本教程之后，你可以将它作为一个家庭作业项目。)相反，我们将简单地在内存中存储电影实例。这意味着当Vert.x服务器重新启动时，电影将会消失，但这对我们的目的来说很好。</p><p id="f85e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个模型来表示我们的电影，所以在那个<code class="fe oc od oe of b">me/</code>目录中，添加一个<code class="fe oc od oe of b">Movie.java</code>文件。我们的模型将包括以下字段:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="9853" class="lv lw it of b gy om on l oo op">private String genre;<br/>private String title;<br/>private UUID guid;</span></pre><p id="5c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，有了所有的仪式，我们的类将看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="3423" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们充实我们的<code class="fe oc od oe of b">AppServer</code>类来保存电影。添加此方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="c529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法检索请求体(<code class="fe oc od oe of b">ctx.getBodyAsString()</code>)，JSON将其解码成电影。它执行一些基本的输入验证，在验证失败时返回HTTP状态400和简单的JSON错误消息。</p><p id="dbf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设验证通过，我们接下来将Vert.x的事件总线引入我们的应用程序。事件总线为Vert.x应用程序的组件提供了一种相互通信的方式，同时保持完全解耦。他们通过发布和消费消息来做到这一点。从概念上讲，您几乎可以将事件总线视为一个消息队列。</p><p id="0f81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应用程序中的事件总线通信将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/357db2053d0274a21c7b65fd678cdd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*esL4XJDrP5eGB267"/></div></div></figure><p id="0430" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">AppServer</code>将向两个事件总线“通道”发布消息:<code class="fe oc od oe of b">getMovie()</code>方法将发布到“service.movie-get”，而<code class="fe oc od oe of b">postMovie()</code>方法将发布到“service.movie-add”。我们很快将创建一个名为<code class="fe oc od oe of b">MovieRepository</code>的垂直平台，它将消费这些消息，处理它们，然后通过相同的通道发送消息作为响应。</p><p id="725d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过Vertx实例获得对事件总线的引用。然后我们在<code class="fe oc od oe of b">service.movie-add</code>频道上发布一条消息，连同我们的新电影实例作为有效载荷。因为我们应该期待来自<code class="fe oc od oe of b">MovieRepository</code>消息消费者的消息响应，所以我们提供了一个消息响应处理程序。假设一切顺利，我们将把消息体作为JSON返回给最初的HTTP调用者。如果出现故障，我们将发送一个通用故障(500)响应。</p><p id="ed90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用<code class="fe oc od oe of b">postHandler()</code>请求处理器方法，我们将修改我们的<code class="fe oc od oe of b">post</code>请求处理器(在<code class="fe oc od oe of b">run()</code>方法中),如下所示:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="68cd" class="lv lw it of b gy om on l oo op">router.post("/movies").handler(ctx -&gt; postMovie(ctx, vertx));</span></pre><p id="1973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了正确处理POST请求，我们还需要将下面一行添加到我们的<code class="fe oc od oe of b">run()</code>方法中(就在我们创建<code class="fe oc od oe of b">router</code>实例的那一行的下面):</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="0c6a" class="lv lw it of b gy om on l oo op">router.route().handler(BodyHandler.create());</span></pre><p id="495e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将创建第二个verticle作为我们的数据存储库。如前所述，我们将只在内存中存储电影。但是可以把这个类想象成一个典型的存储库或与数据库通信的对象。</p><p id="cdc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe oc od oe of b">me/</code>目录下，创建一个包含以下内容的<code class="fe oc od oe of b">MovieRepository.java</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="f3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，像我们的<code class="fe oc od oe of b">Main</code>类一样，这个类也扩展了<code class="fe oc od oe of b">AbstractVerticle</code>并覆盖了<code class="fe oc od oe of b">start()</code>方法。这里，<code class="fe oc od oe of b">start()</code>使用verticle的Vertx实例来创建两个事件总线消费者。第一个监听<code class="fe oc od oe of b">service.movie-add</code>通道，并提供一个处理程序，该处理程序将来自该通道的消息解码为<code class="fe oc od oe of b">Movie</code>实例，给电影分配一个<code class="fe oc od oe of b">UUID</code>，并将它们“持久化”到内存中的<code class="fe oc od oe of b">List</code>。然后它向事件总线发布一条消息作为响应，包含电影(现在有了新的<code class="fe oc od oe of b">UUID</code>)作为主体。</p><p id="16e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您大概可以猜到，这个消费者将处理由<code class="fe oc od oe of b">AppServer.postMovie()</code>发布的消息。</p><p id="d076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个消费者订阅了<code class="fe oc od oe of b">service.movie-get</code>频道。它的处理程序会立即发布一条消息作为响应，消息体包含完整的持久电影列表。</p><p id="e8d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们回到我们的<code class="fe oc od oe of b">AppServer</code>类来利用第二个消费者。添加此方法:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="eb9d" class="lv lw it of b gy om on l oo op">private void getMovie(RoutingContext ctx, Vertx vertx) {<br/>  vertx.eventBus().request("service.movie-get", "", res -&gt; {<br/>    if ( res.succeeded() ) {<br/>      ctx.response()<br/>      .putHeader("content-type", "application/json")<br/>      .end( res.result().body().toString() );<br/>    } else {<br/>      ctx.fail( res.cause() );<br/>    }<br/>  });<br/>}</span></pre><p id="7e4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将作为GET请求的HTTP请求处理程序。它立即向事件总线的<code class="fe oc od oe of b">service.movie-get</code>通道发布消息(消息体无关紧要，所以我们提供一个空字符串)。它还为返回消息提供了一个处理程序，该处理程序将消息体作为JSON有效负载返回给原始的HTTP调用者(如果出现故障，则返回500错误响应)。</p><p id="61ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在<code class="fe oc od oe of b">MovieRepository</code>中，我们已经添加了一个<code class="fe oc od oe of b">service.movie-get</code>通道消费者，它检索之前创建的电影列表。</p><p id="6565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使用<code class="fe oc od oe of b">getMovie()</code>处理程序，我们将修改<code class="fe oc od oe of b">get</code>请求处理程序(在<code class="fe oc od oe of b">run()</code>方法中),如下所示:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="1be4" class="lv lw it of b gy om on l oo op">router.get("/movies").handler(ctx -&gt; getMovie(ctx, vertx));</span></pre><p id="8737" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的最终形式<code class="fe oc od oe of b">AppServer.java</code>应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="9774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们可以考虑这些变化之前，我们将在我们的<code class="fe oc od oe of b">Main</code>类中再添加一个。<code class="fe oc od oe of b">MovieRepository</code>是一个verticle，你会注意到它没有被实例化。这意味着，它的事件总线订阅者将永远不会被创建，因此电影将不会被保存或检索。需要部署Vert.x verticles，所以我们将在<code class="fe oc od oe of b">Main</code>进行部署。首先，添加这个方法:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="8133" class="lv lw it of b gy om on l oo op">protected void deployVerticle(String className) {<br/>  vertx.deployVerticle(className, res -&gt; {<br/>    if (res.succeeded()) {<br/>      System.out.printf("Deployed %s verticle \n", className);<br/>    } else {<br/>      System.out.printf("Error deploying %s verticle:%s \n", className, res.cause());<br/>    }<br/>  });<br/>}</span></pre><p id="1c59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将此作为部署任何垂直市场的通用方法。我们使用<code class="fe oc od oe of b">Main</code>的<code class="fe oc od oe of b">Vertx</code>实例来部署verticle，并提供一个记录结果的回调处理程序。需要一个回调处理程序，这样我们就不会在部署verticle时阻塞当前线程。</p><p id="3c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们简单地在<code class="fe oc od oe of b">start()</code>方法中添加这一行:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="7787" class="lv lw it of b gy om on l oo op">deployVerticle(MovieRepository.class.getName());</span></pre><p id="bd18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译并再次启动应用程序:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="262d" class="lv lw it of b gy om on l oo op">mvn clean install<br/>java -jar target/movies-app-1.0.0-SNAPSHOT-fat.jar</span></pre><p id="ba74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从网络浏览器点击<code class="fe oc od oe of b">localhost/movies</code>仍然会返回一个空列表，因为我们还没有添加电影。你需要使用一个类似于<a class="ae ky" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>的工具向<code class="fe oc od oe of b">localhost/movies</code>发出一个POST请求，并提供如下请求体:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="9100" class="lv lw it of b gy om on l oo op">{<br/>  "title": "Dances With Wolves",<br/>  "genre": "drama"<br/>}</span></pre><p id="244f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一切顺利，您应该得到一个包含新保存的电影及其新guid值的响应:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="6c6b" class="lv lw it of b gy om on l oo op">{<br/>  "genre": "drama",<br/>  "title": "Dances With Wolves",<br/>  "guid": "7254537a-82d2-4bee-96d3-f12c61bc2cd9"<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/dbfbdcbba7a92c1727337aec4ea1d018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqnOZ0ahpZzM8uUk3ealNg.png"/></div></div></figure><p id="309d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，回到您的web浏览器(或者继续使用Postman)并发出另一个GET请求:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/e7c558c46f4a7d60f1dd0fd7d0f54cc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*9-1NGPQ5ILmJnEdrs60-ag.png"/></div></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="d209" class="nr lw it bd lx ns nt nu ma nv nw nx md jz ny ka mg kc nz kd mj kf oa kg mm ob bi translated">前端和后端布线</h1><p id="72d4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在是最后一步——连接React和Vert.x应用程序。</p><h2 id="a960" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">获取和显示电影</h2><p id="9ba8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们回到React代码并修改<code class="fe oc od oe of b">MovieList.js</code>。我们需要:</p><ul class=""><li id="e037" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">将要显示的电影列表从const in <code class="fe oc od oe of b">App.js</code>移动到MovieList的<code class="fe oc od oe of b">state</code>。</li><li id="008b" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">创建新电影时通知<code class="fe oc od oe of b">MovieList</code>。</li><li id="e5d5" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">允许<code class="fe oc od oe of b">MovieList</code>向Vert.x应用程序查询要显示的电影列表。</li></ul><p id="b207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先将它添加到文件的顶部，就在导入的下面:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="5a99" class="lv lw it of b gy om on l oo op">var xhr;</span></pre><p id="27e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们将以下内容添加到<code class="fe oc od oe of b">MovieList</code>的构造函数中:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="4724" class="lv lw it of b gy om on l oo op">this.state = {<br/> movies: []<br/>}<br/>this.sendRequest = this.sendRequest.bind(this);<br/>this.processRequest = this.processRequest.bind(this);<br/>this.props.eventDispatcher.subscribe(“addMovie”, this.sendRequest);</span></pre><p id="5922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们创建一个<code class="fe oc od oe of b">state</code>对象，由一个名为<code class="fe oc od oe of b">movies</code>的空数组组成。在绑定了两个新函数(我们将在接下来创建)之后，我们订阅了一个事件调度程序(我们也将很快编写代码)。这将允许<code class="fe oc od oe of b">MovieList</code>在新电影创建时得到通知。</p><p id="c94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们添加那个<code class="fe oc od oe of b">sendRequest</code>函数:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="2485" class="lv lw it of b gy om on l oo op">sendRequest() {<br/>  xhr = new XMLHttpRequest();<br/>  xhr.open("GET", "http://localhost/movies")<br/>  xhr.send();<br/>  xhr.addEventListener("readystatechange", this.processRequest, false);<br/> }</span></pre><p id="0138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数将为我们的<code class="fe oc od oe of b">xhr</code>变量分配一个新的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a>实例，并告诉它向<code class="fe oc od oe of b">localhost/movies</code>发出一个GET请求(为了清楚起见，我们在这里对URL进行了硬编码，但我们不会在生产就绪的系统中这样做)。我们还将<code class="fe oc od oe of b">processRequest</code>函数标识为对成功请求的回调。</p><p id="3115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来让我们创建<code class="fe oc od oe of b">processRequest</code>函数:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="a39f" class="lv lw it of b gy om on l oo op">processRequest() {<br/>  if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {<br/>    var response = JSON.parse(xhr.responseText);<br/>    this.setState({<br/>      movies: response<br/>    })<br/>  }<br/>}</span></pre><p id="4198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法只是解析对GET请求的成功响应的主体内容。回想一下，我们的Vert.x <em class="mt"> GET </em>端点将返回一个电影对象列表。所以我们只需将<code class="fe oc od oe of b">MovieList</code>的状态设置为内容。如果您还记得前面的内容，那么这样做会导致<code class="fe oc od oe of b">MovieList</code>组件在UI中重新呈现。</p><p id="2971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望确保在UI第一次加载时(例如，如果用户刷新了浏览器)检索电影列表。为此，我们使用了<code class="fe oc od oe of b">componentDidMount()</code>生命周期挂钩。这是React组件对象中定义的方法，我们可以覆盖它。正如您可能猜到的那样，它是在组件完全加载后被调用的。</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="dd34" class="lv lw it of b gy om on l oo op">componentDidMount() {<br/>  this.sendRequest()<br/>}</span></pre><p id="c68c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们在<code class="fe oc od oe of b">render()</code>方法中做了一个小改动。显示的电影现在需要来自<code class="fe oc od oe of b">MovieList</code>的州，所以我们现在通过以下方式创建表格行:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="3462" class="lv lw it of b gy om on l oo op">{this.state.movies.map(this.toMovie)}</span></pre><h2 id="494c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">持续电影</h2><p id="71a3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在我们将增强<code class="fe oc od oe of b">MovieForm.js</code>来将新电影保存到Vert.x应用程序中。</p><p id="e2b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe oc od oe of b">MovieList.js</code>一样，我们将在顶部添加以下内容:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="a3eb" class="lv lw it of b gy om on l oo op">var xhr;</span></pre><p id="69b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将在构造函数中绑定两个新函数:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="ff57" class="lv lw it of b gy om on l oo op"> this.tryCreateMovie = this.tryCreateMovie.bind(this);<br/> this.processRequest = this.processRequest.bind(this);</span></pre><p id="2580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建第一个函数，如下所示:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="e5b7" class="lv lw it of b gy om on l oo op">tryCreateMovie() {<br/>  xhr = new XMLHttpRequest();<br/>  xhr.open("POST", "http://localhost/movies")<br/>  xhr.send(JSON.stringify({ “title”: this.state.title, "genre": this.state.genre }));<br/>  xhr.addEventListener("readystatechange", this.processRequest, false);<br/> }</span></pre><p id="cca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数将一个新的<code class="fe oc od oe of b">XMLHttpRequest</code>对象赋给<code class="fe oc od oe of b">xhr</code>变量，然后将我们正在创建的电影的JSONified形式发布到<em class="mt">http://localhost/movies</em>。成功响应后，它调用<code class="fe oc od oe of b">processRequest</code>回调函数，如下所示:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="f9f2" class="lv lw it of b gy om on l oo op">processRequest() {<br/>  if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) {<br/>    this.props.eventDispatcher.dispatch("addMovie", "")<br/>    this.changeState( { title: ""} )<br/>  }<br/>}</span></pre><p id="8f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数向事件调度程序发布一条<code class="fe oc od oe of b">addMovie</code>消息(我们将很快创建它)。它还将<code class="fe oc od oe of b">MovieForm</code>的状态更改为标题为空的电影，以便清除<code class="fe oc od oe of b">Title</code>文本字段。</p><p id="c59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，是时候编写我们的事件调度程序了。我们将在<code class="fe oc od oe of b">App.js</code>文件中这样做。首先，让我们去掉<code class="fe oc od oe of b">movies</code>数组——我们不再需要它了。在这里，我们将创建一个简单的对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="635d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，<code class="fe oc od oe of b">listeners</code>字段被声明为一个空对象。最终，它将作为一种列表地图。键将是字符串，它将代表事件类型(例如，上面的<code class="fe oc od oe of b">addMovie</code>)，而值将是一个回调函数的数组，每当发布事件时都会被调用。</p><p id="b637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oc od oe of b">subscribe</code>函数接受一个事件名和一个回调函数。它只是将回调函数添加到侦听器对象中，放在与事件名称匹配的键下。<code class="fe oc od oe of b">dispatch</code>函数接受一个事件名(一个字符串)和数据(可以是任意对象)。然后它检查<code class="fe oc od oe of b">listeners</code>对象是否有匹配事件名称的键。如果找到了那个键，它就遍历存储在关联数组中的回调函数并调用它们，传递数据。</p><p id="5e52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们的小应用程序来说，这个事件调度器可能看起来有些多余，但是如果我们要扩展这个应用程序，它会使处理整个应用程序的状态变化变得简单。此外，它是完全通用的，因此可以复制到其他React应用程序中。对于在复杂得多的应用程序中处理状态，还有<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>。我们不会在本文中介绍Redux，但您可以稍后作为家庭作业尝试将其改造到这个应用程序中。</p><p id="2dfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将修改<code class="fe oc od oe of b">App()</code>函数中<code class="fe oc od oe of b">MovieForm</code>和<code class="fe oc od oe of b">MovieList</code>组件的创建。我们已经移除了<code class="fe oc od oe of b">movies</code>数组，所以我们不再将它传递给<code class="fe oc od oe of b">MovieList</code>。但是<code class="fe oc od oe of b">MovieForm</code>和<code class="fe oc od oe of b">MovieList</code>都需要引用事件调度程序。所以我们将组件声明改为:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="ed20" class="lv lw it of b gy om on l oo op"> &lt;MovieForm genres={genres} eventDispatcher={eventDispatcher} /&gt;<br/> &lt;MovieList genres={genres} eventDispatcher={eventDispatcher} /&gt;</span></pre><h2 id="b06c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">这是一个总结</h2><p id="e856" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们将创建一个小的shell脚本，将整个应用程序React部分和Java/Vert.x部分——打包成一个可执行文件。在<code class="fe oc od oe of b">react-app/</code>目录下，创建一个包含以下内容的<code class="fe oc od oe of b">deploy.sh</code>脚本:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="089b" class="lv lw it of b gy om on l oo op">npm run build<br/>if [ -d "../vertx/src/main/resources/webroot/" ]; then rm -Rf ../vertx/src/main/resources/webroot/; fi<br/>mkdir ../vertx/src/main/resources/webroot/<br/>cp -R build/* ../vertx/src/main/resources/webroot/</span></pre><p id="86c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个脚本中，我们使用npm来构建应用程序，并针对生产部署进行了优化。然后，我们确保在<code class="fe oc od oe of b">vertx</code>目录中存在一个空的<code class="fe oc od oe of b">src/main/resources/webroot</code>子目录(首先删除任何以前的此类目录)。最后，我们将构建的React应用程序复制到那个<code class="fe oc od oe of b">src/main/resources/webroot</code>目录中，在那里它将作为Vert.x应用程序的静态内容提供。</p><p id="e154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保脚本可执行(<code class="fe oc od oe of b">chmod 777 deploy.sh</code>)，然后运行它(<code class="fe oc od oe of b">./deploy.sh</code>)。然后进入<code class="fe oc od oe of b">vertx</code>目录(<code class="fe oc od oe of b">cd ../vertx</code>)，构建并启动app:</p><pre class="kj kk kl km gt oi of oj ok aw ol bi"><span id="c970" class="lv lw it of b gy om on l oo op">mvn clean install<br/>java -jar target/movies-app-1.0.0-SNAPSHOT-fat.jar</span></pre><p id="11fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用网络浏览器点击<a class="ae ky" href="http://localhost" rel="noopener ugc nofollow" target="_blank"> http://localhost </a>，看看我们得到了什么:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/1c1f463cada9d61fd978edfe77768231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eU2JMsnHv9c1b22NCCMljw.png"/></div></div></figure><p id="dbef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果应该看起来很熟悉。现在，让我们添加几部电影:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/5c9f0b060e35c69ece8ba46cb939896f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OXuaZ9jkU3N_G2bMaayi0w.png"/></div></div></figure><p id="6d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">刷新浏览器，你的电影将被重新获取和渲染。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="e5c8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结束学分</h2><p id="cae4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您遇到了任何问题，您可以根据这个存储库检查您的代码:</p><div class="pd pe gp gr pf pg"><a href="https://github.com/taubler/movies-react-vertx" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">陶布勒/电影-反应-vertx</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">示例电影数据库教程，包含React.js和vert . x-taubler/movies-react-vertx</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">github.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div><p id="38b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个用React和Vert.x构建web应用程序的简单演示。下面是一些让它更加充实的想法:</p><ul class=""><li id="e4df" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">向电影模型中添加更多字段。</li><li id="2640" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">将电影保存在持久数据存储中，例如本地MongoDB或MySQL数据库，或者云数据存储。</li><li id="0851" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">使用<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> redux </a>来传播React应用程序的状态。</li></ul><p id="0685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，抓一碗爆米花，尽情享受你的新React和Vert.x技能吧！</p><h2 id="d8bb" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">资源</h2><ul class=""><li id="9311" class="mv mw it lb b lc mo lf mp li pv lm pw lq px lu na nb nc nd bi translated">https://vertx.io/<a class="ae ky" href="https://vertx.io/" rel="noopener ugc nofollow" target="_blank"/></li><li id="9127" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">【https://nodejs.org/en/ T4】</li><li id="74f6" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://www.taniarascia.com/how-to-install-and-use-node-js-and-npm-mac-and-windows/" rel="noopener ugc nofollow" target="_blank">https://www . taniarascia . com/how-to-install-and-use-node-js-and-NPM-MAC-and-windows/</a></li><li id="597b" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://solarianprogrammer.com/2018/09/28/installing-openjdk-macos/" rel="noopener ugc nofollow" target="_blank">https://solarianprogrammer . com/2018/09/28/installing-open JDK-MAC OS/</a></li><li id="f19d" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b" rel="noopener">https://medium . com/@ maybe Katz/introducing-npx-an-NPM-package-runner-55 f 7d 4 BD 282 b</a></li><li id="fe0f" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://www.codementor.io/@niladrisekhardutta/how-to-call-apply-and-bind-in-javascript-8i1jca6jp" rel="noopener ugc nofollow" target="_blank">https://www . code mentor . io/@ niladrisekhardutta/how-to-call-apply-and-bind-in-JavaScript-8i 1 JCA 6 jp</a></li><li id="5c78" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated"><a class="ae ky" href="https://reactjs.org/docs/forms.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/forms.html</a></li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="327e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得这个故事有用？想多读点？只需<a class="ae ky" href="https://dt-23597.medium.com/subscribe" rel="noopener">在这里订阅</a>就可以将我的最新故事直接发送到你的收件箱。</p><p id="5c5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以支持我和我的写作——并获得无限数量的故事——通过今天<a class="ae ky" href="https://dt-23597.medium.com/membership" rel="noopener">成为媒体会员</a>。</p></div></div>    
</body>
</html>