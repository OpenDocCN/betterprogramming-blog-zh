<html>
<head>
<title>Writing a High-Performance Golang Client Library — Batching on Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写高性能Golang客户端库——流水线批处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-high-performance-golang-client-library-part-1-batching-on-pipeline-97988fe3211?source=collection_archive---------3-----------------------#2022-02-02">https://betterprogramming.pub/writing-high-performance-golang-client-library-part-1-batching-on-pipeline-97988fe3211?source=collection_archive---------3-----------------------#2022-02-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4211" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以正确的方式在流水线的写入路径上进行批处理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/90fea789db2ce2d3180c13c9745b8c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VfwOQsk9__SnZg9-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@marcusdallcol?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·达尔科尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f6ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank"> Rueidis </a>是我最近自己构建的一个高性能Golang Redis客户端库，目的是使用<code class="fe ls lt lu lv b">server-assisted client side caching</code>特性，自Redis 6发布以来(2020年)，其他现有Golang库尚未很好地支持该特性。</p><p id="a566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了客户端缓存，我还从构建库的过程中学到了很多常用的技术，这些技术在日常编程中也很有用。</p><p id="ca1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一系列的帖子中，我将分享我在<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>中学到并使用的技巧。这些技巧不仅推荐给库作者，也推荐给在日常生活中处理网络或RPC的程序员。它们是:</p><ul class=""><li id="2bbf" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">第1部分——管道配料</li><li id="2024" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/working-on-high-performance-golang-client-library-reading-again-from-channels-5e98ff3538cf?source=friends_link&amp;sk=a336644446cf70749e1a0f1aa0d4c706">第二部分——从频道中再次阅读？</a></li><li id="d478" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">第3部分——用<code class="fe ls lt lu lv b">sync.Cond</code>去除坏的忙循环</li><li id="3cc9" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">第4部分—优雅地关闭并发作者的通道</li></ul><h1 id="9a2b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">请求和响应模型</h1><p id="96bf" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">许多客户端和服务器通信都是基于请求和响应模型设计的。</p><p id="5c90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从客户端库的角度来看，以这种方式编程非常容易:</p><ol class=""><li id="fb21" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nh mc md me bi translated">将请求写入套接字。</li><li id="970e" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nh mc md me bi translated">读取套接字的响应。</li></ol><p id="d458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写和读操作都会引起系统调用，并且套接字会被占用，直到读操作完成。</p><p id="1bc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了支持并发操作和减少握手开销，客户端库通常使用连接池技术。然而，系统调用和往返时间的成本仍然巨大。</p><h1 id="af35" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">管道铺设</h1><p id="409a" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">TCP或QUIC提供了可靠流的抽象。依赖于流的高级协议，如HTTP 1.1、Redis序列化协议3或PostgreSQL协议3.0，通常支持流水线操作。</p><p id="5de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也就是说，客户端库可以只在传出流上继续写，同时只在传入流上继续读，而无需相互等待。</p><p id="ae6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，通过这种方式，可以将每个流上的多个操作批处理到一个系统调用中。</p><p id="1e29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果客户端被编程为使用流水线，那么它不需要为每个操作支付两个读/写系统调用和一个RTT的成本，因此它可以具有更好的性能。</p><div class="ni nj gp gr nk nl"><a href="https://redis.io/topics/pipelining" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">使用流水线技术加速查询</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">Redis是一个TCP服务器，使用客户机-服务器模型和所谓的请求/响应协议。这意味着…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">redis.io</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div><p id="d77e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以上Redis文档推荐阅读。它很好地解释了管道上的批处理是如何有益的，以及如何将吞吐量提高10倍。</p><h1 id="d4f2" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">戈朗管道配料</h1><p id="92df" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在Golang中，在这种情况下只需使用<code class="fe ls lt lu lv b">channel</code>和<code class="fe ls lt lu lv b">bufio.Writer</code>就可以很容易地实现批处理。</p><p id="c460" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个代码片段，类似于我在<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>中使用的自动批处理管道上的请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e7da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码片段是如何工作的？<code class="fe ls lt lu lv b">bufio.Writer</code>已经用它默认的4k缓冲区帮助我们减少了套接字写系统调用。当缓冲区满了，它会自动调用socket write系统调用。然而，换句话说，在缓冲区满之前，请求只是在客户端缓冲区中保持未发送状态。</p><p id="cc1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个客户端库，我们不能让请求停留在缓冲区中，等待用户发送更多的请求来填充缓冲区。如果没有进一步的请求要发送怎么办？我们需要尽快把他们送出去。</p><p id="2bcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里使用通道的非阻塞读操作<code class="fe ls lt lu lv b">select case with default</code>来检测是否没有进一步的请求。如果是，则立即刷新<code class="fe ls lt lu lv b">bufio.Writer</code>缓冲器。之后，我们仅对通道上的下一次读取使用阻塞操作，以避免循环忙于旋转。</p><h1 id="c20c" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结果</h1><p id="b2fa" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">因此，使用类似的批处理技术，<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>在跨1、8、64个并行体的本地并行基准测试中比<code class="fe ls lt lu lv b">go-redis</code>具有更好的吞吐量:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/0421990e447e5d1c0a0383eb07cc9103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-X05XNuVBYEfJNbHA8eCgw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">基准源代码:<a class="ae kv" href="https://github.com/rueian/rueidis-benchmark" rel="noopener ugc nofollow" target="_blank">https://github.com/rueian/rueidis-benchmark</a></p></figure><h1 id="69ac" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">下一步是什么</h1><p id="91e2" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在Golang中，对管道的写路径进行批处理是相当容易的，但是处理读路径要困难得多。</p><p id="1856" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如下文<a class="ae kv" href="https://www.postgresql.org/docs/14/libpq-pipeline-mode.html" rel="noopener ugc nofollow" target="_blank"> PostgreSQL文档</a>所述:</p><blockquote class="od oe of"><p id="ff45" class="kw kx og ky b kz la jr lb lc ld ju le oh lg lh li oi lk ll lm oj lo lp lq lr ij bi translated">虽然管道模式提供了显著的性能提升，但是使用管道模式编写客户端更加复杂，因为它涉及到管理挂起查询的队列，以及查找哪个结果对应于队列中的哪个查询。</p></blockquote><p id="0281" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可能是大多数库默认不这么做的原因。</p><p id="7000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的系列文章中，我将分享<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/rueian/rueidis" rel="noopener ugc nofollow" target="_blank">rueidis</a></code>如何将流水线响应映射回请求和响应模型。</p><h1 id="bb71" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">附录</h1><div class="ni nj gp gr nk nl"><a href="https://github.com/rueian/rueidis" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">GitHub - rueian/rueidis:一个快速的Golang Redis RESP3客户端，支持客户端缓存，自动…</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">一个快速的Golang Redis RESP3客户端，支持自动流水线操作和客户端缓存。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="ok l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://redis.io/topics/client-side-caching" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">服务器辅助的客户端缓存</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">客户端缓存是一种用于创建高性能服务的技术。它利用了可用的内存…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">redis.io</p></div></div><div class="nu l"><div class="ol l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://www.postgresql.org/docs/14/libpq-pipeline-mode.html" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">34.5.管道模式</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">libpq管道模式允许应用程序发送查询，而不必读取先前发送的查询的结果…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">www.postgresql.org</p></div></div><div class="nu l"><div class="om l nw nx ny nu nz kp nl"/></div></div></a></div></div></div>    
</body>
</html>