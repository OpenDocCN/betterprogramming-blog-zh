<html>
<head>
<title>An Efficient Git Branching Strategy Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的高效Git分支策略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/efficient-git-branching-strategy-every-developer-should-know-f1034b1ba041?source=collection_archive---------1-----------------------#2020-03-15">https://betterprogramming.pub/efficient-git-branching-strategy-every-developer-should-know-f1034b1ba041?source=collection_archive---------1-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="36c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">完成的代码应该放在哪里？我们应该从哪里释放？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4faece314a67d6645cedee0c5794fad0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSE6ialQ-9TcGUz5ts_FMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片来自<a class="ae ky" href="https://itnext.io/become-a-git-pro-in-just-one-blog-a-thorough-guide-to-git-architecture-and-command-line-interface-93fbe9bdb395" rel="noopener ugc nofollow" target="_blank"> ITNEXT </a>。</p></figure><p id="2cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的基地分支应该是<code class="fe lv lw lx ly b">master</code>、<code class="fe lv lw lx ly b">develop</code>，还是别的？让我们看一个你可能不熟悉的git分支策略。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cae5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是分支策略？</h1><ul class=""><li id="bd13" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">应该从哪个分支剪切特征分支？</li><li id="2463" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">代码完成后，您应该在哪个分支中为代码审查和测试提出一个<strong class="lb iu"> MR </strong>(合并请求)/ <strong class="lb iu"> PR </strong>(拉请求)？</li><li id="ead2" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在完成测试和评审之后，这个特性分支应该合并到哪个分支中？</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="71da" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">为什么重要？</h1><ul class=""><li id="5526" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">从中剪切特征分支的分支应该是生产稳定的。</li><li id="7707" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">您不应该将有问题的/未测试的代码合并到生产分支(它将上线)。</li><li id="8c3c" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在将您的代码合并到产品中时，您应该会遇到最小的合并冲突。</li></ul><p id="9d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分支策略的目的是提高代码稳定性、开发人员的生产率，并避免不必要的冲突。</p><p id="fead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会涵盖所有类型的分支策略，但我会列出最常用的最佳策略。</p><p id="5fff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将使用<code class="fe lv lw lx ly b">master</code>、<code class="fe lv lw lx ly b">develop</code>和<code class="fe lv lw lx ly b">feature</code>分支。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ae12" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">掌握</h1><ul class=""><li id="c43f" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">我们可以称之为生产部门。经过充分测试的稳定代码就在这里。</li><li id="6aec" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">这是上一个版本应该离开的分支，下一个版本也应该离开。</li><li id="5b75" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">我们可以有发布这个分支的管道(也就是说，每当这个分支遇到一个新的合并时，管道会自动地将软件构建并部署到我们的生产服务器上)。</li><li id="49c2" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">它应该只接受来自<code class="fe lv lw lx ly b">develop</code>分支的合并。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e3e2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">发展</h1><ul class=""><li id="f600" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">低于主级别的分支。</li><li id="711b" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">开始开发一个特性的开发人员从这个树枝上剪下一个新的树枝。</li><li id="01db" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在开发/测试/代码审查完成后，他们将向同一个分支提交一个MR，因为这是将在下一个版本中发布的分支。</li><li id="789a" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">在发布的时候，一个合并从这个分支到<code class="fe lv lw lx ly b">master</code>分支。而<code class="fe lv lw lx ly b">master</code>就是被释放的那个。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6db8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">特征</h1><ul class=""><li id="e1f9" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">从<code class="fe lv lw lx ly b">develop</code>分出的一个分支，用于下一个版本中计划的功能。</li><li id="d112" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">通常，一个单独的开发人员在一个<code class="fe lv lw lx ly b">feature</code>分支上工作。</li></ul><p id="f6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">拥有这三种类型的分支可以避免不必要的冲突，并提高团队的生产力。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="af2c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">质量保证测试</h1><p id="86c4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">但是我们忽略了一件事:QA测试。</p><p id="64bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">QA测试应该在哪个分支上进行？换句话说，应该将哪个分支部署到QA环境中？</p><p id="4fe7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的方法是从dev分支<strong class="lb iu">获得一个QA环境(</strong>即QA服务器将通过从<code class="fe lv lw lx ly b">develop</code>分支触发的构建来部署)。和QA签准后，可以将MR/PR提交给主分支机构。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/4143d98498f8aa3c6bd00e13d940e18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eZMKRu5BrdTSRhr-JqwyVw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">两分支策略。</p></figure><h2 id="022e" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">赞成的意见</h2><ul class=""><li id="0be4" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">在发布之前，每个变更都可以通过一次构建/部署进行测试(例如，可以一次完成所有特性的单个特性测试)。</li><li id="119b" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">后特性测试，这个分支最好进行回归测试，因为这个分支中的变化是为下一个版本计划的。</li></ul><h2 id="4667" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">骗局</h2><ul class=""><li id="25f5" class="my mz it lb b lc na lf nb li nc lm nd lq ne lu nf ng nh ni bi translated">如果其中一个<code class="fe lv lw lx ly b">feature</code>分支的变更有bug，那么QA测试就会被阻塞，会浪费整个团队的带宽。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e875" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决方法</h1><h2 id="1306" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">第一种解决方案</h2><p id="fd34" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">等待功能所有者解决问题。将其合并到<code class="fe lv lw lx ly b">develop</code>分支，重新部署到QA，并恢复测试。但是这是不可行的，因为我们不确定修复一个特定的bug需要多少时间。</p><ul class=""><li id="3b88" class="my mz it lb b lc ld lf lg li oe lm of lq og lu nf ng nh ni bi translated">此外，QA带宽正在被浪费。</li><li id="9c32" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">发布阻止程序，以防没有该功能也能发布。</li><li id="2d1d" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">多个来回，以防QA在不同的特性中发现bug。</li></ul><h2 id="604d" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">第二种解决方案</h2><p id="f00d" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">恢复该特性的更改并继续测试。这种方法对于整个团队的生产力来说更好，但是对于特性所有者来说可能是痛苦的。如果他们恢复更改，将创建一个新的提交，恢复该分支中的所有更改。如果他们试图在修复后将其合并回来，git将只考虑新的修复提交合并到<code class="fe lv lw lx ly b">develop</code>，因为旧的提交已经在<code class="fe lv lw lx ly b">develop</code>的提交历史中了。</p><p id="2308" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，开发人员需要恢复恢复提交。</p><h2 id="d2a9" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">第三种解决方案</h2><p id="46b6" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">第三种也是最简单的方法是强制将<code class="fe lv lw lx ly b">master</code>推到<code class="fe lv lw lx ly b">develop</code>，重新合并其他的<code class="fe lv lw lx ly b">feature</code>分支，并重新部署QA。</p><p id="c36f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方式是我推荐的方式，关注整个团队的生产力。</p><h2 id="d491" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">最佳方法</h2><p id="a552" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们可以用下面的方法来解决这个问题:为了测试的目的，再增加一个QA分支。QA最好用<code class="fe lv lw lx ly b">develop</code>更新。</p><p id="dd30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在这种情况下会增加一个额外的步骤，整个生命周期如下:</p><ul class=""><li id="1a59" class="my mz it lb b lc ld lf lg li oe lm of lq og lu nf ng nh ni bi translated">从<code class="fe lv lw lx ly b">develop</code>上剪下一根树枝。</li><li id="bf38" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">后期开发和开发测试，将PR/MR提交给QA进行代码审查。</li><li id="6dfa" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">后期代码评审，合并到QA分支。</li><li id="1f7d" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">QA进行功能测试，签署后，您提交MR/PR进行开发。</li><li id="3d39" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">进行第二轮评审(为了理智起见)或者让你的分支直接合并到<code class="fe lv lw lx ly b">develop</code>，因为它已经被评审和测试过了。</li><li id="fd60" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">每当<code class="fe lv lw lx ly b">develop</code>发布就绪时(即所有的特性分支都被合并)，QA触发一个构建来进行回归测试。这个构建可以在已经配置好的QA环境中运行。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/00760fdbe2e56f6e364d8c4a6a9ef41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XV7ACDj6_GSCRh1nFSa73A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三分支策略。</p></figure><h2 id="dbdc" class="ns mh it bd mi nt nu dn mm nv nw dp mq li nx ny ms lm nz oa mu lq ob oc mw od bi translated">这种方法的好处</h2><p id="4cea" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">尽管这种方法看起来与前面的方法相似，并且添加一个额外的分支看起来没有好处，但它将有助于提高生产率，如下所示:</p><ul class=""><li id="270a" class="my mz it lb b lc ld lf lg li oe lm of lq og lu nf ng nh ni bi translated">您可以从QA分支进行特性测试，从稳定的<code class="fe lv lw lx ly b">develop</code>分支进行回归，合并当前版本中计划的所有特性。</li><li id="f69e" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe lv lw lx ly b">develop</code>会一直稳定，任何开发者都可以在任何时间点砍掉他们的<code class="fe lv lw lx ly b">feature</code>分支。</li><li id="cb9e" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">你不会滥发<code class="fe lv lw lx ly b">develop</code>分支的提交历史。</li><li id="22fb" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">如果QA面临任何<code class="fe lv lw lx ly b">feature</code>分支的问题，那么您可以修复它，如果该特性独立于其他特性，则无需恢复就可以推送。</li><li id="aa6f" class="my mz it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">修补程序:在任何产品问题的情况下，从<code class="fe lv lw lx ly b">master</code>切下一个分支，修复它，然后发布。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="28e1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="ab55" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">感谢<a class="oi oj ep" href="https://medium.com/u/eca81dc58b9e?source=post_page-----f1034b1ba041--------------------------------" rel="noopener" target="_blank"> Jashan Preet Singh </a>对本文的贡献。<br/>感谢阅读。编码快乐！</p></div></div>    
</body>
</html>