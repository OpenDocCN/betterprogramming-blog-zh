<html>
<head>
<title>Inheritance vs. Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">继承与构成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/inheritance-vs-composition-2fa0cdd2f939?source=collection_archive---------0-----------------------#2020-05-10">https://betterprogramming.pub/inheritance-vs-composition-2fa0cdd2f939?source=collection_archive---------0-----------------------#2020-05-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="17c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你应该使用哪一个？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b0399bcd2a950d4d2ab0271dadf78a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hdNw3NzctHmVRZqLGEk5ow.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多梅尼科·洛亚在<a class="ae ky" href="https://unsplash.com/s/photos/website?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="851b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自从引入以来，继承一直是OOP最受欢迎的特性之一。但是现在似乎不推荐将它作为编程中的好实践。很容易找到许多关于“<a class="ae ky" href="http://Composition over inheritance" rel="noopener ugc nofollow" target="_blank">组成优于继承</a>”的讨论和文章，作为工程师的一种预防措施。一些现代编程语言，如Go，甚至不允许使用继承，而只允许使用复合。</p><blockquote class="lv"><p id="dda5" class="lw lx it bd ly lz ma mb mc md me lu dk translated">有人:让我们使用继承来重用代码</p><p id="b8b9" class="lw lx it bd ly lz ma mb mc md me lu dk translated">Go:什么是继承？</p></blockquote><p id="d29e" class="pw-post-body-paragraph kz la it lb b lc mf ju le lf mg jx lh li mh lk ll lm mi lo lp lq mj ls lt lu im bi translated">让我们搞定这件事！首先，什么是继承？</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8eaa" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">遗产</h1><p id="0f92" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">来自维基百科<a class="ae ky" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="63ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长话短说，当子类从父类继承时，子类从父类获得所有行为。继承会产生一个类层次结构——你可以把它想象成一个类的树。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/947035c29bfe7f15147f7df1d2455cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*LjU8B8cNB4EXwYxqBlJTEg.png"/></div></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="614b" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">作文</h1><p id="2d5e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">同样来自维基百科<a class="ae ky" href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="bbdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组合与继承相反，它通过组合其他类型的对象(组件)来创建复杂类型，而不是从基类或父类继承。简单地说，composition包含实现所需功能的其他类的实例。</p><p id="0f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以把构图想象成玩乐高积木，而组件就是乐高积木。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/ed4de78659e94d9d0edea880dcb5fb56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMRW0x65QYRPkxQmh4fPfQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@penguinphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">埃里克&amp;尼克拉斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/lego?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f2f0" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">继承与构成</h1><p id="e885" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">继承和组合的主要区别在于对象之间的关系。</p><ul class=""><li id="0229" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">继承:“是”例如，汽车<em class="nz">是</em>车辆。</li><li id="3ab5" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">组成:“有一个”。例如汽车<em class="nz">有一个</em>方向盘。</li></ul><p id="3ae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承被认为是面向对象编程中最紧密的耦合形式。改变一个基类会对它的子类甚至整个代码库产生不必要的副作用。</p><p id="d129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组合是一种非常松散的耦合。结合依赖注入(这里的<a class="ae ky" href="https://medium.com/flawless-app-stories/dependency-injection-for-dummies-168dad181a3d" rel="noopener"/>，它带来了更多的灵活性，也允许我们改变运行时的行为。</p><p id="b4e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当构建一个组合各种组件的类时，使用组合比试图找到它们之间的共性并创建一个类树更自然。</p><p id="7d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法适应了未来的需求变化，这可能需要在继承方法中更容易地完全重构类树。我们可以简单地向复合类添加一个新组件，而不是修改超类来适应变化。</p><p id="1763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们的目的也不同。</p><ul class=""><li id="fd2e" class="nq nr it lb b lc ld lf lg li ns lm nt lq nu lu nv nw nx ny bi translated">继承:根据它是什么来设计一个类。</li><li id="c42f" class="nq nr it lb b lc oa lf ob li oc lm od lq oe lu nv nw nx ny bi translated">组成:根据它做什么来设计一个类。</li></ul><p id="0b93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，组合可以与继承互换使用。让继承如此广为人知的一点是多态性。组合最初不是为多态性设计的。但是大多数编程语言都允许我们通过接口(在Swift世界中被称为协议)来做到这一点。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="2ba0" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">成分多态性</h1><p id="1ff3" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Swift中的多态性可以通过协议来完成。最流行的术语是POP(面向协议编程)。</p><p id="dd4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子来进一步理解它。我们有一个<code class="fe of og oh oi b">Animal</code>类，而<code class="fe of og oh oi b">Dog</code>和<code class="fe of og oh oi b">Cat</code>是从它继承而来的。</p><p id="0527" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一只狗会叫，一只猫会叫，所有的动物都需要，呃…去洗手间。</p><p id="61a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用继承方法:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="2ffb" class="on ms it oi b gy oo op l oq or">class Animal { <br/>   func poop() { }<br/>}</span><span id="1c5b" class="on ms it oi b gy os op l oq or">class Dog: Animal {<br/>   func bark() { }<br/>}</span><span id="af4c" class="on ms it oi b gy os op l oq or">class Cat: Animal { <br/>   func meow() { }<br/>}</span><span id="0669" class="on ms it oi b gy os op l oq or">let animals: [Animal] = [Dog(), Cat()]</span></pre><p id="2763" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用构图法，一只狗既是<em class="nz">便便者</em>又是<em class="nz">剥皮者，</em>和一只猫既是<em class="nz">便便者</em>又是<em class="nz">喵儿</em>:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="95ea" class="on ms it oi b gy oo op l oq or">protocol Poopale {<br/>   func poop()<br/>}</span><span id="3070" class="on ms it oi b gy os op l oq or">protocol Barkable { <br/>   func bark() <br/>}</span><span id="cd5b" class="on ms it oi b gy os op l oq or">protocol Meowable {<br/>   func meow()<br/>}</span><span id="b2c3" class="on ms it oi b gy os op l oq or">class Dog: Poopable, Barkable {<br/>   var barker: Barkable<br/>   var pooper: Poopable <br/>   func bark() { barker.bark() }<br/>   func poop() { pooper.poop() }<br/>}</span><span id="afbb" class="on ms it oi b gy os op l oq or">...</span><span id="4a21" class="on ms it oi b gy os op l oq or">typealias Animal = Poopable &amp; ... // and any behaviors</span><span id="9ea1" class="on ms it oi b gy os op l oq or">let animales: [Animal] = [Dog(), Cat()]</span></pre><p id="0eea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用组合的一个缺点是，由单个组件(Barker)提供的方法可能必须在派生类型中重新实现。</p><p id="3037" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">*注:但这种不便有些方面可以通过Swift中的协议扩展功能来解决</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d4d1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">继承的问题</h1><p id="3bf2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">你会很快得到一份相当深厚和广泛的遗产。有一天你可能会有一个很深的阶级结构。上层阶级的一个变化可能会摧毁所有下层阶级。当你决定从另一个类继承的时候，就是你把你的类绑定到它的时候了。你永远不知道超类会做什么，因为它不在你的控制之内，:D，这就是所谓的脆弱基类问题</p><p id="9bcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦被部署，类的层次结构是很难改变的。一种选择是重写全部内容。</p><p id="c2d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，遗传给我带来了很多烦恼。正常的一天，我得到了:</p><pre class="kj kk kl km gt oj oi ok ol aw om bi"><span id="3309" class="on ms it oi b gy oo op l oq or">git pull master</span></pre><p id="e65b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切看起来都很好——没有冲突。是时候创建一个工作分支了。首先，运行项目——仍然很好，编译成功。然后，我对我最新开发的功能进行了全面检查——结果，它搞砸了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/c1113f51b21a944afdf0fa8ab5cadf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxkTkKW9b3u4ndyL1UK6QQ.png"/></div></div></figure><p id="e303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一段时间的调试，我终于找到了原因。是因为根类做了一些改动！</p><p id="2663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，我们确实不恰当地使用了继承。里斯科夫替代原则是决定继承是否适合你的设计的最重要的指导方针。</p><p id="a435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如:B继承自A，用Liskov代换证明B和A的关系，然后反转关系，再次证明。如果这种关系在两个方向上都有意义，那么最好不要使用继承。</p><p id="11d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了继承，你可以考虑超类在做什么，以及你的子类想要覆盖/改变什么。你可能不得不花时间去理解应用程序中的大量代码，而不是专注于你的范围，只是为了“让它工作”得更好。</p><p id="af83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承的一个问题是它鼓励你预测未来——这是一个陷阱。继承鼓励您在项目的早期建立对象的分类。你这样做可能会犯设计错误。在某些情况下，它还通过暴露属性/方法供子类使用来打破封装。</p><p id="eb25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">继承的另一个缺点是，当类的层次结构变得太复杂时，它使调试成为一个巨大的挑战。当有30层继承时，简单的堆栈跟踪可能会溢出屏幕。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a1db" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="3ce0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">凡事都有利弊。像软件开发中的所有事情一样，需要做出权衡。在大多数情况下，合成可以代替继承。但这不是银弹。</p><p id="a048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">选择编程工具类似于选择正确的厨房工具:你不会用黄油刀切菜，同理，你也不应该为每个编程场景选择构图。</em></p><p id="4649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在真正需要的时候使用继承，而不仅仅是重用一些代码。当你考虑使用继承时，问问你自己子类是否真的是超类的一个更专门化的版本，否则，总有一天你会经历混乱。</p><p id="69f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当谈到继承时，总是再问自己一次“使用组合是否更有意义？”</p><div class="ou ov gp gr ow ox"><a href="https://lvhan.medium.com/membership" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">用我的推荐链接加入媒体-布莱恩</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">lvhan.medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>