<html>
<head>
<title>Shazam for Paintings: A Computer Vision Python Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">绘画的Shazam:一个计算机视觉Python项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/shazam-for-paintings-a-computer-vision-project-513ff2e1b498?source=collection_archive---------12-----------------------#2020-05-11">https://betterprogramming.pub/shazam-for-paintings-a-computer-vision-project-513ff2e1b498?source=collection_archive---------12-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6607" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Python和OpenCV识别照片中的绘画</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17d47506fad3ee78ce50737da7efb6c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hw_IHRvJ_NEnXZIG"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@brooklyngrace?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克林</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="970b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算视觉是一个蓬勃发展的领域。它负责通过数学计算来理解或让计算机理解图像的内容。计算机科学的这个领域有大量的应用。</p><p id="b7ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中之一就是创造出能够判断两幅图像是否非常相似的系统。有时候，我们需要尽可能快地识别我们正在看的东西。我们总是在寻找信息。我想到了制作一个应用程序的想法，给定一幅画的照片，它可以识别它的名字。</p><p id="8dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a>(开源计算机视觉库)是最强大的库之一。它有许多内置功能，使处理图像更容易。对于这个项目，我们将与Python合作。</p><p id="f8f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先我们需要安装<code class="fe ls lt lu lv b">cv2</code>。这将让我们在Python中使用OpenCV。用<code class="fe ls lt lu lv b">pip install opencv-python</code>安装包即可。</p><p id="6d37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<a class="ae kv" href="https://github.com/raynelglez99/shazampaintings/" rel="noopener ugc nofollow" target="_blank">项目</a>由一个Python脚本、一组位于<code class="fe ls lt lu lv b">images/</code>的画作的标记图像和一组博物馆中的画作照片组成。我们的目标是识别照片中的画。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/090f3843738fb9d7990b81bc216bb86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*k2p3WMAHuRTAWH0CIzBNVw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一组已知的画</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/53674759815c41f16ccc42f0b18af4d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*uVUBz9WFn4io_wjtQAecaA.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要鉴别的画</p></figure><p id="c2d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的源代码在GitHub 上的<a class="ae kv" href="https://github.com/raynelglez99/shazampaintings/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="73e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从代码开始:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="27a1" class="mc md iq lv b gy me mf l mg mh"><strong class="lv ir">import</strong> cv2<br/> <strong class="lv ir">import</strong> os<br/> <strong class="lv ir">from</strong> collections <strong class="lv ir">import</strong> defaultdict<br/> <br/> paintings=[]<em class="mi"><br/> </em><strong class="lv ir">def</strong> loadFiles():<br/> <strong class="lv ir">global</strong> paintings<br/> paintings = os.listdir(“<strong class="lv ir">images</strong>”)</span></pre><p id="68bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们用<code class="fe ls lt lu lv b">images</code>文件夹中每个文件的名称填充<code class="fe ls lt lu lv b">paintings</code>数组。这个功能非常清楚。</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="e56f" class="mc md iq lv b gy me mf l mg mh">orb=<strong class="lv ir">None</strong></span><span id="9236" class="mc md iq lv b gy mj mf l mg mh">flann=<strong class="lv ir">None</strong></span><span id="4077" class="mc md iq lv b gy mj mf l mg mh"><em class="mi">#Initializes ORB and Flann</em></span><span id="dfc2" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">def </strong>initOrbandFlann():</span><span id="be55" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">global </strong>orb,flann</span><span id="7aa5" class="mc md iq lv b gy mj mf l mg mh">orb = cv2.ORB_create(700)   <em class="mi">#ORB Init</em></span><span id="3585" class="mc md iq lv b gy mj mf l mg mh">index_det = dict(algorithm = 6,table_number=10,key_size=20,multi_probe_level=0)</span><span id="e9f2" class="mc md iq lv b gy mj mf l mg mh">search = dict(checks=50)</span><span id="f037" class="mc md iq lv b gy mj mf l mg mh">flann = cv2.FlannBasedMatcher(index_det,search) <em class="mi">#Flann Init</em></span></pre><p id="192c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">orb</code>？<code class="fe ls lt lu lv b">flann</code>？</p><p id="26c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我解释一下:</p><ul class=""><li id="26a2" class="mk ml iq ky b kz la lc ld lf mm lj mn ln mo lr mp mq mr ms bi translated">ORB是一个关键点检测器和图像描述符。我们将使用它来获得每个图像的特征。</li><li id="8466" class="mk ml iq ky b kz mt lc mu lf mv lj mw ln mx lr mp mq mr ms bi translated"><a class="ae kv" href="https://github.com/mariusmuja/flann" rel="noopener ugc nofollow" target="_blank"> FLANN </a>(快速近似最近邻搜索)是一个针对大型数据库中真正快速的最近邻搜索而优化的库。</li></ul><p id="03e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用这个来比较我们的照片和场景的图像。</p><p id="341e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一行中，我们用<code class="fe ls lt lu lv b">nfeatures=700</code>初始化ORB检测器，它表示要存储的最大特征数:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="eae0" class="mc md iq lv b gy me mf l mg mh">orb = cv2.ORB_create(700)</span></pre><p id="1354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面几行中，我们用LSH算法(algorithm = <code class="fe ls lt lu lv b">6</code>)初始化FLANN。对于精度，建议使用其他值:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="fbaa" class="mc md iq lv b gy me mf l mg mh">index_det = dict(algorithm = 6,table_number=10,key_size=20,multi_probe_level=0)</span><span id="adb4" class="mc md iq lv b gy mj mf l mg mh">search = dict(checks=50)</span><span id="bce7" class="mc md iq lv b gy mj mf l mg mh">flann = cv2.FlannBasedMatcher(index_det,search) <em class="mi">#Flann Init</em></span></pre><p id="0f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着ORB和FLANN的创建，我们为<code class="fe ls lt lu lv b">images/</code>文件夹中的每个图像提取关键点和描述符。</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="09b1" class="mc md iq lv b gy me mf l mg mh"><em class="mi">#Get descriptors for each image</em></span><span id="8035" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">def </strong>getDescriptors():</span><span id="7c41" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">global </strong>flann,paintings</span><span id="a9e3" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">for </strong>filename <strong class="lv ir">in </strong>paintings:</span><span id="cc24" class="mc md iq lv b gy mj mf l mg mh">img2 =cv2.imread(<strong class="lv ir">"images/"</strong>+filename,0)</span><span id="21c3" class="mc md iq lv b gy mj mf l mg mh">kp2, des2 = orb.detectAndCompute(img2, <strong class="lv ir">None</strong>)</span><span id="de16" class="mc md iq lv b gy mj mf l mg mh">flann.add([des2])<em class="mi">#Add each image descriptor to flann</em></span><span id="2aae" class="mc md iq lv b gy mj mf l mg mh">flann.train()</span><span id="cbe2" class="mc md iq lv b gy mj mf l mg mh">img2 =cv2.imread(<strong class="lv ir">"images/"</strong>+filename,0) This line will create the object img2 containing each image as the loop run.</span></pre><p id="eeec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的两行检测每个图像的关键点和描述符，并将描述符添加到FLANN:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="d885" class="mc md iq lv b gy me mf l mg mh">kp2, des2 = orb.detectAndCompute(img2, <strong class="lv ir">None</strong>)</span><span id="aca5" class="mc md iq lv b gy mj mf l mg mh">flann.add([des2])</span></pre><p id="6c96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着所有描述符的检测和计算，我们继续训练我们的FLANN指数。此方法需要在匹配描述符之前运行:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="2fb9" class="mc md iq lv b gy me mf l mg mh">flann.train()</span></pre><p id="6686" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一行将生成一个索引以提高搜索速度。</p><p id="3eb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，下一步应该是为我们的照片找到匹配:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="4a7e" class="mc md iq lv b gy me mf l mg mh"><em class="mi">#img -&gt; filename of the painting</em></span><span id="a82c" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">def </strong>getMatch(img):</span><span id="5513" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">global </strong>kp1, des1,flann</span><span id="f908" class="mc md iq lv b gy mj mf l mg mh">img1 = cv2.imread(img)</span><span id="c04c" class="mc md iq lv b gy mj mf l mg mh">kp1, des1 = orb.detectAndCompute(img1, <strong class="lv ir">None</strong>)</span><span id="57f3" class="mc md iq lv b gy mj mf l mg mh">matches= flann.match(des1)</span><span id="f5f0" class="mc md iq lv b gy mj mf l mg mh">matches_dict = defaultdict(<strong class="lv ir">lambda </strong>: 0)</span><span id="0b68" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">for </strong>f <strong class="lv ir">in </strong>matches:</span><span id="b9a7" class="mc md iq lv b gy mj mf l mg mh">matches_dict[f.imgIdx]+=1</span><span id="f78e" class="mc md iq lv b gy mj mf l mg mh">temp = sorted(matches_dict.items(),key=<strong class="lv ir">lambda </strong>x:x[1],reverse=<strong class="lv ir">True</strong>)</span><span id="c97a" class="mc md iq lv b gy mj mf l mg mh">index = next(iter(temp)</span><span id="7131" class="mc md iq lv b gy mj mf l mg mh">file = paintings[list(index)[0]]</span><span id="dd9b" class="mc md iq lv b gy mj mf l mg mh">print(file)</span></pre><p id="9ea4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在检测到包含要识别的绘画的照片的关键点和描述符后，我们可以让FLANN进行匹配。</p><p id="0ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面一行将获得一个DMatch对象数组:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="5020" class="mc md iq lv b gy me mf l mg mh">matches= flann.match(des1)</span></pre><p id="575b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DMatch对象是一个包含匹配信息的类。我们将使用字段<code class="fe ls lt lu lv b">_imgIdx</code>，其中存储了匹配图像的索引。</p><p id="97d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算完所有匹配后，我们继续创建一个字典，它将图像索引作为关键字，并包含为每个图像找到的匹配数:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="7ba5" class="mc md iq lv b gy me mf l mg mh">matches= flann.match(des1)</span><span id="4b92" class="mc md iq lv b gy mj mf l mg mh">matches_dict = defaultdict(<strong class="lv ir">lambda </strong>: 0)</span><span id="892c" class="mc md iq lv b gy mj mf l mg mh"><strong class="lv ir">for </strong>f <strong class="lv ir">in </strong>matches:</span><span id="7adb" class="mc md iq lv b gy mj mf l mg mh">matches_dict[f.imgIdx]+=1</span></pre><p id="f33c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">defaultdict</code>是因为如果没有找到关键字，它会将值初始化为0。</p><p id="4f79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后字典按值降序排序:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="8f0a" class="mc md iq lv b gy me mf l mg mh">temp = sorted(matches_dict.items(),key=<strong class="lv ir">lambda </strong>x:x[1],reverse=<strong class="lv ir">True</strong>)</span></pre><p id="b8c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对字典排序后，我们在<code class="fe ls lt lu lv b">index</code>获得第一个值和绘画的文件名:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="6a8f" class="mc md iq lv b gy me mf l mg mh">index = next(iter(temp)</span><span id="63c7" class="mc md iq lv b gy mj mf l mg mh">file = paintings[list(index)[0]]</span><span id="0d16" class="mc md iq lv b gy mj mf l mg mh">print(file)</span></pre><p id="1e9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这应该是我们的主要方法:</p><pre class="kg kh ki kj gt ly lv lz ma aw mb bi"><span id="1711" class="mc md iq lv b gy me mf l mg mh">def main():</span><span id="7778" class="mc md iq lv b gy mj mf l mg mh">global flann</span><span id="b8d6" class="mc md iq lv b gy mj mf l mg mh">print("Initialazing ORB")</span><span id="4823" class="mc md iq lv b gy mj mf l mg mh">initOrbandFlann()</span><span id="94a7" class="mc md iq lv b gy mj mf l mg mh">print("Loading files")</span><span id="0987" class="mc md iq lv b gy mj mf l mg mh">loadFiles()</span><span id="c67b" class="mc md iq lv b gy mj mf l mg mh">print("Getting images descriptors")</span><span id="0a1d" class="mc md iq lv b gy mj mf l mg mh">getDescriptors()</span><span id="e2ae" class="mc md iq lv b gy mj mf l mg mh">print("Training FLANN")</span><span id="9c04" class="mc md iq lv b gy mj mf l mg mh">print("Current number of paintings: "+str(len(flann.getTrainDescriptors())))</span><span id="ab48" class="mc md iq lv b gy mj mf l mg mh">while True:</span><span id="7d72" class="mc md iq lv b gy mj mf l mg mh">image = input("Write image name\n")</span><span id="0739" class="mc md iq lv b gy mj mf l mg mh">print ("Getting match")</span><span id="96e8" class="mc md iq lv b gy mj mf l mg mh">getMatch(image)</span></pre><p id="410c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们运行脚本并输入包含要识别的绘画的图像的名称，然后…瞧:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/3aebfcf3593db32f9d6cdbc535b537d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Ek8tmAXxaOPT03bm5Joykw.gif"/></div></figure><p id="b765" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它能够在不到200毫秒的时间内识别Core i3 7100U、8 GB RAM笔记本电脑上的绘画。一个非常好的改进是计算一次描述符，并将它们保存到一个文件中。这个脚本可以用来识别标志，计算一个产品被看到的次数，以及许多其他应用程序。</p><p id="fa15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章是有帮助的。保重！</p></div></div>    
</body>
</html>