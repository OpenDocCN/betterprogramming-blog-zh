<html>
<head>
<title>The Decorator Pattern, Why We Stopped Using It, and the Alternative</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">装饰模式，为什么我们停止使用它，以及替代方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-decorator-pattern-why-i-stopped-using-it-and-the-alternative-2ae447f9de08?source=collection_archive---------2-----------------------#2022-03-08">https://betterprogramming.pub/the-decorator-pattern-why-i-stopped-using-it-and-the-alternative-2ae447f9de08?source=collection_archive---------2-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="272f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">装饰模式引发的问题以及如何避免它们</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9bd61771fe6f0af61c3a29666b84f71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NmqtNU1Q23pc-xe542dwwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简化的装饰模式。图片来源:作者。</p></figure><p id="2feb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰模式是一种众所周知且广泛使用的编程设计模式。乍一看，该模式似乎符合多种软件开发原则和最佳实践，然而，在使用该模式多年后，我们已经注意到一些严重的问题。这篇文章描述了与装饰模式相关的一些缺陷，这些缺陷最终使我们完全避免了这种模式。</p><h1 id="afc6" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">装饰图案</h1><p id="ce80" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">装饰模式是一种众所周知的结构设计模式，它允许在不触及原始实现的情况下用附加功能扩展现有的类。</p><p id="c83f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本质上，该模式采用一个我们想要扩展的组件，比方说带有重试逻辑的组件，并创建一个包装原始组件的新组件。对新组件的所有调用都被转发到被包装的组件，在此之前或之后完成一些额外的逻辑。这两个组件应该实现相同的接口，允许注入装饰器并用来代替原始组件。</p><p id="9f72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的要点显示了装饰模式的一个简化用法。这里，查找用户名用重试10次的策略来修饰。现在可以用<code class="fe mr ms mt mu b">UsernameLookupRetryDecorator</code>代替<code class="fe mr ms mt mu b">UsernameLookup</code>，因为它们实现了相同的接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰模式的简化使用。来源:作者。</p></figure><h1 id="39fe" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">装饰模式的好处</h1><p id="e345" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">应用装饰模式的典型原因是遵循著名的<a class="ae mx" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>和<a class="ae mx" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">开闭原则</a>。</p><p id="99ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对这些原则的普遍理解是，一个类应该只做一件小事。decorator模式使这一点成为逻辑的一部分，比如重试或日志记录，可以放在一个单独的类中修饰原来的类，从而分离关注点。</p><p id="39c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开闭原则鼓励扩展而不是修改，这正是decorator模式所做的——如果您意识到您现有的组件需要额外的逻辑，decorator模式允许您添加它，而不用以任何方式修改原始类。</p><h1 id="9e79" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">为什么我们停止使用装饰模式</h1><p id="422f" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">尽管装饰模式有上述好处，但我们几乎完全停止了使用这种模式。事实证明，装饰模式的好处也是造成严重缺陷的原因。</p><p id="b5de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰器是在不修改原始组件甚至组件使用位置的情况下添加的。这也意味着，当稍后查看现有代码时，并不立即清楚它实际上是在幕后用附加逻辑修饰的。decorators中包含的逻辑本质上是隐藏的。这导致了严重的隐患。</p><p id="ccf2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在过去的几年里，我们已经看到这在各方面造成了问题。最糟糕的情况是，当重构一个组件时，由于来自装饰者的关键逻辑被忽略和遗漏，导致了生产问题。相反的事情也发生过多次——人们将逻辑直接添加到一个组件中，而这个组件已经存在于装饰器中了。</p><p id="71df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有人可能偶然发现上面要点中的UsernameLookup组件，意识到它没有重试逻辑，并将其直接添加到类中，如下所示。一旦部署到生产中，组件将重试100次，而不是预期的10次。10次，乘以隐藏装饰逻辑中已经存在的10次重试。</p><p id="9bf1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种模式不太严重的缺点是，当密切相关的逻辑分散到不同的类中时，代码可读性更差，更难理解。当这些类在幕后组合在一起时，情况尤其如此，就像装饰模式一样。</p><h1 id="e167" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">装饰模式的替代方案</h1><p id="c1fb" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">大多数时候，装饰模式的使用可以被简单地删除。不要将日志、重试或任何其他需要的逻辑放入装饰器中，而是直接将其放入原始组件中。单一责任原则不必在这样的粒度级别上解释，修改组件而不是扩展它在实践中很少会有任何负面影响。同时，所需的文件和类的数量显著减少，这有助于保持代码简洁和易于理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">装饰模式的简单替代方案。将逻辑直接放置在原始组件中，并完全移除装饰器。来源:作者。</p></figure><p id="b34e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您真的想将一部分逻辑分离到它自己的类中，或者是为了分离关注点，或者是为了避免在多个组件需要它时复制逻辑，请考虑将这个类注入到原始组件中，而不是修饰它。这样，在查看原始组件时，就可以清楚地看到发生了什么。</p><p id="e3ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰模式在某些情况下当然可以提供足够的价值来抵消风险和缺点。这里重要的一点是简单地考虑它实际上是否值得。如果您选择使用该模式，请考虑添加覆盖端到端预期行为的测试。孤立地覆盖单个类的单元测试不足以发现本文中描述的缺失或重复的逻辑。</p><p id="b5aa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你喜欢阅读这篇文章，并且它让你重新思考使用流行的装饰模式所带来的影响。这篇文章是简化软件编写方式系列文章的一部分。查看最初的帖子，它描述了整体想法以及我们如何删除80%的代码:</p><div class="my mz gp gr na nb"><a rel="noopener  ugc nofollow" target="_blank" href="/avoiding-premature-software-abstractions-8ba2e990930a"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">避免过早的软件抽象</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">我们如何删除80%的代码，从而提高开发速度并减少错误</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">better编程. pub</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ks nb"/></div></div></a></div><pre class="kj kk kl km gt nq mu nr ns aw nt bi"><span id="bcf0" class="nu lv it mu b gy nv nw l nx ny"><strong class="mu iu">Want to Connect?</strong></span><span id="ceef" class="nu lv it mu b gy nz nw l nx ny"><a class="ae mx" href="https://jonastulstrup.medium.com/subscribe" rel="noopener">Join my email list for more simplified software insights!</a></span></pre></div></div>    
</body>
</html>