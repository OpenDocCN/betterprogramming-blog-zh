<html>
<head>
<title>Horizontal vs. Vertical Scaling in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的水平和垂直缩放</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/horizontal-vs-vertical-scaling-in-node-js-1b4f3ec8282?source=collection_archive---------10-----------------------#2020-07-27">https://betterprogramming.pub/horizontal-vs-vertical-scaling-in-node-js-1b4f3ec8282?source=collection_archive---------10-----------------------#2020-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解节点如何随CPU扩展</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/18656adf4326be1d4f6631f58f24d715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rKOhkBq4gxbyqQmV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">爱德华·豪厄尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="721e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我听到很多人说我们应该水平扩展应用程序而不是垂直扩展，但是这真的是最好的扩展方式吗？在本文中，我们将探索Node.js如何随CPU伸缩，并看看如果我们这样做，是否还有其他需要考虑的事情。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0c7a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">测试基础设施</h1><p id="9543" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了测试Node.js，创建了一个带有端点的演示应用程序，可以用来模拟负载。<a class="ae ky" href="https://hub.docker.com/r/harrymartland/node-load-app" rel="noopener ugc nofollow" target="_blank">应用</a>已备案，可在Docker Hub上找到。源代码可以在GitHub 上找到<a class="ae ky" href="https://github.com/HarryEMartland/node-scaling-experiment/tree/master/load-app" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="eaf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该应用程序部署在具有不同CPU限制的AWS ECS上，并在前端放置了一个负载平衡器，以使其可公开访问。用于部署这个基础设施的代码可以在GitHub 上找到<a class="ae ky" href="https://github.com/HarryEMartland/node-scaling-experiment/blob/master/cdk/lib/cdk-stack.ts" rel="noopener ugc nofollow" target="_blank">。如果你想自己动手，可以查看这个库并运行<code class="fe mz na nb nc b">yarn build</code>来构建CloudFormation栈。然后运行<code class="fe mz na nb nc b">yarn cdk deploy</code>。不同的实例部署在<code class="fe mz na nb nc b">&lt;loadbalancer DNS&gt;/&lt;CPU&gt;</code>，其中CPU是<code class="fe mz na nb nc b">256</code>、<code class="fe mz na nb nc b">512</code>、<code class="fe mz na nb nc b">1024</code>或<code class="fe mz na nb nc b">2048</code>中的一种。一旦完成，就可以用<code class="fe mz na nb nc b">yarn cdk delete</code>删除一切。</a></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6d42" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">负荷试验</h1><p id="2a98" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><a class="ae ky" href="https://artillery.io/" rel="noopener ugc nofollow" target="_blank">cannon</a>用于对应用程序进行负载测试，从每秒一个请求(RPS)开始，在四分钟内增加到40 RPS。通过在四分钟内缓慢加速，我们可以更准确地看到应用程序从哪一点开始失败。这一过程重复了四次——每种CPU尺寸一次。在GitHub 上可以找到<a class="ae ky" href="https://github.com/HarryEMartland/node-scaling-experiment/blob/master/artillery/fib.yaml" rel="noopener ugc nofollow" target="_blank">火炮文件</a>和所有测试的结果<a class="ae ky" href="https://github.com/HarryEMartland/node-scaling-experiment/tree/master/artillery" rel="noopener ugc nofollow" target="_blank">。您将找到可以下载来查看图表的<code class="fe mz na nb nc b">.html</code>文件。如果您想要原始输出，请查看同一个目录中的<code class="fe mz na nb nc b">.json</code>文件。测试的终点是计算第30个斐波那契数。这是一项计算量很大的任务，模拟真实世界的应用程序工作。</a></p><p id="e970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图来自512 CPU测试。在测试的第一部分，延迟和并发用户保持不变。这表明应用程序运行良好，能够处理负载。一旦服务不堪重负，延迟和并发用户就会增加。请注意并发用户的增长看起来是指数级的。一旦服务达到极限，延迟也会从大约50毫秒急剧增加到超过5秒。一旦服务接收请求的速度超过它的处理速度，请求就会备份，这会使服务速度变慢，并导致更多的请求备份。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/5f38237326d1b6c22f198b367cf59ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUdmrgQA4zr93dnqeQo5WQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">512 CPU负载测试结果</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0928" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结果</h1><p id="1ff1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在绘制了每个CPU的测试开始失败的点(当并发用户和响应时间增加时)之后，我们可以看到Node.js随CPU线性扩展。这意味着，在大多数情况下，就每CPU RPS而言，增加CPU没有任何好处。下图描绘了这一点。请注意，<code class="fe mz na nb nc b">1024</code>和<code class="fe mz na nb nc b">2048</code>之间没有增加。这是由于节点的单线程性质。额外的CPU处于闲置状态。AWS Fargate按部分vCPU收费，因此四个<code class="fe mz na nb nc b">256</code>pod与一个<code class="fe mz na nb nc b">1024</code> pod价格相同。因此，创造更大的豆荚没有经济利益。</p><p id="bb7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，当应用程序无法处理负载时，并发请求和响应时间会激增。如果我们使用这些指标来自动扩展，当指标增加并且我们要求扩展时，服务已经在影响客户了。对此的解决方案是在RPS上进行扩展，并在其他指标受到影响之前设置值。这保持了良好的客户体验，并允许增加一些呼吸空间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d60b6373b69b426f232a6eb07cb1ae62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mZHTac9qfzFaARqXgnhDA.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="092b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">水平扩展的优势</h1><p id="4d19" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">主要好处是成本。我们要求更精确的资源数量。这意味着浪费更少。如果我们可以用半个CPU来处理负载，但只扩展完整的CPU，我们就浪费了半个CPU的价格。</p><p id="804c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的服务的流量在一天中发生变化，您可以缩减到最小的pod数量(通常是两个以获得弹性)。通过保持CPU小，它保持你的最低成本的价格下降。</p><p id="7881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过增加流量中的pod，我们还提高了弹性。如果一个pod出现故障，负载会分散到仍在运行的pod上。如果我们有十个吊舱，每个吊舱处理10个RPS，其中一个出现故障，剩下的九个吊舱将只获得1.1个RPS。如果我们只有五个10 RPS的服务，一个失败了，剩下的会得到2.5 RPS。这足以让服务不堪重负。如果可用的话，拥有更多的单元还可以将负载分散到更多的可用性区域和节点上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="641c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="ad02" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">努力抵制增加服务CPU的冲动。而是增加它们的数量。这将使您的应用程序的成本得到控制，同时也增加了它的弹性。您还应该自动缩放您的应用程序，但是在使用响应时间或并发请求时要小心，因为这可能会给您的客户带来糟糕的体验。</p><p id="7bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这是您构建经济高效且有弹性的服务所需的证据。</p></div></div>    
</body>
</html>