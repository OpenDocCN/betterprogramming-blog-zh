<html>
<head>
<title>The 5 Java Concise Syntaxes I Miss in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在Kotlin中错过的5个Java简明语法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-5-java-concise-syntax-i-missed-in-kotlin-8112b219a4a9?source=collection_archive---------5-----------------------#2021-12-21">https://betterprogramming.pub/the-5-java-concise-syntax-i-missed-in-kotlin-8112b219a4a9?source=collection_archive---------5-----------------------#2021-12-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c5e4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Java并不总是比Kotlin差</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d4b63255e4701d51d679601a14dd0802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VyETl0YDXdPjEliH20Qu2w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@anthonytran?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Anthony Tran </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="553f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从2016年开始，在Android开发中使用Kotlin后，我就再也没有真正错过Java。总的来说，Kotlin让我对用Java开发Android感到非常满意。</p><p id="3766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，偶尔我会发现一些我在Java中真正错过的东西。下面是其中的5个。</p><h1 id="b309" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.三元运算符</h1><p id="83b5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Java中，对于简单的布尔逻辑，我们可以使用如下的三元运算符，而不必编写if-else</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e90a" class="mx lw it mt b gy my mz l na nb">selector ? function1() : function2();</span></pre><p id="eb8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在科特林，我们将不得不求助于传统的if-else</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="907d" class="mx lw it mt b gy my mz l na nb">if (selector) function1() else function2()</span></pre><p id="af2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不算太坏。它只是比我喜欢在Java中使用的三元组略显冗长。</p><h1 id="537a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.静态变量</h1><p id="3698" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Java中，当我们想在一个类中声明一个静态变量时，我们可以使用传统的C风格，只需要在前面加上一个<code class="fe nc nd ne mt b">static</code>关键字</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a70f" class="mx lw it mt b gy my mz l na nb">class SomeClass {<br/>    static int STATIC_INTEGER = 1<br/>}</span></pre><p id="c92a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在Kotlin中，我们需要使用嵌套的<code class="fe nc nd ne mt b">companion object</code></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="858a" class="mx lw it mt b gy my mz l na nb">class SomeClass {<br/>    companion object {<br/>        val static_integer = 1<br/>    }   <br/>}</span></pre><p id="b6ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，与Java中的<code class="fe nc nd ne mt b">static</code>相比，<code class="fe nc nd ne mt b">companion object</code>是Kotlin的一个更强大的特性，正如这个<a class="ae ky" href="https://stackoverflow.com/a/38382433/3286489" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>所述。</p><p id="8a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果我只想在我的类中有一个静态变量，我必须有另一个嵌套层缩进和额外的行，这让我觉得太像样板文件了。</p><h1 id="3970" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.按位运算符</h1><p id="4a60" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Java中，<a class="ae ky" href="https://www.geeksforgeeks.org/bitwise-operators-in-java/" rel="noopener ugc nofollow" target="_blank">我们有一个简洁的按位运算符</a>。例如，我可以写出自C语言诞生以来我们所知道的更传统的位操作方式。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="be90" class="mx lw it mt b gy my mz l na nb">int twoPowerOf = 2&lt;&lt;x;<br/>int removeTransparent = 0xFF000000|color;</span></pre><p id="13c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kotlin中，我们可以通过<a class="ae ky" href="https://www.programiz.com/kotlin-programming/bitwise" rel="noopener ugc nofollow" target="_blank">使用逐位关键字</a>来实现。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="b893" class="mx lw it mt b gy my mz l na nb">val twoPowerOf = 2 shl x<br/>var removeTransparent = 0xFF000000 or color</span></pre><p id="74b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还不算太差。只是它不是传统的。</p><h1 id="d776" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.循环增量浮点数</h1><p id="6326" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当我画了一些图形如下，我需要通过浮点数循环。</p><p id="c3bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java中，我可以很容易地做到以下几点:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="66e2" class="mx lw it mt b gy my mz l na nb">for (float i = 0; i &lt;= 10; i += 0.1) {<br/>    // Do something with i<br/>}</span></pre><p id="9df8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在科特林，我们没有传统的循环能力。我们还是可以做如下，手动分割:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bf22" class="mx lw it mt b gy my mz l na nb">(0..100).<em class="nf">forEach </em><strong class="mt iu">{<br/>    </strong>val i = <strong class="mt iu">it</strong>/10f<br/>    <em class="nf">// Do something with i</em><br/><strong class="mt iu">}</strong></span></pre><p id="bb18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者使用while-loop，比如这个StackOverflow 中共享的<a class="ae ky" href="https://stackoverflow.com/a/59347640" rel="noopener ugc nofollow" target="_blank">。while循环的缺点是，必须在循环之外设置和递增控制变量。</a></p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="1162" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">var i = 0f</strong><br/>while (i &lt;= 10f) {<br/>    // Do something with i<br/><strong class="mt iu">    i += 0.1f</strong><br/>}</span></pre><h1 id="0a10" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.多变量声明</h1><p id="9ec9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在Java中，我们可以声明多个相同类型的变量，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9acf" class="mx lw it mt b gy my mz l na nb">int w = 8, x = 10, y = 12, z = 14;</span></pre><p id="0b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kotlin中，由于类型有时是推断出来的，我们最好使用分号:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="215d" class="mx lw it mt b gy my mz l na nb">val w = 8; val x = 10; val y = 12; val z = 14</span></pre><p id="e49a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是更啰嗦一点。我想我不能抱怨，因为Kotlin拥有隐式类型推理的智能。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><p id="dbc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有一种语言是完美的。总的来说，我仍然喜欢科特林，因为它非常简洁。这些都是相对较小且可以忽略的挫折。虽然我希望有一天这些能成为科特林的一部分。</p><p id="7120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在使用Kotlin时有任何其他地方错过了Java，请分享一下。</p><p id="5248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>