<html>
<head>
<title>Exploring Jetpack Compose’s Hot-Reload Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Jetpack Compose的热重新加载功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-jetpack-composes-hot-reload-feature-3fdb5fa43ba1?source=collection_archive---------5-----------------------#2022-08-12">https://betterprogramming.pub/exploring-jetpack-composes-hot-reload-feature-3fdb5fa43ba1?source=collection_archive---------5-----------------------#2022-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7b44" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Jetpack Compose中实现热重装</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5a05fe0ee48bf38b7fc609598e9c40b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ktDsUTq2onXPQtw5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@qmikola?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">miko aj</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a0d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我一直非常羡慕Flutter中的热重装功能。或许谷歌也感受到了这种羡慕，去年年底推出Compose的时候，也推出了热重装功能。这是Android编程中第一次热重装出现。</p><p id="ecdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">热重装是一个显著的优势，因为它可以缩短开发时间，我认为这个优势足以启动Jetpack Compose。如果是，如何在Compose中实现这种热重载？在这篇文章中，我们将了解它。</p><p id="b247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">先说答案，所有文字都被提取为<code class="fe ls lt lu lv b">MutableState</code>，热重载是通过跟踪这个<code class="fe ls lt lu lv b">State</code>实现的。因为所有文件中的文字都被提取，所以所有与Compose无关的文件中的文字也用<code class="fe ls lt lu lv b">MutableState</code>提取。我们来看看是怎么提取的。</p><p id="6ff8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个使用“再见世界”文字的地球函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的函数在编译过程中是这样转换的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="00d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来分析一下上面转换后的代码。</p><ol class=""><li id="9d2a" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">创建一个名为“LiveLiterals${filename}”的对象(第5行)</li><li id="88d9" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">创建一个接收初始值的变量(第6行)</li><li id="d0d4" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">创建一个<code class="fe ls lt lu lv b">MutableState</code>对象来保存文本(第7行)</li><li id="ba1e" class="ly lz iq ky b kz mh lc mi lf mj lj mk ln ml lr md me mf mg bi translated">创建一个导入文字的函数(第8–19行)</li></ol><p id="dc5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它由4个步骤组成。每个变量和函数的命名是通过结合相应文字的位置和所用函数的签名来唯一确定的。</p><p id="a8fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，只有<code class="fe ls lt lu lv b">Int</code>、<code class="fe ls lt lu lv b">String</code>、<code class="fe ls lt lu lv b">Color</code>、<code class="fe ls lt lu lv b">Dp</code>和<code class="fe ls lt lu lv b">Boolean</code>支持这种转换，并且由于只支持文字，所以准确地说，它被称为live-literal而不是hot-reload。</p><p id="dd0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再来看看上面转换后的代码的第4步。如果你看第4步的第10行到第17行，如果没有初始化的<code class="fe ls lt lu lv b">MutableState</code>对象，就用一个叫<code class="fe ls lt lu lv b">liveLiteral</code>的函数初始化，然后返回<code class="fe ls lt lu lv b">MutableState</code>。这里用于初始化的<code class="fe ls lt lu lv b">liveLiteral</code>函数是什么，文字值更新在哪里？</p><p id="a3d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们先来看一下<code class="fe ls lt lu lv b">liveLiteral</code>函数。这是在位于Android x . compose . runtime . internal的LiveLiteral.kt文件中定义的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ded9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它是通过将键和值放入接收<code class="fe ls lt lu lv b">String</code>和<code class="fe ls lt lu lv b">MutableState</code>的<code class="fe ls lt lu lv b">HashMap</code>变量中来实现的。这样，<code class="fe ls lt lu lv b">liveLiteral</code>功能实现起来相对简单。</p><p id="1801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新文字值是通过<code class="fe ls lt lu lv b">updateLiveLiteralValue</code>函数完成的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="cffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了调用这个函数，必须从Android Studio编辑器接收输入，并用相应的值调用它。换句话说，在上面转换后的代码中没有使用(不能使用)这个函数，而是用编辑器中输入的值直接从Android Studio中调用。</p><p id="e61a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，当<code class="fe ls lt lu lv b">State</code>被LiveLiteral改变并且重组继续进行时，Android Studio使用<code class="fe ls lt lu lv b">findEffectiveRecomposeScope</code>函数仅重组使用该文字的最小范围。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a7e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个功能，我们可以优化使用LiveLiteral。我猜有时候LiveLiteral不行的原因是上面的函数因为某种原因返回null。</p><h2 id="c48e" class="mm mn iq bd mo mp mq dn mr ms mt dp mu lf mv mw mx lj my mz na ln nb nc nd ne bi translated">性能优化</h2><p id="ec11" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如果LiveLiteral只应用于使用Compose的部分就好了，但是由于它应用于所有不使用Compose的文件，所以从这么多文件中提取文字作为<code class="fe ls lt lu lv b">State</code>。如果有100个字面值，这对性能会有非常严重的影响，因为所有这100个字面值都会被<code class="fe ls lt lu lv b">State</code>跟踪。因此，为了优化性能，应该对不使用LiveLiteral的文件关闭LiveLiteral功能。</p><p id="2d74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过简单地注释<code class="fe ls lt lu lv b">@NoLiveLiterals</code>来禁用LiveLiteral。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d2d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果在发布模式下构建，将对所有文件禁用LiveLiteral。这就是我们在进行基准测试时应该使用发布模式的原因。</p><p id="4574" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个组合插件选项，即使在调试模式下也可以禁用所有文件的LiveLiteral。如果<code class="fe ls lt lu lv b">liveLiterals</code>选项设置为false，LiveLiteral被禁用，但会弹出一个错误，说这是一个重复的插件选项，所以我就跳过它。一旦成功，我会尽快更新这篇文章。</p><p id="2611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相关问题:<a class="ae kv" href="https://stackoverflow.com/questions/73172453/how-can-i-use-the-liveliterals-plugin-option" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/73172453/how-can-I-use-the-liveliterals-plugin-option</a></p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="c234" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们研究了Jetpack Compose如何实现热重载(live-literal)特性。感谢阅读。</p><pre class="kg kh ki kj gt nr lv ns nt aw nu bi"><span id="37f6" class="mm mn iq lv b gy nv nw l nx ny"><a class="ae kv" href="https://sungbin.land/%ED%94%8C%EB%9F%AC%ED%84%B0%EC%97%90%EC%84%9C%EB%A7%8C-%EB%90%98%EB%8D%98-hot-reload-%EC%BB%B4%ED%8F%AC%EC%A6%88%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B5%AC%ED%98%84%ED%96%88%EC%9D%84%EA%B9%8C-2ab37c45ed68" rel="noopener ugc nofollow" target="_blank">[View in Korean]</a></span></pre></div></div>    
</body>
</html>