<html>
<head>
<title>How to Achieve Principles of OOPs in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现围棋中的哎呀原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-achieve-principles-of-oops-in-go-6568f7b76f5f?source=collection_archive---------12-----------------------#2022-06-16">https://betterprogramming.pub/how-to-achieve-principles-of-oops-in-go-6568f7b76f5f?source=collection_archive---------12-----------------------#2022-06-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="597a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">熟悉Go中的OOPs概念，理解Go如何以自己独特的方式实现这些原则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1120671f335f74d3770a558364cbae6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ulDnTOVEnIks4Dtz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">费德里科·贝卡里在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="188d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以看到上面有一个迷人的红色天体，在这个远离数百万颗恒星和行星的黑暗宇宙中，它看起来和描述的比这张照片要多得多。嗯，我们也可以把这和我们今天的话题联系起来，比如宇宙是一个大的<strong class="ky ir">类</strong>物体，指的是太阳、行星、卫星、小行星等等，都是那个类的<strong class="ky ir">物体</strong>。事实上，月光也在遗传中发挥着作用。因此，我们可以把OOP的概念和很多事情联系起来。那么，让我们更熟悉一下围棋。</p><h1 id="c8ca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是哎呀，为什么我们需要使用它们？</h1><p id="b2a0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">OOPs代表<em class="mp">面向对象的编程系统，而</em>是一种编程类型，在这种编程中，我们需要定义数据类型的数据结构和特定的操作，以模块化我们的程序结构。更多可以参考这个链接:<a class="ae kv" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Object-oriented_programming</a></p><p id="1612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们需要模块化我们复杂的代码结构，使它更可靠，更易维护，为代码库提供一个好的框架等等时，我们需要OOPs。</p><h1 id="14e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Go实际上使用OOPs概念还是一种OOP语言？</h1><p id="41c7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们考虑一下Go是一种轻量级的面向对象编程语言，因为Go很简单。使用相同的哎呀概念，但不要一次全部使用。首先，Go不是一种面向对象的语言，它不是被设计成那样的，因为OOPs的原理被设计成由类和对象结构组成，通过实现超类、抽象类、构造函数、对象、派生类和析构函数等来维护代码基础结构。嗯，那有很多。说到Go，它只是用自己的方式实现了它的OOPs结构。这场争论可能会持续很长时间，但这里有一个官方的常见问题解答链接:<a class="ae kv" href="https://go.dev/doc/faq#Is_Go_an_object-oriented_language" rel="noopener ugc nofollow" target="_blank">https://go.dev/doc/faq#Is_Go_an_object-oriented_language</a>。去看看。</p><p id="3d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一些关于围棋的OOPs的概念，让我们试着熟悉一下。</p><h2 id="0440" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">包装</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/e8fbe39ea2794b1597005eadb3f7f373.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LrOvPSXUBcPkDO9n"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴恩·托普金</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="f667" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，<a class="ae kv" href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)" rel="noopener ugc nofollow" target="_blank">封装</a>意味着如果我们有写在任何类或包中的单一实体数据，它对另一个类或外部世界是隐藏的，而<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstraction_(computer_science)" rel="noopener ugc nofollow" target="_blank">抽象</a>意味着隐藏不必要的信息</p><p id="3a78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Go中，我们在包级别使用这个原则，因为它不提供像private、public和protected这样的访问修饰符<a class="ae kv" href="https://en.wikipedia.org/wiki/Access_modifiers" rel="noopener ugc nofollow" target="_blank">。它还在变量、结构、方法和函数中起作用，所以如果你说，例如，用大写字母声明一个函数，该函数可以很容易地在当前包和另一个包中调用，因此它使它在代码结构中公开可用，而如果你用小写字母声明一个函数，它将只对那个特定的包可用，因此使它更私有和有点安全。</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">围棋中的数据隐藏</p></figure><p id="a834" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，从上面的例子中，您可以看到函数如何根据大小写的不同变成私有和公共的。</p><p id="67d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就OOPs而言，封装和抽象不仅仅是数据隐藏和访问规范，它为类和接口带来了更多的特性，但在Go中，它只是使用了这两个概念的简化版本。</p><h2 id="e169" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">遗产</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/dbc7bf0067386f9263f1d8c6d701302b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IG4MvVVrjeko_8-FN0_ZqA.jpeg"/></div></div></figure><p id="b280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，<a class="ae kv" href="https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)#:~:text=Inheritance%20allows%20programmers%20to%20create,via%20public%20classes%20and%20interfaces." rel="noopener ugc nofollow" target="_blank">继承</a>是指从现有的基(父)类创建新的类(子类或派生类)并实现代码重用。在Go中，没有继承这种东西，但是有<strong class="ky ir">组合</strong>来通过<strong class="ky ir"> struct-embedding </strong>实现结构继承，这意味着将一个结构的字段嵌入到另一个结构中。你可以通过这个链接了解更多关于结构嵌入的知识:<a class="ae kv" href="https://gobyexample.com/struct-embedding" rel="noopener ugc nofollow" target="_blank">https://gobyexample.com/struct-embedding</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">围棋中的构图</p></figure><p id="4820" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果从继承的角度来说，围棋只支持作曲。而继承不仅仅是像那些有JAVA、C++等OOPs语言经验的人那样的组合。</p><h2 id="1050" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">多态性</h2><p id="ed7b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">多态性是oop的概念，在这个概念中，一个对象能够塑造成多种形式，就像我们的例子中的三个蜘蛛侠，从不同的维度看，有不同的形式，但实体是相同的。</p><p id="40e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Go中，我们可以通过在Go <strong class="ky ir">中实现<a class="ae kv" href="https://gobyexample.com/interfaces" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">接口</strong> </a> <strong class="ky ir"> </strong>来实现多态性。接口是方法的集合。让我们更熟悉一个例子。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">围棋中的多态性</p></figure><p id="0d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在上面的例子中，你可以看到Developer struct通过定义像BugFix和Improvement这样的方法来实现Tasks接口。我写这个例子是因为我们开发人员在接受不同版本的任务，如bugfix、改进、hotfix等时，对这些术语更加友好。</p><h2 id="aabb" class="mq lt iq bd lu mr ms dn ly mt mu dp mc lf mv mw me lj mx my mg ln mz na mi nb bi translated">枚举</h2><p id="ced6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Enumerated_type" rel="noopener ugc nofollow" target="_blank">枚举</a>是一种特殊的数据类型，枚举数据由一组元素组成。在许多语言中，大多数枚举数据都是常量类型。<br/>在Go的情况下，我们可以创建枚举并相应地定义常量变量，方法是将<strong class="ky ir"> iota </strong>声明为一系列变量中的第一个变量。iota关键字表示从零开始的整数常量。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="6c69" class="mq lt iq nh b gy nl nm l nn no">const (<br/>     Java = iota<br/>     Go<br/>     Javascript<br/>     Rust<br/>)</span><span id="e0a9" class="mq lt iq nh b gy np nm l nn no">Output: 0 1 2 3</span></pre><p id="4df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一些例子可以让我们更多地了解iota在几种初始化方式下的不同工作方式。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="8652" class="mq lt iq nh b gy nl nm l nn no">const (<br/>     Java = iota<br/>     Go<br/>     _<br/>     Rust<br/>)</span><span id="1ad6" class="mq lt iq nh b gy np nm l nn no">Output: 0 1 3</span></pre><p id="acc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所示，您可以看到_跳过了枚举计数器中的值</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="75d7" class="mq lt iq nh b gy nl nm l nn no">const (<br/>     Java = iota<br/>     Go<br/>)</span><span id="91d0" class="mq lt iq nh b gy np nm l nn no">const (<br/>     Rust = iota<br/>     Javascript<br/>)</span><span id="952a" class="mq lt iq nh b gy np nm l nn no">Output1: 0 1<br/>Output2: 0 1</span></pre><p id="736d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，您可以看到，如果您定义不同的枚举类型常量，它们将有自己的从零开始的增量值。</p><p id="4158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，这就是围棋中的哎呀。在下一篇文章中，我会写我们如何在Go中实现函数式编程，同时我也会提出系统设计原则。</p><p id="5cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">敬请关注。</p></div></div>    
</body>
</html>