<html>
<head>
<title>Getting Started With React.js — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.js入门—第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/getting-started-with-react-js-part-2-3dbd08c680a2?source=collection_archive---------7-----------------------#2019-10-24">https://betterprogramming.pub/getting-started-with-react-js-part-2-3dbd08c680a2?source=collection_archive---------7-----------------------#2019-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7937" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入我们的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cdd875fd4aa86459c91136f1ad40d2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*teK4yjRXfJ5IBavrQueB6g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过<a class="ae ky" href="https://commons.wikimedia.org/wiki/File:React-icon.svg" rel="noopener ugc nofollow" target="_blank">维基共享资源</a>反应图标</p></figure><p id="436a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我上一篇文章的后续。如果你对React一无所知，那么在这里快速地向自己介绍一下<a class="ae ky" href="https://medium.com/better-programming/getting-started-with-react-js-part-1-59598ef17780" rel="noopener">，否则我们将在React中构建一个简单的待办事项应用。所有代码都可以在</a><a class="ae ky" href="https://github.com/FuzzySid/react-todo" rel="noopener ugc nofollow" target="_blank">这里</a>获得。然而，为了充分利用本文，您应该继续编码。如果你在某个地方遇到困难，不要担心，我会在必要的时候给你提供代码和截图，这样你就可以把你的代码和我的代码进行比较，以防事情变糟。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="35dc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在React中使用CSS</h1><p id="32c1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们开始编写任何JavaScript代码之前，我想快速向您介绍一下我们如何向React组件添加样式。</p><p id="1450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还记得我们是如何删除<code class="fe mz na nb nc b">App.css</code> <strong class="lb iu"> </strong>的吗，因为我说我们不需要它了？在React中使用CSS有两种方式:通过本地CSS文件或通过全局CSS文件。本地CSS文件对每个组件都有单独的样式，并且每个组件本身都有自己的CSS文件。这在包含许多需要不同样式的组件的大型应用程序中非常有用。</p><p id="454c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个应用程序，让我们保持简单。让我们把所有的样式放在<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">index.css</code> <strong class="lb iu"> </strong>中，你可以在任何组件中自动使用这些样式。从<a class="ae ky" href="https://github.com/FuzzySid/react-todo/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank">这里</a>复制样式并粘贴到你的<code class="fe mz na nb nc b">index.css</code>中。如果你愿意，你可以跳过这一步，在你编码的时候加入你自己的风格。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0bab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建应用程序组件</h1><p id="d580" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，让我们在我们的<code class="fe mz na nb nc b">App Component</code>状态中添加一些虚拟的<code class="fe mz na nb nc b">todos</code>，这样每次你打开应用程序时，页面上已经有一些<code class="fe mz na nb nc b">todos</code>了。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9eef" class="nh md it nc b gy ni nj l nk nl">import React, {Component} from 'react';</span><span id="6694" class="nh md it nc b gy nm nj l nk nl">export default class App extends Component{<br/>  state={<br/>   'todos':[</span><span id="ec0f" class="nh md it nc b gy nm nj l nk nl">       {'name':'Walk the dog', 'id': 0},</span><span id="43ee" class="nh md it nc b gy nm nj l nk nl">       {'name':'Bake a cake', 'id': 1},</span><span id="2218" class="nh md it nc b gy nm nj l nk nl">        {'name':'Study for the test', 'id': 2}</span><span id="5c99" class="nh md it nc b gy nm nj l nk nl">        ]<br/>      }</span><span id="1b66" class="nh md it nc b gy nm nj l nk nl">render(){<br/>  return(<br/>    &lt;div&gt;<br/>     &lt;h1&gt;To-do list app using React &lt;/h1&gt;<br/>   &lt;/div&gt;<br/>  )<br/> }</span><span id="3ac8" class="nh md it nc b gy nm nj l nk nl">}</span></pre><p id="c46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，我们所做的就是创建一个组件，在<code class="fe mz na nb nc b">state object</code>中添加一个<code class="fe mz na nb nc b">todos</code>变量，这个变量本身是一个包含两个属性<code class="fe mz na nb nc b">name</code>和<code class="fe mz na nb nc b">id</code>的对象的<em class="nn">数组。<code class="fe mz na nb nc b">name</code>就是<code class="fe mz na nb nc b">todo</code>的意思，<code class="fe mz na nb nc b">id</code>是用来唯一标识每个<code class="fe mz na nb nc b">todo</code>的。</em></p><p id="09ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在不要太担心<code class="fe mz na nb nc b">id</code>——如果你愿意，你甚至可以暂时跳过它。让我们回到<code class="fe mz na nb nc b"><em class="nn"> localhost:3000</em></code> <em class="nn"> </em>(还记得吗，我们NPM开始开开发服务器了吗？)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/9e8d67bb7abd9a795e012993c9cf02c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*-Hn2D35cptdNA0TWel--9g.png"/></div></figure><p id="35c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等，<code class="fe mz na nb nc b">todos</code>在哪里？我以为我们把它们呈现在页面上了？</p><p id="f6f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你一行一行地检查代码，我们实际上并没有写任何东西来告诉React获取这个<code class="fe mz na nb nc b">state object</code>，从它那里获取<code class="fe mz na nb nc b">todos</code>数组，循环通过那个数组，并在浏览器上的那个<code class="fe mz na nb nc b">forEach</code>循环中输出name属性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/1e5dd41a7b18cf5416a6ae74f8e6dfc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfBIE1bAL7O1Kn0Rj2tZJA.png"/></div></div></figure><p id="194c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住:我们不会使用<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">App Component</code>来渲染<code class="fe mz na nb nc b">todos </code>——我们只会使用它来维护<code class="fe mz na nb nc b">todos.</code>的当前状态，我们会使用另一个组件(<code class="fe mz na nb nc b">Todos Component</code> <strong class="lb iu"> ) </strong>来输出浏览器上的所有<code class="fe mz na nb nc b">todos</code>。</p><h2 id="d113" class="nh md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">React中的道具</h2><p id="60ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">道具是<em class="nn">不可变的数据</em>或者是我们无法改变的数据。React使用props作为将数据从一个组件发送到另一个组件的方式。这有助于我们创建更加灵活的应用程序，在这些应用程序中，数据必须在各种组件之间进行交换。我们可以传递任何东西作为道具:组件的状态，可能是一些成员函数，几乎任何东西。接收这些道具的组件通过调用名为<code class="fe mz na nb nc b">this.props</code>的对象来访问它们。</p><p id="1904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">状态总是作为道具从父组件传递到子组件。它不应该被传递给兄弟或父组件。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="48ac" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建Todos组件</h1><p id="f000" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建另一个组件<code class="fe mz na nb nc b">todos.js</code>，然后将我们的<code class="fe mz na nb nc b">App Component</code> <strong class="lb iu"> </strong>的<code class="fe mz na nb nc b">state</code>传递给这个<code class="fe mz na nb nc b">Todos Component</code>作为<code class="fe mz na nb nc b">props</code>，并使用那个道具在浏览器上显示所有的<code class="fe mz na nb nc b">todos</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="07fc" class="nh md it nc b gy ni nj l nk nl">import React from 'react';</span><span id="8873" class="nh md it nc b gy nm nj l nk nl">const Todos=({todos})=&gt;{<br/> const todoItems=[];<br/> todos.forEach(todo=&gt;{<br/>  todoItems.push(<br/>    &lt;div key={todo.id}&gt;<br/>      &lt;li&gt;{todo.name} &lt;button className="btn btn-delete"&gt;X&lt;/button&gt;<br/>      &lt;/li&gt;<br/>    &lt;/div&gt;<br/>  )<br/>});</span><span id="9c75" class="nh md it nc b gy nm nj l nk nl">return(<br/>  &lt;div className="list-container"&gt;<br/>    &lt;ul className="list"&gt;<br/>     {todoItems}<br/>   &lt;/ul&gt;<br/>  &lt;/div&gt;<br/> )<br/>}<br/>export default Todos;</span></pre><p id="50ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们只是更新UI，所以我们制作了一个<em class="nn">无状态函数组件</em> <code class="fe mz na nb nc b">todos.js</code>，在<code class="fe mz na nb nc b">Todos()</code> <em class="nn"> </em>函数内部，我们使用从<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">App Component</code> <strong class="lb iu"> </strong>接收的<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">props</code>，并创建一个名为<code class="fe mz na nb nc b">todoItems</code>的空数组。我们循环遍历<code class="fe mz na nb nc b">props</code>，并将一些JSX和每个<code class="fe mz na nb nc b">todo</code>一起放入<code class="fe mz na nb nc b">&lt;li&gt;</code>中。然后在关键字<code class="fe mz na nb nc b">return</code>中，我们返回一些嵌入了数组<code class="fe mz na nb nc b">todoItems</code>的JSX。</p><p id="b1b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">在React中，JavaScript变量可以通过封装在{ }中直接在JSX中输出。</em></p><p id="705c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们所要做的就是将它导入到我们的<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">App Component</code>中，并将我们<code class="fe mz na nb nc b">App Component</code>的<code class="fe mz na nb nc b">state</code>作为<code class="fe mz na nb nc b">props</code>传递给<code class="fe mz na nb nc b">Todos Component</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="92d6" class="nh md it nc b gy ni nj l nk nl">import Todos from ‘./todos’<br/>...</span><span id="6911" class="nh md it nc b gy nm nj l nk nl">...<br/>&lt;Todos todos={this.state.todos}&gt;&lt;/Todos&gt;<br/>...<br/></span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/58a66ab4cda4266b26c50bcc73e60c47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*EpkcQR_QHXA0xtA1RCgQSw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">你的App.js应该是这样的</p></figure><p id="dd6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在检查浏览器:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/a352ac920cf18f05d5202d034eaf2765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*9GlLvH-RzsLuU9ZCNpbzLg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们已经根据应用程序组件的状态在页面上呈现了todos</p></figure><p id="00f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧——我们在浏览器上有了所有的虚拟人<code class="fe mz na nb nc b">todos</code>!</p><p id="a323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到这里，让我们通过点击每个<code class="fe mz na nb nc b">todo</code>上的“X”来实现删除功能。一开始这似乎有点挑战性，所以让我们一步一步来。</p><p id="e7fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在删除按钮上附加一个<em class="nn"> onClick </em>事件监听器，并在事件被触发时触发一个函数。</p><p id="0eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个函数中，我们将传入我们刚刚点击的<code class="fe mz na nb nc b">todo</code>的<code class="fe mz na nb nc b">id</code> <strong class="lb iu"> </strong>。我们可以使用<code class="fe mz na nb nc b">todo.id</code>很容易地访问它，其中<code class="fe mz na nb nc b">todo</code>是我们循环遍历的数组中的每个对象。但是我们如何删除那个<code class="fe mz na nb nc b">todo</code>？如果我们从里到外对<code class="fe mz na nb nc b">todos</code>组件进行这样的操作，我们不会真的删除它，因为我们还没有更新<code class="fe mz na nb nc b">App Component</code>的<code class="fe mz na nb nc b">state</code>，而这正是我们的<code class="fe mz na nb nc b">todos</code>组件获取数据并显示在浏览器上的内容。我们实际上需要从我们的<code class="fe mz na nb nc b">App Component</code>的<code class="fe mz na nb nc b">state</code>中删除那个<code class="fe mz na nb nc b">todo</code>。</p><h2 id="aa67" class="nh md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">React中的<em class="od">设置状态</em></h2><p id="690e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经在React中简要讨论过<code class="fe mz na nb nc b">state</code>。这是与组件相关联的动态数据。正如动态这个词所暗示的，动态数据具有随时间变化的能力，所以<code class="fe mz na nb nc b">state</code>也应该能够改变其中的数据。</p><p id="c137" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而<em class="nn">、</em>你必须<em class="nn">千万不要</em>直接修改状态！这意味着您不应该这样写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="56a1" class="nh md it nc b gy ni nj l nk nl">this.state.todos.push({‘name’:‘clean room’, ‘id’:4})</span></pre><p id="9bca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了改变、修改或更新状态，我们使用一种叫做<code class="fe mz na nb nc b">setState()</code>的方法。该方法将一个对象作为参数，该对象是组件的新状态，在该方法中，我们可以用新状态覆盖旧状态。</p><p id="0552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">引擎盖下，</em> <code class="fe mz na nb nc b"><em class="nn"> setState()</em></code> <em class="nn">不同步。它首先调用该组件的</em> <code class="fe mz na nb nc b"><em class="nn"> render()</em></code> <em class="nn">，然后更新状态。生成一个新视图，然后在DOM中更新它。</em></p><p id="e4e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了删除那个特定的<code class="fe mz na nb nc b">todo</code>，我们引用了它的<code class="fe mz na nb nc b">id</code>。我们使用这个<code class="fe mz na nb nc b">id</code>，并尝试将它与我们状态中的每个<code class="fe mz na nb nc b">todo</code>匹配，并将每个<code class="fe mz na nb nc b">todo</code>推入一个新数组中——除了其<code class="fe mz na nb nc b">id</code>与传递的<code class="fe mz na nb nc b">id</code>匹配的那个。</p><p id="8167" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们在<code class="fe mz na nb nc b">App Component</code>中创建一个删除函数，在这里我们实现这个功能并使用<code class="fe mz na nb nc b">setState()</code>来更新状态:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a363" class="nh md it nc b gy ni nj l nk nl">deleteTodos=(id)=&gt;{</span><span id="55aa" class="nh md it nc b gy nm nj l nk nl">  let todos=this.state.todos.filter(todo=&gt;{<br/>    return todo.id!==id;<br/>  })</span><span id="4815" class="nh md it nc b gy nm nj l nk nl">  this.setState({<br/>     todos: todos<br/>  })</span><span id="56ee" class="nh md it nc b gy nm nj l nk nl">}</span></pre><p id="a4b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将把<code class="fe mz na nb nc b">deleteTodos()</code>函数作为<code class="fe mz na nb nc b">props</code>传递给我们的<code class="fe mz na nb nc b">Todos Component</code>。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="06a4" class="nh md it nc b gy ni nj l nk nl">&lt;Todos deleteTodos={this.deleteTodos} todos={this.state.todos}&gt;&lt;/Todos&gt;</span></pre><p id="a500" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在转到<code class="fe mz na nb nc b">Todos Component</code>，这样我们可以为每个<code class="fe mz na nb nc b">todo</code>附加一个事件监听器，并把那个<code class="fe mz na nb nc b">todo</code>的<code class="fe mz na nb nc b">id</code>作为参数传入。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8108" class="nh md it nc b gy ni nj l nk nl">const Todos=({deleteTodos,todos})=&gt;{<br/>...</span><span id="648d" class="nh md it nc b gy nm nj l nk nl"> &lt;li &gt;{todo.name} &lt;button className=”btn btn-delete”</span><span id="c99e" class="nh md it nc b gy nm nj l nk nl">   onClick={()=&gt;{deleteTodos(todo.id)}}&gt; X<br/>               &lt;/button&gt;<br/>&lt;/li&gt;</span><span id="9ed4" class="nh md it nc b gy nm nj l nk nl">&lt;/div&gt;</span><span id="ab46" class="nh md it nc b gy nm nj l nk nl">)<br/>...</span></pre><p id="05d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到服务器，试着删除一些<code class="fe mz na nb nc b">todos</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="9dc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在可以删除那些<code class="fe mz na nb nc b">todos</code>。</p><p id="4c92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，你学到了很多！你的<code class="fe mz na nb nc b">todos.js</code>或者<code class="fe mz na nb nc b">Todos Component</code>完了！你现在可以在这里对比一下你的<code class="fe mz na nb nc b">Todos Component</code> <a class="ae ky" href="https://github.com/FuzzySid/react-todo/blob/master/src/todos.js" rel="noopener ugc nofollow" target="_blank">的代码。</a></p><p id="bf5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">在继续之前，尝试自己使用</em> <code class="fe mz na nb nc b"><em class="nn">addTodos Component</em></code> <em class="nn">实现在页面上添加</em> <code class="fe mz na nb nc b"><em class="nn">todos</em></code> <em class="nn">的功能。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0071" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建addTodos组件</h1><p id="47fc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我保证这是你最后一次看到这张图表——我知道你现在可能已经厌倦了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/1e5dd41a7b18cf5416a6ae74f8e6dfc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DfBIE1bAL7O1Kn0Rj2tZJA.png"/></div></div></figure><p id="5f9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先弄清楚我们要做什么。为了在页面上添加一些<code class="fe mz na nb nc b">todos</code>，我们将创建一个带有添加按钮的输入字段。每当用户想要在页面上添加一个<code class="fe mz na nb nc b">todo</code>时，我们获取输入的值并将其添加到<code class="fe mz na nb nc b">App Component</code>的<code class="fe mz na nb nc b">state</code> <strong class="lb iu"> </strong>。</p><p id="1956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用一个单独的组件来实现这个功能是合乎逻辑的。一旦你创建了一个<code class="fe mz na nb nc b">addTodos Component</code>，事情就会变得简单。该组件将在<code class="fe mz na nb nc b">render()</code>方法中呈现一个输入标签和一个添加按钮，作为JSX模板。</p><p id="4e8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，它是不是一个<em class="nn">无状态的功能组件</em>？</p><p id="a6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不完全是。我们需要一种方式来告诉组件一个新的<code class="fe mz na nb nc b">todo</code>已经到达，它需要被处理。还有什么比给组件的状态添加新的<code class="fe mz na nb nc b">todo</code>更好的方式呢！这样，我们的组件将引用我们添加的每个新的<code class="fe mz na nb nc b">todo</code>。</p><p id="1ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在我们知道<code class="fe mz na nb nc b">addTodos</code>是一个容器组件，它将有一个<code class="fe mz na nb nc b">state</code>来存储新添加的<code class="fe mz na nb nc b">todo</code>。让我们继续这样做:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="427d" class="nh md it nc b gy ni nj l nk nl">import React,{Component} from ‘react’;</span><span id="89e1" class="nh md it nc b gy nm nj l nk nl">export default class AddTodos extends Component{</span><span id="2284" class="nh md it nc b gy nm nj l nk nl">  state={</span><span id="3a0f" class="nh md it nc b gy nm nj l nk nl">   ‘name’: null</span><span id="80b6" class="nh md it nc b gy nm nj l nk nl">   }</span><span id="d310" class="nh md it nc b gy nm nj l nk nl">render(){</span><span id="cee9" class="nh md it nc b gy nm nj l nk nl"> return(</span><span id="90d8" class="nh md it nc b gy nm nj l nk nl">  &lt;div&gt;</span><span id="78c5" class="nh md it nc b gy nm nj l nk nl">    &lt;form&gt;</span><span id="6dc4" class="nh md it nc b gy nm nj l nk nl">     &lt;label htmlFor=”item”&gt;&lt;/label&gt;</span><span id="5e4e" class="nh md it nc b gy nm nj l nk nl">     &lt;input type=”text” placeholder=”Add a todo…” id=”item”/&gt;</span><span id="b51c" class="nh md it nc b gy nm nj l nk nl">     &lt;button className=”btn btn-add”&gt;Add&lt;/button&gt;</span><span id="df50" class="nh md it nc b gy nm nj l nk nl">   &lt;/form&gt;</span><span id="92ee" class="nh md it nc b gy nm nj l nk nl">  &lt;/div&gt;</span><span id="a0db" class="nh md it nc b gy nm nj l nk nl">  )</span><span id="13af" class="nh md it nc b gy nm nj l nk nl"> }</span><span id="abf2" class="nh md it nc b gy nm nj l nk nl">}</span></pre><p id="2c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要设置我们的<code class="fe mz na nb nc b">addTodos Component</code>的<code class="fe mz na nb nc b">state</code>。我们将把一个<code class="fe mz na nb nc b">onChange</code>事件附加到我们的输入字段，这样组件的状态就会动态变化。当被触发时，该事件将触发一个函数<code class="fe mz na nb nc b">handleChange()</code>，该函数将事件对象作为一个参数，并使用<code class="fe mz na nb nc b">setState()</code>来更新组件的状态。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="38e4" class="nh md it nc b gy ni nj l nk nl">import React,{Component} from ‘react’;</span><span id="3ff5" class="nh md it nc b gy nm nj l nk nl">export default class AddTodos extends Component{</span><span id="f41b" class="nh md it nc b gy nm nj l nk nl">....</span><span id="9be0" class="nh md it nc b gy nm nj l nk nl">handleChange=(e)=&gt;{</span><span id="6c4b" class="nh md it nc b gy nm nj l nk nl"> this.setState({</span><span id="4cd4" class="nh md it nc b gy nm nj l nk nl">  [‘name’]:e.target.value</span><span id="87e5" class="nh md it nc b gy nm nj l nk nl">})</span><span id="9e00" class="nh md it nc b gy nm nj l nk nl">render(){</span><span id="5f07" class="nh md it nc b gy nm nj l nk nl">...</span><span id="96cd" class="nh md it nc b gy nm nj l nk nl">  &lt;input onChange={this.handleChange} type=”text” placeholder=”Add a         todo…” id=”item”/&gt;</span><span id="9d40" class="nh md it nc b gy nm nj l nk nl">....</span><span id="8c8a" class="nh md it nc b gy nm nj l nk nl">}</span></pre><p id="f218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这是如何工作的。</p><p id="c991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">handleChange()</code>方法中注销我们组件的<code class="fe mz na nb nc b">state</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e978" class="nh md it nc b gy ni nj l nk nl">handleChange=(e)=&gt;{</span><span id="9c50" class="nh md it nc b gy nm nj l nk nl">  this.setState({<br/>[‘name’]:e.target.value<br/>})</span><span id="3877" class="nh md it nc b gy nm nj l nk nl"> console.log(this.state);</span><span id="b082" class="nh md it nc b gy nm nj l nk nl">}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/671d35c40d0ed1273a965e98189e76ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3SZs_LPiadd6vcXkp5ovg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">您的addTodos组件应该如下所示</p></figure><p id="c7b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，我们直接从我们的根组件，也就是<code class="fe mz na nb nc b">App Component</code>，渲染一切。因此，将它导入到<code class="fe mz na nb nc b">App.js</code>中，并在其渲染方法中将该组件渲染为JSX。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6954" class="nh md it nc b gy ni nj l nk nl">...<br/>import AddTodos from ‘./addtodos’;<br/>...<br/>render(){<br/>....<br/>  &lt;AddTodos&gt;&lt;/AddTodos&gt;<br/>...<br/>}</span></pre><p id="4dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转到浏览器并查看其运行情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh of l"/></div></figure><p id="d725" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态在动态更新——酷！</p><p id="1363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在剩下唯一要做的事情就是当我们点击add按钮时将这些<code class="fe mz na nb nc b">todos</code>添加到页面中。你可能会猜测我们将简单地使用一个<code class="fe mz na nb nc b">onSubmit</code>事件，并将我们的<code class="fe mz na nb nc b">addTodos Component</code> <strong class="lb iu"> </strong>的<code class="fe mz na nb nc b">state</code>作为<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">props</code>传递给<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">App Component</code> <strong class="lb iu">。但是有一个条件。记住:<em class="nn">状态只能作为道具从父组件传递给子组件</em>。</strong></p><p id="6039" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没问题。在这种情况下，我们将直接把<code class="fe mz na nb nc b">addTodos Component</code>的状态传递给<code class="fe mz na nb nc b">Todos Component</code>。但是等等…将状态作为道具从一个兄弟传递给另一个兄弟<em class="nn">也是不允许的</em>。</p><p id="1153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我们不能用<code class="fe mz na nb nc b">addTodos Component</code>的状态做<em class="nn">任何</em>的事情吗？</p><p id="bf39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要担心，有一个简单的解决方法。我们可以在我们的<code class="fe mz na nb nc b">addTodos Component</code>中创建一个函数，它接受当前的<code class="fe mz na nb nc b">todo</code>作为参数，给它分配一个惟一的<code class="fe mz na nb nc b">id</code>，然后将它添加到我们的<strong class="lb iu"> </strong> <code class="fe mz na nb nc b">App Component</code>的<code class="fe mz na nb nc b">state</code>中。我们将这个函数作为<code class="fe mz na nb nc b">props</code>传递给<code class="fe mz na nb nc b">addTodos Component</code>，后者在我们的<code class="fe mz na nb nc b">onSubmit</code>函数中触发它，从这里我们将<code class="fe mz na nb nc b">addTodos Component</code>的<code class="fe mz na nb nc b">current state</code> <strong class="lb iu"> </strong>传递给<em class="nn"> </em> <code class="fe mz na nb nc b">addTodos()</code>函数。</p><p id="cc89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="66ed" class="nh md it nc b gy ni nj l nk nl">...<br/>import AddTodos from './addTodos';</span><span id="af4f" class="nh md it nc b gy nm nj l nk nl">export default class App extends Component{</span><span id="140c" class="nh md it nc b gy nm nj l nk nl">...</span><span id="eaa7" class="nh md it nc b gy nm nj l nk nl">addTodos=(newTodo)=&gt;{<br/>  newTodo.id=this.state.todos[this.state.todos.length-1].id+1;<br/>  let todos=[...this.state.todos,newTodo]<br/>  this.setState({<br/>    todos<br/> })</span><span id="f5e2" class="nh md it nc b gy nm nj l nk nl">...</span><span id="ceba" class="nh md it nc b gy nm nj l nk nl">render(){</span><span id="ab4f" class="nh md it nc b gy nm nj l nk nl">  ...</span><span id="2ef2" class="nh md it nc b gy nm nj l nk nl">   &lt;AddTodos addTodos={this.addTodos} /&gt;</span><span id="5b90" class="nh md it nc b gy nm nj l nk nl"> ...</span><span id="8f58" class="nh md it nc b gy nm nj l nk nl">}</span></pre><p id="0d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要调用这个我们作为<code class="fe mz na nb nc b">props</code>得到的方法，并把<code class="fe mz na nb nc b">addTodos Component</code>的<code class="fe mz na nb nc b">state</code>作为参数传入。我们将在附加到表单的<code class="fe mz na nb nc b">onSubmit</code>事件被触发后触发的<code class="fe mz na nb nc b">handleSubmit</code>函数中做这件事。在这个事件中，我们首先需要防止提交时重新加载页面的默认操作。我们还需要重置表单内的输入字段。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d0e9" class="nh md it nc b gy ni nj l nk nl">....</span><span id="2d3f" class="nh md it nc b gy nm nj l nk nl">export default class AddTodos extends Component{</span><span id="ee46" class="nh md it nc b gy nm nj l nk nl">...</span><span id="765a" class="nh md it nc b gy nm nj l nk nl">  handleSubmit=(e)=&gt;{</span><span id="1152" class="nh md it nc b gy nm nj l nk nl">          e.preventDefault();</span><span id="28e0" class="nh md it nc b gy nm nj l nk nl">         this.props.addTodos(this.state);</span><span id="4a17" class="nh md it nc b gy nm nj l nk nl">         document.querySelector(‘form’).reset();</span><span id="0719" class="nh md it nc b gy nm nj l nk nl">     }</span><span id="0d1b" class="nh md it nc b gy nm nj l nk nl">...</span><span id="52bb" class="nh md it nc b gy nm nj l nk nl">}</span></pre><p id="c79d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快好了！</p><p id="9a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过将这个<code class="fe mz na nb nc b">handleSubmit()</code>函数附加到我们的<code class="fe mz na nb nc b">onSubmit</code>事件来总结一下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5948" class="nh md it nc b gy ni nj l nk nl">...</span><span id="bbc3" class="nh md it nc b gy nm nj l nk nl">export default class AddTodos extends Component{</span><span id="0c38" class="nh md it nc b gy nm nj l nk nl">    ....<br/>    render(){<br/>      return(<br/>          ....</span><span id="9fde" class="nh md it nc b gy nm nj l nk nl">         &lt;form onSubmit={this.handleSubmit}&gt;</span><span id="4aea" class="nh md it nc b gy nm nj l nk nl">          ...<br/>      )<br/>   }</span><span id="718c" class="nh md it nc b gy nm nj l nk nl">...</span><span id="8881" class="nh md it nc b gy nm nj l nk nl">}</span></pre><p id="3bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nn">*十指交叉* </em>现在让我们检查一下开发服务器…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi of l"/></div></figure><p id="491b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长舒一口气！现在，您已经理解了基础知识，并在React.js中编写了第一个简单的应用程序！</p><p id="294d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以逐行检查你的应用程序组件，这里是<a class="ae ky" href="https://github.com/FuzzySid/react-todo/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank"/>，这里是<code class="fe mz na nb nc b">Add Todos Component</code> <a class="ae ky" href="https://github.com/FuzzySid/react-todo/blob/master/src/addtodos.js" rel="noopener ugc nofollow" target="_blank">，</a>，以防你遗漏了什么。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e1a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">React要学的就这些吗？</h1><p id="4f07" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">显然，React中还有更多——可能是更多——需要探索。我们只学了最基本的。</p><p id="65f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在其<a class="ae ky" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">官网</a>上阅读更多关于React的内容。作为练习，尝试使用React.js构建一个简单的井字游戏，这在他们的<a class="ae ky" href="https://reactjs.org/tutorial/tutorial.html" rel="noopener ugc nofollow" target="_blank">教程部分</a>中有精彩的解释。</p></div></div>    
</body>
</html>