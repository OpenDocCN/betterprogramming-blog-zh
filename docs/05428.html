<html>
<head>
<title>How I Enabled CORS for Any API on My Single-Page App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在我的单页应用程序上为任何API启用CORS</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-enabled-cors-for-any-api-on-my-single-page-app-c51700dc7c29?source=collection_archive---------14-----------------------#2020-07-07">https://betterprogramming.pub/how-i-enabled-cors-for-any-api-on-my-single-page-app-c51700dc7c29?source=collection_archive---------14-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c699" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你也可以</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2f897d1faae9516bfbfc52806d1b89f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*aodimLvT-mWkN5e8-1fn0A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">jose aljovin 在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="6463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示我如何使用任何人都可以获得的免费服务为我的应用程序构建一个小代理服务器，以克服我的单页应用程序的某些CORS限制。</p><p id="926c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我构建了<a class="ae kv" href="https://chisel.cloud" rel="noopener ugc nofollow" target="_blank">凿子</a>来帮助我在工作中做一些重复的API响应组合和操作。</p><p id="c99a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个单页应用程序，允许您针对任何API端点执行请求，并组合结果以仅提取您需要的内容。<a class="ae kv" href="https://alediaferia.com/2020/05/08/how-used-chisel-pull-gitlab-pipelines-stats/" rel="noopener ugc nofollow" target="_blank">它还允许CSV导出。非常简单。</a></p><p id="cef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于它仍处于早期阶段，我决定用最简单的架构来构建它，以便能够快速迭代。我选择了JAMstack，在React中构建它，并部署在Netlify上。</p><p id="68b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为它没有与之对话的后端服务器，所以你做的任何事情都留在你的机器上。不幸的是，并不是所有的API都支持跨源请求，所以在某些情况下，除非启用代理功能，否则您将无法从浏览器执行任何请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/5af7f2574f2ea8319ec8375574f95c16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t6OkrGBgVaAt1Gni.png"/></div></div></figure><p id="538c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不这样做，你的浏览器将会尝试一个CORS预检请求，如果API没有用预期的标题响应，那么这个请求将会失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/68e3427ecc55524a7dd41cc62cc2dacf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tHoZOo5_uJ-2Hav_.png"/></div></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="568d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">什么是CORS，什么时候它会成为你的单页应用的问题？</h1><p id="b2d2" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">来自<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>:</p><blockquote class="mx my mz"><p id="e4e0" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated"><strong class="ky ir">“跨来源资源共享</strong> ( <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>)是一种机制，它使用额外的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" rel="noopener ugc nofollow" target="_blank"> HTTP </a>头来告诉浏览器，让运行在一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/origin" rel="noopener ugc nofollow" target="_blank">来源</a>的web应用程序访问来自不同来源的选定资源。当web应用程序请求来源(域、协议或端口)与其自身不同的资源时，它会执行跨来源HTTP请求。</p></blockquote><p id="2d24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在有一些被称为<em class="na">简单请求</em>的请求不会触发CORS检查。不幸的是，这些类型的请求非常有限，不允许您传递某些头，比如<code class="fe ne nf ng nh b">Authorization</code>头(例如，一个basic-auth请求)。你可以在这里阅读更多关于这类请求的信息<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Simple_requests" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="43c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于这个原因，我们将允许一组好的HTTP方法和头通过我们的代理，并尽可能不加改变地返回响应。</p><p id="df4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大部分工作将是配置正确的一组<code class="fe ne nf ng nh b">Access-Control-Allow-*</code>标题，当CORS预检执行时，这些标题将返回给浏览器。我建议你看一下<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>来了解更多关于CORS的信息，因为它非常全面。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="60d2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">设置NGINX</h1><p id="5023" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">代理本身是NGINX的一个简单实例，配置了一个服务器，允许对动态目的地的代理请求。</p><p id="439d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了能够在Heroku上运行NGINX，我们必须做一些修改，以非特权用户的身份运行它。</p><p id="0baa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们基本上确保NGINX将尝试写入非特权可写位置:这是因为Heroku强制我们的容器作为非根运行。你可以在这里阅读更多相关信息<a class="ae kv" href="https://devcenter.heroku.com/articles/container-registry-and-runtime" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="041a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">考虑任何URL</h1><p id="2c32" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这种配置的第二个方面实际上是定义我们的动态代理:我们将把请求转换成任何URL，这样它们将公开正确的CORS信息。</p><p id="b48a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Chisel 案例的主要复杂性在于我们希望允许任何URL被代理。当然，这是因为我们不会提前知道用户将输入什么样的URL。</p><p id="9662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NGINX允许设置代理功能的方式是通过指令:</p><blockquote class="mx my mz"><p id="dc36" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">"设置代理服务器的协议和地址以及位置应该映射到的可选URI。作为协议，可以指定<code class="fe ne nf ng nh b">http</code>或<code class="fe ne nf ng nh b">https</code></p><p id="ebc3" class="kw kx na ky b kz la jr lb lc ld ju le nb lg lh li nc lk ll lm nd lo lp lq lr ij bi translated">— NGINX文档</p></blockquote><p id="3906" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了能够指定要动态传递的URL，我决定使用一个自定义头:<code class="fe ne nf ng nh b">X-Chisel-Proxied-Url</code>。这样，我们将使用这个头来告诉代理要代理到哪个目的地。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="ffd0" class="nm mb iq nh b gy nn no l np nq">proxy_pass $http_x_chisel_proxied_url;</span></pre><p id="04fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NGINX中的<code class="fe ne nf ng nh b">$</code>符号用于引用变量，HTTP头使用上面的语法自动转换成以<code class="fe ne nf ng nh b">$http_</code>为前缀的<a class="ae kv" href="https://nginx.org/en/docs/http/ngx_http_core_module.html#var_http_" rel="noopener ugc nofollow" target="_blank">变量</a>。</p><p id="f79b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个NGINX服务器配置中有相当多的事情要经历。让我们先从<code class="fe ne nf ng nh b">location /</code>区块开始。</p><p id="62c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一部分是<code class="fe ne nf ng nh b">if</code>语句:它处理<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests" rel="noopener ugc nofollow" target="_blank"> CORS预触发请求</a>的情况，默认情况下它基本上允许一堆HTTP方法和头。它将一切都限制在<code class="fe ne nf ng nh b">https://chisel.cloud</code>源，只是因为我不希望我的代理被其他应用程序使用。</p><ul class=""><li id="32b7" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated"><code class="fe ne nf ng nh b">proxy_redirect off</code>:我暂时禁用了重定向。我仍然不确定我将如何处理它们，所以我决定把它们关掉，直到我能为它们找到一个用例。</li><li id="5a85" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><code class="fe ne nf ng nh b">proxy_set_header Host $proxy_host</code>:这只是将目的主机作为<code class="fe ne nf ng nh b">Host</code>报头转发。这是通过浏览器的有效HTTP请求的一个要求。该值将与为<code class="fe ne nf ng nh b">proxy_pass</code>设置的值完全相同。</li><li id="4447" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><code class="fe ne nf ng nh b">proxy_set_header X-Real-IP $remote_addr</code>:在这里，我们只是负责将客户端IP转发到目的地</li><li id="bead" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><code class="fe ne nf ng nh b">proxy_pass $http_x_chisel_proxied_url</code>:这是整个配置真正重要的一点。我们从Chisel客户端应用程序获取头部，并将其设置为URL。这有效地使动态代理成为可能。</li><li id="a25d" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated"><code class="fe ne nf ng nh b">proxy_hide_header 'access-control-allow-origin'</code>:这和下面的<code class="fe ne nf ng nh b">add_header 'access-control-allow-origin' 'https://chisel.cloud'</code>一起，基本上是确保用一个只允许来自Chisel应用程序的请求的头覆盖从目的服务器返回的任何<code class="fe ne nf ng nh b">Access-Control-Allow-Origin</code>头。</li></ul><p id="f01d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，最上面的两条指令:</p><ul class=""><li id="cd0c" class="nr ns iq ky b kz la lc ld lf nt lj nu ln nv lr nw nx ny nz bi translated"><code class="fe ne nf ng nh b">resolver</code>:这是必需的，这样NGINX就知道如何解析上游服务器的名称，以便进行代理。就我而言，我选择了一个公共的免费DNS。你可以从<a class="ae kv" href="https://public-dns.info/" rel="noopener ugc nofollow" target="_blank">这里</a>挑选你的。</li><li id="4b6e" class="nr ns iq ky b kz oa lc ob lf oc lj od ln oe lr nw nx ny nz bi translated">相反，这条指令使得在Heroku上使用Docker成为可能。我们将在这篇文章的后面看到它，所以请继续阅读！</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f05d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">构建容器映像</h1><p id="3d66" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如上所述，我准备用NGINX的<a class="ae kv" href="https://hub.docker.com/_/nginx" rel="noopener ugc nofollow" target="_blank">基图</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/99161f725263ad02fe8e48bee8c8e4b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*O_T4ucJMAv4LMaX3.png"/></div></div></figure><p id="06c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b"><a class="ae kv" href="https://github.com/chiselcloud/proxy/blob/master/Dockerfile" rel="noopener ugc nofollow" target="_blank">Dockerfile</a></code>非常简单。我们将默认的<code class="fe ne nf ng nh b">nginx.conf</code>替换为我们自己的，以确保NGINX可以无特权运行。我们还复制了我们的代理服务器配置。</p><p id="e884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我将该文件命名为<code class="fe ne nf ng nh b">proxy.conf.tpl</code>。我这样做是为了明确这个文件还不能按原样使用。在启动NGINX之前，我们必须动态地编辑它将在运行时监听的端口。</p><p id="12ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如在<a class="ae kv" href="https://devcenter.heroku.com/articles/container-registry-and-runtime#dockerfile-commands-and-runtime" rel="noopener ugc nofollow" target="_blank">文档</a>中所阐明的，Heroku期望容器能够监听<code class="fe ne nf ng nh b">$PORT</code>环境变量中指定的值。我们在这里使用的解决方案是确保用<code class="fe ne nf ng nh b">$PORT</code>环境变量的实际内容替换我在配置中包含的<code class="fe ne nf ng nh b">$__PORT__$</code>占位符。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ce5e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">建立Heroku</h1><p id="db39" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们快到了。现在我们需要配置我们的应用程序，这样我们就可以直接从我们的存储库部署我们的容器。</p><p id="c143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Heroku上创建一个<a class="ae kv" href="https://dashboard.heroku.com/new-app" rel="noopener ugc nofollow" target="_blank">新的可爱的应用程序</a>,这样我们就可以让它和容器一起工作了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/720013861282eeca9ff95fa5b5d06409.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SCpi82W5WqnyoZuj.png"/></div></div></figure><p id="eae0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们配置应用程序来处理容器图像。我还没有找到通过仪表板来实现它的方法，所以让我们继续使用命令行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/01db4df885ab8067799aa392b7cfb1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t6R4GliURXv-n53g.png"/></div></div></figure><p id="3941" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在将一个简单的<code class="fe ne nf ng nh b">heroku.yml</code>文件添加到您的存储库中，这样Heroku就知道如何构建映像。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="47db" class="nm mb iq nh b gy nn no l np nq">build: <br/>  docker:<br/>    web: Dockerfile</span></pre><p id="9b5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这么简单。</p><p id="e448" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在应用程序仪表板的Deploy <em class="na"> </em>选项卡中，确保将您的存储库连接到应用程序:这样您将能够自动部署。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/d65f34a312b59b095ac5684f4048969a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HYEkrQea2eaRBOVK.png"/></div></div></figure><p id="c30b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你的代理终于准备好了。一旦开始部署，您将能够在应用程序日志中看到它的启动，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/30b5cc3205af9804f76f213a99451141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vp8jUIe5SClizzcM.png"/></div></div></figure><p id="480f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，这个进程是使用我们通过<code class="fe ne nf ng nh b">CMD</code>指令指定的命令启动的，Heroku正在注入<code class="fe ne nf ng nh b">PORT</code>值。</p><p id="6122" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代理启动后，您现在可以通过代理转发您的请求。如上所述，您需要使用定制的<code class="fe ne nf ng nh b">X-Chisel-Proxied-Url</code>头(或者您决定为您的代理配置的任何头)来指定用户想要访问的原始URL。</p><p id="d70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您从下面的动画GIF中看到的，代理功能允许您在点击<a class="ae kv" href="https://date.nager.at/" rel="noopener ugc nofollow" target="_blank">管理器时克服CORS限制。日期</a> API自凿。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/46bfdfd577eeacb92d8aed27891ce6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*Rh0vWYR4cRHT9uqy.gif"/></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2c51" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="f861" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们刚刚构建了一个重用开源技术的代理服务器。这允许我们将单页应用程序与克服CORS限制所需的服务器逻辑分开。</p><p id="506f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，CORS是您的浏览器采用的安全措施之一，以减少劫持您的网站来执行意外活动的机会。即使我们刚刚检查了绕过这个限制的机会，也要再三考虑它是否适合您的用例。</p><p id="6851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望您喜欢这个构建您自己的免费代理服务器的快速演练。</p></div></div>    
</body>
</html>