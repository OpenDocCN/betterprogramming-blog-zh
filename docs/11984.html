<html>
<head>
<title>Using Bitwise Operations to Improve Python Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用按位运算提高Python性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-bitwise-operations-to-improve-python-performance-b0a5593e96aa?source=collection_archive---------13-----------------------#2022-05-02">https://betterprogramming.pub/using-bitwise-operations-to-improve-python-performance-b0a5593e96aa?source=collection_archive---------13-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e9b5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">或者为什么一点点C++能让你走得更远</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ff4d52e03ee3418178805e488ab2b1e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wi9GWDCK5rQOSmCt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="5721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将通过一个算法来使用Python做加法。使用按位运算符和C++扩展模块可以获得与基本Python加法几乎相当的性能。</p><h1 id="a633" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">背景</h1><p id="c584" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我最近一直在与字节和位打交道。我想我应该重温一下我记得以前看到的一些老算法问题。一个经典的问题是:</p><p id="f133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个整数加法“+”运算符。假设你不会用乘法、除法或减法。为简单起见，假设输入只能是非负整数。</p><p id="fb4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先来想一个简单幼稚的解决方法。一种方法是复制长加法，但使用一些简单的记忆来优化它。</p><h1 id="8b08" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">慢速法:查找加法</strong></h1><p id="32ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于长加法，你要把你要加的两个数对齐。从最右边(第一个数字)开始，如果您添加的两个术语大于9，您将继续添加和结转术语。</p><p id="8e5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用伪代码描述这个算法，然后通过一个简单的例子来说明。</p><h2 id="f006" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated"><strong class="ak">伪代码</strong></h2><p id="9bd8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用一个示例更深入地解释这段伪代码的含义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/d4a3da20bab304ba95e89d5028c77d16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30FoiwEOgFuuEGXwydqFMQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查找附加伪代码</p></figure><h2 id="a8ad" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated"><strong class="ak">遍历伪代码</strong></h2><p id="b860" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们举一个把23和48这两个数字相加的例子。将这两个数字视为两个字符串数组:</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="8110" class="ms lw it ng b gy nk nl l nm nn">[‘2’, ‘3’] and [‘4’, ‘8’]</span></pre><p id="f237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们排列数字，然后从右到左。在每个位置，我们将只添加两个一位数(例如位置1的3+8和位置0的2+4)。</p><p id="cf48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要确定两件事:</p><ol class=""><li id="6b16" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">余项</li><li id="9f7a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">结转术语</li></ol><p id="961c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这个例子中讨论它们的含义。<br/> <br/> <strong class="lb iu">位置1 </strong></p><ul class=""><li id="fa0a" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">从两个术语开始:(3，8)</li><li id="11cf" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">余数步骤:余数(3，8) = 1(因为3+8 = 11 mod 10 = 1)</li><li id="d36e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">结转步骤:结转(3，8) = 1(因为3+8 &gt; 9)</li><li id="29e0" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">将余数步骤添加到输出数组:[1]</li></ul><p id="1e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">位置0 </strong></p><ul class=""><li id="7e8b" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">从两个术语开始:(2，4)</li><li id="d9fb" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">将上一步的剩余项前移:(2+1，4)</li><li id="b947" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">余数步骤:余数(3，4) = 7</li><li id="3645" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">结转步骤:结转(3，4) = 0</li><li id="c11f" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">将余数步骤添加到输出数组:[7，1]</li></ul><p id="e3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">最后一步</strong></p><ul class=""><li id="69d9" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">返回串联数组:71</li></ul><p id="df49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到的是，在位置1，余数步骤给出输出中的数字，而进位步骤将增加下一个位置(即位置0)的数字。我们重复这个过程，使用余数步骤追加一个输出数组，直到我们用完两个数组。</p><h2 id="0b98" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">Python代码</h2><p id="3302" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在谈谈python代码。不幸的是，这很复杂。我们不会花时间对此进行重构，因为另一种解决方案可读性更好，速度也更快。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="6a83" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">简单加速</h2><p id="8d1e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以通过定义查找数组来记忆余数和结转步骤:<strong class="lb iu">余数</strong>和<strong class="lb iu">结转数</strong>。我们不会对此进行更深入的研究，但这是该算法的主要速度改进。</p><p id="de76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">余数数组</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ef1a3b039f943fe50644d5e273e4f55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*raPNKF4vtiTSgzam7GUQvw.png"/></div></div></figure><p id="ef59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">遗留阵列</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/f5468fcc724855457817527ff9d088a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JTOk7Rxv_EdDz5LwNSNUkA.png"/></div></div></figure><h1 id="8a5b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">快速方法:位移加法</h1><p id="92fa" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">另一个解决方案是使用位移位操作符。移位相当于将一个数乘以或除以某个基数。例如，在二进制中，数字4表示为[1，0，0]。记住，比特只是系数，所以<code class="fe oh oi oj ng b">4=1*2²+0*2¹+0*2⁰</code>。</p><p id="6d6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左移4位相当于4乘以数字2，因此<code class="fe oh oi oj ng b">BitshiftLeft(4)=8=[1,0,0,0]</code>。</p><h2 id="c69f" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">伪码</h2><p id="c6ff" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">下面我们有一个基于位的算法的伪代码。您马上会注意到，位移加法不依赖于查找数组，而且它的伪代码要短得多。原来它的python/c++代码也非常非常短。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/a8607c7c3bb9bae91d6f1889c9ed8ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psDMxT5Q3rhbWU6PN66fuw.png"/></div></div></figure><h2 id="b727" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">遍历伪代码</h2><p id="a140" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我将介绍这是如何工作的逻辑。我们来做一个比之前更简单的加法，假设要加5+3。</p><p id="d388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们将5、3和8(答案)转换成基数为2的二进制表示:</p><ul class=""><li id="6251" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">5=1*2² +0*2¹+1*2⁰</code></li><li id="0f19" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">3=0*2² +1*2¹+1*2⁰</code></li><li id="4b21" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">8=1*2³+0*2²+0*2¹ +0*2⁰</code></li></ul><p id="0a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要做的基本上是从上面复制我们的结转逻辑，但这次是二进制的。这允许我们以“矢量化”的方式进行结转。</p><p id="58a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法试图找到两位集，使得它们没有值大于0的重叠位。为此，我们交替使用位移位和位掩码。该算法的基本情况是将x，y定义为我们试图相加的输入值:</p><ul class=""><li id="5c61" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">x=[1, 0, 1]</code>(即基数-2中的5)</li><li id="0aa7" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">y=[0,1,1]</code>(即3进制-2)</li></ul><p id="4104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">迭代1 </strong></p><p id="f299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ol">步骤1:使用AND和Bitshift位运算符的结转步骤</em></p><p id="8e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步只是查找3和5之间共享的位，然后在下一步中继续执行。我们结合AND和左移来重新定义x:</p><ul class=""><li id="08ad" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">x=BitshiftLeft(And(x,y)) = [0,1,0]</code></li></ul><p id="d579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解这些步骤:</p><ul class=""><li id="80b5" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">And(x,y) = [0, 0, 1]</code>(因为5和3共用2⁰)</li><li id="95be" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">BitshiftLeft([0,0,1]) = [0, 1, 0]</code>(这相当于2 =2⁰+2⁰)</li></ul><p id="d9b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ol">步骤2:使用OR和位掩码位运算符防止重复计数步骤</em></p><p id="d960" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在步骤1中，我们删除了x和y之间共享的位，我们想从y中删除这些位。</p><ul class=""><li id="3130" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">y=BitMask(Or(x,y), ~And(x,y))=[1,1,0]</code></li></ul><p id="9172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分解这些步骤:</p><ul class=""><li id="78a7" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">~And(x,y) = [1, 1, 0]</code>(这些是我们在步骤1中没有消除的位，我们希望保留)</li><li id="2953" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">Or(x,y) = [1, 1, 1]</code>(这些是我们需要屏蔽的位)</li><li id="db19" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">BitMask([1, 1, 1], [1, 1, 0]) = [1, 1, 0]</code>(屏蔽2⁰位置的位)</li></ul><p id="5009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">停止条件</strong></p><p id="dec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们继续进行这些迭代，直到x和y不共享任何位，也就是说，我们可以简单地将位表示相加。在本例中，这是x和y的最终值:</p><ul class=""><li id="4716" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">最终x=[1，0，0，0]</li><li id="dee9" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">最终y=[0，0，0，0]</li></ul><p id="f398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用OR运算符来得到我们的解:</p><ul class=""><li id="fd82" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated"><code class="fe oh oi oj ng b">8 = Or(x, y) = [1, 0, 0, 0]</code></li></ul><h2 id="a8c1" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">Python代码</h2><p id="b533" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">python代码相对简单明了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h2 id="5e26" class="ms lw it bd lx mt mu dn mb mv mw dp mf li mx my mh lm mz na mj lq nb nc ml nd bi translated">简单加速— C++扩展模块</h2><p id="0401" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个“简单”的加速方法是用C++编写代码并创建一个<a class="ae ky" href="https://docs.python.org/3/extending/index.html" rel="noopener ugc nofollow" target="_blank"> C++扩展模块</a>。扩展模块的代码如下。我们将在python中调用的实际C++函数被定义为<code class="fe oh oi oj ng b">c_bitadd_method</code>，剩下的代码是定义c++类/方法，以便它可以与Python集成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div></figure><h1 id="14c8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结果</h1><p id="1164" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我做了一个简单的实验，改变两个参数:</p><ul class=""><li id="13ed" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">样本总数:使用三个值:100k、1密耳、10密耳</li><li id="5096" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">最大可能数量:使用三个值:100k、10mil、1gl</li></ul><p id="5bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个参数改变了加法的总数，以及整数的大小。例如，当最大可能数= 1bil时，这意味着add函数可能需要将10亿个整数加在一起。<br/> <br/>我测试了4种算法:</p><ol class=""><li id="edd7" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">Python基本加法运算符</li><li id="5df1" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">查找加法(LookupAdd)</li><li id="c459" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">位移加法-Python(PyBitshiftAdd)</li><li id="61e5" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">移位加法— C++ (CPyBitshiftAdd)</li></ol><p id="e46a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下，并且相当清楚:</p><ul class=""><li id="689b" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu oc nu nv nw bi translated">查找添加非常慢:这是意料之中的</li><li id="52ad" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu oc nu nv nw bi translated">用C++编译的比特移位加法执行起来非常接近Python的基本加法操作，鉴于这是第一个版本，很高兴看到这一点:</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/e39ca8015a59668caa860c72f0d5cd88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htkDoU3CMpN36K9jUk_X8g.png"/></div></div></figure><h1 id="8796" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="bd3d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这篇文章简单介绍了如何使用位运算和C++创建一个与Python的加法运算符性能相当的加法函数。</p><pre class="kj kk kl km gt nf ng nh ni aw nj bi"><span id="72aa" class="ms lw it ng b gy nk nl l nm nn">Want to Connect?</span><span id="38a2" class="ms lw it ng b gy on nl l nm nn">I discuss on similar topics on my <a class="ae ky" href="https://ryanlstevens.github.io/2022-05-02-bitshiftAddition/" rel="noopener ugc nofollow" target="_blank">personal website</a>.</span></pre></div></div>    
</body>
</html>