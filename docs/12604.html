<html>
<head>
<title>Writing, Accessing, and Modifying Nested APIs With Ruby and Sinatra</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ruby和Sinatra编写、访问和修改嵌套API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-accessing-and-modifying-nested-apis-with-ruby-sinatra-21c8f0d765?source=collection_archive---------18-----------------------#2022-06-15">https://betterprogramming.pub/writing-accessing-and-modifying-nested-apis-with-ruby-sinatra-21c8f0d765?source=collection_archive---------18-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8cb2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建和修改API对于web开发的每个方面都是必不可少的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fed2812517ff333f5261049d97c3d842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cdvnjcylDm2QJ6pz"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚历克斯·埃克曼在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="b959" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在熨斗学校软件工程项目的第三阶段，我创建了一个API来支持我的模拟应用程序“无家可归者的克莱尔湖社区”，这是一个为无家可归者设想的社区。这个应用程序是为这个社区的管理者和顾问设计的。</p><p id="b00e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">ActiveRecord</code>，我创建了一个居民表和一个居民活动表，其中居民有许多活动和属于一个居民的活动—一对多关系。由于这种关系的结构，activities表有一个外键<code class="fe ls lt lu lv b">resident_id</code>，这是在表之间操作数据的关键。</p><p id="5ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我需要能够在<code class="fe ls lt lu lv b">residents</code>的桌子上执行完整的CRUD，并且能够看到每个居民的活动，为他们创建其他活动，就好像我是一个社区管理员一样。这要求我能够通过API中的居民数据访问活动数据。</p><p id="1e00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了创建API，我在<code class="fe ls lt lu lv b">application_controller.rb</code> <strong class="ky ir"> </strong>文件中编写了必要的端点。下面代码片段中的第一个方法是标准的GET请求，而第二个是单个居民的端点，但是请注意，当我“JSONify”居民数据时，我还包含了相关的活动。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7b44" class="ma mb iq lv b gy mc md l me mf">class ApplicationController &lt; Sinatra::Base<br/>  set :default_content_type, 'application/json'<br/>  <br/>  get "/residents" do<br/>    residents = Resident.all <br/>    residents.to_json<br/>  end<br/><br/>  get "/residents/:id" do<br/>    resident = Resident.find(params[:id])<br/>    resident.to_json(include: :activities)<br/>  end</span></pre><p id="d043" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于有了<code class="fe ls lt lu lv b">resident_id</code> <strong class="ky ir"> </strong>外键，Sinatra能够找到并显示与每个居民相关的活动。</p><p id="1f49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是SQL(创建和管理关系数据库的平台，其数据通常由<code class="fe ls lt lu lv b">ActiveRecord</code>处理)生成的activities表。在该表中，园艺活动的resident_id为9，这意味着该活动与居民9相关联。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/ce0cf44ef354bf73659f407c9363e0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30j8gdXFoyXmyE9no7Vufw.png"/></div></div></figure><p id="76bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种数据库关系的神奇之处在于，任何处理数据的人都可以通过<strong class="ky ir"> </strong>访问一个表。因此，我的<code class="fe ls lt lu lv b">/residents/:id</code>端点能够显示以下内容，其中关于居民的相关活动的信息是嵌套的对象。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8e5e" class="ma mb iq lv b gy mc md l me mf">{<br/>  "id": 5,<br/>  "name": "Carter Daugherty Jr.",<br/>  "date_of_birth": "2001-03-20",<br/>  "phone": "340-239-7307",<br/>  "email": "<a class="ae kv" href="mailto:penny_wilderman@example.org" rel="noopener ugc nofollow" target="_blank">penny_wilderman@example.org</a>",<br/>  "activities": [<br/>    {<br/>      "id": 5,<br/>      "activity": "Exercise",<br/>      "day_of_week": "Thursday",<br/>      "instructor": "Lynda Strosin LLD",<br/>      "resident_id": 5<br/>    }<br/>  ]<br/>}</span></pre><p id="ded7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为用户，这允许我点击一个居民的名字，并看到他们一周的活动。但是我在创建这个应用程序时的挑战是如何为给定的居民创建一个新的活动，因为起初，我认为我必须将新的活动发布到<code class="fe ls lt lu lv b">/residents/:id</code>。事实上，我必须向<code class="fe ls lt lu lv b">/activities</code>发出POST请求，并编写我的前端代码，以便新活动与<code class="fe ls lt lu lv b">resident_id</code>外键相关联。</p><p id="4dda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了发布到activities，我使用Sinatra gem编写了以下Ruby方法。这个端点可以用于为所有居民或单个居民创建新的活动，这取决于我在前端调用它的方式。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d4e4" class="ma mb iq lv b gy mc md l me mf">post "/activities" do <br/>    activity = Activity.create(activity: params[:activity],    <br/>    day_of_week: params[:day_of_week], instructor: <br/>    params[:instructor], resident_id: params[:resident_id])<br/>    activity.to_json<br/>end</span></pre><p id="4cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的应用程序中，管理员可以在每个居民的页面上看到下面所示的新活动表单。表单本身没有任何用于指定与新活动相关联的居民的字段，但是因为该页面的端点是<code class="fe ls lt lu lv b">/residents/2</code> ( <code class="fe ls lt lu lv b">/residents/:id</code>)，所以我可以使用react-router-dom: <code class="fe ls lt lu lv b">const { id } = useParams()</code> <strong class="ky ir">中的<code class="fe ls lt lu lv b">useParams</code>钩子轻松地获取该id。</strong></p><p id="0b08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我将POST请求写到<code class="fe ls lt lu lv b">/activities</code>端点时，我可以使用id发送到后端，将活动绑定到驻留。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/cd3dea571392cdfa9dacebbd3f5500d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OcXLm9ycIN0kNKlNPaoJgw.png"/></div></div></figure><p id="b0ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了抽象出React中的表单数据，我创建了一个名为<code class="fe ls lt lu lv b">actFormData</code>的状态变量，我将它的字段设置为空字符串。我没有在POST请求的主体中只发送<code class="fe ls lt lu lv b">actFormData</code>,而是创建了一个新的变量，该变量也将发送<code class="fe ls lt lu lv b">resident_id: const activityData = {…actFormData, resident_id: id}</code></p><p id="b06a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，因为我设置了一个嵌套的API，所以我不能仅仅使用spread操作符和新元素来编写典型的<code class="fe ls lt lu lv b">handleAddSoAndSo</code>函数。这是我的第一次尝试:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="fad4" class="ma mb iq lv b gy mc md l me mf">function handleAddNewActivity(newActivity) {<br/>   setResident([...resident, newActivity])<br/>}</span></pre><p id="7e70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是看到<code class="fe ls lt lu lv b">setResident</code>函数中的<code class="fe ls lt lu lv b">newActivity</code>元素从一开始就很奇怪。相反，我需要将<code class="fe ls lt lu lv b">newActivity</code>推入常驻对象。只有这样我才能正常。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="eed6" class="ma mb iq lv b gy mc md l me mf">function handleAddNewActivity(newActivity) {<br/>    const residentCopy = {...resident};<br/>    residentCopy.activities.push(newActivity);<br/>    setResident(residentCopy)<br/>}</span></pre><p id="570f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样非常重要的是，在为居民定义状态时，我必须在<code class="fe ls lt lu lv b">residents</code>对象中包含一个空的activities数组:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a43a" class="ma mb iq lv b gy mc md l me mf">const [resident, setResident] = useState({activities: []})</span></pre><p id="eea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我把它保留为<code class="fe ls lt lu lv b">useState([])</code>，我将无法迭代<code class="fe ls lt lu lv b">resident.activities</code>，或者在这种情况下，将一个新的活动推入activities数组。</p><p id="c775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然所有繁重的工作已经完成，我想演示一下，如果我在同一个居民的页面上添加一个新的活动——Carter Daugherty Jr——它将同时出现在前端和后端。在上图中，Daugherty先生的页面上只有两个活动。添加第三个之后，他的页面呈现如下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/a4a2127b8e77ed7524aa972edfc54e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q_nVAgnoXHzHJ5lQ1sGUyA.png"/></div></div></figure><p id="bb25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并且它持续存在于API中:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6657" class="ma mb iq lv b gy mc md l me mf">{<br/>  "id": 5,<br/>  "name": "Carter Daugherty Jr.",<br/>  "date_of_birth": "2001-03-20",<br/>  "phone": "340-239-7307",<br/>  "email": "<a class="ae kv" href="mailto:penny_wilderman@example.org" rel="noopener ugc nofollow" target="_blank">penny_wilderman@example.org</a>",<br/>  "activities": [<br/>    {<br/>      "id": 5,<br/>      "activity": "Exercise",<br/>      "day_of_week": "Thursday",<br/>      "instructor": "Lynda Strosin LLD",<br/>      "resident_id": 5<br/>    },<br/>    {<br/>      "id": 9,<br/>      "activity": "Fishing",<br/>      "day_of_week": "Saturday",<br/>      "instructor": "Bland Simpson",<br/>      "resident_id": 5<br/>    },<br/>    {<br/>      "id": 10,<br/>      "activity": "Computer literacy",<br/>      "day_of_week": "Tuesday",<br/>      "instructor": "Alan Turing",<br/>      "resident_id": 5<br/>    },<br/>  ]<br/>}</span></pre><p id="6b55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们已经了解了如何推断id并将其发送到后端，以及如何将新的活动推入到单个居民的数据对象中，那么让我们完整地看一下POST请求来回顾一下这个过程。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7aa7" class="ma mb iq lv b gy mc md l me mf">function handleActivitySubmit(e) {<br/>   e.preventDefault();<br/>   const activityData = {...actFormData, resident_id: id}<br/>   fetch("<a class="ae kv" href="http://localhost:9292/activities" rel="noopener ugc nofollow" target="_blank">http://localhost:9292/activities</a>", {<br/>      method: "POST",<br/>      headers: {<br/>          "Content-Type": "application/json"<br/>      },<br/>           body: JSON.stringify(activityData)<br/>      })<br/>   .then(r =&gt; r.json())<br/>   .then((newActivity) =&gt; {<br/>       handleAddNewActivity(newActivity);<br/>       setActFormData({<br/>           activity: "",<br/>           day_of_week: "",<br/>           instructor: "",<br/>       })<br/>   })<br/>}</span></pre><p id="15fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，外键是允许开发人员关联表以及通过另一个表<strong class="ky ir"> </strong>访问和操作一个表中的数据的关键，正如我们在这篇博客中看到的。为了创建一个新的活动并在其中将它与一个居民相关联，后端代码仍然是一个普通的POST方法，而前端代码从单个居民的页面获取id，并将其与来自受控的React表单的数据一起发送到服务器。由于建立了关联，我能够将活动推入附加到居民API页面的活动数组中。</p><p id="87b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注:以上使用的数据是使用<a class="ae kv" href="https://fakerjs.dev/" rel="noopener ugc nofollow" target="_blank"> Faker gem </a>生成的。</p></div></div>    
</body>
</html>