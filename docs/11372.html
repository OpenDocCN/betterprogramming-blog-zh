<html>
<head>
<title>Exploring MovableContentOf in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Jetpack Compose中探索MovableContentOf</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-movablecontentof-in-jetpack-compose-6807a43047cd?source=collection_archive---------8-----------------------#2022-03-14">https://betterprogramming.pub/exploring-movablecontentof-in-jetpack-compose-6807a43047cd?source=collection_archive---------8-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="73ea" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">告别Android中的重组视图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/79436b77ff4d3ea78cf27c23c258afe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6djzQ32ibt019QXP0D72Q.png"/></div></div></figure><p id="766b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jetpack Compose最近在版本<code class="fe ln lo lp lq b">1.2.0-alpha03</code>中引入了一个名为<code class="fe ln lo lp lq b">movableContentOf</code>的新功能。</p><p id="2e64" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">顾名思义，这使我们能够移动内容而不需要重组。如果重新压缩的开销很大或者数量很多，这可以节省时间并提高性能。</p><p id="e4ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jetpack compose已经有了一些非常智能的优化<a class="ae lr" href="https://www.jetpackcompose.app/articles/donut-hole-skipping-in-jetpack-compose" rel="noopener ugc nofollow" target="_blank"/>，这些优化会自动应用，以避免不必要的重新组合。尽管它可能很聪明，但我们有时需要手动避免重新编译，而<code class="fe ln lo lp lq b">movableContentOf</code>是这项工作的工具之一。</p><p id="d806" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的工作原理是接收一个可组合的lambda函数，它将记住这个函数并移动到它被调用的任何地方。我认为理解和掌握好处的最好方法是通过一个例子。</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="bce2" class="lw lx iq lq b gy ly lz l ma mb">...<br/>var isRow by remember {  <br/>    mutableStateOf(true)  <br/>}  <br/>  <br/>Column(  <br/>    horizontalAlignment = Alignment.CenterHorizontally  <br/>) {  <br/>    Button(onClick = { isRow = !isRow }) {  <br/>        Text(text = "Switch")  <br/>    }  <br/>    if (isRow) {  <br/>        Row(  <br/>            Modifier.weight(1f),  <br/>            verticalAlignment = Alignment.CenterVertically  <br/>        ) {  <br/>            LetterBox(letter = 'A')  <br/>            LetterBox(letter = 'B')  <br/>        }  <br/>    } else {  <br/>        Column(  <br/>            Modifier.weight(1f),  <br/>            verticalArrangement = Arrangement.Center  <br/>        ) {  <br/>            LetterBox(letter = 'A')  <br/>            LetterBox(letter = 'B')  <br/>        }  <br/>    }  <br/>}<br/>...</span></pre><p id="6301" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的例子包含两个可以在行或列中显示的框。该按钮可用于在两种模式之间切换。问题是每次点击按钮时，图块都会被重新组合。每当发生重组时，我们都可以通过使用log语句来看到这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/0f884fb841e416b2a28005f4bef5473a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3OiRw-Pg1KpcNeB3.gif"/></div></div></figure><p id="d33b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了防止瓷砖在切换方向时不必要的重组，我们可以引入<code class="fe ln lo lp lq b">movableContentOf</code>。</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="1af8" class="lw lx iq lq b gy ly lz l ma mb">...<br/>val boxes = remember {  <br/>    movableContentOf {  <br/>        LetterBox(letter = 'A')  <br/>        LetterBox(letter = 'B')  <br/>    }  <br/>}  <br/>  <br/>Column(  <br/>    horizontalAlignment = Alignment.CenterHorizontally  <br/>) {  <br/>    Button(onClick = { isRow = !isRow }) {  <br/>        Text(text = "Switch")  <br/>    }  <br/>    if (isRow) {  <br/>        Row(  <br/>            Modifier.weight(1f),  <br/>            verticalAlignment = Alignment.CenterVertically  <br/>        ) {  <br/>            boxes()  <br/>        }  <br/>    } else {  <br/>        Column(  <br/>            Modifier.weight(1f),  <br/>            verticalArrangement = Arrangement.Center  <br/>        ) {  <br/>            boxes()  <br/>        }  <br/>    }  <br/>}<br/>...</span></pre><p id="7e19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用<code class="fe ln lo lp lq b">movableContentOf</code>，盒子只会被组合一次。当方向切换时，相同的盒子将会相应地重新排列，而不会重新组合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/013b471f1b415be0564878eb289d83e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vCjCvAIe039eHd3w.gif"/></div></div></figure><p id="063b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个可能派上用场的场景是在列表中。在下一个示例中，它用于正确维护状态并避免列中不必要的重新计算。</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="939e" class="lw lx iq lq b gy ly lz l ma mb"><a class="ae lr" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a>  <br/>fun ColumnExample() {  <br/>    val list = remember {  <br/>        mutableStateListOf&lt;String&gt;().apply {  <br/>            for (i in 0..20) add("Counter ${'A' + i}")  <br/>        }  <br/>    }  <br/>  <br/>    Column {  <br/>        Button(onClick = {  <br/>            list.removeFirstOrNull()  <br/>        }) {  <br/>            Text(text = "Remove first")  <br/>        }  <br/>        Column(  <br/>            modifier = Modifier  <br/>    .verticalScroll(state = rememberScrollState())  <br/>                .weight(1f)  <br/>        ) {  <br/>            list.forEach {  <br/>                Counter(text = it)  <br/>            }  <br/>        }  <br/>    }  <br/>}</span></pre><p id="f5e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们有一列计数器和一个删除列表中第一个计数器的按钮。但是，如果我们运行应用程序并检查日志语句，我们会注意到两个主要问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/658f6fb6a0ca8de5c8e523f5be1ae93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*44DNM2GP1RcMDAfu.gif"/></div></div></figure><p id="4afd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，应用程序不能正确维护状态。当第一个计数器被移除时，计数器的状态移动到下面的位置。其次，日志语句表明，删除一个计数器会重新组合其位置受到影响的每个项目。使用<code class="fe ln lo lp lq b">movableContentOf</code>我们可以保持计数器的正确状态，并且当我们只需要在列中移动计数器的位置时，可以避免重新计算。</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="c597" class="lw lx iq lq b gy ly lz l ma mb">...<br/>val listComposables = list.movable {  <br/>    Counter(text = it)  <br/>}  <br/>  <br/>Column {  <br/>    Button(onClick = {  <br/>        list.removeFirstOrNull()  <br/>    }) {  <br/>        Text(text = "Remove first")  <br/>    }  <br/>    Column(  <br/>        modifier = Modifier  <br/>   .verticalScroll(state = rememberScrollState())  <br/>            .weight(1f)  <br/>    ) {  <br/>        list.forEach {  <br/>            listComposables(it)  <br/>        }  <br/>    }  <br/>}<br/>...</span></pre><p id="2247" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">扩展函数<code class="fe ln lo lp lq b">movable</code>定义为:</p><pre class="kg kh ki kj gt ls lq lt lu aw lv bi"><span id="f421" class="lw lx iq lq b gy ly lz l ma mb"><a class="ae lr" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a>  <br/>fun &lt;T&gt; List&lt;T&gt;.movable(  <br/>    transform: <a class="ae lr" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a> (item: T) -&gt; Unit  <br/>): <a class="ae lr" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a> (item: T) -&gt; Unit {  <br/>    val composedItems = remember(this) { mutableMapOf&lt;T, <a class="ae lr" href="http://twitter.com/Composable" rel="noopener ugc nofollow" target="_blank">@Composable</a> () -&gt; Unit&gt;() }  <br/>    return { item: T -&gt;  <br/>        composedItems.getOrPut(item) {  <br/>            movableContentOf { transform(item) }  <br/>        }.invoke()  <br/>    }  <br/>}</span></pre><p id="3690" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们现在运行它，我们将看到计数器的状态被正确保存，同时，当移动位置时，计数器不会被重新组合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mc"><img src="../Images/cadeafa8ca3f93e4ca05e84d06746d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RmPY8B6vkn0qsk9X.gif"/></div></div></figure><p id="eb1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完整的代码可在<a class="ae lr" href="https://github.com/sinasamaki/movableContentOf/tree/main" rel="noopener ugc nofollow" target="_blank">这里</a>获得。这只是两个例子，但是使用<code class="fe ln lo lp lq b">movableContentOf</code>来提高代码性能的可能性有很多。如果你需要更多关于如何使用它的信息，你可以直接去<a class="ae lr" href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/runtime/design/movable-content.md" rel="noopener ugc nofollow" target="_blank"> android docs </a>。在这里，你还可以找到更多关于它在不同情况下的行为的信息。</p><p id="b3fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢阅读，祝你好运！</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="c8e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mk">原载于</em><a class="ae lr" href="https://sinasamaki.com/post/2022-03-14-movable-content-of/" rel="noopener ugc nofollow" target="_blank"><em class="mk"/></a><em class="mk">。</em></p></div></div>    
</body>
</html>