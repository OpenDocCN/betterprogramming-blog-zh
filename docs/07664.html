<html>
<head>
<title>Deploy a Python API With Docker and Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker和Kubernetes部署Python API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/python-fastapi-kubernetes-gcp-296e0dc3abb6?source=collection_archive---------2-----------------------#2021-02-08">https://betterprogramming.pub/python-fastapi-kubernetes-gcp-296e0dc3abb6?source=collection_archive---------2-----------------------#2021-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f05" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自动扩展计算密集型工作负载，以跟上不断变化的需求</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9db7daa5141cc654dc60c3be7435e6c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fRIL0ju9I7iIN3gYOzn44A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:作者</p></figure><p id="bba2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Kubernetes允许您跨集群部署多容器应用程序——无论是在您自己的机器上还是在云中。API是应用程序的网关，是用户(甚至其他服务)可以用来与之交互的接口。然而，构建一个API并不是一件难事。有了<a class="ae lu" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>你可以在几分钟内拥有一个工作系统，并且在你打包部署的每个阶段调试和测试都很简单。</p><p id="8baa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将介绍:</p><ol class=""><li id="464e" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">使用FastAPI在Python中构建一个兼容<a class="ae lu" href="https://www.openapis.org/" rel="noopener ugc nofollow" target="_blank"> OpenAPI </a>的接口</li><li id="983e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">将API打包到一个<a class="ae lu" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>容器中</li><li id="6abb" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">部署到本地<a class="ae lu" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群</li><li id="a726" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">使用<a class="ae lu" href="https://locust.io/" rel="noopener ugc nofollow" target="_blank">蝗虫</a>进行负载测试</li><li id="dc1d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">使用<a class="ae lu" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> Google Cloud Kubernetes引擎</a>部署到云(GKE)</li></ol></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="7c5f" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">快速入门</h1><p id="91bc" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">如果您只想快速启动并运行，可以克隆配套的存储库，并按照说明部署到本地Kubernetes集群或Google cloud:</p><div class="nn no gp gr np nq"><a href="https://github.com/4OH4/kubernetes-fastapi" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">4OH4/kubernetes-fastapi</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">Kubernetes中的准系统Python FastAPI基于FastAPI-AWS-lambda-example(MIT License):运行(独立)…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ks nq"/></div></div></a></div><p id="486d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您需要本地集群进行开发，请遵循 <code class="fe of og oh oi b"><a class="ae lu" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">minikube</a></code>的<a class="ae lu" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">设置说明。</a></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0c72" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">介绍</h1><p id="8a26" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">API是你的代码的接口，无论它是一个推荐新内容的光滑的新人工智能模型，还是一个在网络上爬行寻找答案的长期运行的数据处理服务。API使得你的代码可以被访问，这样你就可以和全世界分享它。如果您使用一个处理样板代码的框架，那么在Python中部署API是很容易的。</p><p id="37a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将服务打包到Docker容器中。这创建了一个方便的包，它包含了运行我们的代码所需的所有依赖项。它也是一个方便的构建块，我们可以用它来进行水平扩展:如果需求增加，部署更多的容器映像副本。我们使用Kubernetes来管理流程编排——随着需求的变化自动调整部署。</p><p id="6fb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，容器不是唯一的选择:功能即服务(Function-as-a-service，FaaS)是一种流行的途径，特别适合从云服务提供API。事实上，本文的灵感来自于另一篇关于将API部署到Amazon Web Services (AWS) Lambda函数的文章:</p><div class="nn no gp gr np nq"><a href="https://iwpnd.pw/articles/2020-01/deploy-fastapi-to-aws-lambda" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd iu gy z fp nv fr fs nw fu fw is bi translated">如何使用AWS SAM将fastAPI持续部署到AWS Lambda</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">我上一篇关于fastAPI的文章应该是一篇关于如何在预算范围内部署fastAPI的文章，但是…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">iwpnd.pw</p></div></div><div class="nz l"><div class="oj l ob oc od nz oe ks nq"/></div></div></a></div><p id="3d87" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“功能即服务”是无服务器模式的一部分，它让您专注于编写实现您的需求的代码，而服务提供商则解决如何部署和扩展的问题。它是容器使用之上的一个抽象层。如果你的代码非常标准(例如，纯Python ),并且预计在几秒钟(或几分钟)内完成执行，那么它是值得考虑的。</p><p id="c9e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在本文中使用的例子在FaaS模型中可以很好地工作，但是出于几个原因，我没有选择走这条路。在构建作为本文基础的系统时，我们希望能够在内部系统和云系统之间轻松切换。不依赖于任何特定的云提供商也是有利的；我在下面使用了Google Kubernetes引擎，但是API代码也可以在Amazon Elastic Kubernetes服务上很好地工作。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ddbc" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">构建API</h1><p id="7dea" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们使用Python包FastAPI作为构建API的框架。主要特点:</p><ul class=""><li id="c435" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ok mb mc md bi translated">它是异步的，所以可以处理多个并发请求；</li><li id="f0e5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">它是OpenAPI兼容的，所以很容易记录和与API交互——比如使用包含的UI(见下面的截图)。</li><li id="269d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">它基于<a class="ae lu" href="https://pydantic-docs.helpmanual.io/" rel="noopener ugc nofollow" target="_blank"> pydantic </a>，因此您可以使用标准Python数据类型指定输入和输出数据结构——无需额外的语法或标记语言。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/c71d55ce7383affb60b33ff06baae912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ALL0tEgh6QrFyWb-DErnKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">记录API端点的UI (SwaggerUI)的屏幕截图，甚至可以让您测试每个端点。</p></figure><p id="cbdf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码库包含以下主要文件:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="3552" class="oq mr it oi b gy or os l ot ou">kubernetes-fastapi/<br/>├── Dockerfile<br/>├── api.yaml<br/>├── autoscale.yaml<br/>├── locustfile.py<br/>├── requirements.txt<br/>├── Dockerfile<br/>└── service/<br/>    ├── main.py<br/>    └── api/<br/>        ├── api_v1/<br/>        │  ├── api.py<br/>        │  └── endpoints/<br/>        │      └── hello.py<br/>        └── core/<br/>            ├── config.py<br/>            ├── logic/<br/>            │   └── business_logic.py<br/>            └── models/<br/>                └── input.py<br/>                └── output.py</span></pre><p id="6282" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为您的目的定制API:</p><p id="8ae4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">更新<code class="fe of og oh oi b">models/</code>中的输入和输出数据结构。<code class="fe of og oh oi b">input.py</code>和<code class="fe of og oh oi b">output.py</code>文件包含定义API输入和响应的字段和数据类型的类。下面是<code class="fe of og oh oi b">output.py</code> —每个字段都有一个变量名、类型(<code class="fe of og oh oi b">int</code>、<code class="fe of og oh oi b">float</code>、<code class="fe of og oh oi b">str</code>等)。)和一段描述。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="a2f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个端点后面的处理在<code class="fe of og oh oi b">endpoints/</code>文件夹中定义——这是<code class="fe of og oh oi b">hello.py</code>。它接收<code class="fe of og oh oi b">MessageInput </code>类型并返回一个<code class="fe of og oh oi b">MessageOutput</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="0a20" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们运行一个计算来找出一个随机数的最大质因数。结果和元数据连同格式化的字符串消息一起返回给调用者。</p><p id="15c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该计算通常需要1-100毫秒来完成，并且通过迭代来解决。虽然与远程服务器通信的时间并不多，但这是一项计算密集型任务，因此该过程受CPU限制(与IO限制相反)。FastAPI使用<code class="fe of og oh oi b">async</code>操作来并行处理多个请求——这通常可以很好地扩展，因为操作通常是IO绑定的，这意味着要花费时间等待其他操作完成。在等待时，控制权会移交给另一个线程，以便它可以完成自己的工作。对于CPU受限的操作，这种情况不会发生，因此吞吐量会低很多(参见下面关于负载测试的部分)。</p><p id="eec7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其他文件:</p><ul class=""><li id="1468" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ok mb mc md bi translated"><code class="fe of og oh oi b"><a class="ae lu" href="https://github.com/4OH4/kubernetes-fastapi/blob/main/service/main.py" rel="noopener ugc nofollow" target="_blank">main.py</a></code>初始化API，我们还为测试目的定义了一个<code class="fe of og oh oi b">ping</code>端点。</li><li id="7ed5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><code class="fe of og oh oi b">Dockerfile</code>定义容器图像的内容并加载任何依赖项(在<code class="fe of og oh oi b">requirements.txt</code>中定义)。</li><li id="2e9b" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><code class="fe of og oh oi b">api.yml</code>描述了Kubernetes的部署。</li><li id="62fe" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><code class="fe of og oh oi b">autoscale.yml</code>描述了一个Kubernetes <code class="fe of og oh oi b">HorizontalPodAutoscaler</code>，它告诉Kubernetes如何根据CPU的使用情况来扩展应用程序的部署。</li><li id="23ef" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><code class="fe of og oh oi b">locustfile.py</code>描述了Locust进行负载测试的配置(见下文)。</li></ul><p id="a98f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下面的阶段中，我们将API上传到公共云，并使端点可公开访问。从网络安全的角度来看，示例API的风险相对较低，因为它不接受用户输入，也不包含敏感信息。也就是说，没有什么可以阻止第三方访问它或向它发送大量请求。虽然超出了本文的范围，但是如果您正在构建一个用于生产的定制服务，您应该考虑<a class="ae lu" href="https://fastapi.tiangolo.com/tutorial/query-params-str-validations/" rel="noopener ugc nofollow" target="_blank">输入验证</a>和<a class="ae lu" href="https://fastapi.tiangolo.com/tutorial/security/" rel="noopener ugc nofollow" target="_blank">认证</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d9e7" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">本地测试</h1><p id="b7bd" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在部署API之前，最好使用本地Python环境进行一些调试测试。首先，使用存储库中的<code class="fe of og oh oi b">requirements.txt</code>文件安装依赖项:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="21f5" class="oq mr it oi b gy or os l ot ou">$ pip install -r requirements.txt</span></pre><p id="0a7d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后使用<code class="fe of og oh oi b">uvicorn</code>启动一个本地web服务器:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="632c" class="oq mr it oi b gy or os l ot ou">$ uvicorn service.main:app --host 0.0.0.0 --port 8080 --reload</span></pre><p id="a329" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当应用程序启动时，控制台应该显示许多消息。然后导航到<a class="ae lu" href="http://localhost:8080/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/docs</a>来探索使用Swagger UI界面的API。您可以使用“尝试”按钮锻炼<code class="fe of og oh oi b">/hello</code>和<code class="fe of og oh oi b">/ping</code>端点。</p><p id="3d0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe of og oh oi b">/hello</code>端点以问候和计算随机整数的最大质因数的结果作为响应。您应该会看到类似以下内容的响应正文:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="fed3" class="oq mr it oi b gy or os l ot ou">{<br/>  "message1": "Hello, world!",<br/>  "message2": "The largest prime factor of 1462370954730 is 398311. Calculation took 0.006 seconds.",<br/>  "n": 1462370954730,<br/>  "largest_prime_factor": 398311,<br/>  "elapsed_time": 0.0057561397552490234<br/>}</span></pre><p id="99ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe of og oh oi b">--reload</code>参数告诉<code class="fe of og oh oi b">uvicorn</code>监控源代码，并在发生更改时重新加载API这样您就可以继续工作并更新代码，并立即在浏览器中测试结果。按Ctrl-C退出。</p><p id="5349" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果安装了cURL，也可以直接从命令行调用API:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="07ea" class="oq mr it oi b gy or os l ot ou">$ curl -H ‘Content-Type: application/json’ -d {} localhost:8080/api/v1/hello</span><span id="6792" class="oq mr it oi b gy ox os l ot ou">{"message1":"Hello, world!","message2":"The largest prime factor of 1927651733935 is 991080583. Calculation took 0.011 seconds.","n":19276517 ....</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a4f0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">在本地Docker容器中运行</h1><p id="744a" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">下一步是将API打包到Docker容器中，在本地测试，然后推送到<a class="ae lu" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>。在这里的例子中，我使用我的Docker Hub ID<code class="fe of og oh oi b">4oh4.</code>构建和推送，您需要用您自己的ID替换它。或者，您可以跳过这个构建阶段，使用原始映像(未修改的)。要构建Docker映像:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="e583" class="oq mr it oi b gy or os l ot ou">$ docker build -t 4oh4/kubernetes-fastapi:1.0.0 .</span></pre><p id="8b16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要运行容器:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="0007" class="oq mr it oi b gy or os l ot ou">$ docker run -p 8080:8080 --name kubernetes-fastapi 4oh4/kubernetes-fastapi:1.0.0</span></pre><p id="0caf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您跳过了build命令，现在将从Docker Hub中提取映像。和以前一样，导航到<a class="ae lu" href="http://localhost:8080/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/docs</a>来探索使用Swagger UI接口的API。按Ctrl-C退出。</p><p id="7892" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您修改了API并构建了自己的容器，将映像推送到Docker Hub(记住将<code class="fe of og oh oi b">4oh4</code>改为您的ID):</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="cac9" class="oq mr it oi b gy or os l ot ou">$ docker push 4oh4/kubernetes-fastapi:1.0.0</span></pre><p id="0e03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认情况下，新映像创建为私有映像。与其处理认证，不如导航到<a class="ae lu" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>，登录，找到您的新图像，并使其可公开访问。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="22a3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">蝗虫负载试验</h1><p id="cde1" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我们可以使用Python包Locust来模拟对API的大量并发请求。GitHub存储库在<code class="fe of og oh oi b">locustfile.py</code>中包含一个测试配置，告诉<code class="fe of og oh oi b">locust</code>如何与API通信。安装软件包并从命令行运行它:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="6248" class="oq mr it oi b gy or os l ot ou">$ pip install locust<br/>$ locust</span><span id="1615" class="oq mr it oi b gy ox os l ot ou">[2021-01-24 16:21:29,188] INFO/locust.main: Starting web interface at <a class="ae lu" href="http://0.0.0.0:8089" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8089</a> (accepting connections from all network interfaces)</span></pre><p id="40da" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">导航至<a class="ae lu" href="http://localhost:8089" rel="noopener ugc nofollow" target="_blank"> http://localhost:8089 </a>查看网络界面，并初始化测试——如果不在本地运行，自定义主机名:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/f109b2722d0141d23cbbeca09e48c763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HJg1AI1sHLJUHASGOziWHg.png"/></div></div></figure><p id="d778" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">点击开始，几秒钟后，蝗虫将开始击中API与流量从一个池的模拟用户。选择图表选项卡以可视化性能指标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/8d26a108e13682eb8312411eb6508390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vxEqxvDHSY6sVbuUiIVq1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用刺槐进行模拟负载测试期间的性能结果。该API部署在Kubernetes集群上，具有多种自动缩放和配置设置，因为并发用户的数量增加到了250。</p></figure><p id="fc99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">练习:</strong>尝试禁用计算密集型计算，并观察对响应时间和吞吐量的影响(注释掉<code class="fe of og oh oi b">endpoints/hello.py</code>中的函数调用并返回固定值)。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="02ad" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">部署到Kubernetes集群</h1><p id="254a" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">现在，我们的API在Docker容器中工作，我们将把我们的应用程序部署到一个Kubernetes集群中。Kubernetes将管理多个容器的编排，以便计算资源的提供与需求相匹配。我们将使用基于CPU使用的自动缩放策略，以便在负载增加的情况下部署更多的容器来服务API请求。</p><p id="66f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本节要求访问Kubernetes集群。我们中的大多数人家里都没有计算集群，但是可以使用<code class="fe of og oh oi b">minikube</code>或类似工具在您的本地机器上建立一个单节点集群。<a class="ae lu" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">安装说明</a>可在文档中找到。或者，云提供商的受管Kubernetes集群也可以工作——关于部署到Google Kubernetes引擎的详细说明见下文。无论您选择哪条路线，我们都将使用<code class="fe of og oh oi b">kubectl</code>工具来建立我们的集群。</p><p id="ad84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们部署的核心在<code class="fe of og oh oi b">api.yaml</code>中描述。此配置文件包含:</p><ul class=""><li id="8d39" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ok mb mc md bi translated">Kubernetes部署—描述要使用的Docker映像、所需资源和要公开的端口。</li><li id="c178" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">Kubernetes服务——这描述了如何将部署呈现给外部世界，在这种情况下，是通过一个在多个(潜在的)容器之间分配流量的负载平衡器。</li></ul><p id="359c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe of og oh oi b">kubectl</code>应用配置，检查pod是否启动并运行，然后列出服务以查找外部IP地址:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="8979" class="oq mr it oi b gy or os l ot ou">$ kubectl apply -f api.yaml</span><span id="9f02" class="oq mr it oi b gy ox os l ot ou">service/kf-api-svc configured<br/>deployment.apps/kf-api configured</span><span id="8692" class="oq mr it oi b gy ox os l ot ou">$ kubectl get pods<br/>NAME                      READY   STATUS    RESTARTS   AGE<br/>kf-api-65d656b8c9-ppn7j   1/1     Running   0          4m</span><span id="228b" class="oq mr it oi b gy ox os l ot ou">$ kubectl get svc kf-api-svc<br/>NAME         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE<br/>kf-api-svc   LoadBalancer   10.105.177.140   &lt;pending&gt;     8080:32578/TCP   5m</span></pre><p id="e8e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我正在使用<code class="fe of og oh oi b">minikube</code>，外部IP尚未分配—请使用<code class="fe of og oh oi b">tunnel</code>命令将其连接起来:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="dd56" class="oq mr it oi b gy or os l ot ou">minikube tunnel</span></pre><p id="5979" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从另一个终端(因为前面的命令仍在另一个终端中运行)，再次列出服务:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="c7be" class="oq mr it oi b gy or os l ot ou">$ kubectl get svc kf-api-svc<br/>NAME         TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE<br/>kf-api-svc   LoadBalancer   10.105.177.140   10.105.177.140     8080:32578/TCP  6m</span></pre><p id="a42e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">外部IP现在公开了(它实际上与集群IP相同)。现在，您可以在web浏览器中导航到该地址，端口8080，并且应该会看到熟悉的Swagger UI。在我的例子中，它是<a class="ae lu" href="http://10.105.177.140:8080/docs," rel="noopener ugc nofollow" target="_blank">http://10 . 105 . 177 . 140:8080/docs，</a>尽管您需要将IP地址替换为系统分配的地址。</p><p id="95f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">目前，我们有一个Docker容器的副本运行在集群上，这很好，但是集群的真正力量来自于大规模运行。当然，如果您只在<code class="fe of og oh oi b">minikube</code>上运行单节点集群，您将看不到扩展的好处。应用<code class="fe of og oh oi b">HorizontalPodAutoscaler</code>策略并检查缩放的结果:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="b239" class="oq mr it oi b gy or os l ot ou">$ kubectl apply -f autoscale.yaml<br/>horizontalpodautoscaler.autoscaling/kf-api-hpa configured</span><span id="8090" class="oq mr it oi b gy ox os l ot ou">$ kubectl get hpa<br/>NAME        REFERENCE          TARGETS   MINPODS  MAXPODS  REPLICAS   AGE<br/>kf-api-hpa  Deployment/kf-api  42%/50%   1        10       1          10m</span></pre><p id="98b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此配置文件中的关键行告诉Kubernetes通过将CPU利用率保持在50%来扩展1到10个副本的部署:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="3a38" class="oq mr it oi b gy or os l ot ou">  minReplicas: 1 <br/>  maxReplicas: 10 <br/>  targetCPUUtilizationPercentage: 50</span></pre><p id="cd66" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你愿意，现在可以用Locust重复负载测试(只需用集群外部IP替换<code class="fe of og oh oi b">localhost</code>)。</p><p id="d24a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成测试后，取下部署、服务和自动缩放器:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="7184" class="oq mr it oi b gy or os l ot ou">kubectl delete deployment kf-api<br/>kubectl delete svc kf-api-svc<br/>kubectl delete hpa kf-api-hpa</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="dc31" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">部署到谷歌云</h1><p id="cdc8" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">最后，我们将部署到基于云的Kubernetes集群。本地和云部署的部署过程实际上非常相似——我们只需要配置<code class="fe of og oh oi b">kubectl</code>与集群通信。在本节中，我们将在Google Cloud上提供一个三节点集群，并在其上部署我们的API。有关更多信息，请参考<a class="ae lu" href="https://cloud.google.com/kubernetes-engine/docs/quickstart" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><h2 id="0cf9" class="oq mr it bd ms oz pa dn mw pb pc dp na lh pd pe nc ll pf pg ne lp ph pi ng pj bi translated">要求</h2><ul class=""><li id="c344" class="lv lw it la b lb ni le nj lh pk ll pl lp pm lt ok mb mc md bi translated">一个Google Cloud帐户，可以启用计费，也可以剩余足够的免费点数。如果您没有让集群运行很长时间，这应该会产生大约1-2美元的费用。</li><li id="0a31" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">GCP上的一个活动项目—通过<a class="ae lu" href="https://console.cloud.google.com/" rel="noopener ugc nofollow" target="_blank">控制台</a>创建一个。</li><li id="890d" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated">安装了Google Cloud SDK—<a class="ae lu" href="https://cloud.google.com/sdk/docs/install" rel="noopener ugc nofollow" target="_blank">在此下载</a>。</li></ul><p id="d0ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，确保您的项目启用了GCP Kubernetes引擎，无论是在<a class="ae lu" href="https://console.cloud.google.com/apis/library/container.googleapis.com" rel="noopener ugc nofollow" target="_blank">这个页面</a>还是通过使用以下命令:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="368f" class="oq mr it oi b gy or os l ot ou">gcloud services enable container.googleapis.com</span></pre><p id="747d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后安装<code class="fe of og oh oi b">gcloud kubectl</code>组件并用您的项目ID和默认区域配置<code class="fe of og oh oi b">gcloud</code>:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="41cf" class="oq mr it oi b gy or os l ot ou">gcloud components install kubectl<br/><br/>gcloud config set project my-project-id<br/>gcloud config set compute/zone europe-west2-a</span></pre><p id="e0fb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">将<code class="fe of og oh oi b">my-project-id</code>替换为项目的ID——而不是名称。您可以在仪表板页面的项目信息框中找到该ID。我住在英国伦敦附近，所以选择了<code class="fe of og oh oi b">europe-west2-a</code>作为我的首选地区。选择哪个区域并不重要，尽管在这里指定区域可以省去以后输入的麻烦。</p><p id="4de7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，在GCP上创建一个三节点Kubernetes集群，并配置<code class="fe of og oh oi b">kubectl</code>通过获取所需的凭证与它对话:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="ae9a" class="oq mr it oi b gy or os l ot ou">$ gcloud container clusters create my-cluster-name --num-nodes=3</span><span id="d877" class="oq mr it oi b gy ox os l ot ou">Creating cluster my-cluser-name in europe-west2-a... Cluster is being health-checked (master is healthy)...done.<br/>...</span><span id="49b3" class="oq mr it oi b gy ox os l ot ou">$ gcloud container clusters get-credentials my-cluster-name</span><span id="2fc5" class="oq mr it oi b gy ox os l ot ou">Fetching cluster endpoint and auth data.<br/>kubeconfig entry generated for my-cluser-name.</span></pre><p id="2481" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里<code class="fe of og oh oi b">my-cluster-name</code>可以是你选择的任何东西。最后，部署应用程序和服务，应用自动伸缩策略，并检查结果:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="2f76" class="oq mr it oi b gy or os l ot ou">$ kubectl apply -f api.yaml<br/>service/kf-api-svc created<br/>deployment.apps/kf-api created</span><span id="e907" class="oq mr it oi b gy ox os l ot ou">$ kubectl apply -f autoscale.yaml<br/>horizontalpodautoscaler.autoscaling/kf-api-hpa created</span><span id="0a7a" class="oq mr it oi b gy ox os l ot ou">$ kubectl get svc kf-api-svc<br/>NAME         TYPE           CLUSTER-IP       EXTERNAL-IP     PORT(S)          AGE<br/>kf-api-svc   LoadBalancer   10.103.246.129   34.89.100.187   8080:31382/TCP   2m1s</span><span id="f8f8" class="oq mr it oi b gy ox os l ot ou">$ kubectl get hpa<br/>NAME         REFERENCE           TARGETS   MINPODS   MAXPODS   REPLICAS   AGE<br/>kf-api-hpa   Deployment/kf-api   2%/50%    1         10        1          2m20s</span></pre><p id="2efc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为一切看起来都很好，所以继续使用Locust应用一些加载，使用集群外部IP(端口8080)作为目标。作为响应，您应该会看到CPU利用率和副本数量都有所增加:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="7a79" class="oq mr it oi b gy or os l ot ou">$ kubectl get hpa<br/>NAME     REFERENCE           TARGETS   MINPODS   MAXPODS   REPLICAS   AGE<br/>kf-api   Deployment/kf-api   94%/50%   1         10        8          5m54s</span></pre><p id="d2a9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成后，记得关闭部署并删除集群:</p><pre class="kj kk kl km gt om oi on oo aw op bi"><span id="d915" class="oq mr it oi b gy or os l ot ou">$ kubectl delete deployment kf-api<br/>$ kubectl delete svc kf-api-svc<br/>$ kubectl delete hpa kf-api-hpa</span><span id="1aba" class="oq mr it oi b gy ox os l ot ou">$ gcloud container clusters delete my-clutser-name</span></pre><p id="f434" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得在谷歌云控制台中检查所有资源是否都已停止——否则你可能会收到一份意想不到的账单。安全的选择是从项目设置中完全删除项目。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bf6d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">摘要</h1><p id="265c" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在本文中，我们用Python构建了一个简单的API，并在部署到Kubernetes集群(本地和云中)之前对其进行了本地测试(用本地Python和通过Docker)。希望您已经看到了像<code class="fe of og oh oi b">kubectl</code>和<code class="fe of og oh oi b">gcloud</code>这样的工具如何模糊了在本地开发机器和集群/云资源之间的界限，使得在两者之间转移变得容易。我期待在回复<em class="pn"> </em>部分看到您的评论和问题。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="befd" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">参考</h1><ul class=""><li id="879c" class="lv lw it la b lb ni le nj lh pk ll pl lp pm lt ok mb mc md bi translated"><a class="ae lu" href="https://iwpnd.pw/articles/2020-01/deploy-fastapi-to-aws-lambda" rel="noopener ugc nofollow" target="_blank">如何使用AWS SAM将fastAPI持续部署到AWS Lambda</a></li><li id="a90a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><a class="ae lu" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a></li><li id="abf6" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ok mb mc md bi translated"><a class="ae lu" href="https://console.cloud.google.com/apis/library/container.googleapis.com" rel="noopener ugc nofollow" target="_blank">谷歌云Kubernetes引擎API </a></li></ul></div></div>    
</body>
</html>