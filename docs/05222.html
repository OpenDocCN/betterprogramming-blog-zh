<html>
<head>
<title>Functional Programming With Java: Exception Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数式编程:异常处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-with-java-exception-handling-67f40b1f0330?source=collection_archive---------4-----------------------#2020-06-22">https://betterprogramming.pub/functional-programming-with-java-exception-handling-67f40b1f0330?source=collection_archive---------4-----------------------#2020-06-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3987" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">处理功能代码中破坏性情况的更好方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b88b3a634ff2a10d4dc3bda53f4fb231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ArPN7k-nZxACuclw_6qJA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@randyfath?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">兰迪·法特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/different?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前关于 <a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener">函数式</a> <a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-immutability-8dc748e85f9e" rel="noopener">编程</a>的<a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener">文章中，我已经展示了如何将一种更函数式的风格融入到我们的Java代码中。但是我忽略了一个至关重要的话题:如何处理异常。</a></p><p id="e91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<a class="ae ky" href="https://medium.com/swlh/all-you-ever-wanted-to-know-about-java-exceptions-cfae1dff8504" rel="noopener"> Java异常</a>的文章没有谈到如何在lambdas和streams中处理它们，因为它值得自己写一篇文章。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="1046" class="ma mb it lw b gy mc md l me mf">1. <a class="ae ky" href="#4dc0" rel="noopener ugc nofollow">Exceptions in Lambdas</a> <br/>2. <a class="ae ky" href="#8a32" rel="noopener ugc nofollow">Dealing With Exceptions the Java Way</a><br/>3. <a class="ae ky" href="#060f" rel="noopener ugc nofollow">A More Functional Approach</a><br/>4. <a class="ae ky" href="#3776" rel="noopener ugc nofollow">Third-Party Libraries</a><br/>5. <a class="ae ky" href="#88a2" rel="noopener ugc nofollow">Conclusion</a><br/>6. <a class="ae ky" href="#3505" rel="noopener ugc nofollow">Resources</a></span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="4dc0" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">Lambdas中的异常</h1><blockquote class="ne"><p id="9901" class="nf ng it bd nh ni nj nk nl nm nn lu dk translated">"异常处理是一种机制，用于处理程序控制流中的破坏性异常情况."</p></blockquote><p id="5038" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">Java异常处理随着时间的推移不断发展，增加了像<a class="ae ky" href="https://medium.com/swlh/all-you-ever-wanted-to-know-about-java-exceptions-cfae1dff8504#7fd0" rel="noopener"> multi-catch </a>或<a class="ae ky" href="https://medium.com/swlh/all-you-ever-wanted-to-know-about-java-exceptions-cfae1dff8504#3eed" rel="noopener"> try-with-resources </a>这样的功能，但遗憾的是，目前还没有针对lambdas的任何考虑。我们仍然必须遵守检查异常的<a class="ae ky" href="https://medium.com/swlh/all-you-ever-wanted-to-know-about-java-exceptions-cfae1dff8504#338b" rel="noopener"> catch-or-specify要求</a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="dacb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们需要依靠<code class="fe nv nw nx lw b">try</code> - <code class="fe nv nw nx lw b">catch</code>来让编译器开心:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想我们都同意，在lambda中直接引入<code class="fe nv nw nx lw b">try</code> - <code class="fe nv nw nx lw b">catch</code>是处理Java非功能性异常处理的一种糟糕方式。</p><p id="e76a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异常的抛出和处理与我们用功能性更强的编码风格努力实现的目标相反。这相当冗长，并且会导致<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/functional-programming-with-java-an-introduction-daa783355731#c7cd"> <em class="ny">杂质</em> </a> <em class="ny"> </em>，使函数不再具有确定性(相同的输入生成相同的输出)。但是有一些方法可以处理异常，而不会失去函数式编程的简单性和清晰性。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="8a32" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">用Java方式处理异常</h1><p id="83a9" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">例外是一个基本特性，并且会一直存在。尽管我们可能希望有一种替代方案，但我们需要找到一种方法在我们的功能代码中处理它们。</p><p id="7435" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的功能代码中，有几种方法可以使用正常的方法，并取得不同程度的成功。</p><h2 id="2728" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">取消检查例外</h2><p id="26fb" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">第一种方法是取消检查我们的异常，从而消除catch-or-specify需求。我们可以通过为我们的调用创建一个包装器来做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8a7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以包装一个现有的函数，正在发生的异常仍然会被抛出——但是作为未检查的<code class="fe nv nw nx lw b">RuntimeException</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器现在可能很高兴，但是我们没有修复可能的控制流中断的一般问题。而且我们根本没有机会在本地处理。</p><p id="7e9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，我们没有处理任何异常——我们只是对编译器隐藏了异常。我们用流操作构建的任何复杂的多步管道，如果其中任何一个抛出异常，都会完全崩溃。</p><p id="4b43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">未检查的异常应该是未预料到的，并且通常是不可恢复的。这就是为什么他们一开始就不符合“捕捉或指定”的要求！因此，仅仅为了编译我们的代码而滥用这个概念可能不是我们希望的最佳实践。</p><p id="216c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使这种处理方式我们可以接受，那<code class="fe nv nw nx lw b">BiFunction&lt;T,U,R&gt;</code>、<code class="fe nv nw nx lw b">Consumer&lt;T&gt;</code>、<code class="fe nv nw nx lw b">Supplier&lt;T&gt;</code>等呢？？我们需要为任何抛出异常的函数接口创建一个包装器。</p><h2 id="dfdc" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">通过提取处理异常</h2><p id="03f1" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们不应该只是通过编写包装来隐藏异常，而是应该实际处理任何异常，以便控制流可以有序地恢复。</p><p id="71ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">方法引用提高了流的可读性，即使没有可视化移除异常处理的优势:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="e766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在<code class="fe nv nw nx lw b">read(File)</code>中直接处理任何<code class="fe nv nw nx lw b">IOException</code>，或者，如果不是我们的代码需要更改，我们可以用一个处理方法来包装这个调用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="452e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">管道仍然很容易理解，并且<code class="fe nv nw nx lw b">safeRead</code>给了我们处理异常的可能性。或者，如果不能，我们仍然可以将它作为未检查的异常重新抛出。</p><h2 id="abb9" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">根本不抛出异常</h2><p id="3328" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">包装异常和将代码提取到方法只是对现有代码的抽象，因此我们可以控制破坏性的情况。</p><p id="83b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们控制了API，我们就可以以一种不需要异常的方式来设计契约。或者至少更容易管理。</p><p id="8293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java为我们提供了<code class="fe nv nw nx lw b"><a class="ae ky" href="https://medium.com/better-programming/better-null-handling-with-java-optionals-4793a8566710" rel="noopener">java.util.Optional</a></code>来表示一个不存在的值，可以用更函数化的方式来处理。我们应该尽可能避免返回<code class="fe nv nw nx lw b">null</code>(希望)一劳永逸地消灭可怕的<code class="fe nv nw nx lw b">NullPointerException</code>。返回空集合<a class="ae ky" href="https://medium.com/better-programming/utility-classes-of-the-jdk-collections-and-arrays-cc07dbcb8586#b51a" rel="noopener">而不是<code class="fe nv nw nx lw b">null</code>也会有所帮助。</a></p><p id="71c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，<code class="fe nv nw nx lw b">null</code>并不总是等同于<em class="ny">没有找到值</em>。返回<code class="fe nv nw nx lw b">null</code>可能意味着与返回<code class="fe nv nw nx lw b">Optional&lt;T&gt;.empty()</code>或空集合完全不同的东西。这很大程度上取决于我们的需求以及我们如何设计API契约。</p><p id="ed3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异常应该是关于我们的控制流的附加信号。但是在一个更实用的环境中，我们应该试着放弃其中的一些，尤其是那些不太明显的。这将使我们的代码更容易理解和推理。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="060f" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">更实用的方法</h1><p id="d317" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们必须记住，Java是一种通用语言，其核心是基于类的面向对象。即使添加了lambdas、方法引用、流等。，它没有成为一种成熟的函数式语言。但是我们可以看看其他功能更强的语言，看看如何更好地处理异常情况。</p><p id="9aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Scala也是一种运行在JVM上的通用语言。它解决了Java的许多缺点，并作为一等公民支持函数式编程。</p><h2 id="2894" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">选项'，'一些'，'无'</h2><p id="1d48" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated"><code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/Option.html" rel="noopener ugc nofollow" target="_blank">Option[+A]</a></code>类型是Scala处理可空值的方式，就像<code class="fe nv nw nx lw b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">java.util.Optional&lt;T&gt;</a></code>一样。但是它不仅仅是另一个对象的(智能)通用包装器，而是为您提供了对结果的更细粒度的控制，直接内置于语言本身:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它没有抛出一个可能的异常，而是被直接处理并替换为一个<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/Option.html" rel="noopener ugc nofollow" target="_blank">Option[Int]</a></code>。现在可以通过模式匹配或提供的任何方法来处理它。</p><p id="dc2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/Option.html" rel="noopener ugc nofollow" target="_blank">Option[+A]</a></code>比<code class="fe nv nw nx lw b"><a class="ae ky" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">java.util.Optional&lt;T&gt;</a></code>更强大，但是它缺少由异常提供的额外信息:哪里出错了。</p><h2 id="4713" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">尝试'，'成功'，'失败'和'任一'</h2><p id="33a2" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">Scala提供了额外的类型来缩小这个差距:</p><p id="2aa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Try.html" rel="noopener ugc nofollow" target="_blank">Try[+T]</a></code>和<code class="fe nv nw nx lw b">Option[+A]</code>一样，返回两个可能的值:</p><ul class=""><li id="c064" class="op oq it lb b lc ld lf lg li or lm os lq ot lu ou ov ow ox bi translated"><code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Success.html" rel="noopener ugc nofollow" target="_blank">Success[+T]</a></code></li><li id="7f2a" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Failure.html" rel="noopener ugc nofollow" target="_blank">Failure[+T]</a></code></li></ul><p id="fae5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们改变之前的示例，使用这些类型，这样它们可以提供更多信息:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Try.html" rel="noopener ugc nofollow" target="_blank">Try[+T]</a></code>，还有一个更通用的<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Either.html" rel="noopener ugc nofollow" target="_blank">Either[+A, +B]</a></code>，不绑定<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/index.html#Throwable=Throwable" rel="noopener ugc nofollow" target="_blank">Throwable</a></code>。</p><p id="9cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很棒的Scala特性，但是这对我们的Java代码意味着什么呢？</p><h2 id="ac5c" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">用Java尝试'和'任一'</h2><p id="e50e" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated"><code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Try.html" rel="noopener ugc nofollow" target="_blank">Try[+T]</a></code>和<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Either.html" rel="noopener ugc nofollow" target="_blank">Either[+A, +B]</a></code>背后的一般概念也可以在Java中应用，尽管不如Scala中做得好。</p><p id="24c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Try.html" rel="noopener ugc nofollow" target="_blank">Try[+T]</a></code>最基本的功能可以用大约120行代码复制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="3d17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前的Scala示例现在可以在Java中复制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2dbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仍然有很多需要改进的地方，特别是处理和从失败中恢复的方法。但是你应该知道这里应该完成什么的大概意思。</p><p id="99f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Disjoint_union" rel="noopener ugc nofollow" target="_blank">不相交并集</a>类型，我们获得了在单个对象中表示多个状态的可能性。其他语言使用基于元组的模式，比如<a class="ae ky" href="https://blog.golang.org/error-handling-and-go" rel="noopener ugc nofollow" target="_blank"> Golang错误处理</a>，来实现同样的目的。但是一个专用类型可以用方法扩展，比如<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Try.html#map%5BU%5D(f:T=%3EU):scala.util.Try%5BU%5D" rel="noopener ugc nofollow" target="_blank">map</a></code>、<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Try.html#flatMap%5BU%5D(f:T=%3Escala.util.Try%5BU%5D):scala.util.Try%5BU%5D" rel="noopener ugc nofollow" target="_blank">flatMap</a></code>、<code class="fe nv nw nx lw b"><a class="ae ky" href="https://www.scala-lang.org/api/current/scala/util/Try.html#fold%5BU%5D(fa:Throwable=%3EU,fb:T=%3EU):U" rel="noopener ugc nofollow" target="_blank">fold</a></code>等。，以更好地适应函数式编码风格。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3776" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">第三方库</h1><p id="2387" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">我们不需要自己实现所有的类型和功能，而是可以依赖一个久经考验的库。像<code class="fe nv nw nx lw b">Either</code>这样的联合类型或者像<code class="fe nv nw nx lw b">Try</code>这样改进的异常处理有多种选择。</p><h2 id="91b6" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">Vavr</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/265b9121f6c80f436a064ac73ade5258.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*Mt-KtrsRqZLwqJZ1tEQi0Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.vavr.io/" rel="noopener ugc nofollow" target="_blank">https://www.vavr.io/</a></p></figure><p id="da8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Vavr项目的目标是提供使Java更具功能性所需的所有工具，比如不变性和所有缺失的功能控制结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="15a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还支持模式匹配:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="77fc" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">函数式Java</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/e8a75b6744af0af077686a7e9468f52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*HIRkQ2sg13hbNtPwgx5fTA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">【https://www.functionaljava.org/ T4】</p></figure><p id="abd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个选择是<a class="ae ky" href="http://www.functionaljava.org/" rel="noopener ugc nofollow" target="_blank">函数式Java </a>库。它没有提供显式的<code class="fe nv nw nx lw b">Try</code>类型，但是使用它的不相交联合类型<code class="fe nv nw nx lw b">Either&lt;A,B&gt;</code>，可以获得相同的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="a25d" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">jOOλ</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/a36656d6e6851857b7ebda460b2fe187.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*8c_cjteHPlkB4ubpdLb58g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/jOOQ/jOOL" rel="noopener ugc nofollow" target="_blank">https://github.com/jOOQ/jOOL</a></p></figure><p id="bbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个伟大的SQL库<a class="ae ky" href="https://www.jooq.org/" rel="noopener ugc nofollow" target="_blank"> jOOQ </a>的创建者也创建了<a class="ae ky" href="https://github.com/jOOQ/jOOL" rel="noopener ugc nofollow" target="_blank"> jOOλ </a>，它提供了Java的lambdas的一些缺失部分。</p><p id="9983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它并不意味着像前两个框架一样是一个完整的功能解决方案。最好的部分是它的<code class="fe nv nw nx lw b">Seq&lt;T&gt;</code>型，就像是类固醇上的<code class="fe nv nw nx lw b">Stream&lt;T&gt;</code>。为了处理异常，它提供了包装器来轻松取消选中的异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="88a2" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="f3d1" class="pw-post-body-paragraph kz la it lb b lc nz ju le lf oa jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">在我们的函数式Java代码中，处理异常的最好方法是什么？我不能给你一个确定的答案，但希望这篇文章能给你一些可能性。</p><p id="ad51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择哪种样式或库很大程度上取决于我们打算如何使用它并将其合并到我们的项目中。</p><p id="3f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">全功能方法可能意味着彻底改变我们设计和编码API的方式。仅仅取消对异常的检查可能还不够。</p><p id="e3d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在提交样式或库之前，确保它是一个很好的选择。在选定一种特定的风格或库之前，最好的办法是用小型概念验证项目尝试多种方法。</p><p id="4d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你决定包含一个第三方库，这不是一个容易的决定，不应该轻易做出。每个依赖都有一个学习曲线、隐藏成本和未来技术债务的可能性。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3505" class="mn mb it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">资源</h1><ul class=""><li id="c7b9" class="op oq it lb b lc nz lf oa li pg lm ph lq pi lu ou ov ow ox bi translated"><a class="ae ky" href="https://www.oreilly.com/content/handling-checked-exceptions-in-java-streams/" rel="noopener ugc nofollow" target="_blank">“处理Java流中被检查的异常</a>”(O ' Reilly)</li><li id="5b6b" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://www.freecodecamp.org/news/better-exception-handling-in-java-8-streams-using-vavr-6eda31285ce9/" rel="noopener ugc nofollow" target="_blank">“使用Vavr在Java 8流中实现更好的异常处理</a>”(freeCodeCamp)</li><li id="80e8" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://docs.scala-lang.org/overviews/scala-book/functional-error-handling.html" rel="noopener ugc nofollow" target="_blank">《Scala函数错误处理</a>》(Scala书籍)</li><li id="1fb5" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://www.baeldung.com/vavr" rel="noopener ugc nofollow" target="_blank">《Vavr简介</a>》(bael dung)</li><li id="931e" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://www.baeldung.com/java-functional-library" rel="noopener ugc nofollow" target="_blank">《函数式Java简介</a>》(bael dung)</li><li id="b03c" class="op oq it lb b lc oy lf oz li pa lm pb lq pc lu ou ov ow ox bi translated"><a class="ae ky" href="https://www.baeldung.com/jool" rel="noopener ugc nofollow" target="_blank">《jOOL入门</a>(拜尔东)》</li></ul><h2 id="c2cb" class="ma mb it bd mo oe of dn ms og oh dp mw li oi oj my lm ok ol na lq om on nc oo bi translated">我的相关文章</h2><div class="pj pk gp gr pl pm"><a href="https://medium.com/swlh/all-you-ever-wanted-to-know-about-java-exceptions-cfae1dff8504" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">你想知道的关于Java异常的一切</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">为什么，怎么做，该做什么和不该做什么</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="pw l px py pz pv qa ks pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://medium.com/better-programming/functional-programming-with-java-immutability-8dc748e85f9e" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">Java函数式编程:不变性</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">具有不可变状态的更好的数据结构</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="qb l px py pz pv qa ks pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">Java函数式编程:流</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">最佳实践概述</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="qc l px py pz pv qa ks pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://medium.com/better-programming/functional-programming-with-java-whats-in-the-box-4c0ee20035af" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">Java函数式编程:盒子里是什么</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">JDK中可用的不同种类的功能接口</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="qd l px py pz pv qa ks pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">Java函数式编程:简介</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">Java从来就不是函数式语言，但这并不意味着我们不能尝试</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="qe l px py pz pv qa ks pm"/></div></div></a></div><div class="pj pk gp gr pl pm"><a href="https://medium.com/better-programming/better-null-handling-with-java-optionals-4793a8566710" rel="noopener follow" target="_blank"><div class="pn ab fo"><div class="po ab pp cl cj pq"><h2 class="bd iu gy z fp pr fr fs ps fu fw is bi translated">使用Java选项更好地处理空值</h2><div class="pt l"><h3 class="bd b gy z fp pr fr fs ps fu fw dk translated">可怕的NullPointerException是许多Java开发人员的祸根</h3></div><div class="pu l"><p class="bd b dl z fp pr fr fs ps fu fw dk translated">medium.com</p></div></div><div class="pv l"><div class="qf l px py pz pv qa ks pm"/></div></div></a></div></div></div>    
</body>
</html>