<html>
<head>
<title>How To Build a FastApi Server to Control a Raspberry Pi</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建一个FastApi服务器来控制一个树莓pi</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-docker-compose-app-for-a-raspberry-pi-7d7003b4cbc?source=collection_archive---------5-----------------------#2019-10-31">https://betterprogramming.pub/how-to-build-a-docker-compose-app-for-a-raspberry-pi-7d7003b4cbc?source=collection_archive---------5-----------------------#2019-10-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7cf2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用docker-compose，您需要了解从安装到部署的所有信息</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/4a091fe9537a293af85409a6dbec0f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*_-gpiubO105ki6CI.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">摘自<a class="ae ku" href="https://www.heise.de/ratgeber/Docker-auf-dem-Raspberry-Pi-einrichten-4269052.html" rel="noopener ugc nofollow" target="_blank">https://www . heise . de/ratgeber/Docker-auf-DEM-Raspberry-Pi-einrichten-4269052 . html</a></p></figure><p id="39b3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最近，我的一个朋友问我是否可以帮助他建立一个图形用户界面，让他可以使用<a class="ae ku" href="https://www.raspberrypi.org/" rel="noopener ugc nofollow" target="_blank">树莓派</a>轻松控制几个阀门。除此之外，他还想在数据库中记录一些事情。</p><p id="cbc3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我的回答是:</p><p id="cd2d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">“听起来很棒！让我们构建一个小型web服务器，它将网页作为GUI，与<a class="ae ku" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>数据库一起，<strong class="kx iu"> </strong>在您的Raspberry Pi上的<a class="ae ku" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">Docker-compose</a><strong class="kx iu"/>环境中运行。”</p><p id="8bc5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这里，我想告诉你我做了什么，让树莓派(Rpi)的所有大胆的点工作。我假设你已经知道Docker和Docker Compose是什么。如果没有，慢慢来，仔细阅读<a class="ae ku" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和<a class="ae ku" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank"> Docker Compose </a>。</p><p id="a038" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你吃完了吗？让我们开始吧。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="a70f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">设置Docker和Docker撰写</h1><p id="38cc" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">首先，Docker和Docker为什么要作曲？</p><p id="2618" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对我来说，只要我构建了一个依赖于安装在目标机器上的依赖项的应用程序，我就会使用Docker。这避免了潜在的麻烦，并最终避免了“但是它在我的机器上运行”的问题。</p><p id="b310" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当应用程序需要配置和/或由多个必须相互交互的组件组成时，我使用Docker Compose。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7db7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">码头工人</h1><p id="26db" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">为了让我们的应用程序在Rpi上运行，我们首先需要安装Docker和Docker Compose。幸运的是，这非常简单。</p><p id="0959" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们需要安装Docker。要做到这一点，并能够以非sudo用户的身份运行Docker，只需执行以下命令:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="1796" class="na lz it mw b gy nb nc l nd ne">curl -sSL <a class="ae ku" href="https://get.docker.com" rel="noopener ugc nofollow" target="_blank">https://get.docker.com</a> | sh<br/>sudo usermod -aG docker $USER<br/># When you do a reboot, you can just type docker ---.<br/># Alternatively, to make it work in your current session, just type<strong class="mw iu"><br/></strong>newgrp docker</span></pre><p id="c987" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了检查一切是否如预期的那样工作，执行通常的Docker <code class="fe nf ng nh mw b">hello-world</code>示例:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d779" class="na lz it mw b gy nb nc l nd ne">docker run hello-world</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3319" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Docker撰写</h1><p id="2506" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">接下来，要安装Docker Compose，我们需要<a class="ae ku" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a> 3和<a class="ae ku" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> Pip </a> 3。为什么是3？这不仅仅是因为我不喜欢Python 2，还因为你不必安装额外的依赖项。</p><p id="98c9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你还没有安装它，跟随这篇<a class="ae ku" href="https://medium.com/@isma3il/install-python-3-6-or-3-7-and-pip-on-raspberry-pi-85e657aadb1e" rel="noopener">文章</a>。现在，我想我可以有把握地假设您有Pip 3，并且安装Docker Compose就像:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="79d1" class="na lz it mw b gy nb nc l nd ne">pip3 install docker-compose<br/><strong class="mw iu"># To check if everything worked as expected</strong><br/>docker-compose --version</span></pre><p id="bfde" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，您的Rpi应该已经设置好了。把它放在一边，切换到您的本地机器上开发应用程序，我将在下面向您解释。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="5f23" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">网络服务器</h1><p id="1a52" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">有几种语言和框架可以用来编写web服务器。作为一个Python爱好者，我将向您展示如何用现代Python 3.6+编写一个<em class="ni">快速</em> web服务器。</p><p id="9f7d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了管理项目的依赖和包，我将使用<a class="ae ku" href="https://poetry.eustace.io" rel="noopener ugc nofollow" target="_blank">诗歌</a>。为了构建web服务器，我使用<a class="ae ku" href="https://github.com/tiangolo/fastapi" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>作为web框架，使用<a class="ae ku" href="http://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicon</a>作为服务器。</p><p id="c0e9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我将提供一个简单的网页，对不起UI/UX人。最后，所有这些都将打包到一个Docker映像中，稍后将在我们的Rpi上运行。</p><p id="1f05" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是总体大纲，所以让我们一步一步地看，看看需要做些什么。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9b36" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">诗意</h1><p id="0f2d" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">首先，我们在开发机器上安装诗歌，而不是Rpi，来创建和管理我们的应用程序。我在所有的Python项目中使用诗歌，因为它简化了我管理依赖项、包和创建脚本的生活。</p><p id="1b9d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有各种方法来安装它，但在这里，我们只打算使用Pip。在撰写本文时，我使用的是诗歌版本0.12.7，所以让我们安装它:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="05e9" class="na lz it mw b gy nb nc l nd ne">pip3 install poetry=0.12.7</span></pre><p id="d9e7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们使用诗歌初始化名为<code class="fe nf ng nh mw b">rpiserver</code>的应用程序，如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6097" class="na lz it mw b gy nb nc l nd ne">poetry new rpiserver</span></pre><p id="ce78" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，您应该有一个名为<code class="fe nf ng nh mw b">rpiserver</code>的新文件夹，这是我们剩余部分的基本文件夹。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="93b1" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Web框架和服务器</h1><p id="69f4" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">正如我已经说过的，我使用FastAPI作为框架，使用Uvicorn作为服务器。FastAPI是一个现代的web框架，速度非常快，允许您用最少的代码设置端点，自动为您创建OpenAPI文档。</p><p id="d97d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此外，与<a class="ae ku" href="https://palletsprojects.com/p/flask/" rel="noopener ugc nofollow" target="_blank">烧瓶</a>不同，它与Uvicorn一起直接投入生产。</p><p id="bffa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于一个业余爱好项目来说，文档和生产准备可能不是那么重要，但是为什么不拥有它呢？好，让我们通过以下方式将其添加到我们的<code class="fe nf ng nh mw b">rpiserver</code>项目中:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d8f2" class="na lz it mw b gy nb nc l nd ne">poetry add fastapi --extras all</span></pre><p id="5d44" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">安装<code class="fe nf ng nh mw b">extras</code> <em class="ni"> </em>依赖项<em class="ni"> </em>直接为我们安装Uvicorn。现在，我们可以开始编写API了。</p><p id="4bb3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我在本文中简化的目标是使用Rpi和GPIOs构建打开和关闭阀门的接口。我使用两个REST API端点来实现这一点。</p><p id="a204" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">除此之外，当服务器停止时，我想关闭阀门。为了与GPIOs通信，我们首先需要安装另一个名为<a class="ae ku" href="https://pypi.org/project/RPi.GPIO/" rel="noopener ugc nofollow" target="_blank"> RPi的模块。GPIO </a>。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7f28" class="na lz it mw b gy nb nc l nd ne">poetry add RPi.GPIO</span></pre><p id="bbaf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，让我们创建一个文件<code class="fe nf ng nh mw b">server.py</code> <em class="ni">，</em>导入库，并配置GPIOs。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="3f81" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">from</strong> fastapi <strong class="mw iu">import</strong> FastAPI<br/><strong class="mw iu">from</strong> pydantic <strong class="mw iu">import</strong> BaseModel<br/><strong class="mw iu">try</strong>:<br/>    import RPi.GPIO as GPIO<br/><strong class="mw iu">except</strong> RuntimeError <strong class="mw iu">as</strong> e:<br/>    <strong class="mw iu">from</strong> .Dummypi <strong class="mw iu">import</strong> GPIO</span><span id="7d21" class="na lz it mw b gy nj nc l nd ne">GPIO.setmode(GPIO.BCM)<br/>GPIO.setwarnings(False)</span></pre><p id="6a0e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了在我的本地机器上测试和实现API，我创建了一个助手类<code class="fe nf ng nh mw b">Dummypi</code>,它具有与真正的GPIO模块相同的接口，但是只是将我们正在做的事情打印到控制台。</p><p id="1bba" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我创建了一个类，它提供了与阀门交互的简单接口:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7e04" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">class</strong> Valve(BaseModel):<br/>    gpio : int<br/>    is_open : bool = False</span><span id="e6ce" class="na lz it mw b gy nj nc l nd ne"><strong class="mw iu">def</strong> init(self):<br/>        GPIO.setup(self.gpio, GPIO.OUT)<br/>        return self</span><span id="cdb0" class="na lz it mw b gy nj nc l nd ne"><strong class="mw iu">def</strong> open(self):<br/>        GPIO.output(self.gpio, GPIO.HIGH)<br/>        self.is_open = True</span><span id="1492" class="na lz it mw b gy nj nc l nd ne"><strong class="mw iu">def</strong> close(self):<br/>        GPIO.output(self.gpio, GPIO.LOW)<br/>        self.is_open = False</span><span id="48a0" class="na lz it mw b gy nj nc l nd ne">valve = Valve(gpio=19).init()</span></pre><p id="8630" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您现在只需要定义GPIO ID，就可以开始了。</p><p id="0c1e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该类从<code class="fe nf ng nh mw b">BaseModel</code>继承的原因是我想从我的REST端点返回实例<code class="fe nf ng nh mw b">valve</code>，但是你马上就会看到。</p><p id="a90f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，实际的终端应用程序:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5672" class="na lz it mw b gy nb nc l nd ne">valve_app = FastAPI()</span><span id="7d05" class="na lz it mw b gy nj nc l nd ne">@valve_app.on_event(<strong class="mw iu">"shutdown"</strong>)<br/><strong class="mw iu">def</strong> close_valves():<br/>    valve.close()</span><span id="4c37" class="na lz it mw b gy nj nc l nd ne">@valve_app.get(<strong class="mw iu">"/valves/open"</strong>, response_model=Valve)<br/><strong class="mw iu">def</strong> open_valve(id:int):<br/>    valve.open()<br/>    <strong class="mw iu">return</strong> valve</span><span id="d6c7" class="na lz it mw b gy nj nc l nd ne">@valve_app.get(<strong class="mw iu">"/valves/close"</strong>, response_model=Valve)<br/><strong class="mw iu">def</strong> close_valve():<br/>    valve.close()<br/>    <strong class="mw iu">return</strong> valve</span></pre><p id="04eb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么，我们在这里做了什么？</p><p id="b1db" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们首先创建了一个FastAPI应用程序，我称之为<code class="fe nf ng nh mw b">valve_app</code>。我之所以选择这个名字，而不仅仅是app，是为了强调在下面的装饰器中以及启动服务器时，你必须使用<em class="ni">这个名字</em>。</p><p id="750c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，在<code class="fe nf ng nh mw b">close_valves</code>中，我定义了当服务器关闭时该做什么，即关闭阀门。</p><p id="ce1a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在真正有趣的部分，我们的封闭和开放端点。它们都是<code class="fe nf ng nh mw b">GET</code>方法，你可以从装饰器中看到。一个可通过<code class="fe nf ng nh mw b"><a class="ae ku" href="http://SERVER-ADDRESS/valves/open" rel="noopener ugc nofollow" target="_blank">http://SERVER-ADDRESS/valves/open</a></code>进入，另一个可通过<code class="fe nf ng nh mw b"><a class="ae ku" href="http://SERVER-ADDRESS/valves/close" rel="noopener ugc nofollow" target="_blank">http://SERVER-ADDRESS/valves/</a>close</code>进入。</p><p id="0a2c" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">两个端点都返回一个对象<em class="ni">的JSON表示。</em>你通过<code class="fe nf ng nh mw b">reponse_model</code>参数来定义。就是这样！不会太多吧？您可以通过以下方式运行服务器:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="ab7d" class="na lz it mw b gy nb nc l nd ne">poetry run uvicorn rpicontrol.server:valve_app — reload — port 8080</span></pre><p id="b897" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，打开浏览器，输入<code class="fe nf ng nh mw b">http://localhost:8080/valves/open</code>。这将打开你的阀门，并显示相应的JSON。</p><p id="24d9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要访问OpenAPI文档，只需键入<code class="fe nf ng nh mw b"><a class="ae ku" href="http://localhost:8080/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/docs</a></code>。</p><p id="5bba" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">耶！或者说，几乎是。我们不是说过要创建一个图形用户界面吗？保持冷静，这是我们下一步要做的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f4ef" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">网页</h1><p id="dd57" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">为了创建图形用户界面，我们的端点必须返回HTML页面，而不是JSON对象。用FastAPI实现这一点的一种方法是返回一个<code class="fe nf ng nh mw b">HTMLResponse</code>的实例。相应的代码读作:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="43e9" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">from</strong> starlette.responses <strong class="mw iu">import</strong> HTMLResponse</span><span id="0770" class="na lz it mw b gy nj nc l nd ne">@app.get(<strong class="mw iu">"/"</strong>,  response_class=HTMLResponse)<br/><strong class="mw iu">def</strong> read_item():<br/>    return generate_html_response()</span><span id="4af0" class="na lz it mw b gy nj nc l nd ne">@app.get(<strong class="mw iu">"/valves/open"</strong>, response_class=HTMLResponse)<br/><strong class="mw iu">def</strong> open_valve():<br/>    valve.open()<br/>    return generate_html_response()</span><span id="7f07" class="na lz it mw b gy nj nc l nd ne">@app.get(<strong class="mw iu">"/valves/close"</strong>, response_class=HTMLResponse)<br/><strong class="mw iu">def</strong> close_valve():<br/>    valve.close()<br/>    return generate_html_response()</span></pre><p id="2cec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我现在做了什么？</p><p id="a191" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我添加了另一个端点“<code class="fe nf ng nh mw b">/</code>”，当点击服务器URL时，它将直接返回您的网页。这基本上是我们的主要切入点。所有的端点现在都返回一个<code class="fe nf ng nh mw b">HTMLReponse</code>和相同的网页。</p><p id="5580" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是通过<code class="fe nf ng nh mw b">generate_html_reponse</code> <em class="ni">，</em>创建的，我接下来会向您展示。最后要注意的是，以前，我们在装饰器中声明了<code class="fe nf ng nh mw b">response_model</code> <strong class="kx iu"> </strong>，它必须是类型<code class="fe nf ng nh mw b">BaseModel</code>。</p><p id="0eef" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，当我们返回一个HTML页面时，我们需要定义<code class="fe nf ng nh mw b">reponse_class</code>。</p><p id="be33" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，创建HTML页面的函数。该页面显示打开/关闭状态，并提供两个打开和关闭按钮。按钮简单地分别跟随链接<code class="fe nf ng nh mw b">/valves/open</code>、<code class="fe nf ng nh mw b">/valves/close</code>。</p><p id="cde8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这也是两个端点返回网页的原因。这是有点hacky，但它工作得很好。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="32f7" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">def</strong> generate_html_response() -&gt; HTMLResponse:<br/>    state = <strong class="mw iu">"opened" if</strong> valve.is_open <strong class="mw iu">else</strong> <strong class="mw iu">"closed"<br/>    </strong>html_content = <strong class="mw iu">f"""<br/>    &lt;html&gt;<br/>        &lt;head&gt;<br/>            &lt;title&gt;Your Basic Valve App&lt;/title&gt;<br/>        &lt;/head&gt;<br/>        &lt;body&gt;<br/>            Valve </strong>{state}<br/><strong class="mw iu">        &lt;br&gt;<br/>&lt;button onclick="location.href='/valves/open'" type="button"&gt;OPEN<br/>&lt;/button&gt;<br/>&lt;button onclick="location.href='/valves/close'" type="button"&gt;CLOSE<br/>&lt;/button&gt;<br/>        &lt;/body&gt;<br/>    &lt;/html&gt;<br/>    """<br/>    return</strong> HTMLResponse(content=html_content, status_code=200)</span></pre><p id="0231" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">网站看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/98d941cc9a9117f8ab6dd247d27e1063.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*-YawPlmoDOnrPqVM32NJWg.png"/></div></figure><p id="e713" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我知道这看起来很90年代。但是，可以肯定的是，FastAPI允许您提供高度专业的HTML页面，这些页面是使用<a class="ae ku" href="https://jinja.palletsprojects.com/en/2.10.x/" rel="noopener ugc nofollow" target="_blank"> Jinja 2模板引擎</a>进行模板化和渲染的。</p><p id="7e1e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">你也可以很容易地添加静态文件，如CSS文件和图片，以美化你的页面。</p><p id="7548" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我最初也想过在这里添加这一点，但那会使帖子太长，所以我只是让你参考相应的<a class="ae ku" href="https://fastapi.tiangolo.com/tutorial/templates/" rel="noopener ugc nofollow" target="_blank"> FastAPI页面</a>以了解更多细节。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d5db" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">Docker图像</h1><p id="8422" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">最后一步是将我们的web服务器打包成Docker映像。为此，首先，创建一个名为<code class="fe nf ng nh mw b">Dockerfile</code>的文件，并将其放在您的<code class="fe nf ng nh mw b">pyproject.toml</code>文件旁边。</p><p id="9062" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">添加一个<code class="fe nf ng nh mw b">.dockerignore</code>文件也是很好的做法。在该文件中，您指定了在构建时不应该复制到Docker映像中的所有内容。这有助于精简您的映像并加快构建时间。</p><p id="1e5a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们需要选择一个基础图像。我们的代码需要Python 3.7，图像应该在您的Rpi上运行，因此，我选择了<code class="fe nf ng nh mw b">arm32v7/python:3.7-slim-buster</code> <em class="ni">。</em></p><p id="7382" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">添加这个并安装诗歌，docker文件的第一行如下所示:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="6333" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">FROM</strong> arm32v7/python:3.7-slim-buster<br/><strong class="mw iu">RUN</strong> apt-get update \<br/>&amp;&amp; apt-get install build-essential -y \<br/>&amp;&amp; pip install poetry</span></pre><p id="8411" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下一步是复制<code class="fe nf ng nh mw b">pyproject.toml</code>文件并安装所有非开发依赖项:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="8b19" class="na lz it mw b gy nb nc l nd ne"><strong class="mw iu">COPY</strong> ./pyproject.toml /app/<br/><strong class="mw iu">WORKDIR</strong> /app/<br/><strong class="mw iu">RUN</strong> poetry install --no-dev</span></pre><p id="8c14" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，我们复制我们的应用程序代码，并添加一个入口点，在运行容器时启动服务器:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7249" class="na lz it mw b gy nb nc l nd ne"># Install app<br/><strong class="mw iu">COPY</strong> ./rpicontrol /app/rpicontrol<br/><strong class="mw iu">RUN</strong> poetry install --no-dev<br/><strong class="mw iu">ENTRYPOINT</strong> poetry run uvicorn rpicontrol.server:valve_app --reload --host 0.0.0.0 --port 8080</span></pre><p id="7cde" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为什么我们不一次复制所有内容，只运行一次诗歌安装？</p><p id="7a9d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是一个很小但非常有效的Docker构建优化技术。当一次做所有事情并改变你的代码时，在一次重建中，Docker会重新安装所有的依赖项，即使它们没有改变。</p><p id="a026" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过将这两个步骤分开，我们利用了Docker的层缓存机制，并且不必重新安装依赖项。一般来说，经常变化的东西应该出现得很晚，才能利用Docker的层缓存机制。</p><p id="977d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将为您在代码或配置文件中更改小东西时节省大量构建时间。很抱歉那个借口，但我希望将来能对你有所帮助。这里是更多的细节。</p><p id="abf4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后要注意的是，最终，您必须在Raspberry Pi上构建该映像，这样优化会更有意义，因为有了基本映像。然而，如果您想在本地测试构建，只需从基本映像中删除<code class="fe nf ng nh mw b">arm32v7/</code>就可以了。</p><p id="98cb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，这就是web服务器，让我们部署它吧！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="79e0" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">部署应用程序</h1><p id="442d" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">为了部署这个应用程序，我最后添加了一个<code class="fe nf ng nh mw b">docker-compose.yaml</code>文件，它比<code class="fe nf ng nh mw b">pyproject.toml</code>文件高一级。我宁愿向您展示我的文件夹结构，以免让您感到不必要的困惑:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="fc88" class="na lz it mw b gy nb nc l nd ne">├── docker-compose.yaml<br/>└── rpicontrol<br/> ├── Dockerfile<br/> ├── poetry.lock<br/> ├── pyproject.toml<br/> ├── rpicontrol<br/> │ ├── Dummypi.py<br/> │ ├── __init__.py<br/> │ ├── server.py</span></pre><p id="bf60" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为什么我在这里使用docker-compose？因为两个原因:</p><ol class=""><li id="a02f" class="nl nm it kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated">我可以将运行Docker容器的配置参数存储在一个文件中，并对该文件进行版本控制。</li><li id="d264" class="nl nm it kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">将来，我想添加一个数据库，这将是添加到组合文件中的另一个服务。</li></ol><p id="a8cf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么，合成文件应该包含什么呢？</p><p id="5d24" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我希望可以通过端口80访问该应用程序，所以我将容器端口8080映射到Rpi上的端口80。为了访问GPIOs，我还需要在特权模式下运行服务，并且我还必须将<code class="fe nf ng nh mw b">/dev/mem</code>从Rpi挂载到Docker容器。</p><p id="d153" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">所有这些都是通过以下docker-compose文件完成的:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="5dfa" class="na lz it mw b gy nb nc l nd ne">version: '3.7'<br/>services:<br/>  server:<br/>    image: rpicontrol<br/>    build: ./rpicontrol<br/>    ports:<br/>      - 80:8080<br/>    devices:<br/>      - "/dev/mem:/dev/mem"<br/>    privileged: true</span></pre><p id="9551" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，假设您已经将整个文件夹复制到您的Rpi，希望通过克隆一个Git repo，您只需输入:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="b642" class="na lz it mw b gy nb nc l nd ne">docker-compose up</span></pre><p id="dc97" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将建立图像，只是第一次它没有找到相应的图像。之后，它将重用可用的那个。如果您进行了任何更改，您可以通过以下方式重建映像:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="183a" class="na lz it mw b gy nb nc l nd ne">docker-compose build</span></pre><p id="2359" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要访问Rpi，您必须在同一个网络上，并且知道它的IP地址。</p><p id="fb8e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，只要打开一个浏览器，进入<code class="fe nf ng nh mw b"><a class="ae ku" href="http://192.168.1.RPIIP." rel="noopener ugc nofollow" target="_blank">http://192.168.1.RPIIP</a></code> <a class="ae ku" href="http://192.168.1.RPIIP." rel="noopener ugc nofollow" target="_blank">。</a>现在，我们有一个正在运行的网络服务器，一个丑陋的网页，可以通过图形用户界面控制我们的阀门。任务完成了。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="27e7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="9515" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">感谢您的关注。我想我已经在这篇文章中涉及了很多东西，实际上比我之前想的要多得多。</p><p id="24c0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我希望至少有一样东西对你有用，你可以开始开发和部署漂亮的web应用程序，也许是在Raspberry Pi上。</p></div></div>    
</body>
</html>