<html>
<head>
<title>The Complete Guide to Creating Python Packages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建Python包的完整指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-complete-guide-to-creating-python-packages-3ecb150a1a43?source=collection_archive---------8-----------------------#2021-03-16">https://betterprogramming.pub/the-complete-guide-to-creating-python-packages-3ecb150a1a43?source=collection_archive---------8-----------------------#2021-03-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="53f8" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">是时候将可重用的Python脚本转换成包了</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/847ab3489d9f2ab6174414bdc62fb301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gxm5w6sZg1cBX8yn"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过<a class="ae kz" href="https://unsplash.com/@benchaccounting?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">工作台会计</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上创建包</p></figure><p id="fc17" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你像我一样，你可能有几个Python脚本，可以在每个项目中重复使用。它们充满了有用的函数和类，可以帮助您提高工作效率。在一个新项目的开始，你复制脚本，你就上路了。</p><p id="d705" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，是时候将您的脚本转换成真正的Python包了。转换它们将使它们更易于使用和与他人共享。别再复制粘贴了！</p><p id="1ad8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我还有几个在Kaggle比赛中重复使用的Python脚本。例如，在TensorFlow中实现CutMix和MixUp数据扩充的两个脚本。</p><p id="3883" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我将把这些脚本转换成一个Python包。我们将一步一步来，以便你能跟上。到本文结束时，我们将已经向PyPI上传了一个包，准备供其他人使用！</p><p id="e0fb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你只对源代码感兴趣，你可以在<a class="ae kz" href="https://github.com/PatrickKalkman/python-package-creation" rel="noopener ugc nofollow" target="_blank"/>GitHub仓库中找到。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="76f8" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">将代码转换为本地包</h1><p id="b321" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">你要做的第一件事是为你的包创建一个特定的文件夹结构。我将调用我的包<code class="fe na nb nc nd b">tensorflow_helpers</code>，所以我创建了下面的目录结构:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">包的初始目录结构</p></figure><p id="9012" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我的存储库的根目录下，我创建了一个<code class="fe na nb nc nd b">tensorflow_helpers</code>目录。在这个文件夹里，我放了一个叫做<code class="fe na nb nc nd b">__init__.py</code>的特殊文件。该文件将该目录标记为Python包—文件本身是空的。另一个文件<code class="fe na nb nc nd b">tensorflow_helpers.py</code>包含包代码。</p><p id="38dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我添加了两个子包，分别叫做<code class="fe na nb nc nd b">augmentation</code>和<code class="fe na nb nc nd b">training-preparation</code>。这使得组织代码更加容易。您可以通过在带有<code class="fe na nb nc nd b">__init__.py</code>文件的主包文件夹中创建附加文件夹来添加子包。文件夹结构现在看起来像这样:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">添加子包</p></figure><h2 id="ad38" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">添加文档</h2><p id="a8cb" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">有了目录结构，我们必须讨论文档。我知道这不是最有趣的部分，但它是至关重要的，因为它帮助用户使用你的代码。</p><p id="12e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们必须记录每个函数、类和类方法。在开始之前，我们必须选择一种文档样式。有四种风格可以使用:Google、NumPy、reST和Javadoc——它们没有太大区别。</p><p id="03a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我选择使用reStructuredText (reST)。这款是<a class="ae kz" href="https://www.python.org/dev/peps/pep-0287/" rel="noopener ugc nofollow" target="_blank"> PEP 287 </a>推荐的。</p><p id="8551" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">开始记录的一个简单方法是使用<code class="fe na nb nc nd b">pyment</code>。这是一个Python程序，可以在现有的Python文件中创建、更新或转换文档字符串。它支持前面提到的样式。</p><p id="8869" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你用<code class="fe na nb nc nd b">pip install pyment</code>安装<code class="fe na nb nc nd b">pyment</code>。然后，您可以使用它来生成文档模板，如下所示:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="d3ca" class="ng me iu nd b gz nw nx l ny nz">pyment -w .\training-preparation.py -o reST</span></pre><p id="7bd0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">-w</code>告诉<code class="fe na nb nc nd b">pyment</code>将文档添加到现有文件中。<code class="fe na nb nc nd b">-o</code>设置输出文档样式，在我们的例子中是<code class="fe na nb nc nd b">reST</code>。当然，它不会编写文档，但会给你一个很好的开始。如下图所示。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">没有文件</p></figure><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用pyment添加的文档模板</p></figure><h2 id="4665" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">结构化导入</h2><p id="170b" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">有了文档，就该考虑如何让用户导入您的包了。默认情况下，以下内容不起作用:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="5ec1" class="ng me iu nd b gz nw nx l ny nz">from tensorflow_helpers.augmentation import CutMixImageDataGenerator</span><span id="24e5" class="ng me iu nd b gz oa nx l ny nz">help(CutMixImageDataGenerator)</span></pre><p id="c9a7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">执行此操作会导致以下错误:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="38f1" class="ng me iu nd b gz nw nx l ny nz">Traceback (most recent call last):<br/>  File "main.py", line 3, in &lt;module&gt;<br/>    help(tensorflow_helpers.CutMixImageDataGenerator)<br/>AttributeError: module 'tensorflow_helpers' has no attribute 'CutMixImageDataGenerator'</span></pre><p id="faed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们现在想要使用<code class="fe na nb nc nd b">CutMixImageDataGenerator</code>，我们必须像这样导入它:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="2ac6" class="ng me iu nd b gz nw nx l ny nz">import tensorflow_helpers.augmentation.cutmix_imagedatagenerator</span><span id="fbfa" class="ng me iu nd b gz oa nx l ny nz">help(tensorflow_helpers.augmentation.cutmix_imagedatagenerator.CutMixImageDataGenerator)</span></pre><p id="5e76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是大量的打字工作。为了让你的用户更容易使用这个包，我们通过使用内部导入来解决这个问题。</p><p id="0465" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们必须向<code class="fe na nb nc nd b">augmentation</code>文件夹中的<code class="fe na nb nc nd b">__init__.py</code>文件添加两个相对导入。</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="0ca4" class="ng me iu nd b gz nw nx l ny nz">from .cutmix_imagedatagenerator import CutMixImageDataGenerator<br/>from .mixup_imagedatagenerator import MixupImageDataGenerator</span></pre><p id="6681" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其次，我们向<code class="fe na nb nc nd b">tensorflow-helpers</code>文件夹中的<code class="fe na nb nc nd b">__init__.py</code>添加一个相对导入。</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="1165" class="ng me iu nd b gz nw nx l ny nz">from . import augmentation</span></pre><p id="312f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们可以这样使用<code class="fe na nb nc nd b">CutMixImageDataGenerator</code>。这看起来更好，使用的字符更少。</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="6e8c" class="ng me iu nd b gz nw nx l ny nz">from tensorflow_helpers.augmentation import CutMixImageDataGenerator</span><span id="bffd" class="ng me iu nd b gz oa nx l ny nz">help(CutMixImageDataGenerator)</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="69f3" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">将本地软件包转换为可安装软件包</h1><p id="5358" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">到目前为止，我们的包的源代码一直在我们的解决方案文件夹的子文件夹中。因为包是子文件夹，我们可以直接导入。但是，如果我们将包移动到另一个位置，我们就不能。</p><p id="7178" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们必须使软件包可安装，然后安装软件包。安装后，我们可以在任何地方使用它，就像任何其他软件包一样。</p><p id="109e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过添加文件<code class="fe na nb nc nd b">setup.py</code>来使包可安装。</p><h2 id="e7da" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">添加安装脚本</h2><p id="1cb8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">安装脚本包含软件包的附加元数据。如果您想发布您的包，这个文件是至关重要的。</p><p id="8a3c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在添加<code class="fe na nb nc nd b">setup.py</code>之前，我们必须重新构建代码。<code class="fe na nb nc nd b">setup.py</code>脚本不应该是包源代码的一部分。因此，我们创建一个新的顶级文件夹，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/9e44a6837f0619b5ef7240226c1b1628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lKGqoJg-ep7-Ymo1F-2Gw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">我们的包的文件夹结构</p></figure><p id="4462" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在文件夹<code class="fe na nb nc nd b">tensorflow_helpers</code>里面添加了一个文件夹<code class="fe na nb nc nd b">tensorflow_helpers</code>。我已经将setup.py文件添加到外层的<code class="fe na nb nc nd b">tensorflow_helpers</code>中。</p><p id="14ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">安装脚本包含作者、名称、描述和软件包版本等内容。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">setup.py脚本使您的软件包可以安装</p></figure><p id="9b9f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一旦创建了setup.py脚本，就可以使用<code class="fe na nb nc nd b">pip</code>来安装它。我们导航到与setup.py脚本相同的文件夹，并执行以下命令:</p><p id="7523" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">pip install -e .</code></p><p id="cc76" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">.</code>告诉pip在当前目录下安装包。<code class="fe na nb nc nd b">-e</code>表示您希望在可编辑模式下安装软件包。如果没有这一点，您将不得不在开发过程中每次对包进行更改时重新安装包。</p><p id="d78a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果一切顺利，您应该会看到以下内容:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/96ecfd46763b3fc30fedbaea1a8431c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaWKxo7TFxCOPZM5rOhu_w.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在可编辑模式下安装软件包</p></figure><h2 id="1d93" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">处理依赖关系</h2><p id="95b3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">通常，您的包使用其他包，如NumPy或Pandas。这些包是您的包的依赖项。</p><p id="217d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了确保您的软件包的用户自动安装这些依赖项，我们在安装脚本中添加了<code class="fe na nb nc nd b">install_requires</code>参数。</p><p id="1cf4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还必须确保它们使用正确的Python版本，这可以通过<code class="fe na nb nc nd b">python_requires</code>参数来指定。</p><p id="5d89" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我们的<code class="fe na nb nc nd b">setup.py</code>脚本看起来像这样:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ne nf l"/></div></figure><p id="fc53" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您尝试允许尽可能多的依赖包版本，那将是最好的。如果您对版本号限制过多，您的用户可能不会安装您的软件包。</p><h2 id="92cb" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated"><strong class="ak">开发者环境</strong></h2><p id="131a" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">为包开发人员提供一个环境也是一个很好的实践。您的包合作者的开发环境都需要拥有所有依赖包的完全相同的版本。</p><p id="4817" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过执行<code class="fe na nb nc nd b">pip freeze</code>命令找出您正在使用的所有确切版本，这将生成一个包含所有包和版本的列表。您可以像这样将其写入一个<code class="fe na nb nc nd b">requirement.txt</code>文件:</p><p id="c96d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">pip freeze &gt; requirements.txt</code></p><p id="a423" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这确保了任何人都可以通过简单地执行<code class="fe na nb nc nd b">pip install</code>命令开始开发。</p><h2 id="5501" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">添加许可证</h2><p id="414d" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果你在线共享你的包和代码，你必须包含一个许可文件。如果你不这样做，你就没有给其他人分享、修改或使用代码的许可。大多数Python包都是开源的，可以由其他用户自由修改和共享。</p><p id="deb7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">choosealicense.com网站可以帮助你选择合适的许可证。</p><p id="69fc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于我的包，我选择<a class="ae kz" href="https://choosealicense.com/licenses/mit/" rel="noopener ugc nofollow" target="_blank">麻省理工学院许可</a>。您从choosealicense.com复制许可证的内容，并将其放在一个名为<code class="fe na nb nc nd b">LICENSE</code>的文件中。</p><h2 id="2a92" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">添加自述文件</h2><p id="5caf" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">项目的另一个重要文件是自述文件。该文件充当您的包的首页。如果你在Github或PyPI上在线托管你的包，那么你的自述文件将会显示在那里。</p><p id="9650" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你包括什么由你决定。一份好的自述文件将包括:</p><ul class=""><li id="0448" class="od oe iu lc b ld le lg lh lj of ln og lr oh lv oi oj ok ol bi translated">包标题。</li><li id="2f2c" class="od oe iu lc b ld om lg on lj oo ln op lr oq lv oi oj ok ol bi translated">包的描述。</li><li id="b8d6" class="od oe iu lc b ld om lg on lj oo ln op lr oq lv oi oj ok ol bi translated">如何安装软件包。</li><li id="fc59" class="od oe iu lc b ld om lg on lj oo ln op lr oq lv oi oj ok ol bi translated">入门示例。</li><li id="fc61" class="od oe iu lc b ld om lg on lj oo ln op lr oq lv oi oj ok ol bi translated">如何为包代码做贡献？</li><li id="9fbc" class="od oe iu lc b ld om lg on lj oo ln op lr oq lv oi oj ok ol bi translated">关于所用许可证类型的说明。</li></ul><p id="6d9f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看看tensorflow_helpers包的<a class="ae kz" href="https://github.com/PatrickKalkman/python-package-creation/blob/main/tensorflow_helpers/README.md" rel="noopener ugc nofollow" target="_blank">自述文件</a>。</p><h2 id="005e" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">正在添加清单. in</h2><p id="3e50" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在发布您的包之前，您需要创建的最后一个文件是<code class="fe na nb nc nd b">MANIFEST.in</code>文件。该文件列出了您希望随软件包一起分发的所有额外文件。</p><p id="604e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，该发行版不包括许可证和自述文件。所以我们需要把它们列在<code class="fe na nb nc nd b">MANIFEST.in</code>里，就像这样:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="8859" class="ng me iu nd b gz nw nx l ny nz">README.md<br/>LICENSE</span></pre></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="3cb7" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">发布您的包</h1><p id="50d8" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">此时，您的包已准备好发布。当您使用<code class="fe na nb nc nd b">pip</code>安装包时，您可以从Python包索引(称为PyPI)下载它们。</p><p id="499c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">PyPI是一个在线代码库，任何人都可以上传包。你只需要注册一个免费账户。</p><p id="7184" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在你上传你的包之前，你必须创建你的包的发行版。有两种分布:源分布和轮分布。</p><p id="89cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">源代码发行版包含您作为包的一部分编写的所有Python文件。车轮发行版是软件包的处理版本，尺寸更小，安装更快。车轮发行版是首选发行版—如果可用，Pip将使用该发行版。</p><p id="5462" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是，当您将发行版上传到PyPI时，最好同时上传wheel和源发行版。</p><h2 id="1749" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">创建发行版</h2><p id="5920" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您可以使用以下命令创建分布:</p><p id="53e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">python setup.py sdist bdist_wheel</code></p><p id="5b6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">参数<code class="fe na nb nc nd b">sdist</code>和<code class="fe na nb nc nd b">bdist_wheel</code>表明我们想要构建源和轮分布。该命令的结果是一个包含轮子和源分布的<code class="fe na nb nc nd b">dist</code>文件夹。它还会创建build和egg-info目录，但是您可以忽略这些。</p><p id="1196" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">剩下的工作就是将dist文件夹中的文件上传到PyPI。您可以像这样使用<code class="fe na nb nc nd b">twine</code>上传包。</p><p id="c2cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">twine upload dist/*</code></p><p id="1bb2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Twine将要求您输入您的PyPI用户名和密码。还有一个PyPI的测试版本，您可以使用它来确保一切都按照您想要的样子运行。使用以下命令将我们的包上传到TestPyPI:</p><p id="d8bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">twine upload -r testpypi dist/*</code></p><p id="bb1e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意，TestPyPI站点需要一个单独的帐户。当你上传这个包时，它会立即出现在<a class="ae kz" href="https://test.pypi.org/project/tensorflow-helpers/0.2.0/" rel="noopener ugc nofollow" target="_blank">网站</a>上。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj or"><img src="../Images/05498d14cad90034b415879a53df40af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y9oBxiKvuVTSXnuPYq4Ulw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">上传到TestPiPI的包</p></figure></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="0872" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">提高您的包装质量</h1><p id="c8c3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">现在，我们上传了我们的包，我们可以看看如何提高我们的包的质量。我们可以通过添加自动测试和验证代码的一致性来提高质量。</p><h2 id="1f32" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">自动测试</h2><p id="b3e2" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">许多开源包都包含一组可以自动运行的测试。他们甚至在项目页面上显示使用这些测试覆盖了多少代码。参见<a class="ae kz" href="https://github.com/pandas-dev/pandas" rel="noopener ugc nofollow" target="_blank"> Pandas Github项目页面</a>。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj os"><img src="../Images/f0fed7ea2bdf7cc821d805bfa97c602b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5maaXfIsFQQz7IUr2ivF9g.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">熊猫主页上的代码覆盖率指示</p></figure><p id="f594" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">codecov徽章显示88%——这意味着Pandas包的自动化测试覆盖了88%的源代码。</p><p id="e78c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">理想情况下，您为包中的每个函数添加一个测试。您的测试应该以类似于您的包源代码的方式组织。对于包中的每个脚本文件，您还需要创建一个测试文件。这意味着我们的代码结构看起来像这样——左边是包本身的源代码，右边是测试代码:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ot"><img src="../Images/2430c5af64cda5a3838d1f4d07a3ef10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ubC11gTTTre-GURKOnIbSw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">包内测试代码的组织</p></figure><p id="59cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我不会详细讨论创建测试本身，因为那是另外一个主题。您可以在Python <a class="ae kz" href="https://docs.python.org/3/library/unittest.html" rel="noopener ugc nofollow" target="_blank">文档</a>中找到更多相关信息。</p><h2 id="7373" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">代码一致性</h2><p id="1770" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如你所知，源代码被阅读的次数比它被编写的次数多。因此，为了帮助读者，保持一致的代码风格很重要。这种风格应该包括命名变量和函数、源代码布局和一般的经验法则。</p><p id="dab4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们没有创建自己的风格，而是使用了一个名为PEP8的预定义风格。我们通过使用flake8来加强PEP8。Flake8是一个静态代码检查器。这意味着它分析你的源代码而不运行它。您可以使用以下命令安装flake8:</p><p id="60e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">python -m pip install flake8</code></p><p id="c2dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以从终端运行flake8，但是如果您使用Visual Studio代码，您可以使用一个插件，在键入时直接分析源代码。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="7639" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">使用Cookiecutter</h1><p id="0adc" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">在前面的段落中，我们从头开始构建我们的包。也可以使用Cookiecutter等发生器。Cookiecutter是一个从模板创建包的命令行工具。</p><p id="faaf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以使用它来创建一个空的Python包。这些模板创建了您的包需要的所有文件。因此，您可以将更多的精力放在代码上，不需要担心是否忘记了什么。</p><p id="c7fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在使用它之前，您必须安装它:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="b7a6" class="ng me iu nd b gz nw nx l ny nz">python3 -m pip install cookiecutter</span></pre><p id="e6b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">安装后，使用以下命令启动CookieCutter:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="bbb4" class="ng me iu nd b gz nw nx l ny nz">cookiecutter <a class="ae kz" href="https://github.com/audreyr/cookiecutter-pypackage" rel="noopener ugc nofollow" target="_blank">https://github.com/audreyr/cookiecutter-pypackage</a></span></pre><p id="cddf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您查看Cookiecutter生成的文件，您会看到两个额外的文件，<code class="fe na nb nc nd b">CONTRIBUTING.md</code>和<code class="fe na nb nc nd b">HISTORY.md</code>。</p><p id="e55f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe na nb nc nd b">CONTRIBUTING.md</code>描述了其他开发者如何帮助开发这个包。如果开发人员有兴趣帮助您的包，这个文件是他们首先要看的地方。</p><p id="1326" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Cookiecutter生成的<a class="ae kz" href="https://github.com/audreyfeldroy/cookiecutter-pypackage/blob/master/CONTRIBUTING.rst" rel="noopener ugc nofollow" target="_blank"/><code class="fe na nb nc nd b"><a class="ae kz" href="https://github.com/audreyfeldroy/cookiecutter-pypackage/blob/master/CONTRIBUTING.rst" rel="noopener ugc nofollow" target="_blank">CONTRIBUTING.md</a></code>是一个很好的起点。它以下面的句子开始:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="8e89" class="ng me iu nd b gz nw nx l ny nz">Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</span></pre><h2 id="e34c" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">HISTORY.md</h2><p id="90d9" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated"><code class="fe na nb nc nd b">HISTORY.md</code>包含发行说明。这是一个降价文件，描述了从一个版本到另一个版本的所有变化。它告诉您的用户在以前的版本和新版本之间有什么重要的变化，这样他们就可以知道他们应该使用哪个版本的软件包。</p><p id="e99c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">没有关于如何构造这个文件的官方指南，但是大多数软件包都使用这样的结构:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="1a2c" class="ng me iu nd b gz nw nx l ny nz">Release History<br/>===============<br/><br/>2.25.1 (2020-12-16)<br/>-------------------<br/>**Bugfixes**<br/>- Requests now treats `application/json` as `utf8` by default. Resolving inconsistencies between `r.text` and `r.json` output. (#5673)<br/><br/>**Dependencies**<br/>- Requests now supports chardet v4.x.<br/><br/>2.25.0 (2020-11-11)<br/>------------------<br/>**Improvements**<br/>- Added support for NETRC environment variable. (#5643)</span></pre><h2 id="611f" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">版本编号</h2><p id="27e3" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您看到了<code class="fe na nb nc nd b">HISTORY.md</code>包含版本号。如果你发布了一个新版本的包，你必须增加版本号。版本号由三部分组成。主要编号、次要编号和修补程序编号。</p><p id="f9eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着你开发这个包，你将增加这些数字。一个众所周知的更新版本号的策略叫做语义版本化。<a class="ae kz" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本化</a>规定了版本号如何分配和递增。它指出:</p><blockquote class="ou ov ow"><p id="93b5" class="la lb ox lc b ld le jv lf lg lh jy li oy lk ll lm oz lo lp lq pa ls lt lu lv in bi translated">给定主要版本号。小调。补丁，增加:</p><p id="9792" class="la lb ox lc b ld le jv lf lg lh jy li oy lk ll lm oz lo lp lq pa ls lt lu lv in bi translated">主要版本当您进行不兼容的API更改时，</p><p id="cb23" class="la lb ox lc b ld le jv lf lg lh jy li oy lk ll lm oz lo lp lq pa ls lt lu lv in bi translated">当您以向后兼容的方式添加功能时，次要版本</p><p id="ca58" class="la lb ox lc b ld le jv lf lg lh jy li oy lk ll lm oz lo lp lq pa ls lt lu lv in bi translated">当你做向后兼容的错误修正时，补丁版本。</p><p id="cc9c" class="la lb ox lc b ld le jv lf lg lh jy li oy lk ll lm oz lo lp lq pa ls lt lu lv in bi translated">预发布和构建元数据的附加标签可作为主标签的扩展。小调。补丁格式。</p></blockquote><h2 id="f341" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">凹凸版本工具</h2><p id="71d0" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">您可以使用<code class="fe na nb nc nd b">bump-version</code>工具更新版本号。我们在命令行上从您的包的顶层运行该工具。</p><p id="15eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用当前版本、参数、主要版本、次要版本或补丁以及文件名运行<code class="fe na nb nc nd b">bumpversion</code>。然后，它会增加该文件中版本号的主版本号、次版本号或补丁号。</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="5013" class="ng me iu nd b gz nw nx l ny nz">bumpversion --current-version 0.2.0 patch setup.py</span></pre><h2 id="6cd3" class="ng me iu bd mf nh ni dn mj nj nk dp mn lj nl nm mp ln nn no mr lr np nq mt nr bi translated">使用Makefile</h2><p id="e2cc" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">Cookiecutter还生成一个Makefile。Makefile使得执行我们之前使用的各种终端命令变得更加容易。您可以随时向Makefile中添加更多的函数。Cookiecutter的默认Makefile包含以下命令:</p><pre class="kk kl km kn gu ns nd nt nu aw nv bi"><span id="d04e" class="ng me iu nd b gz nw nx l ny nz">clean          remove all build, test, coverage and Python artifacts<br/>clean-build    remove build artifacts<br/>clean-pyc      remove Python file artifacts<br/>clean-test     remove test and coverage artifacts<br/>lint           check style with flake8<br/>test           run tests quickly with the default Python<br/>test-all       run tests on every Python version with tox<br/>coverage       check code coverage quickly with the default Python<br/>docs           generate Sphinx HTML documentation, including API<br/>servedocs      compile the docs watching for changes<br/>release        package and upload a release<br/>dist           builds source and wheel package<br/>install        install the package to the Python's site-packages</span></pre><p id="ba4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">例如，不要执行<code class="fe na nb nc nd b">python setup.py sdist bdist_wheel</code>来生成分布，可以使用<code class="fe na nb nc nd b">make dist</code>，这样更容易记住。</p></div><div class="ab cl lw lx hy ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="in io ip iq ir"><h1 id="acb6" class="md me iu bd mf mg mh mi mj mk ml mm mn ka mo kb mp kd mq ke mr kg ms kh mt mu bi translated">结论</h1><p id="a971" class="pw-post-body-paragraph la lb iu lc b ld mv jv lf lg mw jy li lj mx ll lm ln my lp lq lr mz lt lu lv in bi translated">如果您继续学习，您会看到我们从将Python脚本转换成本地包开始。我们添加了文档并组织了导入。这使得用户更容易使用该软件包。</p><p id="26d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们通过创建安装脚本将本地包转换为可安装包。我们管理了我们的依赖项，并添加了一个许可证和一个自述文件。在制作了一个源和轮子发行版之后，我们将它们发布到PyPI。</p><p id="2317" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">发布之后，我们研究了添加测试和提高代码一致性如何提高我们的包的质量。</p><p id="1dbc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">最后，我们看了如何使用Cookiecutter生成一个带有模板的Python包。Cookiecutter生成了额外的文件，如<code class="fe na nb nc nd b">CONTRIBUTING.md</code>和<code class="fe na nb nc nd b">HISTORY.md</code>。Cookiecutter还生成了一个Makefile，使与包的交互更加容易。</p><p id="d4ca" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我将我的包上传到测试PyPI站点，以确保它正确显示。你可以在这个<a class="ae kz" href="https://github.com/PatrickKalkman/python-package-creation" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到我的包的源代码。</p><p id="20f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">谢谢你的阅读，记住永远不要停止学习！</p></div></div>    
</body>
</html>