# 以初学者的心态看战略设计模式

> 原文：<https://betterprogramming.pub/approaching-design-patterns-with-beginners-mind-the-strategy-f326eb810cd7>

## 通过一个 Java 例子理解策略设计模式

![](img/0b62c57db4b45deaf6307744b44095b1.png)

[斯科特·格雷厄姆](https://unsplash.com/@homajob?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

# 介绍

在我们开始之前，有一个小问题:你知道学习的最好方法之一是教别人吗？它之所以有效，是因为当你向某人解释你所学到的东西时，你会比仅仅举例阅读更好地理解它。这是我在练习时一直在做的事情，这对保留知识很有帮助。

回到手头的事情，在过去的几个月里，我参加了一些软件开发人员职位的面试。不出所料，有一些技术问题，问得最多的一个问题是:“你知道哪些设计模式？”我只有基本的知识，不能自信地谈论它。所以他们建议我阅读经典书籍《设计模式:可重用面向对象软件的元素》

说实话，那本书的封面很吓人。但是一旦开始读，就很过瘾了。虽然这是一本厚厚的书，但它回顾了一些 OOP 概念，并以一种非常自然的方式介绍了设计模式。在本文中，我将分享我对书中提出的第一批模式之一的一些想法:策略设计模式。

如果你不熟悉设计模式，你可能会问“这些名字是什么意思？”该模式的名称表达了该模式的本质，并让我们与同事讨论它们。我们还有参与设计模式的类和对象的名称。请记住，这些名称通常过于抽象，您的工作就是找到在应用程序中使用的好名称。然而，您可以在应用程序中包含这些名称，以使模式实现显式化。

# 编程到接口

当谈到设计模式时，接口是一个非常常见的主题。他们常说一个接口就是一组空体的方法。和继承接口的类必须实现该接口定义的所有方法。我以前也是这么想的，但这并不能解释我们为什么要实现接口。幸运的是，这本书阐明了这个主题:

> "类继承根据另一个对象的实现来定义一个对象的实现。简而言之，它是一种代码和表示共享的机制。
> 然而，实现重用只是故事的一半。继承定义具有相同接口的对象族的能力也很重要。为什么？因为多态依赖于它。”

如果对象共享相同的接口，它们可以支持相同的请求，即使实现不同。简而言之，它允许我们用一个对象代替另一个——也称为多态性。但是就接口而言，操纵对象有什么好处呢？客户端，也就是任何访问这个接口的软件，都不知道实现这些对象的类型或类。

> “这极大地减少了子系统之间的实现依赖性，导致了以下可重用面向对象设计的原则:

> **程序给一个接口，而不是一个实现。**

> 不要将变量声明为特定具体类的实例。相反，只提交由抽象类定义的接口。"

# 战略设计模式

策略模式的目的是将算法封装在对象中。它强烈地基于前面提到的“编程到接口”原则，因为它是通过设计一个支持一系列算法的接口来实现的。下图说明了这一想法:

![](img/059762e473ab49e4f3829e3c66718311.png)

图片来源:作者

这是一个基于对象建模技术(OMT)符号的类图。每个框代表一个类，其名称在顶部以粗体显示。斜体名称表示该类或方法是抽象的。因此，我们只有一个名为`Strategy`的抽象类和一些其他的具体类。

该策略以抽象类的形式呈现，因为《设计模式》一书是很久以前写的，并且主要用 C++提供示例，c++将接口实现为抽象类。在 Java 或 C#等编程语言中，该策略可以作为纯接口来实现:

```
interface MyStrategy
{
    void DoAlgorithm();
}
```

该图还显示了通过一条垂直线和一个三角形连接到`Strategy`的三个具体类:

![](img/9efd936f5308fdc653b1670e0a080aa3.png)

这意味着具体的类将根据使用**类继承**或接口实现的策略类来定义。策略类将把它的所有实现委托给具体类(子类)中定义的方法。在声明类型为 Strategy 的变量的任何地方，都可以分配这些类中的一个。如前所述，它们可以相互替换，因为它们共享相同的接口。

最后，我们有 Context 类，它引入了一种新的符号:

![](img/ef5b8b171edb3e91d4963f87c5dfcb10.png)

这条底部带菱形的箭头线表示一个**聚合关系**。简单来说，一个 Context 类的对象有一个 Strategy 类的对象。以及策略对象是上下文对象的一部分。通常通过定义成员变量来实现这种关系:

```
class Context
{
    MyStrategy myStrategy;
}
```

# 它是如何工作的？

对我来说，学习设计模式时最困难的事情之一是弄清楚如何在现实世界中应用它们。这没关系，因为也许你永远也不会面临一个你可以用本书涵盖的 23 种设计模式中的一种来解决的问题。我喜欢把它们想象成一个盒子里的工具，你可能在某个时候需要它。

使用策略模式的一个非常常见的场景是当一个**类定义了许多行为**，并且这些行为在其操作中表现为多个条件语句:

```
class Context
{
    switch (someCondition)
    {
        case 1:
            DoThingsOneWay();
            break;
        case 2:
            DoThingsAnotherWay();
            break;
        // ...
    }
}
```

策略模式通过将任务委托给策略对象提供了另一种选择:

```
class Context
{
    MyStrategy myStrategy; public void Operation()
    {
        myStrategy.DoAlgorithm();
    }
}
```

如前所述，上下文和策略相互作用来调用具体的算法。客户端通常创建一个 ConcreteStrategy 对象，并通过构造函数将其传递给上下文。我们还可以有一个 setter 方法来在运行时切换策略。无论如何，客户端只与上下文交互，它转发请求来执行它的策略:

```
Context context = new Context(new ConcreteStrategy());
context.Operation();
```

# 结论

在本文中，我试图强调我对策略设计模式的理解。要点是**策略模式将一个算法封装在一个对象**中。你可以在我的 [GitHub repo](https://github.com/marciosouzajunior/DesignPatterns) 中找到更多代码示例。

感谢阅读。