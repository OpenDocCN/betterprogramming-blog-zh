<html>
<head>
<title>The “never” Return Type for PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP的“永不”返回类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-never-return-type-for-php-802fbe2fa303?source=collection_archive---------7-----------------------#2021-04-15">https://betterprogramming.pub/the-never-return-type-for-php-802fbe2fa303?source=collection_archive---------7-----------------------#2021-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e59e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这不是一个大的增加，但它是一个受欢迎的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8d33b84d6819abca256f6e438d47e796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IQkweeOndZKeQwkY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@enginakyurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> engin akyurt </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="1616" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇，PHP列车不停啊？最近有一个针对PHP语言本身的新功能的RFC(征求意见稿)关闭了投票，它叫做 <code class="fe ls lt lu lv b"><a class="ae kv" href="https://wiki.php.net/rfc/noreturn_type" rel="noopener ugc nofollow" target="_blank">never</a></code>。</p><p id="70ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PHP 8.1计划在今年年底发布，除了<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/a-look-at-the-new-php-8-1-fibers-feature-979489399918">纤程</a>之外，新的<code class="fe ls lt lu lv b">never</code>关键字将允许你将一个函数标记为“永不”返回。该函数将通过抛出一个异常、永远循环或者简单地用<code class="fe ls lt lu lv b">die()</code>告诉PHP停止来停止正常的脚本执行。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="2125" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用新的“从不”</h1><p id="e220" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">说明为什么<code class="fe ls lt lu lv b">never</code>返回类型有意义的最好方法是用一个简单的例子来说明函数中的返回类型。不要过多考虑例子。这只是为了说明。</p><p id="79de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个类，<code class="fe ls lt lu lv b">Credentials</code>，用户可以在他们的项目中扩展使用。这个类保存有意义的数据，并使其可用于其他类，比如连接到不同外部API的HTTP客户端。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9dc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将其扩展到包含敏感数据，我们可以避免意外泄露。要做到这一点，我们可以很容易地在<code class="fe ls lt lu lv b">__toString()</code>方法中放入一个异常来阻止它的泄漏:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e3b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">返回类型在这里没有多大意义。我们不仅<em class="nc">不会</em> <strong class="ky ir"> </strong>返回一个<code class="fe ls lt lu lv b">string</code>，而且<em class="nc">永远不会</em>返回任何东西！我们总是不得不在某个地方记录它，因为PHP永远不会意识到代码中的这个中断。</p><p id="18f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多亏了新的RFC，我们可以通过返回协方差来“覆盖”它，这在代码级别就很清楚了:这个函数<em class="nc">永远不会</em>返回任何东西——这就是新关键字的名字。</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="01af" class="nh me iq lv b gy ni nj l nk nl">public function swim(): never<br/>{<br/>    throw new RuntimeError("Cats are very bad swimmers!")<br/>}</span></pre><p id="a6da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会说<code class="fe ls lt lu lv b">void</code>也一样，其实不然。当你使用<code class="fe ls lt lu lv b">void</code>时，你的意思是函数<em class="nc">返回空值</em>，所以脚本仍然可以继续正常执行，而<code class="fe ls lt lu lv b">never</code>则不能。</p><p id="73c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于永远不会返回任何东西的函数，你应该使用<code class="fe ls lt lu lv b">never</code>(例如，当它们永远循环的时候):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0ae0" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">这对我的应用程序意味着什么？</h1><p id="418f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">好吧，如果你正在使用一个函数，只有<em class="nc">为了方便起见</em>抛出一个异常或者它停止脚本执行，一旦PHP 8.1登陆你的服务器，你可以使用<code class="fe ls lt lu lv b">never</code>。在野外很难看到无尽的循环，但如果你看到了，你也可以使用<code class="fe ls lt lu lv b">never</code>。</p><p id="e102" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一件很酷的事情是，如果一个<em class="nc">从未</em>返回的函数实际上返回了其他东西，基于PHP 的<a class="ae kv" href="https://github.com/php/php-src/pull/6761" rel="noopener ugc nofollow" target="_blank"> pull请求，PHP将会恐慌。</a></p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="f6eb" class="nh me iq lv b gy ni nj l nk nl">function thisWillError(): never<br/>{<br/>    return 'oops!';<br/>}</span></pre><p id="6b04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用静态分析代码工具，如果您传递一个从不返回并期望正常执行的函数，您可能会捕捉到一个错误，因为捕捉和修复它会更容易。</p></div></div>    
</body>
</html>