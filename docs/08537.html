<html>
<head>
<title>Top 5 Hardest Coding Questions From Recent FAANG Interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最近FAANG访谈中最难的5个编码问题</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/top-5-hardest-coding-questions-from-recent-faang-interviews-d46bcb4dd8dc?source=collection_archive---------1-----------------------#2021-05-12">https://betterprogramming.pub/top-5-hardest-coding-questions-from-recent-faang-interviews-d46bcb4dd8dc?source=collection_archive---------1-----------------------#2021-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8dfe" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道哲学家进餐问题吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae1e13f0b9ac4f24f1b76c8850af404d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBH7flnvKyDj4f20yOzvaQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="b791" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">看起来编码面试变得越来越难，准备面试并不是一件容易的事情。面试中向你提出的问题种类没有限制，其中许多都不容易。“最难”的问题因人而异。对你来说轻而易举的事情对其他人来说可能极其困难，反之亦然。</p><p id="0b4c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不管你“最难”的问题是什么，为你的编码面试做好准备是至关重要的。我们与初级和高级开发人员讨论了他们对最难的编码面试问题的看法，并将前五名编辑成一个列表。今天，我们将更详细地探讨这个列表，并给你一些如何准备的建议。</p><p id="a0af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将涵盖:</p><ul class=""><li id="36a4" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">如何设计垃圾收集器</li><li id="1f41" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">硬币兑换问题</li><li id="62e1" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">哲学家进餐问题(多线程)</li><li id="c888" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">为什么要使用这些编程最佳实践？</li><li id="06d4" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如何实现LRU缓存</li><li id="f8ef" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">准备面试的后续步骤</li></ul></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="210c" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">1.如何设计垃圾收集器</h1><p id="9e12" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">如果你从未听说过，垃圾收集器问题是众所周知的非常困难。垃圾收集是一个大多数人在学校里不了解的话题，相关素材极其密集。学习垃圾收集涉及到很多理论，可能会让人不知所措。无论你使用哪种语言，了解你首选语言的来龙去脉对于有效解决这个问题都是至关重要的。</p><p id="12b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你解决这个问题时，不要害怕向面试官提问。记住，你的面试官是来帮助你的，希望看到你做得好。面试官通常会给你一些信息，帮助你朝着正确的方向前进。</p><p id="733d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nm">注意:垃圾收集问题在核心和高级Java面试中尤其常见，但对于其他编程语言来说，了解这些问题也很重要。</em></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="19dc" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">2.硬币兑换问题</h1><p id="a2dd" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">硬币找零的问题在脸书和亚马逊的采访中很常见。你会得到不同面值的硬币和总金额。由此，你需要写一个函数来计算出你需要的最少的硬币数，以达到这个数目。如果你不能用任何硬币组合达到给定的钱数，你返回<code class="fe nn no np nq b">-1</code>。</p><p id="23d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有三种方法可以解决这个问题:</p><ul class=""><li id="dbf3" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">强力</li><li id="b8f9" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">记忆自顶向下动态规划</li><li id="7889" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">具有表格化的自底向上动态规划</li></ul><p id="2773" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看在C++中使用自底向上的动态编程和表格化的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bcfc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于内循环的每次迭代，我们用<code class="fe nn no np nq b">denoms[j]</code>得到解，并存储在<code class="fe nn no np nq b">x</code>中。我们也得到了没有<code class="fe nn no np nq b">denoms[j]</code>的解，并存储在<code class="fe nn no np nq b">y</code>中。通过这样做，我们能够引用早期的解决方案来避免重复计算。</p><p id="c8f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于面额中的每一枚硬币，只能有两种可能:包含它或排除它。我们知道，如果硬币<code class="fe nn no np nq b">denom[j]</code>大于<code class="fe nn no np nq b">amount</code>，那么<code class="fe nn no np nq b">x</code>被设置为<code class="fe nn no np nq b">0</code>，因为不可能将它考虑在内。</p><p id="ddc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">时间复杂度为<em class="nm">* O(amount * denomsLength)</em>，即<code class="fe nn no np nq b">for</code>循环迭代次数。</p><p id="234b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nm">注意:这三种方法中的每一种都包括时间复杂度，这意味着要成功解决硬币兑换问题，时间复杂度是一个重要的概念。</em></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="dda7" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">3.哲学家进餐问题(多线程)</h1><p id="4d85" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">哲学家进餐问题通常用于并发算法设计，以演示同步问题以及解决这些问题的技术。问题陈述了有五个哲学家围坐在一张圆形桌子旁。哲学家必须交替思考和进食。</p><p id="4618" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个哲学家面前都有一碗食物，他们要求每只手拿一把叉子来吃东西。然而，只有五个叉子可用。你需要设计一个解决方案，每个哲学家都可以吃他们的食物，而不会导致死锁。</p><p id="0518" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于这个问题，开发人员通常会忽略这样一个想法，即它不是真正询问真实世界的场景，而是说明您在线程程序执行和/或疏忽处理锁时可能遇到的问题。这个想法是让你思考限制和正确的顺序，以最有效的方式完成这个任务。</p><p id="1973" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了准备这个问题，您应该深入了解同步、并发控制和信号量。</p><p id="0ff6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有两种可能的方法来解决这个问题:</p><ul class=""><li id="11cd" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">限制即将吃饭的哲学家。</li><li id="3f7a" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">重新订购叉车。</li></ul><p id="b363" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一下用Java重新订购叉式提货的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="bac4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个解决方案中，你让任何一个哲学家先拿起左边的叉子，而不是右边的。你选择哪个哲学家是左撇子并被要求先拿起他们的左叉并不重要。在我们的解决方案中，我们选择带有<code class="fe nn no np nq b">id=3</code>的哲学家作为我们的左手哲学家。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="0374" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">4.为什么要使用这些编程最佳实践？</h1><p id="90ea" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">在学习编程时，您通常会学到一些“最佳实践”最高效的开发人员在他们的编码过程中实施某些实践，这有助于他们确保他们的代码在功能和形式上都是最好的。</p><p id="df3c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">经过多年的编程经验，您会知道应该避免哪些实践，应该采用哪些实践。您可能对为什么一些实践比其他的更好有一个大概的想法，但是当需要解释原因的时候却犹豫了。</p><p id="5ece" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些最佳实践的例子包括:</p><ul class=""><li id="ec95" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">经常注释你的代码。</li><li id="36ba" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">识别并删除重复代码。</li><li id="12eb" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">React中的按功能分组。</li><li id="fa6b" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">避免Ruby中的隐藏结构。</li></ul><p id="f5d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为这些问题做好准备的最好方法是刷新你对有用和可避免的实践及其背后的推理的记忆。记住，你可以和面试官一起讨论这些问题。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="35a5" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">5.如何实现LRU缓存</h1><p id="bb1d" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">最近最少使用的(LRU)缓存实现问题在一些Google、Microsoft和Amazon访谈中被问到，但这不是一个很常见的问题。这个问题需要你深入思考，将两种或两种以上现有的数据结构结合起来。</p><p id="73b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重要的是要慢慢地阅读问题，并确保你明白你在问什么。这些问题通常要求您做一些事情。一旦你彻底阅读了问题，你可以要求你的面试官确认你的方向是正确的。</p><p id="3aff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在解决这些问题之前，请确保您了解什么是<em class="nm">缓存</em>。LRU是一种常见的缓存策略，它定义了当缓存已满时从缓存中删除元素以便为新元素腾出空间的策略。这意味着它首先丢弃最近最少使用的项目。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="3390" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">准备面试的后续步骤</h1><p id="bdab" class="pw-post-body-paragraph ky kz it la b lb nh ju ld le ni jx lg lh nj lj lk ll nk ln lo lp nl lr ls lt im bi translated">我们今天讨论的问题只是许多困难的编码面试问题中的几个。这些问题应该很难，甚至会难倒最有经验的开发人员。尽早开始面试准备很重要，这样你就有机会尽可能多的准备。</p><p id="3a94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些更困难的问题包括:</p><ul class=""><li id="2777" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">从数据流中找出中间值。</li><li id="50f0" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在旋转排序的数组中搜索。</li><li id="4287" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">最少骑士移动。</li><li id="7df8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">还有很多。</li></ul><p id="d3e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快乐学习！</p></div></div>    
</body>
</html>