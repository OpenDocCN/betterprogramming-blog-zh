<html>
<head>
<title>How to Optimize Performance of Your React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何优化React应用的性能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optimize-performance-react-59b3e7ba47fa?source=collection_archive---------5-----------------------#2022-06-08">https://betterprogramming.pub/optimize-performance-react-59b3e7ba47fa?source=collection_archive---------5-----------------------#2022-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a309" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解React的幕后，让您的应用程序运行得更快！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c5588ce9b5e9fc995777ee6196226fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M62xpUj_NcHAOc6XDaEguw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="c00a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要掌握任何框架或库，你必须深入其中。这不仅有助于理解抽象，也有助于改善开发人员的调试体验。对一个库的深入了解也会帮助你优化app。</p><p id="a2b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在React中，有一些事情让新手感到沮丧，当他们遇到这些事情时，他们会抓耳挠腮。在这篇文章中，我会试着列出一些让我毛骨悚然的事情，并告诉你了解这些基本原则是如何给我带来平静的！</p><h1 id="b9e7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">重新评估组件≠重新呈现Dom</h1><p id="4d1e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">就像一个库不知道存在像“DOM”这样的东西一样。是<code class="fe ms mt mu mv b"><a class="ae lu" href="https://reactjs.org/docs/react-dom.html" rel="noopener ugc nofollow" target="_blank">ReactDOM</a></code>与实际的DOM进行通信和交互。它是一个只管理组件和状态的库。然后，React将所有关于更改内容以及屏幕上应显示的内容的信息传递给正在使用的界面(即<code class="fe ms mt mu mv b">ReactDOM)</code>)。React基本上关心以下内容:</p><ol class=""><li id="370b" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated">道具(来自父组件)</li><li id="8cd5" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">状态(组件的内部数据)</li><li id="81fe" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">上下文(应用程序范围的状态)</li></ol><p id="3932" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当道具、状态或上下文发生变化时，React都会检查是否有新的内容要呈现在屏幕上，如果确实需要呈现，它会将该信息传递给<code class="fe ms mt mu mv b">ReactDOM</code>。</p><h1 id="fd1c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">虚拟DOM</h1><p id="9a89" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">React使用一种叫做<a class="ae lu" href="https://reactjs.org/docs/faq-internals.html" rel="noopener ugc nofollow" target="_blank">虚拟DOM </a>的东西。虚拟DOM决定了组件树(最终会呈现在屏幕上)，每个组件都有一个子树。所以React在任何状态改变后确定当前虚拟DOM和新虚拟DOM之间的差异，并将这个差异交给<code class="fe ms mt mu mv b">ReactDOM</code>。如果需要的话，<code class="fe ms mt mu mv b">ReactDOM</code>然后接收差异并操纵真正的DOM。</p><p id="efff" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，无论何时状态、上下文或属性发生变化，React都会重新评估并重新运行组件功能。</p><p id="4da9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有这样一个演示组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">演示组件</p></figure><p id="6841" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当该组件上的道具改变时，组件功能<code class="fe ms mt mu mv b">Demo</code>将重新运行并重新执行。另一方面，这并不意味着整个真实的DOM也会重新渲染。</p><p id="25c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">真正的DOM只会在道具/状态/上下文的变化影响到DOM的部分发生变化。因此，对真实DOM的更改只是为了评估之间的差异。真正的DOM很少改变，只有在需要的时候才会改变。</p><p id="5126" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一个很大的性能优势！在先前状态和新状态之间进行虚拟比较相对更便宜，因为它只发生在内存中，而不是接触真实的DOM然后进行比较。这个比较虚拟DOM新旧状态的概念叫做<a class="ae lu" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">虚拟DOM Diffing </a>。<a class="ae lu" href="https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e" rel="noopener">这篇</a>是关于同一主题的另一篇精彩文章。</p><h1 id="ce65" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">差分算法:幕后</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js</p></figure><p id="80de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，想象一个状态变化，一个新的<code class="fe ms mt mu mv b">&lt;p&gt;</code>标签被引入DOM。所以，<code class="fe ms mt mu mv b">ReactDOM</code>不会再渲染整个东西，即<code class="fe ms mt mu mv b">&lt;div&gt;</code>和<code class="fe ms mt mu mv b">&lt;h1&gt;</code>。但这只会造成差异。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">App.js</p></figure><p id="1bd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了查看它的运行情况，我将在浏览器中呈现上面的示例。我还将向您展示它是如何出现在开发人员工具中的，因为差异会“闪现”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8140d2d0601c929e2f51ca012b06a2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*6b33WVxoHsD88jIcfz7iRQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nn">按钮切换&lt; p &gt;标签</em>的可见性</p></figure><p id="348f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于上面的功能，如果你仔细观察开发者工具，当添加和删除时，<code class="fe ms mt mu mv b">&lt;p&gt;</code>会闪烁，而DOM的其余部分保持不变。这证明了真正的DOM只显示所需的更改，而不会不必要地呈现整个DOM。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl no"><img src="../Images/3a1b216b9d088da79aaff12c64391099.png" data-original-src="https://miro.medium.com/v2/format:webp/0*v9fvMTnZL4h9v2vc.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nn"> DOM显示切换&lt; p &gt;时的变化</em></p></figure><p id="d5e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的例子甚至适用于在JSX渲染的组件(有/没有道具)。</p><p id="e961" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑重新评估与状态和属性更改相关的组件。每当一个组件的状态或属性值改变时，整个组件都被“重新评估”这并不意味着DOM，即由该组件返回的整个JSX也被重新呈现。只有在虚拟DOM中存在差异的部分，变化才会在真实DOM中发生。</p><p id="c5d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">重新评估包括功能组件中定义的变量以及创建的功能的重新初始化。但是，React足够智能，不会重新初始化使用React挂钩<code class="fe ms mt mu mv b">useState</code>和<code class="fe ms mt mu mv b">useCallback</code>创建的状态和功能。因此，当整个组件被重新评估时，setter函数、状态变量和初始状态(对于<code class="fe ms mt mu mv b">useState</code>、<code class="fe ms mt mu mv b">useReducer</code>)都不会被重新初始化。</p><p id="5fae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4069" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从上面可以清楚地看到，当<code class="fe ms mt mu mv b">showPara</code>变量发生状态变化时，只有<code class="fe ms mt mu mv b">&lt;p</code> &gt;标签闪烁，因此<code class="fe ms mt mu mv b">DemoOutput</code>组件的<code class="fe ms mt mu mv b">show</code>的<code class="fe ms mt mu mv b">prop</code>值也发生变化。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2ebf64acd7863da81782bc81aa12cb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/0*Aw8RgKjh-0xb_XoN.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nn"> &lt; p &gt;标签闪烁为这是唯一的状态变化</em></p></figure><p id="d21b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是React的主要性能激励，因为组件子树可能非常复杂，并且与应用程序的大小嵌套很深。</p><h1 id="f09f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">不必要的重新评估</h1><p id="8d34" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">每当父组件中有状态改变时，子组件和链接到它的子组件的整个子树也将重新评估。这意味着，在上面的例子中，每当父组件<code class="fe ms mt mu mv b">App</code>发生状态变化时，<code class="fe ms mt mu mv b">&lt;DemoOutput&gt;</code>都会重新评估。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6a1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当道具改变时，对<code class="fe ms mt mu mv b">DemoOutput</code>组件的重新评估是有意义的。但是如果道具永远不变呢。</p><p id="2b19" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">&lt;DemoOutput show={false} /&gt;</code></p><p id="487a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，<code class="fe ms mt mu mv b">show</code>道具永远不会变。还会重新评估<code class="fe ms mt mu mv b">&lt;DemoOutput&gt;</code>组件吗？是啊！</p><p id="1ab1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我知道这很糟糕，但这就是React的工作方式！</p><p id="dfd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当组件很小时，这不是问题。但是当<code class="fe ms mt mu mv b">&lt;DemoOutput&gt;</code>组件是一个拥有多个子组件的巨大组件时，应用程序的性能会受到影响。</p><p id="d2ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果<code class="fe ms mt mu mv b">DemoOutput</code>中有异步逻辑或者一些内存密集型的操作(比如繁重的排序)，那么会让app真的很慢！这就是为什么我们需要减少组件不必要的重新评估的数量。</p><p id="aa94" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑这个带有控制台语句的新<code class="fe ms mt mu mv b">DemoOutput</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c83f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里的例子中，您将看到每当父组件中有状态改变时，<code class="fe ms mt mu mv b">DemoOutput</code>组件中的控制台语句将运行，即使<code class="fe ms mt mu mv b">show</code>的属性值从未改变并且对<code class="fe ms mt mu mv b">false</code>是静态的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/7b47b6c3142bce604143f51dd6fe92ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5T6kdIenv1Ouhijijx1qWw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nn">每次父组件发生状态变化时，演示都会记录日志，但演示输出的属性不会发生变化</em></p></figure><h1 id="33a8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">React中组件的React.memo()</h1><p id="4f9d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">以上问题可以通过在React上使用<code class="fe ms mt mu mv b">memo()</code> API来解决。<code class="fe ms mt mu mv b">memo</code>有两种形式:</p><ol class=""><li id="045b" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated"><code class="fe ms mt mu mv b">React.memo(Component)</code></li><li id="d72c" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated"><code class="fe ms mt mu mv b">useMemo</code>挂钩</li></ol><p id="4eec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就使得利用“记忆化”原理！</p><blockquote class="nr ns nt"><p id="11ac" class="ky kz nu la b lb lc ju ld le lf jx lg nv li lj lk nw lm ln lo nx lq lr ls lt im bi translated"><em class="it">在计算中，记忆化或记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序。—谷歌</em></p></blockquote><p id="fc23" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了使一个完整的函数被记忆，我们将把函数组件包装在<code class="fe ms mt mu mv b">React.memo</code>中。这样，组件将只在属性值发生实际变化时才进行渲染，从而减少不必要的重新计算次数。</p><p id="64a7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe ms mt mu mv b">&lt;DemoOutput show={false} /&gt;</code>，并在导出时以这种方式包装组件:</p><p id="4967" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">export default React.memo(DemoOutput);</code></p><p id="d493" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经记住了反应成分。现在，父组件的任何状态变化都不会重新评估<code class="fe ms mt mu mv b">DemoOutput</code>组件，直到道具发生变化！</p><p id="20d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查看“演示如何运行”不再在控制台中记录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/5647c1f4c3e87322d84d1e5b6896ac3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aAPY-SGKc83db9MEVzV0rg.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="nn">演示运行不再记录</em></p></figure><p id="480b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要测试所有这些新事物，请使用这里的操场:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nl l"/></div></figure><p id="1d0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">React.memo()</code>将功能组件的属性与它们之前的状态进行比较。只有当传递到<code class="fe ms mt mu mv b">memo()</code>的组件的任何属性值发生变化时，它才会重新执行并重新评估该组件。</p><p id="697b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，它不会重复执行组件，因为传递给组件<code class="fe ms mt mu mv b">DemoOutput</code>的属性<code class="fe ms mt mu mv b">show</code>不会从<code class="fe ms mt mu mv b">false</code>改变。你可以在这里阅读更多关于<code class="fe ms mt mu mv b">React.memo()</code> <a class="ae lu" href="https://dmitripavlutin.com/use-react-memo-wisely/" rel="noopener ugc nofollow" target="_blank">的内容</a>。</p><p id="c622" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是避免整个react组件不必要的重新执行的第一步。</p><h1 id="37c1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">抓住了！</h1><p id="27da" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">尝试使用带有适当值的<code class="fe ms mt mu mv b">React.memo()</code>:</p><ol class=""><li id="9de0" class="mw mx it la b lb lc le lf lh my ll mz lp na lt nb nc nd ne bi translated">原语—布尔、数字等。</li><li id="428b" class="mw mx it la b lb nf le ng lh nh ll ni lp nj lt nb nc nd ne bi translated">抽象—数组、对象、函数</li></ol><p id="fcfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您会惊讶地发现，即使prop值从不改变，当prop是抽象类型时，组件也会被重新计算。例如，组件将重新执行，即使在这些例子中使用了<code class="fe ms mt mu mv b">React.memo( )</code>:</p><p id="efb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">&lt;DemoOutput listItems={[1,2,3,4]} /&gt;</code></p><p id="f55b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">或者</p><p id="61d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">&lt;DemoOutput onClick={onDemoClick} /&gt;</code></p><p id="4948" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于作为属性数据的原始数据类型，它比较</p><p id="574f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">props.show === previous.props.show</code>。</p><p id="8291" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于原语，这将像<code class="fe ms mt mu mv b">false === false</code>将给出<code class="fe ms mt mu mv b">true</code>一样工作，因为在JavaScript中，比较两个原语类型就是这样工作的。</p><p id="63b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于抽象，这将是不同的<code class="fe ms mt mu mv b">[1,2,3,4] === [1,2,3,4]</code>将给出<code class="fe ms mt mu mv b">false</code>，因为比较两个抽象数据类型是通过引用进行比较的，因此它给出false。</p><p id="b807" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">DemoOutput组件将被重新渲染，因为JavaScript中的所有函数都是对象。对象再次被引用比较时给出<code class="fe ms mt mu mv b">false</code>，即使对象值相同！</p><h1 id="f3b6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用useCallback防止函数重新创建</h1><p id="c4cd" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当一个父组件被重新执行，并且它有一个带有作为函数的属性的子组件时，传递给它的函数总是被重新创建。这有重新执行子组件的副作用，即使功能是相同的！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">onDemoClick函数永远不会改变</p></figure><p id="f8f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，为了记忆对象(也称为函数)，我们可以使用<code class="fe ms mt mu mv b">useCallback</code>钩子。传递给这个钩子的函数被React记忆，在重新执行组件时，函数不会被重新创建。</p><p id="dc7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">useCallback</code>的定义与<code class="fe ms mt mu mv b">useEffect</code>类似。它还接受一个依赖数组。</p><h1 id="bd21" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">useCallback为什么需要依赖数组？</h1><p id="2a8b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated"><code class="fe ms mt mu mv b">useCallback</code>需要一个依赖数组，因为JavaScript 中函数的<a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">“闭包”现象。这些函数关闭其环境中可用的值。第一次定义函数时，Javascript锁定函数中使用的变量。下次函数运行时，将使用锁定变量的存储值。</a></p><p id="d20e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些情况下，我们确实需要重新创建函数，因为来自外部的函数所使用的值可能已经改变。因此使用了依赖数组。</p><p id="f5c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们在这里讨论的函数使用了一个<code class="fe ms mt mu mv b">useState</code>变量的值，那么一旦变量发生变化，就需要向函数提供该变量的新值。如果我们在<code class="fe ms mt mu mv b">useCallback</code>中省略了依赖数组的使用，那么在状态改变时，将会重新执行函数，但是我们的函数仍然具有该状态变量的旧值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6b12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只在<code class="fe ms mt mu mv b">DemoOutput</code>组件被包裹在<code class="fe ms mt mu mv b">React.memo(DemoOutput)</code>中时有效。</p><h1 id="91c2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用useMemo()挂钩</h1><p id="1725" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">考虑这个例子，其中我们对来自<code class="fe ms mt mu mv b">DemoOutput</code>组件中父组件的<code class="fe ms mt mu mv b">items</code>数组进行排序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a84c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的组件对道具<code class="fe ms mt mu mv b">items</code>上的输入项目进行排序，然后显示这些项目。</p><p id="8b3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，考虑我们仅仅改变道具上的<code class="fe ms mt mu mv b">title</code>。您将看到<code class="fe ms mt mu mv b">DemoOutput</code>组件重新执行。老实说，应该是这样的。这里所关心的是，即使输入(<code class="fe ms mt mu mv b">props.items</code>)从未改变，整个排序算法每次都要重新运行。</p><p id="a8a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这又是一个性能打击，可以让你的应用程序毫无理由地慢下来！</p><p id="6809" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，让我给你介绍一下<code class="fe ms mt mu mv b"><a class="ae lu" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">useMemo</a></code>钩。</p><p id="098c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe ms mt mu mv b">useMemo</code>挂钩，您可以记忆排序功能和其他对象！因此，将排序函数改为使用钩子，它将只在传递给它的依赖数组的参数改变时运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c1e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将减少浏览器的压力，从而提高应用程序的性能！</p><h1 id="1c75" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">记忆化的缺点</h1><p id="16ec" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这种优化需要额外的成本。当我们将一个组件放入<code class="fe ms mt mu mv b">memo</code>时，React必须存储<code class="fe ms mt mu mv b">props</code>之前的值，这样它才有东西可以比较。这需要额外的时间和内存。因此，我们不为每个组件添加<code class="fe ms mt mu mv b">memo</code>。</p><p id="5187" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">权衡取决于你试图优化的组件树的级别。对于一个长而复杂的组件树分支，使用<code class="fe ms mt mu mv b">memo</code>是有意义的。</p><h1 id="e907" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">组件和状态</h1><p id="84f2" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">一切都归结于状态/道具/上下文，它们控制着屏幕的重新渲染。</p><p id="d1bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当函数组件由于状态改变而重新执行时，我们看不到<code class="fe ms mt mu mv b">useState</code>、<code class="fe ms mt mu mv b">useReducer</code>等钩子React提供的重新初始化。</p><p id="8a78" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为<code class="fe ms mt mu mv b">useState</code>来自React，它会为您进行管理。</p><p id="d56d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如:</p><p id="be98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">const [isLoading, setIsLoading] = useState(false);</code></p><p id="7e4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，</p><p id="31ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">isLoading</code>–状态变量</p><p id="d53c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">setIsLoading</code>–状态变量的设置器</p><p id="aef7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">false</code>–初始值</p><p id="7a1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，React确保<code class="fe ms mt mu mv b">useState</code>和传递的初始值只被考虑一次——组件第一次运行的时候。然后，React会记住初始值属于哪个组件。</p><p id="2393" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果组件从DOM中完全删除，它将重新初始化<code class="fe ms mt mu mv b">useState</code>。它可以是有条件的，也可以是用户退出该组件/页面。</p><h1 id="8fae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">了解状态更新和调度以优化性能</h1><p id="484c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">考虑我们上面的同一个例子</p><p id="48d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">const [isLoading, setIsLoading] = useState(false);</code></p><p id="c3bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">调用setter时，状态不会立即更新。它被安排在晚些时候。对于时间表中的状态更改，顺序始终保持不变。</p><p id="8318" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们在第一次状态更改发生之前再次调用状态设置器来更新状态，第二次状态更改将不会先于第一次更改。秩序保持不变。</p><p id="a397" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我举个例子解释一下:</p><p id="a8c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">考虑一下<code class="fe ms mt mu mv b">App.js</code>中的这段代码。有两个按钮分别与两个功能相关联。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e428" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当<code class="fe ms mt mu mv b">updateLoading</code>被点击时，即使最后的<code class="fe ms mt mu mv b">setIsLoading</code>将状态设置为<code class="fe ms mt mu mv b">true</code>，我们也会得到<code class="fe ms mt mu mv b">false</code>的安慰。该函数完成的状态更改计划在以后进行。当执行了一些延迟/异步任务或者重新呈现函数时，它就会发挥作用。</p><p id="2401" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，当点击<code class="fe ms mt mu mv b">checkLoading</code>按钮时(延迟一段时间后)，会打印<code class="fe ms mt mu mv b">true</code>，因为预定值是<code class="fe ms mt mu mv b">true</code>。</p><blockquote class="nr ns nt"><p id="cd8f" class="ky kz nu la b lb lc ju ld le lf jx lg nv li lj lk nw lm ln lo nx lq lr ls lt im bi translated">这是我们需要理解和掌握的调度原则，因为这是大多数开发人员在学习React时忽略或误解的复杂部分。这也是在<a class="ae lu" href="https://adityatyagi.com/index.php/2022/02/19/how-to-debug-a-react-app/" rel="noopener ugc nofollow" target="_blank">调试</a> React应用程序时必须牢记的原则。–自我提醒</p></blockquote><p id="096d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果有许多状态改变调用，我们将从函数组件的最后一次执行中得到结果。所有状态变化都不会考虑中间状态变化值，而只会返回最后一次函数执行的结果。</p><p id="f73d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是为什么如果你依赖于先前的状态快照，就要使用函数形式来更新状态。</p><p id="e764" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ms mt mu mv b">setIsLoading((prevState) =&gt; !prevState);</code></p><p id="eb38" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，函数形式——对于每一个状态变化，它查看突出的状态，并给出结果。它不使用组件上次执行时的状态。</p><p id="8ec9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">注意</strong>:组件被重新渲染的时间和状态改变被安排的时间是不同的。一次函数执行可以有多次状态改变。</p><p id="6783" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果在一个块中有两个背靠背的状态更新，中间没有任何回调/承诺/时间延迟，将不会导致功能组件的两次重新执行。它将在一次重新执行中批处理这两个文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e658" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所有三个状态变化将被合并成一个功能重新执行。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="871d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">记住以上几点，你不仅可以优化你的React应用程序，还可以获得更好的<a class="ae lu" href="https://adityatyagi.com/index.php/2022/02/19/how-to-debug-a-react-app/" rel="noopener ugc nofollow" target="_blank">调试</a>体验！</p><p id="1159" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望你觉得这是有帮助的和有趣的。万一有什么问题出现，我很乐意回答！</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="0cae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nu">最初发表于</em><a class="ae lu" href="https://adityatyagi.com/index.php/2022/06/07/optimize-performance-in-a-react-applications/" rel="noopener ugc nofollow" target="_blank">T5【adityatyagi.com】</a><em class="nu">。</em></p></div></div>    
</body>
</html>