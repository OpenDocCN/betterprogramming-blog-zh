<html>
<head>
<title>10 Confusing Yet Crucial Swift Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">10个令人困惑但至关重要的Swift功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-confusing-but-crucial-swift-functions-f290dfaaf-f29080bdfaaf?source=collection_archive---------6-----------------------#2020-09-29">https://betterprogramming.pub/10-confusing-but-crucial-swift-functions-f290dfaaf-f29080bdfaaf?source=collection_archive---------6-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b7ce" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">is vs. isKind(of:) vs. isMember(of:)，append() vs. appending()，isEmpty() vs. count==0，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0fecfa50f4dda97a0e97749506ec80cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g971Yvuf28biaiw3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@davidgrdm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·格兰姆金</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="098d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">is vs. isKind(的:)vs. isMember(的:)</h1><p id="4dcf" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">is</code>是类型检查操作符，检查一个实例是否属于某种类型。它可以用来检查<code class="fe mu mv mw mx b">class</code>的实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d17d" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">is</code>操作符也可以用来检查<code class="fe mu mv mw mx b">class</code>的子类的实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8d44" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">is</code>操作符可以用来检查<code class="fe mu mv mw mx b">struct</code>的实例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="48d7" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">isKind(of:)</code>与<code class="fe mu mv mw mx b">class</code>配合使用，采用<code class="fe mu mv mw mx b">NSObjectProtocol</code>。它检查给定值是<code class="fe mu mv mw mx b">class</code>的一个实例还是从那个类继承的任何类的一个实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="ca7e" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">isMember(of:)</code>与<code class="fe mu mv mw mx b">class</code>配合使用，采用<code class="fe mu mv mw mx b">NSObjectProtocol</code>。它检查给定值是否只是<code class="fe mu mv mw mx b">class</code>的一个实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="43cc" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">append()与appending()</h1><p id="09e6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当连接两个<code class="fe mu mv mw mx b">String</code>变量时，我们通常使用两个名称相似的函数:<code class="fe mu mv mw mx b">append()</code>和<code class="fe mu mv mw mx b">appending()</code>。</p><p id="92be" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">append()</code>是将给定字符串追加到该字符串的变异方法。其工作原理与加法<code class="fe mu mv mw mx b">addition assignment operator</code> ( <code class="fe mu mv mw mx b">+=</code>)相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="4644" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">appending()</code>是继承了<code class="fe mu mv mw mx b">NSString</code>的类型。它以与<code class="fe mu mv mw mx b">addition operator</code> ( <code class="fe mu mv mw mx b">+</code>)相同的方式创建一个新的<code class="fe mu mv mw mx b">String</code>值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8fb0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">sort()与sorted()</h1><p id="e2b0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">sort()</code>和<code class="fe mu mv mw mx b">sorted()</code>是Swift <code class="fe mu mv mw mx b">Array</code>的内置方法，可以对数组<code class="fe mu mv mw mx b">Element</code>进行排序。当阵列<code class="fe mu mv mw mx b">Element</code>符合<code class="fe mu mv mw mx b">Comparable</code>协议时，它们可用。默认情况下，元素按升序排序。</p><p id="243f" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">两者的复杂度都是<em class="nf"> O(n log n) </em>，其中<em class="nf"> n </em>是集合的长度。</p><p id="9447" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">sort()</code>改变现有数组，默认情况下按升序排列元素。要按降序对元素进行排序，请将大于号运算符(<code class="fe mu mv mw mx b">&gt;</code>)传递给<code class="fe mu mv mw mx b">sort(by:)</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="8cf5" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">sorted()</code>默认情况下，按升序返回序列中的元素。要按降序对序列中的元素进行排序，请将大于号运算符(<code class="fe mu mv mw mx b">&gt;</code>)传递给<code class="fe mu mv mw mx b">sorted(by:)</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="55d6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">反转()与反转()</h1><p id="c148" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">reverse()</code>和<code class="fe mu mv mw mx b">reversed()</code>与<code class="fe mu mv mw mx b">Element</code>的集合一起工作，其中<code class="fe mu mv mw mx b">Element</code>采用<code class="fe mu mv mw mx b">Comparable</code>协议。集合可以是一个<code class="fe mu mv mw mx b">Array</code>、<code class="fe mu mv mw mx b">String</code>等。</p><p id="e2f6" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">reverse()</code>是将集合中的元素就地反转的突变方法。以下是我们如何使用<code class="fe mu mv mw mx b">reverse()</code>和<code class="fe mu mv mw mx b">Array</code>:</p><p id="72db" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">复杂度为<em class="nf"> O(n) </em>，其中<em class="nf"> n </em>是集合中元素的个数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="1709" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">reversed()</code>用<code class="fe mu mv mw mx b">ReversedCollection</code>实例包装底层集合，它以相反的顺序提供对其元素的访问。它不会为集合分配任何新空间。</p><p id="2225" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">复杂度为<em class="nf"> O(1) </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="0dea" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">随机()与随机()</h1><p id="36c3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">从Swift 4.2开始，<code class="fe mu mv mw mx b">shuffle()</code>和<code class="fe mu mv mw mx b">shuffled()</code>是混洗<code class="fe mu mv mw mx b">Element</code>实例集合的方法。他们随机地对元素重新排序，但是不需要元素采用<code class="fe mu mv mw mx b">Comparable</code>协议。</p><p id="ddfc" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">复杂度为<em class="nf"> O(n) </em>，其中<em class="nf"> n </em>为集合的长度。</p><p id="6325" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">shuffle()</code>对现有集合进行变异。它可以与一组可比较和不可比较的元素一起使用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="a3a7" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">shuffled()</code>返回序列的混洗元素，可以是<code class="fe mu mv mw mx b">String</code>、<code class="fe mu mv mw mx b">Array</code>等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b9e8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">isEmpty() vs. count == 0</h1><p id="e529" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">虽然<code class="fe mu mv mw mx b">isEmpty()</code>和<code class="fe mu mv mw mx b">count == 0</code>都可以用来检查字符串是否为空，但我们建议使用<code class="fe mu mv mw mx b">isEmpty()</code>而不是<code class="fe mu mv mw mx b">.count == 0</code>。</p><p id="0de1" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated"><code class="fe mu mv mw mx b">isEmpty()</code>比较字符串的开始索引和结束索引。</p><p id="383c" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">复杂度为<em class="nf"> O(1) </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="563a" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">而<code class="fe mu mv mw mx b">.count == 0</code>循环字符串以计数所有字符。</p><p id="dc2f" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">复杂度为<em class="nf"> O(n) </em>。</p><p id="bf53" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">当把它们放在一起比较时，<code class="fe mu mv mw mx b">isEmpty()</code>比<code class="fe mu mv mw mx b">.count == 0</code>更有性能，更容易阅读。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="53be" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="f742" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在Swift的不同功能之间进行选择时，思考总是有好处的。了解细节对我们帮助很大。</p><p id="f5c4" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">感谢您的阅读，请在评论中留下您可能有的任何问题。</p><p id="ebdc" class="pw-post-body-paragraph ly lz it ma b mb na ju md me nb jx mg mh nc mj mk ml nd mn mo mp ne mr ms mt im bi translated">上面提到的所有代码都可以在这个<a class="ae ky" href="https://gist.github.com/ericleiyang/872b9b89b5fb4f14b0dc381c95fd3eb7" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p></div></div>    
</body>
</html>