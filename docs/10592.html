<html>
<head>
<title>Building GitHub Apps With Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang构建GitHub应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-github-apps-with-golang-43b27f3e9621?source=collection_archive---------9-----------------------#2022-01-17">https://betterprogramming.pub/building-github-apps-with-golang-43b27f3e9621?source=collection_archive---------9-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7429" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在几分钟内启动并运行您的第一个GitHub应用程序，并使用它来自动化您在GitHub上做的所有事情</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f96ae59aba62e6ff130b10de82d1e361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fq7CgEWgalZYglme00B83A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">背景照片由<a class="ae ky" href="https://unsplash.com/@fakurian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">法库里安设计</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。作者编辑</p></figure><p id="85dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你选择使用GitHub作为你的版本控制系统，那么GitHub应用程序对很多任务都非常有用，包括构建CI/CD、管理存储库、查询统计数据等等。</p><p id="df6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将详细介绍在Go中构建这样一个应用的过程，包括设置GitHub集成、使用GitHub进行认证、监听webhooks、查询GitHub API等等<em class="lv">。</em></p><p id="6509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TL；DR:本文中使用的所有代码都可以在我的<a class="ae ky" href="https://github.com/MartinHeinz/go-github-app" rel="noopener ugc nofollow" target="_blank"> GitHub资源库</a>中找到。</p><h1 id="0f69" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">选择集成类型</h1><p id="c0ba" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们开始构建应用程序之前，我们首先需要决定我们想要使用哪种类型的集成。GitHub提供了3个选项— <em class="lv">个人访问令牌</em>、<em class="lv"> GitHub应用、</em>和<em class="lv"> OAuth应用</em>。这三种方法各有利弊，所以下面是一些需要考虑的基本问题:</p><ul class=""><li id="4023" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><em class="lv">个人访问令牌</em>是最简单的认证形式，适用于您只需要以<em class="lv">身份向GitHub认证</em>的情况。如果您需要代表其他用户，那么这还不够好。</li><li id="7a2a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv"> GitHub应用</em>是开发GitHub集成的首选方式。它们可以由个人用户安装，也可以由整个组织安装。他们可以通过webhooks监听来自GitHub的事件，并在需要时访问API。它们非常强大，但是即使您请求了所有可用的权限，您也无法使用它们来执行用户可以执行的所有操作。</li><li id="19e8" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">OAuth Apps 使用OAuth2代表用户向GitHub认证。这意味着他们可以执行用户可以执行的任何操作。这似乎是最好的选择，但是权限不能提供与GitHub应用程序相同的粒度，而且由于OAuth的原因，设置起来也更加困难。</li></ul><p id="b5a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不确定该选择什么，那么你也可以看看文档中的<a class="ae ky" href="https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps#determining-which-integration-to-build" rel="noopener ugc nofollow" target="_blank">图，这可能会帮助你做出决定。在本文中，我们将使用GitHub App，因为它是一个非常通用的集成，是大多数用例的最佳选择。</a></p><h1 id="5827" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">安装</h1><p id="d928" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们开始编写任何代码之前，我们需要创建和配置GitHub应用程序集成:</p><ul class=""><li id="442b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">作为一个先决条件，我们需要一个隧道，我们将使用它来把GitHub webhooks从互联网传送到我们本地运行的应用程序。您需要安装带有<code class="fe nh ni nj nk b">npm install -g localtunnel</code>的<code class="fe nh ni nj nk b">localtunnel</code>工具，并开始使用<code class="fe nh ni nj nk b">lt --port 8080</code>转发到您的本地主机。</li><li id="fc22" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">接下来，我们需要去<a class="ae ky" href="https://github.com/settings/apps/new" rel="noopener ugc nofollow" target="_blank">https://github.com/settings/apps/new</a>配置集成。按如下方式填写字段:</li></ul><p id="2d87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">首页网址</em>:您的<code class="fe nh ni nj nk b">localtunnel</code>网址</p><p id="fc5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">网页挂钩网址</em> : <code class="fe nh ni nj nk b">https://&lt;LOCALTUNNEL_URL&gt;/api/v1/github/payload</code></p><p id="c806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Webhook秘密:你想要的任何秘密(并保存它)</p><p id="0517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">存储库权限</em>:内容、元数据(只读)</p><p id="0636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">订阅事件</em>:推送、发布</p><ul class=""><li id="ee09" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">创建应用程序后，您将看到集成的设置页面。记下<em class="lv">应用ID </em>，生成私钥并下载。</li><li id="f4c3" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">接下来，你还需要安装该应用程序，以便与你的GitHub帐户配合使用。转到<em class="lv">安装应用程序</em>选项卡，并将其安装到您的帐户中。</li><li id="8102" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我们还需要<code class="fe nh ni nj nk b">installation</code> <em class="lv"> ID </em>，我们可以通过转到<em class="lv">高级</em>选项卡并单击列表中的最新交付来找到它，记下请求有效负载中的安装ID，它应该位于<code class="fe nh ni nj nk b">{"installation": {"id": &lt;...&gt;}}</code>中。</li></ul><p id="c19f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你在某个地方迷路了，请参考指南<a class="ae ky" href="https://docs.github.com/en/developers/apps/getting-started-with-apps/setting-up-your-development-environment-to-create-a-github-app" rel="noopener ugc nofollow" target="_blank"> GitHub文档</a>，它显示了你可以在哪里找到每个值。</p><p id="f3b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成后，我们就配置好了集成，并保存了所有重要的值。在我们开始接收事件和发出API请求之前，我们需要启动并运行Go服务器，所以让我们开始编码吧！</p><h1 id="b020" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">构建应用程序</h1><p id="73d2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了构建Go应用程序，我们将使用我在<a class="ae ky" href="https://github.com/MartinHeinz/go-github-app" rel="noopener ugc nofollow" target="_blank">https://github.com/MartinHeinz/go-github-app</a>中准备的模板。这个应用程序已经可以作为GitHub应用程序使用了，它所缺少的，是我们在上一节的设置过程中保存的几个变量。该存储库包含一个方便的脚本，您可以使用它来填充所有值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面几节将带你浏览代码，但如果你是住院病人，那么这个应用程序是不错的。您可以使用<code class="fe nh ni nj nk b">make build</code>构建应用程序的二进制文件，或者使用<code class="fe nh ni nj nk b">make container</code>创建应用程序的容器化版本。</p><p id="bd13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要处理的代码的第一部分是认证。使用<code class="fe nh ni nj nk b">ghinstallation</code>包完成，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="caaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数在<em class="lv"> Gin </em>服务器启动期间从<code class="fe nh ni nj nk b">main.go</code>调用，获取应用ID、安装ID和私钥来创建GitHub客户端，然后存储在<code class="fe nh ni nj nk b">config.Config.GitHubClient</code>的全局配置中。稍后我们将使用这个客户端与GitHub API对话。</p><p id="8e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了GitHub客户端，我们还需要设置服务器路由，以便能够接收有效负载:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="45e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先是我们在GitHub集成设置中使用的<code class="fe nh ni nj nk b">http://.../api/v1/github/payload</code>处的有效负载路径。该路径与<code class="fe nh ni nj nk b">webhooks.ConsumeEvent</code>函数相关联，该函数将从GitHub接收所有事件。</p><p id="02bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于安全原因，<code class="fe nh ni nj nk b">webhooks.ConsumeEvent</code>函数做的第一件事是验证请求签名，以确保GitHub确实是生成事件的服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2cca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它通过使用webhook secret作为密钥计算有效负载的HMAC摘要来执行验证，然后将其与请求的<code class="fe nh ni nj nk b">X-Hub-Signature-256</code>报头中的值进行比较。如果签名匹配，那么我们可以继续消费单个事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4e40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，我们从<code class="fe nh ni nj nk b">X-GitHub-Event</code>头中提取事件类型，并遍历我们的应用程序支持的事件列表。</p><p id="99ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，它们是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果事件名匹配其中一个选项，我们继续将JSON有效负载加载到一个<code class="fe nh ni nj nk b">EventPayload</code>结构中，这个结构在<code class="fe nh ni nj nk b"><a class="ae ky" href="https://github.com/MartinHeinz/go-github-app/blob/master/cmd/app/webhooks/models.go" rel="noopener ugc nofollow" target="_blank">cmd/app/webhook/models.go</a></code>中定义。这只是一个使用<a class="ae ky" href="https://mholt.github.io/json-to-go/" rel="noopener ugc nofollow" target="_blank">https://mholt.github.io/json-to-go/</a>生成的结构，去掉了不必要的字段。</p><p id="f32c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，该有效负载被发送到处理相应事件类型的函数，该函数为以下类型之一:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，对于<em class="lv">推送</em>事件，可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下——检查接收存储库和分支，并枚举这个单个推送中包含的提交。例如，您可以在这里将数据插入到数据库中，或者发送一些关于事件的通知。</p><p id="2213" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经准备好了代码，但是我们如何测试它呢？为此，我们将使用您已经运行的隧道，假设您遵循了前面几节中的步骤。</p><p id="2b05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们还需要启动服务器，您可以通过运行<code class="fe nh ni nj nk b">make container</code>来构建容器化的应用程序，然后运行<code class="fe nh ni nj nk b">make run</code>来启动监听端口<code class="fe nh ni nj nk b">8080</code>的容器。</p><p id="d6e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以简单地推送至您的一个存储库，您应该会在服务器日志中看到类似的输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9f2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免总是将虚拟变更推送到存储库，您可以从GitHub应用程序配置中的高级选项卡重新交付有效负载。在该选项卡上，您会发现以前的请求列表，只需选择一个并点击<em class="lv">重新交付</em>按钮。</p><h1 id="b7d6" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">进行API调用</h1><p id="e7b4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">GitHub应用以webhooks为中心，你可以订阅和收听，但你也可以使用任何GitHub REST/GraphQL API端点，假设你请求了必要的权限。</p><p id="6d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用API而不是push事件非常有用，例如，在创建文件、分析批量数据或查询无法从webhooks接收的数据时。</p><p id="5a17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示如何做到这一点，我们将检索指定存储库的拉请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2b04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数有两个参数——<code class="fe nh ni nj nk b">owner</code>和<code class="fe nh ni nj nk b">repo</code>——传递给GitHub客户端实例的<code class="fe nh ni nj nk b">PullRequests.List(...)</code>函数。除此之外，我们还提供了<code class="fe nh ni nj nk b">PullRequestListOptions</code> struct来指定我们只对状态设置为<code class="fe nh ni nj nk b">open</code>的pull请求感兴趣。然后，我们迭代返回的PRs，并累积我们在响应中返回的所有标题。</p><p id="fd78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述函数驻留在<code class="fe nh ni nj nk b">main.go</code>中指定的<code class="fe nh ni nj nk b">.../api/v1/github/pullrequests/:owner/:repo</code>路径上，因此我们可以像这样查询它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="be93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们希望返回大量数据的情况下，如上所示查询API可能并不理想。在这些情况下，我们可以利用<em class="lv">分页</em>来避免达到速率限制。</p><p id="dc32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nh ni nj nk b"><a class="ae ky" href="https://github.com/MartinHeinz/go-github-app/blob/master/cmd/app/apis/github.go" rel="noopener ugc nofollow" target="_blank">cmd/app/apis/github.go</a></code>中可以找到一个名为<code class="fe nh ni nj nk b">GetPullRequestsPaginated</code>的函数，它执行与<code class="fe nh ni nj nk b">GetPullRequests</code>相同的任务，并增加了用于指定页面大小的<code class="fe nh ni nj nk b">page</code>参数。</p><h1 id="13d8" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">写作测试</h1><p id="dd27" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">到目前为止，我们一直在用<code class="fe nh ni nj nk b">localtunnel</code>测试该应用，这对于针对实时API的快速特别测试来说很好，但它不能取代适当的单元测试。要为这个应用程序编写单元测试，我们需要模拟API以避免依赖外部服务。为此，我们可以使用<code class="fe nh ni nj nk b"><a class="ae ky" href="https://github.com/migueleliasweb/go-github-mock" rel="noopener ugc nofollow" target="_blank">go-github-mock</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="613b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个测试从定义一个模拟客户端开始，它将被用来代替一个普通的GitHub客户端。我们给它一个拉请求列表，当调用<code class="fe nh ni nj nk b">PullRequests.List</code>时将返回这些请求。然后，我们创建测试上下文，其中包含我们想要传递给被测函数的参数，然后我们调用该函数。最后，我们读取响应体并断言只返回了具有<code class="fe nh ni nj nk b">open</code>状态的PRs。</p><p id="2afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关更多测试，请参见完整的<a class="ae ky" href="https://github.com/MartinHeinz/go-github-app/blob/master/cmd/app/apis/github_test.go" rel="noopener ugc nofollow" target="_blank">源代码</a>，其中包括分页测试以及来自GitHub API的错误处理的示例。</p><p id="7d2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当测试我们的webhook方法时，我们不需要使用模拟客户端，因为我们正在处理基本的API请求。此类测试的例子包括通用API测试设置可以在<code class="fe nh ni nj nk b"><a class="ae ky" href="https://github.com/MartinHeinz/go-github-app/blob/master/cmd/app/webhooks/webhook_test.go" rel="noopener ugc nofollow" target="_blank">cmd/app/webhooks/github_test.go</a></code>中找到。</p><h1 id="83c5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="e6a3" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我试图让您快速浏览一下这两个GitHub应用程序，以及包含示例Go GitHub项目的<a class="ae ky" href="https://github.com/MartinHeinz/go-github-app/" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="071d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，我没有涵盖所有内容，Go client包提供了更多功能，要查看您可以使用它执行的所有操作，我建议浏览一下<a class="ae ky" href="https://pkg.go.dev/github.com/google/go-github/v41/github#pkg-index" rel="noopener ugc nofollow" target="_blank">文档索引</a>以及查看源代码本身，其中列出了GitHub API链接和每个函数。比如像前面展示的<code class="fe nh ni nj nk b">PullRequests.List</code> <a class="ae ky" href="https://github.com/google/go-github/blob/master/github/pulls.go#L147" rel="noopener ugc nofollow" target="_blank">这里的</a>。</p><p id="76a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于存储库，您可能还想看看更多的东西，包括Makefile目标、<a class="ae ky" href="https://github.com/MartinHeinz/go-github-app/tree/master/.github/workflows" rel="noopener ugc nofollow" target="_blank"> CI/CD </a>或额外的测试。如果您有任何反馈或建议，请随意创建一个问题，或者只要对您有帮助就开始讨论。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><div class="kj kk kl km gt nu"><a href="https://towardsdatascience.com/all-the-things-you-can-do-with-github-api-and-python-f01790fca131" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">你可以用GitHub API和Python做的所有事情</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">GitHub REST API允许您管理问题、分支、回购、提交等等，所以让我们看看您如何使用…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">towardsdatascience.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ks nu"/></div></div></a></div><pre class="kj kk kl km gt oj nk ok ol aw om bi"><span id="052e" class="on lx it nk b gy oo op l oq or"><strong class="nk iu">Want to Connect?</strong></span><span id="bcde" class="on lx it nk b gy os op l oq or">This article was originally posted at <a class="ae ky" href="https://martinheinz.dev/blog/65?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_65" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a>.</span></pre></div></div>    
</body>
</html>