<html>
<head>
<title>Spotify OAuth2 Authentication in a NestJS Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS应用程序中的Spotify OAuth2身份验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/spotify-oauth2-authentication-in-a-nestjs-application-307b25b2e49e?source=collection_archive---------3-----------------------#2022-03-15">https://betterprogramming.pub/spotify-oauth2-authentication-in-a-nestjs-application-307b25b2e49e?source=collection_archive---------3-----------------------#2022-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f48" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将Spotify Web API的OAuth2授权代码流策略集成到具有TypeScript和NestJS后端应用程序的NodeJS中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca37077db3665baa943326ed2ce43daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TQxbsklckR4fHg5M"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">亚历山大·沙托夫在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="12b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">构建API时，应用程序最重要的部分之一是用户的安全性和身份验证。大多数框架都提供了一些关于如何实现不同身份验证策略的指南。例如，NestJS在其<a class="ae kv" href="https://docs.nestjs.com/security/authentication" rel="noopener ugc nofollow" target="_blank">官方文件</a>中提出了JWT战略。</p><p id="ec72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，一种广泛传播的身份验证策略是OAuth2方法，通常用于第三方服务，如脸书、谷歌和Spotify帐户，它提供了一种使用这些服务中的现有帐户来验证用户身份的方法，甚至可以代表经过验证的用户与这些服务进行交互。</p><p id="d205" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于没有将这种类型的身份验证与NestJS集成的官方文档，并且开发文章通常专注于Google和脸书的集成，本文提出了一种替代方案，使用<a class="ae kv" href="https://github.com/jaredhanson/passport" rel="noopener ugc nofollow" target="_blank"> Passport </a>身份验证中间件和<a class="ae kv" href="https://github.com/JMPerez/passport-spotify" rel="noopener ugc nofollow" target="_blank"> passport-spotify </a>策略将<a class="ae kv" href="https://developer.spotify.com/documentation/general/guides/authorization/code-flow/" rel="noopener ugc nofollow" target="_blank"> Spotify授权代码流</a>与<a class="ae kv" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>集成。</p><h1 id="08e5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">要求</h1><p id="cc66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">本文重点介绍将OAuth2策略用于Spotify并与NestJS应用程序集成的过程，因此，在本文描述的过程之前，需要满足以下要求:</p><ul class=""><li id="e8d9" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">一个NestJS应用程序以其基本结构启动。对于这部分，遵循<a class="ae kv" href="https://docs.nestjs.com/first-steps#setup" rel="noopener ugc nofollow" target="_blank"> NestJS文档</a>中的快速设置指南就足够了；</li><li id="7509" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">一个可以访问Spotify开发者仪表盘的Spotify帐户，以及一个使用其<code class="fe nd ne nf ng b">CLIENT ID</code>和<code class="fe nd ne nf ng b">CLIENT SECRET</code>凭据注册的应用程序。遵循关于如何使用Spotify API的循序渐进的官方文档<a class="ae kv" href="https://developer.spotify.com/documentation/web-api/quick-start/" rel="noopener ugc nofollow" target="_blank">对本文来说就足够了。</a></li></ul><p id="5789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不熟悉OAuth2授权代码流程，请查看Spotify Web API文档提供的<a class="ae kv" href="https://developer.spotify.com/documentation/general/guides/authorization/code-flow/" rel="noopener ugc nofollow" target="_blank">指南。</a></p><h1 id="56e7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">授权文件夹</h1><p id="e3ba" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">准备好NestJS应用程序后，必须使用以下命令创建一个<code class="fe nd ne nf ng b">auth </code>资源——考虑到机器中已经安装了<a class="ae kv" href="https://docs.nestjs.com/cli/overview" rel="noopener ugc nofollow" target="_blank"> Nest CLI </a>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="336b" class="nl lt iq ng b gy nm nn l no np">nest g mo auth<br/>nest g s auth --no-spec<br/>nest g co auth --no-spec</span></pre><p id="00fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些命令创建一个<code class="fe nd ne nf ng b">auth </code>文件夹，其中包含基本模块、服务和控制器文件，但不包含任何文件。规格文件。一切就绪后，文件夹结构应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1141b480240d689259bc2c044589d8ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*CgDM2UhPMzwIL55pYxL7QA.png"/></div></figure><p id="bb8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，必须安装以下依赖项:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="6fb4" class="nl lt iq ng b gy nm nn l no np">npm install @nestjs/passport @nestjs/jwt passport passport-jwt passport-spotify</span><span id="aaa7" class="nl lt iq ng b gy nr nn l no np">npm install -D @types/passport-jwt @types/passport-spotify</span></pre><p id="3688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在开始，在身份验证方面，有3个功能必须在应用程序中可用:</p><ol class=""><li id="444a" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr ns mv mw mx bi translated">使用Spotify OAuth2授权代码流的用户登录；</li><li id="6ae0" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr ns mv mw mx bi translated">从Spotify检索用户信息并生成JWT；</li><li id="0a19" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr ns mv mw mx bi translated">使用JWT策略，这样就不需要每次在会话期间需要用户验证时都连接Spotify OAuth2服务器。</li></ol><h1 id="e71c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">路线</h1><p id="303b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于之前描述的第一和第二功能，需要有一个带有路线<code class="fe nd ne nf ng b">/login</code>和<code class="fe nd ne nf ng b">/redirect</code>的控制器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述代码包含以下内容:</p><ul class=""><li id="7d29" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">两条路线<code class="fe nd ne nf ng b">/login</code>和<code class="fe nd ne nf ng b">/redirect</code>都由<code class="fe nd ne nf ng b">SpotifyOauthGuard</code> <a class="ae kv" href="https://docs.nestjs.com/guards" rel="noopener ugc nofollow" target="_blank">自定义守卫</a>守卫，该守卫执行稍后将描述的<code class="fe nd ne nf ng b">passport-spotify</code>策略；</li><li id="b7a1" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">login </code>方法/路由是用户将访问以启动身份验证的端点；</li><li id="5c6b" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">spotifyAuthRedirect</code>方法('/redirect' route)是用户成功登录后Spotify OAuth2服务将被重定向到的URL</li><li id="4581" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">spotifyAuthRedirect</code>方法:检索来自位于<code class="fe nd ne nf ng b">req.user</code>属性的Spotify的用户信息——如果没有信息，意味着认证没有执行或失败，该方法将请求再次重定向到登录路由——将<code class="fe nd ne nf ng b">user</code> req属性设置为未定义(因为它将被进一步定义为JWT有效载荷),用它生成JWT，并返回用户信息和Spotify令牌，应用程序可以使用这些信息和令牌根据定义的范围使用用户信息访问Spotify Web API中的路由。</li></ul><h1 id="151f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Spotify OAuth2战略</h1><p id="92f9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当使用内置的passport策略时，必须创建一个自定义防护及其相应的策略。<code class="fe nd ne nf ng b">SpotifyOauthGuard</code>只是一个扩展了<code class="fe nd ne nf ng b">AuthGuard </code>类的类，所以，在创建了/guards文件夹后，在里面的<code class="fe nd ne nf ng b">SpotifyOauthGuard</code>应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="488b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，命名的<code class="fe nd ne nf ng b">spotify</code>策略必须在/strategies文件夹中创建:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6a86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码负责连接Spotify OAuth2服务，并管理应用程序的重定向。流程是:</p><ul class=""><li id="06ac" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">SpotifyOauthStrategy</code>类使用<a class="ae kv" href="https://github.com/JMPerez/passport-spotify" rel="noopener ugc nofollow" target="_blank"> passport-spotify </a> lib提供的策略扩展了<code class="fe nd ne nf ng b">PassportStrategy</code>，并将其命名为‘Spotify ’,以便<code class="fe nd ne nf ng b">SpotifyOauthGuard</code>能够识别它；</li><li id="77c1" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">构造器方法使用<code class="fe nd ne nf ng b">super </code>方法调用<a class="ae kv" href="https://github.com/JMPerez/passport-spotify" rel="noopener ugc nofollow" target="_blank"> passport-spotify </a> <code class="fe nd ne nf ng b">Strategy </code>构造器方法，传递spotify应用凭证<code class="fe nd ne nf ng b">CLIENT_ID</code>和<code class="fe nd ne nf ng b">CLIENT_SECRET</code>(保存在。env vars，因为它们不得公开暴露)，<a class="ae kv" href="https://developer.spotify.com/documentation/web-api/quick-start/" rel="noopener ugc nofollow" target="_blank">这里更好地描述</a>，回调URL，它与auth.controller.ts中定义的路由相同，'/redirect '，以及应用程序与用户信息交互所需的范围；</li><li id="9b96" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated"><code class="fe nd ne nf ng b">super</code>方法还有一个回调函数，一旦用户的登录过程成功，在它被重定向到应用程序之前，这个函数就会被调用。该函数向将对“/redirect”路由做出的请求添加以下属性:user(包含用户的配置文件信息)和authInfo(包含<code class="fe nd ne nf ng b">refreshToken</code>、<code class="fe nd ne nf ng b">accessToken</code>和<code class="fe nd ne nf ng b">expires_in</code>信息)。</li></ul><h1 id="823a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">重定向和JWT一代</h1><p id="8331" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一旦实现了该策略，用户将被重定向到“/redirect”URL，并且在<code class="fe nd ne nf ng b">auth.controller.ts</code>(前面已经介绍过)中，<code class="fe nd ne nf ng b">spotifyAuthRedirect</code>方法将拦截req对象，提取<code class="fe nd ne nf ng b">user</code>和<code class="fe nd ne nf ng b">authInfo</code>属性，并将<code class="fe nd ne nf ng b">user</code>传递给<code class="fe nd ne nf ng b">authService</code>。利用用户的信息，<code class="fe nd ne nf ng b">AuthService </code>类中的<code class="fe nd ne nf ng b">login</code>方法负责生成JWT。auth.service.ts应如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="c952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在<code class="fe nd ne nf ng b">auth.service.ts</code>中，<code class="fe nd ne nf ng b">/redirect</code>路由返回一个包含<code class="fe nd ne nf ng b">authInfo</code>和用户属性的对象，以及一个与JWT连接的设置为“承载”的报头认证。</p><h1 id="511b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">JWT战略</h1><p id="7735" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这部分认证基本上如<a class="ae kv" href="https://docs.nestjs.com/security/authentication#jwt-functionality" rel="noopener ugc nofollow" target="_blank">官方NestJS文档</a>中所述。对于这一部分，需要在您的<code class="fe nd ne nf ng b">.env</code>变量中定义一个<code class="fe nd ne nf ng b">JWT_SECRET</code>，它是一个字符串，用于生成和加密/解密应用程序生成的JWT，不得公开暴露。类似于Spotify的策略，有必要创建一个<code class="fe nd ne nf ng b">JwtAuthGuard</code>类来扩展内置的passport AuthGuard和一个相应的名为“jwt”的类。在<code class="fe nd ne nf ng b">/guards</code>文件夹中，创建如下<code class="fe nd ne nf ng b">jwt-auth.guard.ts</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a317" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">/strategies文件夹中相应的策略应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码是在用<code class="fe nd ne nf ng b">JwtAuthGuard</code>修饰一条路线时执行的。<code class="fe nd ne nf ng b">super()</code>方法提取由对受保护路由的请求提供的JWT，用提供的<code class="fe nd ne nf ng b">JWT_SECRET</code>解密它，并将一个<code class="fe nd ne nf ng b">user</code>属性插入到req对象中，该对象包含先前插入到JWT有效负载中的信息。</p><p id="7e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要强调的是，插入的<code class="fe nd ne nf ng b">user</code>属性不同于<code class="fe nd ne nf ng b">spotify-strategy</code>插入到<code class="fe nd ne nf ng b">req</code>对象中的属性，这就是为什么在<code class="fe nd ne nf ng b">spotifyAuthRedirect</code>方法中，在使用jwt策略登录之前<code class="fe nd ne nf ng b">req.user</code>属性被设置为未定义的原因。</p><p id="6a7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，任何认证路由都可以用<code class="fe nd ne nf ng b">JwtAuthGuard</code>来修饰，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="f953" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">授权模块和应用模块配置</h1><p id="237b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一切就绪后，就该配置所有模块的实例化了。<code class="fe nd ne nf ng b">AuthModule</code>类应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="65e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">auth.module.ts</code>文件定义了auth资源的所有提供者，并在<code class="fe nd ne nf ng b">JwtModule</code>的实例化过程中注册了<code class="fe nd ne nf ng b">JWT_SECRET</code>及其到期时间，这里定义为3600秒(1小时)。</p><p id="fd9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，AppModule应该类似于:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">app.module.ts</code>实例化应用程序的所有模块，包括<code class="fe nd ne nf ng b">ConfigModule</code>，这是使用流程中描述的所有env变量所必需的。</p><p id="e0c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序的文件夹和文件的最终状态应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f4e71cc1e386b88acf003ffa53e0f306.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*-jHB2X58YhJz2-OJKQQ3zQ.png"/></div></figure><h1 id="1196" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="00c7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">OAuth2是一种将应用程序与外部应用程序(如广泛的社交媒体服务)集成的有趣方式，它利用一种简单的方式来登录用户，并向用户提供与这些应用程序相关的功能。</p><p id="9c47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管NestJS没有提供进行这种集成的官方方法，但是有许多开源项目旨在简化这种认证方法，比如本文中描述和使用的方法。</p></div></div>    
</body>
</html>