<html>
<head>
<title>What Are Svelte Stores and How to Use Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是苗条商店，如何使用它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-are-svelte-stores-and-how-to-use-them-a4963968ee89?source=collection_archive---------1-----------------------#2022-05-08">https://betterprogramming.pub/what-are-svelte-stores-and-how-to-use-them-a4963968ee89?source=collection_archive---------1-----------------------#2022-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bda0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本教程中，我们将通过一个简单的例子来了解什么是苗条商店以及如何使用它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/22f74e9c4e3336f7e1254bf914e926da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCTN0d2XVRAcmn3Uj4v42Q.png"/></div></div></figure><p id="a25a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最近一直在开发我的个人项目，用Svelte代替通常的React，我真的很喜欢它。它有很多很棒的功能，感觉很相似，足以让我舒服地使用它，但同时感觉更轻更简单，但仍然足够强大，可以做我需要的事情。我特别喜欢Svelte的一个特点是它的商店系统。</p><h1 id="d523" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">什么是苗条商店？</h1><p id="84c0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一个苗条的商店允许应用程序在许多组件之间共享数据，而不需要在它之前通过其他组件传递数据。如果一个远嵌套的组件需要一些数据，但它上面的组件都不需要，这将非常有用。在这种情况下，使用存储可以避免将数据传递给一堆对数据没有用处的组件，以便这个嵌套的组件可以使用它。使用这样的存储使代码更简单，意味着我们不必在数据经过所有这些组件时跟踪这些数据。</p><p id="44a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您熟悉React，这可能类似于Redux或React上下文。不过，我喜欢苗条商店的原因是，它感觉更简单、更容易使用。</p><p id="cd3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">存储也是反应性的，这意味着如果存储值在任何地方被更新，使用该存储的所有组件都将反映更新的值。</p><h1 id="5f28" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">商店如何运作</h1><p id="aae1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我提到存储是反应式的，但这并不意味着任何组件都可以设置存储的值。在组件能够读取或写入存储之前，它必须订阅该存储。所有存储都必须有一个subscribe方法，当它的任何值发生变化时，该方法将从外部(在组件中)更新它的值。</p><p id="2a67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一个使用subscribe方法的商店示例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/10733c37194e50ecd769feed4fbe3ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*e498aswZO-PHBrBluYEOwA.png"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">项目目录</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">index.svelte</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">这是我们的存储被制造和初始化的地方</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/5216eea940bad06b0b186c5b3564ef14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/0*u1vJf7S2cG7A2qbk"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">网页结果</p></figure><h1 id="7687" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">苗条商店速记美元</h1><p id="28e1" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">虽然这是一个简单的例子，但我相信您可以看到当需要与多个组件共享大量数据时，这是多么有用，这些组件不一定彼此相关(比如用户名)。然而，手动订阅每个想要使用的组件中想要使用的每个存储可能会很烦人。</p><p id="40c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，Svelte为我们提供了自动订阅和退订商店的快捷方式！</p><p id="a642" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">继续将<code class="fe ms mt mu mv b">StoreExample.svelte</code> <em class="mw"> </em>切换到如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">使用$速记的StoreExample.svelte</p></figure><p id="0bcb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用这种简写方式更简单，在产生相同结果的同时节省了我们几行代码。通过使用Svelte store简写$,您可以像对待任何其他JavaScript对象一样对待store。</p><h1 id="467e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">各种苗条的商店</h1><p id="d0ed" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有三种苗条的存储:可写的、可读的和派生的。</p><h2 id="6a3b" class="mx lo iq bd lp my mz dn lt na nb dp lx la nc nd lz le ne nf mb li ng nh md ni bi translated">可写商店</h2><p id="85ea" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">可写存储允许其订户修改其数据。假设您使用简写，组件可以像任何其他Javascript对象一样修改存储值。</p><p id="0788" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者，您可以使用<code class="fe ms mt mu mv b"><a class="ae nj" href="https://svelte.dev/tutorial/writable-stores" rel="noopener ugc nofollow" target="_blank">set()</a></code>和<code class="fe ms mt mu mv b"><a class="ae nj" href="https://svelte.dev/tutorial/writable-stores" rel="noopener ugc nofollow" target="_blank">update()</a></code>方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">StoreExample.svelte使用store.set()方法</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/ace251430491e1c0ed325e07799b6131.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/0*Pv3j-q5Z5Zisq9Yq"/></div></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">结果</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">StoreExample.svelte —使用$速记设置商店值</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9b2e907010d927fa44ed1c428a50a1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/0*kqZr-WLq4K5-yYkD"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">结果</p></figure><p id="af9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如您所看到的，更新商店数据是非常容易的，这些更改不仅适用于进行更改的组件，还适用于订阅商店的任何组件。</p><h2 id="0689" class="mx lo iq bd lp my mz dn lt na nb dp lx la nc nd lz le ne nf mb li ng nh md ni bi translated">可读存储</h2><p id="1a38" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">可读存储的数据不能被任何订阅者编辑。这意味着可读存储的所有数据必须在创建时初始化。这对于像当前日期这样的数据可能很有用，因为对于当前日期，不需要更改数据，但是多个组件可能仍然需要它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">可读存储— DateStore.js</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">使用可读存储的StoreExample.svelte</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/0d2bfd22ecbbc21ed1efb34565950857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/0*j9SkT6bE5fwjkeyT"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">结果</p></figure><h2 id="04e7" class="mx lo iq bd lp my mz dn lt na nb dp lx la nc nd lz le ne nf mb li ng nh md ni bi translated">派生存储</h2><p id="6b2c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">顾名思义，派生存储是从另一个存储派生出来的。当从其派生的存储更新时，派生存储的值也将更新。派生存储基本上只是可读存储，但它们的值至少部分来自其他地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">衍生商店— DatePlusWeekStore.js</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">使用派生存储的StoreExample.svelte</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/438f739c4734bafd93d6b94c8344baf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*ueZt0kZg7Os3xdYmeOe9hg.png"/></div><p class="ml mm gj gh gi mn mo bd b be z dk translated">结果</p></figure><h1 id="5a8e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">摘要</h1><p id="eb04" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">再看一遍，苗条商店基本上只是反应式的Javascript对象，可以导入到多个组件中，彼此都不相关。</p><p id="949b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里使用的例子非常简单，很可能您将使用瘦存储来存储更复杂的数据，但是概念将保持不变。我希望这种对苗条商店的新理解能帮助你创建令人惊奇的网站/应用程序！</p></div></div>    
</body>
</html>