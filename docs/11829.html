<html>
<head>
<title>Building a Simple Spring-like Dependency Injection Framework in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java构建一个简单的类似Spring的依赖注入框架</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-simple-spring-like-dependency-injection-framework-in-java-5d91254d2dbf?source=collection_archive---------3-----------------------#2022-04-20">https://betterprogramming.pub/building-a-simple-spring-like-dependency-injection-framework-in-java-5d91254d2dbf?source=collection_archive---------3-----------------------#2022-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bb21" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">结合反射和注释来构建强大的库和框架</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/16dbbb99d55d6397dfa780142aa20ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wB9-EseMDsLotQ35igiIeQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ourlifeinpixels?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a>上的我们的生活像素</p></figure><p id="f1e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像Spring，Hibernate等框架。让java程序员的生活变得简单。这些框架给了我们很多超能力。例如，你可以在spring中用一个<code class="fe ls lt lu lv b">Autowired</code>注释神奇地注入对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0507" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用hibernate，您可以简单地在关系数据库中持久化对象，这是一个完全不同的范例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个魔法的背后是什么？</p><p id="d76e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，所有这些都是通过java反射和注释实现的。</p><p id="bed7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像Intellij Idea和Eclipse这样的ide在幕后使用反射来为我们提供所有的智能。Spring、Hibernate和Lombok等框架也使用反射和注释来加速和简化Java编程。</p><p id="5714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将拿出我们的魔棒，学习如何施咒凭空构建对象——我们将在反射和注释的帮助下创建一个类似Spring的迷你版依赖注入框架。</p><p id="2cc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目的是让你习惯于反射和注释，并且给你足够的实践理解来自己构建这种框架。给你的下一个项目加点魔法。</p><h1 id="3df1" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">反思与注释初级读本</h1><h2 id="1a61" class="mq lz iq bd ma mr ms dn me mt mu dp mi lf mv mw mk lj mx my mm ln mz na mo nb bi translated">反思:</h2><p id="1a21" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">Java反射API允许我们检查和改变类、接口、字段和方法的运行时属性。这些都捆绑在<code class="fe ls lt lu lv b"><a class="ae kv" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/reflect/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.lang.reflect</a></code>包中。</p><p id="46a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">反思的中坚力量是<code class="fe ls lt lu lv b">java.lang.Class</code>。正在运行的Java应用程序中的所有类和接口都有一个该类的对应实例。<code class="fe ls lt lu lv b">Class </code>当类被加载到JVM中时，实例被自动构造。</p><p id="fbfe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe ls lt lu lv b">Class</code>实例有多种方法。</p><p id="238d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用<code class="fe ls lt lu lv b">forName()</code>类的静态方法。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="5c0c" class="mq lz iq lv b gy nl nm l nn no">Class&lt;?&gt; clazz = Class.forName("java.lang.String")</span></pre><p id="ba44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方式是通过调用对象上的<code class="fe ls lt lu lv b">getClass()</code>方法。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="7a6d" class="mq lz iq lv b gy nl nm l nn no">Class&lt;?&gt; clazz = object.getClass()</span></pre><p id="1077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类对象提供了多种方法来访问类的运行时信息。这里有一些例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不可能在这篇博客中涵盖所有的功能。你可以参考这里了解更多:<a class="ae kv" href="https://www.baeldung.com/java-reflection" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-reflection</a>。</p><h2 id="152f" class="mq lz iq bd ma mr ms dn me mt mu dp mi lf mv mw mk lj mx my mm ln mz na mo nb bi translated"><strong class="ak">注释:</strong></h2><p id="6a19" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">注释用于定义类、方法、字段等的附加元数据信息。，可以在运行时通过反射读取。注释本身对程序的执行方式没有任何影响。</p><p id="e049" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Java中有一些内置的注释。一些例子。我们还可以创建自定义注释。在下一节中，我们将看到如何使用自定义注释和反射来编写强大的代码。</p><h1 id="26a4" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">搭建框架</strong></h1><p id="d7d7" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这里有一个简单的例子让我们开始。我们有一个<code class="fe ls lt lu lv b">OrderService</code>类，它提供一个API来使用订单id获取订单细节。<code class="fe ls lt lu lv b">OrderService</code>在内部使用<code class="fe ls lt lu lv b">OrderRepository</code>类从数据存储中获取细节。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="16f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们测试一下代码是否有效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a048" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利！我们得到了预期的产量。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="b99b" class="mq lz iq lv b gy nl nm l nn no">Id: 1, description: Special Order, price: 10.0</span></pre><p id="f11b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后来，您遇到了<a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_injection#:~:text=In%20software%20engineering%2C%20dependency%20injection,object%20is%20called%20a%20service." rel="noopener ugc nofollow" target="_blank">依赖注入</a>模式，并了解了它的好处。现在您想在这个项目中引入DI，并围绕它构建一个轻量级框架。</p><p id="ee18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们该如何着手呢？我们应该删除依赖关系的所有直接实例化，而是让框架创建和注入依赖关系。</p><p id="4e12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们移除<code class="fe ls lt lu lv b">OrderService</code>中<code class="fe ls lt lu lv b">OrderRepository</code>的实例化，并用<code class="fe ls lt lu lv b">SimplyAutoWired</code>注释来注释该字段。我们期待框架为我们注入<code class="fe ls lt lu lv b">OrderRepository</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/0ada43e5d9a10614414870391a818a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*8L5wxXwDNYziOspiRMLFKA.gif"/></div></div></figure><p id="446b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在声明自定义注释<code class="fe ls lt lu lv b">SimplyAutoWired</code>。使用<strong class="ky ir"> <em class="nq"> @interface </em>关键字声明注释。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8c31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你注意到它上面的两个附加注释了吗？这些应用于其他注释的内置注释被称为<a class="ae kv" href="https://dzone.com/articles/what-are-meta-annotations-in-java" rel="noopener ugc nofollow" target="_blank">元注释</a>。</p><p id="e84a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个注释声明我们只能将<code class="fe ls lt lu lv b">SimplyAutoWired</code>应用于字段，第二个注释指定它具有运行时可见性。注释没有任何方法，它只是一个简单的标记。</p><p id="ccd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经准备好了注释，让我们创建一个类<code class="fe ls lt lu lv b">ApplicationContext</code>，它将负责实例化和组装对象。</p><p id="318b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望实现这样的目标。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="64d8" class="mq lz iq lv b gy nl nm l nn no">ApplicationContext applicationContext = new ApplicationContext();<br/>orderService = <strong class="lv ir">applicationContext.getInstance(OrderService.class);</strong></span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ac00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在使用该类的<code class="fe ls lt lu lv b">getConstructor</code>方法获取该类的公共默认构造函数。通过使用构造函数，我们创建了一个实例。</p><p id="4f98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将实现<code class="fe ls lt lu lv b">injectAnnotatedFields</code>方法，它将实例化并注入类中用我们的<code class="fe ls lt lu lv b">SimplyAutoWired</code>注释标注的字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们可以通过使用Java的反射API来读取自定义注释。使用字段类中的<code class="fe ls lt lu lv b">isAnnotationPresent()</code>方法，我们检查字段是否用<code class="fe ls lt lu lv b">SimplyAutoWired</code>注释进行了注释。</p><p id="a34b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">字段可能是私有的，所以在用它的实例设置字段之前，我们将<em class="nq">可访问的</em>标志设置为真。现在，我们将递归调用<code class="fe ls lt lu lv b">injectAnnotatedFields</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/d9e86540727023f2f3328f735ff87d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bmPeVWyUnz_d4ioUVsWNAA.png"/></div></div></figure><p id="ad86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们可以使用<code class="fe ls lt lu lv b">applicationContext</code>来获得一个实例<code class="fe ls lt lu lv b">OrderService</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="f79b" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">进一步增强</h1><p id="fdbc" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">到目前为止，我们已经看到了如何创建定制注释。我们还看到了如何将它们与反射API一起使用，以便于框架创建实例并将依赖项注入其中。</p><p id="b583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将放一些铃铛和哨子。</p><p id="e815" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据<a class="ae kv" href="http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s12.html" rel="noopener ugc nofollow" target="_blank"> Spring文档</a>Spring bean在默认情况下是单件的。</p><p id="a7bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，每次调用<code class="fe ls lt lu lv b">getInstance</code>方法时，我们都在创建新的实例，这是低效的。</p><p id="b15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，DI框架还应该在<em class="nq">创建</em>、<em class="nq">编排</em>和<em class="nq">销毁方面对对象的生命周期拥有完全的控制权。</em></p><p id="c2aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们会做以下改进。</p><ol class=""><li id="2596" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated">创建一次对象，然后重用它们。</li><li id="ac5f" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">当应用程序启动时，通过定位和注册所有组件来控制对象的创建。</li></ol><p id="559c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是首先，我们需要告诉框架，它应该注册哪些组件，应该在哪些包中搜索。</p><p id="447e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了显示要注册哪些类，我们将创建一个新的注释<code class="fe ls lt lu lv b">@SimpleComponent</code>。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="dc2a" class="mq lz iq lv b gy nl nm l nn no">@SimpleComponent<br/>class OrderService {<br/>  ...<br/>}</span></pre><p id="6aac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了存储要扫描的包的值，我们将添加另一个注释<code class="fe ls lt lu lv b">@ComponentScan</code>。以前，我们只见过没有方法的注释。但是像任何其他接口一样，注释也可以有方法。此外，注释的所有属性都被定义为方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="399d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该注释声明了一个名为“value”的字符串属性。</p><p id="8e56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一次，我们使用了一个名为<code class="fe ls lt lu lv b">@Repeatable</code>的新的元注释，它规定了该注释可以多次应用于同一个声明。</p><p id="86ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用<code class="fe ls lt lu lv b">Repeatable</code>，我们需要一个容器注释来存储数组值<em class="nq">。在这种情况下，我们将使用<code class="fe ls lt lu lv b">ComponentScans</code>。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="dfb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们把所有东西放在一起。首先，我们将创建一个用<code class="fe ls lt lu lv b">ComponentScan</code>注释的配置文件，并将要扫描的包作为其值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6224" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，它将被传递给<code class="fe ls lt lu lv b">ApplicationContext</code>。</p><pre class="kg kh ki kj gt nh lv ni nj aw nk bi"><span id="bdad" class="mq lz iq lv b gy nl nm l nn no">ApplicationContext applicationContext = new ApplicationContext(ApplicationConfig.class);</span></pre><p id="3475" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">ApplicationContext</code>中，我们现在将使用一个映射来存储和重用创建的实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在应用程序启动时，我们将创建对象。首先，从<code class="fe ls lt lu lv b">ComponentScan</code>注释中获取要扫描的包。然后获取包中的所有类。之后，遍历每个类，检查是否用<code class="fe ls lt lu lv b">Component</code>进行了注释。如果它被注释，创建一个实例并将对象存储在映射中。</p><p id="f4c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了可读性，我在这里不为<code class="fe ls lt lu lv b">findClasses</code>添加代码。你可以在这里阅读代码<a class="ae kv" href="https://github.com/daleef-rahman/DiFramework/blob/main/src/com/di/ApplicationContext.java#L69" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="42d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在重构剩余的方法，从地图中获取对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们简单的依赖注入框架已经准备好了！</p><p id="e518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章的源代码可以在GitHub项目上找到。</p><h1 id="38a8" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">我们今天学到了什么</h1><p id="a429" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们已经创建了一个像Spring这样的迷你依赖注入框架，并且在这个过程中学习了反射和注释处理的基础知识。</p><p id="c0c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">DI框架的实际实现要比这复杂得多。</p><p id="4de2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇博客的目的只是让你了解如何将反射和注释结合起来构建像这样强大的库和框架。</p><p id="b818" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nq">如果你喜欢读这篇文章，你可能也会发现下面的文章值得你花时间去读:</em></p><div class="og oh gp gr oi oj"><a rel="noopener  ugc nofollow" target="_blank" href="/exploring-the-template-method-pattern-through-jdbctemplate-4ee02ec9fcad"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">通过JdbcTemplate探索模板方法模式</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">模板方法模式的基础以及JdbcTemplate如何实现该模式</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">better编程. pub</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kp oj"/></div></div></a></div></div></div>    
</body>
</html>