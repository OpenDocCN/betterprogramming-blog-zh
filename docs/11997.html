<html>
<head>
<title>Let’s Smell Some Tests #2 — Asserting The Internal Behavior in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们闻闻测试# 2——断言Java的内部行为</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lets-smell-some-tests-2-asserting-the-internal-behavior-in-java-1c0f34fe8bbc?source=collection_archive---------6-----------------------#2022-05-03">https://betterprogramming.pub/lets-smell-some-tests-2-asserting-the-internal-behavior-in-java-1c0f34fe8bbc?source=collection_archive---------6-----------------------#2022-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="742a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么您的测试应该只验证可观察到的行为，而不是实现细节</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d3604a2d61c82432380e3bb6fc854054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HVICthxB0J23QLL0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">米歇尔·勒恩斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="89ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大家好，欢迎来到“<em class="ls">让我们闻闻测试”</em>系列的新一集。</p><p id="be0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将考虑我们的测试到底应该(不应该)验证什么，以避免错误警报，以及为什么有时候越少越好。为了更好地理解这个主题，我们将更仔细地看一下<em class="ls">脆弱测试</em>和<em class="ls">可观察行为</em>的定义，这样我们将能够检测设计不佳的测试，并使它们抵抗重构。</p><p id="6777" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6398" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">当你的测试想知道太多的时候</h1><p id="ccb7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在我深入研究自动化测试之前，这种事情已经发生在我身上很多次了。到底是什么？嗯，以防万一，我想确保我的测试验证了比必要的更多的东西。我曾经相信，我的测试包含的<code class="fe mx my mz na b">assert</code>和类似的陈述越多，它们带来的价值就越大。</p><p id="68b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然上面的方法看起来很合理，但从长远来看，选择它会让开发人员的日子不好过。当我自己的测试让我不得不比我预期的更频繁地回来时，我才艰难地发现了这一点。一个理由？事实证明，这些测试与实现细节有关，而不是可观察的行为，因此，当重构时，即使功能仍然工作良好，它们也会失败。</p><h2 id="bacd" class="nb mb iq bd mc nc nd dn mg ne nf dp mk lf ng nh mm lj ni nj mo ln nk nl mq nm bi translated">脆性试验？可观察的行为？实施细节？</h2><p id="604b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在我们进一步深入之前，让我们定义这些神秘短语背后的含义，因为它们对于理解如何编写好的测试是必不可少的，可以为我们的项目增加真正的价值，而不是不必要的负担。</p><p id="2c7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于良好测试实践的一个极好的知识来源是一本由Vladimir Khorikov写的名为<em class="ls">“单元测试:原则、实践和模式”</em>的书。</p><p id="7cd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据作者(第4.4.4章)，当时<strong class="ky ir">测试是脆弱的</strong></p><blockquote class="nn no np"><p id="9fb0" class="kw kx ls ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">它们经不起重构，不管底层功能是否被破坏，它们都会变红</p></blockquote><p id="4e17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，重构后你的功能仍然可以产生正确的结果，但与此同时，你的测试可能会失败，如果他们检查<em class="ls">某事如何工作，而不是检查<em class="ls">什么是<em class="ls">可观察的行为</em>。</em></em></p><p id="daef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，什么是可观察的行为呢？在第5.2.1章中。，本书的作者用下面的话定义了<strong class="ky ir">的可观察行为</strong>:</p><blockquote class="nn no np"><p id="da09" class="kw kx ls ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">要使一段代码成为系统可观察行为的一部分，它必须做以下事情之一:</p><p id="215a" class="kw kx ls ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">公开一个帮助客户端实现其目标之一的操作。操作是一种执行计算或产生副作用或两者兼而有之的方法。</p><p id="7679" class="kw kx ls ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">公开一个帮助客户端实现其目标之一的状态。状态是系统的当前状况。</p><p id="6eea" class="kw kx ls ky b kz la jr lb lc ld ju le nq lg lh li nr lk ll lm ns lo lp lq lr ij bi translated">任何不做这两件事的代码都是实现细节。</p></blockquote><p id="70c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，当你在开发一个新的功能时，想想调用你的代码的客户的真正目标是什么(客户代码期望从我们的解决方案中得到什么行为，或者你的功能应该覆盖什么业务案例)，暂时忘记你想要如何开发那个功能(实现细节)。</p><p id="b275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法应该让您更清楚地区分可观察的行为和实现细节。</p><h1 id="e16d" class="ma mb iq bd mc md nt mf mg mh nu mj mk jw nv jx mm jz nw ka mo kc nx kd mq mr bi translated">案例研究:排行榜</h1><p id="51f8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">让我们仔细看看下面这个用Java编写的例子:</p><ul class=""><li id="3509" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">我们正在为一个游戏开发一个排行榜，让我们称这个游戏为“<em class="ls">追逐与竞赛”</em></li><li id="22e3" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">我们希望我们的排行榜根据得分选出最佳球员</li></ul><p id="1d80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">Player</code>类负责保存玩家的名字和他们的分数。分数通过<code class="fe mx my mz na b">Player#updateScore</code>功能更新。</p><p id="a5a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">Leaderboard</code>类允许我们通过<code class="fe mx my mz na b">Leaderboard#addPlayer</code>函数将玩家添加到排行榜列表中，并通过<code class="fe mx my mz na b">Leaderboard#getBestPlayer</code>检索游戏的最佳玩家。</p><p id="b6b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mx my mz na b">LeaderboardTest</code>测试类中，我们正在检查<code class="fe mx my mz na b">Leaderboard#getBestPlayer</code>方法是否能够返回最高分的玩家:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/c9c157674e291d98de6c32f290e44d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZKVHxg_RP49K67Rv33PtCQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">检索最佳玩家的测试通过</p></figure><p id="df62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，一切顺利——如您所见，测试报告是绿色的。</p><p id="218e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">后来，我们决定重构<code class="fe mx my mz na b">Leaderboard</code>类的内部结构，因此每当我们向它添加一个新的玩家时，它就按降序对玩家列表进行排序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/8748e8030550000c8ddf0acb4b50ad0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*quyN1ZPF1f-HWeNzIZ6vvQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实现细节发生了变化，这次测试失败了，尽管测试的方法产生了正确的输出</p></figure><p id="0244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们省略关于是否需要这种改变的讨论——我想向您展示的是改变实现细节会如何影响现有的测试。</p><p id="8368" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你所看到的，测试报告变红了，但是可观察到的行为保持不变——<code class="fe mx my mz na b">Leaderboard#getBestPlayer</code>函数仍然正常工作，它返回最高分的玩家。</p><p id="4660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何解决这个问题？如果一次编写的测试不需要我们额外关注重构代码库，那将是最好的。为此，<code class="fe mx my mz na b">Leaderboard#players</code>列表应该不能从外部访问，因此用<code class="fe mx my mz na b">private</code>修饰符标记这个集合就足够了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="3101" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是考试呢？它现在有一个编译错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/f96b1b81ad3e16faa4965e72d121f22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGoilwbNmx6Buc0-xyd-2Q.png"/></div></div></figure><p id="9ff5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于您的测试应该只验证可观察的行为，<strong class="ky ir">我们可以安全地从第25行删除断言，因为它检查实现细节，这使得这个测试变得脆弱</strong>。</p><h1 id="7a67" class="ma mb iq bd mc md nt mf mg mh nu mj mk jw nv jx mm jz nw ka mo kc nx kd mq mr bi translated">结论</h1><p id="3304" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在您的项目中进行脆弱测试的后果可能非常严重。例如，这样的测试会阻碍开发人员进行代码重构，因为说实话，当你完成了重构，而这导致了一系列失败的测试时，这并不一定会让你心情愉快。另一个可能的后果是，开发人员可能会习惯于发出错误警报的测试，降低他们的整体警觉性，从而增加了bug潜入产品的机会。</p><p id="cd51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们总结一下注意事项:</p><ul class=""><li id="7281" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">记住测试<em class="ls">可观察的</em>行为，而不是<em class="ls">实现细节</em>，你的开发人员的生活会轻松很多</li><li id="48a6" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">不要向外界公开实现细节，因为在保持已发布的功能不变的情况下，内部结构将来应该很容易被替换</li><li id="9eb1" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">测试套件中的代码和产品代码一样重要，所以要注意你验证的内容，否则项目的整体质量会下降</li></ul><h1 id="3ee1" class="ma mb iq bd mc md nt mf mg mh nu mj mk jw nv jx mm jz nw ka mo kc nx kd mq mr bi translated">参考</h1><p id="8d49" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">单元测试:原则、实践和模式</p></div></div>    
</body>
</html>