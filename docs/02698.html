<html>
<head>
<title>TypeORM Migrations Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了类型迁移</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typeorm-migrations-explained-fdb4f27cb1b3?source=collection_archive---------0-----------------------#2019-12-18">https://betterprogramming.pub/typeorm-migrations-explained-fdb4f27cb1b3?source=collection_archive---------0-----------------------#2019-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">安全地对生产数据库模式进行更改</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/25801fac3c281949b87b110eff8b8cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tc9G91jdR3PYlLdDwEEn1w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@7bbbailey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Barth Bailey </a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的原图。由<a class="ae ky" href="http://www.songthamtung.com" rel="noopener ugc nofollow" target="_blank">song tham Tungkitkancharoen</a>修改。</p></figure><p id="82cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeORM中的<em class="lv">迁移</em>是一个带有SQL查询的单个文件，用于更新数据库模式。作为数据库管理员、后端工程师或技术主管，了解这一点很重要，因为这是在生产中对数据库进行更改的最安全的方式之一。在本文中，我们将回顾如何使用TypeORM在MySQL中执行迁移的最佳实践。</p><p id="1f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本指南建立在<a class="ae ky" href="https://medium.com/better-programming/get-started-with-typeorm-mysql-and-express-js-653270a6a078" rel="noopener">上一篇文章</a>的基础上，该文章展示了如何快速开始使用TypeORM、MySQL和ExpressJS。如果您没有现成的TypeORM项目，我强烈建议您按照本文中的步骤创建一个，这样您就可以按照本指南进行操作了。#边做边学</p><p id="2a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">阅读本文时，请记住:</p><ul class=""><li id="bfbe" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">对象关系映射(ORM)是API和数据库之间的桥梁</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mf"><img src="../Images/e71973380e66e15d84cbbf7230be6ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/0*1KvkCROjeB9Jl9JP.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ORM是API和数据库之间的桥梁</p></figure><ul class=""><li id="75c0" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">更改实体—也称为数据模型(在数据库中存储对象状态的TypeORM类)—将在同步或迁移期间更新模式。</li></ul><p id="2324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>虽然我引用了MySQL，但是您也可以使用其他数据库。</p><h2 id="5de3" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">先决条件</h2><ul class=""><li id="764a" class="lw lx it lb b lc mz lf na li nb lm nc lq nd lu mb mc md me bi translated">连接到数据库的现有TypeORM项目</li></ul><h2 id="0f4d" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">概述</h2><ol class=""><li id="c55b" class="lw lx it lb b lc mz lf na li nb lm nc lq nd lu ne mc md me bi translated">同时发生</li><li id="0b6c" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu ne mc md me bi translated">迁移</li><li id="4052" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu ne mc md me bi translated">关闭</li></ol></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="e434" class="nr mh it bd mi ns nt nu ml nv nw nx mo jz ny ka mr kc nz kd mu kf oa kg mx ob bi translated">同时发生</h1><p id="5ff7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">在讨论TypeORM中的迁移时，我们需要先谈谈<code class="fe of og oh oi b">synchronize</code>。让我们从<code class="fe of og oh oi b">ormconfig.json</code>开始——用<code class="fe of og oh oi b">typeorm init</code>初始化一个新的TypeORM项目时生成的配置文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe of og oh oi b">ormconfig.json</code></p></figure><p id="7734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意那个<code class="fe of og oh oi b">synchronize: true</code>。这是默认设置，但具体是什么呢？它与迁移有什么关系？根据<a class="ae ky" href="https://github.com/typeorm/typeorm" rel="noopener ugc nofollow" target="_blank">type ORM readme . MD</a>:</p><blockquote class="ol om on"><p id="1403" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated"><code class="fe of og oh oi b">Synchronize</code>确保每次运行应用程序时，您的实体都将与数据库同步</p></blockquote><p id="0b83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，每当您对实体进行更改时，它会自动使用链接到您应用程序的数据库更新这些模式更改。</p><p id="76b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本节的其余部分，我们将讨论三种同步场景:</p><ol class=""><li id="91c2" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu ne mc md me bi translated">向实体添加新列</li><li id="2996" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu ne mc md me bi translated">通过创建新实体来创建新表</li><li id="7922" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu ne mc md me bi translated">通过修改实体来删除列和/或表</li></ol><p id="798f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看实际情况。</p><h2 id="b223" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">1.向实体添加新列</h2><p id="576c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">导航到<code class="fe of og oh oi b">User.ts</code>，您应该会看到以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/实体/用户. ts</p></figure><p id="6def" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过复制并粘贴下面的代码，向<code class="fe of og oh oi b">User</code>实体添加一个新列<code class="fe of og oh oi b">birthplace</code>。</p><p id="d520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">@Column()</code></p><p id="8413" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">birthplace: string;</code></p><p id="20bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存。重启本地服务器，您应该看到<code class="fe of og oh oi b">birthplace</code>列被添加到了<code class="fe of og oh oi b">User</code>表中。</p><div class="kj kk kl km gt ab cb"><figure class="or kn os ot ou ov ow paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ecc9ca79e6d945a716f072e69915c295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*ADEhLkB11ks-z_2XAXYdbA.png"/></div></figure><figure class="or kn os ot ou ov ow paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/87a7f1e83cbab5d1f6cd2cabeda9a816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*IcJbfdHz0mQeE8XwtU9aBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk ox di oy oz translated">之前和之后。注意增加了出生地一栏。</p></figure></div><p id="4e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。看看在TypeORM中使用<code class="fe of og oh oi b">synchronize</code>向数据库添加新列有多容易？</p><p id="7ec3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以使用这种方法创建一个新表。</p><h2 id="5992" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">2.通过创建新实体来创建新表</h2><p id="9813" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">要创建一个新的<code class="fe of og oh oi b">Entity</code>，在与<code class="fe of og oh oi b">User.ts</code>相同的文件夹中创建一个名为<code class="fe of og oh oi b">Company.ts</code>的新文件，并粘贴以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">src/实体/公司. ts</p></figure><p id="6d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存。重启本地服务器，您应该会看到添加到数据库中的<code class="fe of og oh oi b">Company</code>表，其中包含<code class="fe of og oh oi b">id</code>和<code class="fe of og oh oi b">name</code>列。</p><div class="kj kk kl km gt ab cb"><figure class="or kn pa ot ou ov ow paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/3ea3a63293aa20ec62d14c85facaa3e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1472/format:webp/1*9QXVOGNEO5l89i0eTt7dxQ.png"/></div></figure><figure class="or kn pb ot ou ov ow paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/0d2b718772bfc616643059458e055cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/1*NpsmNYdFwRV04uN5-a7r2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk pc di pd oz translated">通过创建新实体来创建新表</p></figure></div><h2 id="0c8c" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">3.通过修改实体来删除列和/或表</h2><p id="8e75" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">如果您想要删除任何表或列，同样的逻辑也适用—只需在代码中进行更改，保存并重新启动服务器。</p><p id="5fd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，那么如果<code class="fe of og oh oi b">synchronize</code>自动将我们的代码与数据库同步，为什么迁移是必要的呢？</p><p id="f4d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迁移是必要的，因为一旦在数据库中获得数据，在生产环境中使用<code class="fe of og oh oi b">synchronize:true</code>进行模式同步通常是不安全的。</p><p id="b9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，用<code class="fe of og oh oi b">synchronization</code>自动更新生产模式是危险的。如果东西坏了会怎么样？如果数据丢失会发生什么？如果您想要<em class="lv">版本控制</em>任何数据库模式变更，会发生什么？</p><p id="c882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是TypeORM迁移的用武之地。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="fea2" class="nr mh it bd mi ns nt nu ml nv nw nx mo jz ny ka mr kc nz kd mu kf oa kg mx ob bi translated">迁移</h1><p id="353a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">不要跳过这一步。要开始迁移，您应该做的第一件事是在<code class="fe of og oh oi b">ormconfig.json</code>中设置<code class="fe of og oh oi b">synchronize: false</code>。这将阻止模式同步。</p><p id="6652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本节的其余部分，我们将讨论迁移中的三个场景:</p><ol class=""><li id="0a4c" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu ne mc md me bi translated">生成迁移</li><li id="02b2" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu ne mc md me bi translated">运行迁移</li><li id="afa6" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu ne mc md me bi translated">还原迁移</li></ol><p id="4a6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧。</p><h2 id="3bda" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">1.生成迁移</h2><p id="34db" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">要生成迁移文件，我们需要对实体进行更改。打开<code class="fe of og oh oi b">Company.ts</code>，添加一个新列:</p><p id="6d80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">@Column()</code></p><p id="d060" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">city: string;</code></p><p id="fcee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保存。现在尝试重新启动服务器。由于synchronize为false，数据库不应更新。</p><p id="41d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是使用CLI命令<code class="fe of og oh oi b">typeorm migration:generate</code>。这会生成一个新的迁移文件，需要执行SQL来更新模式。运行它将显示帮助菜单，因为我们没有指定<code class="fe of og oh oi b">name</code>参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/3c0b1f01e095e0c3332906f6256d753c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIudC-Gxy-cyC7Rlyx5Yiw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型迁移:生成</p></figure><p id="90a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">name</code>参数是迁移类的名称，应该是描述性的，比如Git commit。在我们的例子中，让我们使用<code class="fe of og oh oi b">AddCityColumnToCompany</code>。但是，问题是如果我们运行下面的命令，我们可能会得到下面的错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/935c01978b6d03b122b0af3ddd509e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_zJ9jg3eRwx9HxlT2kEsA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">意外的标记{错误！</p></figure><p id="1c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个<a class="ae ky" href="https://github.com/typeorm/typeorm/issues/371#issuecomment-359161565" rel="noopener ugc nofollow" target="_blank">已知问题</a>，与我们的节点环境试图加载<code class="fe of og oh oi b">.ts</code>而不是<code class="fe of og oh oi b">.js</code>有关。如果您收到此错误，快速解决方法是运行以下命令:</p><p id="e9a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe of og oh oi b">./node_modules/.bin/ts-node ./node_modules/.bin/typeorm migration:generate -n AddCityColumnToCompany</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/74cecdcbd0bf437ddf4ff0f784a3d0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnkMCUcf4k0G7diVmWBoPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe of og oh oi b">typeorm</code>迁移:生成</p></figure><p id="ec43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成功，您将在迁移文件夹中看到一个名为<code class="fe of og oh oi b">{TIMESTAMP}-AddCityColumnToCompany.ts</code>的自动生成的新文件，包含以下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="8857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意两个方法:(1) <code class="fe of og oh oi b">up</code> (2) <code class="fe of og oh oi b">down</code>。这些是SQL命令。</p><ol class=""><li id="be65" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu ne mc md me bi translated"><code class="fe of og oh oi b">up</code><strong class="lb iu"/>—包含执行迁移所需的代码。</li><li id="03ef" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu ne mc md me bi translated"><code class="fe of og oh oi b">down</code> —包含恢复<code class="fe of og oh oi b">up</code>已更改内容的代码。</li></ol><p id="cf4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！现在我们已经生成了一个迁移文件，让我们运行它。</p><h2 id="dba9" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">2.运行迁移</h2><p id="f6d7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">要运行迁移，请使用以下命令:</p><pre class="kj kk kl km gt ph oi pi pj aw pk bi"><span id="a5ff" class="mg mh it oi b gy pl pm l pn po">./node_modules/.bin/ts-node ./node_modules/.bin/typeorm migration:run</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/2200b100e706797e95ec3527e98e0515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NVkn1Wpp8mf7Fqn3pOwsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型迁移:运行</p></figure><p id="74c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功的迁移将运行<code class="fe of og oh oi b">up</code> <strong class="lb iu"> </strong>方法中的代码。让我们一行一行地看看正在执行哪些语句。</p><p id="c7ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.<code class="fe of og oh oi b">SELECT * FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE `TABLE_SCHEMA` = ‘test’ AND `TABLE_NAME` = ‘migrations’</code>:这是检查你的数据库中是否有一个迁移表。</p><p id="d782" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe of og oh oi b">CREATE TABLE `test`.`migrations` (`id` int NOT NULL AUTO_INCREMENT, `timestamp` bigint NOT NULL, `name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) SONGTHAM ENGINE=InnoDB</code>:如果没有表格，就创建一个。</p><p id="4d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe of og oh oi b">SELECT * FROM `test`.`migrations` `migrations`</code>:查找迁移表并交叉检查是否有与迁移文件名匹配的迁移。如果存在，跳过。否则，继续。</p><blockquote class="ol om on"><p id="f078" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">0个迁移已加载到数据库中。<br/>在源代码中发现1个迁移。<br/> 1迁移是需要执行的新迁移。</p></blockquote><p id="144a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.<code class="fe of og oh oi b">query: START TRANSACTION</code> <br/> <code class="fe of og oh oi b">query: ALTER TABLE `company` ADD `city` varchar(255) NOT NULL</code>:这是运行迁移脚本的SQL语句。</p><p id="2102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.<code class="fe of og oh oi b">INSERT INTO `test`.`migrations`(`timestamp`, `name`) VALUES (?, ?) — PARAMETERS: [1576405409745,”AddCityColumnToCompany1576405409745"]</code>:如果迁移运行成功，该语句将在迁移表中插入一条新记录。该日志确保如果我们再次运行迁移命令，TypeORM将跳过它，因为它从步骤3知道它以前已经运行过。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pq"><img src="../Images/038f21111da6f23f0aa503e2101c4826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SQl0K7jSgHoGrwOM9Pxuaw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有挂起的迁移</p></figure><p id="9bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下我们的数据库，我们将看到上面的脚本所做的更改。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/db2b850020a3b8ceffa30e70dcc88256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7rl3GiM9l4DsRmUMSaDSQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">请注意公司表中的迁移表和城市列</p></figure><h2 id="44b1" class="mg mh it bd mi mj mk dn ml mm mn dp mo li mp mq mr lm ms mt mu lq mv mw mx my bi translated">3.还原迁移</h2><p id="342c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">本指南的最后一步是恢复迁移。</p><p id="fb2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恢复迁移会运行迁移文件中的<code class="fe of og oh oi b">down</code> <strong class="lb iu"> </strong>方法。如果我们做了一个我们不再需要的模式改变，这是很有用的。</p><p id="2fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要恢复迁移，请使用以下命令:</p><pre class="kj kk kl km gt ph oi pi pj aw pk bi"><span id="d4a5" class="mg mh it oi b gy pl pm l pn po">./node_modules/.bin/ts-node ./node_modules/.bin/typeorm migration:revert</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ps"><img src="../Images/f525a8f3bc63e624633b0e2120c82383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZxlEvOKxHFSMbW0x-aUQuA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">类型迁移:恢复</p></figure><p id="b577" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一行一行地看看正在执行哪些语句。</p><p id="dfa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.<code class="fe of og oh oi b">query: SELECT * FROM `INFORMATION_SCHEMA`.`COLUMNS` WHERE `TABLE_SCHEMA` = ‘test’ AND `TABLE_NAME` = ‘migrations’<br/>query: SELECT * FROM `test`.`migrations` `migrations`</code>:查找迁移表并交叉检查是否有与迁移文件名匹配的迁移。如果是，则执行反转。</p><blockquote class="ol om on"><p id="1eff" class="kz la lv lb b lc ld ju le lf lg jx lh oo lj lk ll op ln lo lp oq lr ls lt lu im bi translated">1迁移已加载到数据库中。<br/>addcitycolumntocompany 1576405409745是最后执行的迁移。本协议于2019年12月15日星期日17:23:29 GMT+0700(印度支那时间)执行。<br/>现在恢复它…</p></blockquote><p id="d230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe of og oh oi b">query: START TRANSACTION<br/>query: ALTER TABLE `company` DROP COLUMN `city`</code>:这是运行迁移恢复脚本的SQL语句。</p><p id="8a29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(3) <code class="fe of og oh oi b">query: DELETE FROM `test`.`migrations` WHERE `timestamp` = ? AND `name` = ? — PARAMETERS: [1576405409745,”AddCityColumnToCompany1576405409745"]</code>:这将从迁移表中删除记录。这样，如果我们要恢复迁移，什么也不会发生，因为TypeORM无法在数据库中找到迁移日志。这也意味着，如果我们愿意，我们现在可以再次运行迁移。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pt"><img src="../Images/0a2ba22702d7c496554b9c183bcfb115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r3muC039cFxTToyMDiy7FA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">请注意空的migrations表，并且已经从company表中删除了city列</p></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="6fb2" class="nr mh it bd mi ns nt nu ml nv nw nx mo jz ny ka mr kc nz kd mu kf oa kg mx ob bi translated">关闭</h1><p id="c3f8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">就是这样。恭喜你完成了整个教程——这并不容易。您刚刚使用TypeORM成功地生成、运行和恢复了迁移。</p><p id="c7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迁移是处理数据库模式更新的一项基本功能。最棒的是，这一切都是在代码中处理的，这意味着它可以被版本控制。您不必再手动执行SQL语句。最重要的是，您可以将其与CI/CD管道集成，因为运行TypeORM迁移需要使用CLI。</p><p id="dc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="33fd" class="nr mh it bd mi ns nt nu ml nv nw nx mo jz ny ka mr kc nz kd mu kf oa kg mx ob bi translated">资源</h1><ul class=""><li id="e2e9" class="lw lx it lb b lc mz lf na li nb lm nc lq nd lu mb mc md me bi translated"><a class="ae ky" href="http://www.typeorm.io/" rel="noopener ugc nofollow" target="_blank"> www.typeorm.io </a></li><li id="e4e0" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu mb mc md me bi translated"><a class="ae ky" href="https://github.com/typeorm/typeorm/blob/master/docs/migrations.md" rel="noopener ugc nofollow" target="_blank">https://github . com/type ORM/type ORM/blob/master/docs/migrations . MD</a></li><li id="104a" class="lw lx it lb b lc nf lf ng li nh lm ni lq nj lu mb mc md me bi translated"><a class="ae ky" href="https://github.com/typeorm/typeorm/issues/371#issuecomment-359161565" rel="noopener ugc nofollow" target="_blank">https://github . com/type ORM/type ORM/issues/371 # issue comment-359161565</a></li></ul></div></div>    
</body>
</html>