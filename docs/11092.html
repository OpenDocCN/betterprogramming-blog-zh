<html>
<head>
<title>Exploring Ruby Splat Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Ruby Splat运算符</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/single-and-double-splat-operators-in-ruby-55dbe771ace6?source=collection_archive---------5-----------------------#2022-02-17">https://betterprogramming.pub/single-and-double-splat-operators-in-ruby-55dbe771ace6?source=collection_archive---------5-----------------------#2022-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1472" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">看一下单双splat算子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/145ae236e6256767e19df47d9bb935af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bw9o_-t7slg59n11H5oj_w.jpeg"/></div></div></figure><p id="65b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开发人员一学会splat操作符的用法，就会尝试使用它。运营商是伟大的，并在许多情况下工作，但我们必须意识到它的力量和后果。</p><p id="ec20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将描述什么是Ruby Single和Double splat操作符，以及我在生产中看到的危险用法。其目的是展示操作者有信心<strong class="kt ir">使用它</strong>的能力，并在代码审查期间识别危险情况。</p><h1 id="6b89" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Splat运算符</h1><p id="1e43" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Splat运算符有两种类型:单(<strong class="kt ir"> * </strong>)和双(**)。两个操作符都有两个主要功能:构造和展开。</p><p id="279e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">单个Splat操作符(*) </strong>构造并展开数组。让我们看一些例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="699e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在前面的例子中，我们可以看到单个splat操作符获取了<code class="fe mm mn mo mp b">prime</code>数组的元素并将它们展开。抓取数组中的项目并将其分配给另一个变量也很有帮助，如前面的示例中的<code class="fe mm mn mo mp b">rest</code>变量所示。</p><p id="692f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也可以将数组元素插入另一个数组。在下面的例子中，<code class="fe mm mn mo mp b">primes</code>元素被添加到<code class="fe mm mn mo mp b">numbers</code>数组中，从调用<code class="fe mm mn mo mp b">*primes</code>的位置开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="f7dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们也可以用它从单个元素构造一个数组。将Splat添加到该值会将该值转换为一个新数组。请参见以下示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="9068" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">double Splat操作符</strong>是在2.0 Ruby版本上发布的，工作原理类似。我们可以构建并传播<strong class="kt ir">散列。</strong>参见下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b316" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">这些运算符可用于功能</strong>。要么在函数的定义中(作为参数)，要么在调用函数作为参数值时。为了深入这两种情况，我们先来看看Ruby函数可以有哪些类型的参数。</p><h1 id="bf02" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">Ruby中的参数类型</h1><p id="7605" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">一个函数可以有不同类型的参数:</p><ul class=""><li id="9378" class="mq mr iq kt b ku kv kx ky la ms le mt li mu lm mv mw mx my bi translated">位置参数。</li><li id="1362" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">关键字参数(也称为kwargs)。</li><li id="9927" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">Splat参数(单运算符和双运算符)</li></ul><p id="248c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">位置参数是最简单的。关键字参数有一个键(一个符号)。一个例子描述了一千个单词:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="33fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mm mn mo mp b">arg_1</code>和<code class="fe mm mn mo mp b">arg_2</code>是位置论元，<code class="fe mm mn mo mp b">key_1</code>和<code class="fe mm mn mo mp b">key_2</code>是夸尔格。</p><p id="38d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两种类型的参数可以有默认值，这意味着调用者不需要传递它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="a5fa" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">函数中的单个Splat运算符</h1><h2 id="0f74" class="ne lo iq bd lp nf ng dn lt nh ni dp lx la nj nk lz le nl nm mb li nn no md np bi translated">调用函数时使用单个Splat运算符</h2><p id="c351" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">splat操作符允许我们将数组的元素传递给函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="6072" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，调用<code class="fe mm mn mo mp b">*arr</code>展开数组<code class="fe mm mn mo mp b">arr</code>元素，并按照给定的顺序将其值作为位置参数传递给函数。</p><p id="bce4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，如果数组<code class="fe mm mn mo mp b">arr</code>包含的值比位置参数(2)多，它将出错(尝试传递<code class="fe mm mn mo mp b">arr = ["1", "2", "3"]</code>)。同样，如果传递的参数较少，将会出现错误。<strong class="kt ir"> <em class="nq">传递的参数数量必须与函数</em> </strong> <em class="nq">接受的位置参数数量相匹配(考虑带有默认值的参数)。</em></p><h2 id="f6dd" class="ne lo iq bd lp nf ng dn lt nh ni dp lx la nj nk lz le nl nm mb li nn no md np bi translated">单个Splat运算符作为函数定义中的参数</h2><p id="bff8" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们已经看到了如何使用Splat操作符作为值，但是我们也可以在函数定义中使用它作为参数。请参见以下示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b278" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mm mn mo mp b">arg_1</code>是一个使用splat操作符的参数，这意味着位置参数是数组<code class="fe mm mn mo mp b">arg_1</code>的元素。因此，您可以向函数传递0个或多个位置参数。</p><p id="054f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不一定要成为最后一个论点。它可以位于函数的中间，如下例所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="d6f4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">函数中的双Splat算子</h1><p id="17d4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这个操作符与单个操作符非常相似，但是它是针对散列(和kwargs)的。</p><h2 id="bcca" class="ne lo iq bd lp nf ng dn lt nh ni dp lx la nj nk lz le nl nm mb li nn no md np bi translated">调用函数时使用双Splat运算符</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7941" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要记住两件重要的事情:</p><ul class=""><li id="b3a0" class="mq mr iq kt b ku kv kx ky la ms le mt li mu lm mv mw mx my bi translated"><strong class="kt ir">哈希必须具有完全相同的键。</strong></li><li id="cc09" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated"><strong class="kt ir">哈希必须将关键字作为符号，而不是字符串。如果你好奇为什么它不使用字符串，请阅读本期<a class="ae nr" href="https://bugs.ruby-lang.org/issues/10118" rel="noopener ugc nofollow" target="_blank"/>。</strong></li></ul><h2 id="a34c" class="ne lo iq bd lp nf ng dn lt nh ni dp lx la nj nk lz le nl nm mb li nn no md np bi translated">Double Splat运算符作为函数定义中的参数:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="415d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该函数接受0个或多个属于<code class="fe mm mn mo mp b">hash</code>的kwargs。与可以在任何位置的单splat运算符不同，<strong class="kt ir">双Splat参数必须在参数列表的最后</strong>。</p><p id="ffbc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能想知道在函数定义中使用Splat <code class="fe mm mn mo mp b">**</code>和仅仅使用散列变量有什么区别？嗯，有一些不同之处:</p><ul class=""><li id="20f9" class="mq mr iq kt b ku kv kx ky la ms le mt li mu lm mv mw mx my bi translated">双Splat是可选的。您不需要向函数传递值。</li><li id="39d7" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">Double Splat不能有默认值，而simple Hash可以。Double Splat的默认值是隐式的空散列值(<code class="fe mm mn mo mp b">{}</code>)。</li><li id="f981" class="mq mr iq kt b ku mz kx na la nb le nc li nd lm mv mw mx my bi translated">如果位置参数中有默认值，结果可能会不同。请参见以下示例:</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="3a50" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结合不同类型的论点</h1><p id="02d4" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">只要double Splat是最后一个参数并且满足所需的参数数量，就可以组合使用single和Double Splat运算符。请看这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="f49f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">小心！</strong></h1><p id="a2af" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我在生产中看到过与这个操作符相关的不同错误，所有这些错误都有一个确切的原因:传递的参数大小不同于所需的大小。这会影响双运算符和单运算符。</p><p id="8d81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个例子。花点时间看看下面这段代码，在看下面的原因之前，想想这段代码为什么可怕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="5973" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有一个<code class="fe mm mn mo mp b">ActiveRecord</code>类<code class="fe mm mn mo mp b">Post</code>链接到包含三列<code class="fe mm mn mo mp b">id</code>、<code class="fe mm mn mo mp b">title</code>和<code class="fe mm mn mo mp b">description</code>的表<code class="fe mm mn mo mp b">posts</code>。</p><p id="5489" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类<code class="fe mm mn mo mp b">PostSchema</code>是<code class="fe mm mn mo mp b">Post</code>类的包装器。它有一个构造函数，该构造函数接受的表所具有的三个属性。</p><p id="2199" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mm mn mo mp b">Service</code>有一个方法，它接收一个<code class="fe mm mn mo mp b">post_id</code>并在表中查找文章。如果找到一篇文章，它将获得其符号化散列的属性，并将它们赋给<code class="fe mm mn mo mp b">attributes</code>变量。然后，它使用带有<code class="fe mm mn mo mp b">attributes</code>变量的双Splat创建一个<code class="fe mm mn mo mp b">PostSchema</code>。最后，我们打印出<code class="fe mm mn mo mp b">PostSchema</code>。</p><p id="b8c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你注意到这段代码有什么问题吗？如果没有，花点时间读一下<code class="fe mm mn mo mp b">print_post</code>函数。</p><p id="ba13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我更改了<code class="fe mm mn mo mp b">posts</code>表的模式会发生什么？例如，让我们向<code class="fe mm mn mo mp b">posts</code>表中添加一个新列<code class="fe mm mn mo mp b">created_at</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/477cef7322b65e21eac8fcd9db0d2c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*OxlMgv-gCy073MgTdLadkA.png"/></div></figure><p id="ad7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💥💥💥💥💥嘣！测试现在失败了！原因是Splat操作符现在传递了一个构造函数不支持的新参数<code class="fe mm mn mo mp b">created_at</code>。</p><p id="d0df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个角落的情况，但肯定像这样的情况发生！其他错误可能是由不同的因素引起的，例如将按键作为字符串使用double Splat，但我没有见过很多。</p><h1 id="89ca" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated"><strong class="ak">结论</strong></h1><p id="767e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">splat操作符是有益的，我建议使用它。但是，在函数中使用它时应该小心。主要是，确保函数满足传递的参数的大小。此外，当有默认值时要格外注意，如果使用double Splat作为参数值，要确保键是符号。</p></div></div>    
</body>
</html>