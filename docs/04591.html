<html>
<head>
<title>7 OpenZeppelin Contracts You Should Always Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该经常使用的7个OpenZeppelin合同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/7-openzeppelin-contracts-you-should-always-use-5ba2e7953cc4?source=collection_archive---------5-----------------------#2020-04-23">https://betterprogramming.pub/7-openzeppelin-contracts-you-should-always-use-5ba2e7953cc4?source=collection_archive---------5-----------------------#2020-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="992f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用OpenZeppelin改进您的智能合同开发</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2a30b78a961f949018614b783c91335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kwEXRR0Dbr3czeVvUPa38Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">OpenZeppelin徽标</p></figure><p id="9fe8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于以太坊开发者来说，OpenZeppelin的智能合同库是一个无价的资源。它拥有经过社区审查的ERC令牌标准、安全协议和其他实用程序的实现，使开发人员能够专注于功能，减少了重新发明轮子的需要。</p><blockquote class="lv"><p id="ec7a" class="lw lx it bd ly lz ma mb mc md me lt dk translated"><strong class="ak">“安全智能合约开发库。</strong>建立在社区审查代码的坚实基础之上。”—<a class="ae lu" href="https://docs.openzeppelin.com/contracts/2.x/" rel="noopener ugc nofollow" target="_blank">OpenZeppelin.com</a></p></blockquote><p id="aefe" class="pw-post-body-paragraph ky kz it la b lb mf ju ld le mg jx lg lh mh lj lk ll mi ln lo lp mj lr ls lt im bi translated">以下是您应该在项目中使用的最有用的Openzeppelin智能合同列表。</p><p id="afd6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="mk">注意:在本文中，我们使用的是OpenZeppelin contracts 2.5 . x版，其中所有的合同都是使用solidity编译器0.5.x版编译的。更新的版本已经推出！</em> </strong></p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9235" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">控制访问</h1><h2 id="3d27" class="nk mt it bd mu nl nm dn my nn no dp nc lh np nq ne ll nr ns ng lp nt nu ni nv bi translated">1.可拥有的</h2><p id="a842" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">由<code class="fe ob oc od oe b">Ownable</code>契约提供的<code class="fe ob oc od oe b">onlyOwner</code>模式是一种简单但非常有效的模式，用于限制对某些功能的访问。这使得它成为智能合约开发人员非常受欢迎的选择。</p><p id="d78a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它实现了一个前提，即部署智能合约的地址是其所有者。像转移所有权一样，某些函数应该只允许从所有者的地址调用。</p><p id="094b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图1显示了<code class="fe ob oc od oe b">Ownable</code>合同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图1:可拥有的合同</p></figure><p id="e93b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意第23行的构造函数是如何设置契约所有者的。一旦任何子契约被初始化，默认情况下，初始化它的地址将成为<code class="fe ob oc od oe b">_owner</code>。</p><p id="f9cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图2显示了扩展<code class="fe ob oc od oe b">Ownable</code>契约的简单实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图2:可拥有的合同</p></figure><p id="d412" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过给<code class="fe ob oc od oe b">restrictedFunction()</code>添加<code class="fe ob oc od oe b">onlyOwner</code>自定义修饰符，只有契约的所有者才能成功调用它。</p><h2 id="d1e6" class="nk mt it bd mu nl nm dn my nn no dp nc lh np nq ne ll nr ns ng lp nt nu ni nv bi translated">2.角色</h2><p id="b396" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">从<code class="fe ob oc od oe b">Ownable</code>向上的下一层是<code class="fe ob oc od oe b">Roles</code>库，它允许实现不止一个所有者角色。当一个契约具有多个访问级别的功能时，这是很方便的。</p><p id="f798" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图3显示了<code class="fe ob oc od oe b">Roles</code>库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图3: Roles.sol</p></figure><p id="1762" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个库，你不能像扩展抽象契约那样扩展它。相反，使用该库的契约使用一个<code class="fe ob oc od oe b">using</code>语句来声明该库提供的函数用于特定的数据类型。</p><p id="1825" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，图4显示了一个契约，它使用<code class="fe ob oc od oe b">Roles</code>库将函数限制为两个角色:<code class="fe ob oc od oe b">_minters</code>和<code class="fe ob oc od oe b">_burners</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图4:使用角色</p></figure><p id="f047" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第8行声明这个契约必须使用<code class="fe ob oc od oe b">Roles</code>库来处理发生在<code class="fe ob oc od oe b">Roles.Role</code>数据类型上的任何操作。第18行显示了在<code class="fe ob oc od oe b">_minters.add() </code> — <code class="fe ob oc od oe b">add()</code>中使用的这个函数是由<code class="fe ob oc od oe b">Roles</code>库提供的。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5053" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">算术</h1><h2 id="b26b" class="nk mt it bd mu nl nm dn my nn no dp nc lh np nq ne ll nr ns ng lp nt nu ni nv bi translated">3.安全数学</h2><p id="d129" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">不要使用简单的算术运算符，如加、减、除和乘，来编写数学计算。除非专门检查不足和溢出漏洞，否则不能保证计算是安全的。</p><p id="34bf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是<code class="fe ob oc od oe b">SafeMath</code>的用武之地。它会执行所有必要的检查，确保您的计算正确运行，而不会给代码带来漏洞。</p><p id="80c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图5显示了<code class="fe ob oc od oe b">SafeMath</code>库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图5:安全数学库</p></figure><p id="6ca9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像使用<code class="fe ob oc od oe b">Roles</code>库一样使用这个库，通过用<code class="fe ob oc od oe b">using</code>语句声明要由<code class="fe ob oc od oe b">SafeMath</code>执行的单元操作。这可以在图6的第7行看到。第10行显示了使用<code class="fe ob oc od oe b">SafeMath</code>库执行减法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图6:使用SafeMath</p></figure><h2 id="b647" class="nk mt it bd mu nl nm dn my nn no dp nc lh np nq ne ll nr ns ng lp nt nu ni nv bi translated">4.安全广播</h2><p id="cd6e" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">作为一名智能合同开发人员，您应该始终寻求节省执行时间和空间。节省空间的一种方法是对整数数据类型使用较小的大小。不幸的是，如果你对一个变量使用<code class="fe ob oc od oe b">uint8</code>并且想对它做一些<code class="fe ob oc od oe b">SafeMath</code>操作，你必须把它转换成<code class="fe ob oc od oe b">uint</code>(又名<code class="fe ob oc od oe b">uint256</code>)。如果你想让结果再次回到<code class="fe ob oc od oe b">uint8</code>中，你必须把它强制转换回来。<code class="fe ob oc od oe b">SafeCast</code>使您能够做到这一点，而不用担心溢出问题。</p><p id="f2d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图7显示了<code class="fe ob oc od oe b">SafeCast</code>库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="ad13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图8显示了一个使用<code class="fe ob oc od oe b">SafeCast</code>库的基本实现，将<code class="fe ob oc od oe b">uint</code>转换为<code class="fe ob oc od oe b">uint8</code>数据类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图8:使用安全广播</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5016" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">代币</h1><h2 id="21da" class="nk mt it bd mu nl nm dn my nn no dp nc lh np nq ne ll nr ns ng lp nt nu ni nv bi translated">5.ERC 20详细信息</h2><p id="c677" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">想都别想写一份完整的合同——open zeppelin已经帮你完成了。你所需要做的就是扩展它并初始化它；剩下的代码已经完成了。</p><p id="f78a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有其他选项可供选择。比如OpenZeppelin提供的基本<code class="fe ob oc od oe b">ERC20</code>契约，只要不需要命名令牌就足够了。<code class="fe ob oc od oe b">ERC20Detailed</code>增加了命名、提供符号和小数位数的功能。</p><p id="2faa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图9显示了使用<code class="fe ob oc od oe b">ERC20</code>和<code class="fe ob oc od oe b">ERC20Detailed</code>契约编写一个ERC20令牌有多简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图9:自定义ERC20令牌</p></figure><h2 id="f97c" class="nk mt it bd mu nl nm dn my nn no dp nc lh np nq ne ll nr ns ng lp nt nu ni nv bi translated">6.ERC 721可数和ERC 721满</h2><p id="202b" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">不可替代的代币<code class="fe ob oc od oe b">ERC721</code>也是如此。你不需要写一份已经完成的符合标准的合同。</p><p id="5df7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过调用<code class="fe ob oc od oe b">_tokensOfOwner(address owner)</code>，使用<code class="fe ob oc od oe b">ERC721Enumberable</code>而不是基本的<code class="fe ob oc od oe b">ERC721</code>来更容易地检索一个地址拥有的所有令牌。或者，如果你想要所有的铃铛和哨子，<code class="fe ob oc od oe b">ERC721Full</code>合同附带每一个额外的扩展。图10显示了<code class="fe ob oc od oe b">ERC721Full</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图10:完整的ERC721</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="3497" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">公用事业</h1><h2 id="316d" class="nk mt it bd mu nl nm dn my nn no dp nc lh np nq ne ll nr ns ng lp nt nu ni nv bi translated">7.地址</h2><p id="0c0e" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">不容易知道您的智能合约正在处理的地址是实际的钱包还是另一个智能合约。<code class="fe ob oc od oe b">Address</code>契约提供了一个名为<code class="fe ob oc od oe b">isContract()</code>的函数，它返回一个回答这个问题的布尔值。</p><p id="c6f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图11显示了如何使用<code class="fe ob oc od oe b">isContract()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="d72c" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">进一步阅读</h1><p id="5d62" class="pw-post-body-paragraph ky kz it la b lb nw ju ld le nx jx lg lh ny lj lk ll nz ln lo lp oa lr ls lt im bi translated">如果你对区块链开发感兴趣，我会写一些关于入门和建立投资组合的教程、演练、提示和技巧。查看以下资源:</p><div class="oh oi gp gr oj ok"><a href="https://medium.com/blockcentric/blockchain-development-resources-b44b752f3248" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd iu gy z fp op fr fs oq fu fw is bi translated">区块链开发资源马上跟进</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">学习区块链、以太坊和DApp开发的资源列表</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy ks ok"/></div></div></a></div></div></div>    
</body>
</html>