<html>
<head>
<title>Understand Smart Contracts by Learning Solidity Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过学习可靠性基础知识了解智能合同</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-smart-contracts-by-learning-solidity-basics-43cfb25878c0?source=collection_archive---------12-----------------------#2022-05-11">https://betterprogramming.pub/understand-smart-contracts-by-learning-solidity-basics-43cfb25878c0?source=collection_archive---------12-----------------------#2022-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f05c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对基础知识的探究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1fe78b45e65f733417e70fb2cfc9cd9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IwT3C0uAuBZZdRAV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扬·安东宁·科拉尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="05a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分散金融应用的潜力是我学习更多以太坊开发的最初动机。智能合约是我在钻研这个话题时学到的第一个概念。</p><p id="e1e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我准备从头开始学习这项技术。但是仔细研究之后，我意识到以前的面向对象和web开发经验已经是一个有益的开始。</p><p id="9375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将分解Solidity中的智能契约，以提高您的理解，并为您开始在以太坊区块链中开发应用程序打下更好的基础。</p><h2 id="9945" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">简单介绍</h2><p id="a2ea" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">智能合同既不智能也不合法。它是居住在以太坊区块链上特定地址的代码(函数)和数据(状态)组合的计算机程序。</p><p id="38cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把智能合同想象成部署在世界计算机上的程序，对其他人来说是可见的和可访问的，可能会有所帮助。</p><p id="5711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署的契约是不可变的。修改智能协定的唯一方法是部署新实例。</p><p id="8a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定相同的交易上下文和以太坊区块链的状态，对于任何运行该合约的人来说，结果将是相同的。</p><h2 id="f3c3" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">执行上下文</h2><p id="13f2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在执行时，合同具有有限的上下文，包括:</p><ul class=""><li id="7d72" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">进入他们自己的国家</li><li id="04e8" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">启动执行的事务的上下文</li><li id="fd9c" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">以太坊区块链的状态(一些关于最近街区的信息)</li></ul><p id="1157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">智能合约处于休眠状态。它们仅在事务触发时执行。只有当执行成功终止时，交易期间所做的合同状态或帐户更改才会记录到区块链中。</p><h2 id="333c" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">简单智能合同</h2><p id="8352" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">让我们分解一个简单的可靠性智能合同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的智能合约示例。</p></figure><p id="993b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第1行指定了一个版本杂注:<code class="fe nj nk nl nm b">pragma solidity ^0.8.13;</code></p><p id="6219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个编译器指令，用于指示编译器我的合同需要哪个编译器版本。这一行告诉编译器如何处理源代码。</p><p id="a6ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的例子中，我指定代码是为最小可靠性版本的<code class="fe nj nk nl nm b">0.8.13</code>编写的。脱字符号<code class="fe nj nk nl nm b">^</code>表示我允许小的修改，如<code class="fe nj nk nl nm b">0.8.14</code>或<code class="fe nj nk nl nm b">0.8.15</code>，但不允许大的修改<code class="fe nj nk nl nm b">0.9.0</code>。这是为了确保我的代码不会因为任何重大改变而被编译。</p><p id="18af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第3行定义了合同:<code class="fe nj nk nl nm b">contract Greeting { ...</code></p><p id="ac07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据类型<code class="fe nj nk nl nm b">contract</code>定义了一个对象。这个定义类似于面向对象语言中的类定义。契约对象可以包含数据和方法。</p><h2 id="eba5" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">可变能见度</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/464f82443f26caab481602998424a88d.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*AoQJvJc_BocsoFeeGgV6hg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">状态变量声明。</p></figure><p id="a482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Solidity中，每个状态变量都需要一个数据类型和可见性。我的契约的第4行声明了一个类型为<code class="fe nj nk nl nm b">string</code>的<code class="fe nj nk nl nm b">public</code>状态变量<code class="fe nj nk nl nm b">name</code>。</p><p id="8bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">string public name;</code></p><p id="2af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">固体中的变量有3种可能的可见性级别:</p><ul class=""><li id="ab3e" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu"> public: </strong>允许其他契约读取它们的值。编译器会自动为它们生成一个getter函数。</li><li id="8cac" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">内部:</strong>默认可见性级别。这些变量只能从它们的协定和派生协定中访问。</li><li id="de0d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">私有:</strong>类似于内部变量，但它们对衍生合同不可见。</li></ul><p id="2871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第7行和第11行声明了公共函数。</p><p id="be3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是在Solidity中声明函数的语法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/1b0ef4f4850347508e15cb08e6b222a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xvv2M7O7B-gBxBgN80p2MA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Solidity中的函数语法。</p></figure><h2 id="1a88" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能可见性</h2><p id="1e41" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">与状态变量类似，函数也有可见性级别。</p><ul class=""><li id="5c2b" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu">公共:</strong>可通过外部账户交易或合同访问。契约中的其他功能也可以看到它们。</li><li id="1794" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">外部:</strong>类似于公共函数。然而，要在契约中调用它们，您必须在它们的调用前面加上关键字<code class="fe nj nk nl nm b">this.</code></li><li id="c382" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">内部:</strong>只能从合同和派生合同内部访问。</li><li id="5e29" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">私有:</strong>类似于内部函数，但不能从派生契约中访问。</li></ul><p id="1d3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将合同部署到区块链，您可以让公众看到您的合同。内部或私有声明仅定义如何以及何时可以访问您的契约函数。</p><h2 id="1451" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">功能行为</h2><p id="16ed" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一个函数也可以有3种可能的行为声明:</p><ul class=""><li id="6471" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu">常量或视图:</strong>这些函数不会修改任何状态变量值。</li><li id="7266" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">纯:</strong>没有任何副作用。它们既不读也不写存储器中的任何变量。</li><li id="0706" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu">应付款:</strong>应付款功能接受来款。</li></ul><h2 id="c5bf" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">结论</h2><p id="2a04" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">围绕分散技术有很多积极的发展。智能合约在这一领域扮演着重要角色。我希望这篇介绍能让你有信心开始你的去中心化之旅。</p></div></div>    
</body>
</html>