<html>
<head>
<title>How To Use a Scoped Service in a Singleton in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中如何在单例中使用作用域服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-a-scoped-service-in-a-singleton-in-c-a85d6fd02368?source=collection_archive---------6-----------------------#2022-09-06">https://betterprogramming.pub/how-to-use-a-scoped-service-in-a-singleton-in-c-a85d6fd02368?source=collection_archive---------6-----------------------#2022-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ae12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">对这一过程的简要讨论</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7ccd341cf5f76fdf07146ea07a4fd34b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*twNwECkfcrOrpff9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@olloweb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">新闻社</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上追踪</p></figure><p id="0f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来不干净，没有达到示波器的目的，对吗？通常，当您拥有一个作用域服务时，它只能在相同作用域的其他作用域服务中使用。作用域是一个相互关联的请求的封闭环境。例如，当您向一个API发出请求时，这个API可能会在一个封闭的范围内处理您的请求，这就是实例化只在这个范围内使用的服务。</p><p id="23e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与此相反，单例服务在每个应用程序生命周期只托管一次，只有在应用程序结束时才被释放。自然，您不能在单例服务中引用封闭范围的服务，而且在大多数情况下，您也不应该这样做。</p><p id="d22c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在极少数情况下，托管使用作用域服务的单例可能是有意义的。例如，在我最近的项目中，我在<a class="ae ky" href="https://azure.microsoft.com/" rel="noopener ugc nofollow" target="_blank"> Azure </a>上托管了一个<a class="ae ky" href="https://azure.microsoft.com/de-de/services/functions/" rel="noopener ugc nofollow" target="_blank">函数应用</a>，其中每个请求产生一个作用域。这个功能应用程序还使用定时触发器和后端触发器，这将有应用程序的范围。</p><p id="bbac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，每次后端请求进来时，应用程序都会实例化一个新的范围，其中包含新的HttpClients、BlobClients等等。当然，有许多后端请求…应用程序将创建成千上万的客户端，这也将是可重用的。然而，使它们成为单例是不可能的，因为身份验证服务必须被限定范围。</p><p id="f2bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您从未使用过依赖注入，请查看本文档。</p><p id="499a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是简单地手动创建一个限定了作用域的，它的生存期与singleton的生存期相同。</p><h1 id="b58e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">IServiceScopeFactory</h1><p id="fe40" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">负责创建新作用域的服务称为:<code class="fe ms mt mu mv b">IServiceScopeFactory</code>。该接口可以在<code class="fe ms mt mu mv b">Microsoft.Extensions.DependencyInjection.Abstractions</code>库中找到。你可以简单地把这个接口放在一个构造函数中，并且有能力创建你自己的作用域。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用IServiceScopeFactory手动实现</p></figure><p id="8b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您只需要将这个服务作为单例添加到DependencyInjection容器中，就可以开始了！</p><p id="066f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在想知道是否需要重写所有代码，以便可以在单例中使用作用域服务，请不要担心，我已经开发了一个替代方案:</p><h1 id="2971" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">AddScopedSingleton()扩展方法</h1><p id="b570" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">就像您将服务添加到<code class="fe ms mt mu mv b">IServiceCollection</code>中一样，我希望添加我的作用域单件服务，而不需要改变服务本身。这就是我创建以下方法的原因:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">扩展方法AddScopedSingleton</p></figure><p id="57ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，该方法在技术上向<code class="fe ms mt mu mv b">IServiceCollection</code>添加了一个单例实例，然而，服务本身是在一个新的范围内创建的。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="bc23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些扩展现在使我的函数应用程序在每个应用程序生命周期中只托管一种服务。请记住，您不能使用这个方法来包装所有的作用域服务。对于大多数API请求来说，作用域通常是必需的，只有极小一部分可以在单例中运行。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。<br/>非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你有美好的一天！</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="ng">加入中现</em> </a></p><p id="cb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>