<html>
<head>
<title>How To Take Advantage of JavaScript Event Propagation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用JavaScript事件传播</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-take-advantage-of-javascript-event-propagation-ea2d6daa0ee1?source=collection_archive---------16-----------------------#2019-10-28">https://betterprogramming.pub/how-to-take-advantage-of-javascript-event-propagation-ea2d6daa0ee1?source=collection_archive---------16-----------------------#2019-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6387" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这种方法将改变您编写事件的方式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de93956fc3eaf37b4190e53dbc4170f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZPtaSiyyILF4gOwcnXAKA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">伊丽莎白在<a class="ae kv" href="https://unsplash.com/s/photos/bubbling?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上探索</p></figure><p id="b25d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我相信每个开发人员一生中都至少使用过一次jQuery，并且注意到将事件附加到元素上非常容易。</p><p id="961e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为与<code class="fe ls lt lu lv b">addEventListener</code>相比，提供的语法非常简单，而且很容易听到多个元素而不需要遍历它们。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1194" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">听不止一种元素</h1><p id="ccb3" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">假设我们想用<code class="fe ls lt lu lv b">.accordion-link</code>来监听手风琴元素的点击，以显示或隐藏内容。</p><p id="e638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用jQuery，不管是一个元素还是几个元素，我们都将编写相同的代码块。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="247f" class="ne me iq lv b gy nf ng l nh ni">$('.accordion-link').click(function (event) {<br/>    // Add some logic...<br/>});</span></pre><p id="0ffb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，<a class="ae kv" href="http://vanilla-js.com/" rel="noopener ugc nofollow" target="_blank"> Vanilla JS </a> <code class="fe ls lt lu lv b">addEventListener()</code>方法只能附加到一个元素上。因此，我们可以为每个元素添加一个单独的事件侦听器，或者更好的方法是，遍历所有元素，如下所示:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="eab0" class="ne me iq lv b gy nf ng l nh ni">const <!-- -->accordionLinks<!-- --> = document.querySelectorAll('.<!-- -->accordion-link<!-- -->');</span><span id="34d6" class="ne me iq lv b gy nj ng l nh ni">for (let i = 0; i &lt; elements.length; i++) {<br/>    elements[i].addEventListener('click', function (event) {<br/>        <!-- -->// Add some logic...<br/>    }<br/>}</span></pre><p id="31e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码有几个问题:</p><ul class=""><li id="9062" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">移除已注册的事件将会很棘手，因为您需要再次遍历它们。</li><li id="6aff" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">它不适用于动态呈现的元素，因为我们需要对以后添加到DOM中的每个元素重复这个过程。</li></ul><p id="84e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，更好的处理方式是什么呢？</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8da7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">事件授权方法</h1><p id="3139" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">JavaScript事件使用一种叫做<em class="ny">事件冒泡</em>的东西，每当用户与嵌套元素交互时就会发生这种情况，并且事件通过所有祖先元素向上传播(“冒泡”)。</p><p id="2f46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事件委托通过将事件监听器附加到<code class="fe ls lt lu lv b">document</code>元素来利用这种传播。然后我们可以检查被点击的元素是否有我们关心的选择器。</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="cea2" class="ne me iq lv b gy nf ng l nh ni">document.addEventListener('click', function (event) {<br/>    if (event.target.classList.contains('accordion-link')) {<br/>        // Add some logic...<br/>    }<br/>}, false);</span></pre><p id="cc55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">event.target</code>总是被点击的元素。</p><p id="bff9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法的另一个好处是，您可以动态地向DOM添加元素，而不必添加额外的事件侦听器。</p><p id="8431" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">祝编码愉快！</p></div></div>    
</body>
</html>