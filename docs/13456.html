<html>
<head>
<title>Design Pattern of Streaming Enrichment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">流式浓缩的设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-pattern-of-streaming-enrichment-17a9eb065eca?source=collection_archive---------8-----------------------#2022-08-29">https://betterprogramming.pub/design-pattern-of-streaming-enrichment-17a9eb065eca?source=collection_archive---------8-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="af21" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解流式架构的概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d8a7e1de79bb2f8486d3a5207a101aa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gwm6shsOymkXvJPF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">若昂·布兰科在<a class="ae kv" href="https://unsplash.com/photos/1_2d3MRbI9c" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="71e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上次，我们<a class="ae kv" href="https://lazypro.medium.com/stream-processing-introduction-796f15061880" rel="noopener">介绍了流式处理</a>。为了能够用更纯粹的基础设施处理批量和实时数据，我们引入了Kafka和流框架。</p><p id="0082" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将介绍一个通用的流设计模式，丰富，并检查流框架能带来什么好处。</p><p id="91a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">什么是充实？简而言之，它是扩展原始事件以满足新功能需求的实现。</p><h1 id="1bc9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">功能描述</h1><p id="9fea" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">许多社交媒体平台上都有类似的功能。</p><ol class=""><li id="983c" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">谁来看我</li><li id="940a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">其他人也在观看</li><li id="d8c5" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">以什么身份来看待我</li></ol><p id="77dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个特征是在给定的时间段内有多少人查看了我的个人资料。例如，我的个人资料在一周内被浏览了多少次。</p><p id="12ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个功能是前一个功能的高级版本，这些人还查看了谁？例如，一周内有10个人查看了我的个人资料，他们也查看了埃隆·马斯克。</p><p id="05f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三个特征是第一个特征的衍生物。这些看我的人是什么身份？例如，一周内有10个人浏览了我的个人资料，其中3人是谷歌员工。</p><h1 id="a65b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">谁来看我&amp;其他人也在看</h1><p id="ca76" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用事件流技术可以容易地实现第一和第二特征。首先，让我们定义一个“视图”事件。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1cec" class="ni lt iq ne b gy nj nk l nl nm">{<br/>    eventType: "PageView",<br/>    timestamp: 1660270009,<br/>    viewerId: 1234,<br/>    viewedId: 5678<br/>}</span></pre><p id="2f4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此事件包括发生时间和谁查看了谁。然后我们只需要创建一个收集所有视图事件的流来分析我们需要的特性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/ac9259bdeb935d2af9560482ea580e08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TirXw-Z-2iyoHmgd.png"/></div></div></figure><p id="6014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上图中，假设我的用户id是4567，那么很容易从事件流中找到两个查看过我的用户，分别是2345和1234。</p><p id="3503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进一步从流记录我们也可以了解到2345查看过1234，而1234查看过5678和2345。</p><p id="e188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综合这些信息，我们可以回答。</p><ol class=""><li id="f00c" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">谁来看我？2345和1234。</li><li id="f07f" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">其他人也在查看1234、5678和2345。</li></ol><p id="a3aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了流框架记录的所有事件流，我们可以执行简单的分析来获得所需的特性。</p><h1 id="51f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">以什么身份来看待我？</h1><p id="5f43" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">然而，要知道以什么身份查看我的个人资料并不是那么简单。</p><p id="cbfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的原始事件没有定义额外的属性，只有id。嗯，有必要修改原来的实现来添加新的功能。</p><h1 id="4995" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在事件中添加元数据</h1><p id="104f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们将作业添加到原始事件中。当用户正在查看时，除了发送带有id的事件之外，还必须附加作业。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="853e" class="ni lt iq ne b gy nj nk l nl nm">{<br/>    eventType: "PageView",<br/>    timestamp: 1660270009,<br/>    viewerId: 1234,<br/>    viewedId: 5678,<br/>    viewerJob: "Google"<br/>}</span></pre><p id="d0f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题看似解决了，但真的是这样吗？</p><p id="5bba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种解决方案有几个明显的问题。首先，修改事件格式会直接影响所有下游消费者。在事件驱动的架构下，生产者不知道消费者的用例，因为两者是分离的。</p><p id="6758" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其次，事件变大，无论消费者是否需要，每个原有的事件都必须加入这个新的领域。换句话说，开销变大了，不仅仅是存储开销，传输开销也变大了。</p><p id="5626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，如果我们想添加新功能，该怎么办？除了工作之外，特性还需要新的头衔、年龄等等。那么上面提到的问题就会一而再再而三的发生。</p><p id="eec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们知道这不是一个好方法。</p><h1 id="bde2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">来自外部数据存储的查询</h1><p id="a874" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为修改原始事件不是一个好方法，所以我们一收到事件就会从其他地方查询所需的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/4af59684905ce3e7c787e4e4223bc6b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*RO4y1Z5g8mZWnMY4.png"/></div></figure><p id="f28a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然在图中表述为数据库，但也可以是微服务或任何能提供信息的平台。</p><p id="4c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，这是事件驱动架构最典型的实现。当工作人员从消息队列中获取事件时，他们处理数据，要么从其他数据源获取必要的信息，要么将结果存储在数据存储中，最后将丰富的事件发送到下一个数据源。</p><p id="58cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种实现在消息队列架构中很好。然而，在流框架中，这样的实现产生了性能瓶颈。假设一个流框架的平均吞吐量是一个数据库的十倍以上。如果每个事件都必须依赖外部数据源，那么总吞吐量将变成<code class="fe np nq nr ne b">1/10</code>。</p><p id="1836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，这种架构还存在一个问题。</p><p id="f7c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个工作集群或流处理集群崩溃时，这是很有可能发生的，毕竟错误无处不在。此时，事件将继续累积，因为没有消费者能够处理它们。这还是正常情况。</p><p id="3a76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦worker集群被修复并且所有worker都在线，所有worker将开始全速消化消息，一个峰值将到达数据源并很可能关闭它。</p><p id="0eec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自身故障会以级联方式影响其他服务。在系统设计中应避免这种紧密耦合。因此，这样的解决方案不够好。</p><h1 id="733d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">合并事件</h1><p id="2b74" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">没有新的元数据进入事件并且不能从外部源查询，那么如何处理丰富？这是提供优势的流框架。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a0c8a9f9e6e710ad0f0c40aaa229e6bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/0*Ap2LAwIOIrq_r3Ob.png"/></div></figure><p id="1df0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中，我们选择了Apache Samza作为说明，但实际上还有许多很好的替代方案，比如Apache Flink。</p><p id="a9c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了将前面提到的处理程序更改为流处理框架之外，还有一个新的事件源<code class="fe np nq nr ne b">ProfileEdit</code>。</p><p id="c447" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个修改事件可以来自数据库的变更数据捕获(CDC ),也可以来自用户服务，但是细节不是本文的重点。</p><p id="4fa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上一节中的数据库成为流处理框架中的状态。这个状态可以被认为是每个工作者的内存空间，因此非常有效。此外，每个工作者共享状态，因此容量比单个实例的内存大得多。</p><p id="30b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当Samza接收到<code class="fe np nq nr ne b">ProfileEdit</code>时，可以保存每个用户的最新状态。一旦收到<code class="fe np nq nr ne b">PageView</code>,它就可以从保存的状态中提取所需的信息，并组装新的事件。</p><p id="dd5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法解决了紧耦合的问题，并显著提高了处理性能。更重要的是，Samza提供了恰好一次的保证，以避免由于外部数据源故障而导致事件重复。</p><p id="2a49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管状态由多个实例共享，但仍有可能达到上限。如何解决可扩展性问题？</p><p id="389f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Kafka中，提供了一种消息分区机制，具有相同键的消息被分配到相同的分区，并由相同的消费者组处理。在流框架中，划分机制仍然存在，并且已经被抽象到更高的级别。不同的流可以共享同一个密钥空间，也就是说，只要<code class="fe np nq nr ne b">PageView</code>和<code class="fe np nq nr ne b">ProfileEdit</code>拥有相同的密钥，它们就可以被相同的工作者处理。</p><p id="4bec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，状态可以通过水平可伸缩性来存储。</p><h1 id="7bd2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="1d3d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本文中，我们介绍了一种常见的设计模式，传统的消息队列体系结构和现代的流处理体系结构都遇到了同样的问题，即事件丰富。</p><p id="9fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计系统时，除了功能实现之外，还要考虑系统的健壮性和性能，这一点很重要。这就是为什么流框架正在兴起。流提供了处理实时大流量的可能性，而流框架另外提供了各种有用的工具来简化开发。</p><p id="e976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如<a class="ae kv" href="https://lazypro.medium.com/stream-processing-introduction-796f15061880" rel="noopener">之前关于流架构的文章</a>中提到的，流架构有能力将许多技术栈折叠成两个核心组件:Kafka和流处理框架。因此，我建议每一个开发人员，即使你不是数据工程师，也应该了解一下流框架。我相信有更多的洞察力会导致更可靠的系统设计。</p></div></div>    
</body>
</html>