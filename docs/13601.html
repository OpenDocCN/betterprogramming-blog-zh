<html>
<head>
<title>Unit Testing Interactions With the Operating System in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试与Go中操作系统的交互</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/unit-testing-interactions-with-the-operating-system-in-go-7704ad50197a?source=collection_archive---------5-----------------------#2022-09-11">https://betterprogramming.pub/unit-testing-interactions-with-the-operating-system-in-go-7704ad50197a?source=collection_archive---------5-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b802" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测试与操作系统交互的功能的两种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/31397f54b57bc3fa9a91a0caffa7936a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*1tPvWYqFa72cQWhluR490A.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图片可在维基共享3.0  下的<a class="ae kr" href="https://www.wikidata.org/wiki/Special:EntityPage/Q14946043" rel="noopener ugc nofollow" target="_blank"> <strong class="bd ks">知识共享署名分享</strong></a></p></figure><p id="172e" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">无论使用何种语言或技术，测试都是维护一个可靠和稳定的应用程序的关键方面。它使代码不容易出现错误，它防止我们破坏已经存在的功能。否则，我们只会在许多用户体验过之后才知道这样的bug。</p><p id="aed3" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">理想情况下，我们应该尝试尽可能高的测试覆盖率。在我们必须与操作系统交互的应用程序中，我们需要特别注意测试设置，因为它需要一个更具体的环境设置。</p><p id="0c50" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">在这个故事中，我将展示一些我通常用来建立与操作系统交互的功能的单元测试的方法。</p><h1 id="d630" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated"><strong class="ak">用真实操作系统测试</strong></h1><p id="a1fa" class="pw-post-body-paragraph kt ku iq kv b kw mh jr ky kz mi ju lb lc mj le lf lg mk li lj lk ml lm ln lo ij bi translated">一些程序需要与操作系统组件或工件进行交互，例如:</p><ul class=""><li id="e1ef" class="mm mn iq kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">环境变量</li><li id="6290" class="mm mn iq kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">文件系统交互。</li><li id="5bd8" class="mm mn iq kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">局部网络</li></ul><p id="fcb4" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">在操作系统环境中执行测试可能会带来其他问题，例如:</p><ul class=""><li id="13dc" class="mm mn iq kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">权限问题。</li><li id="4075" class="mm mn iq kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">安全问题</li><li id="90ac" class="mm mn iq kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">复杂环境的设置。</li><li id="570a" class="mm mn iq kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">最后清理一切的必要性。</li></ul><p id="3366" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这些因素会带来不必要的复杂性。因此，对于单元测试，最好避免处理它们。我有两个主要的策略来避免这些问题。</p><h2 id="d328" class="na lq iq bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated"><strong class="ak">第一个策略:使用抽象概念</strong></h2><p id="8a24" class="pw-post-body-paragraph kt ku iq kv b kw mh jr ky kz mi ju lb lc mj le lf lg mk li lj lk ml lm ln lo ij bi translated">抽象的概念在软件工程中被广泛使用。当我们构建某个实体的抽象时，它由一个定义良好的接口组成，该接口公开了一个允许我们与之交互的行为，其中所有不相关的实现细节对外界都是隐藏的。</p><p id="7380" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">然后，我们可以从客户端的角度创建类似工作的模拟，而不是在真实的操作系统上执行测试。<br/>假设我们想要测试一个函数，检查密钥“版本”是否在某个YAML文件中。</p><p id="dbdc" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们可以形成以下接口来与文件系统进行交互:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="018e" class="na lq iq nn b gy nr ns l nt nu">type FSReader interface {<br/>  ReadFile(string) ([]byte, error)<br/>}</span></pre><p id="0b1a" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">此外，我们可以创建两个具体类型来实现这样的接口，一个是真实的实现，另一个是用于测试的模拟。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5f01" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">因此，在自动化测试的情况下，我们可以检查这个函数内部的业务逻辑，而不用担心设置实际的文件或清理它们。因为模拟方法给出的结果与我们从真实文件中读取的结果一样。</p><h2 id="db3f" class="na lq iq bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated"><strong class="ak">第二个策略:存根</strong></h2><p id="15ea" class="pw-post-body-paragraph kt ku iq kv b kw mh jr ky kz mi ju lb lc mj le lf lg mk li lj lk ml lm ln lo ij bi translated">有一种替代使用模拟和抽象的方法，称为<strong class="kv ir">存根。</strong></p><p id="cdae" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">存根是对代码中某些依赖的直接替换，就像运行一个函数或方法，去掉它所有的内部逻辑，用我们想要返回的内容替换它。</p><p id="41ed" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">通过这种方式，我们可以强制某个功能产生我们想要的效果，而不受任何其他因素的影响。它总是会返回一个预定义的输出。</p><p id="f913" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">在Go中，这样的功能是由<a class="ae kr" href="https://github.com/prashantv/gostub" rel="noopener ugc nofollow" target="_blank"> gostub </a>包提供的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="701c" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">在上面的例子中，函数<code class="fe nx ny nz nn b">MultiplyBy10</code>的输出被一个stub函数代替，它返回乘以20的输入，而不是最初写的10。</p><p id="0406" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们还可以在使用环境变量时将其存根化:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="51d5" class="na lq iq nn b gy nr ns l nt nu">func TestFunctionThatUsesENV(t *testing.T) {<br/>  stubs := gostub.New()<br/>  stubs.SetEnv("ENV_VAR", "some_value")<br/>  defer stubs.Reset()<br/>  <br/>  // Some Logic that Uses ENV_VAR<br/>  // ...<br/>}</span></pre><p id="a605" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">回到我们之前的例子，我们想要检查关键字<code class="fe nx ny nz nn b">version</code> <strong class="kv ir"> </strong>是否可以在某个YAML文件中找到。我们可以直接存根负责从本地文件系统获取文件的函数，而不是创建一个抽象和具体的类型来实现它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="d940" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">对于一个单元测试套件，我们可以将函数存根化，并在最后恢复它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="75e4" class="na lq iq bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">存根或模拟的其他用法</h2><p id="5679" class="pw-post-body-paragraph kt ku iq kv b kw mh jr ky kz mi ju lb lc mj le lf lg mk li lj lk ml lm ln lo ij bi translated">我使用这些工具主要是为了测试与Go操作系统的交互。然而，它们可以以许多其他方式应用。假设我们想要为一个API执行单元测试。它可能会涉及需要与数据库或电子邮件服务交互的功能和方法，这些是可以应用mocks或stubs的一些用例。</p><h1 id="637e" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">结论和关键要点</h1><p id="0e44" class="pw-post-body-paragraph kt ku iq kv b kw mh jr ky kz mi ju lb lc mj le lf lg mk li lj lk ml lm ln lo ij bi translated">在本文中，我们看到了测试与操作系统交互的特性的两种方法。此外，它们还可以用于测试其他类型的功能。</p><ul class=""><li id="4fe0" class="mm mn iq kv b kw kx kz la lc mo lg mp lk mq lo mr ms mt mu bi translated">模仿包括制作抽象，这些抽象封装了我们在业务逻辑中需要的行为。客户端将无法区分具有真实行为的结构和模拟行为。</li><li id="3792" class="mm mn iq kv b kw mv kz mw lc mx lg my lk mz lo mr ms mt mu bi translated">Stubbing包括替换函数内部的逻辑，以便它准确地返回我们想要的结果，使测试套件按照我们计划的方式进行。</li></ul><p id="65dd" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">希望这些提示有用！感谢阅读。</p></div></div>    
</body>
</html>