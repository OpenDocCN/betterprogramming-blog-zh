<html>
<head>
<title>A Practical Demonstration of Interfaces vs. Abstract Classes in PHP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PHP中接口和抽象类的实际演示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/php-a-practical-demonstration-of-interfaces-vs-abstract-classes-56d9838cd5b7?source=collection_archive---------2-----------------------#2020-01-16">https://betterprogramming.pub/php-a-practical-demonstration-of-interfaces-vs-abstract-classes-56d9838cd5b7?source=collection_archive---------2-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5d2f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">轻松越过这个非常常见的开发人员面试问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8c9c8df91c93bfacda9a2bb3f8b901e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jD9ejR1cF4cNw4dc6Vg0Nw.jpeg"/></div></div></figure><p id="760d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我从2008年开始写PHP代码。在那段时间里，我为各种目的构建了各种应用程序。当你写这么长时间的代码时，你会发现自己创建了一个工具、实用程序和代码片段的库，你会反复使用它们。过了一段时间，你发现你在重用多年前写的代码，而现在却不记得它是如何工作的，为什么，甚至不记得是否有新的更好的方法。你的老的可靠的代码只是做它一直做的和工作，所以你使用它，不要问问题。</p><p id="eaea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最近，当有人让我解释接口和抽象类之间的区别时，我意识到我无法回答这个问题(至少不明智)。在这里，我多年来一直在构建这些东西，但不知道如何，或者被要求，来阐明这些差异。</p><p id="a851" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我开始用谷歌搜索这个常见的问题，发现它得到了非常普遍的答案。除了使用示例代码<code class="fe lq lr ls lt b">Function1</code>和<code class="fe lq lr ls lt b">Function2</code>以及一些同样通用的方法的响应之外，我没有发现任何东西。在现实生活中，我为<code class="fe lq lr ls lt b">Customers</code>和<code class="fe lq lr ls lt b">Orders</code>之类的东西编写代码，如果这些例子也更真实一点，对我来说会更有意义。</p><p id="d5ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，我决定创建这个使用抽象类和接口的实际例子。我已经包括了一些工作代码，您可以访问并亲自试验。</p><p id="60d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们开始吧！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="18d9" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">示例代码和数据库设置</h1><p id="a570" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">这个例子的所有PHP代码都可以在下面的Github库中找到。请随意下载并以任何方式使用这些代码，无需注明出处。</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="8717" class="nc mc it lt b gy nd ne l nf ng"><a class="ae nh" href="https://github.com/crmcmullen/medium-interfaces-abstracts/" rel="noopener ugc nofollow" target="_blank">https://github.com/crmcmullen/medium-interfaces-abstracts/</a></span></pre><p id="8d94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，对于这个例子，我将使用一个MySQL服务器，设置在Docker容器中，按照我的文章中的说明，“<a class="ae nh" href="https://medium.com/@crmcmullen/how-to-run-mysql-in-a-docker-container-on-macos-with-persistent-local-data-58b89aec496a" rel="noopener"> <strong class="kw iu"> <em class="ni">如何在macOS上的Docker容器中运行MySQL并使用持久本地数据</em> </strong> </a>”</p><p id="1fdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我的演示，我需要一个数据库，所以我安装了MySQL教程<a class="ae nh" href="https://www.mysqltutorial.org/mysql-sample-database.aspx" rel="noopener ugc nofollow" target="_blank">中的示例数据库。</a></p><p id="80bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您打算试用我的示例代码，您应该从他们的网站下载并安装数据库。它将创建一个名为<code class="fe lq lr ls lt b">classicmodels</code>的数据库，其中包含我们需要的表格。</p><p id="2e72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，运行下面的MySQL脚本来创建一个数据库用户，我们将在示例代码中使用它来连接数据库。</p><p id="68e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:下面的代码片段中有几行代码，您可以复制所有代码，然后在一次执行中运行它们。</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="df80" class="nc mc it lt b gy nd ne l nf ng">/*  Create DB user */</span><span id="57a5" class="nc mc it lt b gy nj ne l nf ng">USE `classicmodels`;</span><span id="c544" class="nc mc it lt b gy nj ne l nf ng">CREATE USER 'classicmodelsUser'@'%' IDENTIFIED WITH mysql_native_password BY 'foobarPassword';</span><span id="7b6e" class="nc mc it lt b gy nj ne l nf ng">CREATE USER 'classicmodelsUser'@'localhost' IDENTIFIED WITH mysql_native_password BY 'foobarPassword';</span><span id="eef5" class="nc mc it lt b gy nj ne l nf ng">GRANT SELECT, INSERT, UPDATE, DELETE, EXECUTE ON classicmodels.* TO 'classicmodelsUser';</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4c1c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">使用案例</h1><p id="3cdc" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在这个例子中，我们将查询并显示来自于<code class="fe lq lr ls lt b">classicmodels</code> MySQL数据库中的两个数据库表的数据:<code class="fe lq lr ls lt b">customers</code>表和<code class="fe lq lr ls lt b">orders</code>表。</p><p id="a121" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我需要能够连接到数据库。这样做的PHP代码对于数据库中的两个表(实际上是所有的表)都是相同的，所以我将创建一个<code class="fe lq lr ls lt b">abstract class</code>，我的所有数据库类都可以<code class="fe lq lr ls lt b">extend</code>连接到数据库。</p><p id="1c8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我将为每个表创建数据库类，其中包含特定于每个表的函数和方法。我想确保我(或我的开发团队)构建的所有数据库类都遵循相同的规则。我的数据库类中总是需要某些方法。例如，每个数据库类都需要一个插入数据的函数、一个删除数据的函数和一个生成记录列表的函数。因此，当我的开发人员构建数据库类时，我希望确保这些特定的方法总是被包含在内，即使它们内部的代码可能有一点不同。为了实施这种“类蓝图”，我将<strong class="kw iu"> <em class="ni">实现</em></strong><strong class="kw iu"><em class="ni">接口</em> </strong>来定义必须包含在所有数据库类中的函数。</p><p id="1e1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了满足这个用例的需求，我将首先构建查询和显示来自<code class="fe lq lr ls lt b">customers</code>表的数据的部件。这将包括以下内容:</p><ul class=""><li id="7b9a" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">一个名为<code class="fe lq lr ls lt b">Data_Access</code>的抽象类，我的“具体”数据库类可以扩展它。它将提供连接到<code class="fe lq lr ls lt b">classicmodels</code>数据库的方法和功能。</li><li id="e3dc" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">一个名为<code class="fe lq lr ls lt b">Data_Interface</code>的接口类，它将定义必须包含在我的具体数据库类中的函数。</li><li id="ce26" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">一个名为<code class="fe lq lr ls lt b">Customers</code>的“具体”数据库类，它将包含与<code class="fe lq lr ls lt b">customers</code>表交互所需的函数。</li><li id="3ec1" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">一个<code class="fe lq lr ls lt b">index.php</code>页面将成为我们的登录页面，它实例化我们的类，并检索和显示客户数据。</li></ul><p id="3493" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成后，我们会回来:</p><ul class=""><li id="9567" class="nk nl it kw b kx ky la lb ld nm lh nn ll no lp np nq nr ns bi translated">添加一个名为<code class="fe lq lr ls lt b">customerOrders.php</code>的页面来显示客户订单。</li><li id="ea8b" class="nk nl it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">创建一个名为<code class="fe lq lr ls lt b">Orders</code>的具体类，它将包含与<code class="fe lq lr ls lt b">orders</code>表交互所需的所有函数，并展示抽象类和接口的强大功能。</li></ul></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="adba" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">抽象类</h1><p id="ee96" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">抽象类不仅有能力定义具体类所需的方法，还能提供这些方法的<em class="ni">实现</em>。要使用抽象类，具体类必须<em class="ni">扩展</em>抽象类，然后使抽象中定义的所有方法在具体类中可用。</p><p id="bff4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了说明这一点，让我们从检查我们的<code class="fe lq lr ls lt b">Data_Access</code>抽象类开始。在我们的示例代码中，我创建了一个名为<code class="fe lq lr ls lt b">data_access.php</code>的文件。它有两个功能:<code class="fe lq lr ls lt b">dbConnect</code>和<code class="fe lq lr ls lt b">getResultSetArray</code>。</p><p id="6295" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下图1中，你可以看到我们在第三行将<code class="fe lq lr ls lt b">Data_Access</code>定义为一个“抽象类”。这强化了这样一个概念，即它是一个抽象类，因此<em class="ni">不能被实例化为一个独立的类。它只能<em class="ni">延长</em>。这是抽象类的一个规则，确保它被视为抽象类。</em></p><p id="9c82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们试图将<code class="fe lq lr ls lt b">Data_Access</code>类实例化为一个独立的对象:</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="2294" class="nc mc it lt b gy nd ne l nf ng">$cDataAccess = new Data_Access;</span></pre><p id="c678" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它会抛出以下错误:</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="bdda" class="nc mc it lt b gy nd ne l nf ng">PHP Fatal error:  Uncaught Error: Cannot instantiate abstract class Data_Access ...</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/2324ade41b1de65c6f79a09b156d1714.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAg1hQcJ_E5ZjFUSqDRaaA.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图1: Data_Access::dbConnect</p></figure><p id="4bcb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的图1显示了<code class="fe lq lr ls lt b">Data_Access</code>中的<code class="fe lq lr ls lt b">dbConnect</code>函数，它执行到数据库的连接。</p><p id="b7ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="ni">注意:</em> </strong> <em class="ni">在这个函数的顶部你可以看到我正在为数据库凭证定义一些变量。通常我不会在代码中保存这类东西，我会从公共web文件夹外的INI文件中获取这些凭证。但是对于这个演示来说，它有助于保持简单。</em></p><p id="35cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b"><em class="ni">dbConnect</em></code>函数试图连接到数据库，并将该连接存储在一个<code class="fe lq lr ls lt b">GLOBAL</code>变量中，在实例化该类的PHP页面的生命周期中，该变量可用于与其他数据库类共享。如果发生错误，它将被引发回数组中的调用函数。</p><p id="8571" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在下图2中，我们有<code class="fe lq lr ls lt b">Data_Access</code> <strong class="kw iu"> : </strong>中的<code class="fe lq lr ls lt b">getResultSetArray</code>函数</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/024ddf03ef695c5eb8b90cc9620d8404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WzZ3B6kowW0n7VokdPdmcw.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图2:Data _ Access::getResultSetArray</p></figure><p id="1b10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">函数<code class="fe lq lr ls lt b">getResultSetArray</code>接受一个查询字符串作为参数，并使用已建立的数据库连接来执行查询。然后，它将结果放入一个关联数组，并将其返回给调用函数。如果发生错误，也会引发给调用函数。</p><p id="9cfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> <em class="ni">注意:</em> </strong> <em class="ni">我之所以以响应数组的形式返回一切，是为了给调用函数提供一致性。通过这样做，我的调用函数可以知道响应总是以这种形式返回，无论是通过还是失败，响应代码、消息和任何数据结果都在一个名为</em> <code class="fe lq lr ls lt b"><em class="ni">dataArray</em></code> <em class="ni">的关联数组中。这个关联数组很容易在PHP或Javascript中使用。</em></p><p id="1d4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着<code class="fe lq lr ls lt b">Data_Access</code>的完成，我们现在有了一个可以被具体类扩展的抽象类。它提供了实现所有类可以共享的代码的函数。它不特定于任何数据库或表(尤其是如果您删除了<code class="fe lq lr ls lt b">dbConnect</code>中的硬编码凭证)，因此满足了PHP中抽象类的要求。</p><p id="77f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们来看一个接口。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b623" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">界面</h1><p id="1aee" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">把一个接口想象成你的具体类的模板或契约。在我们的例子中，我们说我们希望所有的数据库类都有三个函数——一个插入记录，一个删除记录，一个获取记录列表。</p><p id="f3c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我可以通过创建一个包含所有这些函数的签名的接口，然后在我的具体类中用<em class="ni">实现</em>这个接口，在所有的数据库类中实施这个规则。</p><p id="b1c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下图3中的例子。我创建了一个名为<code class="fe lq lr ls lt b"><em class="ni">data_interface.php</em></code>的文件，并添加了所需的三个函数的签名以及它们所需的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/11202eda8d6fb98dd717491262f290e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ihZRHhTmzeSMjAXqqpEvhQ.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图3:数据接口</p></figure><p id="8248" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，接口中的函数都没有主体。这是因为，虽然接口可以实现方法，但它们不能实现功能。这将由实现类提供。</p><p id="d05a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们对一个接口所做的一切都是强制实现这个接口的类都有相同的方法。接口还有其他一些好处，我稍后会讨论。</p><p id="9ab0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们在第一堂混凝土课上把这些结合起来。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4a5f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">客户类</h1><p id="c6ee" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">这个简单的具体类旨在用作我们访问数据库中的<code class="fe lq lr ls lt b">customers</code>表的网关。它将包含与该表交互所需的所有功能。</p><p id="3ae7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下面的图4中，我们看到了文件<code class="fe lq lr ls lt b">customers.php</code>中的<code class="fe lq lr ls lt b">Customers</code>类:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/427030d1e12b04007c3464874f14488d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*73-IB4RFOlBCIZWNkoAKUg.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图4:顾客</p></figure><p id="6298" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">Customers</code>类中，我们扩展了抽象类<code class="fe lq lr ls lt b">Data_Access</code>并实现了接口<code class="fe lq lr ls lt b">Data_Interface</code>。一个具体类只能扩展一个抽象类，但是它可以实现许多接口。您只需用逗号分隔您的接口。我们将很快演示这一点。</p><p id="8704" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Customers</code>类有一个构造函数，调用<code class="fe lq lr ls lt b">dbConnect</code>并尝试数据库连接。如果失败，我们会有一个不那么体面的退出。通常你会导航到一个对访问者友好的页面来解释这个问题。</p><p id="588b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，您会看到我们的三个函数，以及接口所需的参数(如果有的话):<code class="fe lq lr ls lt b">insertRecord</code>、<code class="fe lq lr ls lt b">deleteRecord</code>和<code class="fe lq lr ls lt b">getList</code>。</p><p id="5b54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为接口执行它的实现规则，如果我试图省略掉<code class="fe lq lr ls lt b">Customers</code>中的一个函数，例如<code class="fe lq lr ls lt b">insertRecord</code>，并试图实例化它，我们会收到一个致命错误:</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="2fcb" class="nc mc it lt b gy nd ne l nf ng">PHP Fatal error:  Class Customers contains 1 abstract method and must therefore be declared abstract or implement the remaining methods (Data_Interface::insertRecord)</span></pre><p id="6794" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">getList</code>函数需要一个参数变量。这是由我们实现的<code class="fe lq lr ls lt b">Data_Interface</code>执行的。这是为了确保<code class="fe lq lr ls lt b">getList</code>函数，在所有实现它的具体类中，为<code class="fe lq lr ls lt b">SELECT</code>语句使用一个过滤器参数。在我们的<code class="fe lq lr ls lt b">Customers</code>列表中，我们需要所有记录，所以我们将在查询中包含允许零值表示<code class="fe lq lr ls lt b">All Customers</code>的代码。否则，您可以传递<code class="fe lq lr ls lt b">getList</code>一个特定的客户号，并取回该单个记录。一个列表仍然是一个有效列表！</p><p id="40ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数继续创建一个查询字符串，然后调用在扩展<code class="fe lq lr ls lt b">Data_Access</code>抽象类时变得可用的<code class="fe lq lr ls lt b">getResultSetArray</code>函数——因为抽象类<em class="ni">可以</em>在方法中实现功能。从数据库表中检索数据的所有可重用代码都保存在<code class="fe lq lr ls lt b">Data_Access</code>中。</p><p id="44ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，最后，让我们看看所有这一切的行动。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d5fc" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">索引页</h1><p id="75bf" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我创建了一个名为<code class="fe lq lr ls lt b">index.php</code>的文件，这是我们这个项目的登陆页面。如下图5所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/f3b597de104975f084b218addd7e936e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_vJIH4znq7yTX85dUjf7qQ.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图5:索引页</p></figure><p id="65d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里没有火箭科学。<code class="fe lq lr ls lt b">Index</code>页面实例化了<code class="fe lq lr ls lt b">Customers</code>类，执行了<code class="fe lq lr ls lt b">getList</code>函数，传递了一个变量，该变量表示需要一个所有客户的列表。这将返回一个客户数组，并在屏幕上以表格的形式显示该列表。</p><p id="d781" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将每个客户编号嵌入到一个到<code class="fe lq lr ls lt b">customerOrders.php</code> <em class="ni"> </em>页面的链接中，我们接下来将创建这个页面，它显示所选客户的所有订单。</p><p id="7a15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/19f4bdbc60ddef2e1ef83ffa04a7b601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GnPUN_-QndNiF3AdjyDFTQ.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图6:客户列表</p></figure><p id="67f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！如果您看到类似于上图中的列表，那么恭喜您。</p><p id="d264" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经创建了一个小型web应用程序，它使用了一个抽象类并实现了一个接口。为了说明这一点的潜力，让我们进入用例的下一步，创建一个显示客户订单的页面。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="bbfe" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">订单类</h1><p id="9823" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在让我们创建下一个具体的数据库类:<code class="fe lq lr ls lt b">orders.php</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/a93ace6a8b56fcb529a1af5a48ca57ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3a7Lec9WM7sFvg1WGhAhg.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图7:订单</p></figure><p id="cd1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Orders</code>级与<code class="fe lq lr ls lt b">Customers</code>级几乎相同。它从一个构造函数开始，该构造函数通过调用<code class="fe lq lr ls lt b">dbConnect</code> <strong class="kw iu"> <em class="ni">来尝试数据库连接。</em> </strong></p><p id="20de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它必须遵循与<code class="fe lq lr ls lt b">Customers</code>相同的规则，因为它也实现了<code class="fe lq lr ls lt b">Data_Interface</code>接口类。因此也需要有<code class="fe lq lr ls lt b">insertRecord</code>、<code class="fe lq lr ls lt b">deleteRecord</code>和<code class="fe lq lr ls lt b">getList</code>功能。</p><p id="89b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是接口的好处之一:现在我们有多个类，它们必须遵循相同的规则，并且包括所有相同的指定方法和所需的参数。如果我使用的是任何一个属于<code class="fe lq lr ls lt b">Data_Interface</code>的类，我总能知道它需要这些方法。</p><p id="0a72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与<code class="fe lq lr ls lt b">Customers</code>一样，<code class="fe lq lr ls lt b">Orders</code>中的<code class="fe lq lr ls lt b">getList</code>功能需要一个参数变量，该变量旨在用作<code class="fe lq lr ls lt b">SELECT</code>语句中的过滤器。在本例中，我将利用这一点，因为我们只想显示所选客户的订单。</p><p id="abf9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦创建了查询字符串，<code class="fe lq lr ls lt b">Orders</code>就可以调用<code class="fe lq lr ls lt b">getResultSetArray</code>函数，就像<code class="fe lq lr ls lt b">Customers</code>一样。</p><p id="cd6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们看到了抽象类的好处。在这种情况下，<code class="fe lq lr ls lt b">Customers</code>和<code class="fe lq lr ls lt b">Orders</code>都扩展了<code class="fe lq lr ls lt b">Data_Access</code>，并共享了该抽象类中的所有公共代码。<code class="fe lq lr ls lt b">Data_Access</code>中的代码并不特定于任何单个数据库表，而是适用于所有数据库表，并且本质上是抽象的。</p><p id="ccbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们用最后一个页面来结束这一部分，它将显示客户订单。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e857" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">客户订单页面</h1><p id="7306" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在下图8中，我们看到了<code class="fe lq lr ls lt b">Customer Orders</code>页面的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/9f6288bdb3ec1bed4ad2524b7f783bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nccJ8IqLUoQv-yGnWLvdhw.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图8:客户订单页面</p></figure><p id="00ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和以前一样，这里没有太多的火箭科学。该页面实例化了<code class="fe lq lr ls lt b">Orders</code>类并执行<code class="fe lq lr ls lt b">getList</code>函数，将URL中发送的客户号作为<code class="fe lq lr ls lt b">GET</code>变量传递。结果列表像以前一样显示在HTML表格中。</p><p id="850c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5773b0b889cecce44b00f4b7007c9f23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*JvOhJniY9jS4Hxv7FWWATA.png"/></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">图9:客户订单列表</p></figure><p id="cffd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你有它！我们已经完成了整个用例。我们已经构建了一个现实生活中的web应用程序，它包含了抽象类和接口实现。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="34d6" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">关于接口你应该知道的其他事情</h1><p id="5d22" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">接口真的很酷，除了在具体的类中执行方法之外，还可以做更多的事情。</p><p id="c252" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，您可以一次实现多个接口。假设在我们的例子中，我们有一个名为<code class="fe lq lr ls lt b">Accounts_Receivable</code>的接口，它具有专用于<code class="fe lq lr ls lt b">Customers</code>(例如<code class="fe lq lr ls lt b">creditCheck</code>)的功能，但不适用于<code class="fe lq lr ls lt b">Orders</code>。</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="5cf3" class="nc mc it lt b gy nd ne l nf ng">&lt;?php<br/><br/>interface Accounts_Receivable {<br/>    public function creditCheck($varCustomerNumber);<br/>}</span></pre><p id="0de9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们想在<code class="fe lq lr ls lt b">Customers</code>和<code class="fe lq lr ls lt b">Data_Interface</code>中实现这个接口，它应该是这样的:</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="df89" class="nc mc it lt b gy nd ne l nf ng">require_once ('data_access.php');<br/>require_once ('data_interface.php');<br/>require_once ('accounts_receivable.php');</span><span id="9b73" class="nc mc it lt b gy nj ne l nf ng">class Customers extends Data_Access implements Data_Interface, Accounts_Receivable {</span></pre><p id="04f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您只需用逗号分隔接口名称。在本例中，<code class="fe lq lr ls lt b">Customers</code>现在需要实现<code class="fe lq lr ls lt b">creditCheck</code>函数及其所需的参数。</p><p id="cdb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用接口可以做的另一件事是使用<code class="fe lq lr ls lt b">instanceof</code>来确定具体的类是否实现了所选择的接口。例如，也许我们想确定一个类是否实现了<code class="fe lq lr ls lt b">Data_Interface</code>接口。我们可以做到以下几点:</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="af31" class="nc mc it lt b gy nd ne l nf ng">&lt;?php<br/><br/>$cCustomers = new Customers;<br/><br/>if ($cCustomers instanceof Data_Interface) {  <br/>    echo 'You are a database class!';<br/>}</span></pre><p id="8bc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使您能够根据类实现的接口类型来区别对待类。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="167b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">关于抽象类你应该知道的其他事情</h1><p id="110d" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">抽象类和接口的最大区别在于抽象类可以实现由扩展它们的类共享的代码。</p><p id="fcc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，抽象类也可以有抽象的<em class="ni">方法</em>。这些方法非常像接口，因为它们仅由函数签名(无主体)表示，并且是扩展抽象类的具体类所需要的。</p><p id="8e77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们例子中的抽象类<code class="fe lq lr ls lt b">Data_Access</code>没有使用任何抽象方法。因此，扩展了<code class="fe lq lr ls lt b">Data_Access</code>的类不需要实现那些方法。</p><p id="0c00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们可以像对待抽象方法一样轻松地在抽象类中包含一些接口函数，并且在扩展类中仍然需要它们。</p><p id="f73f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">Data_Access</code>可能包括以下几行:</p><pre class="kj kk kl km gt my lt mz na aw nb bi"><span id="2a46" class="nc mc it lt b gy nd ne l nf ng">&lt;?php</span><span id="3da5" class="nc mc it lt b gy nj ne l nf ng">abstract class Data_Access {</span><span id="ec7b" class="nc mc it lt b gy nj ne l nf ng">abstract function insertRecord();<br/>abstract function deleteRecord($varRecordId);</span></pre><p id="24f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么这两个函数可以从接口类中移除，我们仍然会得到相同的结果。现在抽象类会强制要求<code class="fe lq lr ls lt b"><em class="ni">insertRecord</em></code> <em class="ni"> </em>和<code class="fe lq lr ls lt b"><em class="ni">deleteRecord</em></code>必须存在于<code class="fe lq lr ls lt b">Customers</code>和<code class="fe lq lr ls lt b">Orders</code>中。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f4bc" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">摘要</h1><p id="ff34" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">接口是确保实现它们的具体类包含接口所需的所有方法的蓝图或契约。您还可以查询具体的类，以确定它们是否实现了某些接口，然后以不同的方式处理不同类型的类。一个具体的类可以实现一对多接口。</p><p id="8641" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">抽象类也可以使用抽象方法来提供一种蓝图或契约，确保具体的类扩展它们来实现所需的方法。然而，抽象类可以更进一步，提供实现代码的类，具体类可以继承这些代码来实现通用功能。一个具体类一次只能扩展一个抽象类。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><p id="4a46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这应该让你开始。关于抽象类和接口的能力，您还可以学习更多，但是这里的课程是帮助您以正确的方式组织代码的基础。</p></div></div>    
</body>
</html>