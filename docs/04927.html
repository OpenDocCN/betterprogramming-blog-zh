<html>
<head>
<title>How to Execute Raw SQL Queries on Multiple Databases in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Django的多个数据库上执行原始SQL查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/raw-sql-queries-on-multiple-databases-in-django-a65e7153b5f2?source=collection_archive---------0-----------------------#2020-05-23">https://betterprogramming.pub/raw-sql-queries-on-multiple-databases-in-django-a65e7153b5f2?source=collection_archive---------0-----------------------#2020-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a9d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">建立到多个现有数据库的连接，执行SQL查询，无需Django模型和迁移</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a5063f55f56579fa2d800b39749a44e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLqa7tOC9AbKk_rWhS_bmA.png"/></div></div></figure><p id="dbe9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尝试将我的Django应用程序与预先存在的数据库一起使用有点困难。没有模型和序列化器的Django有点难以想象。但是有时，如果我们需要通过排除Django ORM和serializer功能来创建一个具有多个现有数据库的Django项目，我们可以定义原始SQL查询来从数据库中获取和插入数据。</p><p id="246b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多数据库配置和原始SQL查询实现的基本步骤如下。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="64fc" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">在Django设置文件中定义数据库连接</h1><p id="75b1" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">首先，我们需要在Django设置文件中定义数据库配置，如代码所示。这里，我在本地连接了两个多个Postgres数据库。您可以使用数据库配置定义现有数据库；您不需要运行迁移或创建模型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="0ea2" class="lu lv iq bd lw lx mt lz ma mb mu md me jw mv jx mg jz mw ka mi kc mx kd mk ml bi translated">连接到多个数据库并返回数据帧作为响应的函数</h1><p id="40bf" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">现在，在数据库连接之后，我们使用Django内置函数导入数据库连接，并为每个数据库创建一个游标。游标用于直接执行原始SQL查询，从数据库中提取数据。我执行了原始SQL查询，并将该数据转换为<a class="ae my" href="https://pandas.pydata.org/pandas-docs/stable/reference/frame.html" rel="noopener ugc nofollow" target="_blank"> panda的</a>数据框，以便将数据转换为所需的格式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c14c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我为两个数据库定义了两个游标。有两个独立的函数，因此返回数据框是来自不同数据库的API响应，如游标中定义的那样。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h1 id="550e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated"><strong class="ak">结论</strong></h1><p id="c5d8" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我们在Django设置文件中定义了数据库连接。我们用不同的游标连接数据库，并在这些连接上执行原始SQL查询。查询结果随后被转换为pandas数据框，因此可以轻松地操作数据并将其转换为所需的响应格式。</p><p id="2b38" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这篇文章对你有所帮助。感谢阅读！</p></div></div>    
</body>
</html>