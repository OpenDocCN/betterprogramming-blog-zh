<html>
<head>
<title>Continuous Profiling for Go Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go应用程序的连续分析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/continuous-profiling-go-applications-8cdbdfdfc5ab?source=collection_archive---------10-----------------------#2022-01-18">https://betterprogramming.pub/continuous-profiling-go-applications-8cdbdfdfc5ab?source=collection_archive---------10-----------------------#2022-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c9da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用pyro scope——一个开源的连续分析平台</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f1248f2f755cd7e7e7a80b3d4d9fde39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*iXEUUTVkCHhDMlzIKQAbAg.gif"/></div></div></figure><h1 id="a394" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用Pyroscope分析Golang Rideshare应用程序</h1><p id="64cc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这个例子中，我展示了一个如何使用<a class="ae mi" href="https://github.com/pyroscope-io/pyroscope" rel="noopener ugc nofollow" target="_blank">pyro scope</a>——一个开源的分析库——使用连续分析来加速Golang应用程序的基本用例。</p><p id="96d2" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们模拟一家“rideshare”公司，该公司在<code class="fe mo mp mq mr b">main.go</code>中有三个端点:</p><ul class=""><li id="c2a3" class="ms mt it lo b lp mj ls mk lv mu lz mv md mw mh mx my mz na bi translated"><code class="fe mo mp mq mr b">/bike</code>:调用<code class="fe mo mp mq mr b">OrderBike(searchRadius)</code>函数订购一辆自行车</li><li id="9dac" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated"><code class="fe mo mp mq mr b">/car</code>:调用<code class="fe mo mp mq mr b">OrderCar(searchRadius)</code>函数订车</li><li id="ff3e" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated"><code class="fe mo mp mq mr b">/scooter</code>:调用<code class="fe mo mp mq mr b">OrderScooter(searchRadius)</code>函数订购踏板车</li></ul><p id="8b5e" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我还模拟了在3个不同地区运行3个不同的服务器(通过<a class="ae mi" href="https://github.com/pyroscope-io/pyroscope/blob/main/examples/golang-push/rideshare/docker-compose.yml" rel="noopener ugc nofollow" target="_blank"> docker-compose.yml </a></p><ul class=""><li id="fe8a" class="ms mt it lo b lp mj ls mk lv mu lz mv md mw mh mx my mz na bi translated">美国东部-1</li><li id="9f1a" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">美国西部1号公路</li><li id="a313" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">欧盟-西方-1</li></ul><p id="73b1" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">Pyroscope最有用的功能之一是能够以对您有意义的方式标记您的数据。在这种情况下，我们有两个自然划分，因此我们对数据进行“标记”来表示它们:</p><ul class=""><li id="0c28" class="ms mt it lo b lp mj ls mk lv mu lz mv md mw mh mx my mz na bi translated"><code class="fe mo mp mq mr b">region</code>:静态标记运行代码的服务器区域</li><li id="440d" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated"><code class="fe mo mp mq mr b">vehicle</code>:动态标记端点(类似于如何标记控制器轨道)</li></ul></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c57c" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">用静态区域标记轮廓</h1><p id="da3d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">标记静态的东西，比如<code class="fe mo mp mq mr b">region</code>，可以在<code class="fe mo mp mq mr b">main()</code>函数的初始化代码中完成:</p><pre class="kj kk kl km gt ns mr nt nu aw nv bi"><span id="4e2e" class="nw kv it mr b gy nx ny l nz oa"> pyroscope.Start(pyroscope.Config{<br/>  ApplicationName: "ride-sharing-app",<br/>  ServerAddress:   serverAddress,<br/>  Logger:          pyroscope.StandardLogger,<br/>  Tags:            map[string]string{"region": os.Getenv("REGION")},<br/> })</span></pre><h1 id="3c86" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">在函数中动态标记配置文件</h1><p id="fdc6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">可以在我们的实用函数<code class="fe mo mp mq mr b">FindNearestVehicle()</code>中使用<code class="fe mo mp mq mr b">pyroscope.TagWrapper()</code>更动态地标记一些东西，就像我们对<code class="fe mo mp mq mr b">vehicle</code>标记所做的那样:</p><pre class="kj kk kl km gt ns mr nt nu aw nv bi"><span id="7354" class="nw kv it mr b gy nx ny l nz oa">func FindNearestVehicle(search_radius int64, vehicle string) {<br/> pyroscope.TagWrapper(context.Background(), pyroscope.Labels("vehicle", vehicle), func(ctx context.Context) {<br/>       <br/>        // Mock "doing work" to find a vehicle<br/>        var i int64 = 0<br/>        start_time := time.Now().Unix()<br/>        for (time.Now().Unix() - start_time) &lt; search_radius {<br/>             i++<br/>        }<br/>     })<br/>}</span></pre><p id="b273" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">其功能是:</p><ol class=""><li id="0491" class="ms mt it lo b lp mj ls mk lv mu lz mv md mw mh ob my mz na bi translated">它添加了标签<code class="fe mo mp mq mr b">pyroscope.Labels("vehicle", vehicle)</code></li><li id="6529" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh ob my mz na bi translated">它执行<code class="fe mo mp mq mr b">FindNearestVehicle()</code>功能</li><li id="8ea5" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh ob my mz na bi translated">在程序块结束之前，它(在幕后)从应用程序中移除<code class="fe mo mp mq mr b">pyroscope.Labels("vehicle", vehicle)</code>,因为该程序块已经完成</li></ol><h1 id="2ec6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用火焰图显示性能瓶颈</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/15b04b18778a9df1d896e1692fc482b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpFFFjA6BMVjy0Z8GdnPfQ.jpeg"/></div></div></figure><p id="874b" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">分析来自应用程序的概要文件输出的第一步是注意到<em class="od">最大的节点</em>，这是应用程序花费最多资源的地方。在这种情况下，恰好是<code class="fe mo mp mq mr b">OrderCar()</code>函数。</p><p id="843a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">使用Pyroscope包的好处是，现在我们可以进一步调查为什么<code class="fe mo mp mq mr b">OrderCar()</code>函数有问题。标记<code class="fe mo mp mq mr b">region</code>和<code class="fe mo mp mq mr b">vehicle</code>让我们可以测试两个好的假设:</p><ul class=""><li id="3d9c" class="ms mt it lo b lp mj ls mk lv mu lz mv md mw mh mx my mz na bi translated"><code class="fe mo mp mq mr b">/car</code>端点代码有问题</li><li id="df01" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">我们的一个地区出了问题</li></ul><p id="1263" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">要对此进行分析，我们可以从“选择标签”下拉列表中选择一个或多个标签:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/122bc6f041e3bf25aae631b0bc293f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/0*meOdCoryLbeWpM42.png"/></div></figure><h1 id="ad82" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">使用标签缩小性能问题的范围</h1><p id="a4dd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">知道<code class="fe mo mp mq mr b">OrderCar()</code>函数有问题，我们会自动选择那个标签。然后，在检查了多个<code class="fe mo mp mq mr b">region</code>标签之后，通过查看时间线可以清楚地看到<code class="fe mo mp mq mr b">us-west-1</code>区域存在问题，它在高CPU时间和低CPU时间之间交替。</p><p id="5375" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">我们还可以看到，<code class="fe mo mp mq mr b">mutexLock()</code>函数在此期间几乎消耗了70%的CPU资源。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/ef6b7c892e02e53928871cbe29e2df46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1n3Ys2bCs67WyQqlsov07w.jpeg"/></div></div></figure><h1 id="c6c0" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">比较两个时间段的配置文件</h1><p id="64f7" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用Pyroscope的“比较视图”,我们可以从时间线中选择两个不同的时间范围来比较生成的火焰图。左侧时间线上的粉色部分表示左侧火焰图，右侧的蓝色部分表示右侧火焰图。</p><p id="833a" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">当我们选择一个低CPU利用率的时间段和一个高CPU利用率的时间段时，我们可以看到在 <code class="fe mo mp mq mr b"><strong class="lo iu">mutexLock()</strong></code> <strong class="lo iu">函数中有<strong class="lo iu">不同的行为，它在低CPU时间占用33%的CPU，在高CPU时间占用71%的CPU。</strong></strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/25da94dc22968274d6f572ff142ed95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZork8gHgAPHYB6cjAfgbQ.jpeg"/></div></div></figure><h1 id="02df" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">可视化两个火焰图之间约112%的性能差异</h1><p id="6bb6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">虽然在这种情况下，差异在比较视图中非常明显，但有时两个火焰图之间的差异在彼此重叠的情况下会更明显。在不改变任何参数的情况下，我们只需选择“差异视图”选项卡，就可以看到以颜色编码的差异火焰图表示的差异。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/5d264a76a16a21768df3b2898a5660bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbsaSsU6nKUyaYyiimTMZg.jpeg"/></div></div></figure><h1 id="179d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">剖析的更多用例</h1><p id="8b02" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">无论您是从事业余项目的开发人员，还是想知道“如何加快我的go应用程序”的devops工程师，Pyroscope都有许多使用案例，可以让您轻松了解如何分析您的应用程序。一些例子是:</p><ul class=""><li id="a0b5" class="ms mt it lo b lp mj ls mk lv mu lz mv md mw mh mx my mz na bi translated">标记Kubernetes属性</li><li id="3c5c" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">标记控制器</li><li id="689b" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">标记区域</li><li id="899c" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">标记队列中的作业</li><li id="d9bc" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">标记提交</li><li id="e52a" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">标记暂存或生产环境</li><li id="b41b" class="ms mt it lo b lp nb ls nc lv nd lz ne md nf mh mx my mz na bi translated">标记他们测试套件的不同部分</li></ul><h1 id="f3da" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">未来路线图</h1><p id="3729" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你想试试这个例子，看看有什么方法可以让它适应你的Go应用，这里有一个github 上这个<a class="ae mi" href="https://github.com/pyroscope-io/pyroscope/blob/main/examples/golang-push/README.md" rel="noopener ugc nofollow" target="_blank">例子的链接。持续分析已经成为一种越来越流行的工具，用于监控和调试性能问题(可以说是可观察性的第四个支柱)。</a></p><p id="0388" class="pw-post-body-paragraph lm ln it lo b lp mj ju lr ls mk jx lu lv ml lx ly lz mm mb mc md mn mf mg mh im bi translated">如果你有关于<a class="ae mi" href="https://pyroscope.io" rel="noopener ugc nofollow" target="_blank">火镜</a>如何改进的想法，请随意在GitHub页面上写问题！感谢您的阅读。</p></div></div>    
</body>
</html>