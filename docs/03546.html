<html>
<head>
<title>Build an Endless Scrolling List With SwiftUI List and Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用SwiftUI List和Combine构建一个无止境的滚动列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-an-endless-scrolling-list-with-swiftui-combine-and-urlsession-8a697a8318cb?source=collection_archive---------11-----------------------#2020-02-17">https://betterprogramming.pub/build-an-endless-scrolling-list-with-swiftui-combine-and-urlsession-8a697a8318cb?source=collection_archive---------11-----------------------#2020-02-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="08b2" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">让我们制作一个无限滚动的黑客新闻API提要</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/332f289deda6e5fff3497bb8c901d44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DghQ8cLq9JGeYByPpLeBQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@magicetea?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">冰茶</a>在<a class="ae kz" href="https://unsplash.com/s/photos/list?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="6977" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">苹果的反应式编程框架<a class="ae kz" href="https://developer.apple.com/documentation/combine" rel="noopener ugc nofollow" target="_blank">结合</a>的引入使得<code class="fe lw lx ly lz b">URLSession</code>和其他一些基础类型更加强大。</p><p id="f365" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">URLSession</code>和它的出版商(<code class="fe lw lx ly lz b">dataTaskPublisher</code>)真的是打了兴奋剂，允许我们做很多事情。具体来说，Combine操作符让我们可以轻松地解码、重试、处理错误和链接多个请求，等等。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="99fa" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">我们的目标</h1><p id="1cb7" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">这段代码的目标是构建一个SwiftUI无限滚动列表。为此，我们将在iOS应用程序中的黑客新闻API上使用Combine和<code class="fe lw lx ly lz b"><strong class="lc iv">URLSession</strong></code>。</p><p id="1c18" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果您对Combine框架不熟悉，我建议您在继续之前浏览一下“<a class="ae kz" href="https://medium.com/better-programming/a-deep-dive-into-the-combine-framework-in-swift-cffdfcc6f32c" rel="noopener">Swift</a>中的Combine框架深度剖析”。</p><p id="a0cd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在这一部分结束时，你将能够实现以下结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ne"><img src="../Images/21fd4acc4031abb66b8b53a3a3682d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/1*q9gEDLW54pkeAJc4gsTUKA.gif"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="f38c" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">入门指南</h1><p id="6aca" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">要设置一个SwiftUI列表来显示来自web API的数据，我们需要设置一个<code class="fe lw lx ly lz b">ObservableObject</code>类，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="c2e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">map操作符将API结果转换成一个新的publisher，它从API响应中返回<code class="fe lw lx ly lz b">data</code>。</p><p id="3078" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">重要的是将<code class="fe lw lx ly lz b">receive(on:)</code>设置到主线程以更新列表，并将<code class="fe lw lx ly lz b">store</code>设置到可取消实例中的订阅，以保持其活动。</p><p id="de93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将在下一步使用这些数据，通过使用如下所示的<code class="fe lw lx ly lz b">Codable</code>协议来解码JSON:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="0682" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">HNItem</code>结构需要符合SwiftUI列表的<code class="fe lw lx ly lz b">Identifiable</code>协议，以区分每一行。</p><p id="a83f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">API的结果设置在<code class="fe lw lx ly lz b">HackerNewsFeed</code>类的<code class="fe lw lx ly lz b">hnItems</code>属性上。由于它有一个已发布的属性包装器，这些更改反映在SwiftUI列表中，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="6594" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随后，我们在模拟器中得到以下结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nh"><img src="../Images/4e0199dc84df5d8b1cd32de2ef4069aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*thw1AK3JrD6kAr6pz_jA9g.png"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">没有无限滚动的SwiftUI列表</p></figure><p id="7523" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">至此，我们已经在SwiftUI列表中设置了<code class="fe lw lx ly lz b">URLSession</code>结果。但是这个列表还不能无限滚动。我们来配置一下。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="d698" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">SwiftUI列表无限滚动</h1><p id="6244" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">目前，SwiftUI不提供对滚动监听器的内置支持。幸运的是，有一个解决办法。</p><p id="e56b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要在SwiftUI列表上设置无限滚动，我们需要在代码中处理以下场景:</p><ul class=""><li id="7659" class="ni nj iu lc b ld le lg lh lj nk ln nl lr nm lv nn no np nq bi translated">通过对列表的行使用<code class="fe lw lx ly lz b">onAppear</code>方法，我们可以确定用户何时到达最后一项，并相应地调用下一页的API请求。</li><li id="3fde" class="ni nj iu lc b ld nr lg ns lj nt ln nu lr nv lv nn no np nq bi translated">为了防止重复API请求并确保网络请求同步，我们将使用enum来跟踪状态。</li></ul><p id="a940" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我们可以为错误处理设置另一个枚举。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="a15d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">扩展了<code class="fe lw lx ly lz b">ObservableObject</code>的<code class="fe lw lx ly lz b">HackerNewsFeed</code>类的更新代码如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="840f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们对上面代码中的<code class="fe lw lx ly lz b">fetchStories</code>函数做了一些改动:</p><ul class=""><li id="84d5" class="ni nj iu lc b ld le lg lh lj nk ln nl lr nm lv nn no np nq bi translated">在请求没有返回结果之前，<code class="fe lw lx ly lz b">pageStatus</code>枚举被设置为loading。</li><li id="af28" class="ni nj iu lc b ld nr lg ns lj nt ln nu lr nv lv nn no np nq bi translated"><code class="fe lw lx ly lz b">tryMap</code>用于代替<code class="fe lw lx ly lz b">map</code>操作符处理网络错误。</li><li id="b1e2" class="ni nj iu lc b ld nr lg ns lj nt ln nu lr nv lv nn no np nq bi translated"><code class="fe lw lx ly lz b">tryFilter</code>用于处理用户特定的错误。在我们的例子中，当达到API请求限制时，<code class="fe lw lx ly lz b">exhaustiveNbHits</code>属性作为<code class="fe lw lx ly lz b">false</code>返回。所以我们抛出适当的错误，这触发了<code class="fe lw lx ly lz b">sink</code>中的失败。</li><li id="e97e" class="ni nj iu lc b ld nr lg ns lj nt ln nu lr nv lv nn no np nq bi translated"><code class="fe lw lx ly lz b">endOfList</code>是一个新发布的属性，用于在某些错误时触发警告对话框。</li></ul><p id="fe79" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">shouldLoadMore</code>函数决定在用户滚动期间何时触发下一个API请求。在列表行的<code class="fe lw lx ly lz b">onAppear</code>期间调用，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nf ng l"/></div></figure><p id="1e8b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这样做，我们将得到如前所示的输出。</p><p id="ae36" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们在应用程序中使用的Hacker News API有1000个结果的限制。到达滚动的末尾时，我们将看到如下所示的警告对话框:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ne"><img src="../Images/573e5ae3309193f4f45641468aa4b8d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/1*hSw2NB4fWejzU0NLNSf8Lw.gif"/></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="3a39" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="0de2" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">我们能够使用SwiftUI和Combine构建一个黑客新闻故事无止境滚动新闻订阅应用程序。</p><p id="8b08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">接下来，您可以使用<code class="fe lw lx ly lz b">replaceError</code>或<code class="fe lw lx ly lz b">catch</code>操作符来处理JSON中的解析问题，并设置一个恢复发布器。</p><p id="857e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，您可以微调<code class="fe lw lx ly lz b">shouldLoadMore</code>函数，在用户到达最后一个项目之前加载下一批结果(可能在用户到达倒数第三个项目时触发请求？).</p><p id="0540" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">上述SwiftUI iOS应用程序的代码可以在<a class="ae kz" href="https://github.com/anupamchugh/iowncode/tree/master/SwiftUICombineURLSession" rel="noopener ugc nofollow" target="_blank"> GitHub存储库</a>中找到。</p><p id="0b74" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一篇就到此为止——感谢阅读。</p></div></div>    
</body>
</html>