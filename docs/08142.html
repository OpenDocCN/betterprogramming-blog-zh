<html>
<head>
<title>Closures Made Simple With Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang简化了闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/closures-made-simple-with-golang-69db3017cd7b?source=collection_archive---------1-----------------------#2021-03-31">https://betterprogramming.pub/closures-made-simple-with-golang-69db3017cd7b?source=collection_archive---------1-----------------------#2021-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6899" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在Go中使用闭包和匿名函数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a8b8cfa7114904616345451b1875a6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tsWBYTk_Rc9grpzQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@mr_vero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">欧文·史密斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="fbf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Golang中，闭包是引用其作用域之外的变量的函数。闭包可以比创建它的作用域更长寿。因此，它可以访问该范围内的变量，即使在该范围被销毁之后。</p><p id="a9ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在深入研究闭包之前，您需要理解什么是<strong class="lb iu">匿名函数</strong>。</p><h1 id="8484" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Go中有哪些匿名函数？</h1><p id="86d1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">匿名函数是没有名字的函数。</p><p id="c24f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们创建一个常规函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="626c" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">func</strong> send(message string) {<br/>    fmt.Println(message)<br/>}</span></pre><p id="65d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样称呼它:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="425f" class="mx lw it mt b gy my mz l na nb">send("Hi, it's me")</span></pre><p id="12dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="7f6e" class="mx lw it mt b gy my mz l na nb">Hi, it's me!</span></pre><p id="662a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建这个函数的匿名版本:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="18b5" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">func</strong> (message string) {<br/>    fmt.Println(message)<br/>}("Hi, it's me!")</span></pre><p id="8681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="cfb5" class="mx lw it mt b gy my mz l na nb">Hi, it's me!</span></pre><p id="6064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数类似于常规函数，只是它没有名称。此外，在本例中，您直接在定义后调用函数。</p><p id="1433" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们通过创建一个返回函数的函数来使用匿名函数。</p><h2 id="4351" class="mx lw it bd lx nc nd dn mb ne nf dp mf li ng nh mh lm ni nj mj lq nk nl ml nm bi translated">返回一个函数的函数</h2><p id="8d3e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你可能见过返回整数、字符串等的函数。但是你知道函数可以返回函数吗？</p><p id="5991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们创建一个返回匿名函数的函数:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a921" class="mx lw it mt b gy my mz l na nb"><strong class="mt iu">func</strong> give_me_a_func() func(string) {<br/>    <strong class="mt iu">return</strong> func(message string){<br/>        fmt.Println(message)<br/>    }<br/>}</span></pre><ul class=""><li id="25cf" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">这个函数的返回类型是<code class="fe nw nx ny mt b">func(string)</code>，因为您<strong class="lb iu">返回了</strong>一个以字符串作为参数的函数。</li></ul><p id="ee87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们来玩玩<code class="fe nw nx ny mt b">give_me_a_func()</code>。</p><p id="df7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以创建一个变量来存储由<code class="fe nw nx ny mt b">give_me_a_func()</code>返回的函数。然后可以像调用函数一样调用该变量:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="974c" class="mx lw it mt b gy my mz l na nb">send_func := give_me_a_func()<br/>send_func("Hi, it's me!")</span></pre><p id="cd5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0fc3" class="mx lw it mt b gy my mz l na nb">Hi, it's me!</span></pre><p id="12c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你知道什么是匿名函数以及它是如何工作的了。你也知道一个函数可以返回另一个函数。</p><p id="c22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们来谈谈Go中的闭包。</p><h1 id="559f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Go中的闭包是什么？</h1><p id="34b7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">闭包是一个引用自身函数体(作用域)之外的变量的函数。</p><p id="d7c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，闭包是一个内部函数，它可以访问创建它的作用域中的变量。即使当外部函数完成执行并且作用域被销毁时也是如此。</p><p id="5c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这意味着什么。</p><p id="1648" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个名为<code class="fe nw nx ny mt b">incrementor()</code>的函数。这个函数返回一个匿名函数。换句话说，它返回一个闭包。这个闭包是一个返回整数的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="69a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个变量来存储由<code class="fe nw nx ny mt b">incrementor()</code>返回的函数。让我们也称它几次:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="452f" class="mx lw it mt b gy my mz l na nb">next := incrementor()  // next is a <strong class="mt iu">function</strong> returned by incrementor</span><span id="0678" class="mx lw it mt b gy ob mz l na nb">fmt.Println(next())    // prints 1<br/>fmt.Println(next())    // prints 2<br/>fmt.Println(next())    // prints 3</span></pre><p id="c5a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nw nx ny mt b">next()</code>增加在<code class="fe nw nx ny mt b">incrementor</code>函数中声明的变量<code class="fe nw nx ny mt b">i</code>。但是它怎么知道<code class="fe nw nx ny mt b">i</code>是什么？</p><p id="ca6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是可行的，因为闭包是一个内部函数，它可以访问创建它的作用域中的所有变量。这甚至适用于外部函数完成执行后的<strong class="lb iu">。</strong></p><p id="7fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看<code class="fe nw nx ny mt b">incrementor()</code>函数的作用域(花括号内的所有内容):</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="a85e" class="mx lw it mt b gy my mz l na nb">i := 0<br/><strong class="mt iu">return</strong> <strong class="mt iu">func</strong>() int {<br/>    i++<br/>    return i<br/>}</span></pre><ul class=""><li id="2af4" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">当<code class="fe nw nx ny mt b">incrementor()</code>执行结束时，上述范围被破坏。但是闭包仍然能够访问和更新作用域的变量，即使它已经不存在了。</li></ul><p id="35f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就完成了对Go中闭包的介绍。请随意使用这些示例，以便更深入地理解正在发生的事情。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="075e" class="lv lw it bd lx ly oj ma mb mc ok me mf jz ol ka mh kc om kd mj kf on kg ml mm bi translated">结论</h1><p id="5a04" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">匿名函数是没有名字的函数。</p><p id="6627" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Go中，函数可以返回其他函数。例如，这可以通过返回匿名函数来实现。</p><p id="90fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">闭包是一个引用自身函数体外部变量的函数值。闭包能够比定义它的函数的作用域更长久。这意味着它可以访问作用域外的变量。</p><p id="7ffb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望你觉得这很有用。</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><h1 id="a7e0" class="lv lw it bd lx ly oj ma mb mc ok me mf jz ol ka mh kc om kd mj kf on kg ml mm bi translated">资源</h1><div class="oo op gp gr oq or"><a href="https://golang.org/doc/" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">证明文件</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">Go编程语言是一个开源项目，旨在提高程序员的工作效率。围棋富有表现力，简洁…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">golang.org</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div></div></div>    
</body>
</html>