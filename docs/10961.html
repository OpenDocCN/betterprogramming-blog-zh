<html>
<head>
<title>Optimizing an Algorithm to Delete Multiple Keys in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化删除JavaScript中多个键的算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optimizing-an-algorithm-to-delete-multiple-keys-in-javascript-2a95a8563eb1?source=collection_archive---------12-----------------------#2022-02-07">https://betterprogramming.pub/optimizing-an-algorithm-to-delete-multiple-keys-in-javascript-2a95a8563eb1?source=collection_archive---------12-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2491" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">发现、隔离和解决实际应用中的算法难题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5227167433dd6c070f42a9f444f570ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pf1dqCBgZSPgpLdHUBXjHw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗曼·辛克维奇在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个客户提出了他们从Redis缓存中批量删除太慢的问题。虽然最初，我认为Redis是错的，鉴于删除数千个键并不是最好的，但我错了。请继续关注我寻找、隔离和解决算法挑战的思维过程。</p><h1 id="f45d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">初始调试—寻找瓶颈</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/5e8f6cb35e4a1aedbd198aa9944b5a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dke1GDGwleExzoCDcFTTIw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@amseaman?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德鲁·西曼</a>在<a class="ae ky" href="https://unsplash.com/s/photos/bottleneck?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在做侧写之前，我的大脑开始创建假设，关于什么会很慢的理论。有时它是正确的，但真正的测试是科学地证明瓶颈，用一个分析器确认80%的处理时间花在哪里，然后用20%的努力应用一个修复，获得80%的改进。</p><p id="4392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我调试了Redis缓存删除，用了4分钟响应时间中的5秒钟。那么如果Redis没有错，那会是什么呢？</p><p id="e13f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">仿形</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mo"><img src="../Images/053ebfddd7168c9a6365cb11f7115382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zw07FHugdpb2KtDd.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">示例分析器</p></figure><p id="c1a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我运行了profiler，这是一个可以告诉你每个函数花费了多少时间的工具。结果是一个函数占用了90%的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/71a5b9da79db28e03e550b478a10e381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Z4wOhOrfnGJzI6UsYKtXg.png"/></div></div></figure><p id="2f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这种方式，分析器可以完成它的工作，并将结果分成如下几部分:</p><ul class=""><li id="bb5c" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi translated">方法1: 90%</li><li id="32b8" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">方法2: 3%</li><li id="0e42" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">方法三:3%</li><li id="3872" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">方法三:3%</li></ul><h2 id="59a9" class="ne lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">瓶颈</h2><p id="2d96" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">在阅读了Method1之后，我明白了它的工作是从字符串列表中移除许多键，但它不是简单的移除。它删除了所有从它们开始的键，以及其他集合中的任何键</p><p id="3250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如说。假设我们有一个键列表:</p><ul class=""><li id="a970" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi translated"><strong class="lb iu">“一个”</strong></li><li id="10c7" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">“ab”</li><li id="dc1c" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">“abc”</li><li id="831b" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">“abcd”</li><li id="4e98" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><strong class="lb iu">“BCD”</strong></li><li id="cfe6" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">" bcdf "</li><li id="873c" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">" bdcf "</li></ul><p id="8bdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望删除任何以</p><ul class=""><li id="41b6" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi translated">“ab”</li><li id="412a" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">" bcdf "</li></ul><p id="1388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过滤后，我们应该剩下:</p><ul class=""><li id="cdd6" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi translated">" a "</li><li id="7a8d" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">" bdcf "</li></ul><p id="5de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用一种简单的方法来实现这一目标，我们可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="b4e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的问题在于foreach键，我们需要遍历前缀列表来删除集合，以检查它们是否以。这就引出了一个大O(键*前缀)</p><p id="7f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给我们带来了一个大O(键*前缀)。在这种情况下，它是:</p><blockquote class="nx"><p id="5110" class="ny nz it bd oa ob oc od oe of og lu dk translated">o(键*前缀)</p></blockquote><p id="ca0c" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">有34000个键和27000个前缀在一个指数大O()中运行，它过去在运行时会伤害计算机:</p><blockquote class="nx"><p id="4ac7" class="ny nz it bd oa ob oc od oe of og lu dk translated">O(34000 * 27000) = 917，000，000次迭代</p></blockquote><figure class="on oo op oq or kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/369a0dc7dfdd52a6165cc81995fa89e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JmUims5hdvVi0ru36XrUFw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">每个前缀的可视化表示必须循环遍历这些键</p></figure><blockquote class="os ot ou"><p id="7a08" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">什么是O(键*前缀)</p><p id="1ee5" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">这叫做大O符号，用来描述算法的复杂性。你可以在这里得到更多的信息。随着开发人员资历的提高，能够识别算法的大o符号是一项重要的技能。</p></blockquote><h2 id="bdd8" class="ne lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">回到问题上来</h2><p id="e7fb" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">通常，当您面临从另一个数组中移除多个键的挑战时，您会使用编程、Hashsets和字典的作弊代码。</p><p id="44fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="47ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这解决了这个问题，因为从集合中删除是O(1)，所以我们只需要迭代一次键列表来构建集合，然后在键中删除一次。将我们带到:</p><blockquote class="nx"><p id="b31b" class="ny nz it bd oa ob oc od oe of og lu dk translated">大O(键+前缀)</p></blockquote><p id="19dd" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">但在这种情况下，我们不能作弊。没有一个简单的结构来解决我们的数据算法问题。这是一个典型的leetcode挑战=)</p><blockquote class="nx"><p id="e995" class="ny nz it bd oa ob oc od oe of og lu dk translated">但是我们可以从Set解决方案中获得灵感，我们可以索引我们的数据以减少查找成本吗？</p></blockquote><p id="9a98" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">在我的白板上画满了图表之后，这就是我要做的。假设你有那些钥匙:</p><ul class=""><li id="c5f7" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi">202012</li><li id="e624" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi">202013</li><li id="e930" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi">202014</li></ul><p id="38bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是要删除的前缀:</p><ul class=""><li id="595f" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi">20201</li></ul><p id="bdee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以基于关键字的每个字母创建一个树:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/fa32d1dd9e04dd90ee4f3f51cf570eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*KE5d7F9spxWomsiTccxxlA.png"/></div></figure><p id="f9f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，当您查看某个内容是否以前缀开头时，您可以在树中导航，直到前缀的最后一个字母节点，然后删除该节点及其子节点。将我们的大o符号带到:</p><blockquote class="nx"><p id="1a0a" class="ny nz it bd oa ob oc od oe of og lu dk translated">o(键+前缀)</p><p id="0dfd" class="ny nz it bd oa ob oc od oe of og lu dk translated">O(34000 + 27000) = 61，000而不是</p><p id="5d56" class="ny nz it bd oa ob oc od oe of og lu dk translated">o(34000 * 27000)= 9.17亿</p></blockquote><p id="9439" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">以前，整个端点的响应时间为1.8分钟；这一改，就到了6秒。这是算法效率的巨大差异。此外，它可以有效地将指数转换为线性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/d2be56a0f3ffc15421c32cce63b7c13b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KszA3AxFDTRp3xdLAFUVMg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">指数/线性图表比较</p></figure><p id="6b14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我想起了这个笑话:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi gj"><img src="../Images/96daa9523ca877863e55ee838443fd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XWtBEGvgr_zLdukp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">信用:<a class="pb pc ep" href="https://medium.com/u/18c0b276923b?source=post_page-----2a95a8563eb1--------------------------------" rel="noopener" target="_blank">纳特·艾莉森</a></p></figure><p id="c3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是解决算法挑战的最佳方式吗？也许，从我在LeetCode上看到的其他问题的解决方案来看，可能有更有效的方法来使用更少的内存甚至更高的CPU效率来做到这一点。</p><blockquote class="os ot ou"><p id="ad18" class="kz la ov lb b lc ld ju le lf lg jx lh ow lj lk ll ox ln lo lp oy lr ls lt lu im bi translated">如果你能想到一个更有效的方法，请随时回复或发送给我你的解决方案。</p></blockquote><p id="0f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这将响应时间提高了94%以上，因此它已经实现了我的20%努力80%结果的目标。</p><h1 id="5e99" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">真正的JavaScript实现</h1><p id="3501" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">如果你想看实际操作，这里有一个<a class="ae ky" href="https://github.com/RaphaelYoshiga/algorithm-tree" rel="noopener ugc nofollow" target="_blank">实际的JavaScript实现</a>:</p><h2 id="155a" class="ne lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">测试案例示例:</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="f7c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用我们的简单实现运行这些</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/c7199679ed96e2a746182f9de21eeff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*Zfa44imkNsg-lyQZM_WCQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有大O(键*前缀)= 12.2秒的结果</p></figure><h2 id="87f1" class="ne lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">实现树索引方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="6244" class="ne lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">说明</h2><p id="28b2" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">第一步是构建我们的树，然后遍历所有前缀，从树中删除它们，然后基于剩余的树分支重新构建我们的列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/fa32d1dd9e04dd90ee4f3f51cf570eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*KE5d7F9spxWomsiTccxxlA.png"/></div></figure><p id="768b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/86a32c44959da61e6d0a4d87421bcd99.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*pwhuXa1vaUUzlp1PamiYpA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">优化前12.2秒，优化后65毫秒的最终结果</p></figure><h1 id="2742" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="3776" class="pw-post-body-paragraph kz la it lb b lc nq ju le lf nr jx lh li ns lk ll lm nt lo lp lq nu ls lt lu im bi translated">我希望你能从这里学到三点:</p><ul class=""><li id="9829" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi translated">1 —科学地识别性能瓶颈</li><li id="5b16" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">2 —熟能生巧</li><li id="c873" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">3-能够快速发现代码中的大O符号。</li></ul><p id="142b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在识别性能问题时，可以先了解最初问题的想法，但是最终，您需要通过测量代码在哪里花费时间来证明。</p><p id="3a14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一点是训练；我只能在练习算法网站后解决这个问题。作为钢琴家，在大舞台上表演，如果在主舞台之外训练，收获会更大。</p><p id="2707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，除了度量之外，你还得开发你的大鼻子，这样你就能快速找出可能导致问题的代码。</p></div><div class="ab cl pf pg hx ph" role="separator"><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk pl"/><span class="pi bw bk pj pk"/></div><div class="im in io ip iq"><h2 id="7d62" class="ne lw it bd lx nf ng dn mb nh ni dp mf li nj nk mh lm nl nm mj lq nn no ml np bi translated">参考</h2><ul class=""><li id="1b31" class="mq mr it lb b lc nq lf nr li pm lm pn lq po lu mv mw mx my bi translated"><a class="ae ky" href="https://github.com/RaphaelYoshiga/algorithm-tree" rel="noopener ugc nofollow" target="_blank">源代码</a></li><li id="ec7e" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://medium.com/asos-techblog/a-beginners-guide-to-big-o-notation-f708dae31652" rel="noopener">大魔神解说</a></li></ul></div></div>    
</body>
</html>