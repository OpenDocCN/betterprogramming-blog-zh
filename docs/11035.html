<html>
<head>
<title>Why Using Navigation-Compose in Your Jetpack Compose App is a Bad Idea</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在你的Jetpack撰写应用程序中使用导航撰写是一个坏主意</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-using-navigation-compose-in-your-jetpack-compose-app-is-a-bad-idea-2b16e8751d89?source=collection_archive---------0-----------------------#2022-02-12">https://betterprogramming.pub/why-using-navigation-compose-in-your-jetpack-compose-app-is-a-bad-idea-2b16e8751d89?source=collection_archive---------0-----------------------#2022-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="66ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">知道导航写作的陷阱</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c44e3f4ef715b799cd480308686c6546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p0AsCwW8vfrxGui4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="63f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你正在阅读这篇文章，你可能会想:</p><p id="6d62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“嗯，我想知道在我的Jetpack Compose应用程序中使用什么来导航。我是应该像Google建议的那样使用导航合成，还是坚持使用片段，只在呈现视图时使用合成？”</p><p id="5e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将讲述我在Jetpack Compose应用程序中使用导航合成和片段的经历。你会学到哪种方法更好(在我看来),以及使用每种方法会遇到什么样的障碍。</p><h1 id="9c50" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">我们开始吧</h1><p id="32b4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你在谷歌上搜索“Jetpack Compose Navigation ”,你可能会看到导航合成库作为第一批结果之一。谷歌将其描述为一个新的导航组件，支持用Compose编写的应用程序，并声称“由于它，我们可以在组件之间导航，同时利用导航组件的基础设施和功能。”</p><p id="fa57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来很完美，但真的是这样吗？我们应该谈谈新的导航看起来像什么…</p><p id="9fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谷歌真的想创建一个框架，能够管理生命周期、导航和围绕它的一切，同时消除使用片段的需要。他们的想法是创建一个可组合的导航图(<code class="fe mt mu mv mw b"><a class="ae ky" href="https://developer.android.com/jetpack/compose/navigation#create-navhost" rel="noopener ugc nofollow" target="_blank">NavHost</a></code>)，而不是一个XML文件，我们可以在其中定义应用程序可以导航到的路线。其实仔细看，片段就是这样被navBackstackEntry代替的。不幸的是，它运行得不是很好，而且有很多问题。</p><h1 id="e049" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">路线路径</h1><p id="411e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先—路由路径。</p><p id="8da0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谷歌可能羡慕Flutter、React和其他类似的框架，并认为Android的最佳解决方案是在web应用程序中定义屏幕路径——尽管我们创建的是移动应用程序，而不是web应用程序，对吗？</p><p id="7ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对我们意味着什么？</p><p id="f0e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着每个路由看起来像一个URL结尾，例如</p><ul class=""><li id="347b" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated"><code class="fe mt mu mv mw b">/users </code> —用于用户列表屏幕</li><li id="dba7" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated"><code class="fe mt mu mv mw b">/users/2</code> —用于id = 2的用户的详细屏幕。</li></ul><p id="bda6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从现在开始，开发人员必须保持路径及其部分的顺序，记住它们及其参数，或者为各个屏幕创建常量，这已经意味着我们要开始比以前多得多的工作。</p><p id="d269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来发生的事情更令人困惑。</p><h1 id="6a90" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">导航参数</h1><p id="3b64" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">以前，使用片段和安全参数，我们可以在XML中定义给定片段的参数。当创建从一个屏幕到另一个屏幕的动作时，我们有一个自动生成的代码，要求我们输入正确类型的参数，并将它们打包到<code class="fe mt mu mv mw b">Bundle</code>中。接下来，要在目标片段中提取这些参数，我们可以使用<code class="fe mt mu mv mw b">by navArgs()</code> <strong class="lb iu"> </strong>委托，它会自动为我们完成。</p><p id="52f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能够将许多不同的类型作为参数传递，比如Int、String、Boolean等。还包括自定义的，比如枚举、可序列化的和可打包的。支持类型的完整列表可以在<a class="ae ky" href="https://developer.android.com/guide/navigation/navigation-pass-data#supported_argument_types" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="5e15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在导航作曲上也一样方便吗？<em class="lv">完全没有。</em></p><p id="17f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参数只能在给定路由的URL路径中传递，例如:</p><ul class=""><li id="bb47" class="mx my it lb b lc ld lf lg li mz lm na lq nb lu nc nd ne nf bi translated">路径参数— <code class="fe mt mu mv mw b">/users/{arg1}/details/{arg2}</code></li><li id="61d5" class="mx my it lb b lc ng lf nh li ni lm nj lq nk lu nc nd ne nf bi translated">或者更复杂的是，您还可以在问号后面传递查询参数和可选参数— <code class="fe mt mu mv mw b">/users/{arg1}/details?{arg2}={arg2_value}&amp;{arg3}={arg3_value}</code></li></ul><p id="f375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，不要忘记，对于您想要使用的每个目的地和参数，<em class="lv">您</em> <strong class="lb iu"> </strong>负责所有的类型安全。组合导航不会告诉你，你把一个整型参数错当成了一个字符串。这只会使应用程序崩溃。</p><p id="704e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个参数都必须在<code class="fe mt mu mv mw b">NavHost</code>的<code class="fe mt mu mv mw b">composable</code>中声明:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b4b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且随后也用适当的类型提取:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在，程序员不仅要自己管理所有的路径，他还必须记住特定屏幕采用什么参数，参数的键和数据类型以及它们的顺序。</p><p id="5ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会在编译时得到错误信息吗？没有。只有在应用程序运行时，才会出现错误或应用程序崩溃。</p><h1 id="ed1f" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一切都是一串</h1><p id="1157" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">此外，不要忘记，由于屏幕路径就像一个URL，每个参数都必须作为字符串传递，并且必须进行编码。</p><p id="0104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想将这个字符串作为参数传递:</p><pre class="kj kk kl km gt nn mw no np aw nq bi"><span id="92e4" class="nr lx it mw b gy ns nt l nu nv">val urlParam = "<a class="ae ky" href="https://translate.google.com/?hl=en&amp;tab=TT" rel="noopener ugc nofollow" target="_blank">https://translate.google.com/?hl=en&amp;tab=TT</a>"</span></pre><p id="da80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了导航，我们必须这样写:</p><pre class="kj kk kl km gt nn mw no np aw nq bi"><span id="1df3" class="nr lx it mw b gy ns nt l nu nv">navController.navigate("path/arg=${URLEncoder.encode(urlParam)}")</span></pre><p id="b428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后像这样接收它:</p><pre class="kj kk kl km gt nn mw no np aw nq bi"><span id="01a0" class="nr lx it mw b gy ns nt l nu nv">URLEncoder.decode(bundle.getString("arg_key"))</span></pre><p id="ecd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的是，如果您在包含<code class="fe mt mu mv mw b">‘\n’ </code>字符的字符串上使用<code class="fe mt mu mv mw b">URLEncoder.encode(…)</code>，它会因为<code class="fe mt mu mv mw b">‘%0A’</code>而崩溃，所以使它工作的唯一方法是首先使用<code class="fe mt mu mv mw b">Base64</code>编码。</p><p id="b37a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得导航组合API完全是非类型安全的。</p><h1 id="c759" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">枚举、可序列化和可打包的呢？</h1><p id="990f" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">就像我之前提到的，我们想要传递的任何参数，不管是什么类型，都必须转换成一个字符串，才能添加到路径中。</p><h2 id="392e" class="nr lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">枚举</h2><p id="97be" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">撰写导航不会让您将<code class="fe mt mu mv mw b">Enums</code> <strong class="lb iu"> </strong>作为参数传递，但这可以用不同的方式来完成。理论上，我们可以将它转换成一个字符串，并在目标屏幕上调用<code class="fe mt mu mv mw b">valueOf</code>方法来查找我们之前作为字符串传递的enum中的值。</p><h2 id="33ec" class="nr lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated"><strong class="ak">可打包的和可序列化的</strong></h2><p id="53e0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">这就是乐趣的开始。也不支持在组合导航中将<code class="fe mt mu mv mw b">Serializable</code>和<code class="fe mt mu mv mw b">Parcelable</code>作为导航参数传递。</p><p id="f40e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在网上看到很多人说，进入<code class="fe mt mu mv mw b">backStackEntry</code>参数并手动传递扩展<code class="fe mt mu mv mw b">Serializable</code>或<code class="fe mt mu mv mw b">Parcelable</code>的对象是可能的。</p><p id="a56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">然而… </strong> <br/>这只是一个谷歌不推荐的黑客行为，也没有给出任何保证这一定行得通。</p><p id="8325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就我个人而言，我遇到过很多这样传递参数导致应用程序崩溃的情况。</p><p id="8c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不相信我？去这里读读。</p><h2 id="8c68" class="nr lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">我们能做些什么吗？</h2><p id="c927" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">嗯，理论上…是的。我们可以将我们的<code class="fe mt mu mv mw b">Serializable</code>或<code class="fe mt mu mv mw b">Parcelable</code>对象转换成JSON，并将其作为字符串传递。我为那些想以这种方式传递参数的人感到难过。这是一种方法，但是它太愚蠢了，带来了太多不必要的样板文件和复杂性，我甚至不会考虑使用它。</p><h2 id="650b" class="nr lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated"><strong class="ak">更新</strong></h2><p id="72d4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">自从Compose版本1.0.3和NavigationX <code class="fe mt mu mv mw b">2.4.0-alpha10</code>以来，我们现在能够创建自定义的<code class="fe mt mu mv mw b">NavType</code>:</p><p id="2dec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你有一个这样的类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cdc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以这样定义<code class="fe mt mu mv mw b">NavType</code> <strong class="lb iu"> </strong>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎比我们以前拥有的要好，但是<strong class="lb iu"> </strong>仍然要求我们在内部使用JSON <strong class="lb iu"> </strong>。还可以想象一下，每当您想要传递一个Parcelable时，就创建一个新的定制<code class="fe mt mu mv mw b">NavType</code>。这只是给我们的应用程序添加了更多的样板代码。此外，Google的文档中没有提到这个解决方案也能与组合导航一起工作。</p><h1 id="9226" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">但是为什么呢？</h1><p id="bdda" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在主要的问题出现了——为什么？</p><p id="8485" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么导航排版是那样的？为什么它不支持可序列化，可打包，为什么它有这么多问题？</p><p id="5db4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很有可能Google希望鼓励开发者只传递对象的id，而不是它的静态副本。例如，如果我们操作房间数据库并使用Flow观察数据，这将是有意义的。例如，如果在此期间有什么东西改变了这个数据，那么用户会自动在屏幕上看到当前的值。</p><p id="a209" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">的确，也许在一些像这样的情况下，这是有意义的。不幸的是，经常有这样的情况，我们希望有意识地传递一个静态对象，或者至少传递它的一部分，以便用户可以立即看到屏幕上的数据。之后，我们可以在后台加载一些细节，或者简单地检查数据是否是最新的。</p><h1 id="9c82" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">只用片段</h1><p id="3921" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">好的，那么我应该如何使用Compose来避免这些问题呢？答案很简单。使用片段和旧导航。</p><h2 id="9452" class="nr lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated"><strong class="ak">您仍应使用片段的原因</strong></h2><p id="bd8b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">想用什么都可以:<strong class="lb iu"> XML </strong>，<strong class="lb iu"> Compose </strong>，你选。最简单的方法是将<code class="fe mt mu mv mw b"><strong class="lb iu">ComposeView</strong></code> <strong class="lb iu"> </strong>添加到<code class="fe mt mu mv mw b"><strong class="lb iu">Fragment</strong></code>视图中，并将给定<code class="fe mt mu mv mw b"><strong class="lb iu">Fragment</strong></code>的<code class="fe mt mu mv mw b"><strong class="lb iu">Composable</strong></code> <strong class="lb iu"> </strong>设置在那里。</p><p id="efa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不是<code class="fe mt mu mv mw b">LaunchedEffect</code>、<code class="fe mt mu mv mw b">DisposableEffect</code>之类的粉丝？你不必使用它们，因为你可以用老方法写一些代码，就像在片段中一样。</p><p id="606c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据你使用的DI框架，如果你使用导航合成，你也可能会遇到一些问题。<br/>在我目前的项目中，我们正在使用<code class="fe mt mu mv mw b">Koin</code>，不幸的是，在新的导航中<code class="fe mt mu mv mw b">SavedStateHandle</code>无法注入到<code class="fe mt mu mv mw b">ViewModel</code>中。这个问题当然要由Koin团队来修复，但是目前来说，如果你使用<code class="fe mt mu mv mw b">Fragments</code> <strong class="lb iu"> </strong>并使用<code class="fe mt mu mv mw b">by viewModel()</code> delegate注入<code class="fe mt mu mv mw b">ViewModel</code>就消失了。</p><h2 id="0709" class="nr lx it bd ly nw nx dn mc ny nz dp mg li oa ob mi lm oc od mk lq oe of mm og bi translated">当然，碎片并不完美。在这种情况下，你应该考虑他们的哪些问题？</h2><p id="4da1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，你在用片段。这可能一开始看起来很滑稽，但有些人不喜欢他们，例如，杰克·沃顿。简而言之，他说你可以使用片段，但背后攻击是一场噩梦。</p><p id="cc70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有更多的代码。毕竟，对于每个屏幕，您必须同时编写片段和组合。</p><p id="783b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件事是，您需要管理两个生命周期——片段生命周期和可组合生命周期。这乍一看似乎有问题，但幸运的是，有一个快速的方法来处理它。只需在<code class="fe mt mu mv mw b">ComposeView</code>上使用<code class="fe mt mu mv mw b">setViewCompositionStrategy</code>方法，并设置可组合组件的生命周期相对于片段的生命周期应该如何表现。</p><p id="10b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，您必须记住，当将一个<code class="fe mt mu mv mw b">Parcelable</code>对象作为一个安全的Args参数传递时，您还必须将它添加到proguard配置中，否则您的产品将会崩溃。</p><h1 id="ddba" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">摘要</h1><p id="a133" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">那么使用碎片是不是最好的解决方案呢？大概不会。</p><p id="fad5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，如果Google在Compose中为我们提供一个现成的、有效的、良好的导航API，那将是最好的。不幸的是，正如我之前提到的，我们现在可以忘记它。目前，我提出的解决方案是我自己使用的，我觉得还可以，至少目前是这样。</p><p id="1148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还应该记住，许多库和工具还没有100%支持Compose，有时用老方法、片段甚至XML编写东西的能力正是我们所需要的。</p><p id="ebd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><pre class="kj kk kl km gt nn mw no np aw nq bi"><span id="a0f4" class="nr lx it mw b gy ns nt l nu nv"><strong class="mw iu">Want to Connect?</strong></span><span id="68c9" class="nr lx it mw b gy oh nt l nu nv">✉️ Android Dev Newsletter — If you enjoy learning about Android like I do and want to stay up to date with the latest, worth reading articles, programming news and much more, consider <a class="ae ky" href="https://androiddevnews.com/" rel="noopener ugc nofollow" target="_blank">subscribing to my newsletter</a>.</span><span id="b400" class="nr lx it mw b gy oh nt l nu nv">🎙 Android Talks Podcast — If you’re a Polish speaker and want to listen to what I have to say about Android, architecture, security and other interesting topics, <a class="ae ky" href="https://androidtalks.buzzsprout.com/" rel="noopener ugc nofollow" target="_blank">check out my podcast</a></span></pre><p id="e210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以听听我做的关于这个话题的播客:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi nm l"/></div></figure></div></div>    
</body>
</html>