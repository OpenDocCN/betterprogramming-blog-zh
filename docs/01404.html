<html>
<head>
<title>Real-Time Search Engine With RxJS (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS的实时搜索引擎(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/real-time-search-engine-with-rxjs-part-2-6585d9394128?source=collection_archive---------6-----------------------#2019-09-06">https://betterprogramming.pub/real-time-search-engine-with-rxjs-part-2-6585d9394128?source=collection_archive---------6-----------------------#2019-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/606036a4fc7b20ae1b4f33ebc3b7580d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N_76P6EKQhVmEvHsI_6Vcw.png"/></div></div></figure><p id="bc7d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您好，这是本文的结论部分。你可以在这里找到第一部分<a class="ae kz" href="https://medium.com/better-programming/real-time-search-engine-with-rxjs-530cbadcde8c" rel="noopener"/>。在这一部分，我们将进行关注点的分离，(例如，我们将使我们的组件可重用)。因此，我们将创建两个新组件:</p><ol class=""><li id="26e1" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">搜索框:这将有我们的输入框，用户可以在其中键入搜索查询，我们将使用它来发出HTTP请求。响应将保存在搜索框组件中。</li><li id="e667" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">搜索结果:在HTTP请求之后，响应将从搜索框组件传递到这个搜索结果组件。所以基本上，搜索结果组件将只关心如何将我们的搜索结果呈现给用户。如何获取结果完全基于这个组件。</li></ol><p id="b4a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们开始吧。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="13cf" class="lv lw it bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">代码</h1><p id="72bd" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">让我们创建两个新组件。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/f7972267bc8cbf6debf5c49636139adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LlW51Sy-Vn8_H0Q3rJxSw.png"/></div></div></figure><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/357714ce0ed4c8aa377ae87e588e0c0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mFVpq8FWFfknFEGXB1hevQ.png"/></div></div></figure><p id="9263" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在在<code class="fe nd ne nf ng b">searchBox.css file</code>中，将我们在文章的<a class="ae kz" href="https://medium.com/better-programming/real-time-search-engine-with-rxjs-530cbadcde8c" rel="noopener">第1部分</a>中的代码移动到这个文件中。然后把这个放到<code class="fe nd ne nf ng b">.ts</code>文件中</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/b9c4879f53236cbf57a7264c2d511bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k3F_phTDp8sKEljrwqVTww.png"/></div></div></figure><p id="9e2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，那我做了什么？</p><ol class=""><li id="9548" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">我用一个<code class="fe nd ne nf ng b">@Output</code>指令制作了<code class="fe nd ne nf ng b">EventEmitter</code>类型的<code class="fe nd ne nf ng b">loading</code> <strong class="kd iu"> </strong>和<code class="fe nd ne nf ng b">searchResults</code>变量。这是因为它们的值可以作为事件发出。</li><li id="6ce6" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">在<code class="fe nd ne nf ng b">searchEntries()</code>函数中，当我们从HTTP请求中获得响应时，<code class="fe nd ne nf ng b">searchResult</code>事件会随响应一起发出。加载事件以“false”发出</li></ol><p id="f69d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这正是正在发生的事情。当用户在搜索框中键入内容时，按照<code class="fe nd ne nf ng b">debounce()</code>操作符中的说明等待几毫秒后，我们发出HTTP请求。此时，我们在加载发射器上发出一个错误。每当结果出现时，我们发出一个true，并在<code class="fe nd ne nf ng b">searchResult</code>发射器上发出结果。</p><p id="37f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以更新搜索组件的模板，它现在是我们的父组件，看起来像这样:</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/cbd84adbf3469f8ba3da84d86a18ccec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-lP0evcFi0JtM0SoMIZxBQ.png"/></div></div></figure><p id="509c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而<code class="fe nd ne nf ng b">.ts</code>文件看起来像:</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/6779ba2b037d76eaec6338210a092d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8WkF2ZDApX_6cEJP4Wx4Q.png"/></div></div></figure><p id="d21f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意我是如何使用输入绑定将<code class="fe nd ne nf ng b">searchresult</code>发送给搜索结果组件的。</p><p id="f52e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们更新搜索结果组件，以接受来自父组件(搜索组件)的结果，并将其显示在视图上。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/b6de923f40427380cd18e11dbd7e77e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aiLY49xZhi19capJKPDG7A.png"/></div></div></figure><p id="d13e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">模板呢？</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/efe1da5ebf18c38b5137b4e35ca9b7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtJaWKwfz4l-nPIK6arHMQ.png"/></div></div></figure><p id="bff1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…就是这样。</p><p id="9910" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么这一部分我们学到了什么？</p><ol class=""><li id="eb67" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">我们学习了如何使用输入绑定和事件发射器将数据从一个组件传递到另一个组件。</li><li id="49bd" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">我们学习了如何在我们的代码中分离关注点:我们能够让我们的<code class="fe nd ne nf ng b">searchBox</code>组件执行从用户那里获取搜索查询、从API获取我们的数据以及将数据传递给父组件的功能。父组件也接受数据，并将其传递给搜索结果组件。</li></ol><p id="039a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谢谢你的时间。</p></div></div>    
</body>
</html>