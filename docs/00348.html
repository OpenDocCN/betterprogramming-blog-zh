<html>
<head>
<title>MVVM in iOS (Revisited)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS中的MVVM(重访)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/mvvm-in-ios-revisited-1e2de1419ba6?source=collection_archive---------0-----------------------#2019-04-30">https://betterprogramming.pub/mvvm-in-ios-revisited-1e2de1419ba6?source=collection_archive---------0-----------------------#2019-04-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eb74" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在应用程序中使用MVVM时需要考虑的新技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c0f6eb36f2b2ff6288ae4c0760ec906a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7CxAaW7ehelAIj4POtzp7g.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://www.arc-magazine.com/wp-content/uploads/2018/06/KL-Sports-City.jpg" rel="noopener ugc nofollow" target="_blank">https://www . arc-magazine . com/WP-content/uploads/2018/06/KL-Sports-city . jpg</a></p></figure><p id="7678" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">前段时间，我写了一篇关于使用Swift编程语言在iOS中实现<a class="ae ku" href="https://medium.com/@azamsharp/mvvm-in-ios-from-net-perspective-580eb7f4f129" rel="noopener"> MVVM设计模式的文章。我收到了很多关于这篇文章的很好的反馈。</a></p><p id="3bdb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这篇文章是我的原始文章的更新，重点关注实现iOS应用程序时的新技术，结合了MVVM设计模式。</p><p id="1e3e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">本文的前提围绕着一个咖啡订购应用程序。咖啡师接受顾客的订单，包括以下内容:</p><ul class=""><li id="ff36" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">名字</li><li id="19e3" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">电子邮件</li><li id="f157" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">咖啡类型</li><li id="cf81" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">咖啡大小</li></ul><p id="3c61" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">订单被发送到服务器并保存。最后，咖啡师能够在列表中查看顾客的所有订单。应用程序的演示如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/f565d80fab0c36e65c73492bd78a1f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/1*VfMIFFu0PcAZL30jozwGag.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">热咖啡iOS应用</p></figure><p id="92b4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们开始吧。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="da4c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">计算机网络服务器</h1><p id="29fd" class="pw-post-body-paragraph kv kw it kx b ky nf ju la lb ng jx ld le nh lg lh li ni lk ll lm nj lo lp lq im bi translated">我使用<a class="ae ku" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>在<a class="ae ku" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>中实现了服务器。对于本文的目的来说，服务器并不那么重要。服务器的完整实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9ac3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如您所见，我们的服务器没有使用任何数据库。咖啡订单存储在内存中。在实际的应用程序中，你肯定会使用数据库，否则当服务器重启时，所有的订单都会神奇地消失，导致客户愤怒。</p><p id="a851" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该服务器也公开托管在Heroku上，网址为<a class="ae ku" href="https://guarded-retreat-82533.herokuapp.com" rel="noopener ugc nofollow" target="_blank"> URL </a>。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d70e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">web服务客户端</h1><p id="d653" class="pw-post-body-paragraph kv kw it kx b ky nf ju la lb ng jx ld le nh lg lh li ni lk ll lm nj lo lp lq im bi translated">我们的首要任务是从服务器中检索所有订单。为此，我们将在iOS应用程序中实现一个web服务API客户端。</p><p id="2918" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将首先创建我们的资源结构，它将表示资源类型、URL和用于访问资源的方法(GET/POST)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f014" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们将实现如下所示的<code class="fe nm nn no np b">Webservice</code>客户端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="661b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nm nn no np b">Webservice</code>类利用了Swift 5 编程语言中新的<em class="nq">结果类型。</em></p><p id="c310" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">结果允许我们关联成功和失败函数，这使得处理这两种情况更加清晰。如果您想了解更多关于结果类型的信息，请查看我下面的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr nl l"/></div></figure><p id="17d8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nm nn no np b">Webservice</code>将返回可以映射到我们模型的JSON数据。在下一节中，我们将实现我们的<code class="fe nm nn no np b">Order</code>模型。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="ca07" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">实现模型</h1><p id="14f0" class="pw-post-body-paragraph kv kw it kx b ky nf ju la lb ng jx ld le nh lg lh li ni lk ll lm nj lo lp lq im bi translated">一旦<code class="fe nm nn no np b">Webservice</code>返回数据，我们需要将它映射到我们的模型。Swift 4引入了可编码协议，这有助于我们将JSON结果无缝地映射到一个类或结构，符合可编码协议。</p><p id="cd68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nm nn no np b">Order</code>模型的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7098" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nm nn no np b">Order</code>结构公开了与Web API返回的相同的属性。</p><p id="9aaa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请记住，模型的属性不一定要与API返回的响应相匹配。您可以使用<code class="fe nm nn no np b">CodingKey</code>协议来提供定制映射。定制映射超出了本文的范围。</p><p id="b0ee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们的<code class="fe nm nn no np b">Order</code>模型还包含一些助手方法，允许它创建资源。看看下面的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="18b7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">每个方法将负责返回一个<code class="fe nm nn no np b">Resource</code>对象，该对象提供如何使用资源的信息。</p><p id="a1cf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="nq"> create </em>方法接受一个视图模型对象，并使用它来实例化一个订单，然后将订单对象传递给web服务。</p><p id="f2aa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">一旦模型被填充，它们需要在视图中显示数据。这就是视图模型的概念发挥作用的地方。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f780" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">实现视图模型</h1><p id="9e91" class="pw-post-body-paragraph kv kw it kx b ky nf ju la lb ng jx ld le nh lg lh li ni lk ll lm nj lo lp lq im bi translated">视图模型的基本思想是从模型中获取数据，然后将数据提供给视图。</p><p id="67b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们来看看负责在屏幕上显示订单相关数据的<code class="fe nm nn no np b">OrderViewModel</code>的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4a2b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nm nn no np b">OrderViewModel</code>是一个简单的视图模型，它只是将数据作为原始类型返回给视图。因为它不返回复杂的对象，所以数据可以很容易地显示在视图上。</p><p id="7d4e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">视图模型可以是智能的，也可以是简单的。</p><ul class=""><li id="8d48" class="lr ls it kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">智能视图模型可以通过web服务层进行逻辑调用。</li><li id="7e54" class="lr ls it kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">当一个视图模型简单地向视图提供数据，并且不执行任何复杂的操作时，我们就说它是简单的。</li></ul><p id="0741" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe nm nn no np b">OrderViewModel</code>代表每个订单，将显示在<code class="fe nm nn no np b">UITableView</code>控件中。</p><p id="60af" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">虽然您可以简单地使用一个数组<code class="fe nm nn no np b">OrderViewModels</code>并填充您的<code class="fe nm nn no np b">UITableView</code>，但是我建议创建一个父视图模型来表示整个视图。</p><p id="2bb6" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这样，您就可以灵活地为其他视图项(如<code class="fe nm nn no np b">SegmentedControl</code>、<code class="fe nm nn no np b">PickerView</code>等)提供数据。</p><p id="d518" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应用中的父视图模型叫做<code class="fe nm nn no np b">OrderListViewModel</code>。<code class="fe nm nn no np b">OrderListViewModel</code>代表负责显示订单的整个屏幕。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ed4f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将实现的第二个视图模型称为<code class="fe nm nn no np b">AddCoffeeOrderViewModel</code>。这个视图模型负责提供数据以及从<em class="nq">添加咖啡订单</em>屏幕收集输入数据。</p><p id="66ab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你看下面的咖啡订购屏幕，你会意识到在我们订购咖啡之前，咖啡订购屏幕需要一些不同的东西。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/c83601a7ca5f1b5dc5d457f51eca5403.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*MaVpX6KEju0U_2W7APxQ9A.png"/></div></figure><p id="df14" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">幸运的是，所有这些信息都可以由<code class="fe nm nn no np b">AddCoffeeOrderViewModel</code>提供给视图。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a9af" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">需要注意的一点是<code class="fe nm nn no np b">AddCoffeeOrderViewModel</code>的类型和大小属性。</p><p id="c528" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这两个属性都返回<code class="fe nm nn no np b">[String]</code>，它稍后被绑定到屏幕上。通过返回原始类型，我们可以很容易地在屏幕上显示信息。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="7dfd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">添加新的咖啡订单</h1><p id="a7f1" class="pw-post-body-paragraph kv kw it kx b ky nf ju la lb ng jx ld le nh lg lh li ni lk ll lm nj lo lp lq im bi translated">现在我们已经在屏幕上显示了咖啡的种类和大小，剩下的唯一步骤就是点一杯新咖啡。这是在<code class="fe nm nn no np b">AddCoffeeOrderViewController</code>实施的。</p><p id="9237" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当用户按下save按钮时，我们从UI收集所有选择，填充<code class="fe nm nn no np b">AddCoffeeOrderViewModel</code>的实例，然后通过web服务发出请求，插入新订单。</p><p id="a1e8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e06b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请记住，在用用户选择填充视图模型之后，我们使用<code class="fe nm nn no np b">Order.create</code>函数将视图模型转换成资源，然后使用我们的web服务层将其发送到服务器。</p><p id="9edd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我们没有使用任何第三方框架进行UI到VM的绑定。您可以使用<a class="ae ku" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank"> RxSwift </a>或<a class="ae ku" href="https://github.com/DeclarativeHub/Bond" rel="noopener ugc nofollow" target="_blank"> Bond framework </a>在您的应用中执行单向(UI到VM)绑定。</p><p id="ae9f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">MVVM设计模式允许我们将界面分成更小的组件。这有助于我们构建更多可定制的应用程序，也有助于我们为应用程序编写单元测试。</p><p id="3602" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请记住，仅仅因为您正在使用MVC设计模式，并不意味着您将最终拥有一个庞大的控制器。</p><p id="d63f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有一些方法可以重构你的控制器，并确保它是精简的。将自己的错误归咎于设计模式从来都不是一个好主意。最终，它只是一个设计模式。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="168e" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><ol class=""><li id="e8c1" class="lr ls it kx b ky nf lb ng le nt li nu lm nv lq nw lx ly lz bi translated"><a class="ae ku" href="https://medium.com/@azamsharp/mvvm-in-ios-from-net-perspective-580eb7f4f129" rel="noopener">iOS中的MVVM</a></li><li id="e865" class="lr ls it kx b ky ma lb mb le mc li md lm me lq nw lx ly lz bi translated"><a class="ae ku" href="https://github.com/azamsharp/HotCoffee-MVVM" rel="noopener ugc nofollow" target="_blank">源代码</a></li></ol></div></div>    
</body>
</html>