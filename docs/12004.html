<html>
<head>
<title>How To Manage Multiple Docker Containers at Scale</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何大规模管理多个Docker容器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-manage-multiple-docker-containers-at-scale-72c1189c5e97?source=collection_archive---------3-----------------------#2022-05-04">https://betterprogramming.pub/how-to-manage-multiple-docker-containers-at-scale-72c1189c5e97?source=collection_archive---------3-----------------------#2022-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ef9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">大规模管理Docker容器的指南，包括开发、持续集成、环境提升和DevSecOps</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/688a07102a1649d48de672830270a516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*ZwMVcHTHRFBAuq5Kv_Ur8w.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">信用:docker.com</p></figure><p id="a0bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随着容器和容器编排器的兴起，Docker已经成为所有现代程序员的必备技能。本文面向从应用程序代码构建定制容器映像的任何人，无论您是将Kubernetes用作容器编排器还是裸机服务器。</p><p id="922d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我将关注如何在整个开发和发布周期中管理大量不同的容器映像。我们将涵盖:</p><ul class=""><li id="f285" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">一次构建多个图像</li><li id="b898" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">运行一组图像进行测试</li><li id="0c96" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">在多个图像上执行命令。我将展示如何将它用于DevSecOps过程，比如图像扫描</li><li id="ab38" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">在发布过程中，将映像从一个注册表提升到另一个注册表</li></ul><p id="d16a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我假设您对Docker和Docker Compose有所了解。</p><p id="4dfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你只是想直接跳到好的东西，这里有一个参考<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>来介绍本文中解释的技术。</p><h1 id="10f8" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">目标和原则</h1><p id="7ac9" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在我们开始之前，这里有一些本文试图达到的目标和原则:</p><h2 id="fabd" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">全自动</h2><p id="5edc" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我们管理容器图像的流程应该完全自动化。</p><h2 id="5ce5" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">灵活的</h2><p id="524a" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">容器的美妙之处在于它们可以在许多不同的托管环境中运行。无论您对CI/CD使用什么技术，管理映像的过程都应该适用。</p><p id="b369" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理想情况下，当我们向我们的解决方案添加新的映像/服务时，我们希望对我们的脚本和基础设施/管道代码进行尽可能少的更改。</p><h2 id="a2c5" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">构建一次</h2><p id="0f6a" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">容器最重要的好处之一是它们可以在不同的宿主环境中一致地运行。我们应该充分利用这一点，只构建一次映像，并在发布时在每个环境中推广这些映像。这将确保将相同的映像部署到已经在所有较低环境中测试过的生产环境中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/195a0bb5541d9d492615e1e02606bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siBPMILBeMuP7j7SLCnnjg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">集装箱形象推广</p></figure><h1 id="daf4" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">示例应用程序</h1><p id="e0bd" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">提供了一个<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI" rel="noopener ugc nofollow" target="_blank">示例项目</a>来帮助演示本文中的一些技术。该项目包括以下应用:</p><ul class=""><li id="3e2f" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">。NET Blazor Webassembly web应用程序</li><li id="f3b1" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">。NET Worker代理控制台应用程序</li><li id="dae6" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">SQL Server数据库</li></ul><p id="7cf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该应用程序由一个简单的Web UI组成，用于从SQL Server数据库中检索随机天气预报。代理服务每10秒更新一次预测，并在启动时执行初始数据库模式迁移。</p><p id="d6de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">提供了一个示例<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/azure-pipelines.yml" rel="noopener ugc nofollow" target="_blank"> Azure DevOps管道</a>；但是，这些技术可以用于任何CI/CD过程，因为它们都是命令行驱动的。</p><h1 id="2964" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">Docker撰写</h1><p id="1568" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">我的团队发现,<code class="fe nq nr ns nt b">docker-compose.yml</code>文件是声明对图像进行添加和更改的完美地方。它很好理解，可以被很多容器管理工具使用，比如Docker Desktop和Podman，Docker Engine。</p><p id="dcd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">即使有了完全自动化的CI/CD过程，新服务及其相关的映像名称也必须在某个地方指定，您的项目的docker-compose.yml就是一个很好的地方。</p><p id="258b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Docker Compose概要文件是一个相对较新的功能，它使得在开发周期的每个阶段使用不同的配置变得更加容易。通过docker Compose运行Docker构建、运行和拉/推命令是很好理解的；然而，一个<code class="fe nq nr ns nt b">docker-compose.yml</code>文件及其相关的概要文件也可以通过定制的bash脚本来运行额外的操作。</p><p id="c04c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例项目有以下概要文件，可以用来快速运行不同的活动:</p><ul class=""><li id="0514" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><code class="fe nq nr ns nt b">dev</code>:用于地方发展。数据库或消息总线等本地资源可以快速启动。</li><li id="de96" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><code class="fe nq nr ns nt b">test</code>:一起测试项目的所有服务。</li><li id="4b28" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><code class="fe nq nr ns nt b">ci</code>:用于在持续集成过程中从应用程序代码中构建和推送定制映像。如果您想要跨不同的作业并行运行构建，那么可以将它分成更细粒度的概要文件。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="dde5" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">建筑图像</h1><p id="f2a6" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">描述文件可用于为您的项目构建图像选择。下面的命令将为<code class="fe nq nr ns nt b">ci</code>概要文件构建所有的服务:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="bef4" class="mz md iq nt b gy oa ob l oc od">docker-compose --profile ci build</span></pre><p id="d903" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可以在您的持续集成(CI)过程中用来构建您的所有映像。当服务被添加到您的<code class="fe nq nr ns nt b">docker-compose.yml</code>文件中时，它们将被自动地添加到CI构建中，而不需要对您的CI代码进行任何更改。</p><p id="3739" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我发现Docker Compose profiles有助于将长期运行的映像构建从其他服务中分离出来。通常，使用大量JavaScript npm库构建web应用程序映像会花费很长时间，所以最好创建单独的概要文件来并行运行它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f57f069d5d07ea23833708feaa5484b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*ukrStEgDIwNNL4y8yiCGKw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">在持续集成过程中并行构建概要文件</p></figure><h1 id="e013" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">运行图像</h1><p id="dd8a" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">概要文件也可以用于为您的项目运行一系列服务。以下命令将使用<code class="fe nq nr ns nt b">test</code>概要文件运行本地测试示例应用程序所需的所有服务:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="422a" class="mz md iq nt b gy oa ob l oc od">docker-compose --profile test up</span></pre><p id="2fce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过运行以下命令，可以停止服务并删除容器:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="2f88" class="mz md iq nt b gy oa ob l oc od">docker-compose --profile test down</span></pre><h2 id="5c50" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">地方发展</h2><p id="daca" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">对于开发代码，可能需要一组不同的服务。我经常发现拥有一个<code class="fe nq nr ns nt b">dev</code>概要文件对于运行本地资源(如数据库或消息总线)非常有用。以下命令将只运行数据库进行本地开发:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="45d7" class="mz md iq nt b gy oa ob l oc od">docker-compose --profile dev up</span></pre><h2 id="053d" class="mz md iq bd me na nb dn mi nc nd dp mm la ne nf mo le ng nh mq li ni nj ms nk bi translated">数据持久性</h2><p id="1375" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">提供的<code class="fe nq nr ns nt b">docker-compose.yml</code>文件创建了一个卷，这样当数据库容器被停止和删除时，数据库中的数据将会持久保存。要停止数据库并删除数据卷，可以使用以下方法:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="5be9" class="mz md iq nt b gy oa ob l oc od">docker-compose --profile test down -v</span></pre><h1 id="2695" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">从docker-compose.yml提取图像</h1><p id="b867" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">现在我们的服务已经在我们的<code class="fe nq nr ns nt b">docker-compose.yml</code>文件中指定了，我们可以更进一步，对它们相关的图像运行定制动作。</p><p id="9c8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nq nr ns nt b">docker-compose-extract.sh</code>脚本可用于根据配置文件或图像过滤器从Docker合成文件中提取图像名称。以下命令打印来自<code class="fe nq nr ns nt b">ci</code>配置文件的图像名称:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="9842" class="mz md iq nt b gy oa ob l oc od">./pipelines/scripts/docker-compose-extract.sh -p ci</span></pre><p id="5f50" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="of">注意:您的docker-compose文件必须有Unix行尾才能与提供的bash脚本一起工作。如果需要，使用VS Code或dos2unix将Windows行尾转换为unix行尾。如果您使用Windows，应该从bash终端运行脚本，尝试使用GitBash。</em></p><p id="b62a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上述命令的输出和用于过滤提取图像的附加选项如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi og"><img src="../Images/1333ea98cff8872cfb4fcc1a4eea1fd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9e75Nvg0LnrW8oeL1WF_Cg.png"/></div></div></figure><p id="f7f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/scripts/docker-compose-extract.sh" rel="noopener ugc nofollow" target="_blank">docker-compose-extract . sh</a>的主要逻辑如下所示。为图像及其关联的轮廓创建两个数组。基于所提供的参数，对图像名称和配置文件运行一些不同的过滤器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来自<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/scripts/docker-compose-extract.sh" rel="noopener ugc nofollow" target="_blank">docker-compose-extract . sh</a>的主逻辑</p></figure><p id="118e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了一个很好的方法来通过特定的配置文件检索我们的图像，我们可以将它链接到其他脚本。</p><h1 id="04af" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">提升图像</h1><p id="72c2" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">前面的脚本帮助我们实现了前两个目标；下一个脚本将允许我们一次构建我们的映像，并在发布时通过我们的不同环境推广这些映像。</p><p id="290a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在将代码部署到每个环境之前，执行以下过程:</p><ul class=""><li id="aa01" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">从以前的环境中提取映像进行升级</li><li id="a144" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">使用Docker标记将映像上的注册表名称更改为promotion registry</li><li id="0417" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">将升级的映像推送到当前的环境注册表</li></ul><p id="70cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nq nr ns nt b">docker-compose-promote.sh</code>脚本使用<code class="fe nq nr ns nt b">docker-compose-extract.sh</code>脚本提取提升所需的映像，然后使用Docker标记在本地更改映像的注册表名称。下面的命令将提升带有<code class="fe nq nr ns nt b">1.0.0</code>图像标签的<code class="fe nq nr ns nt b">ci</code>概要文件中的图像，并将注册表名称从<code class="fe nq nr ns nt b">devregistry.io</code>更改为<code class="fe nq nr ns nt b">qaregistry.io</code>:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="3b7f" class="mz md iq nt b gy oa ob l oc od">./pipelines/scripts/docker-compose-promote.sh -p ci -t 1.0.0 -r devregistry.io -u qaregistry.io</span></pre><p id="9a04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该脚本可用于连续部署(CD)过程，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oh"><img src="../Images/ba076d2fb09e01296f7f229d7f1e8ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XIwyK5jQuuON1PRGN23eg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">从连续部署过程部署时提升映像</p></figure><p id="e930" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">来自<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/scripts/docker-compose-promote.sh" rel="noopener ugc nofollow" target="_blank">docker-compose-promote . sh</a>的主要逻辑如下所示。从<code class="fe nq nr ns nt b">docker-compose.yml</code>文件中提取的图像被循环，注册表名称和标签被替换为所需的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">来自<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/scripts/docker-compose-promote.sh" rel="noopener ugc nofollow" target="_blank">docker-compose-promote . sh</a>的主逻辑</p></figure><h1 id="2d95" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">DevSecOps和自定义命令</h1><p id="c9a3" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">现在我们有了一个很好的方法来为我们的项目提取图像组，我们可以对它们运行定制命令，用于DevSecOps之类的过程。一般来说，大多数安全和自动化工具都是基于CLI的，这使得将它们链接到<code class="fe nq nr ns nt b">docker-compose-extract.sh</code>脚本变得很容易。</p><p id="07e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nq nr ns nt b">docker-compose-command.sh</code>脚本可用于对从<code class="fe nq nr ns nt b">docker-compose.yml</code>文件中提取的图像运行自定义命令。您提供的命令必须包含<code class="fe nq nr ns nt b">@image</code>，这将被替换为提取图像的名称。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oi"><img src="../Images/d3f5eade90331c5071fdc29aa7664679.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSGMXzLct4vEQ8IFIJwKJQ.png"/></div></div></figure><p id="66b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下命令显示了使用<a class="ae mb" href="https://github.com/wagoodman/dive" rel="noopener ugc nofollow" target="_blank"> Dive </a>对带有<code class="fe nq nr ns nt b">1.0.0</code>标签的<code class="fe nq nr ns nt b">devregistry.io</code>注册表中的<code class="fe nq nr ns nt b">ci</code>配置文件中的每个图像运行容器扫描的示例。Dive用于扫描图像以寻找浪费的空间。然而，这可以替换为任何其他集装箱扫描或自动化工具:</p><pre class="kg kh ki kj gt nw nt nx ny aw nz bi"><span id="9364" class="mz md iq nt b gy oa ob l oc od">./pipelines/scripts/docker-compose-command.sh -r devregistry.io -p ci -t 1.0.0 -c "dive @image"</span></pre><p id="8bcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">持续集成过程中的Dive扫描输出如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oj"><img src="../Images/993585240eb551bb65da522d618a749b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKr_4LnOwC5TmNWFEsyGow.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">从持续集成流程运行图像扫描</p></figure><p id="9b1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/scripts/docker-compose-command.sh" rel="noopener ugc nofollow" target="_blank">docker-compose-command . sh</a>的主要逻辑如下所示。从docker-compose.yml文件中提取的图像被循环，并对每个图像执行所提供的命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">主逻辑来自<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/scripts/docker-compose-command.sh" rel="noopener ugc nofollow" target="_blank">docker-compose-command . sh</a></p></figure><h1 id="1e66" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">DevOps管道</h1><p id="303c" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">提供的脚本可以在任何CI/CD流程中使用，因为它们是基于命令行的。在<code class="fe nq nr ns nt b"><a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI/blob/master/pipelines/azure-pipelines.yml" rel="noopener ugc nofollow" target="_blank">azure-pipelines.yml</a></code>中可以找到一个Azure DevOps CI/CD管道的例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/195a0bb5541d9d492615e1e02606bdbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siBPMILBeMuP7j7SLCnnjg.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Azure DevOps CI/CD管道示例</p></figure><p id="4a88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建阶段负责构建、扫描和推送图像。这些映像最初被推送到一个开发注册中心，并且产生了下面的部署工件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/4414c47e94d3fa3654e5030d83efbe6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*WoE03KR_X6DUv0GV7KBzrQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">部署工件</p></figure><p id="e5d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">提供的脚本和<code class="fe nq nr ns nt b">docker-compose.yml</code>文件在部署阶段用于提升和发布映像。如果您使用的是Kubernetes这样的容器编排器，那么您的部署清单文件或Helm图表也应该添加到您的部署工件中。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="1143" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这些想法和代码对您有用。如果你有其他想法，我很乐意听听！</p><p id="ec2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">查看我的<a class="ae mb" href="https://github.com/matt-bentley/MultiContainerCI" rel="noopener ugc nofollow" target="_blank"> GitHub </a>获取文章中的完整代码。</p></div></div>    
</body>
</html>