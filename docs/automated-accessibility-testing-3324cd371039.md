# 自动化可访问性测试

> 原文：<https://betterprogramming.pub/automated-accessibility-testing-3324cd371039>

## 静态分析检查器、CI 工具、单元测试等等

![](img/affbdd84cfa81aabf6b3854a66118bd8.png)

克里斯托夫·高尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

随着越来越多的公司专注于让他们的应用程序可访问，一个经常出现的问题是“我们如何确保我们不会让事情溜走？”我们已经做了所有这些工作来修复我们的应用程序，但是我们如何确保我们不会在六个月后把自己挖回一个洞，并最终陷入我们现在所处的类似情况？我们如何保持事物的可访问性？

有几种解决方法。首先是教育和培训。公司中的每个人都需要成为可访问性倡导者，并理解可访问性最佳实践。第二是更好的组织流程。公司应该在整个软件开发生命周期的自然检查点中包括易访问性审计，比如当 UX 向工程团队提供设计模型时，或者当工程团队完成了新功能的代码时。第三个是自动化测试，这也是我今天想要关注的。

# 放弃

在我们开始之前，作为一个简短的免责声明，我想强调的是，当谈到可访问性时，除了使用鼠标、键盘和屏幕阅读器进行良好的手动测试，没有其他合适的替代方法。问任何一个无障碍顾问，他们都会告诉你同样的事情。

棘手的问题是工程师们经常对这个答案不满意。工程师喜欢自动化一切。手动测试听起来很乏味，而且它没有伸缩性。

你是对的。这些都是合理的担忧。因此，让我们来看看一些可用的自动化工具，并检查它们的优点和缺点。

# 自动化辅助工具

有几个很好的工具可以帮助我们实现可访问性。我用过的一些常用工具是 ESLint 插件，如 [eslint-plugin-jsx-a11y](https://www.npmjs.com/package/eslint-plugin-jsx-a11y) ，Deque 的工具，如[axe DevTools Chrome extension](https://chrome.google.com/webstore/detail/axe-devtools-web-accessib/lhdoppojpmngadmnindnejefpokejbdd)或 [axe Monitor](https://www.deque.com/axe/monitor/) web crawler，以及 CI 工具，如 [Google Lighthouse](https://github.com/GoogleChrome/lighthouse-ci/blob/main/docs/getting-started.md) 或 [GitLab CI/CD with Pa11y](https://docs.gitlab.com/ee/user/project/merge_requests/accessibility_testing.html) 。

关于所有这些工具，需要知道的是它们都是静态分析检查器。

静态分析检查器检查代码，无论是 JavaScript 源代码还是网页上的内置 HTML，然后根据一组规则报告可能的违规行为。

更糟糕的是:这些静态分析检查器只能发现应用程序中大约 10-30%的可访问性问题。

是的，你没看错。10–30%.为什么这个数字这么低？为了更好地理解为什么，我们应该看看这些工具擅长识别的东西以及它们不擅长识别的东西。

# 哪些静态分析检查器擅长识别

静态分析检查器擅长识别 HTML 的**无效用法。例如，当您使用不带`href`属性的锚标记(`<a>`)时，它们会捕捉到。也许你在锚标签上放了一个点击处理程序，使它的功能更像一个按钮，这是无效的。静态分析检查器将报告一个违规，并告诉您应该使用带有点击处理程序的`<button>`元素，或者为您的`<a>`元素提供一个有效的`href`属性，如果您真的想让它成为一个链接的话。**

作为另一个例子，静态分析检查器可以识别出您何时以错误的顺序使用了标题元素(`<h1>`到`<h6>)`)。规则是标题级别只能增加一级，所以不能有一个`<h1>`元素后跟一个`<h4>`元素。如果静态分析检查器在您的应用程序中看到这种情况，它将报告一个违规。

作为第三个例子，静态分析检查器也可以识别您是否在列表中错误地嵌套了元素。`<ul>`或`<ol>`元素的直接后代需要是`<li>`元素，因此如果您将类似于`<div>`的东西作为您的`<ul>`或`<ol>`列表容器的子容器，静态分析检查器将会抱怨。

静态分析检查器也擅长识别角色和交互处理程序的不良使用。我经常看到的一个常见错误是有人使用带有点击处理程序的`<div>`元素，而不是`<button>`元素。这种方法本身的问题是，您丢失了语义`<button>`元素为您提供的许多现成的功能。例如，`<button>`元素响应点击以及回车键和空格键，并正确地将其角色(“按钮”)传达给屏幕阅读器。查看源代码的静态分析检查器(如`eslint-plugin-jsx-a11y`)将报告这些违规，并让您知道如果您有一个点击处理程序，您还需要一个伴随的键盘交互处理程序以及元素上的一个适当角色。

最后，当任何给定前景-背景组合的颜色对比度低于所需阈值时，针对浏览器中呈现的应用程序运行的静态分析检查器也非常适合捕捉**颜色对比度问题**。

快速回顾一下，这些是静态分析检查器擅长识别的一些主要事物:

*   HTML 的无效用法
*   角色和交互处理程序使用不当
*   颜色对比问题

# 哪些静态分析检查器不擅长识别

现在，我们来谈谈静态分析检查器不擅长识别什么。简而言之，他们不擅长识别那些拥有技术上正确的源代码，但却为人类提供了糟糕的用户体验的东西。

例如，让我们考虑一个页面的**标签顺序**。对于大多数从左到右阅读的西方语言，页面上的 tab 键顺序通常是从左到右，从上到下。您的页面上可能有一个分栏布局，在这种情况下，tab 键顺序将向下移动一栏，然后移动到下一栏。当浏览页面时，有时你可能会遇到标签焦点移动到一个你不期望的元素，可能会跳过一些其他的按钮或者只是去了一个完全不相关的地方。这对人来说是迷惑的，但是静态分析检查器却不能捕捉到。只有人类才能判断什么样的 tab 键顺序有意义或者没有意义。

另一个例子是**无用的咏叹调标签**。静态分析检查器会很好地告诉你标签何时丢失，比如没有 aria 标签的纯图标按钮。但是静态分析检查器不能告诉你 aria 标签是否有用或者有意义。您可以键入一些无意义的字符作为 aria-label 值来通过静态分析检查器，但是这对您的用户没有帮助。

三、静态分析检查器无法识别**键盘陷阱**。这些是无意的焦点陷阱，只使用键盘的用户不使用鼠标是无法逃脱的。在与弹出内容交互时，比如模态、工具提示或下拉菜单，您可能会遇到键盘陷阱。一个只有键盘的用户需要能够进出键盘陷阱，所以如果他们不能逃脱，那就是一个问题。

第四，静态分析检查器不能识别页面上何时有**缺少替代功能**来适应所有用户。以拖放行为为例。拖放功能本质上是不可访问的，因为它需要使用鼠标和精细电机控制来将鼠标指针从一个特定位置移动到另一个位置。这本身不是问题，但是您确实需要提供替代方法来完成相同的任务。因此，对于使用拖放功能对列表中的项目进行重新排序这样的事情，您还可以提供键盘控件，允许只使用键盘的用户按 Enter 键激活“重新排序模式”，然后使用箭头键在列表中上下移动项目。静态分析检查器不可能知道您何时有足够的备选方法来完成任何给定的任务。

第五，静态分析检查器不能识别语义 HTML 用法可以改进的区域。例如，也许你已经用`<div>`元素构建了一个表格。从视觉上看，它看起来像一个表格，但对于屏幕阅读器用户来说，它不会有相同的导航行为，对于屏幕阅读器用户来说，它不会作为一个表格进行交流。静态分析检查器不会抱怨，因为您编写的实际 HTML 代码在技术上是正确的，没有任何无效语法。静态分析检查器不知道您打算用它来表示一个表。

类似地，页面上可能有一个条目列表，这些条目是使用段落(`<p>`)元素而不是`<ul>` / `<ol>`和`<li>`元素构建的。或者你有一个对话框模式，但是缺少所有必需的伴随模式标记，比如`aria-modal="true"`、`role="dialog"`和一个为模式提供标题的 aria 标签。屏幕阅读器会看到技术上正确的 HTML，但不知道你想要传达的小部件或信息背后的意图。

再次快速回顾一下，这些是静态分析检查器不擅长识别的一些主要事情:

*   混乱的 tab 键顺序
*   无益的咏叹调-标签
*   键盘陷阱
*   缺少替代功能
*   语义 HTML 可以改进的地方

# 人类对计算机

所以，我们现在进退两难。作为工程师，我们希望能够自动化我们的可访问性测试。但是，我们拥有的工具本身不足以让我们相信我们的应用程序实际上是可访问的。我们该怎么办？

这里的关键是要明白，计算机擅长一些事情，人类也擅长一些事情。

计算机速度很快，不需要休息，可以完美地执行指令(即使我们作为人类给了它们不正确的指令！).

另一方面，人类更擅长高级思维和推理。当谈到审核我们的应用程序的可访问性时，我们可以退一步问，“这有意义吗？我能用这个吗？我们构建的产品是否提供了良好的用户体验？”

因此，与其竞争，为什么不让人类和计算机一起工作，以提供两个世界的最佳选择呢？

作为人类，我们可以决定什么标准是重要的，什么是值得测试的，以及预期的行为应该是什么。我们可以将这些需求编码为自动化测试。然后，计算机可以运行我们的测试，我们可以将这些测试包括在持续集成(CI)管道中，以防止我们的应用程序中的可访问性退化。

让我们看几个例子。

# 示例 1:模态

对于我们的第一个例子，假设我们正在构建一个模型。我们可以通过[网站内容可访问性指南(WCAG)](https://www.w3.org/TR/WCAG21/) 以及 [WAI-ARIA 创作实践](https://www.w3.org/TR/wai-aria-practices-1.1/#dialog_modal)文档找到如何构建可访问模式的指南。

我们的模态标准如下所示:

*   单击触发按钮时会打开模式
*   Modal 有适当的 aria 标记(`aria-modal="true"`、`role="dialog"`、aria-label)
*   当打开模式时，焦点被发送到模式中的第一个可聚焦项
*   焦点被困在模态内部
*   当单击关闭按钮时，关闭模式，焦点返回到触发按钮
*   当按下 Escape 键时，模式关闭，焦点返回到触发器按钮
*   当单击模式外部的任何位置时，模式被关闭，焦点返回到触发器按钮

我们的下一个问题自然是，我们应该在什么水平上测试这个标准，以及我们如何编写这些测试？

当编写易访问性测试时，测试它们的正确级别几乎总是作为单元测试。你不需要写一个端到端的测试来验证你的模型有正确的 aria 标记。单元测试就足够了。

那么我们如何为这些标准编写单元测试呢？使用您已经为其他单元测试使用的相同工具。我主要在 React 中工作，所以我选择的工具是用 [Jest](https://jestjs.io/) 作为我的测试框架，用 [React 测试库](https://testing-library.com/docs/react-testing-library/intro/)和[用户事件库](https://testing-library.com/docs/user-event/intro)作为我的测试库。

React 测试库非常适合渲染和与组件交互。User Event 是一个配套库，有助于使测试用户交互更加简单。这对于测试标签行为或者触发`document`正在监听的事件来说非常有用。

# 示例 2:可点击的 Div 按钮

让我们考虑另一个例子。我们在本文前面讨论了可点击的`<div>`元素，以及如果您选择使用语义`<button>`元素以外的元素，您必须自己重新实现的一些功能。

我们对此按钮的验收标准如下:

*   单击时调用单击处理程序
*   按 Enter 键时调用 Click 处理程序
*   在空格键上调用 Click 处理程序
*   点击处理程序*没有在任何其他按键上被调用*
*   元素具有`role="button"`属性

那么，我们在哪里以及如何测试这些标准呢？你的回答应该和上次一样。我们可以使用我们的测试框架和选择的库来编写单元测试。

# 关键要点

我们今天已经介绍了很多信息。如果这篇文章让你想起了什么，我希望是这几点:

1.  静态分析检查器本身不足以确保您的应用程序是可访问的。
2.  重要的是要进行手动探索性测试，以验证人们可以通过鼠标、键盘和/或屏幕阅读器来使用你的应用程序。
3.  我们可以从我们的手动测试中获得这些发现，修复错误，并编写自动化测试来防止回归。

感谢您的阅读，感谢您成为无障碍倡导者。