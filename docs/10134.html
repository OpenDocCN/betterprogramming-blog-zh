<html>
<head>
<title>Slow HTTP Response Times? Celery to the Rescue!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP响应时间慢？芹菜来救场了！</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/slow-http-response-times-celery-to-the-rescue-76346eb4212c?source=collection_archive---------9-----------------------#2021-12-02">https://betterprogramming.pub/slow-http-response-times-celery-to-the-rescue-76346eb4212c?source=collection_archive---------9-----------------------#2021-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="05a8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在Python中卸载计算密集型任务</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6a7707a086021d493a833194ae076335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8vJfNv5HbIBMV3IMOYLmHA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@grant_durr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">格兰特·杜尔</a>在<a class="ae ky" href="https://unsplash.com/s/photos/rabbits?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="2462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个日益数据驱动的世界中，软件工程师构建响应迅速的应用程序是非常重要的。随着我们的软件需求变得越来越复杂，我们的计算需求也在不断升级。与此同时，用户希望他们日常使用的应用程序能够提供快速响应的性能。</p><p id="bc86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">长期运行的后台任务是当今大多数软件应用程序的必要组成部分。我们如何设计软件来优雅地处理这样的任务而不影响用户体验？<br/>想象一下，如果用户不得不打开一个标签来完成上传或发送电子邮件。从用户体验的角度来看，这有多可怕？我们需要的是一种在后台以异步方式处理任务的方法。</p><h1 id="070b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">芹菜和兔子</h1><p id="a47d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们可以使用Python的<em class="ms"> Celery </em>框架来处理后台任务。</p><blockquote class="mt"><p id="0c8d" class="mu mv it bd mw mx my mz na nb nc lu dk translated">Celery是一个用Python编写的异步任务队列框架。本质上，你可以把它想象成一个具有FIFO(先进先出)原则的队列数据结构。</p></blockquote><p id="cb13" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">因此，放入队列的第一个任务首先获得进程。这使得计划任务成为可能。它还确保任务按照应用程序接收的顺序进行处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/9d2200bb5e586d9e20f99dc39bd91e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7w3MhCQ2LOpYgMRS.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示先进先出原则的队列</p></figure><p id="bc8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Celery使用分布式消息传递的范例，这意味着它还包括一个消息队列。在本文中，我们将使用RabbitMQ <em class="ms"> </em>作为消息队列。</p><p id="caff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可能想知道，任务队列和消息队列之间有什么区别。</p><p id="7566" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将任务队列视为在机器或进程之间分配计算的一种方式。一个<em class="ms">工人</em>是由Celery提供的一个抽象，代表一个父进程。当客户端使用我们的应用程序时，一个worker产生一些子进程来处理单个任务。产生的进程将扫描任务队列，寻找要执行的任务。</p><p id="f535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，为了发送和接收这些任务，我们需要类似消息队列的东西，也称为消息代理。这就是RabbitMQ的用武之地。RabbitMQ将负责将任务从任务队列发送到需要它们的工作者。注意，有可能使用一个叫做Redis的解决方案，但是在这篇文章中我们将坚持使用RabbitMQ。</p><p id="8a8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们继续编码吧！</p><h1 id="053a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">设置</h1><p id="fd87" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><em class="ms">注意:我无法让我的Windows电脑运行起来。</em> <br/> <em class="ms">本文假设Linux或macOS环境。</em></p><p id="d705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将构建一个简单的Flask应用程序，发送电子邮件来鼓励芹菜的使用。</p><p id="a107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先安装以下Python包:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="d1b9" class="no lw it nk b gy np nq l nr ns">pip3 install yagmail</span></pre><p id="2b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，安装芹菜包:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="0b10" class="no lw it nk b gy np nq l nr ns">pip3 install celery</span></pre><p id="9dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，由于安全原因，不可能简单地以编程方式发送电子邮件。<br/>如果您使用Gmail，您可以遵循“创建&amp;使用应用程序密码”下的指南<a class="ae ky" href="https://support.google.com/accounts/answer/185833?hl=en" rel="noopener ugc nofollow" target="_blank">在此</a>为您的Gmail帐户设置一次性密码。记得记下密码。</p><p id="23d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，创建一个名为<em class="ms"> default_settings.py </em>的文件，并输入以下常量，用您的电子邮件和密码替换:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="73a6" class="no lw it nk b gy np nq l nr ns">MAIL_USERNAME = &lt;Username&gt; <br/>MAIL_PASSWORD = &lt;One-time password&gt;</span></pre><p id="ff7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，从<a class="ae ky" href="https://docs.celeryproject.org/en/stable/getting-started/first-steps-with-celery.html#rabbitmq" rel="noopener ugc nofollow" target="_blank">这里</a> (Linux)和<a class="ae ky" href="https://docs.celeryproject.org/en/stable/getting-started/backends-and-brokers/rabbitmq.html#installing-rabbitmq-on-macos" rel="noopener ugc nofollow" target="_blank">这里</a> (macOS)安装RabbitMQ。</p><p id="ffc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用以下命令确保RabbitMQ正在运行:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="090d" class="no lw it nk b gy np nq l nr ns">brew services list</span></pre><p id="6fd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">终端应该如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/c0e2ca36ae6ac0a29169f5a081574cfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TQYWfM6TFGMBXTlo.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">RabbitMQ服务正在运行。耶！</p></figure><p id="fcd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！我们来编码吧！</p><h1 id="b00d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">用RabbitMQ初始化芹菜</h1><p id="740d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们首先初始化一个芹菜应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="9d1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过给出芹菜所在模块的名称来初始化芹菜，这是python文件的名称。第二个参数指定了我们希望使用的消息代理的URL。</p><p id="d40f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">URL: <code class="fe nw nx ny nk b">broker=’pyamqp://guest@localhost//’</code>，是RabbitMQ的默认URL。</p><p id="873b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还初始化了一个非常简单的<code class="fe nw nx ny nk b">yagmail</code>实例。</p><p id="e5bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，您会注意到我们设置了一个5秒钟的计时器来模拟一个长时间运行的任务。</p><p id="484d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们定义一个常规的Python函数，负责执行一些长时间运行的计算，然后发送电子邮件通知用户处理完成。这可能是像图像处理，视频编码，或语音转录。</p><p id="5f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，该函数用符号<strong class="lb iu"> <em class="ms"> @ </em> </strong>进行了注释，这表明我们正在用芹菜包提供的装饰函数进行包装。查看我的帖子<a class="ae ky" href="https://haseebkamal.com/2021/11/24/how-to-write-dry-code-in-python-using-decorator-functions/" rel="noopener ugc nofollow" target="_blank">这里</a>我用例子解释了装饰者，这样你就可以跟上了。</p><p id="3f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，注释表明这是一个芹菜任务。这意味着该功能将被委托给工作进程，并由Celery框架处理。</p><p id="c5e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止一切顺利！</p><p id="e1ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们构建一个简单的Flask应用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b8a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们记得从芹菜py文件中导入<code class="fe nw nx ny nk b">sendMail</code>函数。<br/>在第9行中，我们简单地调用:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="a22e" class="no lw it nk b gy np nq l nr ns">sendMail.delay(data)</span></pre><p id="76e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是芹菜的功能。函数调用被添加到Celery任务队列中，并由RabbitMQ发送到一个可用的工作进程。</p><p id="4761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里关键的一点是函数会立即返回— <br/>调用是<code class="fe nw nx ny nk b">asynchronous</code>。</p><p id="7c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着下一行的返回调用会被毫不延迟地执行。这进一步意味着用户在得到HTTP响应之前不需要等待处理的发生。</p><h1 id="9ed2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">运行芹菜和烧瓶</h1><p id="c30e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于Celery作为一个独立的服务，我们需要在一个单独的终端实例中运行它。</p><p id="34c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先从终端执行Flask应用程序，如下所示:</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="1a48" class="no lw it nk b gy np nq l nr ns">python3 app.py</span></pre><p id="e497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，打开一个单独的终端实例并执行以下命令:这将启动Celery服务。</p><pre class="kj kk kl km gt nj nk nl nm aw nn bi"><span id="cf34" class="no lw it nk b gy np nq l nr ns">celery -A mailasync worker --loglevel=INFO</span></pre><p id="17bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望您能看到如下内容。(右边烧瓶，左边芹菜。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/6034104f4290e56845f334cd199075ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CipDoRZ2r70MPr4R.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烧瓶在左边运行。芹菜在右边跑。</p></figure><h1 id="9eef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用邮递员和临时邮件进行测试</h1><p id="9d4f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">精彩！</p><p id="d670" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们使用Postman进行测试。首先，进入<a class="ae ky" href="https://temp-mail.org/" rel="noopener ugc nofollow" target="_blank">https://temp-mail.org/</a>，复制显示的电子邮件地址，同时保持浏览器标签打开。这封电子邮件是可丢弃的和临时的，这意味着它是完美的测试。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/3f3afbf9d9c76e3d5e62b62aa7ac219a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nEBZE6K6n6C7yYit.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用邮递员测试</p></figure><p id="aa49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Postman的正文中，记得用temp-mail中显示的电子邮件替换“to”下面的电子邮件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/981ed09fe1fc8abfaee8a4e22e31deab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4-81C4Sr2WCkCE8C.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">收到来自工人的电子邮件！</p></figure><p id="baf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您点击send，您应该立即得到一个HTTP 200响应，尽管在实际代码中有一个5秒的计时器。因此，您可以看到运行中的异步Celery代码。</p><p id="d8dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，您可以检查临时邮箱，并确认芹菜工人在5秒钟后发送了电子邮件:</p><h1 id="2b33" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">概述</h1><p id="fbdd" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">厉害！这就是这篇文章的内容。</p><p id="166f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将芹菜用于需要时间处理的长期运行的后台任务。Celery负责将这些任务委派给应用程序中的进程。确保它们按照发送的顺序进行处理。我们使用RabbitMQ作为消息代理来处理Celery中任务的发送和接收。</p><p id="620e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，使用Celery意味着用户不必在服务器处理他们的请求时保持标签页打开。也就是说，他们将立即收到HTTP响应。</p><p id="ac26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在芹菜中也可以跟踪任务。您还会注意到，我们不需要使用芹菜工人函数的返回值。可能存在需要在应用程序中使用返回值的情况。这需要额外的配置，将是另一篇文章的主题。</p><p id="d823" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望你喜欢这篇文章。</p></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="8e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">原载于</em><a class="ae ky" href="https://haseebkamal.com/2021/12/02/slow-http-response-times-celery-to-the-rescue/" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。</em></p></div></div>    
</body>
</html>