<html>
<head>
<title>The Dangers of Async in Python and How To Avoid Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中异步的危险以及如何避免它们</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-dangers-of-async-in-python-and-how-to-avoid-them-6e6f98f19f0e?source=collection_archive---------7-----------------------#2021-04-20">https://betterprogramming.pub/the-dangers-of-async-in-python-and-how-to-avoid-them-6e6f98f19f0e?source=collection_archive---------7-----------------------#2021-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e609" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过一个非抢占式事件循环示例了解Python中的异步陷阱</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9b5a2f101330548afa1865f1ae58a74e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kHeak90v3VNevqVy"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>拍摄的照片。</p></figure><p id="c4fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python中的异步web服务器通常被认为是易于使用和高性能的。但是有些警告甚至会让高级软件开发人员出错。</p><p id="51c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中一个警告是，事件循环是<em class="ls">非抢占式的</em>:当一个异步任务正在运行时，其他任何东西都不能运行。让我用一个小例子来说明这一点，这个例子大致基于我在工作中遇到的一个情况。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6ea9" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">问题是</h1><p id="e541" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">我们在Kubernetes中运行了一个简单的Python异步web服务器。它公开了一个端点，该端点下载一个文件，用一个库调用处理它，然后返回结果。我们发送了一个请求，需要一些复杂的、更长时间的处理，但是什么也没有发生。事实上，我们看到web服务器被重启了，所以我们的请求没有得到响应。重试产生了相同的行为。</p><h2 id="549e" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">app为什么重启？</h2><p id="8f0a" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">该应用程序的部署定义了一个<a class="ae kv" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/" rel="noopener ugc nofollow" target="_blank"> Kubernetes活跃度探测器</a>,其工作方式大致如下:为应用程序提供一个端点。每十秒钟，它会发送一个请求。如果它在一秒钟内响应，并且响应状态代码大于或等于200且小于400，则应用程序被认为是活动的。如果其中三个探测器连续失败，就认为它已经死了，Kubernetes将重新启动它。</p><p id="ff48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就引出了下一个问题。</p><h2 id="c58f" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">为什么活性探测失败了？</h2><p id="a313" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这就是Python事件循环的<em class="ls">非抢占</em>特性发挥作用的地方。每个请求都会在事件队列上创建一个新任务。Python事件循环挑选下一个任务并运行它，直到它产生或完成。然后它将运行下一个任务，以此类推。但是如果一个任务不间断地运行几秒钟，其他任务就没有机会运行了。</p><p id="aab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的web服务器，这意味着复杂的请求会阻止其他请求得到服务，导致活跃度探测请求超时。</p><p id="58a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常，如果您自己不做任何大量的请求处理，或者当您使用异步库时，这“不应该发生”。异步库将确保任务在向操作系统发出底层请求(例如，访问文件)时会让步。但是在我们的例子中，处理所需的库不支持async，所以调用它意味着在这两者之间没有其他东西可以运行。</p><p id="3eaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用<a class="ae kv" href="https://www.starlette.io/" rel="noopener ugc nofollow" target="_blank"> starlette </a>和<a class="ae kv" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicon</a>创建了一个小型的示例web服务器来重现这个问题。<a class="ae kv" href="https://github.com/lucas-sonnabend/nonpremeptive-async" rel="noopener ugc nofollow" target="_blank">源代码在GitHub上</a>。请检查它，并与它一起玩。我用一个非异步睡眠来模拟长处理，这个非异步睡眠将阻塞当前事件循环那么多秒。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最小的网络服务器</p></figure><p id="8fc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我没有在Kubernetes中运行web应用程序，而是使用我自己的活跃度探针，每秒钟调用服务器的<code class="fe nl nm nn no b">/health</code>端点。如果您运行web服务器(<code class="fe nl nm nn no b">poetry run uvicorn example:app</code>)，启动活跃度探测(<code class="fe nl nm nn no b">./liveness_probe.sh</code>)，并点击<code class="fe nl nm nn no b">/processing</code>端点(<code class="fe nl nm nn no b">./send_requests.sh</code>，您将看到活跃度探测失败了几次。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/1586d8b978880b9180a65e6789ec21be.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*9VMADnL6SVzTOjR7Ldv2pA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">失败的活性探测器</p></figure><p id="47c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们成功地把这个问题简化为一个小例子。现在我们可以尝试不同的解决方案！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1950" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">那么你说的“非先发制人”是什么意思呢？</h1><p id="a72e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">以上是<em class="ls">非抢占式</em>调度的一个很好的例子。您可以将事件循环视为一个调度程序，它从事件队列中挑选任务，并非抢占式地运行它们。</p><p id="902d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非抢占式调度器只在当前任务阻塞、自愿放弃或完成时切换任务。</p><p id="d263" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是<a class="ae kv" href="https://en.wikipedia.org/wiki/Preemption_(computing)" rel="noopener ugc nofollow" target="_blank"> <em class="ls">抢占式</em>调度</a>，它可以在一个任务执行过程中中断该任务来调度另一个任务。进程和线程通常由操作系统使用抢占式调度程序来运行。我们可以利用它们来解决我们的问题。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d2ed" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">解决方法</h1><h2 id="7632" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">1.使用更多工作进程</h2><p id="e872" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">默认情况下，uvicorn产生一个工作进程，所以我们得到一个事件循环。一个常见的建议是使用<code class="fe nl nm nn no b">2 * available cores + 1</code> workers，因此双核系统上有五个workers。这样，我们得到了五个事件循环，并且可以在遇到同样的问题之前并行处理四个长时间运行的请求。</p><p id="ea0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的示例中，我们可以通过使用<code class="fe nl nm nn no b">poetry run uvicorn --workers 5 example:app</code>启动应用程序来实现这一点。现在，如果您运行<code class="fe nl nm nn no b">./send_requests.sh</code>，您可以看到活性探针始终保持绿色。操作系统可以以<em class="ls">抢占</em>的方式在工作进程之间切换。但是如果用<code class="fe nl nm nn no b">./send_requests.sh 5</code>同时发送五个请求，活跃度探测又会失败。您的请求超过了可用工作进程的数量。</p><h2 id="3c75" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">2.在单独的线程中运行阻塞代码</h2><p id="dcee" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated"><a class="ae kv" href="https://docs.python.org/3.6/library/asyncio-dev.html#handle-blocking-functions-correctly" rel="noopener ugc nofollow" target="_blank"> Python的文档</a>实际上推荐在不同的线程或进程中运行阻塞任务，使用<code class="fe nl nm nn no b"><a class="ae kv" href="https://docs.python.org/3.6/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.run_in_executor" rel="noopener ugc nofollow" target="_blank">EventLoop.run_in_executor()</a></code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9d4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在单独的线程中运行处理，释放主线程中的事件循环，以继续处理其他请求。在示例web服务器中，您可以用<code class="fe nl nm nn no b">./send_requests.sh 5 processing_fixed</code>点击请求端点，活跃度探测器保持绿色——即使在处理多个请求时。</p><p id="f3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，它之所以有效是因为操作系统在线程<em class="ls">和</em>之间抢先切换:它们运行一会儿，然后操作系统调度另一个线程，这样所有的线程都能取得一些进展。重要的是。对活性探测作出反应的主线程可以及时运行。</p><h2 id="412d" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">3.调整你的数字</h2><p id="9e07" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">您可以调整活动探测器，以允许检查之间有更长的暂停时间或更高的连续失败阈值。不利的一面是，如果您的应用程序完全死机，Kubernetes将需要更长的时间来重新启动。在处理一个复杂的请求时，您仍然有一个反应相当迟钝的web应用程序。</p><p id="2d0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不会改变任何调度行为，但仍然是一个实用的解决方案。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="64f3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">还有陷阱吗？</h1><p id="725e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">这些例子相当简单。我将并发请求的数量保持在较低水平，并且使用<code class="fe nl nm nn no b">time.sleep()</code>来模拟请求的“处理”。这会挂起当前线程，让操作系统有机会运行其他线程或进程。在实际项目中，处理将是等待外部资源(读取文件或访问数据库)和CPU上的实际处理的组合，这类似于睡眠。</p><p id="4a2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/lucas-sonnabend/nonpremeptive-async" rel="noopener ugc nofollow" target="_blank">我的示例</a>还提供了一个<code class="fe nl nm nn no b">processing_busy</code>端点，它模拟了一个繁忙循环的CPU密集型处理。我鼓励您尝试一下，改变工作进程、并发请求和不同端点的数量。这样，您将探索应用程序的性能界限和并发性。奥马尔·雷沃德写了一篇关于这个问题的更深入的文章。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="77d0" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">摘要</h1><p id="2efd" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">希望这个示例web服务器展示了异步Python的一个更复杂的行为。我实际上在使用Python的异步Kafka库时遇到了类似的问题，<a class="ae kv" href="https://aiokafka.readthedocs.io/en/stable/kafka-python_difference.html" rel="noopener ugc nofollow" target="_blank"> aiokafka </a>。这里，我们有一个异步心跳任务在后台运行。对消息进行长时间的CPU密集型处理可能会阻止heartbeat任务的运行，从而导致Kafka broker断开与客户端的连接。</p><p id="fb2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，异步Python框架仍然是一个强大的工具。你只需要知道事件循环是不可抢占的！</p><p id="4302" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你在这篇文章中读到了这一点，你很可能会喜欢它。查看我关于一个<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-i-solved-a-challenging-concurrency-bug-in-python-cbf635d4bea9"> python并发错误</a>的文章，了解另一个调试故事。</p></div></div>    
</body>
</html>