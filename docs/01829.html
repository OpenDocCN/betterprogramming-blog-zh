<html>
<head>
<title>I Built an Over-Complicated Data-Driven System to Remind Me to Drink Water</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我建立了一个过于复杂的数据驱动系统来提醒我喝水</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/i-built-an-over-complicated-data-driven-system-to-remind-me-to-drink-water-59dc4c24044a?source=collection_archive---------24-----------------------#2019-10-15">https://betterprogramming.pub/i-built-an-over-complicated-data-driven-system-to-remind-me-to-drink-water-59dc4c24044a?source=collection_archive---------24-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f63a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Data，Golang，Python，Android，Docker，gRPC，Firebase，Cloud，BigQuery，oh my！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a4ca7439ab83dc0fafbff083f68680d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yabJLEJvpqONIH8cDqpSSw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Jana Sabeth 在<a class="ae ky" href="https://unsplash.com/s/photos/glass-of-water?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a31d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">水。阿瓜。H2O。长生不老药。其他星球羡慕的对象。</p><p id="0590" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这种神圣的液体对我们人类来说是必不可少的，我们，我的意思是我，通常会忘记饮用它。在写这篇文章的时候，我正在亚洲背包旅行。在我的新生活的兴奋、享受和冒险中，我几乎没有想到喝水。当它发生时，我通常会忽略它，告诉自己，“不，我会没事的。只是水而已。反正我也不渴。”但是，夜晚来了，在又一个成功的一天接近尾声的时候，头痛和疲劳来了，提醒我应该重新装满我的瓶子。显然，我必须找到一个解决办法。</p><p id="bdc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，作为数据从业者，解决方案必须涉及数据。但是我想要的不止这些——我想要一些<em class="lv">夸张的东西。我的问题本可以通过设置一个定时器或者下载一个与喝水相关的应用程序来轻松解决。但是没有——再说一次，我想要更多的<em class="lv"/>。突然之间，问题变得更像是我能在多大程度上实现我的解决方案，而不仅仅是提醒我稍微刷新一下我的生活。但是我做这个的一个更现实的原因是因为我真的很怀念和这样一个系统一起工作。当我被雇佣时，我每天都要处理数据、Golang、云和生产系统。现在我不想了。所以，我想建立一个系统，在那里我可以使用所有这些工具(我也不想变得生疏，因为我知道一旦我决定告别我的户外冒险并把它们换成办公椅，我就必须给招聘人员留下深刻印象)。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/a60a3a2a189c8d2aff7a4e341775ddea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uroNkQCY7pbv49d6p7R3Og.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">水(但不可饮用)。我拍的(<a class="ae ky" href="https://www.instagram.com/juandesr" rel="noopener ugc nofollow" target="_blank">https://www.instagram.com/juandesr</a>)</p></figure><p id="a16f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的过于复杂的平台，我以著名的口袋妖怪邪恶团队命名为Team Aqua，该团队希望扩展海洋，摧毁所有人类文明，并将世界恢复到原始状态(口袋妖怪可以非常非常暴力)，使用以下平台/服务/组件:</p><ul class=""><li id="73da" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">Fitbit设备</li><li id="3d8c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">Fitbit的API</li><li id="46c9" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">一个Python服务</li><li id="4fe5" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">两个Golang服务</li><li id="acba" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">gRPC(以及Protobufs)</li><li id="2ffc" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">Firebase(信息服务)</li><li id="ca81" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">一款安卓应用</li><li id="eaab" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">码头工人</li><li id="caae" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">谷歌云的容器注册表</li><li id="cdfe" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">谷歌云的计算引擎</li><li id="e8dd" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">BigQuery</li><li id="540e" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">谷歌的数据工作室</li></ul><p id="7c7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将描述我是如何构建这个系统的，它是如何工作的，当然还有它背后的源代码。然而，出于简单的原因，为了让这篇文章尽可能简短和集中，我不会解释该平台的每个角落——例如，Gradle是什么，为什么在Android上使用它。尽管如此，在文章的最后，你会发现一个系统回购的链接。</p><p id="fa6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来解释一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/a0a36df4a88e5edc6119b5cb05ed121e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5olMdSJ4x6HtSuuY3WnVQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更多的水。由我挑选。</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="1a72" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">概观</h1><p id="3481" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在我开始解释每个组件之前，我想给你一个简短的回顾，展示系统的架构，所有的移动部件，以及它们的作用。这个可爱的故事发生在我的Fitbit手表(或应用程序)上。在这里，我将进入每个水会话(姑且称之为水会话)，在这个过程中生成平台需要的数据(这就是为什么我称之为数据驱动的解决方案)。在记录水会话之后，这些数据将被发送到Fitbit并存储在那里。</p><p id="c444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了检索这些数据，我有一个Python服务(称为Water Retriever ),它每隔X分钟与Fitbit的API对话，并获取我今天记录的所有水会话。然后，Python客户端将通过gRPC与后端(用Golang编写)进行通信，我将后端命名为Archie，以团队Aqua的领导者命名。Archie的作用是将水会话保存在内存中，并将它们写入BigQuery。</p><p id="ed77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了阿奇，还有第二个Golang组件，称为提醒。这个小家伙每隔X分钟就会问阿奇，我在这段时间里喝了多少水。如果我在这段时间没有喝一滴水，它会向我作为平台的一部分编写的Android应用程序发送通知，提醒我在过去的X分钟内没有喝水。否则，如果我自己补水了，通知会祝贺我，说我喝了Y ml。在过去的X分钟内。推送通知由Firebase云消息处理。</p><p id="ba23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个服务包含在同一个Docker映像中，该映像托管在Google Cloud的容器注册表中。所述映像在“普通”计算引擎机器上执行(不是Kubernetes集群、云运行或任何花哨的东西)。最后，为了分析数据，因为它已经驻留在BigQuery中，我只运行几个查询，并使用Google的Data Studio可视化它们。</p><p id="3e8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下图是完整架构的图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/9a937821dfb84af276de71a6ffc5f94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MCibKzLCVOZNFbQN5Fevug.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我应该买个绘图板</p></figure><p id="063f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我在Fitbit中记录水资源数据，并将其发送到他们的服务器。然后，水检索器(WR)收集这些数据并将其发送给阿奇，阿奇保存这些数据并在BigQuery中写入一份副本。在它的旁边，有一个提示，谁从Archie那里得到数据并发送一个通知，最终由我阅读。</p><p id="1681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Archie下面的路线里，有BigQuery，他给Data Studio提供数据让我分析。</p><p id="d797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，事不宜迟，让我们看看具体情况。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="7dfc" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Fitbit设备</h1><p id="ea5d" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">系统的入口点和产生数据的地方就是我的Fitbit。在这里，每次我喝水，我都会输入它的量。我如何真正知道准确的数量？我不知道。除非我从一个写有容量的瓶子里喝水，否则我通常只是估计一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/a0e46b60b47d68c317834a00fdb110e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2UichzZhDKiEviLUYAD-0Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的Fitbit(有点脏)，还有Fitbit的app。</p></figure><h1 id="a4c5" class="ms mt it bd mu mv nr mx my mz ns nb nc jz nt ka ne kc nu kd ng kf nv kg ni nj bi translated">Python服务(水检索器)</h1><p id="401c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我要介绍的第一个服务是<strong class="lb iu"> Water Retriever </strong>，这是一个Python程序，它每X分钟查询Fitbit的API，以检索我当天消耗了多少水。为了开发它，我使用了现象库<a class="ae ky" href="https://python-fitbit.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> python-fitbit </strong> </a>来与API接口。这是代码:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1cd6" class="ob mt it nx b gy oc od l oe of">import grpc<br/>import fitbit<br/>import os<br/>import sys<br/>import time<br/>import logging<br/>import app.api.v1.endpoint_pb2 as endpoint_pb2<br/>import app.api.v1.endpoint_pb2_grpc as endpoint_pb2_grpc<br/><br/>from google.protobuf.timestamp_pb2 import Timestamp<br/><br/>waiting_time = 60 * 30<br/><br/><br/>def run():<br/>    starttime = time.time()<br/>    # keep track of the last water consumption id<br/>    last_log_id = 0<br/><br/>    client = fitbit.Fitbit(os.environ['FITBIT_KEY'], os.environ['FITBIT_SECRET'],<br/>                           access_token=os.environ['ACCESS_TOKEN'],<br/>                           refresh_token=os.environ['REFRESH_TOKEN'],<br/>                           system='en_DE')<br/><br/>    with grpc.insecure_channel('localhost:50051') as channel:<br/>        while True:<br/>            print('iterating...')<br/>            # result looks like this: {'summary': {'water': 500}, 'water': [{'amount': 500, 'logId': 6630477481}]}<br/>            result = client.foods_log_water(date='today').get('water', None)<br/><br/>            print(result)<br/>            # if no water has been consumed...<br/>            if result is None or len(result) == 0 or result[-1]['logId'] == last_log_id:<br/>                time.sleep(waiting_time -<br/>                           ((time.time() - starttime) % waiting_time))<br/>                continue<br/><br/>            stub = endpoint_pb2_grpc.DrinkWaterStub(channel)<br/>            try:<br/>                timestamp = Timestamp()<br/>                timestamp.GetCurrentTime()<br/>                response = stub.LogSplash(endpoint_pb2.Splash(<br/>                    amount=result[-1]['amount'],<br/>                    ts=timestamp<br/>                ))<br/>                print("Splash logged. Response: {}".format(response))<br/>            except Exception as e:<br/>                print(e)<br/><br/>            time.sleep(waiting_time -<br/>                       ((time.time() - starttime) % waiting_time))<br/>            print('end')<br/>            last_log_id = result[-1]['logId']<br/><br/><br/>if __name__ == '__main__':<br/>    logging.basicConfig()<br/>    run()</span></pre><p id="fcfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的程序的主要功能在于一个只有40行的函数。</p><p id="f92d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始时，我们用当前时间初始化一个变量，用最后一个“<code class="fe og oh oi nx b">logId</code>”(名为<code class="fe og oh oi nx b">last_log_id</code>)或Fitbit的用水会话ID初始化另一个变量。</p><p id="6c6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建Fitbit客户端，它需要Fitbit密钥、秘密、访问令牌和刷新令牌。要获得这些，您必须创建一个<a class="ae ky" href="https://dev.fitbit.com/getting-started/" rel="noopener ugc nofollow" target="_blank"> Fitbit开发帐户</a>并注册一个应用程序。在创建客户机时，您还可以指定语言(一些API响应包括可能适合显示的文本)，以及地区(或国家；不过，这个列表非常有限)。该参数的作用是包括在各种API响应中的一些文本字段的语言，以及单位系统。在我的例子中，我使用了“<code class="fe og oh oi nx b">en_DE</code>”，因为我希望字段是英文的，并且我的单位是公制。</p><p id="069e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了客户机，接下来的步骤是连接到gRPC后端服务(我将在下一节中描述)。然后陷入无限循环。在每次迭代中，系统调用“Get Water Logs”端点来检索给定一天(今天)的水条目的摘要和列表。典型的响应如下所示:</p><p id="5aa7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi nx b">{‘summary’: {‘water’: 500}, ‘water’: [{‘amount’: 500, ‘logId’: 1234567890}]}</code></p><p id="92ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我检查是否有任何日志，或者来自响应的最新日志是否与系统在过去的迭代中接收到的日志相同(日志id保存在<code class="fe og oh oi nx b">last_log_id</code>)。如果这些条件中的任何一个为真，我们什么都不做，系统将休眠30分钟。另一方面，如果“if”为假，我们创建一个我定义为Splash对象的东西的实例(相信我，我很快就会解释它)——一个由两个字段组成的类:amount和timestamp。</p><p id="2deb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们将在最新的日志和当前时间戳中存储耗水量(以毫升为单位)。然后，我们将调用gRPC方法<code class="fe og oh oi nx b">LogSplash</code>，使用刚刚创建的<code class="fe og oh oi nx b">Splash</code>对象作为参数，将此时消耗的水发送到后端。一旦完成，我们将用刚刚发布的<code class="fe og oh oi nx b">logId</code>更新<code class="fe og oh oi nx b">last_log_id</code>，然后休眠30分钟。</p><p id="80cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到这里有一个严重的缺陷。如果我在30分钟内记录了一个以上的水会话会怎样？在这种情况下，不幸的是，除了最后一个会话之外，我们将错过所有会话，因为系统只查看最近的一个会话。这是我将在下一次迭代中解决的问题。然而，说实话，我很确定在这段时间内我不会喝超过一次！</p><p id="e1da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">水之寻回犬到此为止。现在，让我们看看一旦后端接收到Splash会发生什么。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="4787" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">Archie和gRPC API</h1><p id="3df3" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Archie是用Go编写的系统后端服务之一，负责跟踪(内存中)水的会话，此后被称为<em class="lv">水花</em>。但是在我到达那里之前，我想描述一下我的项目的API服务，它是基于gRPC的。</p><p id="8f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了提醒您，我将快速说明gRPC是一个RPC(远程过程调用)框架。简单地说，它是一个从一个系统到另一个系统执行过程(在这种情况下是函数)的通信协议。我真正喜欢gRPC的地方是，它是使用协议缓冲区(也称为Protobuf)定义的，这是一种"<a class="ae ky" href="https://developers.google.com/protocol-buffers" rel="noopener ugc nofollow" target="_blank"> <em class="lv">语言中立、平台中立、可扩展的机制，用于序列化结构化数据</em> </a> <em class="lv">。</em>“我这里的意思是，一旦在Protobuf中定义了服务和对象，就可以使用众多代码生成器中的一个将其转换成它所支持的众多语言中的一种。</p><p id="9fde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整个事情有点难以理解，但是希望代码能够澄清一些事情:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="5db5" class="ob mt it nx b gy oc od l oe of">syntax = "proto3";<br/><br/>package api;<br/><br/>import "google/protobuf/timestamp.proto";<br/><br/>service DrinkWater {<br/>  rpc LogSplash(Splash) returns (LogSplashResponse);<br/>  rpc WaterConsumed(Since) returns (WaterConsumedSince);<br/>}<br/><br/>message LogSplashResponse {<br/>	bool ok = 1;<br/>	string error = 2;<br/>}<br/><br/>message Splash {<br/>	google.protobuf.Timestamp ts = 1;<br/>	int32 amount = 2;<br/>}<br/><br/>message Since {<br/>	google.protobuf.Timestamp ts = 1;<br/>}<br/><br/>message WaterConsumedSince {<br/>	int32 amount = 1;<br/>}</span></pre><p id="f44c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是项目的Protobuf文件。在前三行中，我只是设置语法、包名，并导入一个我喜欢使用的外部时间相关库。然后，我定义gRPC服务，命名为<code class="fe og oh oi nx b">DrinkWater</code>。如您所见，该服务由两个方法组成:<code class="fe og oh oi nx b">LogSplash</code>和<code class="fe og oh oi nx b">WaterConsumed</code>。前者<code class="fe og oh oi nx b">LogSplash</code>，我们之前看到的，以一个<code class="fe og oh oi nx b">Splash</code>为参数，返回一个<code class="fe og oh oi nx b">LogSplashResponse</code>，后者<code class="fe og oh oi nx b">WaterConsumed</code>，以一个自对象为参数，返回一个<code class="fe og oh oi nx b">WaterConsumedSince</code>(稍后我会详细介绍)。但是这些水和水花是什么？</p><p id="4138" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仪式结束后，你会找到这些信息的定义。其中第一个，Splash，包含两个字段:一个时间戳对象(我导入的那个东西)和一个整数(水以ml为单位。).然后是<code class="fe og oh oi nx b">LogSplashResponse</code>，它由一个布尔值和一个解释错误的字符串(如果有的话)组成，如果在<code class="fe og oh oi nx b">LogSplash</code>期间发生错误，这个布尔值将为假。接下来是<code class="fe og oh oi nx b">Since</code>消息，它封装了一个时间戳。最后，是由单个整数组成的<code class="fe og oh oi nx b">WaterConsumedSince</code>。</p><p id="d033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这五个结构定义了我的完整服务，但它们并不是我可以使用的实际源代码。所以，我的下一步是生成Golang和Python代码。</p><p id="5d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的实验和我的观点中，生成Go代码比Python简单得多。只需一个命令<code class="fe og oh oi nx b">$ go generate protoc -I=. — go_out=plugins=grpc:. endpoint.proto</code>(从Proto文件所在的目录执行)就可以生成代码。尽管如此，我使用Python的体验并不是最好的，因为一些<a class="ae ky" href="https://github.com/protocolbuffers/protobuf/issues/1491" rel="noopener ugc nofollow" target="_blank">问题</a>与生成代码所在的路径有关。对于那些对我如何创建Python代码感兴趣的人，这是我运行的命令(从水检索器的根目录)</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="75ec" class="ob mt it nx b gy oc od l oe of">$ python3 -m grpc_tools.protoc -I.:${PROJ}api/v1/ \<br/>— python_out=app/api/v1/ \ <br/>— grpc_python_out=app/api/v1/ ${PROJ}api/v1/endpoint.proto</span></pre><p id="c2e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是故事并没有就此结束。如果您照原样运行Water Retriever，它不会找到生成的代码。所以，我不得不进入众多<code class="fe og oh oi nx b">__init__.py</code>文件中的一个，并将当前目录附加到<code class="fe og oh oi nx b">PYTHONPATH</code>(我讨厌这一部分)。</p><p id="9cb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！现在我们有了生成的代码。但是我不会在这里展示，不会——那太无聊了！</p><p id="b750" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我将展示<em class="lv">实际上在做什么</em>。您可能已经注意到，Protobuf定义就是这样，<em class="lv">定义— </em>或函数的框架。在里面，没有任何功能。功能必须由你来描述。以下代码片段说明了这一点:</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="60b0" class="ob mt it nx b gy oc od l oe of">package endpoint<br/><br/>import (<br/>	"context"<br/>	"log"<br/><br/>	"cloud.google.com/go/bigquery"<br/>	"github.com/golang/protobuf/ptypes"<br/>	pb "github.com/juandes/teamaqua/api/v1"<br/>)<br/><br/>// Service implement the gRPC endpoints<br/>type Service struct {<br/>	splashes []*pb.Splash<br/>	uploader *bigquery.Uploader<br/>}<br/><br/>// NewService creates a new Service<br/>func NewService(u *bigquery.Uploader) *Service {<br/>	return &amp;Service{<br/>		splashes: []*pb.Splash{},<br/>		uploader: u,<br/>	}<br/>}<br/><br/>func (s *Service) LogSplash(ctx context.Context, in *pb.Splash) (*pb.LogSplashResponse, error) {<br/>	log.Println(in)<br/><br/>	s.splashes = append(s.splashes, in)<br/>	err := s.uploader.Put(ctx, in)<br/>	if err != nil {<br/>		// TODO: Handle error better and don't just exit :/<br/>		log.Fatalf("Error uploading to BQ: %v", err)<br/>	}<br/><br/>	return &amp;pb.LogSplashResponse{<br/>		Ok: true,<br/>	}, nil<br/>}<br/><br/>func (s *Service) WaterConsumed(ctx context.Context, in *pb.Since) (*pb.WaterConsumedSince, error) {<br/>	var waterConsumed int32<br/>	since, err := ptypes.Timestamp(in.Ts)<br/>	if err != nil {<br/>		log.Fatalf("Error converting ptypes.Timestamp to time: %v", err)<br/>	}<br/><br/>	for _, splash := range s.splashes {<br/>		splashTime, err := ptypes.Timestamp(splash.Ts)<br/>		if err != nil {<br/>			log.Fatalf("Error converting ptypes.Timestamp to time: %v", err)<br/>		}<br/><br/>		if splashTime.After(since) {<br/>			waterConsumed += splash.Amount<br/>		}<br/>	}<br/><br/>	return &amp;pb.WaterConsumedSince{<br/>		Amount: waterConsumed,<br/>	}, nil<br/>}</span></pre><p id="c471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码是我的服务结构，它实现了我们之前定义的gRPC方法。但是，除了实现函数，我的服务结构还负责保存<code class="fe og oh oi nx b">Splash</code>的列表。此外，这个结构还包含了<code class="fe og oh oi nx b">BigQuery</code>上传器，这个对象的功能是在<code class="fe og oh oi nx b">BigQuery</code>中写入行。为了简单起见，我不会展示服务的主要功能，在这里我初始化服务和上传者。如果你想看，在这里检查文件<a class="ae ky" href="https://github.com/juandes/team-aqua/blob/master/cmd/startserver/main.go" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="70ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个函数<code class="fe og oh oi nx b">NewService</code>只是创建新的服务对象。然后，还有<code class="fe og oh oi nx b">LogSplash</code>，一种服务方式。正如我们之前看到的，<code class="fe og oh oi nx b">LogSplash</code>带一个Splash(和一个上下文我就不解释了)，返回一个<code class="fe og oh oi nx b">LogSplashResponse</code>，和一个error(这是Golang特有的东西，可以随意忽略)。</p><p id="c26f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数的内容非常简单。首先，它打印Splash，然后将它附加到列表中并写入<code class="fe og oh oi nx b">BigQuery</code>。最后，它返回一个<code class="fe og oh oi nx b">LogSplashResponse</code>，其中“ok”为真。struct的第二个方法是<code class="fe og oh oi nx b">WaterConsumed</code>，它的作用是对给定时间戳后消耗的所有水量求和。阿奇的末日到了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5c96473d537013c96dcf5a5a8d1dd058.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/0*IHUhvfOPIvMyptYr.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">水之队的阿奇。任天堂(<a class="ae ky" href="https://bulbapedia.bulbagarden.net/wiki/File:Omega_Ruby_Alpha_Sapphire_Archie.png" rel="noopener ugc nofollow" target="_blank">来源</a>)</p></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="e8c9" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">提醒</h1><p id="ee1c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">第二个Golang服务是提醒，它的目的是提醒我喝水，或者在我喝水时祝贺我。这些提醒和祝贺将作为推送通知发送到我为这个唯一的项目编写的Android应用程序。下面的代码是完整的服务。与Archie不同，这个完全是在main函数中编写的(对此我并不感到自豪)。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="2c4f" class="ob mt it nx b gy oc od l oe of">package main<br/><br/>import (<br/>	"context"<br/>	"fmt"<br/>	"log"<br/>	"net/http"<br/>	"os"<br/>	"time"<br/><br/>	"firebase.google.com/go/messaging"<br/><br/>	firebase "firebase.google.com/go"<br/>	"github.com/golang/protobuf/ptypes"<br/>	pb "github.com/juandes/teamaqua/api/v1"<br/>	"github.com/spf13/pflag"<br/>	"google.golang.org/api/option"<br/>	"google.golang.org/grpc"<br/>)<br/><br/>const (<br/>	address         = "localhost:50051"<br/>	minutesInterval = 30<br/>)<br/><br/>var (<br/>	token             *string = pflag.String("token", "", "Firebase Token")<br/>	projectID         *string = pflag.String("project-id", "", "Firebase Project ID")<br/>	googleCredentials *string = pflag.String("google-credentials", "", "Google Service Account")<br/>)<br/><br/>func init() {<br/>	pflag.Parse()<br/>}<br/><br/>func main() {<br/>	log.Println("Starting Reminder service...")<br/>	conn, err := grpc.Dial(address, grpc.WithInsecure())<br/>	if err != nil {<br/>		log.Fatalf("did not connect: %v", err)<br/>	}<br/><br/>	ctx := context.Background()<br/>	c := pb.NewDrinkWaterClient(conn)<br/>	opt := option.WithCredentialsFile(*googleCredentials)<br/><br/>	fb, err := firebase.NewApp(ctx, &amp;firebase.Config{<br/>		ProjectID: *projectID,<br/>	}, opt)<br/><br/>	if err != nil {<br/>		log.Panicf("error initializing app: %v", err)<br/>	}<br/><br/>	fbMessaging, err := fb.Messaging(ctx)<br/>	if err != nil {<br/>		log.Panicf("error initializing Firebase Messaging client app: %v", err)<br/>	}<br/><br/>	response, err := fbMessaging.Send(ctx, &amp;messaging.Message{<br/>		Token: *token,<br/>		Notification: &amp;messaging.Notification{<br/>			Title: "Hello!",<br/>			Body:  "Reminder service running ...",<br/>		},<br/>		Data: map[string]string{},<br/>	})<br/><br/>	if err != nil {<br/>		log.Printf("Error sending Firebase notification: %v", err)<br/>	}<br/>	log.Println(response)<br/><br/>	go func() {<br/>		interval := time.NewTicker(minutesInterval * time.Minute)<br/><br/>		for {<br/>			select {<br/>			case &lt;-interval.C:<br/>				var title string<br/>				var body string<br/><br/>				log.Println("Executing...")<br/>				// current time minus minutes interval<br/>				t := time.Now().Add(time.Duration(-minutesInterval) * time.Minute)<br/><br/>				timestampProto, err := ptypes.TimestampProto(t)<br/>				if err != nil {<br/>					log.Fatalf("Error converting time to proto Timestamp: %v", err)<br/>					continue<br/>				}<br/><br/>				waterConsumed, err := c.WaterConsumed(ctx, &amp;pb.Since{<br/>					Ts: timestampProto,<br/>				})<br/>				if err != nil {<br/>					log.Printf("Error calling WaterConsumed: %v", err)<br/>					continue<br/>				}<br/><br/>				if waterConsumed.Amount == 0 {<br/>					title = "Reminder!"<br/>					body = fmt.Sprintf("You havent drink anything in the last %d minutes", minutesInterval)<br/>				} else {<br/>					title = "Good job!"<br/>					body = fmt.Sprintf("You had drunk %d in the last %d minutes", waterConsumed.Amount, minutesInterval)<br/>				}<br/><br/>				response, err := fbMessaging.Send(ctx, &amp;messaging.Message{<br/>					Token: *token,<br/>					Notification: &amp;messaging.Notification{<br/>						Title: title,<br/>						Body:  body,<br/>					},<br/>					Data: map[string]string{},<br/>				})<br/><br/>				if err != nil {<br/>					log.Printf("Error sending Firebase notification: %v", err)<br/>				}<br/>				log.Println(response)<br/><br/>			}<br/><br/>		}<br/><br/>	}()<br/><br/>	http.HandleFunc("/", handler)<br/><br/>	port := os.Getenv("PORT")<br/>	if port == "" {<br/>		port = "8080"<br/>	}<br/><br/>	log.Fatal(http.ListenAndServe(fmt.Sprintf(":%s", port), nil))<br/>}<br/><br/>func handler(w http.ResponseWriter, r *http.Request) {<br/>	fmt.Fprintf(w, "Hi!")<br/>}</span></pre><p id="d070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该服务要做的第一件事是创建一个到gRPC后端的连接。接下来，它创建一个Firebase消息服务(FMS)客户端。我将向我的应用程序发送推送通知，这样我就知道什么时候一切正常。</p><p id="bcc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个注意:要向特定设备发布消息，你需要知道手机的Firebase令牌，可以直接从应用程序获得<a class="ae ky" href="https://firebase.google.com/docs/cloud-messaging/android/client#retrieve-the-current-registration-token" rel="noopener ugc nofollow" target="_blank">(我稍后会展示更多)。一旦完成，我们将产生一个新的<code class="fe og oh oi nx b">Goroutine</code>(把它想象成一个后台线程)，它有一个无限的“for”循环，每X分钟触发一次。</a></p><p id="482d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每次循环迭代中，我们将计算当前时间减去X分钟。然后，使用这个新时间，系统将调用<code class="fe og oh oi nx b">WaterConsumed</code> gRPC方法来获取从那时起我记录的水量——该调用返回一个since对象。如果从时间t开始，水的消耗量等于零，它会给我发送一个通知，告诉我“你什么都没喝。”否则，信息会说，“你在过去的X分钟内喝了XXX毫升水。”除此之外，该服务还监听给定的端口。目前，这不做任何事情(除了返回“嗨！”)，但我计划让它执行健康检查。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="ec04" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">安卓应用</h1><p id="9513" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这个平台的最后一个重要组件是一个Android应用程序，它的唯一目的是接收来自FMS的消息并将它们转发给我。老实说，就这些。在下一个截图中，你会看到这个应用程序只是一个空屏幕，上面有一个“Hello World”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/e24dbb6cda296b3d6e00a6ff231b4fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h-wiugGA-KK-iUPZ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用程序。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/a1bc3d47a0f434f8a8942264eff30e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eHtOJWZrlzQoBESW"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通知。抱歉，我的英语不好。我还没有部署新的更改:)。</p></figure><p id="c4fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于代码，就像app看起来那么简单。它只包含一个活动(screen)，其目的是打印设备的Firebase令牌，这是指定通知的目标所需要的。在这样做之前，我们需要首先在应用程序上安装Firebase SDK(这是另一个故事，我不会涉及)。</p><p id="3578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是活动的代码。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="0263" class="ob mt it nx b gy oc od l oe of">package com.example.teamaqua<br/><br/>import androidx.appcompat.app.AppCompatActivity<br/>import android.os.Bundle<br/>import android.util.Log<br/>import android.widget.Toast<br/>import com.google.android.gms.tasks.OnCompleteListener<br/>import com.google.firebase.iid.FirebaseInstanceId<br/><br/>class MainActivity : AppCompatActivity() {<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/><br/>        FirebaseInstanceId.getInstance().instanceId<br/>            .addOnCompleteListener(OnCompleteListener { task -&gt;<br/>                if (!task.isSuccessful) {<br/>                    Log.w("MyFirebaseMsgService", "getInstanceId failed", task.exception)<br/>                    return@OnCompleteListener<br/>                }<br/><br/>                // Get new Instance ID token<br/>                val token = task.result?.token<br/><br/>                Log.d("This is token!", token)<br/>                Toast.makeText(baseContext, token, Toast.LENGTH_SHORT).show()<br/>            })<br/>    }<br/>}</span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="aee1" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">BigQuery和数据工作室</h1><p id="7421" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">阿奇的<em class="lv">存在理由之一</em>是将生成的数据写入<code class="fe og oh oi nx b">BigQuery</code>，这样我可以稍后回去分析它。现在，你可能会想，为什么？如果数据已经在Fitbit的服务器上，为什么我还要再存储一次？嗯，我想把这个弄得越复杂越好！但真正的原因是因为Data Studio，这是一个与BigQuery无缝集成的交互式仪表板，只需几次点击就可以可视化数据。</p><p id="2d15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Data Studio中，我创建了一个仪表板，其中显示了一个显示每天用水量的折线图，一个显示溅水次数的表格，以及两个显示总用水量和日平均用水量的记分卡。下面的截图就是一个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/82a999d96f8760aa29c02ccd26ce89e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yf_oUZUQZW-fP6Nn2-5HnA.png"/></div></div></figure><p id="98bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我还是需要多喝水…</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="993b" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">部署和对接</h1><p id="e7c7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们就要到达终点了。我们还需要做最后一件事:部署和运行系统。</p><p id="fea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，这并不像我希望的那样直接。我在这里遇到的大多数问题(它们不是实际问题，只是小问题)都是由于系统的微服务和架构设计，因为我想让所有东西都保持在同一个Docker映像中。最重要的是，由于我使用了几个秘密和密钥，我不得不考虑它们的管理。我们来看一下整个(短)过程。</p><p id="5e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是创建Docker映像。它是基于官方的<a class="ae ky" href="https://hub.docker.com/_/golang/" rel="noopener ugc nofollow" target="_blank"> Golang </a> one。然后，对于第一个指令，我们将复制整个项目(是的，所有的东西！)到图像。接下来，我们运行一些测试(非常重要！)并在容器中构建Go二进制文件——以避免可能的交叉编译问题。之后，我们需要安装Python 3(现在是2019年，人)，一些工具，以及Water Retriever需要的库。最后一步，我们将执行启动服务的<code class="fe og oh oi nx b">run(.)sh</code>脚本。下面的两个脚本都是Dockerfile和<code class="fe og oh oi nx b">run.sh</code></p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="1433" class="ob mt it nx b gy oc od l oe of">FROM golang:1.12<br/><br/>WORKDIR /go/src/github.com/juandes/teamaqua<br/>COPY . .<br/><br/>RUN echo $GOPATH<br/>RUN make test<br/>RUN make go-build<br/><br/>RUN apt-get update<br/>RUN DEBIAN_FRONTEND='noninteractive' apt-get install -y --no-install-recommends python3.6  python3-pip python3-setuptools screen<br/><br/>RUN pip3 install -r water_retriever/requirements.txt<br/><br/>CMD [ "./run.sh"]</span><span id="b260" class="ob mt it nx b gy on od l oe of">#!/usr/bin/env bash<br/><br/>echo "Starting Server"<br/>screen -d -m build/startserver --gcp-project=$GCP_PROJECT --bq-dataset=$BQ_DATASET --bq-table=$BQ_TABLE<br/><br/>echo "Starting Reminder"<br/>screen -d -m build/reminder --project-id=$GCP_PROJECT --token=$FB_TOKEN --google-credentials=path/to/credentials.json <br/><br/>screen -list<br/><br/>echo "Starting Water Retriever"<br/>python3 water_retriever/client.py</span></pre><p id="6bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi nx b">run.sh</code>脚本将首先使用<a class="ae ky" href="https://en.wikipedia.org/wiki/GNU_Screen" rel="noopener ugc nofollow" target="_blank"> GNU Screen </a>在后台执行两个Go服务(如果有人知道更好的方法，请告诉我)。然后，在前景中，我们将启动水检索器。请记住组件需要的不同参数(Google Cloud project、Firebase token等等)——这些参数来自环境变量。此外，Water Retriever还需要Fitbit键，这些键也来自运行Docker映像时必须声明的env变量。下一行是我正在使用的命令的例子。</p><pre class="kj kk kl km gt nw nx ny nz aw oa bi"><span id="980d" class="ob mt it nx b gy oc od l oe of">docker run -d -e FITBIT_KEY=ABCDEF \<br/> -e FITBIT_SECRET=abcdef1234567 \<br/> -e ACCESS_TOKEN=12345678 \<br/> -e REFRESH_TOKEN=12345678 \<br/> -e GOOGLE_APPLICATION_CREDENTIALS=path/to/credentials.json \<br/> -e GCP_PROJECT=xxx \<br/> -e BQ_DATASET=xxx \<br/> -e BQ_TABLE=xxx \<br/> -e FB_TOKEN=xxx \<br/> gcr.io/xxx/xxx:tag</span></pre><p id="49bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说到运行Docker，我想提一下，我没有在公共回购中推送图像(抱歉，它包含了太多秘密)，而是在Google容器注册表中推送。事后看来，这是一个正确的决定，因为从注册表的GUI中，您可以快速生成一个新的计算引擎实例，其中已经加载了映像。默认情况下，机器将执行图像，但是在我的例子中，它崩溃了，因为它缺少凭证、密钥等等。因此，您必须SSH并手动运行它。</p><p id="d105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇，我想就这些吧！</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="566d" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">总结和结论</h1><p id="2d8e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">最后3000字介绍了一个平台，目标是提醒我喝水。同样，我意识到我可以使用我的许多应用程序中的一个来实现这个目的。然而，我想建立自己的，看看我能走多远。项目不会就此结束(好吧，也许会)。我想实施一系列功能，例如我提到的运行状况检查、自定义控制面板、指标和警报。但与此同时，我会享受一杯水(并记录下来)。</p><p id="3017" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><p id="d769" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码可在https://github.com/juandes/team-aqua获得</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/72c635cbf8f504dd763e06e9148cd68d.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*lTEiU-NW3tmweAf2.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">漫游数据</p></figure></div></div>    
</body>
</html>