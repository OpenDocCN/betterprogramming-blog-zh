<html>
<head>
<title>How To Test Your React Container Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试React容器组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-your-react-container-components-fd71071cc3e0?source=collection_archive---------2-----------------------#2019-06-28">https://betterprogramming.pub/how-to-test-your-react-container-components-fd71071cc3e0?source=collection_archive---------2-----------------------#2019-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d4e64361c2e60d7f02f0385399347a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0CTr68QplmJURrvcBLz2g.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@chuttersnap?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae kc" href="https://unsplash.com/search/photos/containers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3051" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用<a class="ae kc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae kc" href="https://redux.js.org/introduction/getting-started" rel="noopener ugc nofollow" target="_blank"> Redux </a>时，您面临着测试您的智能组件(通常称为容器)的挑战。有几种方法可以做这件事。</p><p id="ac2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文假设你对<a class="ae kc" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>、<a class="ae kc" href="https://airbnb.io/enzyme/" rel="noopener ugc nofollow" target="_blank"> Enzyme </a>和JavaScript有基本的了解。</p><p id="ff2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在接下来的例子中，我将首先向您展示非连接方法(#1)，然后是连接方法(#2)。最后一个比前面一个有更多的好处，我将在后面演示。</p><h2 id="ce43" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">该组件</h2><p id="91af" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">我们将使用以下组件作为示例。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">#片段1</p></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="aea8" class="mm lc iq bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">#1 —不相关的方法</h1><p id="a2f1" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><strong class="kf ir">测试你的组件和容器相互隔离。</strong></p><p id="3839" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您从全局状态获得标题和描述。您可以通过props传递预期的参数来测试组件。</p><p id="4ff0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redux最后就是这么做的，为什么不直接做，断言最终结果呢？</p><p id="9ac0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对此的一个基本测试是直接传递props，正如组件所期望的那样。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">#片段2</p></figure><p id="d94e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的问题是，我们并没有断言来自商店的映射输出了那些道具。</p><p id="54fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，最后，您测试了组件，但是您不确定容器是否映射了正确的属性，所以您通过如下方式单独测试它:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">#片段3</p></figure><p id="c111" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法有几个缺点:</p><ul class=""><li id="70c2" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated">为了进行测试，您必须导出<code class="fe nm nn no np b">mapStateToProps</code>、<code class="fe nm nn no np b">mapDispatchToProps</code>和<code class="fe nm nn no np b">Component</code>。</li><li id="72ab" class="nd ne iq kf b kg nq kk nr ko ns ks nt kw nu la ni nj nk nl bi translated">你还有另一组测试要做。</li><li id="6e31" class="nd ne iq kf b kg nq kk nr ko ns ks nt kw nu la ni nj nk nl bi translated">容器测试是乏味的，并且无法使用<a class="ae kc" href="https://en.wikipedia.org/wiki/Behavior-driven_development" rel="noopener ugc nofollow" target="_blank"> BDD </a>思维模式进行测试。</li><li id="0a68" class="nd ne iq kf b kg nq kk nr ko ns ks nt kw nu la ni nj nk nl bi translated">您没有测试组件和连接一起工作的真实场景。</li></ul><p id="14a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，让我演示一下这种方法是如何容易出错的。假设您的Redux商店中有一些逻辑。</p><p id="fcc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">#片段4</p></figure><p id="76c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，您检查浏览器是否大于SM(断点)以返回完整的标题值，否则，您将返回该道具的短标题值。</p><p id="6f3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用第一种方法，您将无法在<code class="fe nm nn no np b">Header.test.js</code>上测试这个场景。</p><p id="f8ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你仍然可以使用<code class="fe nm nn no np b">HeaderContainer.test.js</code> <em class="nv"> </em>来测试它，但是用更多的道具和更多的逻辑来扩展这个组件将会把它变成一个测试的噩梦，并且会非常混乱。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="8572" class="mm lc iq bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">#2 —关联方法</h1><p id="f49b" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated"><strong class="kf ir">一起测试组件和容器。</strong></p><p id="ec14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经看到，第一种方法有点乏味，不是很有效，并且它没有测试与Redux store集成的React组件。</p><p id="6c88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于下一个方法，您需要使用<code class="fe nm nn no np b">redux-mock-store</code>的<code class="fe nm nn no np b">configureStore</code>。</p><p id="7b24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将您的<code class="fe nm nn no np b">initialState</code>作为一个参数传递给具有<code class="fe nm nn no np b">configureStore</code>属性的常量，并将其保存在另一个常量中。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">#片段5</p></figure><p id="2e01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们使用<code class="fe nm nn no np b">.dive</code>和<code class="fe nm nn no np b">toJson</code>来获得组件本身的清晰快照，而不使用mount。</p><p id="2377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就测试了到props和组件本身的Redux映射。</p><p id="4a1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">有几个优点:</strong></p><ul class=""><li id="b1ee" class="nd ne iq kf b kg kh kk kl ko nf ks ng kw nh la ni nj nk nl bi translated">更精确的测试。</li><li id="ea8a" class="nd ne iq kf b kg nq kk nr ko ns ks nt kw nu la ni nj nk nl bi translated">连接测试。(每一个测试，除了他们自己的目的之外，还测试商店是否返回预期的结果。)</li><li id="77d7" class="nd ne iq kf b kg nq kk nr ko ns ks nt kw nu la ni nj nk nl bi translated">更可靠的测试和更不容易出错的测试。</li><li id="3949" class="nd ne iq kf b kg nq kk nr ko ns ks nt kw nu la ni nj nk nl bi translated">不必要的容器测试文件。</li><li id="34d9" class="nd ne iq kf b kg nq kk nr ko ns ks nt kw nu la ni nj nk nl bi translated">智能组件中只有一个导出(连接)。</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="4dae" class="mm lc iq bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">奖金</h1><p id="8944" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">您想用不同的状态进行测试，而不重新创建上面的<em class="nv"> # Snippet 5 </em>中显示的样板文件吗？</p><p id="680b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使这个助手函数:</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">#片段6</p></figure><p id="f504" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，不用重复<em class="nv"> # Snippet 5 </em>中所示的步骤，只需将初始状态更改为您想要的状态，并使用<code class="fe nm nn no np b">mockStore</code>功能。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">#片段7</p></figure></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="3eab" class="mm lc iq bd ld mn mo mp lg mq mr ms lj mt mu mv lm mw mx my lp mz na nb ls nc bi translated">结论</h1><p id="507e" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">总而言之，测试您的React-Redux集成组件，因为它们将在真实情况下工作。</p><p id="ba70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，测试应该覆盖组件的预期行为，也包括Redux存储。</p><p id="305d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝测试愉快！</p></div></div>    
</body>
</html>