<html>
<head>
<title>3 Valuable Terminal One-Liners To Boost Your Workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个有价值的终端一行程序来加速您的工作流程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-valuable-terminal-one-liners-to-boost-your-workflow-a70386155bfc?source=collection_archive---------9-----------------------#2021-04-13">https://betterprogramming.pub/3-valuable-terminal-one-liners-to-boost-your-workflow-a70386155bfc?source=collection_archive---------9-----------------------#2021-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9901" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用这些简单的shell命令完成更多工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eeb96d31ec0a84026887d2485653f5d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VppYasNYi5EG0mZ5"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@nihongraphy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">日本摄影</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="82b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名成熟的程序员，开发命令和脚本是你日常工作流程中不可或缺的一部分。</p><p id="b5be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将分享三个单行命令，它们是我工作流程中很有价值的一部分。这些命令在这里是因为它们有用，而不是因为它们复杂！</p><p id="eb78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三个命令是:</p><ol class=""><li id="2cbb" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">使用<code class="fe mb mc md me b">grep</code>在文件中查找文本，</li><li id="782a" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">查看JSON和CSV文件。</li><li id="0fb5" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr lx ly lz ma bi translated">更新Python需求文件。</li></ol><p id="21fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">注意:本文遵循用</em> <code class="fe mb mc md me b"><em class="mk">$</em></code> <em class="mk">启动shell命令的惯例。对于由shell扩展的命令，我将在下面显示不带</em> <code class="fe mb mc md me b"><em class="mk">$</em></code> <em class="mk">的扩展命令。</em></p><p id="62fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我交替使用外壳和终端这两个术语。这些命令都与zsh兼容。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="ebcd" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">任务1 —使用grep在文件中查找文本</h1><p id="b0cb" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">在终端中工作的一个常见任务是查找包含特定文本字符串的文件。</p><p id="cfc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是用来回答以下问题的:</p><ul class=""><li id="f93f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">我在哪个文件中定义了<code class="fe mb mc md me b">Model</code>类？</li><li id="b1d9" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr np ly lz ma bi translated">我在哪里写了关于反向传播的笔记？</li><li id="2ad1" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr np ly lz ma bi translated">哪个文件里有我奶奶的秘方？</li></ul><p id="1d99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多工具可以完成这项任务。<code class="fe mb mc md me b">awk</code>、<code class="fe mb mc md me b">sed</code>、<code class="fe mb mc md me b">find</code>、<code class="fe mb mc md me b">grep</code>都能做到这一点。有这么多不同的方法来完成相同的任务是令人不知所措的——关键是找到适合你的工具。</p><p id="1cc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们来说，这个工具就是<code class="fe mb mc md me b">grep</code>。它用于基于正则表达式(regex)匹配文本。然而，您不需要了解regex就能从<code class="fe mb mc md me b">grep</code>中获得价值！</p><p id="b011" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当试图学习一个像<code class="fe mb mc md me b">grep</code>这样强大的工具时，一个挑战是它可以做大量的事情。使用强大的工具通常遵循帕累托分布——少数用例提供了大部分价值。</p><p id="1726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe mb mc md me b">grep</code>，这些强大的用例之一是在文件中搜索文本，如果匹配就返回文件名。为此，我们向<code class="fe mb mc md me b">grep</code>传递三个参数:</p><ul class=""><li id="6da1" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated"><code class="fe mb mc md me b">-i</code>忽略大小写。</li><li id="c838" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr np ly lz ma bi translated"><code class="fe mb mc md me b">-r</code>递归搜索(深入文件系统)。</li><li id="0a84" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr np ly lz ma bi translated"><code class="fe mb mc md me b">-l</code>返回文件名。</li></ul><p id="6c4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，要在当前目录和更深的目录中搜索包含文本<code class="fe mb mc md me b">class Model</code>的文件(因此是<code class="fe mb mc md me b">.</code>):</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="08a3" class="nu mt iq me b gy nv nw l nx ny">$ grep -irl 'class Model' .</span></pre><p id="a319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我发现<code class="fe mb mc md me b">grep</code>的这个配置非常有用，所以我将它映射到一个别名<code class="fe mb mc md me b">g</code>(在我的<code class="fe mb mc md me b">.zshrc</code>中定义):</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="29da" class="nu mt iq me b gy nv nw l nx ny">alias g='grep -irl '</span></pre><p id="e47f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许仅使用单个字符进行搜索:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="e1e5" class="nu mt iq me b gy nv nw l nx ny">$ g 'class Model' .</span></pre><p id="b1b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想缩小要搜索的文件夹范围，您可以指定它，而不是使用<code class="fe mb mc md me b">.</code>。例如，要仅在名为<code class="fe mb mc md me b">src</code>的文件夹中搜索，我们可以使用:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="4ba5" class="nu mt iq me b gy nv nw l nx ny">$ g 'class Model' src</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="6dc6" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">任务2 —查看JSON和CSV文件</h1><p id="2849" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">将数据存储在文本中的好处之一是，我们可以使用与编写代码相同的工具来处理它们。然而，这些工具通常不会以最佳方式可视化数据。</p><p id="bafc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以一个简单的JSON文件为例，<code class="fe mb mc md me b">data.json</code>:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="ff5c" class="nu mt iq me b gy nv nw l nx ny"># data.json<br/>{"outer":{"inner":"value"}}</span></pre><p id="8795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mb mc md me b">cat</code>将打印出文件，而不会试图使结构更具可读性:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="3da5" class="nu mt iq me b gy nv nw l nx ny">$ cat data.json<br/>{"outer":{"inner":"value"}}</span></pre><p id="7860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里更好的方法是将<code class="fe mb mc md me b">cat</code>的输出通过管道传输到<code class="fe mb mc md me b">jq</code>，这是一个为处理JSON而设计的程序。这将以更有用的方式显示文件的结构:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="13e0" class="nu mt iq me b gy nv nw l nx ny">$ json data.json<br/>{<br/>  "outer": {<br/>    "inner": "value"<br/>  }<br/>}</span></pre><p id="a5e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我经常使用它，以至于在我的<code class="fe mb mc md me b">.zshrc</code>中定义了一个简单的函数:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="856c" class="nu mt iq me b gy nv nw l nx ny"># ~/.zshrc<br/>json() {<br/>  cat $1 | jq | less<br/>}</span></pre><p id="075b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许随时从shell中快速、轻松地查看JSON文件:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="d662" class="nu mt iq me b gy nv nw l nx ny">$ json data.json<br/>{<br/>  "outer": {<br/>    "inner": "value"<br/>  }<br/>}</span></pre><p id="f39c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文本数据的另一种常见形式是CSV。假设我们在<code class="fe mb mc md me b">data.csv</code>中以CSV格式存储了一些数据:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="e51c" class="nu mt iq me b gy nv nw l nx ny"># data.csv<br/>col1,col2,col3<br/>10,20,30<br/>30,40,50</span></pre><p id="957c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mb mc md me b">cat</code>查看该文件会使结构难以阅读:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="e58c" class="nu mt iq me b gy nv nw l nx ny">$ cat data.csv<br/>col1,col2,col3<br/>10,20,30<br/>30,40,50</span></pre><p id="a168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过程序<code class="fe mb mc md me b">column</code>使用以下标志来改进该文件的显示方式:</p><ul class=""><li id="d482" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated"><code class="fe mb mc md me b">-t</code>创建一个表格。</li><li id="20f2" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr np ly lz ma bi translated"><code class="fe mb mc md me b">-s,</code>表示数据用逗号分隔。</li></ul><p id="17a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为CSV通常有许多行，所以将<code class="fe mb mc md me b">column</code>的输出传递到<code class="fe mb mc md me b">less</code>中会很有用，这样就可以对文件进行分页。</p><p id="14ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也可以使用带有<code class="fe mb mc md me b">less</code>的<code class="fe mb mc md me b">-S</code>标志在屏幕的宽度上切断列:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="e246" class="nu mt iq me b gy nv nw l nx ny">$ cat data.csv | column -t -s, | less -S<br/>col1  col2  col3<br/>10    20    30<br/>30    40    50</span></pre><p id="4bea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于<code class="fe mb mc md me b">json</code>命令，我在我的<code class="fe mb mc md me b">.zshrc</code>中保存了一个名为<code class="fe mb mc md me b">csv</code>的命令:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="bb1c" class="nu mt iq me b gy nv nw l nx ny"># ~/.zshrc<br/>csv() {<br/>  cat $1 | column -t -s, | less -S<br/>}</span></pre><p id="2837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样可以从外壳上轻松快速地查看CSV:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="99d3" class="nu mt iq me b gy nv nw l nx ny">$ csv data.csv<br/>col1  col2  col3<br/>10    20    30<br/>30    40    50</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="525d" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">任务3 —更新需求文件</h1><p id="a6a0" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">许多编程语言使用文本文件来跟踪依赖性，例如JavaScript中的<code class="fe mb mc md me b">package.json</code>或Python中的<code class="fe mb mc md me b">requirements.txt</code>。</p><p id="e688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Python的一个常见工作流是在开发项目时安装包，而不指定包的版本。稍后，当我们想要与其他人共享项目时，我们想要在我们的<code class="fe mb mc md me b">requirements.txt</code>中指定我们最终使用的版本。</p><p id="5527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缓慢的方法是:</p><ul class=""><li id="6e46" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr np ly lz ma bi translated">运行<code class="fe mb mc md me b">pip freeze</code>(将安装包打印到STDOUT)。</li><li id="5d0a" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr np ly lz ma bi translated">滚动以查找包。</li><li id="e54a" class="ls lt iq ky b kz mf lc mg lf mh lj mi ln mj lr np ly lz ma bi translated">复制这个包并粘贴到我们的<code class="fe mb mc md me b">requirements.txt</code>文件中。</li></ul><p id="1cf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们可以在一行代码中完成所有这些工作！</p><p id="f689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们用管道将<code class="fe mb mc md me b">pip freeze</code>连接到<code class="fe mb mc md me b">grep</code>，使用<code class="fe mb mc md me b">grep</code>来匹配具有我们的包名(在本例中是<code class="fe mb mc md me b">streamlit</code>)的行:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="3f01" class="nu mt iq me b gy nv nw l nx ny">$ pip freeze | grep streamlit<br/>streamlit==0.79.0</span></pre><p id="babb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以将该命令的输出附加到我们的<code class="fe mb mc md me b">requirements.txt</code>文件中:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="3dbb" class="nu mt iq me b gy nv nw l nx ny">$ pip freeze | grep streamlit &gt;&gt; requirements.txt</span></pre><p id="dceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe mb mc md me b">requirements.txt</code>文件现在将包含<code class="fe mb mc md me b">streamlit</code>，并指定了正确的版本:</p><pre class="kg kh ki kj gt nq me nr ns aw nt bi"><span id="ecac" class="nu mt iq me b gy nv nw l nx ny">$ tail -n 1 requirements.txt<br/>streamlit==0.79.0</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="4389" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="6fdb" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">感谢阅读！</p><p id="b5c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢读这篇文章，一定要看看我关于三个不常见的Bash技巧的其他更好的编程文章。</p><p id="ddf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">原载于</em><a class="ae kv" href="https://www.datasciencesouth.com/blog/terminal-one-liners" rel="noopener ugc nofollow" target="_blank"><em class="mk">https://www.datasciencesouth.com</em></a><em class="mk">。</em></p></div></div>    
</body>
</html>