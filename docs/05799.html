<html>
<head>
<title>Snapshot Testing Your GraphQL API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快照测试您的GraphQL API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/snapshot-testing-your-graphql-api-50d88a5b67d?source=collection_archive---------7-----------------------#2020-08-06">https://betterprogramming.pub/snapshot-testing-your-graphql-api-50d88a5b67d?source=collection_archive---------7-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f78" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Node.js中的Jest快照，通过集成测试轻松实现API的大范围覆盖</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e291af2e601167574eff33738438a657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QTJj_q7zBUN5DsnE_Wf0JA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">费伦茨·阿尔马西在<a class="ae kv" href="https://unsplash.com/s/photos/jest?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="9ca8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">快照测试是由像<a class="ae kv" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>这样的框架推广的，目的是快速有效地跟踪意外的变化以对组件做出反应。然而，这个概念可以从前端中去掉，并为后端测试找到同样的效用。</p><p id="11ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将向您展示如何使用Node.js中的Jest快照通过集成测试轻松实现API的大范围覆盖。</p><p id="de1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的几节中，我们将介绍:</p><ul class=""><li id="0960" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">快照测试的好处</li><li id="3fb2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何设置测试环境</li><li id="f30c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">随着时间的推移管理快照测试</li></ul><p id="06e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们开始吧。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="a338" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">快照测试的优势</h1><p id="ac10" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">测试通常有一个甜蜜点。目标很少是100%的覆盖率，但是你应该致力于使用正确的测试，并在流畅性和稳定性之间找到平衡。</p><p id="75cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当覆盖应用程序的核心部分时，单元测试才是王道，我并不提倡在这里使用快照。</p><p id="e122" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，它们的实用程序更适合于集成测试和断言给定的请求返回给定的响应。通过这样做，您将获得对所有解析器的广泛覆盖，同时能够随着应用程序的增长轻松地更改测试。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="460d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">设置测试环境</h1><p id="1a6c" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们需要一种方法向我们的<a class="ae kv" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务器发送请求，并将响应捕获为快照。我使用apollo-server-testing来做这件事，但是你可以使用类似于<a class="ae kv" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> supertest </a>的东西来代替。</p><p id="9264" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了减少对特定项目的假设，我将展示一种不可知的快照测试方法。实际上，您可能希望为每个测试播种/拆除数据库并模拟第三方请求。</p><p id="8028" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装我们的两个核心依赖项:</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="309f" class="np mo iq nl b gy nq nr l ns nt">yarn add apollo-server-testing jest</span></pre><p id="ffa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要两个文件:</p><ol class=""><li id="1c58" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr nu ly lz ma bi translated">测试用例，作为每个请求的GraphQL查询字符串。</li><li id="db43" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr nu ly lz ma bi translated">我们的测试运行人员处理并记录每个测试用例的快照。</li></ol><h2 id="c6e1" class="np mo iq bd mp nv nw dn mt nx ny dp mx lf nz oa mz lj ob oc nb ln od oe nd of bi translated">测试案例</h2><p id="ce0b" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在规模上，我们可能会为每组解析器创建不同的测试文件，但是现在，让我们假设我们有一个名为<code class="fe og oh oi nl b">resolvers.test.js</code>的文件。</p><p id="3d48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们可以添加我们的测试用例，这是一个包含GraphQL查询字符串和任何与查询相关的变量的对象数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9f91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件的底部，您可以看到我们将<code class="fe og oh oi nl b">testCases</code>传递给了一个名为<code class="fe og oh oi nl b">runTestCases</code>的函数。我们还为这组将应用于输出快照的测试用例提供了一个名称。</p><p id="1ea1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们继续编写测试运行程序本身。</p><h2 id="7b38" class="np mo iq bd mp nv nw dn mt nx ny dp mx lf nz oa mz lj ob oc nb ln od oe nd of bi translated">创建测试运行程序</h2><p id="75a2" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">如您所知，快照测试是一个非常快速的过程。因此，在最简单的形式中，我们将创建一个测试客户端，并将每个查询传递给它。然后，我们等待回应并记录下来。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="e8ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在当运行<code class="fe og oh oi nl b">jest</code>命令时，Jest将在<code class="fe og oh oi nl b">__snapshots__/resolvers.test.js.snap</code>下记录响应:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="27ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从现在起，您可以快速添加和删除每个解析器的测试。根据您的用例，您甚至可以为每个测试播种/丢弃一个数据库，提供独立的端到端覆盖。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="c554" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">管理一段时间内的快照测试</h1><p id="eb35" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">随着项目随着时间的推移而增长，大型重构发生了，您可以继续运行您的测试，并看到快照提供了相同的输出。如果你需要更新快照，运行<code class="fe og oh oi nl b">jest -u</code>，它将替换内容。</p><p id="4014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新快照时，验证新输出是否如您所期望的那样是极其重要的。我见过许多开发人员不假思索地运行<code class="fe og oh oi nl b">jest -u</code>并提交代码。这很容易通过公关评论发现。但是当独自工作时，对这个过程要严格要求。</p><p id="cbf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我使用了VSCode，并发现源代码控制选项卡下的diff工具是在完成重构时监视对快照的意外更改的极好方法。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="424a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">额外信息</h1><h2 id="cf06" class="np mo iq bd mp nv nw dn mt nx ny dp mx lf nz oa mz lj ob oc nb ln od oe nd of bi translated">我该进入<code class="fe og oh oi nl b">createTestClient</code>什么？</h2><p id="f9ac" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">在上面的例子中，我传递了一个方法到<code class="fe og oh oi nl b">createTestClient</code>中，叫做<code class="fe og oh oi nl b">createServer</code>。这只是一个包含您的解析器的ApolloServer实例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="a3e7" class="np mo iq bd mp nv nw dn mt nx ny dp mx lf nz oa mz lj ob oc nb ln od oe nd of bi translated">我如何处理突变？</h2><p id="c6ec" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated"><code class="fe og oh oi nl b">createTestClient</code>返回包含<code class="fe og oh oi nl b">{ query, mutate }</code>的对象。您必须将相应的字符串传递到正确的方法中。在<code class="fe og oh oi nl b">testCases</code>对象中，您可以在名为<code class="fe og oh oi nl b">mutate</code>的键下添加突变，或者编写一个小函数从字符串本身来检测:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="ec60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你还有什么问题，请告诉我。</p></div></div>    
</body>
</html>