<html>
<head>
<title>10 Powerful @Attributes in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift的10大@特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-powerful-attributes-in-swift-d4e4153a0001?source=collection_archive---------3-----------------------#2020-09-16">https://betterprogramming.pub/10-powerful-attributes-in-swift-d4e4153a0001?source=collection_archive---------3-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="20e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何正确有效地使用属性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7533aa64601890cf58b750e5276319b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QjsvBVifljYN9W58"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a7a7" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@逃避</h1><p id="9276" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">它通常用作作为函数参数传递的<code class="fe mu mv mw mx b">escaping</code>闭包。当函数结束并被执行时，它存在于内存中。</p><p id="9772" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">当将可选闭包定义为属性时，默认情况下它已经在转义了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="1636" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">逸出的封闭物可以储存起来以备后用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4edc" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">也可以在函数结束后执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2cd6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@未知</h1><p id="79db" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">@unknown</code>是用<code class="fe mu mv mw mx b">@frozen</code>和<code class="fe mu mv mw mx b">@nonfrozen</code>枚举引入的。未冻结的枚举可能在将来获得新的枚举实例。例如，<code class="fe mu mv mw mx b">UILayoutConstraintAxis</code>目前包含两个轴:<code class="fe mu mv mw mx b">AxisHorizontal</code>和<code class="fe mu mv mw mx b">AxisVertical</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="e497" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">稍后可能会获得另一个案例<code class="fe mu mv mw mx b">axisZ</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="82a6" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">为了安全地避免编译错误:</p><pre class="kj kk kl km gt nf mx ng nh aw ni bi"><span id="1c4d" class="nj lh it mx b gy nk nl l nm nn">error: switch must be exhaustive</span></pre><p id="18ab" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们用<code class="fe mu mv mw mx b">@unknown</code>属性实现开关:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="357e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@属性包装器</h1><p id="afb3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当将属性包装应用于类、结构或枚举的属性时，它通过包装类型的实例包装对属性的访问。</p><p id="afed" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">包装器必须定义一个<code class="fe mu mv mw mx b">wrappedValue</code>，它是公开属性的getter和setter。下面的示例从传入的字符串值中修剪空白和换行符:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a62a" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">要使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4ca5" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">属性包装也可以接受参数作为默认值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c4fd" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">为了直接访问包装的属性，我们使用<code class="fe mu mv mw mx b">_</code>作为前缀名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="40a0" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@可用</h1><p id="0b71" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">它表示该声明仅在特定的Swift语言版本或操作系统版本中可用。</p><p id="971c" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">例如，使用仅在iOS 13+中可用的复合<code class="fe mu mv mw mx b">UICollectionView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="a3fb" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@discardableResult</h1><p id="1379" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">它表示可以忽略函数的结果，而不会出现编译器警告。</p><p id="7f75" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在我们将<code class="fe mu mv mw mx b">@discardableResult</code>应用到函数之前，当调用函数而不使用其结果时，编译器会报错<code class="fe mu mv mw mx b">Result of call to '' is unused</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="67a4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">为了消除警告，我们使用<code class="fe mu mv mw mx b">@discardableResult</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="c13d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@dynamicCallable</h1><p id="dd5b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated"><code class="fe mu mv mw mx b">@dynamicCallable</code>比<code class="fe mu mv mw mx b">@dynamicMemberLookup</code>更进一步。这是语法上的好处，而不是任何形式的编译器魔术。它适用于类、结构、枚举或协议，将该类型的实例视为可调用函数。</p><p id="28f6" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">要使用它，我们需要添加<code class="fe mu mv mw mx b">@dynamicCallable</code>属性并实现下面的一个或两个方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="182e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@ dynamicMemberLookup</h1><p id="fbd7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">它是在<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md" rel="noopener ugc nofollow" target="_blank"> Swift演进提案SE-0195 </a>中介绍的。它指示Swift在访问属性时调用一个<code class="fe mu mv mw mx b">subscript</code>方法。我们需要在使用时添加<code class="fe mu mv mw mx b">subscript</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6265" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">对于下面的实例，我们用成员<code class="fe mu mv mw mx b">firstname</code>和<code class="fe mu mv mw mx b">lastname</code>实现了<code class="fe mu mv mw mx b">User</code>结构。这些属性不是作为属性存在的，而是在运行时查找的。<code class="fe mu mv mw mx b">dynamicMember</code>在字典中查找属性成员<code class="fe mu mv mw mx b">firstname</code>和<code class="fe mu mv mw mx b">lastname</code>并返回其值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4fe3" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@main</h1><p id="7c6b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Swift 5.3中的<code class="fe mu mv mw mx b">@Argument</code>属性变得更加实用，尤其是在创建Swift CLI工具时。它应用于类、结构或枚举声明，以指示它包含顶级入口点。必须提供<code class="fe mu mv mw mx b">main()</code>功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e438" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@UIApplicationMain</h1><p id="93df" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这可能是最广为人知的属性，因为它位于<code class="fe mu mv mw mx b">AppDelegate.swift</code>文件中，指示iOS应用程序的主入口点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="8e7b" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">@NSApplicationMain</h1><p id="cee4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当我们创建一个OS X项目时，Xcode会生成一个<code class="fe mu mv mw mx b">main.swift</code>文件。此属性应用于app委托类，以便为app生成隐式main。它和iOS应用的<code class="fe mu mv mw mx b">@UIApplicationMain</code>作用一样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="3f29" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="696c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">Swift在不同版本中不断增加@属性。正确高效地理解和使用它们，可以给我们带来干净的代码和更好的app性能。</p><p id="2117" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">感谢您的阅读。在评论中留下你可能有的任何问题。</p><p id="359b" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">上面提到的所有代码都可以在这个<a class="ae ky" href="https://gist.github.com/ericleiyang/14a335601f5046a02e73a0756318a4e9" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p></div></div>    
</body>
</html>