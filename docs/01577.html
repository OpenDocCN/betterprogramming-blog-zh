<html>
<head>
<title>Understanding the JavaScript Spread Operator — Advanced Uses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript扩展运算符—高级用途</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-javascript-spread-operator-from-beginner-to-expert-part-2-1ec1808d015e?source=collection_archive---------4-----------------------#2019-09-25">https://betterprogramming.pub/understanding-the-javascript-spread-operator-from-beginner-to-expert-part-2-1ec1808d015e?source=collection_archive---------4-----------------------#2019-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8c7abf9745fcc2fd3f74c83c9558bbe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h0Xwr2Rq9hSBryk1.png"/></div></div></figure><h1 id="52aa" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="5dba" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">扩展运算符<code class="fe lx ly lz ma b">…</code>、<strong class="lb iu">、</strong>最早是在ES6中引入的。它很快成为最受欢迎的功能之一。以至于尽管它只在数组上工作，有人提议将其功能扩展到对象。这个特性最终在ES9中引入。</p><p id="75de" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">本教程分为两个部分，旨在向您展示为什么应该使用spread运算符，它是如何工作的，并从最基本到最高级深入探究它的用法。</p><p id="155f" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如果你还没有阅读本教程的第一部分，我鼓励你这样做！</p><p id="d332" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">以下是本教程内容的摘要:</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3a3f" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">第一部分</h1><ol class=""><li id="5ea1" class="mt mu it lb b lc ld lg lh lk mv lo mw ls mx lw my mz na nb bi translated">为什么应该使用扩展运算符。</li><li id="89cd" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">克隆数组/对象。</li><li id="a502" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">将类似数组的结构转换为数组。</li><li id="f0b9" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">作为参数的扩展运算符。</li><li id="492f" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">将元素添加到数组/对象。</li><li id="71d3" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">合并数组/对象。</li></ol></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="38f4" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">第二部分</h1><ol class=""><li id="d985" class="mt mu it lb b lc ld lg lh lk mv lo mw ls mx lw my mz na nb bi translated">析构嵌套元素。</li><li id="2d1f" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">添加条件属性。</li><li id="375d" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">短路。</li><li id="4591" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">其余参数<code class="fe lx ly lz ma b">…</code>。</li><li id="4a73" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">默认析构值。</li><li id="820d" class="mt mu it lb b lc nc lg nd lk ne lo nf ls ng lw my mz na nb bi translated">默认属性。</li></ol></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3a4b" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">克隆包含嵌套元素的数组/对象</h1><p id="3a0c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本文的第一部分中，我们学习了引用数据类型、意外变量突变，以及如何通过使用spread操作符不可变地克隆数组/对象<em class="nh">来解决这个问题。</em></p><p id="ddeb" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">然而，当涉及嵌套引用数据类型时，这种方法有一个小问题。扩展运算符仅执行<em class="nh">浅层克隆。</em></p><p id="a0cb" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">这是什么意思？例如，如果我们试图克隆一个包含数组的对象，克隆对象内部的数组将包含一个对存储原始数组的内存地址的引用…</p><p id="fa17" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">这意味着，虽然我们的对象是不可变的，但其中的<em class="nh">数组不是。</em>这里有一个例子来说明这一点:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">嵌套对象变异</p></figure><p id="24c0" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如你所见，我们的<code class="fe lx ly lz ma b">squirtleClone</code>已经被永久克隆了。当我们将原<code class="fe lx ly lz ma b">pokemon</code> <em class="nh"> </em>对象的<code class="fe lx ly lz ma b">name</code>属性更改为<code class="fe lx ly lz ma b">Charmander</code>时，我们的<code class="fe lx ly lz ma b">squirtleClone</code>不受影响，它的<code class="fe lx ly lz ma b">name</code> <em class="nh"> </em>属性<em class="nh">没有发生突变</em>。</p><p id="eb36" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">然而，当我们给原来的<code class="fe lx ly lz ma b">pokemon</code>对象的<code class="fe lx ly lz ma b">abilities</code>属性添加一个新的能力时……我们的<code class="fe lx ly lz ma b">squirtleClone</code>的能力会受到这个变化的影响。因为<code class="fe lx ly lz ma b">abilities</code>属性是一个引用数据类型，所以它不会被永久克隆。欢迎来到JavaScript的现实世界。</p><p id="0ce1" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">解决此问题的方法之一是使用spread运算符克隆嵌套属性，如下例所示:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">使用扩展运算符克隆嵌套对象特性</p></figure><p id="aa43" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">很明显，这不是解决我们问题的理想方法。我们需要对每个引用类型属性使用spread操作符，这就是为什么这种方法只对小对象有效。</p><p id="1f97" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">那么，最优解是什么呢？深度克隆<em class="nh">。</em></p><p id="d441" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">由于关于深度克隆有很多要说的，所以我不会讲太多细节。我只想说，深度克隆的正确方法要么是使用外部库(例如，<a class="ae mg" href="https://lodash.com" rel="noopener ugc nofollow" target="_blank"> Lodash </a>)，要么是自己编写一个函数来完成它。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="3da8" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">添加条件属性</h1><p id="fdb7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有时候，我们需要给一个对象添加属性，但是我们不知道这些属性是否存在。这没什么大问题，我们总是可以用一个<code class="fe lx ly lz ma b">if</code>语句来检查该属性是否存在:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="325a" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">然而，有一种更简单的方法可以达到同样的结果，那就是使用带有<code class="fe lx ly lz ma b">&amp;&amp;</code>操作符的短路条件。<strong class="lb iu"> </strong>简要说明:</p><h2 id="ab5d" class="ns kc it bd kd nt nu dn kh nv nw dp kl lk nx ny kp lo nz oa kt ls ob oc kx od bi translated">短路</h2><p id="cdb1" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">当我们用<code class="fe lx ly lz ma b">&amp;&amp;</code>对一个表达式求值时，如果第一个操作数是<code class="fe lx ly lz ma b">false</code>，JavaScript就会短路，忽略第二个操作数。</p><p id="3558" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">让我们来看看下面的代码:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">用&amp;&amp;运算符短路</p></figure><p id="deb6" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如果<code class="fe lx ly lz ma b">starterPokemon.length &gt; 0</code>为假(数组为空)，语句就会短路，我们的<code class="fe lx ly lz ma b">choosePokemon</code>函数永远不会执行。这就是为什么前面的代码等同于使用传统的if语句。</p><p id="2d6d" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">回到我们最初的问题，我们可以利用逻辑操作符<code class="fe lx ly lz ma b">AND</code>向对象添加条件属性。方法如下:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">使用扩展运算符有条件地添加属性</p></figure><p id="8bb7" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">这是怎么回事？请允许我解释。</p><p id="4390" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">我们已经知道，通过使用<code class="fe lx ly lz ma b">&amp;&amp;</code>操作符，只有当第一个操作数为真时，语句的第二部分才会被执行。</p><p id="4828" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">因此，只有<code class="fe lx ly lz ma b">abilities</code> <em class="nh"> </em>变量为真(如果变量存在)，才会执行语句的后半部分。这后半部分是做什么的？</p><p id="02dd" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">它创建一个包含<code class="fe lx ly lz ma b">abilities</code>变量的对象，然后用spread操作符对其进行析构，放在语句的前面，这样就把已经存在的<code class="fe lx ly lz ma b">abilities</code> <em class="nh"> </em>变量不变地添加到我们的<code class="fe lx ly lz ma b">fullPokemon</code>对象中。</p><p id="a149" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在我们介绍最终的高级扩展用途——为对象添加默认属性之前，我们必须先深入了解两个新概念:默认析构值和<code class="fe lx ly lz ma b">rest</code>参数。</p><p id="54d3" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">一旦我们熟悉了这些技术，我们就能够将它们结合起来为对象添加默认属性。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="d281" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">默认析构值</h1><p id="78bb" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如果我们试图析构一个不存在的数组元素或对象属性，我们会得到一个未定义的变量。如何才能避免未定义的值？通过使用<em class="nh">默认值</em>。这是如何工作的？</p><p id="1a20" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在实际的析构语句中，我们可以给析构的变量赋予默认值。这里有一个例子:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">分配默认值</p></figure><p id="ec58" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如您所见，通过在析构语句中向<code class="fe lx ly lz ma b">type</code> <em class="nh"> </em>变量添加默认值<code class="fe lx ly lz ma b">Water</code>，我们避免了在<code class="fe lx ly lz ma b">pokemon</code>对象没有<code class="fe lx ly lz ma b">type</code>属性的情况下出现未定义的变量。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="55fe" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">Rest参数(…)</h1><p id="230e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">你可能会惊讶地听到，传播运营商是<em class="nh">超载</em>。这意味着它有不止一个功能。它的第二个功能是充当rest参数。</p><blockquote class="oe of og"><p id="f11e" class="kz la nh lb b lc mb le lf lg mc li lj oh md lm ln oi me lq lr oj mf lu lv lw im bi translated">函数的最后一个参数可以以<code class="fe lx ly lz ma b"><em class="it">...</em></code>为前缀，这将导致所有剩余的(用户提供的)参数被放置在一个“标准”javascript数组中。只有最后一个参数可以是rest参数。— <strong class="lb iu"> </strong> <a class="ae mg" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> MDN文档</strong> </a></p></blockquote><p id="fd99" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">简单地说，rest操作符获取所有剩余的元素<em class="nh"> ( </em>这就是它被命名为rest的原因，因为在<em class="nh"/><em class="nh"/>中剩余的元素)并将它们放入一个数组中。这里有一个例子:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">Rest参数示例</p></figure><p id="a427" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如你所见，我们可以向<code class="fe lx ly lz ma b">printPokemon</code>函数传递任意多的能力。我们在类型参数(其余的参数)之后引入的每一个值都将被收集到一个数组中，然后我们用<code class="fe lx ly lz ma b">join</code>函数将它转换成一个字符串，并打印出来。</p><blockquote class="oe of og"><p id="466d" class="kz la nh lb b lc mb le lf lg mc li lj oh md lm ln oi me lq lr oj mf lu lv lw im bi translated"><strong class="lb iu"> <em class="it">注意</em> </strong> <em class="it">:记住其余参数必须是</em> <strong class="lb iu"> <em class="it">最后一个参数</em> </strong> <em class="it">，否则会出错。</em></p></blockquote><p id="da73" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在析构的时候也可以使用rest参数，这是我们感兴趣的部分。它允许我们获得一个对象的剩余属性，并存储它们。</p><p id="6ff4" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">下面是一个在析构赋值中使用的rest参数的例子:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">用rest参数进行析构</p></figure><p id="58b9" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如上所示，我们可以使用rest参数来析构<code class="fe lx ly lz ma b">pokemon</code>对象中剩余的属性。<strong class="lb iu"> </strong>和前面的例子一样，在<code class="fe lx ly lz ma b">id</code> <em class="nh"> </em>属性之后，我们的<code class="fe lx ly lz ma b">pokemon</code>对象可以有任意多的属性，它们都将被rest参数收集。</p><p id="fef1" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">现在我们知道了rest参数是如何工作的，以及如何在析构赋值中应用它，让我们回到处理默认属性。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="a896" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">添加默认属性</h1><p id="52d0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">有时，我们有大量相似但不完全相同的对象。它们中的一些缺乏其他物体所具有的特性。然而，我们需要所有的对象都有相同的属性。如何才能实现这一点？</p><p id="e79e" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">通过设置默认属性。这些是带有默认值的属性，如果我们的对象还没有这个属性的话，它们将被添加到我们的对象中。</p><p id="5b3c" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">通过将rest参数与默认值和spread操作符结合使用，我们可以向对象添加默认属性。这听起来可能有点令人生畏，但实际上很简单。这里有一个如何做到这一点的例子:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div><p class="no np gj gh gi nq nr bd b be z dk translated">添加默认属性</p></figure><p id="d91d" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">前面的代码片段是怎么回事？让我们来分解一下:</p><p id="c27b" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如你所见，当我们析构<code class="fe lx ly lz ma b">abilities</code> <em class="nh"> </em>属性时，我们添加了一个默认值<code class="fe lx ly lz ma b">[]</code>。正如我们已经知道的，只有当abilities变量不存在于<code class="fe lx ly lz ma b">pokemon</code>对象中时，默认值才会被赋给它。</p><p id="0485" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在同一行中，我们利用awesome rest参数将<code class="fe lx ly lz ma b">pokemon</code>对象的其余属性(名称和类型)收集到一个名为<code class="fe lx ly lz ma b">rest</code>的变量中。</p><p id="030a" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在第7行，我们将rest变量(如您所见，它是一个包含<code class="fe lx ly lz ma b">name</code>和<code class="fe lx ly lz ma b">type</code>属性的对象)扩展到一个对象文字中，以生成一个新的对象。</p><p id="3dad" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">我们还添加了<code class="fe lx ly lz ma b">abilities</code>变量，在本例中，它是一个空数组，因为这是我们在前一行中指定的默认值。</p><p id="3c27" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在我们最初的<code class="fe lx ly lz ma b">pokemon</code>对象已经有了一个<code class="fe lx ly lz ma b">abilities</code>属性的情况下，先前的代码不会修改它，它将保持它的初始值。</p><p id="6367" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">这就是我们如何给一个对象添加默认属性。让我们将前面的代码放入一个函数中，并将其应用于一个大型对象集合:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8ec0" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">正如你所看到的，数组中所有的<code class="fe lx ly lz ma b">pokemon</code>现在都有一个<code class="fe lx ly lz ma b">abilities</code>属性。</p><p id="dbdb" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在<code class="fe lx ly lz ma b">charmander</code>和<code class="fe lx ly lz ma b">bulbasur</code>的例子中，它们有一个空数组，因为这是我们指定的默认值。然而，<code class="fe lx ly lz ma b">squirtle</code>对象保持了它原来的能力数组。</p><p id="15c9" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">当然，还有其他方法可以给对象添加默认属性，主要是通过使用if语句。</p><p id="54b4" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">然而，我想展示一种有趣的新方法，通过使用默认值、rest参数和spread操作符的组合。然后，您可以选择最适合您的方法。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="d72c" class="kb kc it bd kd ke mo kg kh ki mp kk kl km mq ko kp kq mr ks kt ku ms kw kx ky bi translated">结论</h1><p id="bc93" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是<em class="nh">理解JavaScript Spread操作符—从初学者到专家</em> <strong class="lb iu"> <em class="nh"> </em> </strong>教程的第二部分，也是最后一部分。下面是第一部分的链接<a class="ae mg" href="https://medium.com/better-programming/understanding-the-javascript-spread-operator-from-beginner-to-expert-8f1c110c64db" rel="noopener">。</a></p><p id="2242" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在本教程的第二部分中，我们学习了spread运算符的一些更高级的用法，包括析构嵌套元素、添加条件属性和添加默认属性。</p><p id="88a4" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">我们还学习了三个有趣的JS概念:短路、默认析构值和rest参数。</p><p id="ba1a" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">我真诚地希望这篇文章对你有用，谢谢你的阅读。</p></div></div>    
</body>
</html>