<html>
<head>
<title>Automate All the Boring Kubernetes Operations With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python自动化所有枯燥的Kubernetes操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/automate-all-the-boring-kubernetes-operations-with-python-7a31bbf7a387?source=collection_archive---------0-----------------------#2022-05-18">https://betterprogramming.pub/automate-all-the-boring-kubernetes-operations-with-python-7a31bbf7a387?source=collection_archive---------0-----------------------#2022-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="33d4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Python的Kubernetes客户端库来自动化所有枯燥的Kubernetes任务和操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b56f1b6731c65ec255399901b578a8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBHRng-TPG9BTdb_xeSWLA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sharonmccutcheon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">莎伦·麦卡琴</a>在<a class="ae ky" href="http://localhost:3000/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的背景照片</p></figure><p id="dee0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes在最近几年成为了事实上的标准，我们中的许多人——包括DevOps工程师和开发人员——每天都在使用它。然而，我们执行的许多任务都是相同的、乏味的，并且易于自动化。</p><p id="0dbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，用一堆<code class="fe lv lw lx ly b">kubectl</code>命令快速编写一个shell脚本是足够简单的，但是对于更复杂的自动化任务，bash还不够好，您需要适当语言的能力，比如Python。</p><p id="c41e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在本文中，我们将探讨如何利用Kubernetes Python客户端库来自动化您可能正在处理的任何烦人的Kubernetes任务！</p><h1 id="c093" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">操场</h1><p id="8f57" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在我们开始使用Kubernetes客户端之前，我们首先需要创建一个游乐场集群，在那里我们可以安全地进行测试。我们将使用KinD(Docker中的Kubernetes)，你可以从<a class="ae ky" href="https://kind.sigs.k8s.io/#installation-and-usage" rel="noopener ugc nofollow" target="_blank">这里</a>安装。</p><p id="3095" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用以下集群配置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f6e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要根据上述配置创建集群，您可以运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="30a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着集群的启动和运行，我们还需要安装客户端库(可选地，在虚拟环境中):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="3e80" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">证明</h1><p id="abe1" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">要在我们的Kubernetes集群中执行任何操作，我们首先需要进行身份验证。</p><p id="6478" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用长期令牌，这样我们就不需要重复进行身份验证。可以通过创建一个<code class="fe lv lw lx ly b">ServiceAccount</code>来创建长期令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用服务帐户还有一个好处，那就是它不依赖于任何一个人，这对于自动化来说总是更可取的。</p><p id="615f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，可以在请求中使用上面输出中的令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在通过了身份验证，但没有权限做任何事情。因此，接下来，我们需要创建一个<code class="fe lv lw lx ly b">Role</code>，并将其绑定到<code class="fe lv lw lx ly b">ServiceAccount </code>，这样我们就可以对资源执行操作。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ccd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面给出了我们的服务帐户在pods上执行任何操作的权限，仅限于<code class="fe lv lw lx ly b">default</code>名称空间。</p><p id="f372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该始终保持您的角色非常狭窄和具体，但实际上，应用集群范围的管理员角色是有意义的，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="33c1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">原始请求</h1><p id="f7df" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">为了更好地理解什么是<code class="fe lv lw lx ly b">kubectl</code>以及客户端在幕后做什么，我们将从使用<code class="fe lv lw lx ly b">curl</code>的原始HTTP请求开始。</p><p id="f965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">找出幕后请求的最简单方法是用<code class="fe lv lw lx ly b">-v 10</code>运行所需的<code class="fe lv lw lx ly b">kubectl</code>命令。这将输出完整的<code class="fe lv lw lx ly b">curl</code>命令，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8e11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">loglevel 10</code>的输出会非常冗长，但是在那里的某个地方，您会发现上面的<code class="fe lv lw lx ly b">curl</code>命令。</p><p id="d398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用您的长期令牌在上面的<code class="fe lv lw lx ly b">curl</code>命令中添加一个<code class="fe lv lw lx ly b">Bearer</code>令牌头，您应该能够执行与<code class="fe lv lw lx ly b">kubectl</code>相同的操作，例如:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8a96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要一个请求体，就要查找请求中需要包含哪些字段。例如，当创建一个Pod时，我们可以使用这里描述的API<a class="ae ky" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#create-pod-v1-core" rel="noopener ugc nofollow" target="_blank"/>。当我们这样做时，我们得到以下请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="32a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于对象属性，请参考<a class="ae ky" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23" rel="noopener ugc nofollow" target="_blank"> Kubernetes API参考</a>。此外，您还可以使用以下命令查看OpenAPI定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9d95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接使用REST API与Kubernetes交互可能有点笨拙，但在某些情况下使用它可能是有意义的。一些情况包括当您使用Kubernetes的不同发行版时，与没有等效的<code class="fe lv lw lx ly b">kubectl</code>命令的API进行交互——例如open shift——这暴露了<code class="fe lv lw lx ly b">kubectl</code>或客户端SDK没有覆盖的额外API。</p><h1 id="67b5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Python客户端</h1><p id="ae05" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在转到Python客户机本身。我们需要经历与<code class="fe lv lw lx ly b">kubectl</code>或<code class="fe lv lw lx ly b">curl</code>相同的步骤。第一步是身份验证，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="094e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们定义一个配置对象，它告诉客户端我们将使用<code class="fe lv lw lx ly b">Bearer </code>令牌进行身份验证。考虑到我们的同类集群不使用SSL，我们在真实集群中禁用它。然而，你不应该这样做。</p><p id="a483" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了测试配置，我们使用API客户端的<code class="fe lv lw lx ly b">list_namespaced_pod</code>方法获取<code class="fe lv lw lx ly b">default</code>名称空间中的所有pod，然后打印出它们的<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">namespace </code>和<code class="fe lv lw lx ly b">IP</code>。</p><p id="2398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于一个更现实的任务，让我们创建一个下面的<code class="fe lv lw lx ly b">Deployment</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了创建<code class="fe lv lw lx ly b">Deployment</code>，我们还等待它的pod变得可用。我们通过查询<code class="fe lv lw lx ly b">Deployment </code>状态并检查大量可用副本来做到这一点。</p><p id="ae79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，注意函数名中的模式，比如<code class="fe lv lw lx ly b">create_namespaced_deployment</code>。为了让它更明显，让我们再看几个例子:</p><ul class=""><li id="9a80" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated"><code class="fe lv lw lx ly b">replace_namespaced_cron_job</code></li><li id="9391" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe lv lw lx ly b">patch_namespaced_stateful_set</code></li><li id="4419" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe lv lw lx ly b">list_namespaced_horizontal_pod_autoscaler</code></li><li id="03a9" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe lv lw lx ly b">read_namespaced_daemon_set</code></li><li id="b4c0" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated"><code class="fe lv lw lx ly b">read_custom_resource_definition</code></li></ul><p id="c44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都是全局资源的格式<code class="fe lv lw lx ly b">operation_namespaced_resource</code>或者仅仅是<code class="fe lv lw lx ly b">operation_resource</code>。对于对资源状态执行操作的方法，如<code class="fe lv lw lx ly b">read_namespaced_deployment_status</code>或对资源规模执行操作的方法，如<code class="fe lv lw lx ly b">patch_namespaced_stateful_set_scale</code>，它们可以附加<code class="fe lv lw lx ly b">_status</code>或<code class="fe lv lw lx ly b">_scale</code>后缀。</p><p id="616c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个需要强调的是，在上面的例子中，我们使用<code class="fe lv lw lx ly b">client.AppsV1Api</code>来执行动作，这允许我们使用属于<code class="fe lv lw lx ly b">apiVersion: apps/v1</code>的所有资源。如果我们想使用CronJob，我们会选择<code class="fe lv lw lx ly b">BatchV1Api</code>(在YAML格式中是<code class="fe lv lw lx ly b">apiVersion: batch/v1</code>)，或者对于PVC，我们会因为<code class="fe lv lw lx ly b">apiVersion: v1</code>而选择<code class="fe lv lw lx ly b">CoreV1Api</code>。你知道要点了。</p><p id="4570" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以想象，有很多功能可供选择。幸运的是，所有这些都列在<a class="ae ky" href="https://github.com/kubernetes-client/python/blob/master/kubernetes/README.md" rel="noopener ugc nofollow" target="_blank">文档</a>中，你可以点击其中任何一个来获得它的用法示例。</p><p id="a6f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了基本的CRUD操作，还可以持续观察对象的变化。显而易见的选择是观看<code class="fe lv lw lx ly b">Events</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们选择在<code class="fe lv lw lx ly b">default</code>名称空间中观察事件。我们取前10个事件，然后关闭流。如果我们想持续监控资源，我们只需移除<code class="fe lv lw lx ly b">timeout_seconds</code>和<code class="fe lv lw lx ly b">w.stop()</code>调用。</p><p id="4bd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个例子中，您看到我们使用普通Python <code class="fe lv lw lx ly b">dict</code>来定义部署对象，并将其传递给客户端。或者，我们可以通过使用由库提供的API模型(类)来使用更面向对象的风格，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5f50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试图找出你应该为每个论点使用哪个模型是一场失败的战斗，而且很艰难。当创建如上所示的资源时，您应该总是使用模型的<a class="ae ky" href="https://github.com/kubernetes-client/python/blob/master/kubernetes/README.md#documentation-for-models" rel="noopener ugc nofollow" target="_blank">文档，并在创建单个子对象时遍历链接，以确定每个字段中需要什么值/类型。</a></p><h1 id="0a10" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">方便的例子</h1><p id="3471" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">现在，您应该对客户端的工作原理有了基本的了解，所以让我们来看看一些方便的例子和片段，它们可能会帮助您自动化日常的Kubernetes操作。</p><p id="6bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想要执行的一个非常常见的事情是<code class="fe lv lw lx ly b">Deployment </code>展示——通常用<code class="fe lv lw lx ly b">kubectl rollout restart</code>来完成。然而，没有API可以做到这一点。<a class="ae ky" href="https://github.com/kubernetes/kubectl/blob/release-1.23/pkg/polymorphichelpers/objectrestarter.go#L32" rel="noopener ugc nofollow" target="_blank">方式</a><code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/kubernetes/kubectl/blob/release-1.23/pkg/polymorphichelpers/objectrestarter.go#L32" rel="noopener ugc nofollow" target="_blank">kubectl</a></code><a class="ae ky" href="https://github.com/kubernetes/kubectl/blob/release-1.23/pkg/polymorphichelpers/objectrestarter.go#L32" rel="noopener ugc nofollow" target="_blank"/>是通过更新部署标注。更具体地说，将<code class="fe lv lw lx ly b">kubectl.kubernetes.io/restartedAt</code>设置为当前时间。这是因为对Pod规格的任何更改都会导致重启。</p><p id="be03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要使用Python客户端执行重启，我们需要执行以下操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个常见的操作是缩放一个<code class="fe lv lw lx ly b">Deployment</code>。幸运的是，这个有一个我们可以使用的API函数，您可以在下面看到:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="be2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于故障排除的目的，通常有必要将<code class="fe lv lw lx ly b">exec</code>放入一个Pod中，环顾四周，并可能抓取<code class="fe lv lw lx ly b">environment </code>变量来验证正确的配置。下面是代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="0b9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要，上面的代码片段还允许您运行整个shell脚本。</p><p id="c7a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，假设您想要将<code class="fe lv lw lx ly b">Taint</code>应用到一个有问题的节点上。我们可以专注于面向集群管理的任务。由于没有针对节点污染的直接API，我们可以找到一种方法。下面是帮助我们的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="ae5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能还希望监控集群资源利用率，以自动进行集群扩展。通常，您会使用<code class="fe lv lw lx ly b">kubectl top</code>来交互地获取信息，但是使用客户端库，您可以做以下事情:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子假设您已经在集群中安装了<code class="fe lv lw lx ly b">metrics-server</code>。你可以运行<code class="fe lv lw lx ly b">kubectl top</code>来验证这一点。如果您使用KinD，请使用代码片段中的注释来安装它。</p><p id="0abd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后但同样重要的是，如果您有一堆YAML或JSON文件想要用来部署或修改集群中的对象，或者想要导出和备份您用客户端创建的内容，有一种简单的方法。下面是如何将YAML/JSON文件转换成Kubernetes对象，然后再转换回文件的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="040e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将现有对象转换成Python字典(JSON)的第一种方法是使用<code class="fe lv lw lx ly b">sanitize_for_serialization</code>，它产生包含所有生成/默认字段的原始输出。更好的选择是使用<code class="fe lv lw lx ly b">kopf</code>库的实用方法，这将删除所有不必要的字段。从这里开始，将字典转换成合适的YAML或JSON文件就足够简单了。</p><p id="03ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想逆转这个过程——从字典到客户机对象模型——我们可以使用API客户机的<code class="fe lv lw lx ly b">deserialize</code>方法。然而，这个方法期望它的参数有一个<code class="fe lv lw lx ly b">data</code>属性，所以我们传递给它一个具有这样一个属性的容器类实例。</p><p id="61de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您已经有了想要在Python客户端使用的YAML文件，您可以使用实用函数<code class="fe lv lw lx ly b">kubernetes.utils.create_from_yaml</code>。</p><p id="7286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得所有库特性的完整概述，我建议您查看一下资源库中的<a class="ae ky" href="https://github.com/kubernetes-client/python/tree/master/examples" rel="noopener ugc nofollow" target="_blank">示例目录</a>。</p><p id="da34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也鼓励你浏览一下库存储库中的问题，因为它有很多很好的客户端使用的例子，比如<a class="ae ky" href="https://github.com/kubernetes-client/python/issues/803" rel="noopener ugc nofollow" target="_blank">并行处理事件</a>或者<a class="ae ky" href="https://github.com/kubernetes-client/python/issues/1387" rel="noopener ugc nofollow" target="_blank">查看配置图更新</a>。</p><h1 id="93f7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="7b78" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">Python客户端库包含数百个函数，因此很难涵盖所有的小特性或用例。它们中的大多数遵循一个共同的模式，这应该使库的使用在几分钟后变得相当自然。</p><p id="a55c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果除了上面展示和引用的例子之外，您还想寻找更多的例子，我建议您探索使用Python Kubernetes客户端的其他流行工具，比如用于创建Kubernetes操作符的库。我还发现查看库本身的测试非常有用，因为它展示了它的预期用途。这里有一个优秀的<a class="ae ky" href="https://github.com/kubernetes-client/python/blob/master/kubernetes/e2e_test/test_client.py" rel="noopener ugc nofollow" target="_blank">客户端测试套件</a>要学习。</p><h1 id="009d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">你可能也喜欢</h1><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/building-github-apps-with-golang-43b27f3e9621"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">用Golang构建GitHub应用</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">在几分钟内启动并运行您的第一个GitHub应用程序，并使用它来自动化您在GitHub上做的所有事情</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">better编程. pub</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od ks np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://towardsdatascience.com/keeping-kubernetes-clusters-clean-and-tidy-fad52a37f910" rel="noopener follow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd iu gy z fp nu fr fs nv fu fw is bi translated">保持Kubernetes集群干净整洁</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">清除所有未使用的资源，这些资源会使您的Kubernetes集群变得杂乱并浪费其计算资源</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">towardsdatascience.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od ks np"/></div></div></a></div><pre class="kj kk kl km gt of ly og oh aw oi bi"><span id="4c54" class="oj ma it ly b gy ok ol l om on"><strong class="ly iu">Want to Connect?</strong></span><span id="2777" class="oj ma it ly b gy oo ol l om on">This article was originally posted at <a class="ae ky" href="https://martinheinz.dev/blog/73?utm_source=medium&amp;utm_medium=referral&amp;utm_campaign=blog_post_73" rel="noopener ugc nofollow" target="_blank">martinheinz.dev</a></span></pre></div></div>    
</body>
</html>