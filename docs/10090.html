<html>
<head>
<title>Writing High Order Functions for General Process Like a Senior JavaScript Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像高级JavaScript开发人员一样为通用流程编写高阶函数</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-high-order-functions-for-general-process-like-a-senior-javascript-developer-4d025baa3dc6?source=collection_archive---------0-----------------------#2021-11-26">https://betterprogramming.pub/writing-high-order-functions-for-general-process-like-a-senior-javascript-developer-4d025baa3dc6?source=collection_archive---------0-----------------------#2021-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">函数式编程的力量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7edae87d9003a70e438cfdd450f52160.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6dDmNuo-faRhfGd9nbwBOA.png"/></div></div></figure><p id="57ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们知道函数是解题的基本单位。但是在现实世界中，一些原始函数并不能完全解决一个问题。这时，我们需要扩展我们现有的代码。</p><p id="3a49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有些编码者可能会直接改变原来的功能，以达到存档的目的。嗯，这是初级开发人员的常用方法，也是一种直观的方法。</p><p id="67d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在很多情况下，这不是最好的解决方案，并且有一些缺点。在接下来的部分中，我将为您介绍一些带有示例的通用解决方案。</p><p id="2a5c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，我们走吧。</p><h1 id="1210" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">1.仅执行一次</h1><p id="903d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">很多时候，我们想要一个只执行一次的函数。</p><p id="07b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">比如我们开发网页的时候，总会有一些提交表单的按钮。当用户点击按钮时，它的<code class="fe mn mo mp mq b">onclick</code>事件将被触发。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1803" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mt">为了简化演示问题，该示例只记录一条消息，而不是向服务器发送数据。</em></p><p id="cdc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这里有一个问题:由于网络延迟，我们不能立即显示用户的结果。然后，用户可以继续点击按钮并多次向服务器提交表单。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/a79700c26dae7ceb38a76acb67785d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vB9jtDvecRK1Jr1O_Z6r1Q.gif"/></div></div></figure><p id="5fed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们需要一个解决问题的方法。你的解决方案是什么？</p><p id="bf57" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种常见的解决方案是在用户第一次单击按钮后禁用它。</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="70be" class="mz lr it mq b gy na nb l nc nd">document.getElementById('submit').onclick = function()<br/>  document.getElementById('submit').disabled = true<br/>  console.log("sending data to the server")<br/>}</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/329e8deb4e24f523cfd1700e3238a758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*05yQDxm39Enjt1_mxZJokg.gif"/></div></div></figure><p id="d005" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，这个解决方案没有问题。</p><p id="fae3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们还有一个不同的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="76e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个解决方案中，我们使用一个标志来记录这个函数以前是否被执行过。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/6c234fdbd01b48a2d79f5177530e4601.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*51dtGJMMtflsLSLTnDQxig.gif"/></div></div></figure><p id="0e07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们用图表来表示程序，它可能是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/375fcb1dddb8ae4523ee5ba011be9fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijfvj3Uxh2v5mIuLM1_kYQ.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="1578" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，我们能得到所有这类问题的一般解吗？</p><p id="c833" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们继续一个类似的例子。很多时候，在我们的程序中有一个init函数。</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="e354" class="mz lr it mq b gy na nb l nc nd">let init = function(){<br/>  console.log('init the enviorment')<br/>}</span></pre><p id="fedf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用该功能来设置变量、读取配置等。而且这个功能应该只执行<strong class="kw iu">一次</strong>。为了确保它只执行一次并避免意外，我们可以对函数做一些修改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8be6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的，init函数只会初始化环境一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/83c9885d8bebb562b0997facdb548e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhmGvfjt7ZqdWDRatMl7mw.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">只记录一次消息</p></figure><p id="da58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们也可以把程序绘制成图表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/5d2d3cc65bf29810e4cef6b9040abdcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfSo4OzTFXnzxDIc45vyrw.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="cd1a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你发现表单提交和初始化函数有一些共同之处吗？是的，他们的程序非常相似！</p><p id="a9b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们进行高级抽象，过程应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/b3df9f94fc28d17acd5cf106ba7196af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wz8_k3T3DkKhTwlmbgR-gw.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="6e97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果该函数以前被调用过，则是一个通用的过程。我们可以写一个高阶函数来封闭这个过程。</p><p id="308e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe mn mo mp mq b">once</code>函数的一个实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9907" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，有了<code class="fe mn mo mp mq b">once</code>函数，我们可以很容易地将执行一次函数的目的存档。</p><p id="2be3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提交一次:</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="493a" class="mz lr it mq b gy na nb l nc nd">document.getElementById('submit').onclick = once(function()</span><span id="4e8b" class="mz lr it mq b gy nk nb l nc nd">  console.log("sending data to the server")</span><span id="c22c" class="mz lr it mq b gy nk nb l nc nd">})</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/5099c3cb71e66e354d1e8bdf04c7edab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r9TbJuZdMPlMgQaL3P1rpQ.gif"/></div></div></figure><p id="da6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">初始化一次:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/aafff1ac0d626733d9ee3b6801734222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-h58ZnN6nkQcfr8Ml_K-Q.png"/></div></div></figure><p id="c1a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好，我们用once函数来解决我们的需求。</p><p id="787d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe mn mo mp mq b">once</code>功能的核心思想是什么？</p><p id="62b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我在标题中提到的:我们将一般过程抽象为高阶函数。程序性的——只执行一次功能——是一个通用的过程。它会被多次使用。如果我们不进行抽象，我们就必须为相同的逻辑在不同的函数中重复编写代码。</p><p id="6a15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们使用<code class="fe mn mo mp mq b">once</code>功能，有很多好处:</p><ul class=""><li id="8d27" class="nn no it kw b kx ky la lb ld np lh nq ll nr lp ns nt nu nv bi translated">我们不需要改变原来的功能。</li><li id="51b3" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">保持业务逻辑和执行逻辑的分离，这样代码会更容易维护。</li><li id="8844" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated"><code class="fe mn mo mp mq b">once</code>函数是可重用的函数。</li></ul><h1 id="3538" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">2.缓存结果</h1><p id="429c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们再来看另一个例子。如果有这样的功能:</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="28f4" class="mz lr it mq b gy na nb l nc nd">function compute(str) {    <br/>    // Suppose the calculation in the funtion is very time consuming        <br/>    console.log('2000ms have passed')<br/>    return str.toUpperCase()<br/>}</span></pre><p id="78c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mt">(其实这个案例是我从Vue源码中了解到的。)</em></p><p id="dd3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们想要缓存函数操作的结果。以后调用时，如果参数相同，就不再执行该函数，而是直接返回缓存中的结果。我们能做什么？</p><p id="45e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个建议:<strong class="kw iu">当你需要增强一个函数的时候，不要试图直接修改，考虑先写一个通用的高阶函数来包装它。</strong></p><p id="ee28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">缓存函数结果的一般流程是什么？下面是一个流程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/37d46eb8d41dde6687f3e31bd6ea35cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*48OObvTTWJjo5qEq6zFxhw.png"/></div></div></figure><p id="faee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是缓存结果的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fc24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以使用这个缓存函数来增强<code class="fe mn mo mp mq b">cumpute</code>函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/e9f512c67fcc6251ba547f932530fa39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Yi806VQHxoCqojWNGjsyA.png"/></div></div></figure><p id="5389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们做这个抽象并不是为了炫耀技巧，事实上这样的缓存功能有着广泛的用途。</p><p id="6227" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们知道，有一个著名的数列叫做斐波那契数列。</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="ff87" class="mz lr it mq b gy na nb l nc nd">1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...</span></pre><p id="c643" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">快速浏览后，您可以很容易地注意到序列的模式是每个值都是<strong class="kw iu"> 2个先前值</strong>的总和，这意味着对于N=5 → 2+3或在数学中:</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="be63" class="mz lr it mq b gy na nb l nc nd">F(n) = F(n-1) + F(n-2)</span></pre><p id="4e67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们想写一个函数:</p><blockquote class="od"><p id="e2dc" class="oe of it bd og oh oi oj ok ol om lp dk translated">给定一个数字<em class="on"> N </em>返回斐波那契数列的索引值。</p></blockquote><p id="64bb" class="pw-post-body-paragraph ku kv it kw b kx oo ju kz la op jx lc ld oq lf lg lh or lj lk ll os ln lo lp im bi translated">如何编写函数呢？</p><p id="155e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最简单的解决方案是递归解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2424" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是这种实现是耗时的。如果num大于35，您将需要等待一段时间才能得到结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/5725926dbe824e5f5fc5f5f69e394096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6jnPDiD8YqBVk2yaK9bCIw.gif"/></div></div></figure><p id="e133" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是如果我们使用缓存函数来重构实现，我们将得到一个高性能的函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/c0af1e1848447041256664c5eb0a4000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Hk205CU8KplXQtjd1S6QOw.gif"/></div></div></figure><h1 id="d68d" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">3.函数拦截器</h1><p id="f45c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">我们继续。</p><p id="8cda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设你是一个库的维护者，你准备在未来弃用一个叫做<code class="fe mn mo mp mq b">request</code>的老API。</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="a5d6" class="mz lr it mq b gy na nb l nc nd">function request(){<br/>  console.log('request to server')<br/>}</span></pre><p id="7b84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在当前版本中，您希望通过记录消息来警告用户API将被否决。</p><p id="06e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那你会怎么做？</p><p id="8c14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最糟糕的方法是在函数中添加一个<code class="fe mn mo mp mq b">console.warn</code>语句:</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="c2d3" class="mz lr it mq b gy na nb l nc nd">function request(){</span><span id="b912" class="mz lr it mq b gy nk nb l nc nd">  console.warn(`The request will be deprecated in the future`)</span><span id="53f1" class="mz lr it mq b gy nk nb l nc nd">  console.log('request to server')</span><span id="faae" class="mz lr it mq b gy nk nb l nc nd">}</span></pre><p id="ac28" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么这是最糟糕的解决方案？</p><p id="ef88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你必须找到所有被否决的API并修改它们。这是一个非常繁琐的过程，而且非常容易出错。<strong class="kw iu">如无必要，请勿更改现有功能。</strong></p><p id="4f88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们用图表来表示程序，那就是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/ac6f832bf4808ced36360dde83ce4f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J9NakhpUX8TBOn8a0XOffw.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="dc1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如我们在前两节中所做的那样，我们可以为该过程编写一个高阶函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="178d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以对我们的项目做一些更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b37f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果您的库的用户调用请求函数，他们将会收到一条消息。</p><p id="3105" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好，让我们继续一个类似的例子。</p><p id="3a34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有一个fetch函数向服务器发送请求。它将返回一个HTML文本或JSON格式的文本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c0ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在要做的是，如果发现响应结果是JSON格式的字符串，我们就把它转换成JSON对象。如果是其他格式的字符串，则不会被处理。我该怎么办？</p><p id="17aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">老规矩，先画个图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/e20e8892d6599d96006d513285923514.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5i_yFs2b_QnUzAy9Vxv-Mg.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="967b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">具体原理已经解释过很多次了，这里我直接给出一个高阶函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="43bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用法:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/b626815c086a14a6c9a67758607689d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mvDP9pDYtfwNwNbR6x4PQ.png"/></div></div></figure><p id="617c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这两个例子有点简单。但是附近有一个更重要的想法。</p><ul class=""><li id="49a8" class="nn no it kw b kx ky la lb ld np lh nq ll nr lp ns nt nu nv bi translated"><code class="fe mn mo mp mq b">derecate</code>函数的目的是在原始函数执行之前做一些事情。</li><li id="c98b" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated"><code class="fe mn mo mp mq b">toJSON</code>函数的目的是在原始函数执行后做一些事情。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/da2e9c320d6662e36ba39355b4def077.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9mPlLH1RhZNE7W7PlN6_g.png"/></div></div><p class="nf ng gj gh gi nh ni bd b be z dk translated">作者图片</p></figure><p id="283f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们能把这个过程抽象成一个新的高阶函数吗？</p><p id="32e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然可以。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d80b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你以前使用过Axios，一个著名的HTTP请求库，你会知道Axios有一个拦截器API供用户拦截请求和响应。</p><h1 id="5bf4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">4.一批</h1><p id="448d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">好，这是我们最后一个例子。</p><p id="2f18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个使输入加倍的函数。</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="b3b9" class="mz lr it mq b gy na nb l nc nd">function double(num){<br/>  return num * 2<br/>}</span></pre><p id="c464" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嗯，很简单的功能，只是为了演示。</p><p id="828c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们希望这个函数接受一个数组作为参数，那么将数组中所有元素的值加倍，然后返回一个新的数组。你是怎么写代码的？</p><p id="22a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以这样写:</p><pre class="kj kk kl km gt mv mq mw mx aw my bi"><span id="6132" class="mz lr it mq b gy na nb l nc nd">function double(nums){<br/>  return nums.map(num =&gt;  num * 2)<br/>}</span></pre><p id="2a7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确实可以这么写。</p><p id="98ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但遗憾的是，JavaScript没有函数重载，后一个函数会覆盖前一个。为了让我们的double函数同时处理两个参数类型，我们必须在函数体中做出判断:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="c207" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们想要的是为所有这些问题创建一个通用的解决方案:一个高阶函数，它可以标记一个函数来处理单个参数或类似数组的参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/d164c39af1416f231a47315f0e1e1d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4HrOFfeYS5_MRCpRY5yVNA.png"/></div></div></figure><p id="bee4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/0009038f84f0214c0b65e0692b42ec48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ttZP03Ib1BsPFhqJgo1-1w.png"/></div></div></figure><h1 id="5380" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">结论</h1><p id="c836" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">好了，例子够多了。无论一次、缓存、拦截还是批处理，都是对某个进程做一些抽象。</p><ul class=""><li id="293f" class="nn no it kw b kx ky la lb ld np lh nq ll nr lp ns nt nu nv bi translated">我们想要一个只执行一次的函数，所以我们抽象了<code class="fe mn mo mp mq b">once</code>。</li><li id="d927" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">我们需要一个函数来缓存相应参数的结果，所以我们抽象了<code class="fe mn mo mp mq b">cache</code>。</li><li id="d396" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">我们想要一个在执行前后都做一些事情的函数，所以我们抽象了<code class="fe mn mo mp mq b">intercept</code>。</li><li id="3774" class="nn no it kw b kx nw la nx ld ny lh nz ll oa lp ns nt nu nv bi translated">我们希望s函数通过它的params类型改变它的执行流，所以我们抽象了<code class="fe mn mo mp mq b">batch</code>。</li></ul><p id="57dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们都遵循一个共同的范式:即使用高阶函数来抽象任何一般过程。</p><h1 id="fc36" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">嵌套的</h1><p id="6a3c" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">嗯，最后我想说的是:如果有必要，我们可以嵌套这些高阶函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/9197a90afb0911a66b0f956dbcd5e1d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5ZyMTIzFOX0hlXqyA5WkQ.png"/></div></div></figure><p id="c3ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们不仅要缓存<code class="fe mn mo mp mq b">compute</code>函数的结果，还要在执行它之前记录它的参数，在执行它之后记录它的结果。然后，我们还想让它能够处理多个参数。我们可以这样写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8e5c5097ccbf803a16f40b89c5e8945f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R-wMBVNzGZigsdri19sZ0g.png"/></div></div></figure></div><div class="ab cl pa pb hx pc" role="separator"><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf pg"/><span class="pd bw bk pe pf"/></div><div class="im in io ip iq"><p id="f912" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。希望这篇文章对你有用。</p></div></div>    
</body>
</html>