<html>
<head>
<title>Algorithms: Find the First Duplicate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:找到第一个副本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/algorithms-find-the-first-duplicate-eb7ab30d7da8?source=collection_archive---------11-----------------------#2020-03-17">https://betterprogramming.pub/algorithms-find-the-first-duplicate-eb7ab30d7da8?source=collection_archive---------11-----------------------#2020-03-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b02" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Python列表中搜索第一个重复值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/33dd86379cf65f19a0276f6e3ebb9197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lTp5LRdOe2jOtpelzPPY2Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">钱德勒·希尔肯在<a class="ae ky" href="https://unsplash.com/s/photos/double?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="13c6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">挑战</h1><p id="058b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">编写一个函数来查找值列表中的第一个重复项。这些值可以是介于1和列表长度之间的整数。如果没有找到重复值，则返回-1。</p><p id="8a87" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">以下是一些有效和无效的示例列表，并附有解释。</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7bed" class="ne lh it na b gy nf ng l nh ni">[1,2,3] # valid, no duplicate<br/>[1,2,3,3,2,1] # valid, 3 is the first duplicate<br/>[0,1,2] # invalid, 0 is less than 1<br/>[1,2,4] # invalid, 4 is greater than the list's length</span></pre><p id="a6a7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看看第二个例子，它有一个重复的值。第一个重复值不是恰好有重复值的第一个值(即1)，而是与列表中的前一个值重复的第一个值(即3)。</p><p id="9346" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">既然我们理解了挑战，我鼓励你自己去尝试。</p><p id="21b5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您已经尝试过，或者您想跳过前面的步骤，那么让我们来看看解决方案吧！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="e79c" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">亚军</h1><p id="524f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">该算法利用了集合——一种只包含唯一值的可变数据类型。</p><p id="0031" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">解决方案的前提是遍历列表，向集合中添加新值。在添加每个值之前，我们检查当前值是否存在于集合中。如果它确实存在，那么它是第一个副本，将被返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="d05b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">关于上述解决方案的几点注意事项:</p><ul class=""><li id="0aac" class="nl nm it ma b mb mu me mv mh nn ml no mp np mt nq nr ns nt bi translated">空集不能用花括号定义。Python会将其解释为空字典。</li><li id="ef57" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">这个算法也适用于字符串和其他可迭代对象。</li><li id="f75e" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">虽然该解决方案的时间复杂度为<em class="nz"> O(n) </em>，这对于该挑战是线性的和最优的，但是该算法占用了额外的存储器来创建集合。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="4a62" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">最优解</h1><p id="6ba0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">挑战的最佳算法利用了列表中的值必须在1和列表长度之间的规定。这很重要，因为通过将列表中的任何值移位-1，我们可以保证移位后的值是有效的索引。</p><p id="7413" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">该算法的基础在于利用每个值作为列表中的索引，并标记值以表示它们已经被访问过。我们将把这个值转换成负值，这样就保留了它的原始值。</p><p id="c8ea" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们第一次遇到负值时，我们知道它以前被访问过，因此是我们的第一个副本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="9364" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">关于上述解决方案的几点注意事项:</p><ul class=""><li id="548f" class="nl nm it ma b mb mu me mv mh nn ml no mp np mt nq nr ns nt bi translated">我们将值移动-1，因为索引是从零开始的，等于列表长度的值会超出界限。</li><li id="c1f4" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">由于绝对值先前已被标记，因此将返回该值。</li><li id="f18b" class="nl nm it ma b mb nu me nv mh nw ml nx mp ny mt nq nr ns nt bi translated">这种解决方案具有相同的时间复杂度<em class="nz"> O(n)，</em>，但是不占用使用set会占用的额外空间。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="87c8" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="b5e7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我第一次尝试这个挑战时，我使用了一个<code class="fe oa ob oc na b">for</code>循环来跟踪当前值，一个嵌套的<code class="fe oa ob oc na b">for</code>循环来查找重复项，一个变量来跟踪重复项的最低索引。成功了吗？是的。它有效率吗？号码</p><p id="2e0c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">你过得怎么样？你最初的解决方案是什么？下面分享一下你的经历吧！</p><p id="2baa" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">特别感谢<a class="ae ky" href="https://www.youtube.com/watch?v=XSdr_O-XVRQ" rel="noopener ugc nofollow" target="_blank">尼克·怀特</a>对这个算法的解释！</p></div></div>    
</body>
</html>