<html>
<head>
<title>Save Up to 50% of Your Kubernetes Costs With Preemptible Instances</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用可抢占实例节省高达50%的Kubernetes成本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/save-up-to-50-of-your-kubernetes-costs-with-preemptible-instances-bdade99ccd39?source=collection_archive---------9-----------------------#2020-09-07">https://betterprogramming.pub/save-up-to-50-of-your-kubernetes-costs-with-preemptible-instances-bdade99ccd39?source=collection_archive---------9-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2b84" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Google Kubernetes引擎的可抢占实例上运行Kubernetes入口控制器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/930477eaeaf9fbd43bdea7ff61d5949b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7L94cD5_-g9DzmHBhfMaw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/s/photos/save?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@spanic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Damir spanick</a>拍摄的照片</p></figure><p id="35ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器已经走过了漫长的道路，Kubernetes不仅改变了技术领域，也改变了组织的思维方式。随着越来越多的公司转向云原生技术，对容器和Kubernetes的需求也在不断增加。</p><p id="ace8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes运行在服务器上，服务器可以是物理的，也可以是虚拟的。随着云在当前IT环境中占据重要地位，实施近乎无限的扩展和优化工作负载成本变得更加容易。</p><p id="73b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预先购买服务器、在机架中进行配置并手动维护的日子已经一去不复返了。借助云，您可以在几分钟内启动和关闭虚拟机，并且只需为您调配的基础架构付费。的确是一种强大的力量！</p><p id="670c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数云提供商，如AWS和GCP，以比按需实例低得多的价格提供现场或可抢占实例。唯一的条件是，他们可以随时终止实例来收回资源。在GCP，可抢占的实例在被供应24小时后被自动移除。</p><p id="8d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据谷歌的说法，可抢占实例可以减少你的<a class="ae ky" href="https://cloud.google.com/compute" rel="noopener ugc nofollow" target="_blank">计算引擎</a>高达80%的成本。</p><p id="8713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于云提供商和用户来说，这是一个双赢的局面。虽然云提供商通过在非高峰时段尽可能充分地利用闲置资源而受益，但用户也可以从它提供的低价中受益，并轻松运行无状态工作负载。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ef8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在哪里使用可抢占/点实例</h1><p id="6940" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可抢占的实例适合所有类型的工作负载吗？不要！它们的用例很少，但通常用于机器学习应用程序或运行无状态工作负载。</p><p id="03db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论何时设计在可抢占实例上运行的任何东西，都需要确保应用程序是容错的，并且可以从离开处理的同一点恢复。</p><p id="93fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可抢占的实例不适合有状态的应用程序，如数据库，其中数据持久性至关重要。但是，如果您需要运行负载平衡器、Hadoop集群或任何不受状态变化影响的应用程序，那么可抢占实例可能是一个不错的选择。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ade7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">GKE的可抢占实例</h1><p id="0c20" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Google Kubernetes引擎(GKE)是由Google Cloud提供的托管Kubernetes服务。这是可用的最健壮和功能最丰富的Kubernetes集群之一，它提供的功能之一是允许您提供可抢占的Kubernetes节点池。这意味着您也可以利用容器工作负载中的成本节约。</p><p id="4086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你运行的是不存储状态的微服务，那对你来说就是个金矿。如果架构得当，您可以通过在Kubernetes集群的独立节点池中组合按需和可抢占实例，并利用GKE提供的集群自动伸缩特性，来节省大量资金。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fe88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在GKE上运行负载平衡器</h1><p id="b479" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">负载平衡器是昂贵的资源，大多数组织倾向于使用入口控制器来管理Kubernetes集群中的流量。对于使用Istio等服务网格的组织，Istio入口控制器提供了类似的功能。</p><p id="7fb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些资源是无状态的，很适合在可抢占的工作节点上运行。这里我们将使用混合策略，允许工作负载分布在可抢占节点和普通节点之间。这是因为如果可抢占的节点被收回，我们希望确保客户不会注意到服务质量下降。</p><p id="50f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在GKE集群上安装NGINX入口控制器，并使用可抢占的节点来运行它们。所以让我们开始吧。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/df115330b6f51c1ddc0293e82887791c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*wKkgPzrhyBIfMzn1asCOXg.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ff88" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建集群</h1><p id="3804" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们首先创建一个GKE集群，在默认节点池中有两个工作节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="64b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们创建一个可抢占的节点池，并将其连接到群集。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，现在我们有一个Kubernetes集群，默认节点池上有两个常规工作节点，可抢占节点池上有两个可抢占工作节点。可抢占节点池启用了自动扩展，可以包含2到6个节点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fd3d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">将污点分配给可抢占节点</h1><p id="5830" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能已经注意到，我们还为可抢占节点池分配了一个污点，因为我们不希望所有工作负载都被调度到可抢占节点上。我们只想将入口控制器盒分配给可抢占的节点。其余的应该保留在标准节点上。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d5e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署入口控制器</h1><p id="df4c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要部署入口控制器，请下载NGINX入口控制器清单。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="b5df" class="nh md it nd b gy ni nj l nk nl">wget <a class="ae ky" href="https://raw.githubusercontent.com/bharatmicrosystems/nginx-lb/master/deploy.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/bharatmicrosystems/nginx-lb/master/deploy.yaml</a></span></pre><p id="4ab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对它进行了修改，增加了对可抢占节点池上的<code class="fe nm nn no nd b">NoSchedule</code>污点的容忍，以及在调度期间优先选择可抢占节点池的节点关联性。</p><p id="05de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不希望它优先选择可抢占的节点，而希望Kubernetes决定最佳节点，请从<code class="fe nm nn no nd b">deploy.yaml</code>文件中删除<code class="fe nm nn no nd b">nodeAffinity</code>部分。</p><h2 id="a062" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">默认</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="cdc8" class="nh md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">节点关联性</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d57c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用清单:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="981a" class="nh md it nd b gy ni nj l nk nl">kubectl apply -f deploy.yaml</span></pre><p id="4221" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署后，我们应该能够在<code class="fe nm nn no nd b">ingress-nginx</code>名称空间中看到pod。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="53e5" class="nh md it nd b gy ni nj l nk nl">$ kubectl get pod -n ingress-nginx<br/>NAME                                        READY   STATUS      RESTARTS   AGE<br/>ingress-nginx-controller-6b6855f9cb-sj4mw   1/1     Running     0          3m16s</span></pre><p id="b5fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们等待一段时间，让云提供商为<code class="fe nm nn no nd b">ingress-nginx-controller</code>负载均衡器服务分配一个外部IP，然后让服务知道这个外部IP。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5e8b" class="nh md it nd b gy ni nj l nk nl">$ kubectl get svc -n ingress-nginx ingress-nginx-controller<br/>NAME                       TYPE           CLUSTER-IP   EXTERNAL-IP    PORT(S)   AGE<br/>ingress-nginx-controller   LoadBalancer   10.8.6.193   <strong class="nd iu">35.224.126.9</strong>   80:32546/TCP,443:32267/TCP   10m</span></pre><p id="917b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们为入口控制器创建一个<code class="fe nm nn no nd b">HorizontalPodAutoscalar</code>，以便在集群中进行扩展。这是必要的，因为对工作负载的所有请求都是通过入口控制器pods路由的，所以我们希望它们随着流量而扩展。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等待HPA开始工作，很快我们会发现<code class="fe nm nn no nd b">nginx-ingress-controller</code>有两个吊舱。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="082e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，两个入口控制器都在可抢占池中提供。这是因为它更喜欢它，但当负载增加时，我们会发现它在整个集群中爆发。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fb26" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署示例应用程序</h1><p id="9676" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们部署一个示例应用程序，入口控制器将通过负载平衡器提供服务。让我们部署应用程序的两个版本，以了解它是如何工作的。</p><p id="6345" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为v1创建<code class="fe nm nn no nd b">deployment</code>和<code class="fe nm nn no nd b">service</code>。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="3eaa" class="nh md it nd b gy ni nj l nk nl">$ kubectl create deployment app-v1 --image=bharamicrosystems/nginx:v1<br/>deployment.apps/app-v1 created<br/>$ kubectl expose deployment app-v1 --port 80<br/>service/app-v1 exposed</span></pre><p id="0257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后为v2创建一个<code class="fe nm nn no nd b">deployment</code>和<code class="fe nm nn no nd b">service</code>。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7c4a" class="nh md it nd b gy ni nj l nk nl">$ kubectl create deployment app-v2 --image=bharamicrosystems/nginx:v2<br/>deployment.apps/app-v1 created<br/>$ kubectl expose deployment app-v2 --port 80<br/>service/app-v2 exposed</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="635b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">部署入口资源</h1><p id="ea29" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在让我们通过一个入口资源对外公开<code class="fe nm nn no nd b">app-v1</code>和<code class="fe nm nn no nd b">app-v2</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e1ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所定义的，如果我们用<code class="fe nm nn no nd b">/v1</code>点击入口控制器负载平衡器，我们应该从<code class="fe nm nn no nd b">app-v1</code>得到响应(从<code class="fe nm nn no nd b">app-v2</code>得到<code class="fe nm nn no nd b">/v2</code>)。让我们自己去看看吧。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f7e9" class="nh md it nd b gy ni nj l nk nl">$ curl 35.224.126.9/v1<br/>This is version 1<br/>$ curl 35.224.126.9/v2<br/>This is version 2</span></pre><p id="9c20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">入口规则运行得非常好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d2a2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">负载测试群集</h1><p id="43fb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们把事情变得有趣一些，做一些负载测试。我们将使用<code class="fe nm nn no nd b">hey</code>工具进行测试，但是您可以随意使用任何您想要的负载测试工具。</p><p id="a5cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经将<code class="fe nm nn no nd b">nginx-ingress-controller</code>pod配置为当目标CPU利用率增加超过70%时自动扩展，并且我们已经将pod限制设置为200毫核CPU。因此，任何超过140米的吊舱都应该旋转另一个吊舱来处理负载。</p><p id="efd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为v1和v2的300个并发请求计划1000个。这应该会在可抢占的节点池中旋转几个pod副本。</p><p id="416f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将在两个独立的终端上运行测试。在第三个终端中，我将运行<code class="fe nm nn no nd b">watch 'kubectl top pod -n ingress-nginx'</code>。</p><p id="edde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在第一个终端中使用<code class="fe nm nn no nd b">hey</code>命令继续工作:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1c08" class="nh md it nd b gy ni nj l nk nl">$ hey -z 300s -c 1000 <a class="ae ky" href="http://35.224.126.9/v1" rel="noopener ugc nofollow" target="_blank">http://35.224.126.9/v1</a></span></pre><p id="a45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和第二终端同时:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="226e" class="nh md it nd b gy ni nj l nk nl">$ hey -z 300s -c 1000 <a class="ae ky" href="http://35.224.126.9/v2" rel="noopener ugc nofollow" target="_blank">http://35.224.126.9/v2</a></span></pre><p id="1c61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第三个终端中，我们看到以下内容。随着负载的增加，Kubernetes增加了额外的NGINX入口控制器盒。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/cddbec572b3cec17b5dae3f944750ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bmy0QMx8d6emcjFeCeFquA.gif"/></div></div></figure><p id="8aa5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们得到pod，我们会看到大多数pod都出现在preemptibe节点中。默认节点池上部署了一个单元。这是因为该策略优先选择可抢占的节点，但这是一个软检查，因此如果我们失去了可抢占的节点，可以在常规节点池中部署pod。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="979e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们得到这些节点，我们会看到GKE节点在自动缩放。GKE在节点池中创建了另一个可抢占的节点来处理额外的负载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dbcd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="09f2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在可抢占的节点上运行无状态应用程序是一个不错的成本节约策略。它们可以快速恢复和替换，如果一个节点被拿走，它们可以快速进入其他可用节点。</p><p id="981c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的应用程序SLO可以容忍一些错误，并且您没有非常高的可用性要求，那么使用可抢占节点来运行您的入口控制器可能是一个不错的策略。</p><p id="54a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当GCP取走一个节点时，需要一分钟来旋转一个新的可抢占节点。在新节点中旋转另一个pod需要10秒钟。您需要决定您的SLO是否允许每24小时中断一分钟。如果不是，那么您应该坚持使用常规节点。</p><p id="96d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过在一天中最不繁忙的时段创建节点池来最大限度地减少中断。在大多数情况下，较小的可抢占节点存在24小时，所以当您丢失节点时，您会在没有很多用户的时候丢失它们。</p><p id="1c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还可以在节点虚拟机中使用关闭脚本来清空节点。这将确保更好的可用性。</p><p id="4147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读——我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>