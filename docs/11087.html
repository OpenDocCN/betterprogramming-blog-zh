<html>
<head>
<title>Understanding the 5 SOLID Principles Using Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Swift了解5大原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-s-o-l-i-d-21203ba3a226?source=collection_archive---------0-----------------------#2022-02-17">https://betterprogramming.pub/swift-s-o-l-i-d-21203ba3a226?source=collection_archive---------0-----------------------#2022-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8956" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用面向对象的类设计增强您的Swift代码库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f61fdd2d32ddd3550db02629cf8e7235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ywDprVEvjNYduWSN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@wesson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">威森王</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8b0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一段时间以来，我一直在努力提高我的代码质量，编写更具可读性和可开发性的代码。这个过程中最重要的一步是在代码中应用坚实的原则。让我们看看这个固体是什么？</p><p id="f85e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">固体是面向对象类设计的五个原则。它是设计结构时要遵循的一组规则和最佳实践。</p><h1 id="46f7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> (S)单一责任原则</strong></h1><p id="2c22" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">基本上，这个原则强调每个开发的模块只承担一个责任。对象和/或类从一开始就只负责一项任务。</p><p id="7f0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们先来看看不符合SRP的代码，在正常情况下工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="fdb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个<code class="fe mr ms mt mu b">DataHandler</code>类，它创建数据，解析数据，最后保存它创建的数据。如果您获取这段代码并尝试运行它，它将毫无问题地编译。那么这里的问题是什么呢？</p><p id="5187" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们查看代码时，<code class="fe mr ms mt mu b">DataHandler</code>类有多种职责，比如解析、保存和创建数据。</p><p id="8591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为解决方案，可以将当前职责转移到不同的类别:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="ad21" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> (O)开/关原理</strong></h1><p id="9d0c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">简单地说，实体应该对扩展开放，但对修改关闭。</p><p id="d94a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解释有时会令人困惑。让我们回顾一下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2c94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们想象我们有一个<code class="fe mr ms mt mu b">PaymentManager</code>。让这个经理在第一阶段支持现金和Visa支付方式。到目前为止一切都很好。过了一段时间，我们不得不更新经理，我们预计将万事达卡功能作为一个新的功能。</p><p id="a186" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们像前面的函数一样创建一个名为<code class="fe mr ms mt mu b">makeMasterCardPayment</code>的函数。太好了，我们的代码将继续工作。我们遵守了要求，但是我们打破了一个规则，即类必须关闭才能修改。对于做类似工作的任务，我们不应该在类中添加任何新的东西。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="ac41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何解决这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="4838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在抽象结构(协议)中定义<code class="fe mr ms mt mu b">PaymentManager</code>中的主要任务，这个结构将回答<code class="fe mr ms mt mu b">PaymentManager</code>期望的需求。</p><p id="4c48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还为每种支付方式创建了一个单独的类，这些类将采用<code class="fe mr ms mt mu b">PaymentMamager</code>所期望的抽象结构。因此，我们可以添加尽可能多的新支付方式，而无需对管理器进行任何更改。</p><p id="8ae6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们保持<code class="fe mr ms mt mu b">PaymentManager</code>类对扩展开放，但对修改关闭。</p><h1 id="6272" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> (L)利斯科夫替代原理</strong></h1><p id="55dc" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对象应该在不改变行为的情况下被其子类的实例替换。在这个简短的解释之后，我们来谈谈代码。</p><p id="5401" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一类矩形，矩形有一个宽度和一个高度，它们的乘积等于面积。</p><p id="c521" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有没有square类，理论上正方形是矩形，所以我们可以从类rectangle继承类square。到目前为止一切都很好。</p><p id="7cbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的<code class="fe mr ms mt mu b">setSizeAndPrint</code>函数需要一个rectangle类型的变量，并默认分配矩形的宽度和高度。为rectangle类调用这个函数没问题，因为<code class="fe mr ms mt mu b">width = 4</code>、<code class="fe mr ms mt mu b">height = 5</code>、<code class="fe mr ms mt mu b">area = 20</code>。</p><p id="a9eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是对于从rectangle类继承的正方形来说，情况就不一样了，因为正方形的两边是相等的。我们不能只是默认分配4和5，并期望它像它继承的类一样工作。</p><p id="b64a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，不能作为继承类并且需要特定情况开发的类破坏了LSP。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="261e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一种解决方案，它旨在通过将类之间的共同任务保持在某个抽象结构(协议)中，让每个类在其内部执行自己的任务。</p><p id="e457" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上例所示，<code class="fe mr ms mt mu b">Rectangle</code>和<code class="fe mr ms mt mu b">Square</code>类之间的共同任务是计算对象的面积。rectangle和square类都继承了Polygon抽象结构，这是在一个公共协议中定义的任务。因此，每个类都在自己内部完成必要的任务，不需要进行任何特殊的开发。类的行为就像它们继承的结构一样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="e2a1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">(一)界面分离原理</strong></h1><p id="4f9c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">总之，不应该强迫客户依赖他们不使用的接口。不应该强迫任何代码依赖它不使用的方法。</p><p id="f8a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们直接进入代码，实际地看看问题。</p><p id="7e21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们有一个名为<code class="fe mr ms mt mu b">Worker</code>的抽象结构，一般来说，我们期望那些从Worker类继承的人能够完成吃饭和工作任务。</p><p id="f55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们有一个名为<code class="fe mr ms mt mu b">Human</code>的类，这个类继承自抽象结构工人。理论上，我们期望一个人既吃饭又工作。然后，我们需要一个机器人结构，我们从工人结构继承了它，因为机器人可以工作。</p><p id="99f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题从这里开始，因为工人协议有两个功能，一个是工作，一个是吃饭，工作功能没有问题，因为机器人可以运行，但因为我们从工人结构继承，我们必须添加吃饭功能，这导致了不必要的责任被传递给类。现在是ISP休息时间。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="bee4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们必须将具有抽象结构的职责划分为基本部分。</p><p id="3c79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在为eat函数创建一个名为<code class="fe mr ms mt mu b">Feedable</code>的新抽象结构，为work函数创建一个名为<code class="fe mr ms mt mu b">Workable</code>的抽象结构。因此，我们分工负责。</p><p id="4809" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe mr ms mt mu b">Human</code>类将从<code class="fe mr ms mt mu b">Feeble</code>和<code class="fe mr ms mt mu b">Workable</code>继承，而<code class="fe mr ms mt mu b">Robot</code>类仅从<code class="fe mr ms mt mu b">Workable</code>继承。</p><p id="88b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们不会给任何职业强加任何不必要的责任，我们创建了一个适合ISP的结构。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="783c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak"> (D)依存倒置原则</strong></h1><p id="1e6c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">DIP理论上高层模块不应该从低层模块导入任何东西。两者都应该依赖于抽象，而抽象不应该依赖于细节。细节应该依赖于抽象。</p><p id="4aed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看下面的例子和理论信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="18c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个<code class="fe mr ms mt mu b">employee</code>结构，这个结构有一个功函数。我们还有一个<code class="fe mr ms mt mu b">Employer</code>结构，这个结构使现有员工能够工作。<br/>run函数中创建了一个<code class="fe mr ms mt mu b">employer</code>对象，默认情况下，它接受数组<code class="fe mr ms mt mu b">Employee</code>。同样，到目前为止一切都很好，可能我们的项目会成功，但我们在这里错过了一些东西。<code class="fe mr ms mt mu b">Employer</code>结构直接链接到非抽象<code class="fe mr ms mt mu b">Employee</code>结构。这就是我们需要蘸酱的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用DIP的理论知识，我们知道结构应该依赖于抽象模型。</p><p id="576a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们创建了一个抽象的<code class="fe mr ms mt mu b">Workable</code>结构，并将<code class="fe mr ms mt mu b">Employee</code>类依赖于<code class="fe mr ms mt mu b">Workable</code>，这样<code class="fe mr ms mt mu b">Employee</code>结构就保留了它原来的功能。</p><p id="eeb8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键是<code class="fe mr ms mt mu b">Employer</code>类现在期望抽象结构<code class="fe mr ms mt mu b">Workable</code>的数组，而不是数组<code class="fe mr ms mt mu b">Employee</code>。因此，我们已经将<code class="fe mr ms mt mu b">Employer</code>结构的依赖关系链接到一个抽象模块。这意味着<code class="fe mr ms mt mu b">Employer</code>结构已经到了可以依赖<code class="fe mr ms mt mu b">Workable</code>模块运行任何结构的地步。</p><p id="3141" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章。你可以在我的GitHub上找到所有代码:</p><div class="mv mw gp gr mx my"><a href="https://github.com/MCTOK1903/SwiftSolid" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab fo"><div class="na ab nb cl cj nc"><h2 class="bd ir gy z fp nd fr fs ne fu fw ip bi translated">GitHub - MCTOK1903/SwiftSolid</h2><div class="nf l"><h3 class="bd b gy z fp nd fr fs ne fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ng l"><p class="bd b dl z fp nd fr fs ne fu fw dk translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm kp my"/></div></div></a></div><h1 id="e05e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考链接</h1><p id="d221" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> 1 </strong>。https://en . Wikipedia . org/wiki/Dependency _ inversion _ principle</a></p><p id="1202" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=rndiYu8If-I&amp;list=PL_csAAO9PQ8ZIh89P2re5fziX9kaI8Yhx&amp;index=1" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> 2 </strong>。https://www.youtube.com/watch?v = rndi Yu 8 if-I&amp;list = PL _ CsA ao 9 pq 8 zih 89 p 2 re 5 fzix 9 kai 8 yhx&amp;index = 1</a></p><p id="1253" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 3 </strong>。<a class="ae kv" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/SOLID</a></p><p id="8b67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 4 </strong>。<a class="ae kv" href="http://www.principles-wiki.net/principles:open-closed_principle" rel="noopener ugc nofollow" target="_blank">http://www . principles-wiki . net/principles:open-closed _ principle</a></p><p id="83cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 5 </strong>。<a class="ae kv" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Dependency _ inversion _ principal</a></p></div></div>    
</body>
</html>