<html>
<head>
<title>How to Achieve Dynamic Dispatch Using Generic Protocols in Swift 5.7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.7中如何使用通用协议实现动态调度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-achieve-dynamic-dispatch-using-generic-protocols-in-swift-5-7-cac664d481e0?source=collection_archive---------12-----------------------#2022-07-06">https://betterprogramming.pub/how-to-achieve-dynamic-dispatch-using-generic-protocols-in-swift-5-7-cac664d481e0?source=collection_archive---------12-----------------------#2022-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="657f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从来没有这么简单过！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/05a62b96d2c9d50fe0b7ad6d97a070a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M0AiI3dVSAfCcdnDlCBcOg.jpeg"/></div></div></figure><p id="6f19" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">动态调度是面向对象编程中最重要的机制之一。它是使运行时多态性成为可能的核心机制，使开发人员能够编写在运行时而不是编译时决定其执行路径的代码。</p><p id="fae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在OOP中实现动态调度似乎很容易，但在面向协议编程(POP)中却不是这样。由于Swift编译器中的各种限制，试图使用协议完成动态调度总是会遇到无法预料的困难。</p><p id="a1da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着Swift 5.7的发布，这一切都成为了历史！在POP领域实现动态调度从未如此简单。在本文中，让我们探讨一下Swift 5.7带来了哪些改进，以及使用带有关联类型的协议实现动态调度需要做些什么。</p><p id="baa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，事不宜迟，让我们开始吧！</p><blockquote class="lq lr ls"><p id="0376" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">注意:</p><p id="4a68" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">如果你对Swift中的<code class="fe lx ly lz ma b">some</code>和<code class="fe lx ly lz ma b">any</code>关键字不熟悉，我强烈建议你首先阅读我的博客文章《理解Swift 5.7中的“一些”和“任何”关键字》。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="174e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">重要的事情先来</h1><p id="784c" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在我开始向您展示Swift 5.7的改进之前，让我们定义本文中样本代码所需的协议和结构。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1e7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们上面的定义类似于我们在我的<a class="ae mb" href="https://swiftsenpai.com/swift/understanding-some-and-any/" rel="noopener ugc nofollow" target="_blank">上一篇</a>文章中使用的定义，但是有一点扭曲。在我们的<code class="fe lx ly lz ma b">Vehicle</code>协议中，我们有两个功能需求，<code class="fe lx ly lz ma b">startEngin()</code>和<code class="fe lx ly lz ma b">fillGasTank(with:)</code>。为了便于演示，我们将尝试在<code class="fe lx ly lz ma b">Car</code>和<code class="fe lx ly lz ma b">Bus</code>结构中使用这两个函数来实现动态调度。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="353c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">Swift 5.6及以下版本中通用协议的局限性</h1><p id="b835" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">现在，假设我们想要创建一个接受异构数组的<code class="fe lx ly lz ma b">startAllEngin()</code>函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7a6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到，在Swift 5.6中，这实际上是不可能的，因为您会得到一个错误提示:“协议‘Vehicle’只能用作通用约束，因为它具有自身或关联的类型要求”。Swift编译器禁止我们创建以<code class="fe lx ly lz ma b">Vehicle</code>为元素类型的异构数组，因为<code class="fe lx ly lz ma b">Vehicle</code>有一个关联的类型(<code class="fe lx ly lz ma b">FuelType</code>)。</p><blockquote class="lq lr ls"><p id="9b12" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">专业提示:</p><p id="c188" class="ku kv lt kw b kx ky ju kz la lb jx lc lu le lf lg lv li lj lk lw lm ln lo lp im bi translated">如果您想了解有关该错误的更多信息，以及如何在Swift 5.7之前解决该错误，请查看我在Medium上发表的文章:“<a class="ae mb" href="https://leekahseng.medium.com/accomplishing-dynamic-dispatch-on-pats-protocol-with-associated-types-b29d1242e939" rel="noopener"> Swift:在PATs(具有关联类型的协议)上实现动态调度</a>”</p></blockquote><p id="9013" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于苹果对Swift编译器进行了升级，这一限制在Swift 5.7中不再存在。我们终于可以像在OOP中使用超类一样使用协议了。让我告诉你怎么做。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d03b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">对简单函数执行动态调度</h1><p id="14a4" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">在Swift 5.7中，编译器不再禁止创建异构数组。我们需要做的就是使用<code class="fe lx ly lz ma b">any</code>关键字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0a83" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<code class="fe lx ly lz ma b">any</code>关键字，我们告诉编译器数组将包含存在类型，并且它们的底层具体类型将总是符合<code class="fe lx ly lz ma b">Vehicle</code>协议。</p><p id="fd3d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，调用<code class="fe lx ly lz ma b">startAllEngin(for:)</code>就会得到我们想要的动态调度。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="83a6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">对带有泛型参数的函数执行动态调度</h1><p id="3916" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">现在让我们来看看另一个更复杂的例子。假设我们想要创建一个名为<code class="fe lx ly lz ma b">fillAllGasTank(for:)</code>的函数。该函数将根据给定的<code class="fe lx ly lz ma b">vehicles</code>数组对车辆的<code class="fe lx ly lz ma b">fillGasTank(with:)</code>函数进行动态调度。</p><h2 id="e062" class="ni mk it bd ml nj nk dn mp nl nm dp mt ld nn no mv lh np nq mx ll nr ns mz nt bi translated">定义泛型参数类型</h2><p id="6ba5" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">一开始，我们试图实现的目标似乎很简单，但是当我们开始编码时，我们会遇到第一个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5ae9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于不同类型的车辆需要不同种类的燃料，我们必须创建一个通用协议来表示<code class="fe lx ly lz ma b">Gasoline</code>和<code class="fe lx ly lz ma b">Diesel</code>。让我们继续做那件事。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="07b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lx ly lz ma b">Fuel</code>协议只是一个简单的协议，由一个名为<code class="fe lx ly lz ma b">FuelType</code>的关联类型和一个静态<code class="fe lx ly lz ma b">purchase()</code>函数组成。注意我们如何约束<code class="fe lx ly lz ma b">FuelType</code>总是等于符合<code class="fe lx ly lz ma b">Fuel</code>协议的类型。为了让编译器确定静态<code class="fe lx ly lz ma b">purchase()</code>函数返回的具体类型，这个约束非常重要。</p><p id="4fc6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们使<code class="fe lx ly lz ma b">Gasoline</code>和<code class="fe lx ly lz ma b">Diesel</code>都符合<code class="fe lx ly lz ma b">Fuel</code>协议。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cca8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除此之外，我们还需要确保<code class="fe lx ly lz ma b">Vehicle</code>协议的<code class="fe lx ly lz ma b">FuelType</code>是符合<code class="fe lx ly lz ma b">Fuel</code>协议的类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="c667" class="ni mk it bd ml nj nk dn mp nl nm dp mt ld nn no mv lh np nq mx ll nr ns mz nt bi translated">“任何”到“一些”的转换</h2><p id="e855" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">随着<code class="fe lx ly lz ma b">Fuel</code>协议和所有其他相关变更的就绪，我们现在可以重新访问<code class="fe lx ly lz ma b">fillAllGasTank(for:)</code>函数并对其进行相应的更新。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1a2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，注意我们如何利用车辆的燃料类型来获取<code class="fe lx ly lz ma b">Fuel</code>具体类型的实例，这样我们就可以将它传递给<code class="fe lx ly lz ma b">fillGasTank(with:)</code>函数。</p><p id="3ad7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，如果我们试图编译我们的代码，我们将遇到我们的第二个问题:<strong class="kw iu"> " <em class="lt">成员“fillGasTank”不能用于类型“any Vehicle”的值；考虑使用一个通用约束来代替“</em> </strong>”。那是什么意思？</p><p id="9721" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解我们得到的错误，让我们快速回顾一下<code class="fe lx ly lz ma b">some</code>和<code class="fe lx ly lz ma b">any</code>关键字之间的区别。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/ab4d10c336259562c6fb897c07d2036e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*W89nfWEHun4UouP9"/></div></div></figure><p id="097d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如上图所示，存在类型的底层具体类型被包装在一个盒子里。因此，编译器禁止我们访问<code class="fe lx ly lz ma b">fillGasTank(with:)</code>函数。为此，在访问<code class="fe lx ly lz ma b">fillGasTank(with:)</code>函数之前，我们必须首先将存在类型转换(拆箱)为不透明类型。</p><p id="b0e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，苹果在Swift 5.7中已经使转换(拆箱)过程变得极其容易。我们所要做的就是将存在类型传递给一个接受不透明类型的函数，转换就会自动发生。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ba65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，我们现在可以编译和执行我们的代码，没有任何错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="bdfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想亲自尝试，可以在这里随意获取完整的示例代码<a class="ae mb" href="https://gist.github.com/LeeKahSeng/a347da1778c71f55537eda991bd56c64" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="7ef4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">包扎</h1><p id="ffb3" class="pw-post-body-paragraph ku kv it kw b kx nb ju kz la nc jx lc ld nd lf lg lh ne lj lk ll nf ln lo lp im bi translated">你有它！这就是我们如何在具有关联类型的协议上实现动态调度。综上所述，以下是Swift 5.7中使所有这些成为可能的改进:</p><ol class=""><li id="9c45" class="nv nw it kw b kx ky la lb ld nx lh ny ll nz lp oa ob oc od bi translated">消除使用具有关联类型的协议创建异构数组的限制。</li><li id="b5f8" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">允许在函数的参数位置使用<code class="fe lx ly lz ma b">any</code>和<code class="fe lx ly lz ma b">some</code>关键字。</li><li id="9601" class="nv nw it kw b kx oe la of ld og lh oh ll oi lp oa ob oc od bi translated">从存在型到不透明型的自动转换，反之亦然。</li></ol><p id="3c4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢这篇文章，请随时在Twitter上关注我，并订阅我的每月简讯，这样你就不会错过我即将发表的任何文章。</p><p id="921a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p><h1 id="de0c" class="mj mk it bd ml mm oj mo mp mq ok ms mt jz ol ka mv kc om kd mx kf on kg mz na bi translated">资源</h1><ul class=""><li id="aa90" class="nv nw it kw b kx nb la nc ld oo lh op ll oq lp or ob oc od bi translated"><a class="ae mb" href="https://leekahseng.medium.com/accomplishing-dynamic-dispatch-on-pats-protocol-with-associated-types-b29d1242e939" rel="noopener"> Swift:完成PATs(关联类型的协议)的动态调度</a></li></ul></div></div>    
</body>
</html>