# 数据结构:改善堆栈和队列的时间复杂度

> 原文：<https://betterprogramming.pub/improving-time-complexity-on-stacks-and-queues-7396ab7b5a2b>

## 如何在应用扩展时使用堆栈和队列

![](img/624fc72f8c494b9765ccf63a455d2ae2.png)

照片由 [noor Younis](https://unsplash.com/@nooryounis?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/time?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

# 背景

在我之前的博客中，我介绍了一种叫做栈和队列的利基数据结构。如果你对它不熟悉，请快速看一下我的博客 [*栈和队列*](https://medium.com/better-programming/stacks-and-queues-7c322b5f4e35) 。

简单来说，栈和队列遵循先入后出(栈)和先入先出(队列)的原则。然而，对于现成的 JavaScript 数组方法，栈的时间复杂度是 O(1)，队列的时间复杂度是 O(n)。

这让我想到，我们能做得更好吗？具体来说，我们是否可以将队列的时间复杂度提高到比 O(n)更快？

# 灵感

在我们进一步深入之前，我想感谢 Rud，他向我介绍了循环数组的概念，以改善堆栈和队列的时间复杂度。我对循环数组的研究启发了我创建自己的堆栈和队列数组类。

虽然在这篇博客中我没有深入研究循环数组，但是我使用了从研究循环数组中学到的相同原理，并将它们用于我的堆栈和队列数组类。

# 堆栈和队列类概述

在我们深入研究杂草和代码之前，让我们提供一个如何创建`StackQueueArray`类的概述。

对于堆栈部分，由于即时可用的 Javascript 数组方法的时间复杂度为 O(1)，所以我决定继续使用相同的方法(即`.push()`和`.pop()`)。当它运行得非常好的时候，重新发明轮子是没有意义的，尤其是当它已经被优化的时候。

对于队列部分，这是我必须跳出框框思考的地方。我们仍将利用`.push()`方法，但`.shift()`方法需要改变。毕竟`.shift()`方法是时间复杂度为 O(n)的原因。

这就是利用循环数组原理的地方。根据我的研究，一个关于循环数组的隐含假设是它们有固定的长度。

通常，循环数组有一个指针指向数组的头部和尾部。通过始终跟踪头部和尾部所在位置的指针，您可以计算出数组中是否有空间来添加额外的元素。

换句话说，如果头部和尾部是*而不是*相邻，那么你可以添加元素。

然而，在 JavaScript 中，由于它是一种动态语言，我们不必担心内存分配。这阻止了我使用循环数组，但是启发了我使用指针来跟踪数组的头部。

我们不需要尾部的指针，因为尾部总是数组的最后一个元素。

那么，我们如何结合自定义的`.shift()`方法使用 head 指针呢？

让我们用`StackQueueArray`类建立一个新数组，并将一些元素放入其中。

现在不要担心类方法，因为我们将在后面深入讨论这些方法的细节。回想一下，`.push()`功能将与开箱即用的`.push()`功能相同。

```
let array = new StackQueueArray()
array.push(10)
array.push(20)
array.push(30)
console.log(array) // [10, 20, 30]
```

在`StackQueueArray`类中，它将有一个名为`headIndex`的属性，这将是我们的头指针。目前，在`array`中，`headIndex`应该是`0`，因为按照先入原则`10`是第一个推入数组的元素。

```
console.log(array.headIndex) // 0
```

现在，通过我们的自定义`.shift()`方法，我们将利用我从循环数组中学到的另一个原理。

在一个圆形数组中，只要头指针和尾指针之间有空格，就会用`null`作为占位符来填充。每当我们调用自定义的`.shift()`方法时，我们都要做同样的事情。

当`.shift()`被调用时，它会将`headIndex`处的值与`null`交换，将`headIndex`增加`1`以将磁头指针分配给新的磁头，并返回该值。

因此，在伪代码中，它看起来像这样:

```
console.log(array) // [10, 20, 30]
console.log(array.headIndex) // 0
array.shift()
console.log(array) // [null, 20, 30]
console.log(array.headIndex) // 1
```

让我们真正理解它，并再次调用我们的自定义`.shift()`方法到我们当前的`array`来固化该方法应该做的事情。

```
array.shift() 
console.log(array) // [null, null, 30]
console.log(array.headIndex) // 2
```

既然我们对方法应该做什么和类的一般概念有了更全面的理解，让我们把它分解成代码。

注意:出于简洁和解释的目的，下面的`StackQueueArray`类的代码将只考虑正常情况。有许多边缘情况需要考虑，我将在另一个部分进行讨论，我将在本博客的结尾提供该类的完整代码。

# 推送和弹出功能

让我们从`StackQueueArray`类需要什么开始。我们将初始化一个空数组和`headIndex`。

到目前为止，一切顺利。我们将`headIndex`初始化为`null`，因为数组是空的，所以还不需要头指针。

接下来，让我们进入`.push()`和`.pop()`功能。回想一下，我们将利用 JavaScript 已经提供的现成方法。

首先，我们来做一下`.push()`函数。

在`if`语句中，这仅在数组为空时发生。我们将从`0`开始`headIndex`，因为当你将一个元素推入一个空数组时，它将位于索引`0`。

接下来，我们来做`.pop()`函数。

我正在使用 JavaScript 的开箱即用的`.pop()`函数，并将它作为我自己的函数使用。

# 移位、头部和尾部功能

好了，现在是最难的部分，定制`.shift()`函数。对于正常情况，让我们假设我们已经有了`[10, 20, 30]`作为我们的数组。本例中`headIndex`在`0`处。

根据我在“堆栈和队列类概述”一节中所说的，下面是我们需要完成的三个步骤。

1.  用`null`交换`headIndex`处的值。
2.  将`headIndex`增加`1`。
3.  返回前一个`headIndex`的值(递增`headIndex`前的值)。

因为我们需要返回值，所以我们应该将它保存在一个单独的变量中。

为了节省空间，我将在。`shift()`单独运行，完成后输入到类中。`array`和`headIndex`仍参考以前的代码。

目前看来还不错！

我们还可以包含一些帮助函数来查找头部和尾部，以减轻解析整个数组的痛苦。

因为我们知道尾部总是在数组的末尾，所以我们可以使用数组的长度作为我们的参考点。对于头部，我们已经有了一个头部指针，就是我们的`headIndex`。

太好了，现在让我们将这些方法添加到`StackQueueArray`类中！

还有维奥拉。我们已经创建了`StackQueueArray`类的框架。

如果你能跟得这么远，你已经成功了一半以上！接下来的步骤将会考虑到边缘情况…而且有很多这样的情况。

如果你想挑战自己，试着想想这门课可能发生的所有极端情况。这对于代码挑战和代码面试来说是特别好的实践，因为考虑所有可能的边缘情况是开发人员的责任。

我个人甚至不知道所有的边缘案例是不是我自己想到的。

# 大量边缘案例

有六种独特的边缘情况需要考虑。这些边缘情况中的一些以不同的方式重复。

下面的要点显示了我制作的`StackQueueArray`类的完整代码。我还做了一个额外的方法，叫做`cleanUp()`，稍后我会解释。

## 边缘情况 1

所有的元素都是`null`。这通常发生在`.shift()`一直被调用到数组末尾的时候。

## 边缘情况 2

数组中只有一个非空元素。这只发生在`.pop()`方法上，因为在调用它之后，数组将是空的，这意味着`headIndex`应该是`null`。

## 边缘案例 3

数组的尾部是最后一个非空元素。这只发生在`.pop()`方法中，因为在调用它之后，我们需要通过减少`1`来重新分配`headIndex`。

如果我们不递减它，`headIndex`将在数组本身的范围之外。

## 边缘案例 4

数组或者为空，或者数组中的所有元素都是`null`。

## 边缘情况 5

没有参数用于`.push()`方法。这是针对用户可能忘记输入值或决定输入值`null`的错误。

如果没有参数，`.push()`会将`undefined`推入数组。将`undefined`或`null`压入数组会破坏类，也违反了堆栈和队列数据结构的基础。

在我们进入边缘情况 6 之前，让我解释一下`.cleanUp()`方法的目的。

# cleanUp()方法

我设计了`.cleanUp()`,因为我想到了如果只多次调用`.push()`和`.shift()`方法会发生什么。例如，数组可能看起来像是有一堆`null`值，末尾有两个非空值。

```
console.log(array) 
// [null, null, null, null, null, null, null, null, null, 10, 20]
```

如前所述，`null`值只是代表先前磁头所在位置的占位符。我们不再关心这些`null`值了。

但是，如果您有内存需求或者内存不足以存储这个数组，该怎么办呢？

这就是`.cleanUp()`方法的灵感来源。我们可以调用这个方法，通过删除所有的`null`值来缩短我们的数组以占用更少的内存。

因此，在伪代码中，它看起来像下面这样:

```
array.cleanUp()
console.log(array) // [10, 20]
```

然而，这引入了两种边缘情况:边缘情况 1 和边缘情况 6。我们已经考虑了边缘情况 1，其中数组中的所有元素都是`null`。对于这种方法中的边缘情况，我们将返回到类的初始条件。

## 边缘情况 6

数组为空，或者数组只包含非空元素。

对于边缘情况 6，我们不会以任何方式改变数组，并让用户知道数组中没有更多的`null`值。

# StackQueueArray 类的时间复杂度

如果你已经走了这么远，给自己一点鼓励。这需要处理大量信息，尤其是如果您阅读了我之前关于栈和队列的博客。

记住，最初的目标是将时间复杂度从 O(n)提高到 O(1)。让我们看看每个类方法的时间复杂度，看看我们是否达到了。

`.push()`:对于这个方法，我们做了五个动作:声明、递增、布尔比较、访问数组中的元素，以及使用现成的`.push()`方法。

每个动作的时间复杂度都是 O(1)，这意味着这个方法的时间复杂度是 O(1)。

`.pop()`:对于这个方法，我们做了五个动作:声明、递减、布尔比较、访问数组中的元素，以及使用现成的`.pop()`方法。

每个动作的时间复杂度都是 O(1)，这意味着这个方法的时间复杂度是 O(1)。

`.shift()`:对于这个方法，我们做了四个动作:声明、递增、布尔比较和访问数组中的元素。

每个动作的时间复杂度都是 O(1)，这意味着这个方法的时间复杂度是 O(1)。

对于这个方法，我们做了三个动作:声明、布尔比较和访问数组中的元素。

每个动作的时间复杂度都是 O(1)，这意味着这个方法的时间复杂度是 O(1)。

`.tail()`:对于这个方法，我们做了三个动作:声明、布尔比较和访问数组中的元素。

每个动作的时间复杂度都是 O(1)，这意味着这个方法的时间复杂度是 O(1)。

`.cleanUp()`:对于这个方法，我们做了四个动作:声明、布尔比较、访问数组中的元素，以及使用现成的`.slice()`方法。

除了`.slice()`方法，这些动作的时间复杂度都是 O(1)。

`.slice()`方法根据参数中提供的输入范围复制子阵列。在最坏的情况下，它可以复制整个数组，这取决于数组的长度。

基于此，`.slice()`方法的时间复杂度为 O(n)。这意味着，在最坏的情况下，`.cleanUp()`方法的时间复杂度为 O(n)。

看起来每个方法，除了`.cleanUp()`，时间复杂度都是 O(1)。我们会认为这是成功吗？是啊！原因如下。

回想一下`.cleanUp()`最初是为了帮助分配，而不是时间复杂度。你可以把这个方法更多地看作是一个有好处的方法，而不是一个必须的方法。

这种方法不会直接影响堆栈和队列数据结构的症结。如果我们在`StackQueueArray`类中没有`.cleanUp()`方法，这个类仍然可以用于任何实现堆栈和队列的数据结构，假设内存不是问题。

如果我们现在忽略`.cleanUp()`方法，那么`StackQueueArray`类的总时间复杂度是 O(1)！

我们成功地将栈和队列的时间复杂度从 O(n)提高到 O(1)！

# 结论

注意在`StackQueueArray`类中，我们没有使用任何特殊的函数或者不常见的东西。我们在类中编码的一切都是现成的方法、数组的属性和布尔比较。

构建一个新的类只需要一些创造力，现在我们有了一个比使用栈和队列的现成方法更快的类。