<html>
<head>
<title>A Deep Dive Into Swift’s DispatchWorkItem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入了解Swift的DispatchWorkItem</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-deep-dive-into-dispatchworkitem-274548357dea?source=collection_archive---------1-----------------------#2020-05-11">https://betterprogramming.pub/a-deep-dive-into-dispatchworkitem-274548357dea?source=collection_archive---------1-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7f3f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">何时使用DispatchWorkItem、wait()、notify()和标志</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8abfe14ebbdb560de8217e3b7fe9aa99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6Co291ZPNhSMAH_Z"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@chuklanov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Avel Chuklanov </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cc6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个<code class="fe ls lt lu lv b">DispatchWorkItem</code>封装了要在一个调度队列或一个调度组上执行的工作。它主要用于我们需要延迟或取消代码块执行的场景。</p><p id="35c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它允许我们取消一个排队的任务，但是，我们只能在任务到达队列头并开始执行之前取消它。</p><p id="954b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将看到几个真实世界的例子，其中<code class="fe ls lt lu lv b">DispatchWorkItem</code>用于延迟和/或取消代码块的执行。</p><p id="5176" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将要提到的例子可以不使用<code class="fe ls lt lu lv b">DispatchWorkItem</code>来实现，然而，使用它使得代码更加简单和易于维护。我们还将讨论<code class="fe ls lt lu lv b">DispatchWorkItemFlags</code>、<code class="fe ls lt lu lv b">wait()</code>和<code class="fe ls lt lu lv b">notify()</code>方法。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="1769" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated"><strong class="ak">例1 </strong></h1><p id="f2b6" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">想象一下，我们正在开发一个电子商务应用程序，我们有一个搜索栏向我们显示预先输入的结果。</p><p id="ecc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户开始输入字母时，我们是否希望为用户输入的每个新字母点击后端服务？当然不能，因为这会大大增加我们后端服务器的负载。</p><p id="5c03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们对这些事件进行反跳，只有在用户一两秒钟没有输入任何内容后才会发送请求。让我们看看如何使用<code class="fe ls lt lu lv b">DispatchWorkItem</code>来实现这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/171417a97369a9434bb1ed483d900cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnugTnc00-94Tldkf3CK1Q.png"/></div></div></figure><p id="d524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">getSearchResults</code>方法中，<code class="fe ls lt lu lv b">WorkItem</code>只有在用户30毫秒没有输入任何东西后才会被执行。因此，上述执行的输出将是:</p><pre class="kg kh ki kj gt nb lv nc nd aw ne bi"><span id="28e6" class="nf me iq lv b gy ng nh l ni nj">sent a backend request for sh</span><span id="8153" class="nf me iq lv b gy nk nh l ni nj">sent a backend request for shir</span></pre><p id="e539" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个新的字母在指定的延迟时间内被键入时，我们实质上取消了前面的<code class="fe ls lt lu lv b">workItem</code>。由于我们设置主线程在输入<code class="fe ls lt lu lv b">sh</code>后休眠超过30毫秒，后台线程开始执行<code class="fe ls lt lu lv b">WorkItem</code>。</p><p id="0efc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也可以为需要服务器端验证的文本字段实现。假设用户正在输入用户名以在我们的网站上注册，我们可以使用上面示例中的<code class="fe ls lt lu lv b">DispatchWorkItem</code>来验证该用户名是否已被使用</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="139c" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">示例2</h1><p id="ba3f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">假设我们构建了一个新的应用程序，并希望通过应用程序内的动画演示向用户展示如何使用该应用程序。</p><p id="4482" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果用户已经开始与应用程序交互，我们不想显示它(这意味着用户知道应用程序是做什么的。假设…)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/423ee78c6b8fe610b1c205136b187629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5p-kzWviKg3nkxQhTlu4Jg.png"/></div></div></figure><p id="9a50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户已经与应用程序交互，<code class="fe ls lt lu lv b">usedTheApp</code>方法将取消<code class="fe ls lt lu lv b">DispatchWorkItem</code>的执行。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="50bb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">通知()</h1><p id="b9fd" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">Notify计划在当前工作项目完成后执行指定的工作项目。让我们看看它的实际效果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/7e1ed71cd9acaeafcd18d837c8c1c5c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJBWV79RV63wW7ET_4PDqQ.png"/></div></div></figure><p id="8653" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可用于以串行方式执行两个或多个任务，其中第一个任务必须在执行下一个任务之前完成。</p><p id="d197" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个示例用例是在后台线程上获取表视图的数据，并通知主线程数据已准备就绪</p><p id="8e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">DispatchWorkItem</code>上的<code class="fe ls lt lu lv b">perform()</code>方法将在当前线程上同步启动工作项的执行。看看上面例子中的用法。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="89b7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">等待()</h1><p id="a4d7" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated"><code class="fe ls lt lu lv b">wait()</code>使调用者同步等待，直到分派工作项目执行完毕。让我们看看它的实际效果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/82067cb79197dfdbd20342a62a055528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99ifqYvjKzbm2ljR74DErA.png"/></div></div></figure><p id="f11b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不建议使用to <code class="fe ls lt lu lv b">wait()</code>，因为它会阻止线程执行。</p><p id="5540" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们阻塞了主线程的执行，这是应该避免的。即使我们将任务分派给一个后台线程，当我们执行请求时，我们实际上阻塞了一个非常有限的GCD工作线程。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="4715" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">DispatchWorkItemFlags</h1><p id="8e55" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">这个标志为一个工作项定义了一组行为，比如它的服务质量等级，以及是创建一个屏障还是产生一个新的分离线程。最常用的标志是<code class="fe ls lt lu lv b">assignCurrentContext</code>和<code class="fe ls lt lu lv b">barrier</code>。</p><p id="c96e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">barrier</code>:当提交到并发队列时，使工作项目充当障碍块。在并发队列中，多个任务在不同的线程上同时执行。</p><p id="3c86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当带有<code class="fe ls lt lu lv b">barrier</code>标志的工作项开始执行时，队列中的所有任务被暂时挂起，一旦该工作项完成，这些任务将被恢复。</p><p id="bbf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">assignCurrentContext</code>:设置工作项的属性，以匹配当前执行上下文的属性。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7e1a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">尾注</h1><p id="23c6" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">这就是我这篇文章的全部内容，感谢阅读。<strong class="ky ir">关注我的</strong> <a class="ae kv" href="https://twitter.com/_kiran_44" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">推特</strong> </a> <strong class="ky ir"> </strong>了解更多更新。如果你喜欢这个帖子，请提供一些掌声，因为这将鼓励我写更多(<strong class="ky ir">你可以放弃50个</strong>)。如果你想看更多的文章，请跳上我的网站。如果你认为我可以在文章中做些改进，请告诉我。</p></div></div>    
</body>
</html>