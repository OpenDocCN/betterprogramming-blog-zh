<html>
<head>
<title>Data Classes in Python: A Primer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的数据类:入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-classes-in-python-a-primer-81b63a484435?source=collection_archive---------6-----------------------#2021-09-23">https://betterprogramming.pub/data-classes-in-python-a-primer-81b63a484435?source=collection_archive---------6-----------------------#2021-09-23</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="d80e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">它和普通的Python类有什么不同？</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/824790ed8432960934e432bb518d3743.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zX2yZCoE0szcBQvO"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@flpschi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费利佩·斯基亚罗利</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c761" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">数据类基本上是一个普通的Python类，带有一个<code class="fe lw lx ly lz b">@dataclass</code>装饰器。顾名思义，<em class="ma">数据</em>类通常是为主要包含<em class="ma">数据</em>和存储状态的类创建的。该特性是在<a class="ae kz" href="https://www.python.org/dev/peps/pep-0557/" rel="noopener ugc nofollow" target="_blank"> Python3.7 </a>中引入的，但在Python3.6中也被向后移植了。</p><p id="3dc8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为数据类实际上是类，所以您可以自由地使用继承、用户定义的方法和其他Python类特性。</p><h1 id="56a8" class="mb mc iu bd md me mf mg mh mi mj mk ml ka mm kb mn kd mo ke mp kg mq kh mr ms bi translated">Python类概述</h1><p id="af47" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">在进入数据类之前，让我们快速回顾一下常规的Python类。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Python类概述:属性和方法</p></figure><p id="eb63" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">一个类就像一个对象构造器，你可以把它看作一个用户定义的创建对象的蓝图。对象是一个类的实例，它有属性和方法，作为一种将数据和功能捆绑在一起的方式。</p><h2 id="ea2e" class="na mc iu bd md nb nc dn mh nd ne dp ml lj nf ng mn ln nh ni mp lr nj nk mr nl bi translated">属性</h2><p id="dada" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">可以被认为是类对象中的变量(属性)。参照上面的例子，一旦<code class="fe lw lx ly lz b">bread</code>对象被实例化，其属性如<code class="fe lw lx ly lz b">name</code>、<code class="fe lw lx ly lz b">units</code>、<code class="fe lw lx ly lz b">price</code>可以通过<code class="fe lw lx ly lz b">bread.name</code>、<code class="fe lw lx ly lz b">bread.price</code>等访问。</p><h2 id="5b14" class="na mc iu bd md nb nc dn mh nd ne dp ml lj nf ng mn ln nh ni mp lr nj nk mr nl bi translated">方法</h2><p id="3531" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">可以看作是生活在一个类中的函数。在上面的例子中，<code class="fe lw lx ly lz b">calc_stock_value()</code>是<code class="fe lw lx ly lz b">Inventory</code>类中的一个方法，可以被实例<code class="fe lw lx ly lz b">bread</code>调用。</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h1 id="b3e4" class="mb mc iu bd md me nt mg mh mi nu mk ml ka nv kb mn kd nw ke mp kg nx kh mr ms bi translated">Python数据类</h1><p id="2f0f" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">数据类与常规类的区别在于，数据类装饰器<code class="fe lw lx ly lz b">@dataclass</code>有助于自动生成和维护一组针对类的特殊方法，从而减少样板代码。这些方法可以大致分为:</p><ol class=""><li id="7f20" class="ny nz iu lc b ld le lg lh lj oa ln ob lr oc lv od oe of og bi translated">初始化方法— <code class="fe lw lx ly lz b">.__init__()</code></li><li id="6e28" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">表示方法— <code class="fe lw lx ly lz b">.__repr__()</code></li><li id="ab73" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">比较法— <code class="fe lw lx ly lz b">.__eq__()</code>、<code class="fe lw lx ly lz b">.__le__()</code>、<code class="fe lw lx ly lz b">.__ge__()</code>等。</li></ol><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">演示如何定义数据类和内置方法</p></figure><p id="56f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意，虽然上面的代码块中没有这些方法，但是初始化、表示和比较部分仍然有效，因为装饰器在后台处理它们。</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h2 id="a887" class="na mc iu bd md nb nc dn mh nd ne dp ml lj nf ng mn ln nh ni mp lr nj nk mr nl bi translated"><strong class="ak">初始化方法</strong></h2><p id="bb22" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated"><code class="fe lw lx ly lz b">__init__</code>方法类似于<code class="fe lw lx ly lz b">C++</code>和Java中的构造函数。它用于初始化对象的状态，并在对象创建时执行。</p><p id="9b14" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们考虑下面一个常规Python类中的<code class="fe lw lx ly lz b">__init__</code>片段:</p><pre class="kk kl km kn gu om lz on oo aw op bi"><span id="b97e" class="na mc iu lz b gz oq or l os ot"># __init__ in regular class<br/>def __init__(self, name):<br/>    self.name = name</span></pre><p id="ee96" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意到单词<code class="fe lw lx ly lz b">name</code>重复了3次，只是为了简单地初始化一个对象。最重要的是，多个<code class="fe lw lx ly lz b">self</code>的存在可能会让不熟悉面向对象编程(OOP)概念的初学者感到困惑。</p><p id="102f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，在数据类中，不需要<code class="fe lw lx ly lz b">__init__</code>方法。借助于<a class="ae kz" href="https://www.python.org/dev/peps/pep-0526/" rel="noopener ugc nofollow" target="_blank">变量注释</a>，您只需要在类定义下面列出您的数据类所需的字段。</p><h2 id="9bcf" class="na mc iu bd md nb nc dn mh nd ne dp ml lj nf ng mn ln nh ni mp lr nj nk mr nl bi translated"><strong class="ak">表示方法</strong></h2><p id="6d61" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">当在没有显式定义<code class="fe lw lx ly lz b">__repr__</code>的情况下打印常规Python类中的对象时，结果不会给出关于实例的任何有用信息。</p><pre class="kk kl km kn gu om lz on oo aw op bi"><span id="78a8" class="na mc iu lz b gz oq or l os ot">bread = Inventory('bread', 10, 2.5)<br/>print(bread)<br/># returns &lt;__main__.Inventory object at 0x7f9fca781700&gt;</span></pre><p id="95dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">__repr__</code>方法在调试时特别有用，因为它提供了一个更具代表性的对象视图。常规类中需要一个自定义的<code class="fe lw lx ly lz b">__repr__</code>方法，如下所示。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在常规Python类中定义__repr__。</p></figure><p id="fe6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">相反，默认情况下，这个方法由数据类装饰器负责。</p><h2 id="a7b3" class="na mc iu bd md nb nc dn mh nd ne dp ml lj nf ng mn ln nh ni mp lr nj nk mr nl bi translated"><strong class="ak">比较方法</strong></h2><p id="2837" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">为了执行基本的对象比较，需要在常规Python类中定义类似<code class="fe lw lx ly lz b">__eq__</code>的比较方法，如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在常规类中定义__eq__并比较类实例</p></figure><p id="1a19" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，数据类装饰器自动管理这一点，不需要方法的显式定义。</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h1 id="2381" class="mb mc iu bd md me nt mg mh mi nu mk ml ka nv kb mn kd nw ke mp kg nx kh mr ms bi translated">Python数据类的两个重要特性</h1><p id="71bf" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">以下概念不是数据类独有的。：</p><ol class=""><li id="6c3c" class="ny nz iu lc b ld le lg lh lj oa ln ob lr oc lv od oe of og bi translated">默认值分配</li><li id="ed56" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv od oe of og bi translated">类型提示</li></ol><p id="e0a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，数据类提供了一种实现它们的简洁方法，并提高了可读性，如下面的代码所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在数据类中定义默认值和类型提示。</p></figure><h2 id="4f47" class="na mc iu bd md nb nc dn mh nd ne dp ml lj nf ng mn ln nh ni mp lr nj nk mr nl bi translated">缺省值</h2><p id="4f75" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">在Python中定义常规类时，默认值赋值和类型提示是在<code class="fe lw lx ly lz b">__init__</code>方法中完成的。我希望你会同意上面的数据类定义比下面的代码块简洁得多。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">在常规Python类中定义默认值和类型提示</p></figure><h2 id="ff68" class="na mc iu bd md nb nc dn mh nd ne dp ml lj nf ng mn ln nh ni mp lr nj nk mr nl bi translated">类型提示</h2><p id="6538" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">在数据类中定义属性(字段)时，类型提示是必需的。如果在字段中不存在，该属性将被忽略，并且不会成为数据类的一部分。</p><p id="7618" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果不想为数据类的字段指定确切的类型，建议使用<code class="fe lw lx ly lz b">Any</code>类型(参见上面数据类示例中的<code class="fe lw lx ly lz b">discount</code>字段)。</p><p id="819c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，这些数据类型在运行时不是强制的。为了捕捉类型错误，鼓励使用像<code class="fe lw lx ly lz b"><a class="ae kz" href="http://mypy-lang.org" rel="noopener ugc nofollow" target="_blank">mypy</a></code>这样的包。</p></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><h1 id="daf1" class="mb mc iu bd md me nt mg mh mi nu mk ml ka nv kb mn kd nw ke mp kg nx kh mr ms bi translated"><strong class="ak">总结</strong></h1><p id="19f3" class="pw-post-body-paragraph la lb iu lc b ld mt jv lf lg mu jy li lj mv ll lm ln mw lp lq lr mx lt lu lv in bi translated">数据类是Python 3.7中引入的新特性。如果您计划创建一个主要由属性组成的类，这很方便，因为它有助于:</p><ul class=""><li id="294b" class="ny nz iu lc b ld le lg lh lj oa ln ob lr oc lv ou oe of og bi translated">自动生成样板代码以获得对象的正确初始化、表示和比较</li><li id="0bc4" class="ny nz iu lc b ld oh lg oi lj oj ln ok lr ol lv ou oe of og bi translated">提高可读性，特别是分配默认值和类型提示</li></ul></div><div class="ab cl nm nn hy no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="in io ip iq ir"><p id="ca1a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您花时间阅读我的文章。如果你喜欢你所读到的，看看下面这个故事:</p><div class="ov ow gq gs ox oy"><a rel="noopener  ugc nofollow" target="_blank" href="/the-walrus-operator-in-python-3-8-a-primer-f0156ad80948"><div class="oz ab fp"><div class="pa ab pb cl cj pc"><h2 class="bd iv gz z fq pd fs ft pe fv fx it bi translated">Python 3.8中的Walrus算子:初级读本</h2><div class="pf l"><h3 class="bd b gz z fq pd fs ft pe fv fx dk translated">知道如何使用它</h3></div><div class="pg l"><p class="bd b dl z fq pd fs ft pe fv fx dk translated">better编程. pub</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kt oy"/></div></div></a></div></div></div>    
</body>
</html>