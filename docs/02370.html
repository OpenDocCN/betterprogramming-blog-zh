<html>
<head>
<title>Turn Your Code Into Poetry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">把你的代码变成诗歌</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/turn-your-code-into-poetry-64b38f1d29a0?source=collection_archive---------26-----------------------#2019-11-25">https://betterprogramming.pub/turn-your-code-into-poetry-64b38f1d29a0?source=collection_archive---------26-----------------------#2019-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d99" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用函数式编程提高代码的可读性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c3a7e1e831275ca402954ad2c11ef1db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQTzR4tH4AuGPDKW1rPbTQ.png"/></div></div></figure><h1 id="d960" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="8bce" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">他们说好的代码就像一本书:它可以像英语一样被阅读。那么，你对下面的代码片段有什么看法？</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c27d" class="mn kv it mj b gy mo mp l mq mr">let array = Array(1...100)<br/>array.filter { $0 % 2 == 0}</span></pre><p id="c95e" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这段代码过滤偶数。我确信你以前必须处理过滤一个元素数组。上面的片段是可以理解的，但是如果我们想要扩展它并添加更多的条件呢？</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="d13b" class="mn kv it mj b gy mo mp l mq mr">let array = Array(1...100)<br/>array.filter { $0 % 2 == 0 &amp;&amp; $0 &lt; 40 &amp;&amp; $0 &gt; 10}</span></pre><p id="b7d9" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">现在事情开始变得有点混乱。我们总是可以这样做:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="33e2" class="mn kv it mj b gy mo mp l mq mr">let array = Array(1...100)<br/>array.filter { $0 % 2 == 0 }<br/>    .filter { $0 &lt; 40 }<br/>    .filter{ $0 &gt; 10}</span></pre><p id="8d87" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这个看起来好一点。尽管如此，如果我们看一下<em class="mx">操场</em>中的迭代次数，您可以看到一些元素被迭代了三次:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/e3c4515eeadf7ba95622f5e8e2425025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHyLk8d-rQ933xJxPGCwnw.png"/></div></div><p class="mz na gj gh gi nb nc bd b be z dk translated">在Xcode操场上运行代码</p></figure><p id="a198" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这是因为数组中的元素在第一个<code class="fe nd ne nf mj b">filter</code>中迭代一次。对于第二个<code class="fe nd ne nf mj b">filter</code>，匹配条件的那些被第二次迭代，以此类推。在这个例子中，这可能看起来不相关，但是在一些场景中，我们可能会迭代数千个元素。在这种情况下，我们可能会危及代码性能。有没有一种方法可以在不影响性能的情况下提高代码的可读性？</p><p id="48fb" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">在接下来的几节中，我们将展示一个案例研究，看看如何实现一个易于阅读和使用的通用解决方案。</p><p id="8dfb" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated"><em class="mx">目标是达到这样的详细程度，即代码可以作为纯英语阅读。也就是说，即使一个没有编码知识的人也能阅读和理解正在发生的事情。</em></p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c0f5" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">个案研究</h1><p id="76e6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">想象我们正在构建一个人分类器。我们可以用一个<em class="mx">结构</em> <code class="fe nd ne nf mj b">Person</code>来建模我们的个体，就像这样:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="db3a" class="mn kv it mj b gy mo mp l mq mr">enum EyeColor {<br/>    case dark, blue, green, brown<br/>}</span><span id="386a" class="mn kv it mj b gy ns mp l mq mr">enum HairColor {<br/>    case brunette, blonde, ginger, dark<br/>}</span><span id="2c09" class="mn kv it mj b gy ns mp l mq mr">struct Person {<br/>    var name: String<br/>    var eyesColor: EyeColor<br/>    var hairColor: HairColor<br/>}</span></pre><p id="1e51" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这是一个人的简单定义，但它提供了许多不同的分类方法。假设我们想过滤绿眼睛金发的人和蓝眼睛姜黄色头发的人。我们最终会做这样的事情:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="1344" class="mn kv it mj b gy mo mp l mq mr">let people = [ ... ] <br/>let subset = people.filter { ($0.eyesColor == .green &amp;&amp; $0.hairColor == .blonde) || ($0.eyesColor == .blue &amp;&amp; $0.hairColor == .ginger) }</span></pre><p id="d96e" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这似乎难以辨认和维护，你不觉得吗？我们的目标是重构这个片段。我们能修理它吗？</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="fab3" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">过滤器</h1><p id="f9e4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">让我们从将条件块包装到一个对象中开始:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="1ccd" class="mn kv it mj b gy mo mp l mq mr">struct Filter&lt;Element&gt; {<br/>    typealias Condition = (Element) -&gt; Bool<br/>    var condition: Condition<br/>}</span></pre><p id="6059" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">就这么简单。一个<code class="fe nd ne nf mj b">Filter</code>是一个<em class="mx">结构</em>，它保存了一个通用元素的条件。您可能想知道，将块包装成数据结构比使用<code class="fe nd ne nf mj b">typealias</code>有什么好处？我们将在下一节看一看，但是包装器将允许我们操作条件。此外，<code class="fe nd ne nf mj b">typealias</code>不让我们使用泛型类型。</p><p id="59c3" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">现在我们可以扩展<code class="fe nd ne nf mj b">Array</code>来利用<code class="fe nd ne nf mj b">Filter</code>:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="092b" class="mn kv it mj b gy mo mp l mq mr">extension Array {<br/>    func filtering(_ filter: Filter&lt;Element&gt;) -&gt; Array {<br/>        self.filter(filter.condition)<br/>    }<br/>}</span></pre><p id="762e" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这已经足够好了。尽管如此，同时拥有匹配和非匹配元素还是很有意思的。让我们定义一个返回两个输出的<code class="fe nd ne nf mj b">Filter.Result</code>:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="195d" class="mn kv it mj b gy mo mp l mq mr">extension Filter {<br/>    <br/>    struct Result {<br/>        private var matchingBlock: () -&gt; Array&lt;Element&gt;<br/>        private var restBlock: () -&gt; Array&lt;Element&gt;<br/>        <br/>        var matching: Array&lt;Element&gt; { matchingBlock() }<br/>        var rest: Array&lt;Element&gt; { restBlock() }<br/>        <br/>        init(matching: @escaping @autoclosure () -&gt; Array&lt;Element&gt;,<br/>             rest: @escaping @autoclosure () -&gt; Array&lt;Element&gt;) {<br/>            self.matchingBlock = matching<br/>            self.restBlock = rest<br/>        }<br/>    }<br/>    <br/>}</span></pre><p id="d629" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">我们将元素包装在一个闭包中，这样直到需要时才触发实际的过滤(也就是直到我们调用<code class="fe nd ne nf mj b">matching</code>或<code class="fe nd ne nf mj b">rest</code>)。继续修改<code class="fe nd ne nf mj b">Array</code>扩展，改为使用<code class="fe nd ne nf mj b">Filter.Result</code>:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c1d6" class="mn kv it mj b gy mo mp l mq mr">extension Array {<br/>    func filtering(_ filter: Filter&lt;Element&gt;) -&gt; Filter&lt;Element&gt;.Result {<br/>        Filter.Result(matching: self.filter(filter.condition),<br/>                     rest: self.filter((!filter).condition))<br/>    }<br/>}</span></pre><p id="f28a" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">现在我们可以重写这个:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="ca28" class="mn kv it mj b gy mo mp l mq mr">let subset = people.filter { $0.eyesColor == .blue }</span></pre><p id="2df0" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">变成这样:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="4297" class="mn kv it mj b gy mo mp l mq mr">let hasBlueEyes = Filter&lt;Person&gt; { $0.eyesColor == .blue }<br/>let subset = people.filtering(hasBlueEyes).matching</span></pre><p id="5c33" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">太好了！我们写了一段更易读的代码。如果我们现在想添加一个新的条件呢？</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="866f" class="mn kv it mj b gy mo mp l mq mr">let hasBlondeHair = Filter&lt;Person&gt; { $0.hairColor == .blonde }<br/>let hasBlueEyes = Filter&lt;Person&gt; { $0.eyesColor == .blue }</span><span id="95ed" class="mn kv it mj b gy ns mp l mq mr">let subset = people.filtering(hasBlueEyes).mathing<br/>    .filter(hasBlondeHair).matching</span></pre><p id="fb2a" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">我们在性能问题上又落后了。目前，我们没有办法和<code class="fe nd ne nf mj b">Filter</code>合作。我们将在下一节中解决这个问题。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="13ec" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">添加详细程度</h1><p id="4c54" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">上一节我们得出了<code class="fe nd ne nf mj b">Filter</code>缺乏赘言的结论。目前我们无法合并过滤器，让我们来解决这个问题。</p><p id="4c67" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">扩展<code class="fe nd ne nf mj b">Filter</code>增加一些基本操作:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="d0df" class="mn kv it mj b gy mo mp l mq mr">var inverted: Self {<br/>    .init { !self.condition($0) }<br/>}</span><span id="72c2" class="mn kv it mj b gy ns mp l mq mr">func and(_ filter: Self) -&gt; Self {<br/>    .init { filter.condition($0) &amp;&amp; self.condition($0) }<br/>}</span><span id="3431" class="mn kv it mj b gy ns mp l mq mr">func or(_ filter: Self) -&gt; Self {<br/>    .init { filter.condition($0) || self.condition($0) }<br/>}</span></pre><p id="115e" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">干得好！通过这样做，我们可以重写最后一段代码:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c055" class="mn kv it mj b gy mo mp l mq mr">let subset = people.filter(hasBlueEyes.and(hasBlondeHair).matching</span></pre><p id="49a5" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">哇！这看起来是一个巨大的进步。我们不仅提高了可读性，而且提高了性能，因为元素只迭代一次。干得好！</p><p id="f3fc" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">为了增加更多的冗长性，让它看起来像我们简单地用布尔运算，让我们添加一些自定义操作符<code class="fe nd ne nf mj b">&amp;</code>、<code class="fe nd ne nf mj b">|</code>和<code class="fe nd ne nf mj b">!</code>以及帮助函数和变量，让我们组合一组过滤器:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="3b8c" class="mn kv it mj b gy mo mp l mq mr">struct Filter&lt;Element&gt; {<br/>    typealias Condition = (Element) -&gt; Bool<br/>    var condition: Condition<br/>}<br/><br/>extension Filter {<br/>    <br/>    static var all: Self {<br/>        .init { _ in true }<br/>    }<br/>    <br/>    static var none: Self {<br/>        .init { _ in false }<br/>    }<br/>    <br/>    var inverted: Self {<br/>        .init { !self.condition($0) }<br/>    }<br/>    <br/>    func and(_ filter: Self) -&gt; Self {<br/>        .init { filter.condition($0) &amp;&amp; self.condition($0) }<br/>    }<br/><br/>    func or(_ filter: Self) -&gt; Self {<br/>        .init { filter.condition($0) || self.condition($0) }<br/>    }<br/>    <br/>    static prefix func ! (_ filter: Self) -&gt; Self {<br/>        filter.inverted<br/>    }<br/>    <br/>    static func &amp; (_ lhs: Self, _ rhs: Self) -&gt; Self {<br/>        lhs.and(rhs)<br/>    }<br/>    <br/>    static func | (_ lhs: Self, _ rhs: Self) -&gt; Self {<br/>        lhs.or(rhs)<br/>    }<br/><br/>    static func any(of filters: Self...) -&gt; Self {<br/>        Self.any(of: filters)<br/>    }<br/>    <br/>    static func any(of filters: [Self]) -&gt; Self {<br/>        filters.reduce(.none, |)<br/>    }<br/><br/>    static func not(_ filters: Self...) -&gt; Self {<br/>        Self.combine(filters.map { !$0 })<br/>    }<br/>    <br/>    static func combine(_ filters: [Self]) -&gt; Self {<br/>        filters.reduce(.all, &amp;)<br/>    }<br/><br/>    static func combine(_ filters: Self...) -&gt; Self {<br/>        Self.combine(filters)<br/>    }<br/>    <br/>}</span></pre><p id="b710" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这些最后的变化将有助于我们轻松地组合过滤器。让我们试一试:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="8b61" class="mn kv it mj b gy mo mp l mq mr">let hasBlondeHair = Filter&lt;Person&gt; { $0.hairColor == .blonde }<br/>let hasBlueEyes = Filter&lt;Person&gt; { $0.eyesColor == .blue }</span><span id="2a28" class="mn kv it mj b gy ns mp l mq mr">let result1 = people.filtering(!hasBlueEyes)<br/>let result2 = people.filtering(hasBlueEyes &amp; hasBlondeHair)<br/>let result3 = people.filtering(hasBlueEyes | !hasBlondeHair)</span></pre><p id="b681" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这简单多了，而且只有一次迭代，我们还能要求更多吗？</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="fc39" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">决赛成绩</h1><p id="ba24" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这一点上，你有了所有你需要的工具，把那些不可维护的无意义的代码变成诗歌。想看看怎么样吗？让我们回到我们的案例研究。</p><p id="3fe9" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">这些是我们可能想要在<code class="fe nd ne nf mj b">Person</code>中重用的一些过滤器。我们可以扩展<code class="fe nd ne nf mj b">Filter</code>并添加一些最常见的:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="741c" class="mn kv it mj b gy mo mp l mq mr">extension Filter where Element == Person {<br/>    static let brownEyes = Filter { $0.eyesColor == .brown }<br/>    static let blueEyes = Filter { $0.eyesColor == .blue }<br/>    static let darkEyes = Filter { $0.eyesColor == .dark }<br/>    static let greenEyes = Filter { $0.eyesColor == .green }<br/><br/>    static let brunette = Filter { $0.hairColor == .brunette }<br/>    static let blonde = Filter { $0.hairColor == .blonde }<br/>    static let ginger = Filter { $0.hairColor == .ginger }<br/>    static let darkHair = Filter { $0.hairColor == .dark }<br/><br/>    static func name(startingWith letter: String) -&gt; Filter {<br/>        Filter { $0.name.starts(with: letter) }<br/>    }<br/>}</span></pre><p id="b855" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">现在，在本文的开始，我们的目标是重构这段代码:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="67d5" class="mn kv it mj b gy mo mp l mq mr">let subset = people.filter { ($0.eyesColor == .green &amp;&amp; $0.hairColor == .blonde) || ($0.eyesColor == .blue &amp;&amp; $0.hairColor == .ginger) }</span></pre><p id="e1d8" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">通过使用<code class="fe nd ne nf mj b">Filter</code>，我们可以将前面的代码片段重写为:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="9906" class="mn kv it mj b gy mo mp l mq mr">let subset = people.filtering(Filter.greenEyes.and(.blonde)<br/>    .or(Filter.ginger.and(.blueEyes))).matching</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/c3f85d220ca75c212f014bd3c4fde0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hj4z9OLryO62_1l72AFzZA.jpeg"/></div></div></figure><p id="7839" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">哇！有那么一瞬间，我以为我在读莎士比亚，而不是代码！更清晰了，不是吗？</p><p id="8ace" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">尝试编写一些复杂的人员过滤器:</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="cace" class="mn kv it mj b gy mo mp l mq mr">let people = [<br/>    Person(name: "Eliott", eyesColor: .brown, hairColor: .blonde),<br/>    Person(name: "Eoin", eyesColor: .brown, hairColor: .brunette),<br/>    Person(name: "Michelle", eyesColor: .brown, hairColor: .brunette),<br/>    Person(name: "Kevin", eyesColor: .blue, hairColor: .brunette),<br/>    Person(name: "Jessica", eyesColor: .green, hairColor: .brunette),<br/>    Person(name: "Thomas", eyesColor: .dark, hairColor: .dark),<br/>    Person(name: "Oliver", eyesColor: .dark, hairColor: .blonde),<br/>    Person(name: "Jane", eyesColor: .blue, hairColor: .ginger),<br/>    Person(name: "Justine", eyesColor: .brown, hairColor: .dark),<br/>    Person(name: "Joseph", eyesColor: .brown, hairColor: .brunette),<br/>    Person(name: "Michael", eyesColor: .blue, hairColor: .dark)<br/>]<br/><br/>people.filtering(.combine(.name(startingWith: "E"), .brownEyes, .blonde)).matching      // Eliott<br/>people.filtering(.any(of: .ginger, .blonde, .greenEyes)).matching       // Eliott, Jessica, Oliver, Jane<br/>people.filtering(Filter.not(.name(startingWith: "J"), .brownEyes).and(.brunette)).matching      // Kevin<br/>people.filtering(Filter.greenEyes.and(.blonde).or(Filter.ginger.and(.blueEyes))).matching       // Jane</span></pre><p id="c280" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">或者甚至重用<code class="fe nd ne nf mj b">Filter</code>过滤……狗？</p><pre class="kj kk kl km gt mi mj mk ml aw mm bi"><span id="c697" class="mn kv it mj b gy mo mp l mq mr">enum DogBreed {<br/>    case pug<br/>    case husky<br/>    case boxer<br/>    case bulldog<br/>    case chowChow<br/>}<br/><br/>struct Dog {<br/>    var name: String<br/>    var breed: DogBreed<br/>}<br/><br/>let dog = [<br/>    Dog(name: "Rudolph", breed: .husky),<br/>    Dog(name: "Hugo", breed: .boxer),<br/>    Dog(name: "Trinity", breed: .pug),<br/>    Dog(name: "Neo", breed: .pug),<br/>    Dog(name: "Sammuel", breed: .chowChow),<br/>    Dog(name: "Princess", breed: .bulldog)<br/>]<br/><br/>extension Filter where Element == Dog {<br/>    static let pug = Filter { $0.breed == .pug }<br/>    static let husky = Filter { $0.breed == .husky }<br/>    static let boxer = Filter { $0.breed == .boxer }<br/>    static let bulldog = Filter { $0.breed == .bulldog }<br/>    static let chowChow = Filter { $0.breed == .chowChow }<br/>}<br/><br/>dog.filtering(.boxer).matching                          // Hugo<br/>dog.filtering(.not(.husky, .chowChow)).rest             // Rudolph, Sammuel<br/>dog.filtering(Filter.boxer.or(.chowChow)).matching      // Hugo, Sammuel</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="25e8" class="ku kv it bd kw kx nn kz la lb no ld le jz np ka lg kc nq kd li kf nr kg lk ll bi translated">结论</h1><p id="e83e" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在开发代码时，尽量使它可读、可维护、易于扩展。你的代码应该读起来像一个普通的英语句子——这就是坏代码、好代码和更好代码之间的区别。</p><p id="7c42" class="pw-post-body-paragraph lm ln it lo b lp ms ju lr ls mt jx lu lv mu lx ly lz mv mb mc md mw mf mg mh im bi translated">总而言之，我们从一段难以理解且不太可扩展的代码开始。我们利用<em class="mx">泛型</em>和无状态<em class="mx">结构</em> <code class="fe nd ne nf mj b">Filter</code>来提高易读性，而不牺牲性能。我们给<code class="fe nd ne nf mj b">Filter</code>增加了冗长性，以获得更好的可读性。最后，我们将一些常见的过滤器提取到一个扩展中，并使它们可重用。</p></div></div>    
</body>
</html>