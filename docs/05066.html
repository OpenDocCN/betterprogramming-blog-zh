<html>
<head>
<title>How to Write a Concurrent FTP Server in Go (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中编写并发FTP服务器(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-concurrent-ftp-server-in-go-part-1-3904f2e3a9e5?source=collection_archive---------4-----------------------#2020-06-04">https://betterprogramming.pub/how-to-write-a-concurrent-ftp-server-in-go-part-1-3904f2e3a9e5?source=collection_archive---------4-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e4e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为多个客户服务，了解FTP规范</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f6166062bc8190ab699645da662bed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HcTbalS2ivoWiCNpnSsRWg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@abrkett?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚当·伯基特</a>在<a class="ae ky" href="https://unsplash.com/s/photos/files?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="0542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在研究Go圣经——多诺万和克尼根的“Go编程语言”<em class="lv"/>——时，我遇到了一个让我既受启发又感到沮丧的问题。</p><blockquote class="lw lx ly"><p id="b8b0" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu">练习8.2 </strong>:实现一个并发文件传输协议(FTP)服务器。服务器应该解释来自每个客户端的命令，例如<strong class="lb iu"> cd </strong>改变目录，<strong class="lb iu"> ls </strong>列出目录，<strong class="lb iu"> get </strong>发送文件内容，<strong class="lb iu"> close </strong>关闭连接。</p></blockquote><p id="669f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是让我兴奋的大型自由项目。做这件事没有“正确的方法”,你只是面临着用你所拥有的知识来构建最佳解决方案的挑战。</p><p id="9e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这里的复杂性与你知道多少Go无关——它来自FTP本身。它非常规范(毕竟这是一个网络协议)。除非你已经知道FTP的来龙去脉——它的标准响应代码和何时使用它们，如何配置数据连接，甚至如何终止文本行——这个挑战会让你血压升高。</p><p id="7613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">遵循这个一步一步的指南来构建一个简单的FTP服务器，避免给自己造成动脉瘤。感谢Github用户Kdama给我指明了正确的方向。</p><p id="7d34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我假设对Go的<code class="fe mc md me mf b">net</code>包和goroutines有基本的了解，但是没有比这更难的了。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="87b4" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">倾听并服务</h1><p id="5105" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">FTP服务器的本质很简单:监听传入的连接，解析它们的请求，并做出适当的响应。</p><p id="09a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">监听部分与您可能编写的其他web服务器没有什么不同，除了我们将使用更简单的<code class="fe mc md me mf b">net</code>包来代替<code class="fe mc md me mf b">net/http</code>。这是FTP服务器，不是HTTP服务器。</p><p id="2a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从<code class="fe mc md me mf b">main.go</code>开始，从那里开始构建。我会把我们工作中最重要的代码片段包括进来，但是对于完整的代码，包括导入，你可以访问这个回购。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/119c327784c5595ef935fb81b72cc54d.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*RA_GnCrhMmkHLELGICzxDA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的项目结构</p></figure><p id="76db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让服务器管理员使用命令行标志指定一个可选的监听端口和服务器公共文件的根文件夹。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5e46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们的<code class="fe mc md me mf b">main</code>函数将监听我们选择的端口(或者默认的8080)并接受所有传入的连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">net.Listen</code>对你来说可能是新的，但它和<code class="fe mc md me mf b">Accept</code>一起，扮演着与<code class="fe mc md me mf b">http.ListenAndServe</code>相似的角色。您指定要使用的协议(TCP)和地址，在我们的例子中是<code class="fe mc md me mf b">localhost:port</code>，可以简化为<code class="fe mc md me mf b">:port</code>。</p><p id="dd6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于每个传入的连接，我们用<code class="fe mc md me mf b">Accept</code>生成一个指向<code class="fe mc md me mf b">net.TCPConn</code>(满足<code class="fe mc md me mf b">net.Conn</code>接口)的指针。由于所有的<code class="fe mc md me mf b">net.Conn</code>也满足<code class="fe mc md me mf b">io.ReadWriteCloser</code>接口，我们可以从一个方便的对象中读取请求，编写响应，并在完成后自然地关闭连接。</p><p id="5fd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着<code class="fe mc md me mf b">go handleConn(conn)</code>的出现，事情开始变得有趣起来。关键字<code class="fe mc md me mf b">go</code>使我们的FTP服务器成为了<em class="lv">并发</em> FTP服务器。每一个连接都将在它自己的goroutine中被处理，因此客户不必排队等候使用服务器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4c5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mc md me mf b">handleConn</code>中，我们使用<code class="fe mc md me mf b">defer</code>确保连接在<code class="fe mc md me mf b">ftp.Serve</code>返回时关闭，更重要的是，使用<code class="fe mc md me mf b">ftp.NewConn</code>从原来的<code class="fe mc md me mf b">net.Conn</code>生成一个新的结构。<code class="fe mc md me mf b">ftp</code>是我们将要编写的包，而<code class="fe mc md me mf b">ftp.Conn</code>是一个优雅的对象，它使得许多可能的FTP操作可以从一个接触点实现。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="6636" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">ftp。指挥操舵</h1><p id="7678" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在<code class="fe mc md me mf b">./ftp</code>中发生了很多事情，但是这些都是具有不同角色的小文件，我们将一个一个地介绍它们。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5b7c3d86086f5233c02c648ce3a8ea48.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*q0ptk2W4M4_1llK7iH29_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在里面。/ftp</p></figure><p id="eead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">先说<code class="fe mc md me mf b">conn.go</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7c19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ftp.Conn</code>是我们专门构建的FTP服务器连接表示。请注意，它包装了原始的<code class="fe mc md me mf b">net.Conn</code>，它将为我们完成与客户端的所有直接通信。</p><p id="8f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还包含我们为服务器指定的<code class="fe mc md me mf b">rootDir</code>(公共文件将存放的地方)，以及连接的当前工作目录<code class="fe mc md me mf b">workDir</code>。举例来说，这不能在服务器级别使用像<code class="fe mc md me mf b">os.Chdir</code>这样的功能来控制。如果是这样的话，每当任何一个goroutine更改目录时，每个客户端连接都会受到影响。相反，我们手动跟踪每个连接的工作目录。</p><p id="cc70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">NewConn</code>简单地返回一个指向新的<code class="fe mc md me mf b">ftp.Conn</code>的指针，初始化为默认状态。神秘的<code class="fe mc md me mf b">dataType</code>和<code class="fe mc md me mf b">dataPort</code>字段被自动设置为零值，分别为<code class="fe mc md me mf b">0</code>和<code class="fe mc md me mf b">nil</code>，但是当需要传输数据时，我们会回到它们。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="5e27" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">ftp。服务</h1><p id="d655" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在<code class="fe mc md me mf b">main.go</code>中，我们调用了<code class="fe mc md me mf b">ftp.Serve</code>，将我们的新<code class="fe mc md me mf b">ftp.Conn</code>作为参数传入。<code class="fe mc md me mf b">ftp.Serve</code>是我们应用程序的路由器。它负责检查传入的命令，并将它们与服务器实现的FTP例程进行匹配。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9ace" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入<code class="fe mc md me mf b">Serve</code>后，我们做的第一件事是向客户机发出220响应，让它知道连接已经成功建立，服务器已经准备好接受用户。稍后将详细介绍<code class="fe mc md me mf b">respond</code>和FTP状态代码。</p><p id="f9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了监听传入的命令，我们针对<code class="fe mc md me mf b">ftp.Conn</code>的底层<code class="fe mc md me mf b">net.Conn</code>创建了一个新的<code class="fe mc md me mf b">bufio.Scanner</code>。该循环是无限的，因此<code class="fe mc md me mf b">Serve</code>将继续检查命令，直到某个事件(如<code class="fe mc md me mf b">QUIT</code>命令)导致其返回，这又导致<code class="fe mc md me mf b">main.handleConn</code>返回，关闭我们<code class="fe mc md me mf b">defer</code> ed的<code class="fe mc md me mf b">net.Conn</code>。一旦<code class="fe mc md me mf b">handleConn</code>返回，goroutine就结束了。</p><p id="e779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余的<code class="fe mc md me mf b">ftp.Serve</code>并不比客户端请求的第一个单词<code class="fe mc md me mf b">command</code>上的<code class="fe mc md me mf b">switch</code>更复杂。然而，令人困惑的是，FTP要求的命令名并不总是与您在客户端输入的触发命令相匹配。<code class="fe mc md me mf b">cd</code>在客户端被作为<code class="fe mc md me mf b">CWD</code>发送到服务器。<code class="fe mc md me mf b">ls</code>是<code class="fe mc md me mf b">LIST</code> , <code class="fe mc md me mf b">close</code>是<code class="fe mc md me mf b">QUIT</code>,<code class="fe mc md me mf b">get</code>翻译成<code class="fe mc md me mf b">RETR</code>。</p><p id="888b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，客户端在没有用户直接干预的情况下发送某些命令。例如，在每个<code class="fe mc md me mf b">get/RETR</code>请求之前，秘密发送一个<code class="fe mc md me mf b">PORT</code>命令。</p><p id="2e5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调试FTP服务器时保持理智的诀窍是正确的日志记录。您希望您的服务器尽可能地表达它所接收的请求以及它如何响应。这样，您可以确切地看到客户端发送的内容，如果它与您的预期不符，就相应地调整您的代码。</p><p id="47e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于传入的请求，请看上面的第11–12行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个简单的加法将每个请求格式化成这样，清楚地显示接收到的命令及其参数:</p><p id="2579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">2020/05/28 08:13:58 &lt;&lt; PORT [127,0,0,1,245,1]</code></p><p id="cc26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记录响应同样简单明了，所以让我们借此机会把<code class="fe mc md me mf b">respond</code>作为一个整体来看。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="55a4" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">作出反应</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">准确的状态代码对FTP服务器至关重要。客户端检查每个响应中的三位数状态代码，并根据所发现的内容进行操作。代码后面的可读解释是可选的，但是为了清晰起见，使用标准描述是一个好习惯。将您使用的每个状态放入一个<code class="fe mc md me mf b">const</code>中，以尽量减少重复。</p><p id="3dea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们用方法<code class="fe mc md me mf b">respond</code>扩展<code class="fe mc md me mf b">ftp.Conn</code>。<code class="fe mc md me mf b">respond</code>获取一个字符串，记录下来，然后复制到它的底层<code class="fe mc md me mf b">net.Conn</code>，后者负责将数据发送到客户端。这里唯一需要注意的是对<code class="fe mc md me mf b">c.EOL</code>的调用，它解决了FTP标准的一个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="3775" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据传输的数据类型，FTP要求不同的线路终止符。ASCII数据必须以回车符<code class="fe mc md me mf b">\r</code>和换行符<code class="fe mc md me mf b">\n</code>结束。二进制数据，被FTP规范称为“图像”，但实际上并不局限于图像，只以<code class="fe mc md me mf b">\n</code>结尾。</p><p id="8b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不遵守这个约定，您将会看到来自FTP客户端的警告、编码不正确的文件，或者两者都有。</p><p id="efd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">ftp.EOL</code>是<code class="fe mc md me mf b">ftp.Conn</code>的<code class="fe mc md me mf b">dataType</code>上的一个简单开关。但是<code class="fe mc md me mf b">dataType</code>从何而来？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ccac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b">dataType</code>只是一个整数的包装器，我们使用Go的<code class="fe mc md me mf b">iota</code>关键字来设置<code class="fe mc md me mf b">dataType</code>常量<code class="fe mc md me mf b">ascii = 0</code>、<code class="fe mc md me mf b">binary = 1</code>。</p><p id="727d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Go变量总是被初始化为它们的零值，所以我们创建的每一个新的<code class="fe mc md me mf b">ftp.Conn</code>都以<code class="fe mc md me mf b">dataType = 0</code>、<code class="fe mc md me mf b">ascii</code>开始，如果需要，我们为客户端提供一个函数来改变它。</p><p id="a67a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">FTP客户端各不相同，但是包含在<a class="ae ky" href="https://www.gnu.org/software/inetutils/" rel="noopener ugc nofollow" target="_blank"> GNU Inetutils </a>中的典型示例通过向服务器发送<code class="fe mc md me mf b">TYPE A</code>或<code class="fe mc md me mf b">TYPE I</code>来响应命令<code class="fe mc md me mf b">ascii</code>和<code class="fe mc md me mf b">image</code>，通知服务器它期望接收的数据类型。在<code class="fe mc md me mf b">ftp.Serve</code>中，当<code class="fe mc md me mf b">TYPE</code>命令被识别时，其参数被传递给上面的<code class="fe mc md me mf b">setDataType</code>，并且连接的<code class="fe mc md me mf b">dataType</code>被更新。</p><p id="f6fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些场景中，或者根据您使用的客户端，您可能会看到不止一个参数作为<code class="fe mc md me mf b">TYPE</code>命令的一部分被发送到服务器，但是对于这个基本实现，<code class="fe mc md me mf b">A</code>和<code class="fe mc md me mf b">I</code>将完成这项工作。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="a01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第1部分中，我们看到了如何并发地为多个客户机服务，如何构建一个能够表示FTP连接的结构，如何将命令从客户机路由到正确的处理程序，以及如何发送带有正确的数据类型行终止符的简单响应。</p><p id="0f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2部分中，您将学习如何注册用户、在文件服务器上的目录间导航、列出目录中的文件，当然还有下载它们。</p></div></div>    
</body>
</html>