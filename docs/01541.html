<html>
<head>
<title>Is Node.js Really Single-Threaded?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js真的是单线程吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/is-node-js-really-single-threaded-7ea59bcc8d64?source=collection_archive---------0-----------------------#2019-09-23">https://betterprogramming.pub/is-node-js-really-single-threaded-7ea59bcc8d64?source=collection_archive---------0-----------------------#2019-09-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a2d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于多线程、多处理、线程、进程、线程池等的教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/19f65a3cba809c095836bdee562f8897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*evsXM7DPIKpcV94TZdoTYw.jpeg"/></div></div></figure><p id="5ee1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你是Node.js的新手，你想了解Node.js是如何工作的，那么请阅读这篇文章。</p><p id="49f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每篇Node.js文章都介绍Node.js是单线程的。以下是关于Node.js中多线程的一些误解。</p><ol class=""><li id="ce99" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp lw lx ly lz bi translated">就像JavaScript一样，Node.js也不支持多线程。</li><li id="4af0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">和Java一样，Node.js是一种真正的多线程语言。</li><li id="a0f0" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp lw lx ly lz bi translated">Node.js中有两个线程，一个专门负责事件循环，另一个负责程序的执行。</li></ol><p id="350b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好吧，放松，这些只是假设，实际上可以被称为误解。</p><p id="a7da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们大多数人，在生活中的某个时候，会对多线程和多处理、线程和进程、线程池以及操作系统如何做到这一点感到困惑。</p><p id="f1b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">先把基础的说清楚。</p><h2 id="b3e4" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">流程</strong></h2><p id="d413" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">进程是正在执行的程序，即正在运行的程序，并且是在程序开始执行时创建的。一个进程可以有多个线程。</p><h2 id="a3ba" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">螺纹</strong></h2><p id="2f63" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">一个<em class="nd">线程</em>是可由一个<a class="ae lq" href="https://en.wikipedia.org/wiki/Scheduling_(computing)" rel="noopener ugc nofollow" target="_blank">调度器</a>独立管理的最小程序指令序列，调度器通常是<a class="ae lq" href="https://en.wikipedia.org/wiki/Operating_system" rel="noopener ugc nofollow" target="_blank">操作系统</a>的一部分。</p><p id="251f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">主要区别在于，同一个进程中的线程运行在共享的内存空间中，而进程运行在不同的内存空间中。</p><h2 id="458f" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">多重处理</strong></h2><p id="4183" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">多重处理是在一个计算机系统中使用两个或多个CPU(处理器)。现在，因为有多个处理器可用，所以可以同时执行多个进程。</p><h2 id="23e7" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">多线程</strong></h2><p id="1506" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">多线程是一种执行模型，允许单个进程在该进程的“上下文”中同时运行多个代码块(线程)。</p><h2 id="9bb5" class="mf mg it bd mh mi mj dn mk ml mm dp mn ld mo mp mq lh mr ms mt ll mu mv mw mx bi translated"><strong class="ak">线程池</strong></h2><p id="4db9" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">一个<strong class="kw iu"> </strong> <a class="ae lq" href="https://en.wikipedia.org/wiki/Thread_pool" rel="noopener ugc nofollow" target="_blank">线程池</a> <strong class="kw iu"> </strong>是一组预实例化的空闲线程，它们准备好被分配工作。通过维护线程池，该模型提高了性能，并避免了由于短期任务频繁创建和销毁线程而导致的执行延迟。</p><p id="009b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要写更详细的文章来深入解释上述概念，但我们不要偏离我们的议程。</p><p id="1d2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Node.js应用程序在单线程上运行，事件循环也在同一线程上运行。因此，我们可以说Node.js是单线程的，但问题是Node.js中有一些库不是单线程的。</p><p id="3aef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们借助一个例子来理解这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="ce1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我导入了节点的加密模块，并调用了它的<code class="fe ng nh ni nj b">pbkdf2</code>函数四次<strong class="kw iu"> </strong>，显示了返回的回调所用的时间。</p><p id="da64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好奇看输出？让我们执行这个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/39a14b2f16b83b92d1e9e94bef2511bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*GOXPsN29oco0TCgncXFVkg.png"/></div></figure><p id="fe3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您看到输出，四个<code class="fe ng nh ni nj b">logHashTime()</code>函数几乎用了相同的时间来执行。让我们来理解为什么它们都需要相似的时间来执行。</p><p id="de97" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Node.js内部使用<a class="ae lq" href="https://github.com/libuv/libuv" rel="noopener ugc nofollow" target="_blank"> libuv </a>库，该库负责处理与操作系统相关的任务，如基于异步I/O的操作系统、网络、并发等。</p><p id="58ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想详细了解libuv的工作原理，那么可以参考这篇文章。</p><p id="f63f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Libuv设置了一个由四个线程组成的<a class="ae lq" href="https://en.wikipedia.org/wiki/Thread_pool" rel="noopener ugc nofollow" target="_blank">线程池</a>，通过利用所有CPU内核的能力来执行与操作系统相关的操作。假设我们的机器有四个内核，池中的每个线程都被分配给每个内核。</p><p id="734c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这导致每个内核只有一个线程。在这种设置下，所有四个线程将在每个内核中并行执行<code class="fe ng nh ni nj b">logHashTime()</code>，这使得所有四个函数花费的时间相似。</p><p id="c578" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们想象一下<code class="fe ng nh ni nj b">logHashTime()</code>的执行过程:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/8d9750360cd509386ba4f1821cdc3369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*jIoB-PFiND_6pXExZqAUxg.png"/></div></figure><p id="e02b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果这不是Node.js，它应该是这样执行的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9b008f6146bb736e41c00f9aa454657a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*kvHH21BbsH9J_NAatr6_IA.png"/></div></figure><p id="acaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从更高的层面来看看所有这些是如何协同工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/fe7789c080f2f8d12acef755569246f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*OWlBzRwRk3lC_ikVErv4cw.png"/></div></figure><p id="a1c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了上面的概念，肯定会出现很多假设。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="c675" class="nu mg it bd mh nv nw nx mk ny nz oa mn jz ob ka mq kc oc kd mt kf od kg mw oe bi translated">如果我有两个内核和多个操作要执行，该怎么办？</h1><p id="145e" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">目前，我的机器有四个内核，让我们修改前面的例子，调用<code class="fe ng nh ni nj b">logHashTime()</code>五次。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2c71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/42d7350f052f3c09752a44a8c278e773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*gyni3_mgFxZ_Xx5skbQVdQ.png"/></div></figure><p id="058f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，前四次通话(平均1.2秒)与第五次通话(1.8秒)有所不同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/b7aac43ca0e8de6c3efe02c904d91b17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2G3Dfs8umtkU3AA-L5M2A.png"/></div></div></figure><p id="3960" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Libuv创建了一个由四个线程组成的线程池，每个线程在一秒钟的时间内在四个内核上执行<code class="fe ng nh ni nj b">logHashTime()</code>功能。</p><p id="a018" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当任何一个线程完成执行时，它将选择第五个<code class="fe ng nh ni nj b">logHashTime()</code>函数来执行。所以，这就是为什么我们可以看到前四次呼叫和第五次呼叫之间有明显的时间差。</p><p id="5a9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们想象一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/51d4d93f178245193ea0dd1f109d213e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*q0KIlY_QSe0IMe507Bs5Hw.png"/></div></figure><p id="afdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，第四个线程完成了执行，并准备好选择第五个<code class="fe ng nh ni nj b">logHashTime()</code>函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/10692acdac8c8503a6edec02cbc9ac1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*LJHKTBrVlU-xopsErnSP8g.png"/></div></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="2024" class="nu mg it bd mh nv nw nx mk ny nz oa mn jz ob ka mq kc oc kd mt kf od kg mw oe bi translated">如果我想调整Libuv线程池中的线程数量，该怎么办？</h1><p id="4408" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们可以通过编写一行代码来调整libuv线程池中的线程数量。</p><pre class="kj kk kl km gt oj nj ok ol aw om bi"><span id="eddf" class="mf mg it nj b gy on oo l op oq">process.env.UV_THREADPOOL_SIZE =noOfThreads;</span></pre><p id="3951" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们举同一个例子，将线程的数量从默认的四个增加到五个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="cab5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们检查输出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/89f47e7173bb6c93cf80ed5458e9f091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*45j0y0jMZFftGe5vsfzE_g.png"/></div></figure><p id="cb9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过调整线程数量，我们可以清楚地看到所有五个<code class="fe ng nh ni nj b">logHashTime()</code>函数都花费了1.5秒的等效时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c78fcaac4bd9cf4b6d249ec478318b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ye2lX0lce2jpKymxpP8PXA.png"/></div></div></figure><p id="5ea6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么会这样？</p><p id="7277" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所有五个线程都试图在四个CPU内核上执行<code class="fe ng nh ni nj b">logHashTime()</code>函数。因此，操作系统线程调度器在<a class="ae lq" href="https://www.math.uni-hamburg.de/doc/java/tutorial/essential/threads/priority.html" rel="noopener ugc nofollow" target="_blank">上下文切换</a>的帮助下，平衡并给予每个线程相等的时间来完成执行。</p><p id="a801" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第三个假设将在下一篇文章中讨论。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="da4a" class="nu mg it bd mh nv nw nx mk ny nz oa mn jz ob ka mq kc oc kd mt kf od kg mw oe bi translated">结论</h1><p id="2f0d" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">这就是我们如何得出Node.js是单线程的结论，但在后台，它使用<em class="nd">多线程</em>在libuv库的帮助下执行异步代码。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="af10" class="nu mg it bd mh nv nw nx mk ny nz oa mn jz ob ka mq kc oc kd mt kf od kg mw oe bi translated">下一步是什么？</h1><p id="49d5" class="pw-post-body-paragraph ku kv it kw b kx my ju kz la mz jx lc ld na lf lg lh nb lj lk ll nc ln lo lp im bi translated">我们需要详细讨论更多的话题。在接下来的几篇文章中，我将详细讨论以下主题:</p><ul class=""><li id="954b" class="lr ls it kw b kx ky la lb ld lt lh lu ll lv lp os lx ly lz bi translated">节点事件循环如何在内部工作。</li><li id="2091" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp os lx ly lz bi translated">通过集群增强Node.js性能。</li><li id="c718" class="lr ls it kw b kx ma la mb ld mc lh md ll me lp os lx ly lz bi translated"><a class="ae lq" href="https://github.com/hapijs/hapi" rel="noopener ugc nofollow" target="_blank">哈比神</a>或<a class="ae lq" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">快递</a>给你的创业。</li></ul><p id="622d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div></div>    
</body>
</html>