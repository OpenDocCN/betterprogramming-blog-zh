<html>
<head>
<title>5 Common JavaScript Memory Mistakes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个常见的JavaScript内存错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-common-javascript-memory-mistakes-c8553972e4c2?source=collection_archive---------1-----------------------#2021-03-01">https://betterprogramming.pub/5-common-javascript-memory-mistakes-c8553972e4c2?source=collection_archive---------1-----------------------#2021-03-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="531f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">避免web应用程序内存泄漏的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fdfdcfe49a04f3172cc5297a295eb770.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bHJc2tbv1pM_kLTU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@possessedphotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="91ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript不提供任何内存管理原语。相反，内存是由JavaScript VM通过内存回收过程来管理的。这个过程被称为垃圾收集。</p><p id="3fdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们不能强迫它运行，我们怎么知道它会正常工作？我们对它了解多少？</p><ul class=""><li id="1f78" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在此过程中，脚本执行暂停。</li><li id="b6da" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它为无法访问的资源释放内存。</li><li id="630e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它是不确定的。</li><li id="b25d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它不会一次检查整个内存，而是会运行多个周期。</li><li id="68ce" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它是不可预测的。它会在必要时执行。</li></ul><p id="3f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是否意味着我们不必担心资源和内存分配？当然不是。如果不小心，可能会造成一些内存泄漏。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="334d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">什么是内存泄漏？</h1><p id="dfb7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">内存泄漏是软件无法回收的已分配内存。</p><p id="2c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Javascript为您提供了垃圾收集过程，但这并不意味着您可以避免内存泄漏。为了有资格进行垃圾回收，该对象不能在其他地方被引用。如果您持有对未使用资源的引用，将会阻止这些资源被分配。这就是所谓的无意记忆保持。</p><p id="dff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">内存泄漏可能会导致更频繁地运行垃圾收集器。由于此过程会阻止脚本运行，因此可能会降低您的web应用程序的速度。这将使它不那么爽快，用户会注意到这一点。它甚至会导致你的网络应用崩溃。</p><p id="edab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何才能防止我们的web应用程序泄漏内存？我们必须避免保留不必要的资源。让我们看看最常见的可能发生这种情况的场景。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="1e55" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">1.计时器监听器</h1><p id="8cab" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们来看一下<code class="fe nn no np nq b">setInterval</code>计时器。这是一个常用的Web API特性。</p><blockquote class="nr ns nt"><p id="f1ee" class="kz la nu lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated">在<code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Window" rel="noopener ugc nofollow" target="_blank">Window</a></code>和<code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">Worker</a></code>接口上提供的<code class="fe nn no np nq b"><strong class="lb iu">setInterval()</strong></code>方法重复调用一个函数或执行一段代码，每次调用之间有固定的时间延迟。它返回唯一标识间隔的间隔ID，因此您可以稍后通过调用<code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval" rel="noopener ugc nofollow" target="_blank">clearInterval()</a></code>删除它。这个方法是由<code class="fe nn no np nq b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope" rel="noopener ugc nofollow" target="_blank">WindowOrWorkerGlobalScope</a></code> mixin定义的— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="fd9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建一个组件，它调用一个回调函数来通知它在<code class="fe nn no np nq b">x</code>周期后完成。对于这个特殊的例子，我使用React，但这适用于任何FE框架。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4159" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始，看起来没什么问题。让我们创建一个组件来触发这个计时器，并分析它的内存性能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="debc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击几次<code class="fe nn no np nq b">retry</code>按钮后，这是我们使用Chrome开发工具得到的内存使用结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/9b0ae12cf67b7ddf724726924ca9243a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AY0XlpDVozkeGfxkU5MJ-w.png"/></div></div></figure><p id="c9e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到当我们点击<code class="fe nn no np nq b">retry</code>按钮时，越来越多的内存被分配。这意味着先前分配的内存没有被释放。间隔计时器仍在运行，而不是被替换。</p><p id="6332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何解决这个问题？<code class="fe nn no np nq b">setInterval</code>的返回是一个区间ID，我们可以用它来取消区间。在这个特定的场景中，一旦组件被卸载，我们可以调用<code class="fe nn no np nq b">clearInterval</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="568b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，在代码评审中发现这些问题是很困难的。最佳实践是创建可以管理所有复杂性的抽象。</p><p id="b8c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们在这里使用React，所以我们可以将所有这些逻辑包装在一个自定义挂钩中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="bfab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，无论何时你需要使用<code class="fe nn no np nq b">setInterval</code>，你都可以这样做:</p><pre class="kj kk kl km gt ob nq oc od aw oe bi"><span id="bbf0" class="of mr it nq b gy og oh l oi oj">const handleTimeout = () =&gt; ...;</span><span id="0089" class="of mr it nq b gy ok oh l oi oj">useTimeout(100, handleTimeout);</span></pre><p id="67f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您可以使用这个<code class="fe nn no np nq b">useTimeout</code>钩子，而不必担心内存泄漏，这都是由抽象来管理的。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8dec" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">2.事件监听器</h1><p id="7c6a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">Web API提供了大量的事件侦听器，您可以将自己与它们挂钩。之前，我们介绍过<code class="fe nn no np nq b">setTimeout</code>。现在我们将关注<code class="fe nn no np nq b">addEventListener</code>。</p><p id="9b8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们为web应用程序创建一个键盘快捷键功能。由于我们在不同的页面上有不同的功能，我们将创建不同的快捷功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4cdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一切似乎都很好，除了我们在执行第二个<code class="fe nn no np nq b">addEventListener</code>时没有清理之前的<code class="fe nn no np nq b">keyup</code>。这段代码没有替换我们的<code class="fe nn no np nq b">keyup</code>监听器，而是添加了另一个<code class="fe nn no np nq b">callback</code>。这意味着当一个键被按下时，它将触发这两个功能。</p><p id="8565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要清除之前的回调，我们需要使用<code class="fe nn no np nq b">removeEventListener</code>。让我们看一个代码示例:</p><pre class="kj kk kl km gt ob nq oc od aw oe bi"><span id="9ff7" class="of mr it nq b gy og oh l oi oj">document.removeEventListener(‘keyup’, homeShortcuts);</span></pre><p id="340b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们重构代码来防止这种不必要的行为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据经验，当使用全局对象中的工具时，您需要小心和负责。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="c131" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">3.观察者</h1><p id="c77a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">观察者是一个浏览器Web API特性，很多开发者都不知道。如果您想要检查HTML元素的可见性或大小的变化，它们是非常强大的。</p><p id="42e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们检查交叉点观察器API:</p><blockquote class="ol"><p id="2d54" class="om on it bd oo op oq or os ot ou lu dk translated">“交集观察器API提供了一种异步观察目标元素与祖先元素或顶层文档的<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Viewport" rel="noopener ugc nofollow" target="_blank">视口</a>的交集变化的方法。”— <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="4dc2" class="pw-post-body-paragraph kz la it lb b lc ov ju le lf ow jx lh li ox lk ll lm oy lo lp lq oz ls lt lu im bi translated">虽然它很强大，但你需要负责任地使用它。一旦你完成了对物体的观察，你需要取消监视过程。</p><p id="2fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9d75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码看起来很好。但是，一旦组件被卸载，观察器会发生什么情况呢？它不会被清除，所以你会泄漏内存。我们如何解决这个问题？仅仅通过使用<code class="fe nn no np nq b">disconnect</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e690" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以确定，当组件被卸载时，我们的观察者将被断开。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ede0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">4.窗口对象</h1><p id="1ebd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">向窗口添加对象是一个常见的错误。在某些场景中，可能很难找到——特别是当您在窗口执行上下文中使用<code class="fe nn no np nq b">this</code>关键字时。</p><p id="1aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4b2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来无害，但这取决于您从哪个上下文调用<code class="fe nn no np nq b">addElement </code>。如果您从窗口上下文中调用<code class="fe nn no np nq b">addElement</code>，您将开始看到项目堆积起来。</p><p id="5cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个问题可能是错误地定义了全局变量:</p><pre class="kj kk kl km gt ob nq oc od aw oe bi"><span id="6de0" class="of mr it nq b gy og oh l oi oj">var a = 'example 1'; // scoped to the place where var was created<br/>b = 'example 2'; // added to the Window object</span></pre><p id="8533" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了防止这种问题，请始终在严格模式下执行JavaScript:</p><pre class="kj kk kl km gt ob nq oc od aw oe bi"><span id="7d02" class="of mr it nq b gy og oh l oi oj">"use strict"</span></pre><p id="2e7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用严格模式，您在向JavaScript编译器暗示您想要保护自己免受这些行为的影响。需要的时候还可以用窗户。不过，你必须以明确的方式使用它。</p><p id="9e59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格模式将如何影响我们前面的例子:</p><ul class=""><li id="d13c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">在<code class="fe nn no np nq b">addElement</code>函数上，当从全局范围调用时，<code class="fe nn no np nq b">this</code>将是未定义的。</li><li id="d012" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果您没有在变量上指定<code class="fe nn no np nq b">const | let | var</code>，您将得到以下错误:</li></ul><pre class="kj kk kl km gt ob nq oc od aw oe bi"><span id="b85b" class="of mr it nq b gy og oh l oi oj">Uncaught ReferenceError: b is not defined</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="2d86" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">5.保存DOM引用</h1><p id="9b23" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">DOM节点也不能避免内存泄漏。你需要小心不要持有它们的引用。否则，垃圾收集器将无法清理它们，因为它们仍然是可访问的。</p><p id="d448" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个小代码示例来说明这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="4f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，<code class="fe nn no np nq b">addElement</code>函数清除了<code class="fe nn no np nq b">list</code> div并添加了一个新元素作为子元素。这个新创建的元素被添加到<code class="fe nn no np nq b">elements</code>数组中。</p><p id="0d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次执行<code class="fe nn no np nq b">addElement</code>时，该元素将从<code class="fe nn no np nq b">list</code> div中移除。然而，它没有资格进行垃圾收集，因为它存储在<code class="fe nn no np nq b">elements</code>数组中。这使得它可以达到。这将使您在每次执行<code class="fe nn no np nq b">addElement</code>时成为一个<code class="fe nn no np nq b">Node</code>。</p><p id="13f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们在几次执行之后监视这个函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/cf35743ce8e00e2a9204159d786b6e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Ie_oCAJx66YGRD9IM3xig.png"/></div></div></figure><p id="ac04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在上面的截图中看到节点是如何泄露的。我们如何解决这个问题？清除<code class="fe nn no np nq b">elements</code>数组将使它们符合垃圾收集的条件。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="e12a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="1d0e" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在本文中，我们已经看到了最常见的内存泄漏方式。很明显，JavaScript本身不会泄漏内存。相反，这是由开发人员无意的内存保留造成的。只要代码是整洁的，并且我们不忘记自己清理，就不会发生泄漏。</p><p id="8796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解JavaScript中的内存和垃圾收集是必须的。一些开发人员得到错误的印象，因为它是自动的，他们不需要担心它。</p><p id="c64e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建议定期在web应用程序上运行浏览器分析器工具。这是确保没有任何东西泄漏和遗留的唯一方法。Chrome Developer <code class="fe nn no np nq b">performance</code>标签是开始检测一些异常的地方。发现问题后，您可以使用<code class="fe nn no np nq b">profiler</code>选项卡通过拍摄快照并进行比较来更深入地了解问题。</p><p id="98a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候，我们把时间花在优化方法上，却忘记了内存在web应用程序的性能中扮演着重要的角色。</p><p id="b371" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><p id="2307" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不是中等会员吗？支持我<a class="ae ky" href="http://dioxmio.medium.com/membership" rel="noopener">成为这里的</a>。</p><h1 id="3015" class="mq mr it bd ms mt pb mv mw mx pc mz na jz pd ka nc kc pe kd ne kf pf kg ng nh bi translated">有关系的</h1><div class="pg ph gp gr pi pj"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-write-readable-code-bf1fa656673e"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd iu gy z fp po fr fs pp fu fw is bi translated">如何写出可读的代码？</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">提高代码可读性的6个技巧</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">better编程. pub</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px ks pj"/></div></div></a></div></div></div>    
</body>
</html>