<html>
<head>
<title>Make Your AI-Powered Personal Assistant Play Music! (Featuring Web3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你的人工智能个人助理播放音乐！(以Web3为特色)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-your-ai-powered-personal-assistant-play-music-featuring-web3-a1e7eec68f4a?source=collection_archive---------20-----------------------#2022-08-29">https://betterprogramming.pub/make-your-ai-powered-personal-assistant-play-music-featuring-web3-a1e7eec68f4a?source=collection_archive---------20-----------------------#2022-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="79d2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">整合Houndify API，做一个类似Alexa或者Siri的个人助理</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ed031fd96533c40f0f2249591381576c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFIryDVhLRPId_tdb9ZG1g.png"/></div></div></figure><p id="07be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上一篇文章中，我们用<code class="fe ln lo lp lq b">Wave.js</code>设置了我们的应用程序并添加了音频可视化。现在我们让客户端播放音乐。下面的演示展示了我们正在努力做的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0388" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，服务器从YouTube下载歌曲。然后，它将文件上传到一个分散的存储网络。最后，客户端检索文件并播放它。</p><h1 id="f90f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">安装</h1><p id="3246" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">如果您没有阅读该系列的最后一篇文章，我建议您先阅读它<a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-ai-powered-virtual-assistant-on-the-web-175fc9e61973"/>。</p><p id="4e77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将向您展示如何集成Houndify API，在您的PC上制作一个类似Alexa或Siri的个人助理。</p><p id="3855" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果你想重新开始，启动代码可以在这里找到<a class="ae mq" href="https://github.com/WoolDoughnut310/houndify-voice-assistant/tree/part1" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="fe85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还记得Houndify指示板是如何拥有需要客户端集成才能运行的域的吗？这里有两个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/38df13f05977eeb988f04490def561fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S74ulSFp34sRL3y3.jpeg"/></div></div></figure><p id="62cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">启用这两个域，然后单击页面右上角的保存更改。这将允许用户请求某首歌曲，播放音乐排行榜上的歌曲，或者指定流派。</p><h1 id="ad6a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">启动命令处理程序</h1><p id="5dea" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">现在这些域已经启用，回到您的编辑器，打开<code class="fe ln lo lp lq b">src/App.tsx</code>并插入以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="c70b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果用户的命令需要额外的逻辑，<code class="fe ln lo lp lq b">handleCommand</code>将转换结果。</p><p id="7f78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在新的<code class="fe ln lo lp lq b">src/handlers</code>目录下创建一个名为<code class="fe ln lo lp lq b">index.ts</code>的文件，并插入以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="8a61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，<code class="fe ln lo lp lq b">COMMANDS</code>存储客户机能够处理的Houndify命令。<code class="fe ln lo lp lq b">MusicCommand</code>是允许音乐播放和图表功能的命令。</p><p id="495f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后该函数接受我们的结果对象并查看命令。如果我们可以处理它，我们可以从文件夹中导入处理程序并使用它。如果没有，它将返回相同的结果和默认响应。</p><h1 id="4b2a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">处理音乐命令</h1><p id="4f9e" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">等等，这是怎么回事？</p><p id="3847" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当用户请求一首歌曲时，结果包含诸如曲目名称和艺术家之类的信息。它还包含一个结果的两个新版本。当客户要播放歌曲时，我们使用它们。如果成功，我们返回<code class="fe ln lo lp lq b">AutoPlayResult</code>和<code class="fe ln lo lp lq b">AutoPlayFailedResult</code>否则。</p><p id="762b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们将使用曲目名称和艺术家来查找相应的YouTube视频。然后我们把它上传到服务器。然后在前端，我们检索文件并播放音频。</p><p id="8aec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，定义这两个常数:</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="c54c" class="mx lu iq lq b gy my mz l na nb">const SUCCESS_RESULT = "AutoPlayResult";<br/>const FAILED_RESULT = "AutoPlayFailedResult";</span></pre><p id="cace" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，创建一个<code class="fe ln lo lp lq b">handle</code>函数，这将是处理程序的主要部分。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="0045" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，添加下面的代码，它概括了我们讨论的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="7bc6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们稍后将回到<code class="fe ln lo lp lq b">cid</code>变量。这是web3奖金的一部分！</p><p id="c5e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以创建一个助手功能，从曲目信息中创建一个优化的搜索查询。然后一个额外的函数从我们的服务器调用新的端点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="770a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将不得不使用YouTube数据API来搜索视频，并返回第一个端点的视频ID。那么，让我们跳到上次创建的服务器上来做这件事。</p><h1 id="9fe5" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用YouTube数据API</h1><p id="76e4" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">你可以在这里找到设置API和获取API密钥的指南<a class="ae mq" href="https://developers.google.com/youtube/v3/getting-started#before-you-start" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="dd87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">设置好之后，将API密钥添加到<code class="fe ln lo lp lq b">.env</code>文件中，如下所示:</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="3834" class="mx lu iq lq b gy my mz l na nb">...<br/>YOUTUBE_DATA_API_KEY={YOUR_API_KEY}</span></pre><p id="b27f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们首先安装<code class="fe ln lo lp lq b">body-parser</code>来解析来自请求的JSON数据。然后用<code class="fe ln lo lp lq b">youtube-search</code>来包装API。</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="0ea8" class="mx lu iq lq b gy my mz l na nb">npm i body-parser youtube-search</span></pre><p id="5e80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，将以下代码添加到<code class="fe ln lo lp lq b">server.js</code>文件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="ccd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以定义从YouTube下载视频的路径，并返回对文件的引用。</p><h1 id="0c4e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">下载YouTube视频</h1><p id="66e4" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">在服务器端，我们将使用一个名为<code class="fe ln lo lp lq b">yt-dlp</code>的程序从YouTube中提取视频。然后，它使用[ffmpeg]将视频转换为音频。</p><p id="5180" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里可以下载<code class="fe ln lo lp lq b">yt-dlp</code>的二进制文件，这里可以获取<code class="fe ln lo lp lq b">ffmpeg</code> <a class="ae mq" href="https://ffmpeg.org/download.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="281b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将二进制文件保存到项目中名为<code class="fe ln lo lp lq b">binaries</code>的文件夹中。该文件夹应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/ee01c616ad6627fe5d149d57bd56ffcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/0*p-i9UCLIivu6AeyT.png"/></div></figure><p id="0aec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们必须安装<code class="fe ln lo lp lq b">yt-dlp-wrap</code>库来处理对<code class="fe ln lo lp lq b">yt-dlp</code>命令的执行:</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="05ea" class="mx lu iq lq b gy my mz l na nb">npm i yt-dlp-wrap</span></pre><p id="b0de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，下面的代码将根据ID从YouTube下载任何给定的视频:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="c341" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是将所有的歌曲文件上传到服务器的<code class="fe ln lo lp lq b">public</code>文件夹并不是一个好主意。有一些第三方服务针对文件存储进行了更好的优化。在本教程中，我们将使用<a class="ae mq" href="https://web3.storage/" rel="noopener ugc nofollow" target="_blank"> Web3。存储</a>使用分散式网络存储文件。我使用它有两个原因:</p><ol class=""><li id="129f" class="nd ne iq kt b ku kv kx ky la nf le ng li nh lm ni nj nk nl bi translated">您可以获得完全免费的1 TB存储空间(是的，免费！)</li><li id="7ca9" class="nd ne iq kt b ku nm kx nn la no le np li nq lm ni nj nk nl bi translated">看完快速入门<a class="ae mq" href="https://web3.storage/docs/#quickstart" rel="noopener ugc nofollow" target="_blank">这里</a>就很简单上手了。</li></ol><h1 id="cb85" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">奖励—分散存储</h1><p id="196c" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">将您的API密钥添加到。env文件如下:</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="6ed4" class="mx lu iq lq b gy my mz l na nb">REACT_APP_WEB3_STORAGE_TOKEN={YOUR_KEY}</span></pre><h1 id="af7c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">正在安装Web3。储存；储备</h1><p id="e907" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">现在使用以下命令安装web3.storage:</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="07e4" class="mx lu iq lq b gy my mz l na nb">npm i web3.storage</span></pre><h1 id="3ade" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">上传YT视频到Web3。储存；储备</h1><p id="a77d" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">我们可以首先定义一个函数，用<code class="fe ln lo lp lq b">yt-dlp</code>下载一个视频，并将输出流式传输到我们的存储提供商。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="f87c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以添加本教程的最终API路径了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="b60b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在移到前端。添加以下代码以在<code class="fe ln lo lp lq b">MusicCommand</code>处理程序中检索文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><h1 id="b0da" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">回忆以前的歌曲</h1><p id="4e35" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">此时此刻，你可能在想这样效率有多高。每次我们调用路由时，服务器都会下载视频，不管我们请求的是哪个视频。因此，如果我们再次请求相同的歌曲，服务器将花费相同的时间来响应。</p><p id="80c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过存储一个名为<code class="fe ln lo lp lq b">song_cids.json</code>的JSON文件来加快速度。它将包含YouTube IDs到存储cid(内容标识符)的映射。因此，如果我们请求的视频ID在文件中，我们可以为文件返回一个合适的CID。</p><p id="4028" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将以下内容添加到服务器代码中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="3d44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，像这样延伸路线:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><h1 id="70a2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">Toast通知</h1><p id="4c8b" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">如果你现在启动开发服务器，试着点一首歌。至少要等五秒钟，而且根本不知道发生了什么！为了提供额外的视觉反馈，我们可以使用<code class="fe ln lo lp lq b">react-toastify</code>库。有了它，我们可以轻松地添加优雅的吐司通知。使用以下代码行安装它:</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="b41f" class="mx lu iq lq b gy my mz l na nb">npm i react-toastify</span></pre><p id="846a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开<code class="fe ln lo lp lq b">src/App.tsx</code>，导入我们需要的文件:</p><pre class="kg kh ki kj gt mt lq mu mv aw mw bi"><span id="9587" class="mx lu iq lq b gy my mz l na nb">import { ToastContainer } from "react-toastify";<br/>import "react-toastify/dist/ReactToastify.css";</span></pre><p id="3576" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在组件中添加<code class="fe ln lo lp lq b">ToastContainer</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><p id="4bbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在打开<code class="fe ln lo lp lq b">src/handlers/MusicCommand.ts</code>并改变<code class="fe ln lo lp lq b">handle</code>功能:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms ls l"/></div></figure><h1 id="1348" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">包扎</h1><p id="37fb" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">仅此而已！我们用<code class="fe ln lo lp lq b">yt-dlp</code>从YouTube下载视频，用<code class="fe ln lo lp lq b">web3.storage</code>存储下载的歌曲。你可以在我的repo的这个<a class="ae mq" href="https://github.com/WoolDoughnut310/houndify-voice-assistant/tree/part2" rel="noopener ugc nofollow" target="_blank">分支</a>中找到本教程的所有代码，并可以随意使用。请继续关注该系列的下一部分，我们将能够暂停歌曲。这样，如果你后来觉得这首歌不适合你，你就不必听整首歌了。尽情享受吧！</p><h1 id="2eb3" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">资源</h1><p id="72b1" class="pw-post-body-paragraph kr ks iq kt b ku ml jr kw kx mm ju kz la mn lc ld le mo lg lh li mp lk ll lm ij bi translated">使用Web3在IPFS上存储数据。存储！</p><p id="4b14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mq" href="https://fkhadra.github.io/react-toastify/promise" rel="noopener ugc nofollow" target="_blank">处理承诺|应对承诺</a></p><p id="f6f7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mq" href="https://docs.houndify.com/reference/MusicCommand" rel="noopener ugc nofollow" target="_blank"> MusicCommand API参考| Houndify文档</a></p><p id="ba34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mq" href="https://github.com/ytdl-org/youtube-dl/issues/30102#issuecomment-943849906" rel="noopener ugc nofollow" target="_blank">问题#30102 ytdl-org/youtube-dl </a></p><p id="765b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae mq" href="https://developers.google.com/youtube/v3/getting-started" rel="noopener ugc nofollow" target="_blank"> YouTube数据API概述|谷歌开发者</a></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="7be0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ny">原发布于</em><a class="ae mq" href="https://cs310.hashnode.dev/build-your-own-ai-powered-virtual-assistant-on-the-web-part2" rel="noopener ugc nofollow" target="_blank"><em class="ny">https://cs 310 . hash node . dev</em></a><em class="ny">。</em></p></div></div>    
</body>
</html>