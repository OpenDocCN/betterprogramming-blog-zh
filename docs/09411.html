<html>
<head>
<title>Text Wrapping in Python With the Standard “textwrap” Module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的标准“textwrap”模块进行文本换行</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/text-wrapping-in-python-with-the-standard-textwrap-module-38b2da5b8257?source=collection_archive---------5-----------------------#2021-08-20">https://betterprogramming.pub/text-wrapping-in-python-with-the-standard-textwrap-module-38b2da5b8257?source=collection_archive---------5-----------------------#2021-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2bc7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用标准<code class="fe ki kj kk kl b">textwrap </code>库的强大功能，像专家一样格式化文本！</h2></div><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/a7f5416f8a208df566c411697adecc37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P8Sw0gGAV9VMhqO8"/></div></div><p class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@kadh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kira auf der Heide </a>在<a class="ae lc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="3035" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">当在自然语言处理、数据分析、甚至艺术或设计工作的应用中处理文本语言时，文本换行是一种有用的工具。Python <code class="fe ki kj kk kl b">textwrap </code>模块提供了方便的函数来帮助创建文本换行效果。</p><p id="3b07" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这个模块还提供了几个相关的函数，可以用来规范化空白、删除或添加缩进、前缀和后缀文本，以及许多其他用途。此外，<code class="fe ki kj kk kl b">textwrap</code>模块还提供了一个<code class="fe ki kj kk kl b">TextWrapper</code>类，它提供了类似的功能，但考虑到了更高的内存效率。</p><h1 id="a955" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Python中的文本换行</h1><p id="7090" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">本文中的例子使用了亚历山大·杜马斯<em class="mw">的《基督山伯爵</em>中的文本，该文本现在是公共领域的一部分，可以从古腾堡计划中以多种格式免费获得。下面的文字来自第一章的前三段。</p><pre class="kn ko kp kq gt mx kl my mz aw na bi"><span id="7454" class="nb ma it kl b gy nc nd l ne nf">On the 24th of February, 1815, the look-out at Notre-Dame de la Garde<br/>signalled the three-master, the _Pharaon_ from Smyrna, Trieste, and<br/>Naples.</span><span id="4fca" class="nb ma it kl b gy ng nd l ne nf">As usual, a pilot put off immediately, and rounding the Château d’If,<br/>got on board the vessel between Cape Morgiou and Rion island.</span><span id="2760" class="nb ma it kl b gy ng nd l ne nf">Immediately, and according to custom, the ramparts of Fort Saint-Jean<br/>were covered with spectators; it is always an event at Marseilles for a<br/>ship to come into port, especially when this ship, like the _Pharaon_,<br/>has been built, rigged, and laden at the old Phocee docks, and belongs<br/>to an owner of the city.</span></pre><p id="d6ce" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用下面的代码，我很快了解了这段文本的平均行长度。</p><pre class="kn ko kp kq gt mx kl my mz aw na bi"><span id="2b50" class="nb ma it kl b gy nc nd l ne nf">import statistics</span><span id="c978" class="nb ma it kl b gy ng nd l ne nf"># Calculate the average line length<br/>avg_length = statistics.mean([len(x) for x in text.splitlines()])</span><span id="cc4d" class="nb ma it kl b gy ng nd l ne nf">&gt;&gt;&gt; 48.083333333333336</span></pre><p id="f20b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这与我正在做的事情无关，但将有助于指导在包装期间为宽度传递的值，以获得更好的可视化演示。毕竟，将48个字符宽的文本串包装成50个字符的效果在视觉上不会很有戏剧性。</p><h1 id="fc3d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">独立函数与Textwrapper类</h1><p id="95d3" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><a class="ae lc" href="https://docs.python.org/3/library/textwrap.html" rel="noopener ugc nofollow" target="_blank"> Python textwrap模块</a>提供了一系列方法，作为独立的函数或者通过<code class="fe ki kj kk kl b">TextWrapper</code>类作为类方法。官方文档建议这样使用<code class="fe ki kj kk kl b">TextWrapper</code>类:</p><p id="864e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">“如果你只是包装或填充一个或两个文本字符串，方便的功能应该足够好；否则，为了提高效率，应该使用TextWrapper的实例。</p><p id="a2cf" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">换句话说，如果你只是在修改一两个句子，没有必要强占记忆。我们将从TextWrapper类开始研究每种类型的用法，因为其中定义的几个实例属性与独立函数相关。</p><h1 id="4a78" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">独立功能</h1><p id="fab2" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">以下函数是独立提供的，它们提供了有用的文本实用程序。与模块名称可能暗示的相反，这些函数解决了许多常见的用例，而不是将python中的文本行换行到固定长度。然而，这就是我们要开始的地方！</p><h1 id="f539" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">包</h1><p id="8837" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><em class="mw">"返回输出行列表，没有最后的换行符。如果包装的输出没有内容，则返回的列表为空。—文本包装文档</em></p><p id="28a4" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该函数提供了<code class="fe ki kj kk kl b">textwrap </code>模块最具特征的实用程序——通过<em class="mw">将</em>文本换行到有限数量的字符。该函数接受文本字符串或文本集合、宽度参数以及TextWrapper类可用的任何其他实例参数。</p><p id="4eec" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">使用示例文本、wrap函数和宽度参数25会产生以下输出:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="ffa3" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">充满</h1><p id="8714" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><em class="mw">"将文本中的单个段落换行，并返回包含换行段落的单个字符串。"—文本包装文档</em></p><p id="8b45" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">在使用了wrap函数之后，人们可能会考虑使用子字符串集合。我倾向于发现我的最终用例是文本的<em class="mw">块</em>,而不是子字符串的集合。</p><p id="7c12" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">换句话说，我希望文本换行产生平均行长度更短的单个文本块。我倾向于使用类似于<code class="fe ki kj kk kl b">text_block = "\n".join(lines)</code>的东西来完成这个目标——这正是<code class="fe ki kj kk kl b">fill</code>函数所做的<em class="mw">:</em></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b1d3" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">注意:</strong>fill函数与wrap函数采用相同的参数。唯一的区别是它将结果行连接成一个文本块。</p><h1 id="6608" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">缩短</h1><p id="0ce3" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><em class="mw">“折叠和截断给定的文本以适合给定的宽度。”— TextWrapper文档</em></p><p id="1aa0" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">shorten</code>函数可以被视为一个摘录生成函数。它将一个字符串作为参数，并将该字符串截断为特定数量的字符。在截断过程中，shorten函数还会对空白进行规范化，以使结果文本只包含单个空格字符。查看这个<a class="ae lc" href="https://www.alpharithms.com/ascii-table-512119/" rel="noopener ugc nofollow" target="_blank"> ASCII查找表</a>以获得空白字符值的参考。</p><p id="1041" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><code class="fe ki kj kk kl b">shorten</code>函数是独立函数的第一个例子，其中除了<code class="fe ki kj kk kl b">text</code>和<code class="fe ki kj kk kl b">width</code>之外的关键字参数非常有用。在这里使用<code class="fe ki kj kk kl b">placeholder</code>参数指定什么字符将被附加到结果文本中。个人觉得椭圆(...)在视觉上合适，如下例所示:</p><pre class="kn ko kp kq gt mx kl my mz aw na bi"><span id="e9de" class="nb ma it kl b gy nc nd l ne nf"># Use the shorten function to create a concatenated string<br/>textwrap.shorten(text=sample_text, width=75, placeholder="...")</span><span id="6012" class="nb ma it kl b gy ng nd l ne nf"># The resulting concatenated text with the ellipsis added<br/># via the "placeholder" argument.<br/>&gt;&gt;&gt; On the 24th of February, 1815, the look-out at Notre-Dame de la Garde...</span></pre><p id="29ee" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><strong class="lf iu">注意</strong>:如果空白规范化导致文本短于指定的宽度，那么文本将被完整返回。全空白文本将返回一个空字符串，也不添加占位符。</p><h1 id="ca4a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">德登特</h1><p id="6d27" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><em class="mw">“删除文本中每行常见的前导空格。”—文本包装文档</em></p><p id="9e30" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">dedent函数花了我一点时间来理解。它的目的是规范整个文本块的前导空格<strong class="lf iu">——而不是单独的行</strong>。这里常见的情况是在方法文档、字符串格式等东西中找到预期的文本。此函数不适用于当前的示例文本，但是考虑来自重复源代码的缩进文档字符串的以下情况:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="021f" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">复制/粘贴这个<em class="mw">缩进的</em>文档字符串文本会导致文本行共享四个单空格字符的前导序列(不是制表符！).手动删除这个缩进非常容易，并且几乎不能证明依赖函数的存在。</p><p id="0761" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">想象一下，使用标准库中每个函数的docstring(可能用于NLP分析),需要移除缩进。手动移除在功能上是难以处理的。使用dedent函数将确保在预处理过程中删除所有缩进。一个简单的例子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bdee" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">注意，大仲马作品的这个例子在开头和结尾都有一个换行符，没有被删除。<strong class="lf iu">换行符并不是所有文本行</strong>都通用的，因此在dedent函数算法中不会被删除。仅删除所有行共享的缩进空间。</p><h1 id="f81b" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">缩进</h1><p id="afa6" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><em class="mw">“在文本中所选行的开头添加前缀。”—文本包装文档</em></p><p id="55ad" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">缩进函数的工作方式和预期的一样；它将指定为后缀参数的任何字符串添加到文本正文中。考虑对原始示例文本使用缩进功能的结果:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2d8b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">默认情况下，indent函数会将prefix的值添加到除纯空白行之外的任何行。换句话说，前缀不会添加到示例文本中段落之间的空行中。</p><p id="89e6" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">indent函数还允许将一个可调用的参数作为一个<code class="fe ki kj kk kl b">predicate</code>参数传入。这旨在为被赋予<code class="fe ki kj kk kl b">prefix</code>的线路提供逻辑控制。例如，如果坚持在空白行前加上前缀，可以使用下面的语法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="672e" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">其他创造性的方法可能适用于这样的情况，其中一行包含一系列字符，这样人们会想要视觉通知。例如，每行包含单词“and”:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2d1b" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我希望将来能看到这个函数的一个可能的扩展是支持在多个前缀之间进行有条件的选择。例如，添加一个四个空格的序列来缩进没有单词<em class="mw">和</em>的每一行，或者添加一个带有前导星号的三个空格的序列。目前，我们需要做类似的事情:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3ab7" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这里的最终结果是一个更加视觉平衡的*表示，表示在我们的示例文本的一行中包含单词<em class="mw">和</em>。</p><h1 id="e788" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">TextWrapper类</h1><p id="f21c" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated">TextWrapper类用于可能与内存效率相关的较大文本体。例如，一个一百万字的语料库正在为NLP分析进行预处理。实例化期间传递的关键字参数可作为实例属性用于类对象。TextWrapper类还提供了<code class="fe ki kj kk kl b">wrap</code>和<code class="fe ki kj kk kl b">fill</code>作为公共方法。</p><h1 id="4a06" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最后的想法</h1><p id="2896" class="pw-post-body-paragraph ld le it lf b lg mr ju li lj ms jx ll lm mt lo lp lq mu ls lt lu mv lw lx ly im bi translated"><code class="fe ki kj kk kl b">textwrap</code>模块包含一些非常基本的文本操作工具。我很少发现一个基于文本的项目可以通过这个模块完全解决。然而，它的<code class="fe ki kj kk kl b">wrap</code>和<code class="fe ki kj kk kl b">dedent</code>函数都非常有用，并提供了包含在标准Python库中的好处。我发现自己经常使用它们，足以熟悉它们的内部运作。</p><p id="d2ba" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">如果我可以改变这个模块的任何东西，那就是将<code class="fe ki kj kk kl b">placeholder</code>参数命名为<em class="mw">后缀</em>、<em class="mw">追加、</em>或<em class="mw">结束</em>，以更好地传达用例。<code class="fe ki kj kk kl b">placeholder</code>语法意味着在输入时删除——就像HTML表单字段中的<em class="mw">占位符</em>属性。奇怪的是，<code class="fe ki kj kk kl b">indent</code>方法选择使用<code class="fe ki kj kk kl b">suffix</code>语法。</p><p id="51fb" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我还希望看到一种更简洁的方法来揭示TextWrapper对象的包装版本。例如，要查看包装形式的文本，必须将文本传递给公共方法:<code class="fe ki kj kk kl b">text.wrap(text=self.text)</code>。我希望看到更多类似于<code class="fe ki kj kk kl b">text.show()</code>的东西，这仍然能够带来通过<code class="fe ki kj kk kl b">text.text</code>属性访问原始文本的好处。我估计大家都是评论家吧！</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="97ca" class="pw-post-body-paragraph ld le it lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">文章<a class="ae lc" href="https://www.alpharithms.com/python-text-wrapping-with-textwrap-module-321615/" rel="noopener ugc nofollow" target="_blank"> <em class="mw">使用Python中的标准textwrap模块</em> </a> <em class="mw"> </em>进行文本换行首次出现在<a class="ae lc" href="https://www.alpharithms.com" rel="noopener ugc nofollow" target="_blank">αlphα算法</a>网站上，并经许可在此重新发布。</p></div></div>    
</body>
</html>