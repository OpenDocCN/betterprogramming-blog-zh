# 在堆栈溢出之前编程是什么感觉？

> 原文：<https://betterprogramming.pub/what-was-it-like-to-program-before-stack-overflow-3ddf7a7915b4>

## 程序员问答平台前的生活

![](img/24c7599df261e6655d47eecba1dda211.png)

这可能很难相信，但曾经有一段时间[栈溢出](https://stackoverflow.com/)不是一个真正的网站，这个术语本质上只是指由于某种未知的原因，你的应用程序耗尽了内存——这是一个你无法查找栈溢出的原因。讽刺的是我没有错过。

堆栈溢出已经从根本上永远改变了我们对待软件工程的方式。这是我们找到十年前的错误解决方案的地方，也是我们学习最佳实践的地方，因为人们因为他们的代码过时而互相指责。无论在代码中还是在生活中，当我们遇到任何障碍时，它基本上是我们首先要查看的地方，通常也是我们最后检查确认的地方。

然而，回到 21 世纪初，情况完全不同。当时还没有谷歌，但我们有雅虎，尽管我不太记得当时雅虎有多令人惊讶或失望。在 2008 年之前不存在堆栈溢出。不过，我们确实进行了专家交流，这完全不是一回事，而是有点像。对于那些那些年不从事编码工作的人来说，专家交流是一个论坛，它几乎可以提供你正在寻找的答案。唯一的问题是它位于付费墙后面。网站用一个听起来像你在寻找的答案的片段来戏弄你。

那时，如果你愿意的话，你可以简单地“查看源代码”,看看完整的答案。最终，那个洞被堵上了，你真的需要为解决你的问题付出代价。我个人从来没有这样做过，因为如果你足够努力地在网上论坛搜索，你仍然可以免费找到你的答案，只有少数勇敢的人才敢这样做。

论坛有点像当时的堆栈溢出。他们有一个中心话题或问题，然后是一连串的答案，有时会跨越十几页。但是它们并没有集中在网络上的任何一个位置。大多数时候，你有成千上万的论坛要搜索，但没有任何明确的答案。你只需要坐在那里，阅读每一条评论，直到你发现一些听起来很有用的东西。

不过，大多数论坛都有版主。这些好心人试图做 Stack Overflow 建立其整个商业计划的基础。他们试图清理每天添加的成堆的内容，并试图将相关的东西钉在顶部附近。

当时的开发是一个极其缓慢而乏味的过程。有时甚至很痛苦。花三天时间盯着同样的错误信息，却看不到通往胜利的明确道路，这令人沮丧。你也觉得自己随时都可能被解雇。但你没有。至少，不太可能。

唯一的好处是这是公司期望的软件工程。坐几天完全没问题，也许通过在线论坛搜索，但主要是通过试错来尝试事情。我记得在与整个开发团队的会议中，亮点是我们中的一个人在某个随机论坛或未知位置找到了某个模糊错误的解决方案。这是一个盛大的场合，我们庆祝了这些小胜利——虽然不是真正的“小”胜利，因为通常这些错误是阻碍发展的绊脚石。

这也意味着开发周期比现在长得多。2008 年，我在一个销售管理平台上工作，作为一名初级开发人员，与其他六名程序员组成一个团队。这个项目的时间表是 18 个月，这在当时看来是非常合理的。然而，现在回过头来看，很难想象这个估计是如何计算出来的，特别是因为其中很大一部分时间确实花在了研究和寻找漏洞上。

开发肯定更具挑战性，但原因不对。在那段时间建立起来的许多架构，我很可能不会推荐给任何有抱负的程序员。事情很仓促，为了减轻每天积累的大量技术债务，重构几乎每周都是强制性的。

所有这一切的原因基本上是缺乏任何中央质量保证平台。除了你工作间左边或右边的人之外，根本没有人可以询问模糊的编码错误。当他们没有给出答案时，就该在互联网上寻找答案了。你总是可以选择检查专家交流和通过付费墙支付你的方式。但是，我们是程序员。我们不会那么做的。

然而，当时许多公司都有一个编程书籍库。这现在听起来可能有些怪异和过时，但它很有用，也很方便。如果你正在进行一个新的 Visual Basic 项目，那么你很有可能就是那个“借出”这本书的人。它会放在你的桌子上，主要作为参考指南，当其他程序员走过时，等着你看完它。

现在来说说大学场景是如何在没有栈溢出的情况下存活下来的。在堆栈溢出出现之前，我上了大学。但我记得谷歌搜索任何东西都是被禁止的。如果你不得不写一个二进制搜索树算法，并且你从某个一次性的博客上复制了你的代码，而其他人碰巧复制了同样的代码，那么你就有麻烦了。

我个人不知道从那时起工程系的情况有什么变化，但我可以想象，随着事情变得越来越复杂，在教室环境中使用堆栈溢出可能不会受到反对。至少，我希望如此。

正如我所说的，当时编码有点慢，也有点痛苦。我们主要使用 1000 页的巨型教科书，就像 80 年代家庭使用百科全书代替维基百科一样。

如果说有什么不同的话，那就是它让我更清楚地了解了在过去的十年里，技术是如何以及为什么会以指数级增长的。这并不是说事情变得更容易了；相反，现在的情况非常复杂。但是我们有办法在几分钟内而不是几天内找到解决办法。

如今，有些人认为使用栈溢出这样的工具会让你成为一个弱思考者。盯着一个接一个的错误信息的空白屏幕，直到有一天错误信息消失，你可以继续下一组错误信息，这是一种荣誉。但是就像我说的，我认为那些人是做简单工作的人。很容易坐在那里，认为你面前的挑战是最大的。很难承认这可能只是某个人在五年前解决的五分钟修复，而成千上万的其他开发人员已经同意并投票支持它。

但是，无论您喜欢哪种形式，我希望这篇文章已经或多或少地描绘了十多年前编程的样子。那是一段艰难的时期，但是我们找到并构建了帮助我们进入下一个十年软件开发的解决方案。