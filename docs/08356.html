<html>
<head>
<title>How To Create a Custom TabBar in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中创建自定义标签栏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-custom-tabbar-in-swift-d44b3db3ac0e?source=collection_archive---------3-----------------------#2021-04-21">https://betterprogramming.pub/how-to-create-a-custom-tabbar-in-swift-d44b3db3ac0e?source=collection_archive---------3-----------------------#2021-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="da34" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Containment API创建一个我们完全控制的TabBar</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a6c3e5b8f9f0904ff3e5c1f3592dce3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8Auqqt5rt91VYy0C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@myleon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莱昂</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="933b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI每天都在变得越来越成熟，但UIKit还在。这是其他技术在过去已经发生过的事情。例如，Swift于2014年发布，但仍有许多应用程序是用Objective-C编写和维护的。</p><p id="6dbd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">UIKit提供了几个组件来构建我们的应用程序，但有时它们的API并不像我们希望的那样灵活。有时这些组件工作起来很奇怪，我们很难改变它们的行为。例如，你有没有尝试过为一个<code class="fe lv lw lx ly b">UITabBarButton</code>实现一个自定义动画？</p><p id="9799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我想分享如何构建一个自定义的<code class="fe lv lw lx ly b">TabBar</code>来完全控制它。一旦实现了主要特性，我们就可以根据需要添加许多其他功能:复杂的按钮动画、不同的栏高、自定义动画等等。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e32f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">什么是TabBar？</h1><p id="ca53" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">首先，让我们明确我们想要达到的目标。我们希望:</p><ul class=""><li id="67ed" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">实现一个可以容纳其他视图控制器的视图控制器。</li><li id="ea8b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">显示其中一个视图控制器。</li><li id="8263" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">在屏幕底部所示的视图控制器上显示一个选项卡栏。</li><li id="253e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">当用户点击标签栏按钮时，在各种视图控制器之间切换。</li></ul><p id="9b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">期望的结果是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/700dd08c2854d1b9b7a1644e0362e284.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/1*ojySR6UinAyvgEluNvSaog.gif"/></div></figure><p id="3a92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">达到这个结果的主要工具是由苹果公司提供的<a class="ae ky" href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html" rel="noopener ugc nofollow" target="_blank">包容API </a>。</p><p id="d58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其基本思想是，<code class="fe lv lw lx ly b">UIViewController</code>并不局限于包含视图。它也可以包含其他的<code class="fe lv lw lx ly b">UIViewControllers</code>。然后容器的责任是管理孩子，决定显示什么，什么时候，以及如何处理他们的交互。</p><p id="3ebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码方面，我们可以使用下面的代码片段将包容API的强大功能带到我们的选项卡栏中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段包含了扩展了<code class="fe lv lw lx ly b">UIViewController</code>类的<code class="fe lv lw lx ly b">TabBar</code>的声明。这是我们想要实现的所有其他视图控制器的容器。</p><p id="f08b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，在扩展中，我们可以定义两个函数来处理<code class="fe lv lw lx ly b">UIViewController</code>的孩子:<code class="fe lv lw lx ly b">add</code>和<code class="fe lv lw lx ly b">remove</code>。<code class="fe lv lw lx ly b">add</code>功能将新的视图控制器添加到层次结构中。为此，我们:</p><ol class=""><li id="110d" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nu nj nk nl bi translated">调用<code class="fe lv lw lx ly b">TabBar</code>的<code class="fe lv lw lx ly b">addChild</code>方法。</li><li id="5e5c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">设定儿童的框架。默认情况下，它将使用父对象的整个框架，但是我们可以自定义它来覆盖屏幕的不同部分。</li><li id="24b2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">将子视图添加到选项卡栏视图层次结构中。当添加一个新视图时，它将被放置在所有视图之上。因此，我们必须将它向后移动。</li><li id="19a2" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">通知子视图控制器它已经被移动到不同的父视图。</li></ol><p id="e5c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">remove</code>方法做相反的事情，顺序相反:</p><ol class=""><li id="e86f" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nu nj nk nl bi translated">它通知孩子它将搬到不同的父母那里。</li><li id="368d" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">它从层次结构中移除子视图。</li><li id="5217" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">它将子对象从当前父对象中移除。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7897" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">TabBar视图</h1><p id="7fba" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们从创建视图开始。我们需要展示一些用户可以与之交互的东西来使一切工作，并且它与<code class="fe lv lw lx ly b">TabBar</code>是独立的，所以这是一个很好的起点。</p><p id="2e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">TabBarView</code>由一组按钮组成，用户可以点击这些按钮从一个标签切换到另一个标签。我们将使用一个<code class="fe lv lw lx ly b">UICollectionView</code>来实现这个行为。集合中的每个按钮实际上都是一个<code class="fe lv lw lx ly b">TabBarCell</code>。</p><p id="5b45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选项卡栏在屏幕上的呈现方式取决于以下视图模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="dc13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视图模型由一组选项卡和所选选项卡的索引组成。为了简单起见，我决定只处理选项卡的标题。尽管如此，创建一个任意复杂的模型来保存不同州的图像、徽章、自定义颜色等其他属性还是很容易的。</p><p id="655b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，有一个实用方法来控制我们何时需要重新加载表。抽象这个细节很重要:它将数据重载与我们将来可能添加的其他行为分离开来，使代码更易于维护。</p><p id="d0d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于包含集合的视图来说，视图的代码是非常标准的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="060a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码比平常稍微长一点，但是很简单。让我们关注有趣的部分:</p><ul class=""><li id="80fb" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">在标有<code class="fe lv lw lx ly b">2</code>的部分，我们用一个<code class="fe lv lw lx ly b">lazy</code>变量声明集合视图。这样，集合创建一次，并在第一次使用属性时自动创建。然后，我们用数据源、委托和许多其他属性来配置<code class="fe lv lw lx ly b">UICollectionView</code>。最后，我们归还它。</li><li id="2d74" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">在标有<code class="fe lv lw lx ly b">7</code>的部分，我们访问视图模型，了解是否需要重新加载一些数据。</li><li id="e559" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">在标有<code class="fe lv lw lx ly b">8</code>的部分，我们布置了子视图。请注意，我们从<code class="fe lv lw lx ly b">safeAreaInsets.bottom</code>开始处理iPhone的缺口。</li></ul><h2 id="fccf" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">UICollectionViewDataSource和uicollectionview delegateflowlayout</h2><p id="8918" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在第<code class="fe lv lw lx ly b">3</code>节中，我们声明了一个不在任何地方使用的闭包。我们需要这个闭包来让<code class="fe lv lw lx ly b">TabBar</code>对用户输入做出反应。这是<code class="fe lv lw lx ly b">UICollectionViewDelegateFlowLayout</code>协议的一项任务。该协议的另一个任务是定义每个小区必须有多大。</p><p id="cde5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们必须实现<code class="fe lv lw lx ly b">UICollectionDataSource</code>委托，让集合知道它必须呈现多少项。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="97f5" class="nv mh it bd mi nw nx dn mm ny nz dp mq li oa ob ms lm oc od mu lq oe of mw og bi translated">将ViewController连接到视图</h2><p id="1e3f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">既然我们有了两种主料，让我们一起煮吧。首先，我们在<code class="fe lv lw lx ly b">Tabbar</code>中定义了一些助手属性和函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="560f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们实现了视图控制器的框架:我们定义了选项卡栏的主要属性(<code class="fe lv lw lx ly b">viewControllers</code>和<code class="fe lv lw lx ly b">selectedTab</code>)，我们实现了基本的视图控制器生命周期方法(<code class="fe lv lw lx ly b">loadView</code>和<code class="fe lv lw lx ly b">viewDidLoad</code>)，并且我们添加了一些助手方法:<code class="fe lv lw lx ly b">setupInteractions</code>来设置所有的用户交互，<code class="fe lv lw lx ly b">updateVM</code>来从单个点更新视图模型。</p><p id="6c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是将所有东西连接在一起，这样当<code class="fe lv lw lx ly b">TabBar</code>中的一个属性改变时，UI也会改变。要做到这一点，我们可以利用物业观察员。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="ece9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">viewControllers</code>属性的观察者非常简单。当视图控制器的数组改变时，我们更新视图模型。</p><p id="ed21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的部分来自于<code class="fe lv lw lx ly b">selectedTab</code>的观察者。当用户点击集合中的一个单元格时，此属性会更改。当这种情况发生时，我们:</p><ol class=""><li id="c946" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nu nj nk nl bi translated">检查用户是否点击了不同于当前单元格的单元格。</li><li id="2143" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">从标签栏中删除旧的孩子。</li><li id="59a8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">添加新的。</li><li id="978b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nu nj nk nl bi translated">更新用户界面。</li></ol><p id="a069" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第2步和第3步中，我们最终使用包容API来显示不同的视图控制器！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dccd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用TabBar</h1><p id="4fa2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在一切都连接好了，我们终于可以使用它了。在<code class="fe lv lw lx ly b">AppDelegate</code>中，我们可以用一堆标准的<code class="fe lv lw lx ly b">UIViewControllers</code>作为孩子来创建标签栏视图控制器。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常标准的<code class="fe lv lw lx ly b">AppDelegate</code>代码:我们创建了一个新的视图控制器，我们设置了几个变量(在我们的例子中，是<code class="fe lv lw lx ly b">viewControllers</code>和<code class="fe lv lw lx ly b">selectedTab</code>)，然后我们显示了窗口。</p><p id="6ae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在运行该应用程序，我们应该会观察到上面视频中显示的相同结果。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="05a6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="05ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">今天，我们探索了如何使用包容API将一个<code class="fe lv lw lx ly b">UIViewController</code>放入另一个。</p><p id="186c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用自定义选项卡栏的创建作为工作示例。不过，我们可以在任何组件上使用这个想法。假设您正在实现一个包含几个控件的复杂UX，每个控件都拥有一个非常复杂的逻辑。一个好主意是将该逻辑隔离在它自己的视图控制器中，并组合不同的视图控制器来实现令人惊奇但可维护的结果。</p><p id="37fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，如果你想知道为什么我们需要一个定制的标签栏，那么，并不是所有我们需要实现的行为都可以用默认的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/uikit/uitabbarcontroller" rel="noopener ugc nofollow" target="_blank">UITabBarController</a></code>轻松实现。有时我们想要更多的灵活性，最好的解决方案是自己实现。</p><p id="abc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://github.com/cipolleschi/CustomTabBar" rel="noopener ugc nofollow" target="_blank"> CustomTabBar存储库</a>中，你可以找到我们在本文中共同开发的所有代码，以及一些更多的特性:自定义标签栏高度和用漂亮的动画隐藏标签栏的可能性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/c946bc6c76de9384e05ebba72b623d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/1*uDvFEJFttHO7F1m9YhcHRw.gif"/></div></figure></div></div>    
</body>
</html>