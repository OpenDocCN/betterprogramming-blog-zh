<html>
<head>
<title>The Adapter Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的适配器模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-adapter-pattern-in-javascript-69c3f48ee164?source=collection_archive---------5-----------------------#2020-11-05">https://betterprogramming.pub/the-adapter-pattern-in-javascript-69c3f48ee164?source=collection_archive---------5-----------------------#2020-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1206" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用例子来帮助你实现它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f55f67cd3130ddcb7ee60068d19de804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eeDgyiq0ckk1XJTF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@daryan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Daryan Shamkhali </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="1f4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有遇到过以<code class="fe lv lw lx ly b">Adapter</code>作为函数后缀的代码？您可能正在阅读包含使用适配器模式的两个接口之间行为兼容性的代码。本文将介绍JavaScript中的适配器模式，并解释为什么该模式很重要，以及为什么它在现代编程中是有益的。</p><p id="d339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适配器的工作方式是您创建一个函数(可以是一个类，但不一定要实现为一个类)，让<em class="lz">无缝地将其接口的属性和方法适应</em>到一个新的类中——就好像适配器仍然可以被识别并像原来一样工作，同时能够与新的接口一起工作。</p><p id="8e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着JavaScript中的web技术不断发展，很容易看到这种模式在今天的开源项目中使用(例如<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/axios-mock-adapter"> axios-mock-adapter </a>)。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a9fc" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">看起来怎么样</h1><p id="1421" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">用JavaScript编写适配器模式没有正确的方法。然而，它们都有相同的目标:提供一个接口到另一个接口的兼容性。</p><p id="b3d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有一个函数，它接受一个对象列表(在接下来的例子中，我们将每个对象都称为<em class="lz">动作对象</em>)，并在将它们传递给另一个调用它们的每一个<code class="fe lv lw lx ly b">execute</code>方法的函数之前，将它们转换为数组中的<code class="fe lv lw lx ly b">Action</code>实例，那么如果想要保持兼容性，任何对实现的新介绍都应该遵循类似的接口。</p><p id="4e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看这些具有共同<code class="fe lv lw lx ly b">actionType</code>属性的动作对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1fac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定这些类别，我们定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="290f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个<code class="fe lv lw lx ly b">ActionChain</code>,它接受动作对象的数组，并为它们的执行做准备:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="0392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个动作都可以在我们的应用程序中顺利运行，因为它们都共享一个兼容的界面。</p><p id="e892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想在应用程序中引入一个新的动作，但使用更简洁和健壮的语法，如果新的实现在运行时破坏了你当前的程序，我们就必须记住这个信息。</p><p id="3ad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们在一家公司的前端工作，我们的团队经理想把<code class="fe lv lw lx ly b">pageJump</code>对象(比如<code class="fe lv lw lx ly b">{ actionType: "pageJump", destination: "/contact" }</code>)换成更短的语法，比如<code class="fe lv lw lx ly b">{ goto: "/contact" }</code>。如果我们在应用程序中做这个改变，那么我们的代码就会被破坏。这是因为我们的runner <code class="fe lv lw lx ly b">runActions</code>执行了新语法中不存在的<code class="fe lv lw lx ly b">execute</code>方法。</p><p id="d8e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过使用<em class="lz">适配器</em>支持<code class="fe lv lw lx ly b">goto</code>动作来解决这个问题，这样程序就可以以同样的方式运行。</p><p id="7f1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从创建一个扩展基础的类开始<code class="fe lv lw lx ly b">Action</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="bc25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe lv lw lx ly b">goto</code>基本上只是<code class="fe lv lw lx ly b">pageJump</code>的另一个版本(它们的最终目标是一样的)，我们可以定义一个不同的适配器，它可以接受两者中的任何一个，并返回可以在<code class="fe lv lw lx ly b">ActionChain</code>中运行的东西:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d8c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们就可以保持我们的<code class="fe lv lw lx ly b">pageJump</code>行为方式相同。不仅如此，我们还可以让他们使用<code class="fe lv lw lx ly b">goto</code>所具有的扩展方法(例如，可以随时访问<code class="fe lv lw lx ly b">this.history</code>并设置新的URL)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="c39c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以继续进一步开发该应用程序，同时避免在迁移一些旧代码时中断更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="48cf" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">其他示例</h1><p id="3e09" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我相信，更多来自不同角度的例子可以帮助开发人员更好地理解概念，所以这里有更多利用这种模式的例子。</p><h2 id="8228" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">计算器</h2><p id="18c9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">以下是摘自<a class="ae ky" href="https://gist.github.com/drenther/670720f4787a9ba4de967c0e8ee8cd7c" rel="noopener ugc nofollow" target="_blank">要点</a>的一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个计算器应用程序是使用<code class="fe lv lw lx ly b">OldCalculator</code>编写的，并且您想为它提供一种与<code class="fe lv lw lx ly b">NewCalculator</code>接口一起工作的方式，您需要某种方式来匹配<code class="fe lv lw lx ly b">NewCalculator</code>它们的行为方式是相同的。</p><p id="da88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的示例是使用解决该问题的适配器编写的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="183a" class="ng mi it bd mj nh ni dn mn nj nk dp mr li nl nm mt lm nn no mv lq np nq mx nr bi translated">Axios适配器</h2><p id="e596" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在本文的前面，我提到了axios-mock-adapter，它在代码中使用adapter模式，通过支持使用promises和原始回调方法来提供兼容性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="fdeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个很好的例子，因为它们的语法明显不同。然而，他们最终都实现了自己的目标。这很好！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="7212" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="0227" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这篇文章到此结束！我希望你觉得这个很有价值。展望未来！</p></div></div>    
</body>
</html>