<html>
<head>
<title>Building Two-Factor Authentication With NestJS and Postgres</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NestJS和Postgres构建双因素认证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-two-factor-authentication-with-nestjs-and-postgres-b5e49c7b4a79?source=collection_archive---------15-----------------------#2022-02-01">https://betterprogramming.pub/building-two-factor-authentication-with-nestjs-and-postgres-b5e49c7b4a79?source=collection_archive---------15-----------------------#2022-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c7f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">保护您的公司免受网络犯罪的侵害</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a4076c387f34524515b24b1fb779b7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o07bmbFQNp99MSbG.png"/></div></div></figure><p id="cc54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">近年来，针对公共和私营实体的网络犯罪和敌对行动变得越来越普遍。这种风险的增加解释了为什么许多软件公司为他们的客户账户增加了额外的安全层。</p><p id="d781" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2FA是一个额外的安全层，它确认试图进入一个在线帐户的人就是他们所说的那个人。必须首先输入用户的用户名和密码。然后，他们将被要求提供更多的细节，然后才被授予访问权限。这种方法将保护受损帐户免受欺诈活动的侵害。即使黑客发现了用户的密码，他们也无法登录到该帐户，因为他们缺少第二因素身份验证(<a class="ae lq" href="https://authy.com/what-is-2fa/" rel="noopener ugc nofollow" target="_blank"> 2FA </a>)代码。</p><p id="f6d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本教程将教你如何在一个<a class="ae lq" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>应用程序中实现2FA认证。随时从Github 获取<a class="ae lq" href="https://github.com/Claradev32/Nest2faAuthentication" rel="noopener ugc nofollow" target="_blank">代码。我们开始吧！</a></p><h1 id="c187" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">先决条件</h1><p id="a0f8" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">本教程是一个实践演示。要继续操作，请确保您安装了以下软件:</p><ul class=""><li id="7c0d" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">Nodejs是我们应用程序的运行时环境。</li><li id="b0d9" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">Postgres数据库 —我们将用户的记录保存在Postgres数据库中。</li><li id="3daf" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><a class="ae lq" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> Arctype </a> —我们将使用Postgres GUI来帮助用户验证。</li></ul><h1 id="6caa" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建嵌套应用程序</h1><p id="9c58" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们首先为我们的项目创建一个NestJS应用程序。在此之前，我们将使用以下命令安装Nest CLI:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="977f" class="nh ls it nd b gy ni nj l nk nl">npm i -g @nestjs/cli</span></pre><p id="f269" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，用下面的命令创建一个嵌套应用程序。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="52e1" class="nh ls it nd b gy ni nj l nk nl">nest new authentication<!-- -->Creating a new Nest application.</span></pre><p id="8988" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">继续下一步之前，请等待安装完成。</p><h1 id="ebaf" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">安装依赖项</h1><p id="7737" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，让我们安装这个项目的依赖项。我们将使用下面的命令从开发依赖项开始:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="3b40" class="nh ls it nd b gy ni nj l nk nl">npm i -D @types/bcrypt @types/nodemailer</span></pre><p id="29fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们将添加我们的其他依赖项。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5660" class="nh ls it nd b gy ni nj l nk nl">npm i bcrypt  @nestjs/jwt @nestjs-modules/mailer nodemailer hbs @nestjs/typeorm typeorm pg</span></pre><p id="48fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将需要一点时间来安装，所以等待它完成。完成后，就该为我们的应用程序建立数据库了。</p><h1 id="9dae" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">设置Postgres数据库</h1><p id="cec7" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">至此，我们已经安装了这个项目所需的所有依赖项。现在让我们继续设置我们的Postgres数据库。我们将使用TypeORM Postgres对象关系映射器将我们的应用程序连接到Postgres数据库。运行以下命令来设置Postgres数据库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/867ac37d52ed6f9b500a7f87fed7591a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/0*U2NZo9a5NQH_3l2B.png"/></div></figure><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="702a" class="nh ls it nd b gy ni nj l nk nl">sudo su - postgres<br/>psql<br/>create database  authentication</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/d10f223098ecdf8b72adb7b7792935e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oPBt8WSCY8iPvauq.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/6d2e618c34716c955bdfc69d84abcff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WrWDx5LI_dharwfQ.png"/></div></div></figure><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="da92" class="nh ls it nd b gy ni nj l nk nl">create user authentication with encrypted password authentication<br/>grant all privileges on database authentication to authentication</span></pre><p id="c294" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，打开<code class="fe np nq nr nd b">/src/app.module.ts</code>文件，导入<code class="fe np nq nr nd b">TypeOrmModule</code> <strong class="kw iu">、</strong>并使用<code class="fe np nq nr nd b">forRoot</code> <strong class="kw iu"> </strong>方法连接到数据库，代码片段如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="deb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，注意我们传入了<code class="fe np nq nr nd b">User</code>实体，但是还没有创建它。不要担心——我们将在后续部分创建这个实体。另外，请注意，我们使用了<code class="fe np nq nr nd b">forFeature()</code>方法来定义在当前范围内注册了哪个存储库，这让<code class="fe np nq nr nd b">TypeORM</code>知道了<code class="fe np nq nr nd b">User </code>实体。</p><p id="38c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们创建<code class="fe np nq nr nd b">User</code>实体来定义数据库中的模型。</p><h1 id="64d8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建用户实体</h1><p id="d964" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">此时，我们的应用程序连接到了Postgres数据库。现在我们将创建一个<code class="fe np nq nr nd b">User</code>实体来表示我们将存储在数据库中的用户数据。首先，在<code class="fe np nq nr nd b">src</code>文件夹中创建一个<code class="fe np nq nr nd b">app.entity.ts</code>文件，并添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0620" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们通过定义一个<code class="fe np nq nr nd b">User</code>类创建了一个实体。我们通过使用<code class="fe np nq nr nd b">Column</code>、<code class="fe np nq nr nd b">PrimaryGeneratedColumn</code>和<code class="fe np nq nr nd b">DateCreatedColumn</code>装饰器定义<code class="fe np nq nr nd b">User</code>实体的属性来实现这一点。<code class="fe np nq nr nd b">PrimaryGeneratedColumn</code>装饰器将使用<code class="fe np nq nr nd b"><a class="ae lq" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank">UUID</a></code>模块为用户生成随机id。我们将<code class="fe np nq nr nd b">unique</code>属性添加到我们的电子邮件<code class="fe np nq nr nd b">Column</code>中，以确保没有用户使用同一个电子邮件注册两次。最后，默认情况下，当创建一个记录时，<code class="fe np nq nr nd b">DateCreatedColumn</code>装饰器会添加一个日期。</p><p id="7dd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，打开<code class="fe np nq nr nd b"> app.module.ts</code>文件并导入<code class="fe np nq nr nd b"> User</code>实体。该导入解决了显示在<code class="fe np nq nr nd b">app.module.ts</code>文件上的错误。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f501" class="nh ls it nd b gy ni nj l nk nl">import { User } from './app.entity'</span></pre><p id="29e6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe np nq nr nd b">User</code>实体设置好了。现在，让我们创建控制器来处理用户的请求。</p><h1 id="3d5d" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建应用服务</h1><p id="0a26" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">至此，我们的用户实体设置完毕。现在，让我们通过设置路线处理函数来设置我们的应用程序服务。打开<code class="fe np nq nr nd b">app.service.ts</code>文件和所需的模块。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="822c" class="nh ls it nd b gy ni nj l nk nl">import { Injectable, HttpException, HttpStatus } from "@nestjs/common";<br/>import { User } from "./app.entity"<br/>import { InjectRepository } from '@nestjs/typeorm';<br/>import { Repository } from 'typeorm'<br/>import * as bcrypt from 'bcrypt';<br/>import { JwtService } from '@nestjs/jwt';<br/>import { MailerService } from '@nestjs-modules/mailer';</span></pre><p id="d1f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码片段中，我们导入了几个重要元素:</p><ul class=""><li id="350b" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated"><code class="fe np nq nr nd b">@Injectable</code>装饰器，它使我们的<code class="fe np nq nr nd b"> appService</code>类可以被嵌套IoC容器管理</li><li id="a362" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe np nq nr nd b">HttpException</code>，它让我们创建自定义错误</li><li id="7b8c" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe np nq nr nd b">HttpStatus</code>，发送自定义状态码</li><li id="83cd" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe np nq nr nd b">User</code>实体(如上所述)</li><li id="5718" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">和<code class="fe np nq nr nd b">InjectRepository</code>，它将我们的<code class="fe np nq nr nd b">User</code>实体注入到<code class="fe np nq nr nd b">appService</code>类中。</li></ul><p id="0e05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们还导入了<code class="fe np nq nr nd b">bcrypt</code>、<code class="fe np nq nr nd b"> JwtService</code>和<code class="fe np nq nr nd b">MailerService</code>，我们将在本节稍后的应用程序模块中对其进行配置。</p><p id="01c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们创建一个全局<code class="fe np nq nr nd b">code</code>变量来存储注册后发送给用户的随机验证码。我们生成一个随机代码并将其赋给code变量，然后创建<code class="fe np nq nr nd b">sendConfirmationEmail</code>和<code class="fe np nq nr nd b">sendConfirmedEmail</code>方法来向注册用户发送确认和验证电子邮件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="cc33" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们创建<code class="fe np nq nr nd b">signup</code>方法来处理用户的注册。我们使用下面的代码片段来实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="afed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe np nq nr nd b">signup</code>方法是一个异步函数，它在创建帐户时返回<code class="fe np nq nr nd b">true</code>。我们使用bcrypt <code class="fe np nq nr nd b">genSalt()</code>方法生成一个salt值，并使用<code class="fe np nq nr nd b">hash</code>方法散列用户的密码。然后，我们存储用户密码的散列版本，并使用<code class="fe np nq nr nd b">userRepository</code> insert方法创建一个新对象。接下来，我们调用<code class="fe np nq nr nd b">signin</code>方法，这是一个异步函数，通过下面的代码片段返回JWT令牌或HTTP异常:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1169" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe np nq nr nd b">signin</code>方法使用用户的电子邮件地址来检查他们的记录是否存在于我们的数据库中。如果找到了用户，我们使用bcrypt <code class="fe np nq nr nd b">compare</code>方法检查用户的密码是否与数据库中存储的散列密码相匹配。然后生成并向用户发送一个JWT令牌。如果没有匹配查询的记录，我们将返回相应的错误消息。</p><p id="48b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将创建一个<code class="fe np nq nr nd b">verify </code>方法，这是一个异步函数，当用户被验证时，它返回true或error。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="87b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的verify方法中，我们使用请求体中的代码在数据库中查询用户。如果没有用户匹配搜索，我们返回一个HTTP异常。否则，我们将用户的<code class="fe np nq nr nd b">isVerified</code>属性更新为<code class="fe np nq nr nd b">true</code>，并将<code class="fe np nq nr nd b">authConfirmToken</code>重置为未定义，使其为空。</p><p id="c0a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们打开<code class="fe np nq nr nd b">app.module.ts</code>文件并配置JwtService和MailerService。首先，导入<code class="fe np nq nr nd b">JwtModule</code>、<code class="fe np nq nr nd b">MailerModule</code>、<code class="fe np nq nr nd b">ConfigModule</code>和<code class="fe np nq nr nd b">HandlebarsAdapter</code>，我们将使用它们来配置我们的电子邮件模板。<code class="fe np nq nr nd b">ConfigModule </code>将使我们能够加载我们的环境变量，如JWT秘密，它将在本节稍后创建。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="4bc6" class="nh ls it nd b gy ni nj l nk nl">import { ConfigModule} from '@nestjs/config';<br/>import { JwtModule } from '@nestjs/jwt';<br/>import { MailerModule } from '@nestjs-modules/mailer';<br/>import { join } from 'path';<br/>import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';<br/>…</span></pre><p id="5a48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在项目根目录下创建一个<code class="fe np nq nr nd b">.env</code>文件来存储你的JWT秘密。您可以使用内置的加密模块生成一个。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="88b0" class="nh ls it nd b gy ni nj l nk nl">require('crypto').randomBytes(64).toString('hex')</span></pre><p id="3226" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并将生成的秘密存储在您创建的<code class="fe np nq nr nd b">.env</code>文件中。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="503d" class="nh ls it nd b gy ni nj l nk nl">JWT_SECRET = [your secret goes here]</span></pre><h1 id="9435" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">设置邮件模块</h1><p id="0e06" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">现在，将下面的代码片段附加到app module imports数组中，以加载环境变量。我们还将配置<code class="fe np nq nr nd b">JwtModule</code>、<code class="fe np nq nr nd b">MailerModule</code>和<code class="fe np nq nr nd b">HandlebarsAdapter</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="81a6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建应用控制器</h1><p id="51c6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">至此，我们的app服务设置完毕。现在让我们设置应用程序控制器来处理传入的请求。打开<code class="fe np nq nr nd b">app.controller.ts</code>文件，导入所需模块。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="750a" class="nh ls it nd b gy ni nj l nk nl">import { Controller, Get, Post, Render, Res, Body, HttpStatus, Req, Param } from '@nestjs/common';<br/>import { AppService } from './app.service';<br/>import { User } from './app.entity';<br/>import { JwtService } from '@nestjs/jwt</span></pre><p id="ca8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们将使用<code class="fe np nq nr nd b">@Controller</code>方法来定义我们的应用程序控制器。首先，我们将使用构造函数方法创建一个<code class="fe np nq nr nd b">AppController </code>类。我们为我们的<code class="fe np nq nr nd b">appService </code>类和<code class="fe np nq nr nd b">JwtService</code>类创建了两个私有参数。</p><p id="1631" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们创建我们的<code class="fe np nq nr nd b">Root </code>和<code class="fe np nq nr nd b">VerifyEmail </code>路由，它们将使用<code class="fe np nq nr nd b">@Get</code>装饰器监听一个<code class="fe np nq nr nd b">Get </code>请求，并呈现索引和验证模板，这将在本节稍后使用<code class="fe np nq nr nd b">@Render</code>装饰器进行设置。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="0e10" class="nh ls it nd b gy ni nj l nk nl">@Get()<br/> @Render('index')<br/> root() { }<br/><br/> @Get('/verify')<br/> @Render('verify')<br/> VerifyEmail() { }</span></pre><p id="e838" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们创建了<code class="fe np nq nr nd b">Signup </code>路由，它将监听到达<code class="fe np nq nr nd b">/signup</code>端点的Post请求。<code class="fe np nq nr nd b">Signup </code>控制器从用户的表单中获取输入，并将其与我们创建的用户实体进行匹配。然后它等待<code class="fe np nq nr nd b">appService </code>注册方法的结果，该方法将用户对象作为参数。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="640f" class="nh ls it nd b gy ni nj l nk nl">@Post('/signup')<br/> async Signup(@Body() user: User) {<br/>   return  await this.appService.signup(user);<br/> }</span></pre><p id="c95c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们创建了<code class="fe np nq nr nd b">Signin </code>路由，它将监听到达<code class="fe np nq nr nd b">/signin</code>端点的Post请求。<code class="fe np nq nr nd b">Signin </code>控制器从用户的表单中获取输入，并将其与我们创建的用户实体进行匹配。然后等待<code class="fe np nq nr nd b">appService</code> <code class="fe np nq nr nd b">signin</code>方法的结果，该方法也将用户对象form object作为参数。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="175d" class="nh ls it nd b gy ni nj l nk nl">@Post('/signin')<br/> async Signup(@Body() user: User) {<br/>  return await this.appService.signin(user);<br/> }<br/>…</span></pre><p id="56c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们创建一个<code class="fe np nq nr nd b">Verify </code>路由，并等待来自<code class="fe np nq nr nd b">appService</code> <code class="fe np nq nr nd b">verifyAccount</code>方法的结果，该方法将用户确认码作为参数。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="f330" class="nh ls it nd b gy ni nj l nk nl">@Post('/verify')<br/> async Verify(@Body() body) {<br/>   return await this.appService.verifyAccount(body.code)<br/> }<br/>…</span></pre><p id="a114" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，打开<code class="fe np nq nr nd b">main.ts</code>文件，删除样板代码，并在下面添加以下代码片段，以设置我们的<a class="ae lq" href="https://www.educative.io/edpresso/what-are-template-engines" rel="noopener ugc nofollow" target="_blank">模板引擎</a>和静态文件定向器，从而在我们的应用程序中启用<a class="ae lq" href="https://www.educative.io/edpresso/what-is-server-side-rendering" rel="noopener ugc nofollow" target="_blank">服务器端呈现</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h1 id="88b8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建电子邮件模板</h1><p id="0c92" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">配置好视图引擎和静态文件后，让我们开始创建模板。首先，在项目根目录下创建一个<code class="fe np nq nr nd b">views</code>文件夹，在<code class="fe np nq nr nd b">views </code>文件夹下创建一个<code class="fe np nq nr nd b">email-templates</code>文件夹。在视图文件夹中创建一个<code class="fe np nq nr nd b">index.hbs</code>和一个<code class="fe np nq nr nd b">verify.hbs</code>文件。然后在email-templates文件夹中创建一个<code class="fe np nq nr nd b">confirm.hbs</code>和<code class="fe np nq nr nd b">confirmed.hbs</code>文件。打开<code class="fe np nq nr nd b">view/index.hbs</code>文件并添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="158c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开<code class="fe np nq nr nd b">verify.hbs</code>文件，添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7c7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将下面的代码片段添加到<code class="fe np nq nr nd b">email-templates</code> / <code class="fe np nq nr nd b">confirm.hbs</code>文件中:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9cf2" class="nh ls it nd b gy ni nj l nk nl">&lt;p&gt;Hey {{ fullname }},&lt;/p&gt;<br/>&lt;p&gt;Verify your email with code below&lt;/p&gt;<br/>&lt;p&gt;Your verification code is: {{code}}&lt;/p&gt;<br/><br/>&lt;p&gt;If you did not request this email you can safely ignore it.&lt;/p&gt;</span></pre><p id="add5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并将下面的代码片段保存到<code class="fe np nq nr nd b">email-templates</code> / <code class="fe np nq nr nd b">confirmed.hbs</code>文件中。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1a50" class="nh ls it nd b gy ni nj l nk nl">&lt;p&gt;Hey {{ fullname }},&lt;/p&gt;<br/>&lt;p&gt;Your account for {{email}} has been confirmed!&lt;/p&gt;<br/><br/>&lt;p&gt;If you did not request this email you can safely ignore it.&lt;/p&gt;</span></pre><p id="1f88" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在项目根目录中为我们的静态文件创建一个<code class="fe np nq nr nd b">public</code>文件夹，然后在其中创建一个<code class="fe np nq nr nd b">js</code>文件夹。在其中，用下面的代码片段创建一个<code class="fe np nq nr nd b">index.js</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8481" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码片段向我们的<code class="fe np nq nr nd b">/signup</code>和<code class="fe np nq nr nd b">/verify</code>端点发出post请求，以注册并确认用户的电子邮件。</p><p id="7067" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，从这个项目的<a class="ae lq" href="https://github.com/Claradev32/Nest2faAuthentication/tree/master/public" rel="noopener ugc nofollow" target="_blank"> Github </a>资源库中获取其他静态文件，并将它们添加到public文件夹中。</p><h1 id="ad5a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">启用谷歌LSAA</h1><p id="8e91" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">随着我们的电子邮件模板设置，我们应该能够发送电子邮件给我们的用户。在本教程中，我们将使用Gmail发送电子邮件。因此，我们需要配置我们的Gmail帐户，以允许不太安全的应用程序访问电子邮件。按照以下步骤在您的Gmail帐户上启用LSAA。</p><ol class=""><li id="12a3" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp nu mu mv mw bi translated">打开Chrome。单击浏览器右上角的个人资料图标。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/e367e2a40afdd9f25cbfbbf847ab29d7.png" data-original-src="https://miro.medium.com/v2/0*MPPxJDWN5VKnzF9m"/></div></figure><ol class=""><li id="d2fc" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp nu mu mv mw bi translated">点击<strong class="kw iu">管理您的谷歌账户。</strong></li><li id="a0e5" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp nu mu mv mw bi translated">在搜索框中输入<strong class="kw iu"> less </strong>，点击<strong class="kw iu"> less secure app access。</strong></li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/da54df9b44ae51da54fc32e7fc669ca8.png" data-original-src="https://miro.medium.com/v2/0*gDAInXAFYXl7BANl"/></div></figure><ol class=""><li id="8e4d" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp nu mu mv mw bi translated">切换输入框上的<strong class="kw iu">允许不太安全的应用</strong>:以启用它。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/4bc80c6f21eea4a59d6b42ee8d40adfe.png" data-original-src="https://miro.medium.com/v2/0*WIcWqYWfsbtSxqPb"/></div></figure><p id="7574" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们运行应用程序并对其进行测试。</p><h1 id="1638" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">测试应用程序</h1><p id="593b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">至此，我们的应用程序已经准备好了。让我们来测试一下。在您的终端中，更改目录，使您位于authentication文件夹中，并使用下面的命令运行服务器。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="44b0" class="nh ls it nd b gy ni nj l nk nl">#Change directory<br/>cd authentication <br/><br/>#Start the server<br/>npm run start:dev</span></pre><p id="e788" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后转到<code class="fe np nq nr nd b"><a class="ae lq" href="http://localhost:3001/" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/</a></code>查看索引页面。您应该会看到如下所示的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/85d66d4c2e6aefa415ac935f37a8ad3b.png" data-original-src="https://miro.medium.com/v2/0*_hTdG6_sw1lZTLtF"/></div></figure><p id="fdd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">填写字段并注册。你会被要求验证你的帐户。检查您的电子邮件中的确认码。验证验证页面上的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nv"><img src="../Images/b8cbb4d4f394650a5acf2a5dfe01b06d.png" data-original-src="https://miro.medium.com/v2/0*ovjjIopR1dKWxvXe"/></div></figure><p id="f24d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">成功！根据需要，我们有一个可用的2FA应用程序。</p><p id="07ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">卡住了？有什么问题吗？如果需要，本教程的代码可以在Github上找到。</p><h1 id="a32a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="de9f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">通过构建一个演示项目，我们已经了解了如何在NestJS应用程序中实现2FA认证。我们从介绍2FA身份验证概念开始，并学习了如何创建一个将它们付诸实践的NestJS应用程序。</p><p id="882e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在您已经获得了您所寻求的知识，那么您将如何增加下一个NestJS项目的安全性呢？或许，你可以从<a class="ae lq" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank">官网</a>了解更多关于Nest的信息，并把事情做得更进一步。</p></div></div>    
</body>
</html>