<html>
<head>
<title>Building Responsive Rails Apps With Hotwire</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Hotwire构建响应式Rails应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-responsive-rails-apps-with-hotwire-507880df0f01?source=collection_archive---------3-----------------------#2022-07-24">https://betterprogramming.pub/building-responsive-rails-apps-with-hotwire-507880df0f01?source=collection_archive---------3-----------------------#2022-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cee6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本文中，我们将介绍Hotwire的基础知识，并使用Hotwire和Ruby on Rails构建一个示例应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/77f28b2cbc0b37ec158c87c5005dab1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zZPwV5_wj9ZOgU3AAVz-gw.jpeg"/></div></div></figure><p id="a967" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您正在使用Ruby on Rails开发现代的单页面应用程序，您很可能会使用一些花哨的JS框架来很好地更新您的UI，而不需要重新加载页面。如果不使用它们，你真的没什么可做的，这是当今的一种标准…直到Rails有了Hotwire。</p><p id="eded" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用Hotwire，您可以获得快速响应的web应用程序，而无需编写大量的JavaScript。听起来不错，但是热线是什么？</p><p id="ce20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我们将介绍Hotwire的基础知识，并使用它构建一个示例应用程序。</p><h1 id="b398" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">响应式Rails应用有哪些选项？</h1><p id="d807" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">2013年6月25日，Rails 4发布，引入了Turbolinks。Turbolinks为Rails的“响应”做了什么？Turbolinks拦截所有的链接点击，而不是发送常规的<code class="fe mk ml mm mn b">GET</code>请求，而是发送异步JavaScript请求(AJAX)来获取HTML。</p><p id="3c73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，它合并获取的页面的<code class="fe mk ml mm mn b">head</code>标签，并替换页面的整个<code class="fe mk ml mm mn b">body</code>标签，因此没有全页面重载。无需重新加载样式表或脚本，这意味着更快的页面导航。但它仍然替换了整个<code class="fe mk ml mm mn b">body</code>，而不仅仅是改变了页面的一部分。</p><p id="d822" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果您只想重新加载发生变化的部分呢？嗯，当你将一些元素标记为<code class="fe mk ml mm mn b">data-remote='true'</code>时，你可以使用Rails AJAX帮助器，这使得那些元素发送AJAX <code class="fe mk ml mm mn b">GET/POST</code>请求，而不是常规的<code class="fe mk ml mm mn b">GET/POST</code>请求。Rails用生成的JS代码进行响应，然后由浏览器执行这些代码来动态更新页面的这些部分。</p><p id="43f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们可以在前端使用一些JS组件(例如，使用React ),让应用程序感觉更加灵敏。因此，JS组件发送一个AJAX请求，Rails服务器用JSON数据响应它。然后前端框架将收到的JSON转换成DOM元素，并更新DOM以反映这些变化。它工作得很好，唯一的缺点是它在页面上混合了服务器端呈现和客户端呈现。</p><p id="3c1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一种更传统的方式是在前端使用React、Vue或另一个JS框架，只使用客户端渲染，即所谓的单页面应用程序(SPA)。使用这种方法，前端是一个向Rails服务器发送AJAX请求的独立应用程序，Rails只是一个JSON API。您可能知道，构建、维护和部署两个具有可互换数据的独立应用程序非常复杂。</p><p id="99b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，如果您可以构建一个SPA，而不需要构建两个独立的应用程序和编写大量Javascript代码，那会怎么样呢？以下是Hotwire可以帮助您解决的问题。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="5a5a" class="ln lo iq bd lp lq mv ls lt lu mw lw lx jw mx jx lz jz my ka mb kc mz kd md me bi translated">什么是Hotwire？</h1><p id="af0e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Hotwire是构建类似SPA的web应用程序的另一种方法，它使用Rails模板呈现所有的HTML服务器端，同时保持应用程序快速响应。</p><p id="a374" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将渲染保持在服务器端会使您的开发体验更简单、更高效。Hotwire name基本上是<code class="fe mk ml mm mn b">HTML Over the Wire</code>的缩写，意思是将生成的HTML而不是JSON从服务器发送到客户端。</p><p id="bdbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它也不需要您编写太多定制的javascript代码。热线由涡轮和刺激组成。</p><h1 id="4d2e" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">什么是涡轮增压？</h1><p id="55a0" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">涡轮宝石是热线的心脏。这是一组动态更新页面的技术，通过将页面划分为可以利用WebSockets作为传输工具进行部分更新的组件，加快了导航和表单提交的速度。如果您曾经在Rails中使用过WebSockets，您很可能知道Rails正在使用ActionCable来处理WebSockets连接，默认情况下它包含在Rails中。而<code class="fe mk ml mm mn b">Trubo</code> gem由Turbo Drive、Turbo Frames和Turbo Streams组成。</p><h1 id="03a4" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">涡轮驱动</h1><p id="ba1c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Turbo Drive用于拦截链接点击(就像Turbolinks以前做的那样)和拦截表单提交。</p><p id="c17d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，Turbo Drive合并页面的head标签，并替换页面的body标签。Turbolinks的情况也是如此——没有全页面重新加载，这对于某些页面来说可能很快，但并不像2022应用程序预期的那样响应迅速。所以你可以考虑只更新页面的某些部分，而不是整个页面。这就是涡轮框架派上用场的地方。</p><h1 id="ddd2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">涡轮框架</h1><p id="880a" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">您可以简单地将页面的一部分变成Turbo Fram——只需用一个具有唯一id的turbo-frame标签将它包装起来:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="7e71" class="ne lo iq mn b gy nf ng l nh ni">&lt;turbo-frame id=”13"&gt;<br/>…<br/>&lt;/turbo-frame&gt;</span></pre><p id="2d24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得框架内的任何交互都局限于该框架。该框架内的任何交互都向Rails服务器发送一个AJAX请求，服务器只为该框架响应一个HTML。</p><p id="b7ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它允许Turbo只自动替换页面上的该帧。这不需要编写任何JavaScript。但是如果你想同时更新页面的多个部分呢？这就是Turbo Streams可以帮助你的地方。</p><h1 id="6759" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">涡轮流</h1><p id="afbe" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">当用户与页面上的元素(如表单/链接)交互时，Turbo Drive向服务器发送一个AJAX请求，服务器用一个包含Turbo流元素的HTML进行响应。这些就像是Turbo要遵循的方向，以便更新页面中受影响的部分。</p><p id="553f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Turbo Streams包括七个可用动作:<code class="fe mk ml mm mn b">append, prepend, (insert) before, (insert) after, replace, update, and remove</code>:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="8045" class="ne lo iq mn b gy nf ng l nh ni">&lt;turbo-stream action="append" target="target_a"&gt;<br/>  &lt;template&gt;<br/>    HTML<br/>  &lt;/template&gt;<br/>&lt;/turbo-stream&gt;<br/>&lt;turbo-stream action="prepend" target="target_b"&gt;<br/>  &lt;template&gt;<br/>    HTML<br/>  &lt;/template&gt;<br/>&lt;/turbo-stream&gt;<br/>&lt;turbo-stream action="replace" target="target_c"&gt;<br/>  &lt;template&gt;<br/>    HTML<br/>  &lt;/template&gt;<br/>&lt;/turbo-stream&gt;</span></pre><p id="f219" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Turbo Streams使用ActionCable通过WebSockets异步向多个客户端交付更新。同样，您无需编写任何Javascript代码就能获得所有这些。但是，即使您出于任何原因需要一些定制的Javascript(例如，一些动画、日期选择器等)。)，Hotwire给你提供了刺激。</p><h1 id="fd33" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">什么是刺激？</h1><p id="7965" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">就像Rails拥有带动作的控制器一样，Stimulus允许您以类似的方式组织客户端代码。你有一个控制器，它是一个Javascript对象，定义了动作，也就是Javascript函数。然后，使用HTML属性将控制器动作连接到页面上的交互式元素。然后，当DOM事件被触发时，该操作将作为响应运行。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="dc2e" class="ln lo iq bd lp lq mv ls lt lu mw lw lx jw mx jx lz jz my ka mb kc mz kd md me bi translated">让我们用Hotwire创建一个示例Rails应用程序</h1><p id="7764" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在读完了以上所有内容，你可能会想:我该如何使用它呢？Hotwire使用起来非常简单，我们所需要的只是一个标准的Rails应用程序和Redis服务器。首先，您需要安装Ruby 3和Rails 7以及Redis服务器。</p><blockquote class="nj nk nl"><p id="9fe5" class="kr ks nm kt b ku kv jr kw kx ky ju kz nn lb lc ld no lf lg lh np lj lk ll lm ij bi translated">我不打算介绍它们的安装过程，但是您可以根据您的平台轻松找到您需要的任何说明。</p></blockquote><p id="489a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们建立一个新的Rails应用程序(我们将使用Bootstrap作为CSS选项，只是为了让我们的应用程序看起来更好一点):</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="313f" class="ne lo iq mn b gy nf ng l nh ni">rails new bookstore --css bootstrap</span></pre><p id="78a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rails生成所有需要的文件后，将cd放入app目录:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="eae4" class="ne lo iq mn b gy nf ng l nh ni">cd bookstore</span></pre><p id="a14b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rails 7初始应用程序拥有我们开始使用Hotwire所需的一切，gem文件包括Redis gem、Turbo-rails gem和Stimulus-rails。</p><p id="eb5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确保您已经启动并运行了Redis服务器。Redis是必需的，因为ActionCable使用它来存储websockets相关的信息。Rails连接Redis服务器的默认地址和端口在<code class="fe mk ml mm mn b">config/cable.yml</code>中设置</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="b9dc" class="ne lo iq mn b gy nf ng l nh ni">development:<br/>  adapter: redis<br/>  url: redis:<em class="nm">//localhost:6379/1</em></span></pre><p id="5695" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们可以生成我们的模型、控制器和迁移，在我们的<code class="fe mk ml mm mn b">Bookstore</code>案例中是<code class="fe mk ml mm mn b">Books</code>。它将有一个字符串标题，类型文本的描述，并喜欢计数器作为一个整数:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="d95b" class="ne lo iq mn b gy nf ng l nh ni">rails g scaffold books title:string description:text likes:integer</span></pre><p id="d9ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们修复生成的迁移，这样我们添加到数据库的任何书默认都有0个赞:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="ea41" class="ne lo iq mn b gy nf ng l nh ni">class CreateBooks &lt; ActiveRecord::Migration[7.0]<br/>  def change<br/>    create_table :books do |t|<br/>      t.string :title<br/>      t.text :description<br/>      t.integer :likes, default: 0<br/>      t.timestamps<br/>    end<br/>  end<br/>end</span></pre><p id="61c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要忘记为我们的应用程序创建一个数据库，并在终端中运行:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="c872" class="ne lo iq mn b gy nf ng l nh ni">rake db:create db:migrate</span></pre><p id="b7b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将<code class="fe mk ml mm mn b">books</code>列表页面设为应用的根页面，打开<code class="fe mk ml mm mn b">config/routes.rb</code>，添加缺失的根声明:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="3d7e" class="ne lo iq mn b gy nf ng l nh ni">Rails.application.routes.draw do<br/>  root 'books#index'<br/>  resources :books<br/>end</span></pre><p id="51cc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，您应该能够在您的终端中使用<code class="fe mk ml mm mn b">rails server</code>命令或<code class="fe mk ml mm mn b">./bin/dev</code>(它也将监视CSS和JavaScript的变化)运行rails服务器，当您在浏览器中访问<a class="ae nq" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>时，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/f6b0fcae5f7d10c121e9482cb73a2a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*BCf_JtppzbwZUuan.png"/></div></figure><p id="24c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把<code class="fe mk ml mm mn b">Book</code>部分<code class="fe mk ml mm mn b">app/views/books/_book.html.erb</code>改成这样:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="1770" class="ne lo iq mn b gy nf ng l nh ni">&lt;%= turbo_stream_from "book_#{book.id}" %&gt;<br/>&lt;%= turbo_frame_tag "book_#{book.id}" do %&gt;<br/>  &lt;div style="background: lightblue; padding: 10px; width: 400px;"&gt;<br/>    &lt;h2&gt;&lt;%= book.title %&gt;&lt;/h2&gt;<br/>    &lt;p&gt;&lt;%= book.description %&gt;&lt;/p&gt;<br/>    &lt;br&gt;<br/>    &lt;%= button_to "Like (#{book.likes})", book_path(book, book: { likes: (book.likes + 1) }), method: :put %&gt;<br/>  &lt;/div&gt;<br/>  &lt;br/&gt;<br/>&lt;% end %&gt;</span></pre><p id="c146" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mk ml mm mn b">turbo_stream_from</code>告诉Hotwire使用WebSocket更新用<code class="fe mk ml mm mn b">:book_id</code>标识的帧，而<code class="fe mk ml mm mn b">turbo_frame_tag</code>标识一个帧，该帧可以在更新时被部分替换。</p><p id="920b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了告诉Turbo我们想要将每本新创建的书添加到书籍列表的开头，并在每次点击like按钮时更新like计数，我们需要将以下回调添加到<code class="fe mk ml mm mn b">app/models/book.rb</code>文件(也让我们添加一个验证):</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="c034" class="ne lo iq mn b gy nf ng l nh ni">class Book &lt; ApplicationRecord<br/>  after_create_commit { broadcast_prepend_to :books }<br/>  after_update_commit { broadcast_replace_to "book_#{id}" }<br/>  validates :title, :description, presence: true<br/>end</span></pre><p id="0fb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个告诉Turbo在创建时使用<code class="fe mk ml mm mn b">:books</code> Turbo Stream进行更新，第二个告诉使用<code class="fe mk ml mm mn b">:book_id</code>用更新替换部分更新。</p><p id="7325" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后让我们修复books控制器中的排序，并在<code class="fe mk ml mm mn b">app/controllers/books_controller.rb</code>中添加新的book变量赋值(这样我们可以从根路径创建一本书):</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="a38c" class="ne lo iq mn b gy nf ng l nh ni">...<br/>def index<br/>  @books = Book.order(created_at: :desc)<br/>  @book = Book.new<br/>end<br/>...</span></pre><p id="2502" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还应该编辑<code class="fe mk ml mm mn b">app/views/books/index.html.erb</code>来添加我们的涡轮流和涡轮帧:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="5c66" class="ne lo iq mn b gy nf ng l nh ni">&lt;h1&gt;Books&lt;/h1&gt;<br/>&lt;%= turbo_stream_from :books %&gt;<br/>&lt;%= turbo_frame_tag :book_form do %&gt;<br/>  &lt;%= render 'books/form', book: @book %&gt;<br/>&lt;% end %&gt;<br/>&lt;%= turbo_frame_tag :books do %&gt;<br/>  &lt;%= render @books %&gt;<br/>&lt;% end %&gt;</span></pre><p id="aba2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了避免在我们创建一本新书或更新现有书籍并停留在同一个主页上时发生重定向，我们还需要编辑<code class="fe mk ml mm mn b">app/controllers/books_controller.rb</code>中的创建和更新动作:</p><pre class="kg kh ki kj gt na mn nb nc aw nd bi"><span id="b8da" class="ne lo iq mn b gy nf ng l nh ni">...<br/>def create<br/>  @book = Book.new(book_params)<br/>  respond_to do |format|<br/>    if @book.save<br/>      format.html { redirect_to root_path }<br/>    else<br/>      format.turbo_stream { render turbo_stream: turbo_stream.replace(@book, partial: 'books/form', locals: { book: @book }) }<br/>      format.html { render :new, status: :unprocessable_entity }<br/>    end<br/>  end<br/>end<br/><br/>def update<br/>  respond_to do |format|<br/>    if @book.update(book_params)<br/>      format.html { redirect_to root_path }<br/>    else<br/>      format.html { render :edit, status: :unprocessable_entity }<br/>    end<br/>  end<br/>end<br/>...</span></pre><p id="8b0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此时，我们的书店应用程序应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/c70c8c8014783c3731ff884dc954b6ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bwTPSXmYUrGJm-dG.png"/></div></div></figure><h1 id="8fce" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">结论</h1><p id="2eb7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">每当您使用主页上的表单创建新书时，Turbo会将其添加到图书列表中，无需重新加载页面。如果您在浏览器中打开多个标签，将会更新所有标签。</p><p id="02b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“喜欢”按钮也可以在不重新加载页面的情况下工作，并在所有标签中更新图书的喜欢数。所有这些都没有一行Javascript代码。多酷啊。</p><p id="358e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个示例应用程序只是一个基本的例子，展示了如何在Rails中使用Hotwire，但是您可以使用Turbo和Stimulus做更复杂的事情。因此，如果你想用Rails创建一个新的SPA，请三思是否需要React、Vue或任何其他前端框架，尝试一下Hotwire可能会更有成效。这很有可能会让你开心。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="d6a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nm">原载于</em><a class="ae nq" href="https://aleksulanov.com/posts/hotwire-intro/" rel="noopener ugc nofollow" target="_blank"><em class="nm">https://aleksulanov.com</em></a></p></div></div>    
</body>
</html>