<html>
<head>
<title>How to Make Your TypeScript Generic Functions Safer and Easier to Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使您的TypeScript泛型函数更安全、更易于使用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/figuring-types-in-typescript-generic-functions-9479dd2fc3ea?source=collection_archive---------2-----------------------#2022-03-18">https://betterprogramming.pub/figuring-types-in-typescript-generic-functions-9479dd2fc3ea?source=collection_archive---------2-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1f27" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">找出TypeScript泛型函数中的类型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/879d244603d7ee2f71b76871a60ba87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4GmbUCN8xmej_-Frd0c8Kg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">穆罕默德·拉赫马尼在<a class="ae kv" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="13c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于来自JavaScript世界的人来说，在Typescript中正确使用类型可能会非常令人困惑(如果不是疯狂和令人震惊的话)。我们公司不久前才开始从JavaScript迁移到TypeScript，所以大多数开发人员仍在学习如何使用它(包括我自己)。对于一些人来说，这篇文章可能是微不足道的，但对我来说，这是一个真正的挑战。我相信分享关于挑战性事物的经验和知识是我们所能做的最好的事情，因为它可以帮助面临同样挑战的人。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e40f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题</h1><p id="620e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">因此，有一次，当对来自另一个团队的合并请求进行代码审查时，我和我的同事偶然发现了这两个特殊的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7764" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们跳过对它们实际代码的回顾，这与本文并不相关，它们本质上是对象的转换器，通过这个对象键将某个对象的值映射。引起我们注意的不是函数的内部，而是这些函数使用TS类型的方式。我和我的同事立即发现了这些函数类型的缺陷，这要归功于我们以前分别在Kotlin和C++中的经验。</p><p id="5fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些函数应该是这样使用的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="772c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是来自同一个合并请求的真实函数，但是名字和对象结构已经被改变了——对不起，NDA让我这么做的，☹️</p><h2 id="3769" class="my ma iq bd mb mz na dn mf nb nc dp mj lf nd ne ml lj nf ng mn ln nh ni mp nj bi translated">总之在这里我们看到两个主要问题:</h2><ol class=""><li id="0f23" class="nk nl iq ky b kz mr lc ms lf nm lj nn ln no lr np nq nr ns bi translated">我们没有安全参数——我们可以将“blah”和“blahblah”作为参数传递给我们的<code class="fe nt nu nv nw b">mapByKey</code>函数，Typescript不会阻止我们这样做。</li><li id="46fe" class="nk nl iq ky b kz nx lc ny lf nz lj oa ln ob lr np nq nr ns bi translated">我们必须做<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-assertions" rel="noopener ugc nofollow" target="_blank">类型断言</a>来“平息”类型脚本，这增加了出错的巨大风险。这是因为TS将把<code class="fe nt nu nv nw b">result</code>变量作为任何<code class="fe nt nu nv nw b">T[keyof T]</code>到任何<code class="fe nt nu nv nw b">T[keyof T]</code>的<code class="fe nt nu nv nw b">Map</code>(在这个例子中<code class="fe nt nu nv nw b">T[keyof T]</code>将是<code class="fe nt nu nv nw b">string | Date | { name: string } | number</code>)，并且任何满足那些类型的类型断言将是“合法的”。</li></ol><p id="f1ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不确定这一切意味着什么，我推荐你阅读一些关于操作符的<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/keyof-types.html" rel="noopener ugc nofollow" target="_blank">键和</a><a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>的类型文档。</p><h1 id="e109" class="lz ma iq bd mb mc oc me mf mg od mi mj jw oe jx ml jz of ka mn kc og kd mp mq bi translated">局部解决</h1><p id="aa1a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们想到的第一个解决方案不是在我们的<code class="fe nt nu nv nw b">mapByKey</code>函数中使用<code class="fe nt nu nv nw b">string</code>类型，而是使用<code class="fe nt nu nv nw b">keyof T:</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5657" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它肯定会帮助Typescript防止我们犯拼写错误:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="71ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来已经好多了，但是第二个问题我们该怎么办呢？我们如何摆脱这种类型断言，让代码更安全？我们如何“告诉”Typescript那些函数中的结果<code class="fe nt nu nv nw b">Map</code>包含的不是一些抽象的<code class="fe nt nu nv nw b">keyof T</code>元素，而是我们100%确定的类型(因为我们知道我们传递给函数的对象的“键”是什么，并且我们从对象结构中知道它们的类型)。</p><h1 id="e126" class="lz ma iq bd mb mc oc me mf mg od mi mj jw oe jx ml jz of ka mn kc og kd mp mq bi translated">真正的解决方案</h1><p id="6e99" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">经过一番挖掘和头脑风暴(以及长时间的绝望)，我们终于找到了解决方案——我们需要添加更多的通用参数，并使用带约束的<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints" rel="noopener ugc nofollow" target="_blank">类型参数</a>。这样，Typescript将能够知道函数参数的确切类型。我们的函数现在看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3af4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在使用它们变得更加容易和安全:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a001" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，Typescript处于警戒状态，甚至正在帮助我们编写代码！</p><h1 id="33ee" class="lz ma iq bd mb mc oc me mf mg od mi mj jw oe jx ml jz of ka mn kc og kd mp mq bi translated">结论</h1><p id="25b2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">泛型和其他概念可能很可怕，但是要努力让Typescript成为你的朋友，而不是你的敌人。广泛探索Typescript <a class="ae kv" href="https://www.typescriptlang.org/docs/" rel="noopener ugc nofollow" target="_blank">文档</a>和其他资源，不要害怕尝试一些东西，也不要因为某些东西不起作用而失去动力。最终它肯定会解决的。当它到来时，它将为你创造奇迹。</p></div></div>    
</body>
</html>