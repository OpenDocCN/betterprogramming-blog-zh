<html>
<head>
<title>How to “bake” a Javascript HTML Template Engine in Three Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用三行代码“烘焙”一个Javascript HTML模板引擎</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-bake-a-javascript-html-template-engine-in-just-three-lines-of-code-669fd718c2d?source=collection_archive---------8-----------------------#2022-07-18">https://betterprogramming.pub/how-to-bake-a-javascript-html-template-engine-in-just-three-lines-of-code-669fd718c2d?source=collection_archive---------8-----------------------#2022-07-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8464" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用正则表达式、模板字符串和动态函数以简单快速的方式管理HTML模板字符串</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/578be0bec8e5075298fa94813cd8cd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55EtCtVWAbYXM2o9xQKGFw.jpeg"/></div></div></figure><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="c303" class="kw kx iq ks b gy ky kz l la lb"><strong class="ks ir">Ingredients: </strong>Function class, Regular Expressions, Template Literals, and some curiosity</span><span id="d7f0" class="kw kx iq ks b gy lc kz l la lb"><strong class="ks ir">Cooking time: </strong>10 minutes</span></pre><p id="902f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">网上有几种JavaScript模板引擎。从强调性能的到强调语法和代码可理解性的。</p><p id="fa06" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">除了这些方面，对于大量使用文本模板的项目来说，有一些非常好的产品绝对是理想的选择。</p><p id="37ad" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当然，它不会是用三行代码编写的东西来与更强大的系统竞争，但是考虑从模板开始产生文本的其他机制可能是有用和有趣的。</p><p id="ce72" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">此外，菜单上做出来的东西可能会很有趣。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="3bb7" class="mg kx iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">基本原则</h1><p id="e244" class="pw-post-body-paragraph ld le iq lf b lg mx jr li lj my ju ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">通常模板引擎提供自己的语法，用来调用特定的操作，比如一个<code class="fe nc nd ne ks b">for</code>循环，允许我们通过改变迭代中涉及的变量值来重复文本。有了自己的语法，通常每个引擎都必须实现一个解析器和其他功能，以便能够正确地解释指令，从而在输出中产生我们期望的文本。</p><p id="316a" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">但是，文章标题讲的是三行代码。那么，怎么可能只用三行代码就实现一个解析器和引擎所需的所有功能呢？嗯…这是不可能的，但这不是问题。</p><p id="be3b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">事实上，我们已经有了一个非常好的解释器，它是我们代码运行的JavaScript运行时。如果我们添加ES6的模板字符串和一些正则表达式，这里我们就有了紧凑引擎的所有成分。</p><p id="cfa8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有关更多详细信息:</p><ul class=""><li id="7a0e" class="nf ng iq lf b lg lh lj lk lm nh lq ni lu nj ly nk nl nm nn bi translated"><a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字(模板字符串)MDN </a></li><li id="4ac2" class="nf ng iq lf b lg np lj nq lm nr lq ns lu nt ly nk nl nm nn bi translated"><a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">正则表达式MDN </a></li></ul><p id="e786" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">假设我们有一个数据结构，我们需要通过向其中注入值来生成一些HTML代码，并且还必须重复代码块。显然，每个重复的代码块都必须注入从源数据中读取的不同值。</p><p id="1680" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">数据结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0e15" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们希望实现的目标:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="134f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">显然，解决方案不是创建一个简单的JavaScript函数，而是编写一些连接字符串的代码，读取传递的数据。当然，这种类型的解决方案会产生很好的结果，但是它一点也不通用，而且它与模板引擎的概念相去甚远。</p><p id="65dd" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们希望将模板放在包含一些文本的JavaScript字符串中，在本例中是HTML代码，以及一些可以对数据执行迭代和其他典型语言操作的JavaScript代码。</p><p id="63e8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">哦，我忘了，我们甚至不想写解析器！(至少今天不会)。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="0990" class="mg kx iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">食谱</h1><p id="e3a5" class="pw-post-body-paragraph ld le iq lf b lg mx jr li lj my ju ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">让我们考虑初始数据和我们想要获得的结果，尝试分解相关的部分。</p><p id="31b8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们有了想要在输出中生成的第一条数据:电视剧标题。在这种情况下，这是一个“一次性”脚本，只需要在一个<code class="fe nc nd ne ks b">&lt;div&gt;</code>标签中注入<code class="fe nc nd ne ks b">title</code>属性的值。</p><p id="6af4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的模板可能像这样开始:</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="e3c2" class="kw kx iq ks b gy ky kz l la lb">&lt;div class="title"&gt;{= data.title =}&lt;/div&gt;</span></pre><p id="e70e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们立即注意到在标记中使用了特定的语法，反过来，在标记中使用了典型的JavaScript表达式来访问名为<code class="fe nc nd ne ks b">data</code>的对象的<code class="fe nc nd ne ks b">title</code>属性。</p><p id="79d5" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们立即分析这些首要元素:</p><p id="2efc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">语法<code class="fe nc nd ne ks b">{= ... =}</code>允许我们在模板中引入一条指令，以便解析一个值，从传递的数据中读取该值，并调用下一代。</p><p id="1aeb" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">标识符<code class="fe nc nd ne ks b">data</code> <strong class="lf ir"> <em class="nw"> </em> </strong>是指被传递对象的根，可以是JavaScript对象、数组或任何其他值。在我们的例子中，它是一个包含第一个属性<code class="fe nc nd ne ks b">title</code>的对象，我们感兴趣的是将它解析为一个插入到输出中的值。</p><blockquote class="nx ny nz"><p id="1269" class="ld le nw lf b lg lh jr li lj lk ju ll oa ln lo lp ob lr ls lt oc lv lw lx ly ij bi translated">使用<code class="fe nc nd ne ks b">{=</code>和<code class="fe nc nd ne ks b">=}</code>作为分隔符的选择完全是任意的。只要不与模板的其他部分冲突，您可以使用任何想要的字符组合。也就是说，模板中其他可能的元素不需要转换就可以在输出中结束。<br/>例如，如果我们简单地使用字符<code class="fe nc nd ne ks b">&lt;</code>和<code class="fe nc nd ne ks b">&gt;</code>，那么区分一个值的占位符就比区分一个输出HTML标签更加困难。</p></blockquote><p id="2db4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">此时，我们需要转换“tv series”对象的子元素，滚动剧集名称并将它们插入到一个<code class="fe nc nd ne ks b">div</code>标签内的输出中。</p><p id="3cea" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">但是在我们决定子元素必须驻留在表示剧集列表的额外的<code class="fe nc nd ne ks b">div</code>标签中之前。因此，我们应该将以下开始标记添加到模板中:</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="71d8" class="kw kx iq ks b gy ky kz l la lb">&lt;div class="episodes-list"&gt;</span></pre><p id="ed5e" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这一部分将在输出中打印出来，不做任何转换。</p><p id="ee5d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">下一个零件的不同条件将不得不同于模板中表达的内容。我们必须声明一个包含剧集编号的变量(将通过在循环中递增变量来动态计算)，为了滚动剧集，我们需要一些JavaScript代码作为循环<code class="fe nc nd ne ks b">for..of</code>。</p><p id="f6d6" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在我们的模板中，我们将添加变量和<code class="fe nc nd ne ks b">for..of</code>构造的初始部分:</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="f88d" class="kw kx iq ks b gy ky kz l la lb">let episodeNumber = 1;<br/>for (let episodeName of data.episodes) {</span></pre><p id="b481" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们再次引用主对象<code class="fe nc nd ne ks b">data</code>，浏览包含在<code class="fe nc nd ne ks b">episodes</code>属性中的数组。</p><p id="fe3d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在循环内部，我们应该打印带有剧集号和<code class="fe nc nd ne ks b">episodeName</code>相对值的HTML代码，作为迭代的第n个元素。</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="f993" class="kw kx iq ks b gy ky kz l la lb">&lt;div class="episode-name"&gt;&lt;span&gt;{= episodeNumber =}&lt;/span&gt;&lt;span&gt;{= episodeName =}&lt;/span&gt;&lt;/div&gt;</span></pre><p id="719a" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们递增变量，并通过关闭<code class="fe nc nd ne ks b">for..of</code>构造来结束:</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="1cfc" class="kw kx iq ks b gy ky kz l la lb">episodeNumber++;<br/>}</span></pre><p id="a4af" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最后，我们还关闭章节列表的<code class="fe nc nd ne ks b">div</code>标签，在<code class="fe nc nd ne ks b">for..of</code>循环之前打开。</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="c331" class="kw kx iq ks b gy ky kz l la lb">&lt;/div&gt;</span></pre><p id="18a4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">将所有这些放在一起，让我们想象我们已经构建了以下模板:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a46d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">乍一看，这似乎没什么问题，但是这样一来，我们的“引擎”还不能区分输出文本和JavaScript代码，所以我们必须后退一小步，通过插入一个分隔符(一个或多个字符)来修改我们的模板，该分隔符指示从静态文本到JavaScript指令的转换，反之亦然。</p><p id="0cd8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">选择这样一个分隔符的标准可以根据几个因素而变化，比如输出文本的类型(HTML或其他)或者我们的文本所在的位置(在一个外部HTML文件中，在一个多行JavaScript字符串中，等等)。</p><p id="4028" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对于这个特定的简单例子，我选择使用字符序列<code class="fe nc nd ne ks b">##</code>，因为它在视觉上突出了从HTML代码到JavaScript代码的过渡，并且因为它几乎不会与任何其他代码冲突。<br/>此时，我们的模板应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="edff" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">或者，如果我们发现它更具可读性(这两个代码块是等效的)，也可以采用这种方式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0cc0" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">仅此而已。在模板级别，我们的“引擎”完成工作不需要任何其他东西。</p><p id="6fdf" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这样，它将能够用很少的操作从指令中分离出文本，并将其转换成最终的文本。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="554b" class="mg kx iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">如何制作</h1><p id="0679" class="pw-post-body-paragraph ld le iq lf b lg mx jr li lj my ju ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">到目前为止，我们只看到了与模板编写技术相关的部分，但在开始时承诺的是只用三行代码创建模板引擎的方法，所以是时候转移到我们实际“烹饪”引擎的部分了。</p><p id="e9ea" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">所需的步骤少而简洁:</p><ol class=""><li id="5612" class="nf ng iq lf b lg lh lj lk lm nh lq ni lu nj ly od nl nm nn bi translated">模板字符串的后处理:<br/> <strong class="lf ir"> <em class="nw">一</em> </strong>。在模板文本的开头和结尾添加用于分隔静态代码和JavaScript指令的相同分隔符。<br/> <strong class="lf ir"> <em class="nw"> B </em> </strong>。用两个不同的正则表达式替换特定文本的分隔符(我们很快就会看到)。<br/> <strong class="lf ir"> <em class="nw"> C </em> </strong>。再次用正则表达式将值<code class="fe nc nd ne ks b">{= exp =}</code>的占位符替换为形式为<code class="fe nc nd ne ks b">${exp}</code>的相同表达式。<br/>例如:<code class="fe nc nd ne ks b">{= data.title =}</code>变成了<code class="fe nc nd ne ks b">${data.title}</code>。<br/> <strong class="lf ir"> <em class="nw"> D </em> </strong>。移除模板字符串开头和结尾的所有孤立分隔符。</li><li id="7a32" class="nf ng iq lf b lg np lj nq lm nr lq ns lu nt ly od nl nm nn bi translated">动态生成一个负责转换文本的函数。</li><li id="3bfe" class="nf ng iq lf b lg np lj nq lm nr lq ns lu nt ly od nl nm nn bi translated">调用函数，向其传递用作参数的对象，并生成最终文本。</li></ol><p id="aaae" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们看看接受两个参数的简单函数中的所有内容:第一个是模板文本(静态文本和可能的JavaScript指令)，第二个是将从中读取值的任何数据对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f610" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">好吧，好吧。我说了三行，这里我们至少有20行…但是如果我们去掉所有不必要的注释和回车，剩下的是</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a63f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">准备好了！</p><p id="ac84" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">你们中的一些人可能已经注意到我可以用一行代码写“……这是可能的！)但也许，考虑到生成的代码难以辨认，它应该是clickbait。<br/>反正；)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="6615" class="mg kx iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">分步分析</h1><p id="0053" class="pw-post-body-paragraph ld le iq lf b lg mx jr li lj my ju ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">让我们来看看在单个步骤中详细发生了什么，甚至看看我们的模板文本如何不时地变换。</p><p id="f4e4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们从这个条件出发</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3b3a" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们在开头和结尾添加分隔符</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e8fe" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们使用正则表达式<code class="fe nc nd ne ks b">##\s*&lt;</code>捕获模式<code class="fe nc nd ne ks b">## + (space or empty) + &lt;</code>并用<code class="fe nc nd ne ks b">(new line) + out.push(`&lt;</code>替换它们，使用正则表达式<code class="fe nc nd ne ks b">&gt;\s*##</code>捕获模式<code class="fe nc nd ne ks b">&gt; + (space or empty) + ##</code>并用<code class="fe nc nd ne ks b">&gt;`); + (new line)</code>替换它们。我们将得到的是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f6c5" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">此时，最后一个后处理步骤是用JavaScript模板文字管理的占位符格式替换我们的占位符(如果有的话)。我们将把字符<code class="fe nc nd ne ks b">{=</code>替换为<code class="fe nc nd ne ks b">${</code>，将<code class="fe nc nd ne ks b">=}</code>替换为<code class="fe nc nd ne ks b">}</code>，以获得:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="e6bd" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通过最后的替换，我们已经将模板转换成了正确的JavaScript代码。现在我们只需要将它插入到一个能够执行它的动态函数中，最后，调用该函数产生最终结果。</p><p id="2c7b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">JavaScript语言的Function类将用于生成函数，通过它可以将它将接受的参数和函数本身定义为string。</p><p id="e06f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><em class="nw">更多详情:<br/> </em> <a class="ae no" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function" rel="noopener ugc nofollow" target="_blank">功能MDN </a></p><p id="69cc" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是我们的参考代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><blockquote class="nx ny nz"><p id="9356" class="ld le nw lf b lg lh jr li lj lk ju ll oa ln lo lp ob lr ls lt oc lv lw lx ly ij bi translated">我插入了两行定界注释，以便更好地与最终生成的函数进行比较</p></blockquote><p id="c9d0" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们通过function类创建一个动态函数，我们向它传递第一个表示参数名称的字符串和第二个(最后一个)表示函数体的参数。我们可以看到使用多行字符串来定义主体，这允许我们插入一个占位符来调用之前转换的模板。<br/>运行时将在内存中生成如下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="2c73" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><code class="fe nc nd ne ks b">composeFunc</code>常量将包含对函数的引用，您可以像调用任何其他显式声明的函数一样调用它。<br/>因此:</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="d5ca" class="kw kx iq ks b gy ky kz l la lb">return composeFunc(data);</span></pre><p id="bed0" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">将返回我们想要得到的最终文本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="323a" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">使用简单样式呈现的效果如下所示:</p><pre class="kg kh ki kj gt kr ks kt ku aw kv bi"><span id="b75c" class="kw kx iq ks b gy ky kz l la lb">.title {<br/>    font-weight: 700;<br/>    font-size: 1.2em;<br/>    margin-bottom: 10px<br/>}<br/>.episode-name &gt; span:first-child {<br/>    display: inline-block;<br/>    text-align: right;<br/>    font-weight: 500;<br/>    margin-right: 20px;<br/>    min-width: 2ch;<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/32c47a8afb6f45ca66cc9ad1e9bd16c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*sD_WpVlxFm13Fa2UpML8-w.png"/></div></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="f50b" class="mg kx iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="c094" class="pw-post-body-paragraph ld le iq lf b lg mx jr li lj my ju ll lm mz lo lp lq na ls lt lu nb lw lx ly ij bi translated">我们已经看到了如何使用正则表达式、模板字符串和动态函数以简单快速的方式管理HTML模板字符串。<br/>确切地说，我们已经实现的东西虽然功能多样，但还远远不能被认为是真正的模板引擎。这可能是一个很好的开始想法，但有必要引入许多其他功能和验证，使系统更加实用和安全。</p><p id="efc2" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们所做的更多的是一种风格上的练习，让我们“弄脏我们的手”,并仔细观察一些功能组合在一起时是如何工作的。</p><p id="e971" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">就像任何一道新菜一样，第一次实现往往会带来缺陷和近似。但是实验的美妙之处在于学习新的东西，不管这些成分结合得好不好。这并没有改变食谱可以改进的事实，有时，缺点可以转化为优势。嗯……我已经有想法了，我想我们将来会再来一次。</p><p id="7526" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">保持好奇心，保持创造力！</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><p id="4c45" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">非常感谢我的朋友Chiara Bernardini对我的支持</p></div></div>    
</body>
</html>