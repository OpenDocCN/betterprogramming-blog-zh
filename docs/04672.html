<html>
<head>
<title>ES6 String and Array Methods That Replace Older Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">取代旧方法的ES6字符串和数组方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/es6-string-and-array-methods-that-replace-older-methods-b0224766d255?source=collection_archive---------18-----------------------#2020-04-28">https://betterprogramming.pub/es6-string-and-array-methods-that-replace-older-methods-b0224766d255?source=collection_archive---------18-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a44a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">请不要再使用indexOf</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d8faea897e7272c35b61ff02dd9c2460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dTzJWq_Ai8mqz-yq"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">苏珊·莫尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="41dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是世界上最流行的编程语言之一。</p><p id="2261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为，自2015年以来，JavaScript增加了许多伟大的功能，旨在取代早期版本的旧功能。</p><p id="74fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究取代早期方法的ES6字符串和数组方法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed9c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从索引Of到开始于</h1><p id="0df3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">ES6引入了字符串的<code class="fe mz na nb nc b">startsWith</code>实例方法，可以用来替代<code class="fe mz na nb nc b">indexOf</code>方法。</p><p id="5421" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，给定以下字符串:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5a7b" class="nh md it nc b gy ni nj l nk nl">const str = 'foobar';</span></pre><p id="bd5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以替换:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9b5d" class="nh md it nc b gy ni nj l nk nl">str.indexOf('foo') === 0</span></pre><p id="e3ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6aeb" class="nh md it nc b gy ni nj l nk nl">str.startsWith('foo')</span></pre><p id="49db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想检查字符串<code class="fe mz na nb nc b">str</code>是否以<code class="fe mz na nb nc b">'foo'</code>开始。</p><p id="1006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">startsWith</code>比<code class="fe mz na nb nc b">indexOf</code>短得多，我们也不用按索引查。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="edee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从索引到结束</h1><p id="55c2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">endsWith</code>方法比<code class="fe mz na nb nc b">startsWith</code>方法更有用，因为没有简单的方法来检查一个字符串是否以给定的后缀结尾。</p><p id="e8ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有<code class="fe mz na nb nc b">endsWith</code>，我们不得不写一个如下的函数:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3b29" class="nh md it nc b gy ni nj l nk nl">const endsWith = (str, suffix) =&gt; {<br/>  const index = str.indexOf(suffix);<br/>  return index &gt;= 0 &amp;&amp;<br/>    index === str.length - suffix.length;<br/>}</span></pre><p id="7b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须通过检查索引是否为0或更大来检查后缀是否位于带有<code class="fe mz na nb nc b">str.indexOf(suffix)</code>的字符串中。然后我们必须通过检查<code class="fe mz na nb nc b">index</code>是否在<code class="fe mz na nb nc b">str.length — suffix.length</code>中来检查<code class="fe mz na nb nc b">index</code>是否位于字符串的末端。</p><p id="80dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后给出以下字符串:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1af5" class="nh md it nc b gy ni nj l nk nl">const str = 'foobar';</span></pre><p id="7f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们会写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d105" class="nh md it nc b gy ni nj l nk nl">endsWith(str, 'bar')</span></pre><p id="412c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe mz na nb nc b">endsWith</code>，我们只需写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f34f" class="nh md it nc b gy ni nj l nk nl">str.endsWith('bar')</span></pre><p id="f870" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很方便，我们不必定义自己的函数来检查一个字符串是否以给定的后缀字符串结尾。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="57a1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从索引到包含</h1><p id="419f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">ES6引入的<code class="fe mz na nb nc b">includes</code>方法检查一个字符串是否位于给定的字符串中。</p><p id="d14e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，给定以下字符串:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="f12b" class="nh md it nc b gy ni nj l nk nl">const str = 'foobarbaz';</span></pre><p id="8b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过编写以下代码来检查子字符串是否存在于字符串中:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="78b0" class="nh md it nc b gy ni nj l nk nl">str.indexOf('bar') &gt;= 0</span></pre><p id="24c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于ES6，我们可以改为编写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="12b5" class="nh md it nc b gy ni nj l nk nl">str.includes('bar')</span></pre><p id="3a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个比<code class="fe mz na nb nc b">indexOf</code>短。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d1ea" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从Array.prototype.indexOf到Array.prototype.findIndex</h1><p id="b70d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">ES6引入了<code class="fe mz na nb nc b">findIndex</code>数组实例方法。它对查找任何东西的索引都很有用。它需要一个回调函数来返回我们想要搜索的内容的条件。</p><p id="e324" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">indexOf</code>不能很好地处理对象，因为它只找到与给定对象引用相同的对象。</p><p id="59ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，<code class="fe mz na nb nc b">indexOf</code>非常适用于像数字这样的原始值:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="55da" class="nh md it nc b gy ni nj l nk nl">arr.indexOf(1)</span></pre><p id="32c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它比使用<code class="fe mz na nb nc b">findIndex</code>短，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a536" class="nh md it nc b gy ni nj l nk nl">arr.findIndex(a =&gt; a === 1)</span></pre><p id="686f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们都返回索引1，也就是0。</p><p id="dcd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们搜索一个对象的索引时，<code class="fe mz na nb nc b">indexOf</code>是行不通的。给定以下数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d91b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1956" class="nh md it nc b gy ni nj l nk nl">arr.indexOf({<br/>  name: 'Alex'<br/>})</span></pre><p id="a765" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们将得到-1，因为<code class="fe mz na nb nc b">{ name: ‘Alex’ }</code>与数组中的引用不同。</p><p id="75bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，<code class="fe mz na nb nc b">findIndex</code>在这里将是有用的:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6130" class="nh md it nc b gy ni nj l nk nl">arr.findIndex(a =&gt; a.name === 'Alex')</span></pre><p id="ce50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将返回1，这是正确的索引，因为我们返回一个比较<code class="fe mz na nb nc b">name</code>属性的值的条件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="89e3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">从Array.prototype.slice()到Array.from()或Spread运算符</h1><p id="8fcf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在大多数情况下，<code class="fe mz na nb nc b">slice</code>和<code class="fe mz na nb nc b">from</code>实例都可以用spread操作符替换。</p><p id="bee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们不再需要<code class="fe mz na nb nc b">slice</code>将类似数组的对象转换成数组。</p><p id="8b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想把<code class="fe mz na nb nc b">arguments</code>对象转换成一个数组，而不是写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9ee3" class="nh md it nc b gy ni nj l nk nl">const arr = Array.prototype.slice.call(arguments);</span></pre><p id="b705" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们写道:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="da61" class="nh md it nc b gy ni nj l nk nl">const arr = [...arguments];</span></pre><p id="7e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它要短得多，我们不必调用<code class="fe mz na nb nc b">call</code>并将<code class="fe mz na nb nc b">arguments</code>作为<code class="fe mz na nb nc b">this</code>值传入。</p><p id="73c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两个例子中，当我们有给定的函数时，我们将<code class="fe mz na nb nc b">[1, 2, 3]</code>赋值给<code class="fe mz na nb nc b">arr</code>:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b55b" class="nh md it nc b gy ni nj l nk nl">function foo() {<br/>  const arr = [...arguments]; <br/>}</span></pre><p id="7b15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并写道:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fb4f" class="nh md it nc b gy ni nj l nk nl">foo(1, 2, 3);</span></pre><p id="a406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用spread操作符来替换<code class="fe mz na nb nc b">Array.from</code>方法的大多数用例。</p><p id="5d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要我们传递给<code class="fe mz na nb nc b">Array.from</code>的对象是一个数组或另一种可迭代对象，我们就可以使用spread操作符。</p><p id="8a5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，与其写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a943" class="nh md it nc b gy ni nj l nk nl">function foo() {<br/>  const arr = Array.from(arguments); <br/>}</span></pre><p id="2d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="753b" class="nh md it nc b gy ni nj l nk nl">function foo() {<br/>  const arr = [...arguments]; <br/>}</span></pre><p id="35ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Array.from</code>唯一有用的情况是将整数作为属性标识符的对象和<code class="fe mz na nb nc b">length</code>属性转换成数组。</p><p id="8534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f5aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至<code class="fe mz na nb nc b">[“foo”, “bar”, “baz”]</code>。</p><p id="1edf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不能使用spread操作符将它转换成数组，因为它不是一个可迭代的对象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="85e8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="668d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了一些边缘情况，新的ES6字符串和数组函数是很好的补充，可以用来在许多地方缩短代码。</p><p id="6482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串实例方法节省了最多的代码。更短、自我解释的代码对每个人来说都更容易理解。</p></div></div>    
</body>
</html>