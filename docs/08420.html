<html>
<head>
<title>Form Validation in iOS Apps Made Easy With RxSwift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift简化了iOS应用中的表单验证</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/form-validation-in-ios-apps-made-easy-with-rxswift-266123042bb6?source=collection_archive---------4-----------------------#2021-04-28">https://betterprogramming.pub/form-validation-in-ios-apps-made-easy-with-rxswift-266123042bb6?source=collection_archive---------4-----------------------#2021-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ab80" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用两个实例实现输入表单验证</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2cfb091b90a9da8b3b674bf76be65f4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LVUCiJcsdjRJZQOlLLnTqQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">杰里米·毕晓普在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道“RxSwift”本身听起来是一件很大很难的事情。当我开始工作时，我也有同样的感觉。我们都是学习者。最好的学习方法之一是在现有项目中采用该实现。在本文中，我们将重点介绍RxSwift中表单验证的实现。</p><p id="e8d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RxSwift是Swift语言的<a class="ae kv" href="http://reactivex.io/" rel="noopener ugc nofollow" target="_blank">反应扩展</a> (Rx)。它是一个著名的库，被iOS开发者广泛使用，尤其是在MVVM模式中。关于定义和概述的更多理解，你可以参考<a class="ae kv" href="https://hackernoon.com/mvvm-rxswift-on-ios-part-1-69608b7ed5cd" rel="noopener ugc nofollow" target="_blank"> Hackernoon </a>和<a class="ae kv" href="https://www.raywenderlich.com/books/rxswift-reactive-programming-with-swift/v4.0/chapters/1-hello-rxswift" rel="noopener ugc nofollow" target="_blank"> Raywenderlich </a>写的好文章。</p><h1 id="cb8d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">观察对象、订户和受试者</h1><p id="ea99" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，你应该知道RxSwift基本上是关于可观察性和订户的。两者都是RxSwift的重要元素。</p><ol class=""><li id="ad63" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><em class="my">可观察的</em>。正如这个词所描述的，它是任何可以被观察到并能够通知其观察者的变量或物体。所以，它会不断告诉观察者事件的变化。</li><li id="223e" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated"><em class="my">订户</em>又名观察者。它订阅可观察对象以持续接收通知。</li><li id="dc76" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated"><em class="my">臣民。简单来说，它具有两种能力:被观察者和订阅者。</em></li></ol><h2 id="ffd3" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">数据绑定</strong></h2><p id="605a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">将数据绑定到预期动作或用户界面的过程。</p><p id="fa5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在“重置密码”表单中，要求用户输入有效的电子邮件，以便能够单击提交按钮。</p><p id="8c07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们需要具备以下条件:</p><ol class=""><li id="61ce" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">一个变量，比如说，<code class="fe nq nr ns nt b">isValidEmail</code>(一个布尔值)，其中的值是根据在文本字段中输入的电子邮件确定的(<code class="fe nq nr ns nt b">isValidEmail</code>订阅文本字段的更改)。</li><li id="16a5" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">然后，<code class="fe nq nr ns nt b">isValidEmail</code>的值被绑定到一个提交按钮。所以，每当<code class="fe nq nr ns nt b">isValidEmail</code>为<code class="fe nq nr ns nt b">true</code>时，按钮就会被激活。这是它的<code class="fe nq nr ns nt b">.normal</code>状态。一旦变为假，按钮将变为其<code class="fe nq nr ns nt b">.disable</code>状态。酷！</li></ol><p id="14fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，值可以绑定到UI，反之亦然。</p><h2 id="9ba1" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">处理袋子</strong></h2><p id="b1d5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在RxSwift中，订阅不能自行处理。因此，我们需要创建一个包，用于收集所有的一次性订阅，以适当地避免内存泄漏。您将在代码中看到它的用法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/091a3d872b31a414d91d2db5533658bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYQERUTtp_MpN1q_p_cqMQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@locked_in_the_lens?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Kinga koodziejska</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="a533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将处理两种情况:</p><ol class=""><li id="8bb8" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">重置密码表单(单一文本字段验证)</li><li id="e009" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">注册表单(多文本字段验证)</li></ol><h1 id="b260" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">重置密码表单</strong></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/349ae44d22df88a543bf6ef1dbc16cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*faJOQ8zfgg1AWJLJZomypw.gif"/></div></figure><p id="cc9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本节中，我们将使用电子邮件文本字段的观察者。一旦该值成为一个有效的电子邮件，“提交”按钮将自动成为启用，反之亦然。哇！🤩</p><p id="e677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建一个新项目并添加一个<code class="fe nq nr ns nt b">UITextField</code>和<code class="fe nq nr ns nt b">UIButton</code>网点。然后，将插座连接到ViewController:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/26bc24d663149cdc706efc685db19e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NuPQbiMKKZ_r1kPAGPeJiQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将插座链接到ViewController</p></figure><p id="f2fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用<code class="fe nq nr ns nt b">.gray</code>文本颜色设置禁用状态的提交按钮属性，以区分<code class="fe nq nr ns nt b">rx</code>发射事件期间的按钮状态(您可以通过编程设置<code class="fe nq nr ns nt b">.disabled</code>的文本颜色)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/b4540936b98a6ffdc89472891cf458af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*jdkRIxiw7xoFaangzMzOiA.png"/></div></figure><p id="29f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要更新我们的ViewController。下面是代码，解释在后面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><ol class=""><li id="3134" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">在顶部导入RxSwift和RxCocoa库。</li><li id="e1eb" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">添加新的变量调用<code class="fe nq nr ns nt b">emailSubject</code>。您会注意到我们使用<code class="fe nq nr ns nt b">BehaviorRelay</code>作为email变量，它是类型<code class="fe nq nr ns nt b">String</code>(可选)。它是一个<code class="fe nq nr ns nt b">Subjects</code>类型，它可以从TextField接收一个值，并在每次值改变时(包括初始值)向subscriber发出事件。行尾的“值”是所需初始值的参数。</li><li id="9904" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">如前所述添加<code class="fe nq nr ns nt b">disposeBag</code>(释放内存)。</li><li id="60e3" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">设置UI绑定。添加一个新函数<code class="fe nq nr ns nt b">setupBindings()</code>，并添加代码将TextField中的任何更改绑定到<code class="fe nq nr ns nt b">emailSubject</code>。</li><li id="c42c" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">如果这些步骤发生，<code class="fe nq nr ns nt b">emailSubject</code>将发出事件。检查流量。<br/> a .在<code class="fe nq nr ns nt b">map()</code>中，一旦接收到事件，我们就将该值映射(转换)到<code class="fe nq nr ns nt b">Bool</code>中，以检查电子邮件字符串是否正确(使用简单的字符串扩展<code class="fe nq nr ns nt b">validateEmail()</code> —检查代码的底部)。<br/> b .然后，我们将结果绑定到<code class="fe nq nr ns nt b">submitButton</code>中以改变<code class="fe nq nr ns nt b">isEnabled</code> <br/>的<code class="fe nq nr ns nt b">rx</code>状态c .最后，将订阅处理到那个包中。</li><li id="be56" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">一个字符串扩展，具有使用RegEx验证电子邮件格式的功能。</li><li id="8c69" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">一个字符串扩展，具有使用RegEx验证电子邮件格式的功能。</li></ol><p id="2480" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，我们完成了第一个验证表单。提交按钮现在是安全的，不能点击，除非电子邮件是有效的。</p><p id="2b49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">额外提示💡</strong></p><p id="f65e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，可以通过添加一个新变量<code class="fe nq nr ns nt b">isValidEmail</code>作为<code class="fe nq nr ns nt b">Observable&lt;Bool&gt;</code>来捕捉<code class="fe nq nr ns nt b">emailSubject</code>结果，从而简化数字5。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><h1 id="7884" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">注册表单</h1><p id="e487" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在本节中，我们将对多个字段进行相同的验证。该表单有三个字段:姓名、电子邮件和密码。这些要求是:</p><ol class=""><li id="e6a5" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">名称不能为空或<code class="fe nq nr ns nt b">nil</code></li><li id="1007" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">检查电子邮件是否有效</li><li id="cf37" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">确保密码格式正确，超过六个字符(这只是一个示例，您可以使用regex或其他方法添加自己的规则)</li></ol><p id="ba94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使我们的代码更简洁，我们将把它分成ViewController和ViewModel。ViewController将处理UI设置和绑定，而ViewModel将处理验证逻辑。</p><h2 id="7d53" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">视图模型</h2><p id="d2e7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们开始更新控制器之前，让我们完成作为控制器依赖项的视图模型。添加一个名为“SignUpViewModel.swift”的新文件，并添加一个新类<code class="fe nq nr ns nt b">SignUpViewModel</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="1573" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前面代码的解释如下。</p><ol class=""><li id="0de5" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">添加必要的变量来监听文本字段上的事件变化，包括名称、电子邮件和密码。</li><li id="9669" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">独特的部分是<code class="fe nq nr ns nt b">isValidForm</code>。以前，我们只检查单个字段。现在，我们使用<code class="fe nq nr ns nt b">combineLatest()</code>将所有可观察值组合在一起并作为一个结果返回。因此，在ViewController中，订阅者只需观察<code class="fe nq nr ns nt b">isValidForm</code>来确保表单当前处于有效状态。</li></ol><h2 id="5828" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">视图控制器</h2><p id="338b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，创建一个名为<code class="fe nq nr ns nt b">SignUpViewController</code>的新UIViewController，并用TextField和Button outlets向storyboards添加一个新场景。然后，用SignUpViewController连接它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/b9f0aa8696fddb570e14440038a4da36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0esfEWWvGp8w6Z9lOFx3_Q.png"/></div></div></figure><p id="c147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看SignUpViewController。当我们使用viewModel时，代码得到了简化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="75ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从这个ViewController中，我们了解了以下内容:</p><ol class=""><li id="7109" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">为文本字段和按钮添加出口(确保像我们之前做的那样将按钮标题颜色的<code class="fe nq nr ns nt b">.disable</code>状态设置为灰色)<br/> <code class="fe nq nr ns nt b">submitButton.setTitleColor(.gray, for: .disabled)</code></li><li id="2625" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">从类SignUpViewModel创建viewModel对象来处理验证</li><li id="44da" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">将文本字段绑定到视图模型</li><li id="3c8d" class="mp mq iq ky b kz mz lc na lf nb lj nc ln nd lr mu mv mw mx bi translated">将<code class="fe nq nr ns nt b">isValidForm</code>的值绑定到提交按钮来自动改变按钮状态。</li></ol><p id="0722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">太棒了。现在您已经掌握了使用RxSwift进行表单验证。试着在你现有的项目中逐步实现它们，也许会有更多的规则和变化。您还可以探索进行表单验证的其他方法。在这里下载我的完整源代码<a class="ae kv" href="https://github.com/xmhafiz/learn-rxswift-form-validation" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="f673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这篇文章能帮助你学习RxSwift。感谢阅读。别忘了鼓掌👏并与您的朋友分享。非常欢迎反馈。</p><h1 id="af8b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">参考</h1><p id="36e9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://www.raywenderlich.com/books/rxswift-reactive-programming-with-swift/v4.0/chapters/1-hello-rxswift" rel="noopener ugc nofollow" target="_blank">https://www . raywenderlich . com/books/rx swift-reactive-programming-with-swift/v 4.0/chapters/1-hello-rx swift</a></p><p id="30fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://hackernoon.com/mvvm-rxswift-on-ios-part-1-69608b7ed5cd" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/mvvm-rx swift-on-IOs-part-1-69608 b 7 ed 5 CD</a></p><p id="6843" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://www.raywenderlich.com/books/rxswift-reactive-programming-with-swift/v4.0/chapters/3-subjects#toc-chapter-007-anchor-001" rel="noopener ugc nofollow" target="_blank">https://www . raywenderlich . com/books/rx swift-reactive-programming-with-swift/v 4.0/chapters/3-subjects # TOC-chapter-007-anchor-001</a></p><p id="da6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/ReactiveX/RxSwift" rel="noopener ugc nofollow" target="_blank">https://github.com/ReactiveX/RxSwift</a></p></div></div>    
</body>
</html>