<html>
<head>
<title>Algorithms: Heapsort in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:Swift中的堆排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/heapsort-in-swift-sorting-elements-in-o-n-log-n-866186b5e38c?source=collection_archive---------8-----------------------#2020-02-16">https://betterprogramming.pub/heapsort-in-swift-sorting-elements-in-o-n-log-n-866186b5e38c?source=collection_archive---------8-----------------------#2020-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b97e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在O(n log n)中排序元素</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aad75c72a1616175ea9d087642f70eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97iIDprKg73NKdCNo4uBdA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/pile?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@adityaries?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Aditya Saxena </a>拍摄</p></figure><p id="67b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你能看看我之前关于堆的文章，“T4，让我们在Swift 中学习堆”，因为堆是这个算法的核心。</p><p id="9fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天我们就稍微讨论一下叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Heapsort" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> heapsort </em> </a>的排序算法。它于60年代推出，现在仍然是对数字、字符串等进行排序的最强大的结构之一。引入堆的同一个人也提出了堆排序，所以看起来他们本质上是相互关联的。我们会知道为什么。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="782b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">算法背后的想法</h1><p id="d55a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">没有堆就没有堆排序。堆的概念是有一个结构，其中第一个元素总是插入到结构中的最大或最小的元素——这取决于我们是在讨论最大堆还是最小堆。</p><p id="9b5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆排序使用最大堆将元素从最小到最大排序。利用这个优势，J.W.J. Williams，这个引入这个算法的家伙，决定做一些有趣的事情。他的想法是将堆中的第一个元素与最后一个元素交换。这样做之后，他会说堆的大小减少了一个单位，他会将那个堆堆化。通过<em class="lv"> heapify </em>，我的意思是他将确保堆仍然符合堆的规则:第一个元素仍然是最大的一个。这个过程将重复<em class="lv"> n-1 </em>次，其中<em class="lv"> n </em>是被排序列表的大小。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="61ae" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">这个过程有多快？</h1><p id="2c28" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">根据Cormen的《算法导论》，heapsort要执行的复杂度时间为<em class="lv"> O (n log n) </em>。科尔曼解释说，构建这个堆需要花费<em class="lv"> O (n) </em>的时间，再加上所有n-1次对这个堆进行堆化的调用都需要花费<em class="lv"> O (log n) </em>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fa53" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">在Swift中实施</h1><h1 id="b8bf" class="md me it bd mf mg na mi mj mk nb mm mn jz nc ka mp kc nd kd mr kf ne kg mt mu bi translated">在Swift中实施</h1><p id="1f1c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@Alcivanio/swift-a-quick-look-in-heaps-using-swift-ea9aca929d9d" rel="noopener">我们将使用我们过去用heaps做的实现</a>。唯一的区别是我们现在将使用最大堆而不是最小堆。改变的是我们在调用<code class="fe nf ng nh ni b">heapifyUp</code>和<code class="fe nf ng nh ni b">heapifyDown</code>时所做的比较。我们不检查父节点或子节点是否更大，而是检查它是否更小。正如我在上一篇文章中所承诺的，我已经对堆做了一些修改，这样它现在看起来更敏捷了。</p><p id="1186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要检查堆的大小，我们必须检查条目列表的大小。听起来很公平，我们使用了我们的目标语言所能提供的最好的东西。每当实现堆排序时，我们都会操纵这个计数。为了简单起见，我们将为排序后的元素创建一个计数器。每当一个元素现在被放在正确的位置——意味着它被排序了——我们将把这个变量加1。计数的变化将是计数现在是列表的<strong class="lb iu"> </strong>大小减去排序元素的数量。听起来合法而且有用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="fc8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">装载完堆后，为了执行堆排序，我们只需遍历元素来对它们进行排序。算法会非常简单。它在列表中迭代n-1次，用最后一个元素交换第一个元素，然后执行heapify。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8427" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Heapify如何工作</h1><p id="dda7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><em class="lv">heapify down</em><strong class="lb iu"><em class="lv"/></strong>的思路是获取根节点并放在正确的位置。我们知道根节点现在可能没有定位好，因为我们刚刚得到了最后一个元素并把它放在那里。然后我们检查是否有比它更大的孩子。如果是，我们交换它们。我们继续沿着树往下做同样的检查，直到我们确定堆现在遵循了堆的所有规则；在这种情况下，父节点比子节点大。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a0d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重复这个过程<em class="lv"> n-1 </em>次后，我们将得到一个排序后的列表。如果A是我们想要排序的列表，这个算法将确保A[i] &lt; A[i+1]，A[I+1]&lt;A[I+2]，…，A[n-1] &lt; A[n]，其中I是int，I&gt;0，I&lt;n。n是列表的大小，考虑到我们的列表从1到n进行索引</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="9f4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的GitHub 上有完整的实现，所以你可以在你的系统上检查和运行它。如果您在实施过程中发现任何问题，请不要犹豫。</p><p id="e78e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在评论里说说你对这个算法的看法。</p><p id="f67b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>