# 如何挖掘 Java 中的区块链

> 原文：<https://betterprogramming.pub/how-to-mine-the-blockchain-in-java-9647de36a8fc>

## 面向用户和矿工的 Java 实现

![](img/d441eb1556b6e5bb18f0fefa821e4104.png)

詹姆斯·柯文在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片。

加密货币开采可能是一个误称，并导致对矿工所做的一些误解。采矿通常会让人联想到开采某种东西的画面，但在加密货币采矿中，矿工们正在建造区块链，并为此获得报酬。矿工们争先恐后地收集所有新交易，将它们放在一个区块中，并提供一些人工工作证明。

这是我关于区块链的[系列](/the-blockchain-explained-with-a-java-implementation-27b74d478223)的第三部分，也是最后一部分，我将在其中实现我的 Java 服务集合的用户和矿工。我已经完成了部分采矿工作，因为没有矿工的参与，就不可能有一个区块链。但是我还没有创建一个用户来添加在链的块中使用的地址，以识别合同中涉及的各方。矿工也是用户，因为他们需要一个地址来接收他们工作的积分。

这个项目的最终结果是一个脆弱的区块链，因为没有具体的价值交换，我们不需要确保所有东西都加起来。矿工们在维护区块链的工作中唯一得到的是好的业力。

对于像比特币这样的加密货币，我们需要找到一个地址的所有未用完的输出交易，以确保它们足以支付输入交易中交换的金额。我们还向矿商支付费用，并为他们能添加到区块链的每个区块支付一定数量的比特币。我们的区块链更像是一种以可验证的方式进行通信的方式，尽管它具有加密发生的某些方面，如输入和输出事务。

# 创建用户

让我们从为用户和矿工做一个新的服务开始。它将是区块链和节点的其他两个服务的副本，但是我们将添加一个新的控制器、服务和模型。因为矿工是用户(也就是说，他们需要一个地址来包含在交易中)，我们将从用户开始。让我们创建一个端点来添加、列出和获取用户信息。我将对`list`和`get`端点使用基本认证。`add`端点将是开放的，因为任何人都可以创建用户。

虽然我想演示某种级别的身份验证，但我不想陷入真正的身份验证系统的细节中。因此，为了模拟检查，用户名和密码必须相同，用于列出所有用户的特殊用户必须命名为 admin。如果启动时不存在 admin 用户，我也会立即创建它。

以下是我对控制器的要求:

这项服务非常简单:

使用`application.yaml`设置 MongoDB 的参数:

现在您可以使用`docker-compose.yaml`文件启动 MongoDB 并测试新的端点。您应该能够在系统中添加和列出用户。只要记住使用基本认证。重要的是要记住，基本身份验证使用用户名，而端点使用 ID 进行更有效的搜索。

用户除了 ID 和名字还有什么？在加密货币系统中，我们认为用户有一个钱包。钱包是一个地址和一个私钥/公钥对。在我们的系统中，我们将把它们放在一起，这样一个用户只能有一个“钱包”(即地址和私钥/公钥对)。这样，用户就可以创建事务。我们不能使用 ID 作为地址，因为每个用户都连接到一个节点，并且 ID 在节点之间不是唯一的。所以我们用 UUID 作为地址。那么就只需要创建私有/公共密钥对了。下面是更新后的`UserService.addUser`:

因为我们不想公开`privateKey`，我们将把这一行添加到`UserController`中任何返回用户或用户列表的链中:

```
.doOnNext(u -> u.setPrivateKey(null));
```

现在我们准备代表用户创建一个事务。

我们在区块链服务中有一个基本的事务创建端点，因此我们将删除它。我们将保留添加事务端点，我们可以从用户服务中的新端点调用它。控制器中的新端点如下所示:

`UserService`类中的新方法如下所示:

您可以看到，我们获取了数据库中编码的私钥，并使用它来签署输入合同。就像我们创建了`withHash`方法一样，我们创建了`withSignature`方法，因为必须在应用数据后计算签名。我们懒得检查输出地址，因为地址没有唯一的真实来源。一些加密货币使用一些特定的地址格式来帮助防止将硬币交给不存在的地址，但没有办法确保你不会将硬币发送到众所周知的比特桶。

# 创建矿工

这实际上比创建用户更容易，因为矿工是一个有能力创建块的用户。区块链服务已经创建了一个块，我们可以间接调用它。我们唯一需要的是地址，地址是用户的一部分。所以让我们给`UserController`添加一个新的端点:

由于矿工只是一个用户，我们可以使用相同的代码来认证它。我们不担心授权。每个人都有相同的授权级别。接下来，我们需要给`UserService`添加一个`createBlock`方法:

可以使用现有的端点来创建新的块，这样就完成了。

# 结论

唷。把所有的碎片整理出来需要做大量的工作。在前三篇文章中，我们创建了一个基本的区块链，一个让所有人保持同步的对等网络，以及控制整个事情的用户/矿工。它可能需要很好的重构和一些集成类型的测试来运行所有不同的场景，但现在，我对拥有一个完整的服务系统感到满意，这些服务可以一起工作。

你可以在我的 GitHub 页面上找到所有代码:

[](https://github.com/rkamradt/blockchain/tree/v0.3) [## GitHub-rkamradt/区块链 0.3 版

### yabc。在 GitHub 上创建一个帐户，为 rkamradt/区块链的发展做出贡献。

github.com](https://github.com/rkamradt/blockchain/tree/v0.3) 

以下是本系列的其他文章:

[](/the-blockchain-explained-with-a-java-implementation-27b74d478223) [## 如果你想了解区块链，请看这个 Java 实现

### 解放区块链

better 编程. pub](/the-blockchain-explained-with-a-java-implementation-27b74d478223) [](/build-a-set-of-blockchains-using-java-d99cd866931b) [## 用 Java 建立一套区块链

### 通过对等网络建立信任

better 编程. pub](/build-a-set-of-blockchains-using-java-d99cd866931b)