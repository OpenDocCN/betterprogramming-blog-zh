<html>
<head>
<title>A Nibble of Lazy Evaluation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">懒惰评价的一点点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-nibble-of-lazy-evaluation-22a93e05df3e?source=collection_archive---------4-----------------------#2022-11-13">https://betterprogramming.pub/a-nibble-of-lazy-evaluation-22a93e05df3e?source=collection_archive---------4-----------------------#2022-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="dbaf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">渴望vs严格vs不严格vs懒惰——这一切意味着什么？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6904751f71ca5e3d374115203bd1e392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3lfUWfoTMixk7eLC"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我羡慕树袋熊在最尴尬的地方也能极度舒适。照片由<a class="ae kv" href="https://unsplash.com/@davidclode" rel="noopener ugc nofollow" target="_blank">大卫·克洛德</a>在<a class="ae kv" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a00c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">啃:咬下的一小块食物。在计算中:半个字节的信息。每一个小字节在五分钟内解释一个计算科学或软件工程的想法。</em></p><p id="2b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每种编程语言都需要选择计算表达式的顺序。几乎都使用<em class="ls">严格求值</em>:在对一个表达式求值之前，先对所有子表达式求值。例如，函数的参数在函数之前计算。很多人用<em class="ls">热切评价</em>作为严格评价的代名词。</p><p id="8999" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">少数人，主要是Haskell，使用<em class="ls">非严格评估</em>。非严格求值由它不是什么来定义:任何不首先求值所有子表达式，或者根本不求值的求值策略都是非严格的。<em class="ls">懒评</em>是非严格评价的一种特定策略。</p><p id="d339" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们试着用一点懒惰的评价来澄清混乱。</p><h1 id="2440" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">严格评估</h1><p id="73d6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">像大多数语言一样，Python对函数应用程序使用严格的评估:</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="93a3" class="mv lu iq mr b be mw mx l my mz">def log(value):<br/>  if log_level == INFO:<br/>    print(value)<br/><br/>log(42 + 33)</span></pre><p id="35e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，计算总和，然后记录下来。虽然理解起来很直观，但是这个例子显示了严格求值的一个潜在缺点:如果参数最终没有被使用，如果<code class="fe na nb nc mr b">log_level</code>是<code class="fe na nb nc mr b">WARN</code>，那么就没有必要进行计算。</p><p id="baec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发现严格求值的一个简单方法是想象如果一个子表达式进入无限循环会发生什么。如果顶级表达式从不求值，那么求值是严格的。</p><p id="f8a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">严格求值并不限制子表达式求值的顺序，只是它们都在顶级表达式之前求值。可以是从左到右，像Python中一样；从右到左，像在OCaml中；或者像c语言一样不定义。</p><h1 id="d237" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">非严格评估</h1><p id="6639" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">不严格的评估并不像乍看起来那么不寻常——例如<code class="fe na nb nc mr b">if...else...</code>就是不严格的。</p><p id="ddbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们应用我们的技巧来发现严格的评估。即使<code class="fe na nb nc mr b">else</code>分支永远循环，下面的Python程序也会终止:</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="ad41" class="mv lu iq mr b be mw mx l my mz">if True:<br/>  print("I am True")<br/>else:<br/>  while True:<br/>    print("I never terminate")</span></pre><p id="8dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mr b">else</code>分支根本不求值，所以<code class="fe na nb nc mr b">if...else...</code>在python中并不严格。</p><p id="5b38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">短路布尔运算也是非严格的。下面的<code class="fe na nb nc mr b">or</code>表达式终止。</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="61bf" class="mv lu iq mr b be mw mx l my mz">True or infinite_loop()</span></pre><h1 id="2aed" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">不严格的DIY</h1><p id="8244" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这对于内置来说很好，但是如果你想把事情做好…</p><p id="1f01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用没有参数的<a class="ae kv" href="https://www.wikiwand.com/en/Thunk" rel="noopener ugc nofollow" target="_blank"><em class="ls">thunks</em></a><em class="ls">:</em>函数模拟非严格求值。Thunks延迟评估直到需要。</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="a465" class="mv lu iq mr b be mw mx l my mz">def log(value_thunk):<br/>  if log_level == INFO:<br/>    print(value_thunk())<br/><br/>log(lambda: 42 + 33)</span></pre><p id="11eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Thunks避免了不必要的工作——如果要记录的值计算起来很昂贵，那么<code class="fe na nb nc mr b">log</code>函数只在启用日志记录时才计算它。</p><h1 id="f962" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">懒惰评估</h1><p id="6c9a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">thunks的一个恼人的问题是，每次调用它们时都要重新计算。</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="e3d1" class="mv lu iq mr b be mw mx l my mz">def log(value_thunk):<br/>  if log_level == INFO:<br/>    print(value_thunk())<br/>    send_to_log_aggregator(value_thunk())</span></pre><p id="e90f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们可以保留第一次计算thunk的结果，并重用它。这种评价策略被称为<em class="ls">懒评价</em>。它结合了两种优化:</p><ul class=""><li id="da35" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated">它从不执行不必要的工作，直到需要时才进行评估。</li><li id="b232" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated">它从不通过缓存第一个结果来重复工作。</li></ul><p id="de16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个问题:如果thunk有副作用，比如写入磁盘，那么就很难理解副作用何时或者是否会发生。出于这个原因，惰性评估假设thunks没有副作用。</p><p id="048c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数式编程语言Haskell在默认情况下没有使用惰性求值，因为它是纯粹的:Haskell函数没有副作用。</p><p id="f92d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像OCaml、F#和C#这样的严格语言支持使用<code class="fe na nb nc mr b">lazy</code>关键字或<code class="fe na nb nc mr b">Lazy</code>对象的惰性求值。</p><p id="2f29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是Python中一个<code class="fe na nb nc mr b">Lazy</code>对象的说明性实现:</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="6281" class="mv lu iq mr b be mw mx l my mz">class Lazy:<br/>    def __init__(self, thunk):<br/>        self._thunk = thunk<br/>        self._is_cached = False<br/>        self._value = None<br/><br/>    @property<br/>    def value(self):<br/>        if not self._is_cached:<br/>            self._value = self._thunk()<br/>            self._is_cached = True<br/>        return self._value</span></pre><h1 id="268c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">为什么懒惰评估很重要</h1><p id="b609" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">严格评估更常见，因为它更容易理解，也更容易调试。也就是说，在某些情况下，非严格评估是不可或缺的。</p><p id="8f54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">道格·麦克洛伊的<a class="ae kv" href="https://www.cs.dartmouth.edu/~doug/powser.html" rel="noopener ugc nofollow" target="_blank"> Power Serious </a>很好地说明了这一点:Haskell中无穷幂级数的一个完整的10行实现。</p><p id="0efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是其中的一句:</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="302c" class="mv lu iq mr b be mw mx l nr mz">series f = f : repeat 0</span></pre><p id="d673" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Haskell中，一个基本的数据结构是懒惰列表。函数<code class="fe na nb nc mr b">series</code>创建了这样一个列表。列表的第一个元素是数字<code class="fe na nb nc mr b">f</code>，其余都是零。列表构造函数<code class="fe na nb nc mr b">:</code>在列表前添加一个元素。标准函数<code class="fe na nb nc mr b">repeat s</code>创建了一个<code class="fe na nb nc mr b">s</code>的无限列表。</p><p id="4471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">具体来说，<code class="fe na nb nc mr b">series 13</code>代表无限列表<code class="fe na nb nc mr b">[13, 0, 0, 0,...]</code>。但是由于它很懒，所以只在需要的时候计算元素。获取元素的一种方法是使用函数<code class="fe na nb nc mr b">take n</code>，它从列表的前面获取<code class="fe na nb nc mr b">n</code>元素。换句话说，<code class="fe na nb nc mr b">take 4 (series 13)</code>产生<code class="fe na nb nc mr b">[13, 0, 0, 0]</code>。</p><p id="5f84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，你可能认为懒惰列表只是迭代器。像惰性列表一样，迭代器是按需计算的，可以用来表示无限的数据结构。下面是作为Python生成器的<code class="fe na nb nc mr b">series</code>:</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="f145" class="mv lu iq mr b be mw mx l my mz">def series(f: int) -&gt; Iterable[int]:<br/>    yield f<br/>    while True:<br/>        yield 0</span></pre><p id="3dd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不同之处在于，惰性列表在对列表元素求值时缓存它们。像这样的程序:</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="31cc" class="mv lu iq mr b be mw mx l nr mz">myList = series 10 --list thunk is created<br/>some = take 5 myList --eval first 5 elements<br/>somemore = take 20 myList --eval 15 more elements</span></pre><p id="a792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总共只计算20个值。迭代器有时无法重置，如果可以重置，整个计算将从头开始。懒惰列表就不是这样了！</p><p id="56dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到权力严肃。道格·麦克洛伊使用惰性列表来表示无穷幂级数的系数。换句话说，列表<code class="fe na nb nc mr b">[1, 2, 3, 4, 0, ...]</code>代表幂级数1 + 2𝑥 + 3𝑥 + 4𝑥 +...</p><p id="0fd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是两个幂级数的加法:</p><pre class="kg kh ki kj gt mq mr ms bn mt mu bi"><span id="209a" class="mv lu iq mr b be mw mx l nr mz">(f:ft) + (g:gt) = f+g : ft+gt</span></pre><p id="0b92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Haskell的语法很简洁。在这一行中，<code class="fe na nb nc mr b">:</code>和<code class="fe na nb nc mr b">+</code>符号都是重载的。等号左边的<code class="fe na nb nc mr b">:</code>符号表示列表解构。右边表示列表构造。这张图片用颜色区分了每个符号的不同含义，以阐明:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/30e34b206a46815e82ce820536768eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0OmjjQIlOASDJ_jAkV-4A.png"/></div></div></figure><p id="cd39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等等——没有基本情况的递归定义？这只能归功于懒惰的评估。当需要两个序列的和的第一个元素时，表达式<code class="fe na nb nc mr b">f+g</code>又需要<code class="fe na nb nc mr b">f</code>和<code class="fe na nb nc mr b">g</code>，这通过懒惰模式匹配<code class="fe na nb nc mr b">(f:ft)</code>和<code class="fe na nb nc mr b">(g:gt)</code>触发对左右列表的第一个元素的评估。延迟对<code class="fe na nb nc mr b">ft+gt</code>的进一步评估，直到需要更多元素。当需要第二个元素时，重复这个过程，依此类推。</p><p id="7954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">惰性无限列表简化了一切:不需要检查列表何时结束，因为它没有结束，也不需要递归的基本情况，因为我们只在需要时递归。</p><h1 id="c6ee" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">概述</h1><p id="5c7c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这个小块讨论了一堆术语。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/1b874b8f211af077f4c1c93670b8b682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtQDeNIh6vzl3V1QXhqmig.png"/></div></div></figure><p id="7a27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将<em class="ls">评估策略</em>分为两类:严格和非严格。</p><p id="9e2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在严格计算中，首先计算表达式的所有子表达式。非严格评估包含所有做其他事情的策略，包括根本不评估某些参数。</p><p id="8176" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">严格评估有时被称为热切评估，听起来像是懒惰评估的对应。然而，懒惰评估只是许多可能的非严格策略中的一种。惰性求值非常突出，因为它额外缓存了结果，但只有在表达式没有副作用的情况下才有可能。</p><p id="d3c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，严格和非严格求值通常在一种编程语言中一起使用，甚至在同一个表达式中。因此出现了图像中的交叉点。一个例子是<code class="fe na nb nc mr b">if...else...</code>:条件的评估是严格的，但是两个子句的评估是非严格的。</p><p id="3f8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我打算每个月写一个半字节。更多信息，请<a class="ae kv" href="https://getcode.substack.com/subscribe?" rel="noopener ugc nofollow" target="_blank">订阅我的新信件</a>和<a class="ae kv" href="https://twitter.com/kurt2001" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a>。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="f84b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">原载于</em><a class="ae kv" href="https://getcode.substack.com/p/a-nibble-of-lazy-evaluation" rel="noopener ugc nofollow" target="_blank"><em class="ls"/></a></p></div></div>    
</body>
</html>