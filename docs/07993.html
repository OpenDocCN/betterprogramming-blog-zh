<html>
<head>
<title>Differences Between Git Merge and Rebase — and Why You Should Care</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git Merge和Rebase之间的区别——以及您应该关注的原因</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/differences-between-git-merge-and-rebase-and-why-you-should-care-ae41d96237b6?source=collection_archive---------0-----------------------#2021-03-12">https://betterprogramming.pub/differences-between-git-merge-and-rebase-and-why-you-should-care-ae41d96237b6?source=collection_archive---------0-----------------------#2021-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6482" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">git merge和rebase命令的比较以及何时使用它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c66c539c0900c9ac5403289aff79d04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H0368Iggh2NfKP1CK8Pvhw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Joey Kyber 在<a class="ae kv" href="https://unsplash.com/s/photos/traffic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0f3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不管您的项目使用哪种分支策略，在分支之间集成代码变更是您几乎每天都需要做的事情。有两个主要的选择，要么你选择T1，要么你选择T2。</p><p id="4ed9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将说明并强调这两个选项之间的区别，并指出在执行这些操作时需要注意的事项。</p><p id="dc5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我将使用动画单独演示这两个操作，最后以并排比较结束。如果您已经熟悉了这些操作的工作方式，请随意跳到比较部分。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="e256" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">阅读官方Git手册，它指出<code class="fe ls lt lu lv b">rebase</code> <em class="md">“在另一个基础分支之上重新应用提交”</em>，而<code class="fe ls lt lu lv b">merge</code> <em class="md">“将两个或更多的开发历史结合在一起”</em>。换句话说，merge和rebase的主要区别在于,<em class="md"> merge保留了发生的历史，而rebase重写了它。在我们仔细研究它们各自的内部工作方式以理解这到底意味着什么之前，让我们先来看一个例子。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/df8ee8d8240706f25266ae1822f0db49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mdvCMCaHWVBIdn6Xynpc5Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从Satoshi的角度看历史树，为了方便起见，远程“原点”别名为“o”。还要注意，本地“主”分支(C1)目前落后于远程对应的“o/master”(C4)。</p></figure><p id="cc6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看上面的例子，我们看到开发人员Ada和Satoshi最初创建了两个主题分支(<code class="fe ls lt lu lv b">feature-1</code>和<code class="fe ls lt lu lv b">feature-2</code>)，源自<code class="fe ls lt lu lv b">master</code>分支上的同一个提交(<code class="fe ls lt lu lv b">C1</code>)。然后Ada通过将<code class="fe ls lt lu lv b">feature-1</code>合并到<code class="fe ls lt lu lv b">master</code>中来完成<code class="fe ls lt lu lv b">feature-1</code>(创建合并提交<code class="fe ls lt lu lv b">C4</code>)。Satoshi现在有两个选择来将Ada的改变整合到他的分支<code class="fe ls lt lu lv b">feature-2</code>——合并或重定基础。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="49e8" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">合并</h1><p id="e9f8" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">让我们从集成变更最常见的工作流程开始:合并。在Satoshi准备好将Ada的更改合并到<code class="fe ls lt lu lv b">feature-2</code>之前，他必须首先更新他的本地<code class="fe ls lt lu lv b">master</code>引用，因为它目前落后了。一旦<code class="fe ls lt lu lv b">master</code>和<code class="fe ls lt lu lv b">o/master</code>同步，Satoshi就准备好将所有内容合并到他的主题分支中。</p><p id="de8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请看这个30秒钟的动画演示过程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">演示合并工作流的动画。(只有视频，没有音频)</p></figure><p id="d2eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着所有的变化都被合并到<code class="fe ls lt lu lv b">feature-2</code>中，Satoshi现在可以继续开发这个分支，每当它完成时，通过将其合并回<code class="fe ls lt lu lv b">master</code>来完成它。</p><p id="b93b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是合并操作的最终结果。正如您所看到的，开发历史被保留了下来，只是添加了<code class="fe ls lt lu lv b">C7</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/2c7aacf956f91b098d9589d3d9c5ca32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqggsi8BEPYPRk5iBqSwuA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过将来自“主”的改变合并到“特征-2”中，历史被保留为它发生时的样子，并且仅引入合并提交“C7”。</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><blockquote class="ne nf ng"><p id="8575" class="kw kx md ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">被移动的头部指针搞糊涂了？检查我关于这个主题的另一个帖子！</p></blockquote><div class="nk nl gp gr nm nn"><a href="https://blog.git-init.com/what-is-head-in-git/" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">Git中的HEAD是什么？</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">HEAD回答了这个问题:我现在在存储库中的什么位置？它是一个指向当前检出分支的指针…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">blog.git-init.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kp nn"/></div></div></a></div><h1 id="a81f" class="mf mg iq bd mh mi oc mk ml mm od mo mp jw oe jx mr jz of ka mt kc og kd mv mw bi translated">重定…的基准</h1><p id="018e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">记住了基本的合并工作流，现在是时候从rebase的角度来看同一个例子了。就像合并的情况一样，在Satoshi开始整合变更之前，他必须首先确保他的本地和远程分支同步。但是，Satoshi可以使用rebase来整合所有的更改，因此<em class="md">“重写历史”</em>，而不是进行常规的合并“<em class="md">保留发生的历史</em>”。</p><p id="dc9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将<code class="fe ls lt lu lv b">feature-2</code>重置到<code class="fe ls lt lu lv b">master</code>上，Git将一个接一个地回卷并重新应用提交<code class="fe ls lt lu lv b">C5</code>和<code class="fe ls lt lu lv b">C6</code>,<strong class="ky ir">将</strong>直接重置到<code class="fe ls lt lu lv b">C4</code>上，使得<code class="fe ls lt lu lv b">feature-2</code>看起来像是最初从Ada的已完成变更的顶端分支出来的。</p><p id="23f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">观看这个30秒钟的动画，了解实际操作过程:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">演示重设基础工作流的动画。(只有视频，没有音频)</p></figure><p id="931a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着所有的变化再次整合，Satoshi准备继续他的主题分支工作。</p><p id="7f7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是rebase操作的最终结果。注意提交<code class="fe ls lt lu lv b">C5</code>和<code class="fe ls lt lu lv b">C6</code>是如何被直接重新应用到<code class="fe ls lt lu lv b">C4</code>上的，重写了开发历史并完全删除了旧的提交！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/ff6530368f78864516f444face1b4834.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8zg5Hb3QvUiL8u1D5Gu2w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">请注意C5和C6的散列是如何变化的，原因很简单，因为它实际上是新创建的提交(尽管内容可能仍然相同)。</p></figure><p id="e5f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然我们知道了merge和rebase的区别，是时候更详细地考察这两种结果了。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="78b1" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">合并和重设基础有何不同</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/b841279cfebd200a246cd6ec3c58ba29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y77kjfj3xgPz_YRYa8Zmsg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">最终状态的并排图示，最左边是开始情况。</p></figure><p id="4307" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在上面看到的，合并操作通过创建一个新的单个合并提交(<code class="fe ls lt lu lv b">C7</code>)将分支缠绕在一起，产生了一个菱形的非线性历史——本质上是<em class="md">保留了发生的历史。</em>通过将这个结果与rebase动作的结果进行比较，我们看到没有创建合并提交，相反，两个提交<code class="fe ls lt lu lv b">C5</code>和<code class="fe ls lt lu lv b">C6</code>只是被倒带并直接应用到<code class="fe ls lt lu lv b">C4</code>之上，保持了历史的线性。如果我们进一步仔细检查这两个重新应用的提交，我们可以看到散列已经改变，这表明rebase真正地重写了历史。</p><p id="a95b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">因此，以前的提交最终将从历史中完全删除。</strong></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="f026" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">权力越大，责任越大</h1><p id="1255" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们已经看到rebase如何重写历史，而merge如何保存历史。但这在更广泛的意义上意味着什么呢？以及这两种操作带来了哪些可能性和潜在的弊端？</p><h2 id="e785" class="oh mg iq bd mh oi oj dn ml ok ol dp mp lf om on mr lj oo op mt ln oq or mv os bi translated"><strong class="ak">冲突变更</strong></h2><p id="036a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">比方说，你在试图整合变更时遇到了一些令人讨厌的冲突。在合并场景中，您只需要解决一次冲突，直接在<code class="fe ls lt lu lv b">C7</code>提交中。另一方面，使用rebase，您可能不得不在每次提交(<code class="fe ls lt lu lv b">C5</code>和<code class="fe ls lt lu lv b">C6</code>)时解决类似的冲突，因为它们被重新应用。</p><p id="bf49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果冲突不那么容易解决，这可能表明你和你的同事没有进行足够的沟通，因为你已经在同一个文件上工作了太长时间。</p><h2 id="2565" class="oh mg iq bd mh oi oj dn ml ok ol dp mp lf om on mr lj oo op mt ln oq or mv os bi translated"><strong class="ak">出版分支</strong></h2><p id="c4bd" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">另一个与重定基础相关的潜在问题发生在当你重定基础的分支已经被远程发布，并且其他人已经基于它工作的时候。然后，你的重定基础的分支会给所有相关方带来严重的混乱和头痛，因为Git会告诉你你的分支同时超前和滞后。如果发生这种情况，使用rebase标志(<code class="fe ls lt lu lv b">git pull --rebase</code>)提取远程更改通常可以解决问题。</p><p id="f2ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，无论何时，当你重新构建一个已经发布的分支时，不管是否没有其他人基于它工作，你仍然需要<em class="md">强制推送</em>它来获得你对远程服务器的更新——完全覆盖现有的远程引用。</p><h2 id="cfc3" class="oh mg iq bd mh oi oj dn ml ok ol dp mp lf om on mr lj oo op mt ln oq or mv os bi translated"><strong class="ak">数据丢失(对您有利)</strong></h2><p id="3a7d" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">最后，由于rebase重写了历史，而merge保留了历史，因此在rebase时实际上可能会丢失数据。当重新应用新的提交时，旧的提交将被删除(最终，在垃圾收集之后)。事实上，同样的特性也是rebase如此强大的原因——它允许您在公开发布之前整理开发历史！使用一个<em class="md">交互式rebase </em>(下一篇文章的主题)，你可以删除不想要的提交，压缩变更，或者简单地更新提交消息。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="7aef" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated"><strong class="ak">重设基本经验法则</strong></h1><p id="0aa0" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">为了避免与重定基数相关的最常见问题，我建议坚持以下规则:</p><ul class=""><li id="2bba" class="ot ou iq ky b kz la lc ld lf ov lj ow ln ox lr oy oz pa pb bi translated">不要改变远程发布的分支的基础…</li><li id="43ad" class="ot ou iq ky b kz pc lc pd lf pe lj pf ln pg lr oy oz pa pb bi translated">…除非你知道只有你一个人在做这件事(并感到安全用力)</li><li id="179c" class="ot ou iq ky b kz pc lc pd lf pe lj pf ln pg lr oy oz pa pb bi translated">在重定基础之前，从你要重定基础的分支的顶端创建一个备份分支，因为它将允许你容易地比较结果(一旦完成)并且在必要时跳回到重定基础之前的状态。</li></ul></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="caf9" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">更高级的重定基础案例</h1><p id="23fb" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">rebase还有许多更高级的用例，这些都超出了本文的范围，但将是后续文章的一部分。正如已经提到的，其中一个比较突出的特性是<em class="md">交互式rebase </em>，它允许你定制每个提交应该如何被重新应用。</p><p id="0eba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式可以用来分割提交、压缩提交、重新排序提交，甚至完全删除提交，这只是其中的几种可能性。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="54a0" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">结论</h1><p id="272e" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">许多开发人员倾向于只使用<code class="fe ls lt lu lv b">merge</code>而不使用<code class="fe ls lt lu lv b">rebase</code>，通常的评论是“至少我知道我不会丢失任何工作。”从某种意义上说，不使用您不习惯使用的工具是一种可靠的方法。但是没有学会充分利用强大的功能，即使你知道它们的存在，也不是一个好方法！</p><p id="c3b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有点像说，“我知道我有一辆很棒的车，但我更喜欢坚持第一档，因为我知道速度会致命，”而不是学习如何换高档，并在更高的速度下安全行驶。</p><p id="4661" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以我的经验来看，学习如何使用<code class="fe ls lt lu lv b">rebase</code>尤其会加深你对Git的理解，从总体上提高你作为一个整体开发人员的能力——尤其是在源代码管理方面！</p><p id="6443" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在我职业生涯的早期，我从一位高级开发人员那里得到的最好的建议之一是:“放弃源代码树中的按钮攻击，转而学习如何从终端使用Git命令！否则，您将永远无法获得使用Git的全部好处，并且以后也无法编写任何自动化管道。”</p><p id="3984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从那以后，我只用<a class="ae kv" href="https://git-scm.com/docs/gitk" rel="noopener ugc nofollow" target="_blank"> GitK </a>作为查看历史树的视觉辅助。我在终端输入所有命令。建议你也这样做！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="300d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你知道了合并和重定基础的不同之处，我希望你在开始使用它们的时候更有信心。</p><p id="46a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，祝您好运，提高您的源代码管理技能！</p></div></div>    
</body>
</html>