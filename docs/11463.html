<html>
<head>
<title>The Future of Concurrency Handling in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift并发处理的未来</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-future-of-concurrency-handling-in-swift-f75ab24d6ba8?source=collection_archive---------12-----------------------#2022-03-22">https://betterprogramming.pub/the-future-of-concurrency-handling-in-swift-f75ab24d6ba8?source=collection_archive---------12-----------------------#2022-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9449" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Async/await、actors以及如何使用它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8e24cdc55c0d1d0d03020892ae56c8b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk-iGixNnxsG5iSVZeE3Hg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">资料来源:undraw</p></figure><p id="13c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">炒作终于真实了。在iOS 15和Xcode 13的推出中，苹果带来了一种新的方式来支持并发，并以更结构化的方式编写异步和并行代码。它是由swift-evolution GitHub知识库上的社区提出的。如果你对它很好奇，<a class="ae lr" href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" rel="noopener ugc nofollow" target="_blank">你可以在这里查看一下，值得一看</a>。还有，而且随着Xcode 13.2的推出，Swift并发已经回移植到iOS 13，这显然是一个天大的好消息！现在让我们开始吧。</p><h1 id="9951" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">异步ˌ非同步(asynchronous)</h1><p id="2d63" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这是Swift中异步的一个关键字。这里是为了标记一个方法将执行一个异步任务。这里有一个例子</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="606a" class="mu lt iq mq b gy mv mw l mx my">func getStuff() async -&gt; String {   <br/>    return "stuff"<br/>}</span></pre><p id="ef7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，在这个方法中没有执行真正的异步任务(我们将在本文后面添加代码),但是它已经准备好接受一些任务，因为我们用<code class="fe mz na nb mq b">async</code>标记了方法的签名</p><h1 id="8ca7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">等待</h1><p id="e259" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">是另一个应该和<code class="fe mz na nb mq b">async</code>配对的关键词。当之前用来调用一个<code class="fe mz na nb mq b">async</code>方法时，它告诉代码等待它的执行和返回。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="49e3" class="mu lt iq mq b gy mv mw l mx my">let stuff = await getStuff()<br/>print(stuff)</span></pre><p id="a7eb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，<code class="fe mz na nb mq b">print(stuff)</code>不会被执行，直到<code class="fe mz na nb mq b">await getStuff()</code>返回值。这就是为什么这种处理并发的方法比其他方法干净得多:它简单而高效。</p><h1 id="1ff0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何一起使用它们</h1><p id="4891" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我们把所有的东西放在一起。如果你试图这样调用你的<code class="fe mz na nb mq b">async</code>方法</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8403" class="mu lt iq mq b gy mv mw l mx my">func fetchData() {<br/>    do {<br/>        let stuff = try await getStuff()<br/>        print(stuff)<br/>    } catch {<br/>        print(error)<br/>    }<br/>}</span></pre><p id="3816" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你将会得到一个来自编译器的错误</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4997" class="mu lt iq mq b gy mv mw l mx my">'async' call in a function that does not support concurrency</span></pre><p id="8763" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<code class="fe mz na nb mq b">fetchData()</code>签名上放一个<code class="fe mz na nb mq b">async</code>关键字来解决这个问题……但是你必须对调用<code class="fe mz na nb mq b">fetchData()</code>的方法做同样的事情，等等。</p><p id="25d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们将使用一个<code class="fe mz na nb mq b">Task.init</code>方法从一个支持并发的新任务中调用异步方法。这被称为非结构化并发。这意味着我们在这里创建的任务没有父任务，因此我们可以完全灵活地管理它。</p><p id="ae14" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">综合所有因素，结果如下:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="f543" class="mu lt iq mq b gy mv mw l mx my">func getStuff() async throws -&gt; String {<br/>    let url = URL(string: "https://niceurl/api/stuff")!<br/>    let (data,_) = try await URLSession.shared.data(from: url)<br/>    let string = String(data: data, encoding: .utf8) ?? ""<br/>    return string<br/>}</span><span id="fe0e" class="mu lt iq mq b gy nc mw l mx my">func fetchData() {<br/>    Task.init {<br/>        do {<br/>            let stuff = try await getStuff()<br/>            print(stuff)<br/>        } catch {<br/>            print(error)<br/>        }<br/>    }<br/>}</span></pre><p id="5739" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以注意到<code class="fe mz na nb mq b">getStuff()</code>中添加的代码。使用<code class="fe mz na nb mq b">URLSession</code>是一个简单的请求，但有趣的是，我们在呼叫线上有另一个<code class="fe mz na nb mq b">await</code>。它显然会在处理数据并将字符串返回给<code class="fe mz na nb mq b">fetchData()</code>方法之前等待服务器的回复。一个小的附带说明是，你完全可以在<code class="fe mz na nb mq b">async</code>后添加关键字<code class="fe mz na nb mq b">throws</code>，然后用<code class="fe mz na nb mq b">try-catch</code>处理你的错误。</p><p id="1229" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，这是一种它可以替换的代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8cb6" class="mu lt iq mq b gy mv mw l mx my">func getStuff(completion: @escaping (Result&lt;String, Error&gt;)-&gt;()) {<br/>    let url = URL(string: "https://niceurl/api/stuff")!<br/>    let task = URLSession.shared.dataTask(with: url) {<br/>        data, response, error in<br/>        if let error = error {<br/>            completion(.failure(error))<br/>        } else if let data = data {<br/>            let string = String(data: data, encoding: .utf8) ?? ""<br/>            completion(.success(string))<br/>        }<br/>    }<br/>    task.resume()<br/>}</span><span id="054c" class="mu lt iq mq b gy nc mw l mx my">getStuff(completion: { result in<br/>    switch result {<br/>    case .success(let value):<br/>        print(value)<br/>    case .failure(let error):<br/>        print(error.localizedDescription)<br/>    }<br/>})</span></pre><p id="c963" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码更加清晰，可读性更好，因此明显更不容易出错。此外，不使用闭包避免了保留循环的风险(补充说明:当使用闭包时，不要忘记削弱自身或任何外部属性)。最后，一个很好的优势是您可以像前面看到的那样在实现级别使用<code class="fe mz na nb mq b">try-catch</code>，这对于完成块是不可能的。</p><h1 id="85ac" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关于任务的更多信息</h1><p id="8b57" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">为了把所有的东西放在一起，我们稍微谈了一下任务，更具体地谈了一下<code class="fe mz na nb mq b">Task.init</code>。还有两件事需要注意。第一，虽然<code class="fe mz na nb mq b">Task.init</code>是一个运行在当前actor上的非结构化任务，但是您也可以使用<code class="fe mz na nb mq b">Task.detached</code>运行一个不属于当前actor的非结构化任务。第二，这两个方法都返回一个任务句柄，允许你和任务进行一些交互，比如说，如果需要的话可以取消任务。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a10b" class="mu lt iq mq b gy mv mw l mx my">func fetchData() {<br/>    let taskHandle = Task.detached {<br/>        do {<br/>            let stuff = try await getStuff()<br/>            print(stuff)<br/>        } catch {<br/>            print(error)<br/>        }<br/>    }<br/>    taskHandle.cancel()<br/>}</span></pre><h1 id="be92" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">并行调用异步函数</h1><p id="b867" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">如果您尝试像这样运行多个<code class="fe mz na nb mq b">await</code>调用</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="44bc" class="mu lt iq mq b gy mv mw l mx my">Task.init {<br/>    do {<br/>        let stuff0 = try await getStuff(id: 0)<br/>        let stuff1 = try await getStuff(id: 1)<br/>        let stuff2 = try await getStuff(id: 2)<br/>        print(stuff0, stuff1, stuff2)<br/>    } catch {<br/>        print(error)<br/>    }<br/>}</span></pre><p id="576e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你将面临一个小问题。尽管所有这些<code class="fe mz na nb mq b">getStuff(id:)</code>调用都是异步的，但此时只有一个调用会运行，而其他调用会等待前一个调用完成后才开始运行。但是在我们的例子中，不需要等待上一次调用，因为每个调用都可以独立运行。</p><p id="8979" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢天谢地，苹果为我们提供了一个解决方案来应对这种情况</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="41fb" class="mu lt iq mq b gy mv mw l mx my">Task.init {<br/>    do {<br/>        async let stuff0 = try getStuff(id: 0)<br/>        async let stuff1 = try getStuff(id: 1)<br/>        async let stuff2 = try getStuff(id: 2)<br/>        try await print(stuff0, stuff1, stuff2)<br/>    } catch {<br/>        print(error)<br/>    }<br/>}</span></pre><p id="a510" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只需在您想要将调用结果赋给的let常量前写<code class="fe mz na nb mq b">async</code>，然后在您想要使用该常量时写<code class="fe mz na nb mq b">await</code>。这个例子中的一个小变化是，您需要将<code class="fe mz na nb mq b">try</code>放在<code class="fe mz na nb mq b">await</code>的前面。有了这个实现，所有的<code class="fe mz na nb mq b">getStuff(id:)</code>调用都是单独运行的，不需要等待前一个调用。最后，由于我们之前讨论过任务，<code class="fe mz na nb mq b">async let</code>语法为您创建了一个子任务，可以在任务组中添加和管理它。如果你想了解更多关于任务组的信息，请查看由<a class="ae lr" href="https://www.hackingwithswift.com/about" rel="noopener ugc nofollow" target="_blank">保罗·哈德森</a>撰写的<a class="ae lr" href="https://www.hackingwithswift.com/quick-start/concurrency/how-to-create-a-task-group-and-add-tasks-to-it" rel="noopener ugc nofollow" target="_blank">这篇文章。</a></p><h1 id="dd17" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">行动者</h1><p id="b10c" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">类似于类，它是一个引用类型，这意味着引用类型和值类型(如struct)之间的比较适用于<code class="fe mz na nb mq b">actor</code>类型。关键的区别在于参与者一次只允许一个任务访问它们的可变状态，这使得多个任务中的代码可以安全地与同一个<code class="fe mz na nb mq b">actor</code>实例进行交互。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="21af" class="mu lt iq mq b gy mv mw l mx my">actor Stuff {<br/>    let name: String<br/>    var numberOf: Int</span><span id="f579" class="mu lt iq mq b gy nc mw l mx my">    init(name: String, numberOf: Int) {<br/>        self.name = name<br/>        self.numberOf = numberOf<br/>    }<br/>}</span></pre><p id="dd78" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关键字<code class="fe mz na nb mq b">actor</code>替换了类，你只需使用它的初始化器来初始化它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="58b1" class="mu lt iq mq b gy mv mw l mx my">Stuff(name: "Great Stuff", numberOf: 42)</span></pre><p id="5b6d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后，您拉回关键字<code class="fe mz na nb mq b">await</code>来访问您的<code class="fe mz na nb mq b">actor</code>的一个属性</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bec0" class="mu lt iq mq b gy mv mw l mx my">print(await greatStuff.name)</span></pre><p id="b707" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是这里有一些重要的事情需要注意。上面的代码是一个可能的暂停点。因为一个<code class="fe mz na nb mq b">actor</code>一次只能让一个任务访问它的可变状态，这意味着直到<code class="fe mz na nb mq b">actor</code>允许它访问它的属性名，这段代码才会执行。</p><p id="9a7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">也就是说，您不需要编写<code class="fe mz na nb mq b">await</code>来从actor内部访问代码。例如，如果您正在修改一个由<code class="fe mz na nb mq b">actor</code>拥有的方法的属性，您就处于所谓的actor局部状态，这意味着只有在<code class="fe mz na nb mq b">actor</code>内部的代码才能访问这个状态。Swift通过强制从外部调用<code class="fe mz na nb mq b">actor</code>的代码与<code class="fe mz na nb mq b">await</code>配对来保证这一点，如果不这样做就无法编译。苹果称之为<em class="nd">演员隔离</em>，这也是<code class="fe mz na nb mq b">actor</code>安全的原因。</p><h1 id="67c0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="461d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><code class="fe mz na nb mq b">async / await</code>和<code class="fe mz na nb mq b">actor</code>即将成为Swift中处理并发任务的默认解决方案。由于Xcode 13.2和对iOS 13的支持，以及今年晚些时候iOS 16的到来，这个新概念肯定会在未来几个月丰富许多代码库。</p></div></div>    
</body>
</html>