<html>
<head>
<title>Implement a Clean MVVM Architecture in SwiftUI With Combine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Combine在SwiftUI中实现一个干净的MVVM架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-clean-mvvm-architecture-in-swiftui-with-combine-637246fa1342?source=collection_archive---------2-----------------------#2021-06-30">https://betterprogramming.pub/implement-a-clean-mvvm-architecture-in-swiftui-with-combine-637246fa1342?source=collection_archive---------2-----------------------#2021-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4de8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用配置器和路由器组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c0da596c17341a2d49a6bc1143591e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a0guH9VLvweddPl0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@yuhaispace?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">于海</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="2f2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何在SwiftUI应用中实现一个反应式MVVM架构。我们将使用干净架构建议和单一责任原则。</p><p id="908e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目的源代码可以在文章的底部找到。</p><p id="6ec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们将要构建的示例应用程序:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/396fe7a73f6d3c5c9732bef303c011c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/1*frb6pTHP85Foe31qhMezVg.gif"/></div></figure><p id="6a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个名为Dummy API的免费REST API:</p><div class="lw lx gp gr ly lz"><a href="https://dummyapi.io" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">虚拟API</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">拥有虚假数据的全周期REST/GraphQL生产API服务器，100个用户，800多个帖子，1000条评论，24/7可用…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">dummyapi.io</p></div></div></div></a></div></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="a91f" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">我们开始吧</h1><p id="886a" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">我们项目的结构如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/3e5781e187dad8f9e88670ef7099d767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*WSLpS7pfsKJaTeaRVBfgtg.png"/></div></figure><p id="e03d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是<code class="fe nn no np nq b">Presentation</code>层的每个模块包含的组件:</p><ul class=""><li id="d420" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe nn no np nq b">Configurator</code>:创建一个<code class="fe nn no np nq b">View</code>，并为其提供一个<code class="fe nn no np nq b">View Model</code>。</li><li id="d77a" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nn no np nq b">View</code>:被动，不包含任何商业逻辑。它唯一的职责是显示UI元素。</li><li id="06eb" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nn no np nq b">View Model</code>:通过拥有<code class="fe nn no np nq b">Published</code>属性并将它们绑定到从<code class="fe nn no np nq b">Service</code>接收的数据来模拟<code class="fe nn no np nq b">View</code>的状态。</li><li id="f652" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nn no np nq b">Router</code>:负责导航相关任务。例如，它在一个特定的视图中提供了一个目的地为<code class="fe nn no np nq b">View</code>的<code class="fe nn no np nq b">NavigationLink</code>。</li></ul><p id="5987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Business Logic</code>层由以下组件组成:</p><ul class=""><li id="2f79" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu nw nx ny nz bi translated"><code class="fe nn no np nq b">Services</code>:执行业务逻辑，比如获取一个<code class="fe nn no np nq b">User</code>对象的数组，但是不包含<code class="fe nn no np nq b">URLSession</code>这样的底层实现。他们的目标是检索a <code class="fe nn no np nq b">ViewModel</code>想要处理的特定对象。</li><li id="455e" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nn no np nq b">Models</code>:a<code class="fe nn no np nq b">Service</code>为a <code class="fe nn no np nq b">View Model</code>获取的对象。例如，一个<code class="fe nn no np nq b">Codable</code>结构。</li><li id="8fca" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><code class="fe nn no np nq b">Endpoints</code>:特定的REST API端点。比如用于获取用户的<a class="ae ky" href="https://dummyapi.io/" rel="noopener ugc nofollow" target="_blank">伪API </a>端点。</li></ul><p id="6fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">Core</code>层可以包含负责网络和持久性的类。它还可以包含助手扩展。</p><p id="7975" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干净架构的思想是让高层总是依赖于低层，而不是相反。在我们的应用程序中，<code class="fe nn no np nq b">Presentation</code>层依赖于<code class="fe nn no np nq b">Business Logic</code>层，后者依赖于<code class="fe nn no np nq b">Core</code>层。<code class="fe nn no np nq b">Core</code>层对<code class="fe nn no np nq b">Business Logic</code>一无所知。而<code class="fe nn no np nq b">Business Logic</code>完全不知道<code class="fe nn no np nq b">Presentation</code>。</p><p id="7e95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们从底层开始，深入研究实现。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="d2a1" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">核心</h1><p id="0a87" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">该层包含<code class="fe nn no np nq b">Endpoint</code>结构，稍后将在业务逻辑层中用于创建特定的REST API基本URL和端点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="af97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们有一个<code class="fe nn no np nq b">Networker</code>，它专门负责处理<code class="fe nn no np nq b">URLSession</code>并返回一个包含简单<code class="fe nn no np nq b">Data</code>或解码<code class="fe nn no np nq b">Codable</code>模型的<code class="fe nn no np nq b">Publisher</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="65bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解以上网络组件实现的更多信息，请随意查看我在主题为的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/implement-a-networking-layer-using-combine-in-swift-5-8a83e3ac9bae?source=friends_link&amp;sk=2f118f61b449ece0f90f16321b53f035">文章。</a></p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ae9a" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">业务逻辑</h1><p id="2538" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">首先，我们需要定义<a class="ae ky" href="https://dummyapi.io/" rel="noopener ugc nofollow" target="_blank">虚拟API </a>特定的基本URL:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="9e64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们需要在<code class="fe nn no np nq b">headers</code>属性中提供一个应用程序ID。在<a class="ae ky" href="https://dummyapi.io" rel="noopener ugc nofollow" target="_blank">伪API网站</a>注册账号即可免费获得。</p><p id="e04d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们添加端点来获取用户和具有所提供ID的特定用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0299" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在是时候定义我们将在应用程序中使用的模型了。从虚拟API返回的JSON数据如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们这样定义<code class="fe nn no np nq b">Users</code>和<code class="fe nn no np nq b">User</code>模型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="53b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我提供了一个扩展来生成一个假的<code class="fe nn no np nq b">User</code>。我们将在稍后的SwiftUI预览中使用它。</p><p id="acbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成<code class="fe nn no np nq b">Models</code>之后，是时候创建我们的<code class="fe nn no np nq b">Services</code>了。我们需要创建的第一个负责获取一组用户和一个特定用户，并提供<code class="fe nn no np nq b">id</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="2e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe nn no np nq b">UsersService</code>依赖于<code class="fe nn no np nq b">Networker</code>组件，它是之前定义的<code class="fe nn no np nq b">Core</code>层的一部分。</p><p id="cab5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们添加一个类似的<code class="fe nn no np nq b">Service</code>来获取特定用户的图片:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="7d26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经完成了<code class="fe nn no np nq b">Business Logic</code>层。现在我们终于可以在<code class="fe nn no np nq b">Presentation</code>上工作了。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="499c" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">介绍会；展示会</h1><p id="a3b9" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">首先，我们要创建这个屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/8819c9715028b7988217b906e74614f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xYYQFcrIOXeW-yv1T0_oTw.png"/></div></div></figure><p id="700a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从这个屏幕的<code class="fe nn no np nq b">View Model</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><ol class=""><li id="6bea" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu oi nx ny nz bi translated">我们有一个<code class="fe nn no np nq b">Published</code>属性，我们的<code class="fe nn no np nq b">View</code>将使用它来呈现一个用户数组。</li><li id="5af1" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们依赖于<code class="fe nn no np nq b">UsersServiceProtocol</code>，一个业务逻辑组件。通过依赖协议而不是具体的类，我们实现了<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖倒置</a>。这允许我们在需要时向<code class="fe nn no np nq b">UsersViewModel</code>提供假服务。我们将调用服务的<code class="fe nn no np nq b">getUsers(count:Int)</code>方法，并将结果绑定到第一步中定义的<code class="fe nn no np nq b">users</code>属性。我们还添加了<code class="fe nn no np nq b">cancellables</code>属性来存储未来的订阅。</li><li id="e9b7" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">如果我们想要初始的<code class="fe nn no np nq b">Users</code>数据，初始化器有一个属性。我们还可以注入一个符合<code class="fe nn no np nq b">UsersServiceProtocol</code>的类。默认情况下，它将是<code class="fe nn no np nq b">UsersService</code>。</li><li id="c528" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们将在我们的<code class="fe nn no np nq b">View</code>中运行<code class="fe nn no np nq b">onAppear()</code>方法。不知道运行时会发生什么。在幕后，<code class="fe nn no np nq b">UsersViewModel</code>将获取用户并更新<code class="fe nn no np nq b">Published</code>属性。因此，UI更新将被触发，我们将在屏幕上看到一个用户列表。</li><li id="d062" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">这里，我们有一个私有的<code class="fe nn no np nq b">getUsers(count: Int)</code>方法，一旦<code class="fe nn no np nq b">View</code>触发了<code class="fe nn no np nq b">onAppear()</code>方法，这个方法就会运行。</li></ol><p id="18c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以创建实际的<code class="fe nn no np nq b">UsersView</code>来显示用户:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><ol class=""><li id="e720" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu oi nx ny nz bi translated">我们提供了对<code class="fe nn no np nq b">UsersViewModel</code>的依赖。</li><li id="dba9" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们添加一个标题为“用户”的<code class="fe nn no np nq b">NavigationView</code></li><li id="b945" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">在<code class="fe nn no np nq b">NavigationView</code>中，我们显示了一个列表，将视图模型的<code class="fe nn no np nq b">users</code>属性作为它的数据。</li><li id="c51d" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们显示一个显示用户名字的<code class="fe nn no np nq b">Text</code>。它嵌入在一个<code class="fe nn no np nq b">NavigationLink</code>中，允许导航到<code class="fe nn no np nq b">UserDetailView</code>，我们将在后面定义。注意，<code class="fe nn no np nq b">UsersRouter</code>提供了这个特定动作的目的地。</li><li id="ce53" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">一旦<code class="fe nn no np nq b">NavigationView</code>出现，我们就发信号给<code class="fe nn no np nq b">UsersViewModel</code>。在幕后，视图模型将获取用户。</li></ol><p id="e942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成<code class="fe nn no np nq b">View</code>和<code class="fe nn no np nq b">View Model</code>之后，现在我们可以定义剩余的组件:<code class="fe nn no np nq b">Configurator</code>和<code class="fe nn no np nq b">Router</code>。</p><p id="1ffe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">UsersConfigurator</code>看起来很简单。它向<code class="fe nn no np nq b">UsersView</code>提供<code class="fe nn no np nq b">UsersViewModel</code>并返回:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="64c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在<code class="fe nn no np nq b">UsersApp</code>中使用它来设置窗口的初始<code class="fe nn no np nq b">View</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="c287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们添加<code class="fe nn no np nq b">UsersRouter</code>，它负责导航到<code class="fe nn no np nq b">UserDetail</code>屏幕:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="06fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还记得的话，我们在<code class="fe nn no np nq b">UsersView</code>的<code class="fe nn no np nq b">NavigationLink</code>中调用了这个方法来获得目的地<code class="fe nn no np nq b">View</code>。在方法内部，我们调用<code class="fe nn no np nq b">UserDetailConfigurator</code>的方法，用提供的<code class="fe nn no np nq b">User</code>对象创建<code class="fe nn no np nq b">UserDetailView</code>。我们将很快定义<code class="fe nn no np nq b">UserDetailConfigurator</code>和<code class="fe nn no np nq b">UserDetailView</code>。</p><p id="46bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！<code class="fe nn no np nq b">Users</code>模块完成。现在我们可以创建一个<code class="fe nn no np nq b">UserDetail</code>了。</p><p id="8f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">User Detail</code>模块显示这个简单的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9af2c74d5e0b1c0bc9269e4ce66f0afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Qsc5SclXjNUCgXqPgEWDQ.png"/></div></div></figure><p id="dc4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个<code class="fe nn no np nq b">UserDetailViewModel</code>开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><ol class=""><li id="a808" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu oi nx ny nz bi translated">就像在<code class="fe nn no np nq b">UsersViewModel</code>中一样，我们也有一个<code class="fe nn no np nq b">Published</code>属性，我们的<code class="fe nn no np nq b">UserDetailView</code>将使用它在屏幕上呈现图像。</li><li id="9f13" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们依赖于在<code class="fe nn no np nq b">UsersView</code>中选择的<code class="fe nn no np nq b">User</code>对象。</li><li id="469c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">类似地，我们有一个<code class="fe nn no np nq b">UserPictureServiceProtocol</code>依赖项和<code class="fe nn no np nq b">cancellables</code>属性。我们将使用该服务来获取用户的照片。</li><li id="b3c9" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">这一次，<code class="fe nn no np nq b">onAppear()</code>方法触发了一个图像加载操作。</li><li id="58df" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">私有的<code class="fe nn no np nq b">getAvatarData()</code>方法获得一个<code class="fe nn no np nq b">UIImage</code>，并将其绑定到前面定义的<code class="fe nn no np nq b">Published</code>属性。结果，<code class="fe nn no np nq b">UserDetailView</code>用用户的图像更新。</li></ol><p id="e1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如下实现<code class="fe nn no np nq b">UserDetailView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><ol class=""><li id="0d61" class="nr ns it lb b lc ld lf lg li nt lm nu lq nv lu oi nx ny nz bi translated">与<code class="fe nn no np nq b">UsersView</code>类似，我们对<code class="fe nn no np nq b">UserDetailViewModel</code>有依赖性。</li><li id="fe6f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们添加了一个<code class="fe nn no np nq b">State</code>属性，稍后我们将使用它在屏幕上显示一个包含更多用户信息的模态表。</li><li id="e834" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们添加了一个<code class="fe nn no np nq b">VStack</code>来垂直显示内容。</li><li id="1a83" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated"><code class="fe nn no np nq b">Image</code>视图被绑定到<code class="fe nn no np nq b">UserDetailViewModel</code>的<code class="fe nn no np nq b">Published</code>属性。一旦获得一个<code class="fe nn no np nq b">UIImage</code>，它将显示在<code class="fe nn no np nq b">Image</code>视图中。</li><li id="b9e3" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">添加了一个<code class="fe nn no np nq b">HStack</code>来显示用户的名字和姓氏。</li><li id="3ee8" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">我们添加了一个“获取更多信息”按钮。点击它会出现一个包含更多用户信息的表单。</li><li id="53f8" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">当我们点击它时，stateful <code class="fe nn no np nq b">showingModalSheet</code>属性切换，这导致在步骤8中显示一个工作表。</li><li id="0f69" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">类似于我们在<code class="fe nn no np nq b">UsersView</code>中所做的，我们参考<code class="fe nn no np nq b">UserDetailRouter</code>来获得用户执行的按钮点击动作的目的地<code class="fe nn no np nq b">View</code>。</li><li id="d694" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu oi nx ny nz bi translated">当上面的<code class="fe nn no np nq b">VStack</code>出现在屏幕上时，我们向<code class="fe nn no np nq b">UserDetailView</code>发出开始工作的信号。</li></ol><p id="8dcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">UserDetailConfigurator</code>和前面定义的<code class="fe nn no np nq b">UsersConfigurator</code>一样简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="cf60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还记得，当我们需要导航到<code class="fe nn no np nq b">UserDetailView</code>并且<code class="fe nn no np nq b">NavigationLink</code>需要目的地<code class="fe nn no np nq b">View</code>时，在<code class="fe nn no np nq b">UsersRouter</code>中调用了<code class="fe nn no np nq b">configureUserDetailView()</code>方法。</p><p id="c58b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户点击“获取更多信息”按钮时，<code class="fe nn no np nq b">UserDetailRouter</code>负责提供目的地<code class="fe nn no np nq b">View</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="507c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法在<code class="fe nn no np nq b">UserDetailView</code>的<code class="fe nn no np nq b">.sheet(isPresented:content:)</code>方法中被调用。</p><p id="33b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在只剩下最后一个屏幕——模态表。我提供它是为了展示我们如何执行模态表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/730f5bfedf1bdbca5e5a1df8d48b18ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yvzHdFYnrApSqFtHJQ5K8Q.png"/></div></div></figure><p id="a2c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">MoreInfoViewModel</code>仅仅依赖于<code class="fe nn no np nq b">User</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="5b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nn no np nq b">MoreInfoView</code>里面，我们没有什么新东西。这看起来很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="a8e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里所做的就是在一个<code class="fe nn no np nq b">VStack</code>中显示四个<code class="fe nn no np nq b">Text</code>视图。</p><p id="7160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nn no np nq b">MoreInfoConfigurator</code>使用提供的<code class="fe nn no np nq b">User</code>对象配置模块:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="0dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特定的模块没有导航到任何地方，所以我们这里没有<code class="fe nn no np nq b">Router</code>。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="f4cd" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">资源</h1><p id="0d1e" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">该项目的源代码可以在<a class="ae ky" href="https://github.com/zafarivaev/swiftui-mvvm-clean" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="846b" class="mp mq it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">包扎</h1><p id="e9f3" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">太好了！我们已经创建了一个应用程序使用清洁MVVM的方法。我们还添加了<code class="fe nn no np nq b">Configurator</code>和<code class="fe nn no np nq b">Router</code>组件，将模块创建和导航任务排除在<code class="fe nn no np nq b">View</code>之外。如果我们在<code class="fe nn no np nq b">UserView</code>和<code class="fe nn no np nq b">UserDetailView</code>中有更多的目的地点，就像在真实的项目案例中一样，<code class="fe nn no np nq b">Router</code>类会更大。同样，如果我们需要更多的依赖来构建某个模块，<code class="fe nn no np nq b">Configurator</code>组件将包含更多的逻辑。</p><p id="bdd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要了解更多关于在SwiftUI应用中使用什么架构以及它们如何比较，请查看这篇由<a class="oj ok ep" href="https://medium.com/u/1c1a0c9cea4?source=post_page-----637246fa1342--------------------------------" rel="noopener" target="_blank"> Alexey Naumov </a>撰写的<a class="ae ky" href="https://medium.com/swlh/clean-architecture-for-swiftui-6d6c4eb1cf6a" rel="noopener">的伟大文章</a>。</p><p id="25c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这个教程对你有用。感谢阅读！</p></div></div>    
</body>
</html>