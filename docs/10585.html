<html>
<head>
<title>What Is Autorelease Pool in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的自动释放池是什么</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-autorelease-pool-in-swift-c652784f329e?source=collection_archive---------2-----------------------#2022-01-17">https://betterprogramming.pub/what-is-autorelease-pool-in-swift-c652784f329e?source=collection_archive---------2-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8e67" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及如何优化循环中的内存使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f82fd3c4d6b3a1b82d4d5e71dd9da1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3piP5lkutgMItJEE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">托马斯·巴吉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="a2b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解Swift中的<code class="fe lv lw lx ly b">autoreleasepool</code>，以及它如何帮助我们优化循环中的内存使用。您将在本教程的末尾找到该项目的源代码。这是你将学到的东西:</p><ul class=""><li id="2a3a" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">什么是自动释放池</li><li id="da73" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">它是如何在引擎盖下工作的</li><li id="97fa" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">何时以及如何在Swift代码库中使用它</li><li id="6e4f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">如何在Objective-C中使用它(了解这个问题很有用，因为这个问题有时会在技术面试中被问到)</li></ul><p id="60f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p><h1 id="be39" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">我们开始吧</h1><p id="4b1a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在我们定义自动释放池之前，我们需要知道引用计数是如何工作的。当创建一个引用时，执行<code class="fe lv lw lx ly b">retain</code>命令，使对象保持活动状态。为了减少引用计数，并且当计数等于0时，潜在地从内存中删除对象，运行<code class="fe lv lw lx ly b">release</code>命令。自动引用计数(ARC)为我们解决了这个问题。</p><p id="0b30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">NSAutoreleasePool</code>是当池被清空时发送给<code class="fe lv lw lx ly b">release</code>命令的对象的存储器。该池保留那些对象，直到调用<code class="fe lv lw lx ly b">drain</code>方法，这发生在我们从创建该池的上下文返回时。例如，当我们在一个<code class="fe lv lw lx ly b">for in</code>循环中有一个自动释放池时，这个池将在每次迭代后被清空。</p><p id="bebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经知道了<code class="fe lv lw lx ly b">NSAutoreleasePool</code>的基础知识，让我们在一个示例项目中使用它。</p><h1 id="3cab" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用自动释放池</h1><p id="6dfe" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们有一个简单的应用程序，在屏幕中央显示一个<code class="fe lv lw lx ly b">UIImageView</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/586b3faf7b583e4b25442690a19841d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lQVfkDj5Re2kHUjK_vLQ6A.png"/></div></div></figure><p id="9106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的任务是加载500张图片，并在图片加载后在<code class="fe lv lw lx ly b">UIImageView</code>中显示每张图片。所以我们在<code class="fe lv lw lx ly b">ViewController</code>里面写了下面的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><ol class=""><li id="1a12" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nn mf mg mh bi translated">我们创建一个<a class="ae ky" href="https://developer.apple.com/documentation/dispatch/dispatchqueue" rel="noopener ugc nofollow" target="_blank">串行DispatchQueue </a>,用于图像加载任务。</li><li id="7721" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">我们在<code class="fe lv lw lx ly b">viewDidLoad()</code>内部调用<code class="fe lv lw lx ly b">loadImages()</code>方法。</li><li id="95be" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">获取每次调用检索随机图像数据的url。</li><li id="24e6" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">运行图像加载任务500次</li><li id="ec3a" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nn mf mg mh bi translated">图像检索后，在<code class="fe lv lw lx ly b">UIImageView</code>中显示。</li></ol><p id="036e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前看来还不错，图像如预期所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/cf43f28fb41aeca613ae1797dfd36958.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/1*DwtvceY9coVX6UWwU9EX1g.gif"/></div></figure><p id="4256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，让我们观察它如何随着时间的推移影响记忆:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/10495afd48f1dad602b54689d64db05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZ9TW0sCsxGyMNhTG4cIeA.png"/></div></div></figure><p id="693c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上图我们可以看到，当我们的应用程序运行60秒时，我们使用了大约55 MB的内存。结果是，当循环运行时，每个图像都保存在内存中。我们可以通过在加载新图像后丢弃以前的图像来优化这个过程。这正是我们要通过使用<code class="fe lv lw lx ly b">autoreleasepool</code>来实现的。</p><p id="3bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们按如下方式更新代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们将图像加载任务包装在一个<code class="fe lv lw lx ly b">autoreleasepool</code>中。让我们再次检查内存占用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/e109c156fdc501c2824435972ec86c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*edvoOJwIzGeHj4ieVzJ9qg.png"/></div></div></figure><p id="4444" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们看到，在使用自动释放池后，我们减少了大约70%的内存使用。请注意，这种优化不仅适用于图像，我们还可以在从磁盘读取文件时利用自动释放池。</p></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="c546" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经看到了在Swift中使用自动释放池是多么有用。然而，由于Swift中的ARC，我们不再需要经常使用它。以前，在Objective-C中，自动释放池的使用会非常频繁，尤其是当我们想要返回一些以后会用到的对象时:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="97f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，分配给<code class="fe lv lw lx ly b">Obj</code>实例的内存在方法返回并且外部上下文结束使用后不会被释放，这导致了内存泄漏。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ca76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们在为<code class="fe lv lw lx ly b">Obj</code>实例分配内存之后添加了release命令。但是，现在对象将在方法返回之前被释放，如果处理不当，可能会导致崩溃。</p><p id="8b36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，我们希望在外部上下文保存对对象的引用时保持对象的活动状态，并在对象不再被使用时销毁它。这就是自动释放技巧的用处:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="e779" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">资源</h1><p id="226e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">源代码可以在<a class="ae ky" href="https://github.com/zafarivaev/autoreleasepool-swift" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。要了解有关自动释放池的更多信息，请访问官方文档。感谢阅读！</p></div></div>    
</body>
</html>