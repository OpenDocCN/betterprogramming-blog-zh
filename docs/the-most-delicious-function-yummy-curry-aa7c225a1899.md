# 最美味的功能——美味的咖喱

> 原文：<https://betterprogramming.pub/the-most-delicious-function-yummy-curry-aa7c225a1899>

## 如何将一个获得多个参数的函数变成一次只获得一个参数的函数

![](img/29c0e7cfe1f411242d46f01b003a7037.png)

照片由 [Jason Leung](https://unsplash.com/@ninjason?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

如果你是一个辛辣的食物和函数式编程的爱好者，你会很高兴。

在本文中，我将解释什么是`curry`函数，如何构建它，以及使用它的好处。

# 简短的历史课

“Currying”是一种数学和计算机科学技术。

“currying”这个名字是在 1967 年哈斯克尔·库里(Haskell Curry)之后创造的。库里是美国数学家和逻辑学家。

他的名字可能听起来很熟悉。Haskell 编程语言也是以他的名字命名的。Haskell 的创建者希望它被命名为“Curry”，但这个名字已经被取了。

# 什么是 Currying？

在我们继续实现`Curry`函数或者解释为什么我们应该使用它之前，我们需要理解它背后的数学技术。

使用这种技术，我们可以得到一个有多个参数的函数

一次获取一个参数的函数。

我们首先通过 100 米的尤塞恩博尔特记录，然后我们得到一个函数返回。

向该函数传递我跑 100 米的结果(我差一点就跑完了)，它将运行下划线函数，并向我们返回 false。

# 有什么好处？

Currying 主要用于从一般的函数中生成更具体的函数。

让我们举一个咖啡机的例子。我们将从一个制作咖啡的通用函数(作者没有制作好咖啡)开始，并开始创建更具体的函数。

下面是我们的`makeCoffee`函数的样子:

做一杯美味的美式咖啡简单又容易，但是周六就要到了，我们要举办一场卡布奇诺派对。我们不想每次都用‘卡布奇诺’来调用`makeCoffee`函数。

我们很幸运，因为`makeCoffee`是咖喱，我们可以创造我们的新品牌`makeCappuccino`功能:

现在，我们可以轻松地为所有快乐的客人提供卡布奇诺。

我们的咖啡师朋友过来告诉我们，完美的卡布奇诺配有 3.5 盎司的牛奶。因为我们渴望完美，我们创造了我们的`makePerfectCappuchino`功能:

我们利用了 curried 函数返回 curried 函数本身的事实，从`makeCappuccino`创建了一个更具体的函数。

现在，我们可以为我们所有的客人提供一杯完美的卡布奇诺。

这是一个简单的例子，但是这个工具可以在很多情况下提供帮助，并帮助减少我们编写的新函数的数量。

# 手工染色

在我们开始用更花哨的方法涂抹之前，让我们先用手动涂抹来弄脏我们的手。

我们将使用常规函数语法和 ES6 arrow 函数语法分别编写我们的`isNewOlympicRecord`函数。

我们的目标是能够以这种方式调用我们的函数:

要用手工编写`isNewOlympicRecord`,我们有三个要求:

1.  每次我们收到一个参数，我们需要返回一个新的函数。
2.  这个函数需要“记住”我们已经传递给它的参数。
3.  当我们得到最后一个参数时，我们需要计算结果并返回它。

幸运的是，JS 的闭包可以帮助我们轻松实现第二个需求。闭包为我们提供了一种创建可以访问外部函数范围的内部函数的方法。

我们可以像母亲和婴儿一样思考这个问题。婴儿可以利用他母亲的资源。看起来是这样的:

在我们的例子中，`babyFunc`可以访问`motherFunc`的范围，这意味着他可以访问以下内容:

1.  论据:`arg1`，`arg2`
2.  变量:`var1`，`var2`
3.  功能:`func1`，`func2`

现在我们可以返回一个“记住”外部作用域函数的参数的函数。

剩下的就是当我们得到最后一个参数时计算结果，并在我们收到的每个参数上返回一个新函数。

结合起来，我们得到以下结果:

我们还可以使用 arrow 函数语法编写一个不太冗长的版本。看起来是这样的:

这两个版本是等效的。

就是这样！我们已经建立了我们的手动`curry`功能。

# 为 N 个参数构建我们自己的定制函数

编写我们自己的手动 curry 函数可能相当麻烦，如果我们得到了一个函数作为参数，并希望使它成为 curry 函数，该怎么办？

对于这些情况和其他情况，我们将编写自己的`curry`函数。我们的函数将得到世界上任何一个函数，并返回给我们一个新的漂亮的 curried 函数。

我们需要考虑的第一件事是我们的停止条件，也就是什么时候停止返回一个函数，并运行带有所有参数的原始函数。

当我们的`curry`函数得到的参数数量与原始函数应该得到的数量相同时，我们需要这样做。

换句话说，当我们收到原始函数**的 arity 数量的参数时，我们应该运行原始函数。Arity 就是函数接受的参数的数量。**

我们的第一个版本`curry`将得到以下两个参数:

1.  `arity`:号。
2.  `f`:功能。

返回值将是如下所示的函数:

在函数体内我们会发现什么？

我们知道，我们应该不断返回一个函数，直到我们得到`arity`数量的参数，我们需要一种方法来记住我们已经得到的参数(范围到救援！)

所以，我们会有这样的东西:

如果我们没有达到停止条件，我们需要做什么？

只需返回我们的`curried`函数！这是我们的第一个版本。

# 第二个版本:自动 Arity，纯

对于我们当前版本的`curryN`，我们有两个问题:

1.  它不纯洁！我们正在改变`args`数组，所以我们应该使代码不可变。
2.  我们每次调用`curryN`都要指定函数的 arity 是什么。相反，我们可以推导出 arity。

为了解决我们的第一个问题，我们需要停止变异`args`数组。

一种方法是获取数组作为输入，并返回一个新数组作为输出。

由于我们并不真的想从用户那里获得输入，我们将创建另一个嵌套函数，它将被立即调用以给出第一个输入——一个空的`args`数组。

我们得到这样的结果:

我们得到了不可变的`curry`函数，所有神奇的事情都是使用`nextCurried`作为 IIFE(立即调用的函数表达式)发生的，它得到一个空数组作为第一个参数。

随着我们从用户那里获得更多的参数，我们继续用一个新的参数数组调用`nextCurried`。

我们要做的最后一件事是推导 arity，因为我们不希望我们函数的用户在每次调用我们的`curryN`函数时都要声明 arity。

我们如何做到这一点？

幸运的是，JavaScript 中的函数是对象，`Function`对象具有属性 length。

`Function.length`给我们确切需要的，用户输入函数所期望的参数个数。我们可以重命名我们的函数`curry`并使用`Function.length`。看起来是这样的:

**重要提示:** `Function.length`不考虑“静止参数”。对于更复杂的用例，当`Function.length`没有返回参数的真实数目时，用户将不得不自己陈述 arity。

我们还可以使用 ES6 arrow 函数语法创建我们的`curry`函数，如下所示:

较短但不清晰。在这个版本中，我们仍然以完全相同的方式调用函数。函数参数`nextCurried`只是为我们返回的函数起一个名字。

# 使用 Curry 的第三方库

尽管我们自己编写`curry`函数很有趣，但是已经有一些很好的经过测试的实现，包括如下:

## Ramda.js

 [## 拉姆达文件

### 接受一个收敛函数和一个分支函数列表，并返回一个新函数。新的……

ramdajs.com](https://ramdajs.com/docs/#curry) 

这个使用方法和我们的`curry`一样，如果要指定 arity，可以使用 Ramda.js 的`CurryN`。

## **lodash**

 [## Lodash 文档

### 编辑描述

lodash.com](https://lodash.com/docs/4.17.15#curry) 

这与我们的`curry`函数使用相同的 API。它也可以指定 arity，还有一个很好的函数`curryRight`，它以相反的顺序接收参数。

 [## Lodash 文档

### 编辑描述

lodash.com](https://lodash.com/docs/4.17.15#curryRight) 

# 下一步是什么？

如果你喜欢这篇短文，我相信你会喜欢凯尔·辛普森的 JS 功能课程:

[](https://github.com/getify/Functional-Light-JS) [## GitHub-getify/Functional-Light-JS:JavaScript 中务实、平衡的 FP。推特上的@FLJSBook。

### 这本书是对 JavaScript 中 FP 的一个平衡的、实用的审视。第一版现已完成。在线阅读此处了解…

github.com](https://github.com/getify/Functional-Light-JS) 

我建议复习更多类似以下的概念:

*   部分应用
*   排版和管道功能

坚持学习！