<html>
<head>
<title>How to Achieve Dynamic SQL Query With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Go实现动态SQL查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-sql-query-with-go-8aeedaa02907?source=collection_archive---------7-----------------------#2022-05-16">https://betterprogramming.pub/dynamic-sql-query-with-go-8aeedaa02907?source=collection_archive---------7-----------------------#2022-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f82e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从使用<a class="ae kf" href="https://pkg.go.dev/database/sql#Rows.Columns" rel="noopener ugc nofollow" target="_blank">行开始。列</a>或<a class="ae kf" href="https://pkg.go.dev/database/sql#Rows.ColumnTypes" rel="noopener ugc nofollow" target="_blank">行。ColumnTypes </a>获取列信息</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/bafe6606e2d291a692e795037e950ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LymQJ8BtzG-jbtP6"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sunder_2k25?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sunder Muthukumaran </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a02d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于大多数应用程序，我们将知道我们需要数据库中的什么数据，然后我们可以定义适当的数据类型来获取查询结果。</p><p id="73db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但有时我们可能需要灵活性，在运行时使用动态SQL或未知列查询来生成一些数据。例如，假设我们正在构建一个报告、管理或GUI工具。</p><p id="2c8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将在一个简单的报告示例中讨论如何使用Go标准库(<a class="ae kf" href="https://pkg.go.dev/database/sql" rel="noopener ugc nofollow" target="_blank">数据库/sql </a>)来实现这一点。</p><p id="3138" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完整的代码示例可以在<a class="ae kf" href="https://github.com/wolftsao/go_dynamic_sql_example" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><p id="7e33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将跳过明显的Go代码，直接跳到重要的部分。此外，为了使代码清晰易读，我将忽略错误处理。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b920" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">获取列长度和列名</h1><p id="f4a9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">首先，我们需要获得像列名这样的列信息。</p><p id="1872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本例中，我使用了<a class="ae kf" href="https://www.cockroachlabs.com/" rel="noopener ugc nofollow" target="_blank">cocroach db</a>和下面定义的<code class="fe mw mx my mz b">users</code>表:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="7ce7" class="ne ma iq mz b gy nf ng l nh ni">   column_name  |  data_type  |<br/>----------------+-------------+<br/>  id            | UUID        |<br/>  name          | STRING      |<br/>  age           | INT8        |<br/>  married       | BOOL        |<br/>  location      | JSONB       |<br/>  phone_numbers | STRING[]    |<br/>  creation_time | TIMESTAMPTZ |</span></pre><p id="48e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们运行一个全表查询:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="5185" class="ne ma iq mz b gy nf ng l nh ni">rows, _ := db.Query("select * from users")<br/>defer rows.Close()</span><span id="e6c6" class="ne ma iq mz b gy nj ng l nh ni">cols, _ := rows.Columns()</span></pre><p id="32ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变量<code class="fe mw mx my mz b">cols</code>是列名(字符串的一部分)。假设我们只是将结果打印到<code class="fe mw mx my mz b">stdout</code>，我们可以轻松地使用<code class="fe mw mx my mz b"><a class="ae kf" href="https://pkg.go.dev/text/tabwriter" rel="noopener ugc nofollow" target="_blank">text/tabwriter</a></code>:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="47ec" class="ne ma iq mz b gy nf ng l nh ni">w := tabwriter.NewWriter(os.Stdout, 0, 2, 1, ' ', 0)<br/>defer w.Flush()</span><span id="2e92" class="ne ma iq mz b gy nj ng l nh ni">sep := []byte("\t")<br/>newLine := []byte("\n")</span><span id="096a" class="ne ma iq mz b gy nj ng l nh ni">w.Write([]byte(strings.Join(cols, "\t") + "\n"))</span></pre><p id="cc21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">报告的标题部分已经完成，让我们来处理结果数据。</p><h1 id="2766" class="lz ma iq bd mb mc nk me mf mg nl mi mj jw nm jx ml jz nn ka mn kc no kd mp mq bi translated">处理未知的行数据</h1><p id="f637" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">对于动态或特别查询，由于我们不知道列类型，所以很难预先确定我们需要使用的变量类型(我们可以将<code class="fe mw mx my mz b">switch</code>语句与<code class="fe mw mx my mz b"><a class="ae kf" href="https://pkg.go.dev/database/sql#Rows.ColumnTypes" rel="noopener ugc nofollow" target="_blank">ColumnTypes</a></code>配对来实现这一点，对于像格式化或进一步处理这样的高级用法，我们应该这样做)。但是那将是非常乏味的)。</p><p id="03bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，数据库列可以是<code class="fe mw mx my mz b">NULLABLE</code>。在Go中，我们需要用像<code class="fe mw mx my mz b">NullString</code>这样的特殊数据类型来处理这个问题。</p><p id="ec5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于简单报告的目的，我们需要一个通用数据类型来容纳数据库查询的结果。</p><p id="65f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，字节片<code class="fe mw mx my mz b">[]byte</code>很好地解决了这个问题，包括JSON/array数据。此外，字节片在默认情况下将数据库NULL视为空，这减轻了我们额外处理。</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="1afc" class="ne ma iq mz b gy nf ng l nh ni">row := make([][]byte, len(cols))</span></pre><p id="cd0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于行可能包含多列，我们需要一个字节片。</p><p id="2ad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，Go中有一个棘手的部分，即<a class="ae kf" href="https://pkg.go.dev/database/sql#Rows.Scan" rel="noopener ugc nofollow" target="_blank">行。Scan </a>是一个变量函数，参数类型为<code class="fe mw mx my mz b">any</code>，底层具体类型应该是指针。如果我们将每个参数指定为:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="9cf0" class="ne ma iq mz b gy nf ng l nh ni">var id int<br/>var name string<br/>err := rows.Scan(&amp;id, &amp;name)</span></pre><p id="c45d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们可能认为可以将行改为<code class="fe mw mx my mz b">[]*[]byte</code>，然后在扫描调用中解包它:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="3701" class="ne ma iq mz b gy nf ng l nh ni">row := make([]*[]byte, len(cols))<br/>err := rows.Scan(row...)</span></pre><p id="907d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，我们将得到编译时错误消息:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="8710" class="ne ma iq mz b gy nf ng l nh ni">cannot use row (variable of type []*[]byte) as []any value in argument to rows.Scan</span></pre><p id="8164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们必须遵循编译器告诉我们的。我们需要一个<code class="fe mw mx my mz b">[]any</code>类型的变量，那么每个元素将是一个指向<code class="fe mw mx my mz b">row</code>变量的每个元素的指针:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="b2b2" class="ne ma iq mz b gy nf ng l nh ni">rowPtr := make([]any, len(cols))<br/>for i := range row {<br/>  rowPtr[i] = &amp;row[i]<br/>}</span></pre><p id="0a6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这已经很多了，现在我们可以打印结果了。</p><h1 id="83a9" class="lz ma iq bd mb mc nk me mf mg nl mi mj jw nm jx ml jz nn ka mn kc no kd mp mq bi translated">打印查询结果</h1><p id="9f16" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这一部分应该很简单，只需循环通过<code class="fe mw mx my mz b">rows</code>，扫描并写入标准输出:</p><pre class="kh ki kj kk gt na mz nb nc aw nd bi"><span id="9599" class="ne ma iq mz b gy nf ng l nh ni">for rows.Next() {<br/>  _ := rows.Scan(rowPtr...)</span><span id="caab" class="ne ma iq mz b gy nj ng l nh ni">  w.Write(bytes.Join(row, sep))<br/>  w.Write(newLine)<br/>}</span></pre><p id="2823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以执行程序了，结果会是这样的:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi np"><img src="../Images/64461017ad36d7cd689f68fed255cb5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6-63rPl-ul0mpcmK1WqMA.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">动态查询结果示例</p></figure><p id="d644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是完整的最小可运行代码片段:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b2f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(确保有数据库和表格可用于运行程序，或查看<a class="ae kf" href="https://github.com/wolftsao/go_dynamic_sql_example" rel="noopener ugc nofollow" target="_blank">此</a>以获取完整示例)</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="008b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摘要</h1><p id="4c8e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了在Go中实现动态SQL查询，我们:</p><ol class=""><li id="7405" class="ns nt iq ky b kz la lc ld lf nu lj nv ln nw lr nx ny nz oa bi translated">已用<a class="ae kf" href="https://pkg.go.dev/database/sql#Rows.Columns" rel="noopener ugc nofollow" target="_blank">行。列</a>或<a class="ae kf" href="https://pkg.go.dev/database/sql#Rows.ColumnTypes" rel="noopener ugc nofollow" target="_blank">行。ColumnTypes </a>获取列信息</li><li id="b53d" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">使用更通用的数据类型(在本例中是字节片)来存储查询结果，使用中间类型(<code class="fe mw mx my mz b">[]any</code>)来匹配行。扫描呼叫</li><li id="9907" class="ns nt iq ky b kz ob lc oc lf od lj oe ln of lr nx ny nz oa bi translated">像往常一样循环遍历这些行</li></ol><p id="50c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常感谢你的阅读！</p></div></div>    
</body>
</html>