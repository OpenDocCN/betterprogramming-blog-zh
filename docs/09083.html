<html>
<head>
<title>5 Code Smells React Beginners Should Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者应避免的5种代码气味反应</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-code-smells-react-beginners-should-avoid-480c97799162?source=collection_archive---------0-----------------------#2021-07-14">https://betterprogramming.pub/5-code-smells-react-beginners-should-avoid-480c97799162?source=collection_archive---------0-----------------------#2021-07-14</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="8b85" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated"><em class="kj">在提交</em>之前，请务必仔细检查您对这些东西的拉动请求</h2></div><figure class="kl km kn ko gu kp gi gj paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gi gj kk"><img src="../Images/7359303c4b8d9aedbd0cd0e1616c1335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_kJTb0LR-NIjEORl"/></div></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">Priscilla Du Preez 在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="ed05" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">作为来自各种不同背景(包括训练营和其他非传统教育途径)的前端初学者的导师，我观察到了许多不同的React编码方法。React的部分魅力在于，相对于Angular和Vue这样的框架，它通常是相当独立的。这使得它足够灵活，可以插入许多用不同框架编写的现有代码库。此外，它激发了大量不同用例的社区库，从而推动了整个行业的发展。</p><p id="3e99" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然而，与传统无关的、重配置的生态系统的缺点是，它给初学者留下了很多偏离最佳实践的空间。下面是五个经常被违反的最佳实践——或者说代码味道——这是我在审查React新开发人员的拉请求时经常发现的。</p><p id="3ba4" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">应该注意的是，在这个上下文中的“代码味道”只是我注意到的一种模式，它吸引我的注意力以进行进一步的检查。这并不意味着这些总是不适当的实现。好的软件工程没有绝对的规则。在特殊情况下，如果有适当的上下文，这些代码气味中的每一种都是有意义的。也就是说，如果你发现自己在使用这些模式，你应该停下来问问自己，“这真的有必要吗？”</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="bd4e" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><strong class="ak"> 1。可变变量</strong></h1><p id="dc44" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">在过去的五年里，我只需要使用一次可变变量——就像我说的，每个最佳实践都有例外。可变变量是在代码执行过程中可以重新赋值的变量。JavaScript中的这些变量是<code class="fe nb nc nd ne b">let</code>和<code class="fe nb nc nd ne b">var</code>。如果你正在使用ES6语法，你可能永远不会想使用<code class="fe nb nc nd ne b">var</code>，但是我仍然发现许多React初学者在使用<code class="fe nb nc nd ne b">let</code>。</p><p id="aa1a" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">当审查一个拉请求时，在React中看到任何不是<code class="fe nb nc nd ne b">const</code>变量的变量都告诉我，开发人员可能最熟悉过程化设计模式。<a class="ae la" href="https://blog.devgenius.io/replace-the-accumulator-pattern-665c9969d9f4" rel="noopener ugc nofollow" target="_blank">累加器模式</a>是一个利用可变变量的过程化设计模式的例子，我看到许多初学者都在使用。几乎所有使用可变变量的设计模式都可以用等价的函数式编程来代替。</p><div class="nf ng gq gs nh ni"><a href="https://blog.devgenius.io/replace-the-accumulator-pattern-665c9969d9f4" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fp"><div class="nk ab nl cl cj nm"><h2 class="bd iv gz z fq nn fs ft no fv fx it bi translated">更换累加器模式</h2><div class="np l"><h3 class="bd b gz z fq nn fs ft no fv fx dk translated">保持代码安全不变的函数式编程策略</h3></div><div class="nq l"><p class="bd b dl z fq nn fs ft no fv fx dk translated">blog.devgenius.io</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ku ni"/></div></div></a></div></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="e75c" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">2.程序模式</h1><p id="b3e8" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">如前所述，过程模式通常表示使用可变变量。每当我看到以下任何一个操作者，我都能嗅到一种正在形成的程序模式:</p><ul class=""><li id="977e" class="nx ny iu ld b le lf lh li lk nz lo oa ls ob lw oc od oe of bi translated"><code class="fe nb nc nd ne b">for</code>循环</li><li id="5fb0" class="nx ny iu ld b le og lh oh lk oi lo oj ls ok lw oc od oe of bi translated"><code class="fe nb nc nd ne b">while</code>循环</li><li id="61e6" class="nx ny iu ld b le og lh oh lk oi lo oj ls ok lw oc od oe of bi translated"><code class="fe nb nc nd ne b">forEach</code>作战</li><li id="06dc" class="nx ny iu ld b le og lh oh lk oi lo oj ls ok lw oc od oe of bi translated">一个<code class="fe nb nc nd ne b">push</code>对一个阵</li></ul><p id="c283" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">这些通常表示React组件内部的副作用，这在纯函数式编程中是不好的做法。React实际上旨在用于函数式和声明式范例。有关JavaScript函数式编程的更多信息，请参见下文:</p><div class="nf ng gq gs nh ni"><a rel="noopener  ugc nofollow" target="_blank" href="/functional-programming-in-javascript-introduction-and-practical-examples-d268e44395b2"><div class="nj ab fp"><div class="nk ab nl cl cj nm"><h2 class="bd iv gz z fq nn fs ft no fv fx it bi translated">JavaScript中的函数式编程:简介和实例</h2><div class="np l"><h3 class="bd b gz z fq nn fs ft no fv fx dk translated">从纯函数和组合子到组合和容器</h3></div><div class="nq l"><p class="bd b dl z fq nn fs ft no fv fx dk translated">better编程. pub</p></div></div><div class="nr l"><div class="ol l nt nu nv nr nw ku ni"/></div></div></a></div><p id="9366" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">作为这些代码味道的替代，您通常可以使用<code class="fe nb nc nd ne b">map</code>、<code class="fe nb nc nd ne b">reduce</code>、<code class="fe nb nc nd ne b">find</code>和<code class="fe nb nc nd ne b">filter</code>数组方法。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="214f" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated"><strong class="ak"> 3。字符串文字</strong></h1><p id="70a7" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">字符串文字是任何“匿名字符串”或代码中没有作为某种类型的变量或数据结构存储在内存中的任何字符串。字符串文字使得你的代码在重构时更加脆弱，并且不太支持国际化。许多初学者在早期的代码中使用字符串文字，因为他们还没有遇到最终会变得痛苦的情况。</p><p id="adac" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">请考虑下面的代码示例:</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="on oo l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">图1.1—React组件中使用的字符串文字，用于有条件地呈现文本样式。</p></figure><p id="0dd3" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">图1.1展示了一个React组件，它根据<code class="fe nb nc nd ne b">status</code>属性是否等于字符串文字<code class="fe nb nc nd ne b">'active'</code>来有条件地呈现<code class="fe nb nc nd ne b">Badge</code>组件的背景。因为<code class="fe nb nc nd ne b">status</code> prop也用于将文本呈现到屏幕上，所以假设用户需求在某个时候可能会发生变化，并且他们更愿意看到“就绪”而不是“活动”这个词，这并不令人费解在这种情况下，开发人员将不得不检查应用程序中任何类型的业务逻辑中使用字符串文字<code class="fe nb nc nd ne b">'active'</code>的地方。如果他们错过了这个特殊的三元表达式，那么单词“ready”<em class="om">将会</em>显示在屏幕上，但是它将会有一个红色的背景——这不是想要的用户体验。</p><p id="0113" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如果他们改而重构代码以使用内存中的单个引用点，如图1.2所示，他们已经成功地为将来最小化了他们的重构工作。如果用户回来后决定再次从“ready”更改为“complete”，那么开发人员就不必在代码中到处寻找对字符串“ready”的引用。相反，他们可以简单地改变他们的<code class="fe nb nc nd ne b">status.js</code>文件中的<code class="fe nb nc nd ne b">status</code>对象的<code class="fe nb nc nd ne b">active</code>属性的值，这样就可以了！</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="on oo l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">图1.2 —重构badge组件以消除字符串文字。</p></figure><p id="ab1f" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">最大限度地减少字符串文字的使用也使您的代码更适合翻译成其他语言，因为您可以调用语言文件来返回对适当字符串的引用。例如，如果<code class="fe nb nc nd ne b">Badge</code>组件将语言代码作为其<code class="fe nb nc nd ne b">props</code>之一，那么您可以重构组件中的标签，使其不再使用字符串文字。这在下面图1.3的<strong class="ld iv"> </strong>中的第9行进行了演示。现在，为了支持更多的语言，你所要做的就是更新你的<code class="fe nb nc nd ne b">labels</code>对象，你就可以立即在你的组件中呈现新的语言。</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="on oo l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">图1.3 —重构我们的代码以允许国际化。</p></figure></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="0210" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">4.直接DOM操作</h1><p id="7834" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">我经常看到React初学者试图在React功能组件的主体中使用普通的JavaScript来直接访问HTML DOM元素。很多时候，他们使用这种方法，因为这是他们学习JavaScript的方式，或者他们发现了一个与React无关的关于堆栈溢出的帖子，这给了他们当时需要的解决方案——从他们的角度来看，这就是工作！</p><pre class="kl km kn ko gu op ne oq or aw os bi"><span id="38a0" class="ot mf iu ne b gz ou ov l ow ox">document.getElementById('virtual-div')</span></pre><p id="445e" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">但是，因为React使用虚拟DOM，所以不能保证您试图访问的DOM元素在您查询它时会存在。它可能还没有挂载，也可能正在重新渲染。无论哪种方式，在组件生命周期的整个过程中，您对实际DOM元素所做的任何更改都将丢失。</p><p id="4b48" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">您不需要直接在DOM上操作，而是需要使用<code class="fe nb nc nd ne b">useRef</code>钩子来创建对您想要操作的DOM元素的引用，以便您可以在组件重新呈现的整个过程中继续访问它。React官方网站上的<code class="fe nb nc nd ne b">useRef</code> Hook文档是进一步理解这一点的很好的参考:</p><div class="nf ng gq gs nh ni"><a href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fp"><div class="nk ab nl cl cj nm"><h2 class="bd iv gz z fq nn fs ft no fv fx it bi translated">钩子API参考-反应</h2><div class="np l"><h3 class="bd b gz z fq nn fs ft no fv fx dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="nq l"><p class="bd b dl z fq nn fs ft no fv fx dk translated">reactjs.org</p></div></div><div class="nr l"><div class="oy l nt nu nv nr nw ku ni"/></div></div></a></div></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="2806" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">5.大型组件文件</h1><p id="cad1" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">这可能更像是一种架构的味道，而不是代码的味道，但无论如何还是值得一提。我见过许多全新的工程师，他们只独自编写代码，从不与其他工程师团队合作。在这种情况下，开发人员用一两个非常大的组件编写整个应用程序的情况并不少见。默认情况下，他们不需要将代码抽象和组合成更小、更易消化和更易维护的组件。毕竟，没有其他人需要阅读代码，对不对？</p><p id="31dd" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">这对新工程师来说是一个非常重要的教训:我们不为计算机写代码。我们为下一个到来的工程师写代码。</p><p id="fd3f" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">即使你是一个人的团队，下一个出现的工程师也是你未来的自己。有时候，在未来的几个月或几年，你会回过头来看你的代码，这些代码都聚集在一个组件中，你会想，“这又意味着什么？”</p><p id="cac2" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">有时候，这种建筑的味道并没有那么强烈。相反，我可能会看到一个开发人员写了一些他们不想创建新组件的代码——也许这只是觉得有点矫枉过正。但是，如果随着时间的推移，你在一个组件上添加了许多小的变化，最终你会得到一个大的组件。您甚至可能欺骗自己在另一个组件中编写一个组件，而自己却没有意识到这一点。</p><p id="c2ab" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">考虑图2.1:</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="on oo l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">图2.1 —一个可能比实际需要的要大的组件文件。</p></figure><p id="6f39" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我以前见过一模一样的场景。开发人员心里想，“我不想为一系列数据中的每一行重写所有这些代码行，所以我只是将其抽象成一个快速函数。”他们没有意识到的是，他们实际上已经创建了一个新的组件。他们为<code class="fe nb nc nd ne b">renderRow</code>函数创建的<code class="fe nb nc nd ne b">rowData</code>参数的操作与传统函数组件的<code class="fe nb nc nd ne b">props</code>参数非常相似。当这种情况发生时，我要求开发人员将代码放在自己的组件文件中，以便将来可以单独维护和迭代。</p><p id="8e1b" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我调查了我组织中的几位高级工程师，我们得出了以下经验法则。如果你的组件文件有100-200行代码，你就需要重构你的代码来抽象它，使它变得更小。如果你的代码超过200行，你可能需要想办法把你的文件变小。文件可能太大有两个主要原因:</p><ol class=""><li id="16cf" class="nx ny iu ld b le lf lh li lk nz lo oa ls ob lw oz od oe of bi translated">你在一个组件中放了太多的UI元素。在这种情况下，您可以简单地将一些UI抽象成更小的组件，然后在父组件中引用它们。</li><li id="13ab" class="nx ny iu ld b le og lh oh lk oi lo oj ls ok lw oz od oe of bi translated">您在组件中加入了大量的业务逻辑。一般来说，我尽量让我的工程师避免这种情况。写在功能组件主体中的业务逻辑往往更难测试。如果业务逻辑位于您的功能组件中，那么测试业务逻辑的唯一真正方法是将组件安装到您的测试文件中，并模拟用户交互，以查看您是否获得了想要的UI结果。或者，您可以将任何业务逻辑完全从组件中提取出来，并将它们放在实用程序文件中，或者作为状态管理逻辑的一部分(例如Redux)。我一般倾向于后一种解决方案。它允许编写简单的纯函数，可以很容易地用单元测试来测试。这里有另一条经验法则:尽可能减少表示层中的业务逻辑！</li></ol><p id="93c5" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如果我在React应用程序的表示层(组件)中看到大量业务逻辑，即使组件文件不超过200行代码，我也倾向于要求工程师重构他们的代码，并将业务逻辑移出组件。大多数时候，如果你用纯函数编码，这是相当容易的。然而，这只是一个经验法则。这并不总是可能的。</p></div><div class="ab cl lx ly hy lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="in io ip iq ir"><h1 id="3b5b" class="me mf iu bd mg mh mi mj mk ml mm mn mo ka mp kb mq kd mr ke ms kg mt kh mu mv bi translated">结论</h1><p id="f4e5" class="pw-post-body-paragraph lb lc iu ld b le mw jv lg lh mx jy lj lk my lm ln lo mz lq lr ls na lu lv lw in bi translated">还是那句话，这些“气味”没有一个是不好的。他们只是倾向于让我在审查拉请求时看两遍代码。如果我发现自己在使用它们，我一定会给我的评论者留下一条评论，证明为什么它是必要的。如果你有正当的理由使用它们，我很乐意在评论中听到(GitHub代码的链接会很棒)。</p><p id="fba8" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">编码快乐！</p><div class="nf ng gq gs nh ni"><a href="https://www.medium.com/@jasonleehodges" rel="noopener follow" target="_blank"><div class="nj ab fp"><div class="nk ab nl cl cj nm"><h2 class="bd iv gz z fq nn fs ft no fv fx it bi translated">杰森·李·霍奇斯-中等作家</h2><div class="np l"><h3 class="bd b gz z fq nn fs ft no fv fx dk translated">杰森·李·霍奇斯是一位资深软件工程经理，也是《从零开始的软件工程》一书的作者</h3></div><div class="nq l"><p class="bd b dl z fq nn fs ft no fv fx dk translated">www.medium.com</p></div></div><div class="nr l"><div class="pa l nt nu nv nr nw ku ni"/></div></div></a></div></div></div>    
</body>
</html>