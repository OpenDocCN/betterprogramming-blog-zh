<html>
<head>
<title>Why React’s useState Isn’t a Good Solution for Derived Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么React的使用状态不是派生值的好解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-reacts-usestate-isn-t-a-good-solution-for-derived-values-2a8e41b55fe6?source=collection_archive---------3-----------------------#2021-04-13">https://betterprogramming.pub/why-reacts-usestate-isn-t-a-good-solution-for-derived-values-2a8e41b55fe6?source=collection_archive---------3-----------------------#2021-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9cc3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">React中使用状态的常见误用及更好的解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc45a4268f667bf7862badcb74f8362b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a8P4j17Ou4PpDSjJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@flowforfrank" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae ky" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="156d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">状态是React中的基本概念之一。<code class="fe lv lw lx ly b">useState</code>钩子是功能性React组件中状态管理的基础。事实上，大多数初学者从学习状态管理和<code class="fe lv lw lx ly b">useState</code>钩子开始他们的React之旅。</p><p id="70fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在编写代码时，有些东西不幸地被用在了有更好替代方案的地方。这些通常会导致代码变得比实际需要的更复杂。在这里，我们将看看一个常见的滥用<code class="fe lv lw lx ly b">useState</code>钩和一个更好的解决问题的方法。这种特殊的误用是我见过很多开发人员做的，也是我很长一段时间以来一直做的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5f4e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用案例</h1><p id="151f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了研究如何更好地使用和管理状态，我们将实现一个用例。我们将创建一个名为<code class="fe lv lw lx ly b">ColorList</code>的React组件。</p><ul class=""><li id="b9ef" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">组件以<code class="fe lv lw lx ly b">startHex</code>、<code class="fe lv lw lx ly b">endHex</code>、<code class="fe lv lw lx ly b">selectedHexes</code>、<code class="fe lv lw lx ly b">onColorClicked</code>为道具。</li><li id="b404" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">该组件显示位于<code class="fe lv lw lx ly b">startHex</code>和<code class="fe lv lw lx ly b">endHex</code>之间的所有颜色。如果这些属性中的任何一个发生变化，颜色列表也必须发生变化。</li><li id="0462" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">用户可以从列表中选择多种颜色。通过<code class="fe lv lw lx ly b">selectedHexes</code>列表的颜色显示为选中。</li></ul><p id="4530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:如果<code class="fe lv lw lx ly b">startHex</code>为<code class="fe lv lw lx ly b">#FF0000</code>且<code class="fe lv lw lx ly b">endHex</code>为<code class="fe lv lw lx ly b">#FF0002</code>，则组件将显示颜色<code class="fe lv lw lx ly b">#FF0000</code>、<code class="fe lv lw lx ly b">#FF0001</code>和<code class="fe lv lw lx ly b">#FF0002</code>。</p><p id="7544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不会在这里实现算法，而只是看看与状态管理相关的东西。因此，我们将省略实际生成十六进制值的实现细节。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="bbcf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">解决方案</h1><p id="ba1d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可能会想出这样一个简单的解决方案:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="b94e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这显然完成了任务。但是，这个组件有一个问题。该组件将在每次重新渲染时重新计算<code class="fe lv lw lx ly b">allHexes</code>。每当父元素改变<code class="fe lv lw lx ly b">selectedHexes</code>数组的值时，就会发生这些不必要的重新计算。每次单击一种颜色时，很可能会发生这种情况。</p><p id="8938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于较小的组件来说，这不是一个大问题，但可能会降低这个特定组件的速度，比如说，当父组件想要生成所有颜色时，即<code class="fe lv lw lx ly b">startHex</code>是<code class="fe lv lw lx ly b">#000000</code>而<code class="fe lv lw lx ly b">endHex</code>是<code class="fe lv lw lx ly b">#FFFFFF</code>。这相当于16，777，216种颜色！所以我们可能要对此进行一点优化。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8147" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">复杂的方式</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="dcef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在已经停止在每次重新渲染时计算<code class="fe lv lw lx ly b">allHexes</code>。相反，我们将<code class="fe lv lw lx ly b">allHexes</code>置于一种状态。我们延迟计算初始状态，这样就不会在每次重新渲染时重新计算。然后每当<code class="fe lv lw lx ly b">startHex</code>或<code class="fe lv lw lx ly b">endHex</code>改变时，我们运行一个重新计算<code class="fe lv lw lx ly b">allHexes</code>的效果。</p><p id="a7d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="nt">奖金提示:</em> </strong> <em class="nt">你可以将一个函数作为初始值传递给</em> <code class="fe lv lw lx ly b"><em class="nt">useState</em></code> <em class="nt">。钩子将运行这个函数来初始化状态。在随后的重新渲染中，它将不会运行该函数。如果您发现自己在调用一个函数来计算初始状态，这是一个很好的选择。</em></p><p id="930a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，你不必事事都使用惰性初始化。仅将它用于昂贵的计算。在其他情况下，这是不值得的，甚至可能会降低组件的速度。</p><p id="e495" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案的问题是，为了计算同一个变量的值，在两个不同的地方使用相同的参数调用了<code class="fe lv lw lx ly b">calcColorsBetween</code>。</p><p id="4579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，如果我们需要将<code class="fe lv lw lx ly b">calcColorsBetween</code>更改为其他函数，我们需要在两个地方进行更改。这里的代码比需要的要多。此外，阅读和维护这些代码比它需要的更困难。但只是两个地方，对吗？</p><p id="4c1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不尽然！对于其他用例，可能是三个、四个甚至更多的地方。这是因为当<code class="fe lv lw lx ly b">startHex</code>或<code class="fe lv lw lx ly b">endHex</code>改变时<code class="fe lv lw lx ly b">allHexes</code>必须更新。</p><p id="db47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要是有办法让这变得更容易就好了。嗯，有，而且完全不需要用<code class="fe lv lw lx ly b">useState</code>！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0700" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">更好的方法</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="f640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经删除了作为状态的<code class="fe lv lw lx ly b">allHexes</code>。这是有道理的，因为当你仔细想想，<code class="fe lv lw lx ly b">allHexes</code>更适合术语<em class="nt">派生值</em>而不是术语<em class="nt">状态</em>。这与我们最初的尝试相同，但增加了<code class="fe lv lw lx ly b">useMemo</code>挂钩。</p><p id="8b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">useState</code>存储派生值需要在多个地方编写相同的代码。这可能会使阅读和维护代码变得更加困难。这是因为为了保持状态同步，由<code class="fe lv lw lx ly b">useState</code>钩子返回的setter必须在每个依赖关系改变的地方被调用。</p><p id="3001" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，当计算派生值很昂贵时，我们可以使用<code class="fe lv lw lx ly b">useMemo</code>钩子。这个钩子接受一个返回值的函数。只有当派生值的任何依赖关系发生变化时，才会重新计算该值。这些依赖关系在第二个参数中列出，类似于<code class="fe lv lw lx ly b">useEffect</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ddc6" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="fabe" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果某个值可以使用已经可用的其他值来计算，那么将其存储为一个状态没有太大的好处。相反，它使代码更难维护。因此，最好是即时计算。如果性能是一个问题，那么可以使用<code class="fe lv lw lx ly b">useMemo</code>。</p></div></div>    
</body>
</html>