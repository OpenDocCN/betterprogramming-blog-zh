<html>
<head>
<title>Never Null-Check Again</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不再进行空值检查</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/never-null-check-again-7db8d13cd454?source=collection_archive---------3-----------------------#2020-01-14">https://betterprogramming.pub/never-null-check-again-7db8d13cd454?source=collection_archive---------3-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2d3b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始在像Java这样的语言中使用可选类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/559869f92cb43760957f542db9192291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qR2UhuuQbDcmrq2H"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">萨法尔·萨法罗夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="06cf" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">问题是</h1><p id="22cc" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在允许变量中有<code class="fe mu mv mw mx b">null</code>值的语言中，开发人员必须显式地进行空值检查，以防止他们的程序出现运行时错误。</p><p id="b032" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">虽然空值检查很重要，但它可能会成为一个非常乏味的过程，并且经常会损害可读性。它通常需要大量嵌套的代码，并且妨碍了业务逻辑。</p><p id="070e" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">典型的空值检查代码可能类似于下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="71f7" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">在这个简单的例子中，我们看到一个处理来自<code class="fe mu mv mw mx b">Person</code>对象的<code class="fe mu mv mw mx b">name</code>字段的基本方法变成了一个复杂的嵌套代码块，需要几个阶段的空值检查。</p><p id="47cc" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">代码片段的业务逻辑只是处理人名，隐藏在空检查层中，开发人员必须进行空检查才能创建有弹性的程序。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5f3d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">更好的方法—可选类型</h1><p id="8889" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们可以利用<code class="fe mu mv mw mx b">Optional</code>类型，而不是每次处理一个新值时都必须进行冗长的空检查。</p><p id="1e80" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">Optional&lt;T&gt;</code>基本上可以被认为是一个潜在地保存类型为<code class="fe mu mv mw mx b">T</code>的值的容器。所以，<code class="fe mu mv mw mx b">Optional&lt;T&gt;</code>要么持有<code class="fe mu mv mw mx b">T</code>要么持有<code class="fe mu mv mw mx b">null</code>。</p><p id="6713" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated"><code class="fe mu mv mw mx b">Optional</code>类提供了几个方法，使得处理潜在的空值更加显式和可读。这些方法的一些例子包括:</p><ul class=""><li id="427f" class="nf ng it ma b mb my me mz mh nh ml ni mp nj mt nk nl nm nn bi translated">通过静态的<code class="fe mu mv mw mx b">Optional.ofNullable(T value)</code>方法创建一个<code class="fe mu mv mw mx b">Optional</code>对象。</li><li id="45e8" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">通过<code class="fe mu mv mw mx b">optional.isPresent()</code>方法检查<code class="fe mu mv mw mx b">Optional</code>是否为空值。</li><li id="c689" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">通过<code class="fe mu mv mw mx b">optional.orElse(T defaultValue)</code>方法，如果<code class="fe mu mv mw mx b">Optional</code>为空，则返回默认值。</li><li id="8b8e" class="nf ng it ma b mb no me np mh nq ml nr mp ns mt nk nl nm nn bi translated">通过<code class="fe mu mv mw mx b">.map()</code>和<code class="fe mu mv mw mx b">.flatMap()</code>方法提取并转换<code class="fe mu mv mw mx b">Optional</code>中的值。这两种方法都接受一个函数作为参数，该参数应用于<code class="fe mu mv mw mx b">Optional</code>对象的值。这两种方法的不同之处在于，<code class="fe mu mv mw mx b">map</code>旨在接受一个将值映射到值的函数，而<code class="fe mu mv mw mx b">flatMap</code>接受一个将值映射到<code class="fe mu mv mw mx b">Optional</code>的函数。这种区别很有用，因为如果您的映射函数已经返回了一个<code class="fe mu mv mw mx b">Optional</code>，那么<code class="fe mu mv mw mx b">map</code>方法将创建<code class="fe mu mv mw mx b">Optional&lt;Optional&lt;T&gt;&gt;</code>，而<code class="fe mu mv mw mx b">flatMap</code>将取消嵌套(展平它们)并生成<code class="fe mu mv mw mx b">Optional&lt;T&gt;</code>。</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f813" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">丰富</h1><p id="d6f7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，回到我们最初的代码片段，我们可以使用<code class="fe mu mv mw mx b">Optional</code>值来显著地清理它。</p><p id="d525" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">如果我们重写<code class="fe mu mv mw mx b">getPerson</code>和<code class="fe mu mv mw mx b">getName</code>方法来返回<code class="fe mu mv mw mx b">Optional</code>类型，新代码将如下所示，假设<code class="fe mu mv mw mx b">processName</code>返回一个<code class="fe mu mv mw mx b">String</code>:</p><pre class="kj kk kl km gt nt mx nu nv aw nw bi"><span id="bd23" class="nx lh it mx b gy ny nz l oa ob">return getPerson()                   // returns Optional&lt;Person&gt;<br/>    .flatMap(Person::getName)        // returns Optional&lt;String&gt;<br/>    .map(this::processName)          // returns Optional&lt;String&gt;<br/>    .orElse(DEFAULT_VALUE);          // returns String</span></pre><p id="39db" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">我们看到，我们已经大大减少了所需代码的长度，并且能够将其重写为一个方法调用链。方法链接是处理<code class="fe mu mv mw mx b">Optional</code>类型时遇到的典型模式，类似于Java的<code class="fe mu mv mw mx b">Stream</code>类经常被使用的方式。</p><p id="a2b4" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">通过使用<code class="fe mu mv mw mx b">Optional</code>类型，该方法的逻辑现在更纯粹地表示了它的业务逻辑，它只是简单地处理一个人的名字。</p><p id="dd10" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">既然我们不必让嵌套和空检查使我们的代码陷入困境，我们可以编写更清晰的代码，在意图和效果上更加明确。</p><p id="16d1" class="pw-post-body-paragraph ly lz it ma b mb my ju md me mz jx mg mh na mj mk ml nb mn mo mp nc mr ms mt im bi translated">此外，通过为方法使用<code class="fe mu mv mw mx b">Optional</code>返回值，我们现在可以明确地说方法可以返回<code class="fe mu mv mw mx b">null</code>，它使用语言的类型系统来迫使开发人员适当地处理潜在的空值。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="617d" class="nx lh it bd li oc od dn lm oe of dp lq mh og oh ls ml oi oj lu mp ok ol lw om bi translated">请在评论中告诉我你对可选类型的体验！</h2></div></div>    
</body>
</html>