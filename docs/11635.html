<html>
<head>
<title>How Suspense Works in React 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React 18中悬念的工作原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-suspense-works-in-react-18-c7617a50447f?source=collection_archive---------0-----------------------#2022-04-05">https://betterprogramming.pub/how-suspense-works-in-react-18-c7617a50447f?source=collection_archive---------0-----------------------#2022-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3fed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解新的并发暂记和过渡API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6cd669bb95691d2fa362abe7db782326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pVan148fQjyqdWN8CpJCzA.png"/></div></div></figure><p id="5886" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React <code class="fe lq lr ls lt b">Suspense</code>特性作为<code class="fe lq lr ls lt b">React 16</code>版本的一部分发布。在那里，它只有一个用例。它的本意是与它的<code class="fe lq lr ls lt b">React.lazy</code> API一起用于代码分割。当元素还没有被下载和呈现时，它将作为一个后备。但是它有一个主要的缺点。它不能在服务器端呈现引擎上使用。</p><p id="4eb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它还有其他警告，但这些都只是暂时的。众所周知<code class="fe lq lr ls lt b">Suspense</code>是React并发引擎模式的基石。它不仅仅意味着一个代码分割的专用API。</p><p id="9653" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">随着React 18的发布，<code class="fe lq lr ls lt b">Suspense</code>功能得到了进一步的开发和增强。它适合许多用例，现在它与<code class="fe lq lr ls lt b">SSR</code>兼容。尽管如此，它仍然不能用于数据获取。这项功能仍处于试验阶段，可能会在将来的版本中推出。</p><p id="19cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React团队提供了一个渐进的更新。只有通过使用新的<code class="fe lq lr ls lt b">ReactDOM.createRoot</code> API，我们才能释放并发性和所有新奇的<code class="fe lq lr ls lt b">Suspense</code>特性。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4a8a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">简要回顾</h1><p id="bb01" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">什么是<code class="fe lq lr ls lt b">Suspense</code>？它是一个低级引擎API，可用于暂停组件的执行。这是怎么做到的？简而言之，这一切都归结为一个组件抛出了一个被引擎拦截的承诺。它将推迟组件树的执行，直到承诺被解决或拒绝。</p><p id="6910" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lq lr ls lt b">&lt;Suspense /&gt;</code>需要一个强制的<code class="fe lq lr ls lt b">fallback</code>属性。这是我们指定占位符组件树加载行为的地方。如果有多个<code class="fe lq lr ls lt b">&lt;Suspense /&gt;</code>包装器会怎么样？它将从挂起的组件中获取最近的<code class="fe lq lr ls lt b">&lt;Suspense /&gt;</code>父组件。</p><p id="6178" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="e499" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，当获取<code class="fe lq lr ls lt b">&lt;Content /&gt;</code>时，它将显示<code class="fe lq lr ls lt b">&lt;Loader variant="indeterminate" &gt;</code>组件。当<code class="fe lq lr ls lt b">&lt;Header /&gt;</code>加载时，它将显示<code class="fe lq lr ls lt b">&lt;Loader /&gt;</code>组件。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e87e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">改进的行为</h1><p id="05d8" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在<code class="fe lq lr ls lt b">16</code>和<code class="fe lq lr ls lt b">17</code>中发现的悬念的稳定版本是并发思想的同步实现。它被称为<code class="fe lq lr ls lt b">Legacy Suspense</code>。</p><p id="f12c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">Legacy Suspense</code>中，组件树将从UI中隐藏。不会被该丢弃的丢弃。这可以通过向父DOM元素添加<code class="fe lq lr ls lt b">display: none</code>样式来实现。这种实现导致了生命周期事件触发的不一致性。这些在挂起的组件得到解决之前被激发。这导致了相当多的错误和不受欢迎的行为。</p><p id="aab2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">Concurrent Suspense</code>版本中，组件将在暂停时被丢弃。未完成的渲染树不会被提交。只有当组件准备好了，它才会被放入DOM。它的布局效果将被激活。因此，执行顺序更加直观。组件现在完全是异步的。</p><p id="90fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">遗留悬念</strong></p><ul class=""><li id="65ca" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">元素树会立即挂载到DOM中</li><li id="7462" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">效果/生命周期被激发</li><li id="c36c" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">当悬念被触发时，树在视觉上是隐藏的</li><li id="1bd6" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">只有在挂起的组件被解析后，它才可见</li></ul><p id="0924" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">并发暂停</strong></p><ul class=""><li id="2f79" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated">在挂起的组件得到解决之前，不会挂载元素</li><li id="38ba" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">效果/生命周期被激发</li></ul><p id="1bb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么React团队不直接实现<code class="fe lq lr ls lt b">Concurrent Supense</code>方法？这是因为遗留类组件的生命周期。对于<code class="fe lq lr ls lt b">Concurrent Suspense</code>引擎来说，没有合适的方法来处理像<code class="fe lq lr ls lt b">componentWillMount</code>这样的事件。这就是React团队在所有前缀前加上<code class="fe lq lr ls lt b">UNSAFE_</code>的原因。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4d51" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">带悬念的布局效果</h1><p id="3340" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们之前只是触及了表面。那些<code class="fe lq lr ls lt b">layout events</code>在<code class="fe lq lr ls lt b">Concurrent Suspense</code>中会如何执行？有些组件可以删除，以后再添加到DOM中。</p><p id="eaf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些现在将在<code class="fe lq lr ls lt b">hide</code>和<code class="fe lq lr ls lt b">show</code>事件上运行。当React需要隐藏挂起的节点时，它会运行清理功能。当需要显示悬浮的元素时，它会重新触发它们的布局效果。</p><p id="31d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与<code class="fe lq lr ls lt b">Legacy suspense</code>的情况相反，这些布局效果可能会运行多次。不再认为具有<code class="fe lq lr ls lt b">[]</code>依赖关系的布局效果只会运行一次。最好不要把它们看作生命周期事件，而是不同React特性的行为单元。</p><p id="30ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="3f48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可能会得到几个<code class="fe lq lr ls lt b">log on mount</code>和<code class="fe lq lr ls lt b">log on cleanup</code>日志语句。这取决于组件是否被挂起并多次重新添加。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="34e9" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">服务器端渲染</h1><p id="5462" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在<code class="fe lq lr ls lt b">SSR</code>中使用的时候<code class="fe lq lr ls lt b">Legacy Suspense</code>会抛出一个错误。很不方便。</p><p id="9154" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">添加了新的HTML并发服务器渲染。它输出的不是一个<code class="fe lq lr ls lt b">string</code>，而是一个<code class="fe lq lr ls lt b">stream</code>。</p><p id="78c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那个<code class="fe lq lr ls lt b">stream</code>可以用来提前推送最初的HTML。它将包括<code class="fe lq lr ls lt b">Suspense</code>后备占位符。当内容准备好时，它会发出一个带有<code class="fe lq lr ls lt b">script</code>标签的HTML片段，将组件插入正确的位置。React库将能够在流未完成时合成应用程序的一部分。</p><p id="8750" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当<code class="fe lq lr ls lt b">Concurrent Suspense</code>支持数据抓取时，这个流特性将会非常方便。</p><p id="1f9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看让这一切成为可能的API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="76cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看它在浏览器中的外观</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/855b4be54158b004c5583a13ccb09edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rF39PBOgSjgbZ4xs"/></div></div><p class="np nq gj gh gi nr ns bd b be z dk translated">来自React团队的带有悬念的SSR流HTML的表示在这里找到了<a class="ae nt" href="https://github.com/reactwg/react-18/discussions/37" rel="noopener ugc nofollow" target="_blank"/>。</p></figure><p id="91b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">绿色区域占位符是已经水合的元素。<code class="fe lq lr ls lt b">spinner</code>是一个在服务器上挂起的组件，但还没有流。</p><p id="4397" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更多信息，你可以在这里看到完整的细节<a class="ae nt" href="https://github.com/reactwg/react-18/discussions/37" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="6612" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">暂停列表API</h1><p id="e1e3" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">通过<code class="fe lq lr ls lt b">React 18</code>，我们得到了另一个悬念引擎特性:<code class="fe lq lr ls lt b">&lt;SuspenseList /&gt;</code>。我们可以使用这个组件包装多个<code class="fe lq lr ls lt b">&lt;Suspense /&gt;</code>实例。有了这个特性，我们可以协调和编排如何向用户展示这些内容。这有助于减轻网络的不可预测性。</p><p id="1ecf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这需要两个道具:</p><ul class=""><li id="4a3c" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated"><strong class="kw iu"> revealOrder </strong>:定义了它们应该显示的顺序。选项有<code class="fe lq lr ls lt b">forwards</code>、<code class="fe lq lr ls lt b">backwards</code>、<code class="fe lq lr ls lt b">together</code>。</li><li id="7cc4" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">尾巴:它让我们崩溃或隐藏所有的悬念。数值为<code class="fe lq lr ls lt b">collapse</code>或<code class="fe lq lr ls lt b">hidden</code>。默认情况下，它会显示所有的悬念回落。</li></ul><p id="cd94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看一个使用示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="0fbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，在上面的例子中，出现的顺序是<code class="fe lq lr ls lt b">forwards</code>。这将显示按顺序出现的组件。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="f1bc" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">过渡API</h1><p id="7c6f" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">React 18版本附带了一些新的API，可用于进一步微调<code class="fe lq lr ls lt b">Suspense</code>体验。</p><p id="dc95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可能希望在获取新组件时保留已加载的组件。当组件的下载/解析在后台发生时，用户将继续看到相关信息。为此，我们可以使用<code class="fe lq lr ls lt b">transition API</code>。</p><p id="d6ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来看一个具体的例子。假设我们有一组用户可以浏览的标签。切换选项卡时，显示旧的选项卡内容比显示新内容的<code class="fe lq lr ls lt b">Suspense</code>回退更相关。页面应该保持互动。如果用户点击另一个标签，引擎将放弃当前的暂停任务并加载新的任务。</p><p id="2eaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看代码的例子。我们来看看React 18之前的版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="223b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们使用新的<code class="fe lq lr ls lt b">transition API</code>。<code class="fe lq lr ls lt b">useTransition</code>钩子API提供了一个进度指示器<code class="fe lq lr ls lt b">[0]</code>和一个启动不太关键的转换<code class="fe lq lr ls lt b">[1]</code>的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="7cce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当处理异步发生时，页面将始终以交互方式开始。</p><p id="fe98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">重要的是向用户反馈正在发生的事情。通过使用<code class="fe lq lr ls lt b">isPending</code>布尔值，我们可以使内容变暗。动作<code class="fe lq lr ls lt b">pressing a tab</code>有直接反应:<code class="fe lq lr ls lt b">content is dimmed</code>。</p><p id="8563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是怎么回事？React引擎在等待新版本完成时，会保留UI的先前版本树。它就像React在另一个部门同时工作。这将是同一个JSX树的两个版本。</p><p id="69a4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这个转换API，我们现在可以更好地控制应用程序的行为。我们对它的执行有更多的控制权。这将归结为我们具体的UX情景。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7703" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">包裹</h1><p id="ff36" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">我们已经看到了所有来自<code class="fe lq lr ls lt b">Concurrent Suspense</code> API的很酷的特性。这是性能上的巨大进步。它还修复了一些与<code class="fe lq lr ls lt b">Legacy Suspense</code>实现相关的错误。仅仅是<code class="fe lq lr ls lt b">SSR</code>上的<code class="fe lq lr ls lt b">Suspense</code>就值得升级到<code class="fe lq lr ls lt b">React 18</code>。</p><p id="2141" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管这个版本非常令人兴奋，我们还是迫不及待地想看到<code class="fe lq lr ls lt b">Suspense data fetching</code>准备好。这将是一个巨大的游戏规则改变者，开启许多模式。我们必须有耐心。难点在于需要同步的移动棋子很多。</p><p id="77c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">花了一些时间才完成这个版本。然而，他们对<code class="fe lq lr ls lt b">Suspense</code>的实现值得等待。</p><p id="757e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div></div>    
</body>
</html>