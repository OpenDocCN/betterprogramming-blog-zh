# 雷迪斯锁定了！你确定吗？

> 原文：<https://betterprogramming.pub/redis-as-a-lock-are-you-sure-a870c9f22ad8>

## 你说的锁是专属锁还是壁垒？

![](img/f44f3d087d36a526d0673be164eb4cbb.png)

弗洛里安·奥利佛在 Unsplash[上的照片](https://unsplash.com/?utm_source=medium&utm_medium=referral)

Redis 是一个将数据保存在内存中的存储器，我们知道内存中的任何东西都是不可靠的。此外， [Redis 的数据持久性](https://towardsdev.com/data-persistence-in-redis-2780c11d1623)并不像宣称的那么可靠。因此，使用 Redis 作为锁来实现某种同步是非常危险的。

然而，本文并不打算只关注 Redis 的不可靠性，而是进一步分析这些锁的使用是否正确。

事实上，我们经常把两个非常不同的概念称为锁。

*   独占锁:用于控制一个关键部分的访问权限，一次只能有一个人在关键部分。一个类似的概念是信号量，它允许临界区中有最大数量的人。
*   障碍:用于降低特定动作的频率。

然而，这两个概念具有完全不同的目的，并且以完全不同的方式实现。然而，通常，我们没有仔细定义需求并选择正确的方法，从而导致异常。

# 互锁

排他锁(也称为互斥锁)的目的是控制临界区的并发用户只有一个。

既然是临界段，就有两个动作，锁定和释放，锁定时进入，释放时离开。这通常用于避免数据库中的竞争情况，例如 MySQL 无法避免更新丢失，因此使用额外的排他锁作为两个同时更新的同步机制。

基于以上描述，我们可以编写一个伪代码。

```
while tryLock(forLongTime):
    sleep(veryShortTime)

doSomeThing()releaseLock()
```

以上有几点值得注意。

1.  `tryLock`方法包含两个动作:获取锁并锁定它。如果你能获得锁，你必须立即锁定它，否则锁会被别人拿走，下面的关键部分就会被突破。
2.  等待时间应该设置得很短，目的是能够尽快继续工作，而不是花费大量时间等待。
3.  但是锁定时间要很长，避免事情还没做完锁就消失了，导致临界区失效。
4.  在完成需要完成的工作后，必须立即释放锁，以便其他人可以立即访问临界区。

同样，排他锁的目的是控制对关键部分的访问。如果两个动作同时发生，那么两个动作都可以正确完成，只是一个接一个。

# 屏障

屏障的目的是减少某个动作的频率。比如你连续调用一个 API 两次，第二次 API 回应“请稍后再试”，这就是典型的壁垒。

因为目的是降低频率，所以阻塞的时间很重要，这取决于特性要求。例如，如果产品规范要求 API 之间至少间隔 5 秒，那么锁定时间就是 5 秒。这通常比独占锁的锁定时间短。

我们也试着写伪代码。

```
if tryLock(featureSpecTime):
    return Falsereturn doSomeThing()
```

和独占锁相比，没有解锁和等待，使用的是同一个`tryLock`，只是锁的时间是从产品要求来的。

障碍是降低频率，所以如果两个动作同时发生，那么一个会成功，另一个会失败。

# Redis 怎么样？

好的，我们知道所有这些，那么这对 Redis 有什么关系呢？是的，绝对的。

Redis 是最常用于实现排他锁或屏障的一个，而两边都使用的`tryLock`是 Redis 中的一行命令:`SET someKey 1 EX someTime NX`。根据结果是`OK`还是`nil`，可以判断是否已经获得锁。从实现上来说，这很简单。

但是，正如文章开头提到的，Redis 数据并不可靠，使用 Redis 作为排他锁可能会导致临界区失效。

Redis 可以起到很好的屏障作用，因为一次封杀失败最多是多做几次的动作，不影响系统的稳定性，但作为独占锁，必须慎重考虑利弊。

对于我来说，如果想避免 MySQL 丢失更新，我一直推荐使用 MySQL 的原生`FOR UPDATE`，实现起来并不难，也不需要等待，也不会失效。当然，要避免 MySQL 丢失更新，除了加锁还有几种方法，可以在[我之前的文章](https://medium.com/interviewnoodle/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4)中找到。

# 结论

本文解释了我们通常所说的锁实际上有两种不同的含义，尽管它们有相似的外观，但它们实现的目的和细节是完全不同的。

总结一下。

*   排他锁:两个同时发生的动作都会成功，但是一个接一个。
*   障碍:两个同时发生的动作，只有一个会成功。

当谈到锁时，确保您确切地知道您想要处理哪种上下文，并得到正确的处理。在我的情况下，即使我的系统中有 Redis 并且我会使用它，我也会设计我的系统，就好像 Redis 数据不存在一样，这样当不幸的事情发生时，你就会知道你的系统是否会正确处理它。