# 算法:Swift 中的堆排序

> 原文：<https://betterprogramming.pub/heapsort-in-swift-sorting-elements-in-o-n-log-n-866186b5e38c>

## 在 O(n log n)中排序元素

![](img/aad75c72a1616175ea9d087642f70eee.png)

照片由 [Unsplash](https://unsplash.com/s/photos/pile?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的 [Aditya Saxena](https://unsplash.com/@adityaries?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 拍摄

我希望你能看看我之前关于堆的文章，“T4，让我们在 Swift 中学习堆”，因为堆是这个算法的核心。

今天我们就稍微讨论一下叫做 [*heapsort*](https://en.wikipedia.org/wiki/Heapsort) 的排序算法。它于 60 年代推出，现在仍然是对数字、字符串等进行排序的最强大的结构之一。引入堆的同一个人也提出了堆排序，所以看起来他们本质上是相互关联的。我们会知道为什么。

# 算法背后的想法

没有堆就没有堆排序。堆的概念是有一个结构，其中第一个元素总是插入到结构中的最大或最小的元素——这取决于我们是在讨论最大堆还是最小堆。

堆排序使用最大堆将元素从最小到最大排序。利用这个优势，J.W.J. Williams，这个引入这个算法的家伙，决定做一些有趣的事情。他的想法是将堆中的第一个元素与最后一个元素交换。这样做之后，他会说堆的大小减少了一个单位，他会将那个堆堆化。通过 *heapify* ，我的意思是他将确保堆仍然符合堆的规则:第一个元素仍然是最大的一个。这个过程将重复 *n-1* 次，其中 *n* 是被排序列表的大小。

# 这个过程有多快？

根据 Cormen 的《算法导论》，heapsort 要执行的复杂度时间为 *O (n log n)* 。科尔曼解释说，构建这个堆需要花费 *O (n)* 的时间，再加上所有 n-1 次对这个堆进行堆化的调用都需要花费 *O (log n)* 。

# 在 Swift 中实施

# 在 Swift 中实施

[我们将使用我们过去用 heaps 做的实现](https://medium.com/@Alcivanio/swift-a-quick-look-in-heaps-using-swift-ea9aca929d9d)。唯一的区别是我们现在将使用最大堆而不是最小堆。改变的是我们在调用`heapifyUp`和`heapifyDown`时所做的比较。我们不检查父节点或子节点是否更大，而是检查它是否更小。正如我在上一篇文章中所承诺的，我已经对堆做了一些修改，这样它现在看起来更敏捷了。

要检查堆的大小，我们必须检查条目列表的大小。听起来很公平，我们使用了我们的目标语言所能提供的最好的东西。每当实现堆排序时，我们都会操纵这个计数。为了简单起见，我们将为排序后的元素创建一个计数器。每当一个元素现在被放在正确的位置——意味着它被排序了——我们将把这个变量加 1。计数的变化将是计数现在是列表的大小减去排序元素的数量。听起来合法而且有用。

装载完堆后，为了执行堆排序，我们只需遍历元素来对它们进行排序。算法会非常简单。它在列表中迭代 n-1 次，用最后一个元素交换第一个元素，然后执行 heapify。

# Heapify 如何工作

*heapify down**的思路是获取根节点并放在正确的位置。我们知道根节点现在可能没有定位好，因为我们刚刚得到了最后一个元素并把它放在那里。然后我们检查是否有比它更大的孩子。如果是，我们交换它们。我们继续沿着树往下做同样的检查，直到我们确定堆现在遵循了堆的所有规则；在这种情况下，父节点比子节点大。*

*重复这个过程 *n-1* 次后，我们将得到一个排序后的列表。如果 A 是我们想要排序的列表，这个算法将确保 A[i] < A[i+1]，A[I+1]<A[I+2]，…，A[n-1] < A[n]，其中 I 是 int，I>0，I<n。n 是列表的大小，考虑到我们的列表从 1 到 n 进行索引*

*在我的 GitHub 上有完整的实现，所以你可以在你的系统上检查和运行它。如果您在实施过程中发现任何问题，请不要犹豫。*

*在评论里说说你对这个算法的看法。*

*感谢阅读！*