<html>
<head>
<title>How to Test Multiple SwiftUI Bottom Sheet Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试多个SwiftUI底层回调</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/behavioural-testing-of-swiftui-views-with-host-app-and-viewtest-f1343a281c5f?source=collection_archive---------7-----------------------#2021-10-07">https://betterprogramming.pub/behavioural-testing-of-swiftui-views-with-host-app-and-viewtest-f1343a281c5f?source=collection_archive---------7-----------------------#2021-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6c38" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">并了解如何使用SwiftUI和_ViewTest协议以编程方式点击按钮</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/290fc1ddc84ad421c86263568590b69d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mtKoHAdhbVLOX7p-"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥斯汀·迪斯特尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="c96b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之前我写了一个<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/easter-egg-swiftuis-viewtest-61b86f1e90d">故事</a>，关于SwiftUI公共接口和隐藏测试套件中<code class="fe ls lt lu lv b">_ViewTest</code>协议的发现。</p><p id="4726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个故事中，我将介绍隐藏的SwiftUI测试套件与<code class="fe ls lt lu lv b">XCTest</code>的集成。</p><p id="8816" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于演示的目的，我将使用SwiftUI中的测试场景，通过这个API使用<a class="ae kv" href="https://medium.com/@eugenedudnyk/customise-and-resize-sheets-in-swiftui-df9fae7c369b" rel="noopener"> SheeKit </a>一个接一个地呈现多个工作表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">SheeKit API</p></figure><p id="901b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将测试每一个提交的表单的<code class="fe ls lt lu lv b">onDismiss</code>回调是否真的在表单的每一次撤销时被调用。</p><p id="228b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们设置测试套件。</p><ol class=""><li id="8157" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">创建测试主机应用程序目标和单元测试目标</li></ol><p id="c8d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:在Xcode 12中，在创建测试主机应用程序目标时，必须选择SwiftUI生命周期:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/f09e2a11da62c508a7c524c6bb0cda8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SLq_dJ2pVfhaNsqrKBL2Vw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><code class="fe ls lt lu lv b">SheeKitTestsHost</code>在Xcode 13中测试目标</p></figure><p id="b884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.选择<code class="fe ls lt lu lv b">SheeKitTestsHost</code>作为<code class="fe ls lt lu lv b">SheeKitTests</code>的主机应用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/f2be7a0012112127a3c85e2a088554e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xdAgYlDqv43V_v_l_P-3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为SheeKitTests选择宿主应用程序</p></figure><p id="5223" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.从<code class="fe ls lt lu lv b">SheeKitTestsHost</code>文件夹中删除Xcode创建的<code class="fe ls lt lu lv b">ContentView.swift</code>文件——我们不再需要它。</p><p id="58a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.在<code class="fe ls lt lu lv b">SheeKitTestsHostApp.swift</code>中，我们将运行隐藏的SwiftUI测试主机应用程序(<code class="fe ls lt lu lv b">_TestApp</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="acbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">5.在<code class="fe ls lt lu lv b">SheeKitTests</code> target中，我们需要一些助手来测试视图。我们将用这些内容创建<code class="fe ls lt lu lv b">ViewTestCase.swift</code>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7361" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ViewTestCase</code>将是我们所有SwiftUI行为测试用例的超类。</p><p id="f5f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它期望子类覆盖<code class="fe ls lt lu lv b">initRootView()</code>并提供测试用例主题的具体视图。</p><p id="0a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它在<code class="fe ls lt lu lv b">setUp()</code>方法中将根视图安装到测试主机应用程序屏幕中，并在<code class="fe ls lt lu lv b">tearDown()</code>方法中移除该视图。</p><p id="9077" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些都是通过使用SwiftUI接口中隐藏的公共方法来完成的。</p><p id="1545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在一切都准备好了，可以编写实际的测试用例了。</p><h1 id="d799" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">测试案例示例</h1><p id="8efb" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">我们将使用一个<code class="fe ls lt lu lv b">ShowPartDetail</code>视图作为显示工作表的视图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="967a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将创建空的测试用例实现(但没有实际的测试):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e8dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个测试案例中，我:</p><ul class=""><li id="6392" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr ng me mf mg bi translated">在<code class="fe ls lt lu lv b">setUp</code>方法中禁用动画，然后在<code class="fe ls lt lu lv b">tearDown</code>中将它们恢复到启用状态，这样在测试过程中，工作表会立即显示。</li><li id="17c1" class="ly lz iq ky b kz nh lc ni lf nj lj nk ln nl lr ng me mf mg bi translated">覆盖<code class="fe ls lt lu lv b">initRootView()</code>并返回实际的<code class="fe ls lt lu lv b">ShowPartDetail</code>视图，该视图封装在<code class="fe ls lt lu lv b">AnyView</code>中。此外，我在视图<code class="fe ls lt lu lv b">ShowPartDetail</code>中安装了一个关于表单解散的回调函数，以便在每次回调时增加<code class="fe ls lt lu lv b">dismissCounter</code>。</li><li id="6b2e" class="ly lz iq ky b kz nh lc ni lf nj lj nk ln nl lr ng me mf mg bi translated">调用<code class="fe ls lt lu lv b">super.setUp()</code>以便<code class="fe ls lt lu lv b">ViewTestCase</code>可以在测试开始时将视图安装到主机应用程序中</li><li id="9b41" class="ly lz iq ky b kz nh lc ni lf nj lj nk ln nl lr ng me mf mg bi translated">调用<code class="fe ls lt lu lv b">super.tearDown()</code>以便<code class="fe ls lt lu lv b">ViewTestCase</code>可以在测试中断时从主机应用程序中移除视图</li></ul><p id="c078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们通过按下其声明附近的▶️按钮来运行<code class="fe ls lt lu lv b">test()</code>方法，我们将能够在屏幕上看到我们的<code class="fe ls lt lu lv b">ShowPartDetail</code>视图，甚至与它交互来手动测试是否一切都设置正确。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/5df9810328c1e4c5503c4457b6b074a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v02hZQbbzWHK2BMz0TBY1g.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">初始试运行</p></figure><h2 id="33dd" class="nn mk iq bd ml no np dn mp nq nr dp mt lf ns nt mv lj nu nv mx ln nw nx mz ny bi translated">第一个案例</h2><blockquote class="nz oa ob"><p id="b324" class="kw kx oc ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">对于用<code class="fe ls lt lu lv b">item</code>显示的两个后续页，确保<code class="fe ls lt lu lv b">onDismiss</code>被调用两次。</p></blockquote><p id="16c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试这个场景，我们必须:</p><ol class=""><li id="6eea" class="ly lz iq ky b kz la lc ld lf ma lj mb ln mc lr md me mf mg bi translated">以编程方式点击<code class="fe ls lt lu lv b">Show Part Details</code>按钮，这将分配一个<code class="fe ls lt lu lv b">InventoryItem.first</code>给<code class="fe ls lt lu lv b">sheetDetail</code>并触发第一个要显示的表单。</li><li id="6599" class="ly lz iq ky b kz nh lc ni lf nj lj nk ln nl lr md me mf mg bi translated">点击<code class="fe ls lt lu lv b">Change Part Details</code>按钮，会将<code class="fe ls lt lu lv b">InventoryItem.second</code>分配给<code class="fe ls lt lu lv b">sheetDetail</code>并触发第一张纸的退纸和第二张纸的呈现。</li><li id="f32a" class="ly lz iq ky b kz nh lc ni lf nj lj nk ln nl lr md me mf mg bi translated">再次点击<code class="fe ls lt lu lv b">Change Part Details</code>按钮，将<code class="fe ls lt lu lv b">nil</code>分配给<code class="fe ls lt lu lv b">sheetDetail</code>并触发第二张纸的退纸。</li></ol><p id="f9a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们如何用SwiftUI编程点击按钮呢？</p><p id="1fe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI在<code class="fe ls lt lu lv b">_ViewTest</code>协议中有一个方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6b21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，为了让SwiftUI和UIKit转换它们的齿轮并做它们的事情，我们需要在第一次点击和第二次点击之间等待一段时间，以便第一个表实际上被显示。为此，我们将在<code class="fe ls lt lu lv b">_ViewTest</code>中使用隐藏的公共运行循环控制API:</p><pre class="kg kh ki kj gt og lv oh oi aw oj bi"><span id="0d06" class="nn mk iq lv b gy ok ol l om on">public func turnRunloop(times: Swift.Int = 1)</span></pre><p id="bacb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个测试用例<code class="fe ls lt lu lv b">Item Changed Thrice / Dismissed Twice</code>的完整实现是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="318e" class="nn mk iq bd ml no np dn mp nq nr dp mt lf ns nt mv lj nu nv mx ln nw nx mz ny bi translated">第二种情况</h2><p id="f452" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">对于第二种情况，让我们想想第一种情况可能会出什么问题。当第一种情况中的步骤2和3发生得太快以至于第二张纸没有时间被呈现时，潜在的问题可能发生。在这种情况下，它根本不应该出现，因此<code class="fe ls lt lu lv b">onDismiss</code>应该只被调用一次。</p><blockquote class="nz oa ob"><p id="b26e" class="kw kx oc ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">为<code class="fe ls lt lu lv b">item = first</code>呈现一个表，对于<code class="fe ls lt lu lv b"><em class="iq">item</em></code>到<code class="fe ls lt lu lv b">second</code>然后到<code class="fe ls lt lu lv b">nil</code>的接下来两个快速变化，确保<code class="fe ls lt lu lv b"><em class="iq">onDismiss</em></code>仅被调用一次(仅针对第一个表)，并且第二个表不被呈现。</p></blockquote><p id="1100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过向<code class="fe ls lt lu lv b">Change Part Details</code>按钮发送两次触摸来模拟这样的场景，而不需要在两次触摸之间循环运行。</p><p id="03e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是<code class="fe ls lt lu lv b">Item Changed Thrice / Dismissed Once</code>测试用例的完整实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="675d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当两种情况都准备好了，我们只需要注释初始预览<code class="fe ls lt lu lv b">test()</code>方法，这样我们的测试套件就不会在所有测试用例运行时陷入死循环。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="0252" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论</h1><p id="7095" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated"><code class="fe ls lt lu lv b">_ViewTest</code>允许我们对SwiftUI的运行循环进行精确控制，这对于复杂场景的行为测试来说是一个至关重要的特性，这些复杂场景很难或不可能用UI测试来模拟。</p><p id="4fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它允许直接控制哪些视图被安装用于测试，并且可以直接访问主机应用程序来检查UIKit视图/视图控制器层次结构的状态。</p><p id="7da8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！我希望你从这个故事中学到了一些关于SwiftUI的新东西。</p></div></div>    
</body>
</html>