<html>
<head>
<title>How to Apply Interface Segregation Principle in ReactJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在反应堆中应用界面分离原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-apply-interface-segregation-principle-in-reactjs-fadf77113c5d?source=collection_archive---------2-----------------------#2021-04-29">https://betterprogramming.pub/how-to-apply-interface-segregation-principle-in-reactjs-fadf77113c5d?source=collection_archive---------2-----------------------#2021-04-29</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a2ce" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">行动中的坚实原则</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/cf4d61fcc71199997637b30d164d1986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4jM1TbqPHE3_-ZxkJWUpQ.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由来自<a class="ae kz" href="https://www.pexels.com/photo/black-and-white-classic-camera-2686903/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae kz" href="https://www.pexels.com/@bruzewalker?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">布鲁诺·塞尔韦拉</a>拍摄</p></figure><p id="d7ea" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SOLID是一组不特定于任何框架或语言的原则。这些原则帮助我们理解如何为客户编写漂亮的应用程序。</p><p id="700b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天我们将讨论固体的第四个原理:</p><blockquote class="lw"><p id="0712" class="lx ly iu bd lz ma mb mc md me mf lv dk translated"><strong class="ak"> I: </strong> <em class="mg">界面偏析原理</em></p></blockquote><p id="df9d" class="pw-post-body-paragraph la lb iu lc b ld mh jv lf lg mi jy li lj mj ll lm ln mk lp lq lr ml lt lu lv in bi translated">我们将尝试理解这个原则的基本概念，并在<strong class="lc iv"> ReactJS </strong>的上下文中实现它。</p></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><h2 id="88ea" class="mt mu iu bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated">本系列的前几篇文章</h2><ol class=""><li id="894e" class="nm nn iu lc b ld no lg np lj nq ln nr lr ns lv nt nu nv nw bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/how-to-apply-solid-principles-to-clean-your-code-in-react-cdfd5e0a9cea">单一责任原则</a></li><li id="c806" class="nm nn iu lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40">开启关闭原理</a></li><li id="19a8" class="nm nn iu lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-liskov-substitution-principle-in-react-3a0614a42a08">利斯科夫替代原理</a></li><li id="89de" class="nm nn iu lc b ld nx lg ny lj nz ln oa lr ob lv nt nu nv nw bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/apply-the-dependency-inversion-principle-in-react-c20a0afc3d64">依存倒置原则</a></li></ol></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><h1 id="f031" class="oc mu iu bd mv od oe of my og oh oi nb ka oj kb ne kd ok ke nh kg ol kh nk om bi translated">这个原理是什么？</h1><p id="5693" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj on ll lm ln oo lp lq lr op lt lu lv in bi translated">根据<a class="ae kz" href="https://stackify.com/interface-segregation-principle/" rel="noopener ugc nofollow" target="_blank">叠加</a>中的<strong class="lc iv">界面偏析原理</strong>所述</p><blockquote class="lw"><p id="483d" class="lx ly iu bd lz ma mb mc md me mf lv dk translated">不应该强迫客户端依赖他们不使用的接口</p></blockquote><p id="867f" class="pw-post-body-paragraph la lb iu lc b ld mh jv lf lg mi jy li lj mj ll lm ln mk lp lq lr ml lt lu lv in bi translated">在ReactJS <strong class="lc iv">中我们不使用任何接口</strong>，至少不是在面向对象编程的意义上。因此，这个场景的主要要点是:</p><blockquote class="lw"><p id="27b0" class="lx ly iu bd lz ma mb mc md me mf lv dk translated">组件不应该依赖于它们不需要的东西。</p></blockquote><p id="1467" class="pw-post-body-paragraph la lb iu lc b ld mh jv lf lg mi jy li lj mj ll lm ln mk lp lq lr ml lt lu lv in bi translated">现在，让我们看看这个原则如何帮助我们编写干净漂亮的ReactJS组件。</p></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><h1 id="59d8" class="oc mu iu bd mv od oe of my og oh oi nb ka oj kb ne kd ok ke nh kg ol kh nk om bi translated">实用的方法</h1><p id="c13d" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj on ll lm ln oo lp lq lr op lt lu lv in bi translated">假设我们有一个负责显示用户详细信息的<code class="fe oq or os ot b"><strong class="lc iv">User</strong></code>组件。我们的用户对象看起来像这样:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">user.ts</p></figure><p id="83ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，它使用了两个子组件，名为<code class="fe oq or os ot b">PersonalDetails</code>和<code class="fe oq or os ot b">BankingDetails</code>来显示细节。</p><p id="0cd6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的<code class="fe oq or os ot b">User</code>组件看起来像这样:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="956b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样我们的<code class="fe oq or os ot b">PersonalDetails</code>看起来是这样的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">个人详细信息</p></figure><p id="3960" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们的BankingDetails.js是这样的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">BankingDetails.js</p></figure><p id="3e4e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那么，这种方法有什么问题呢？嗯，两件事。</p><p id="bb33" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先，我们的<code class="fe oq or os ot b">PersonalDetails</code>组件不需要银行信息，我们的<code class="fe oq or os ot b">BankingDetails</code>组件也不需要个人信息来运行，所以这显然违反了接口分离原则。</p><p id="9449" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">其次，在将来，如果我们想在我们的项目中添加typescript(你应该这样做)，然后测试<code class="fe oq or os ot b">PersonalDetails</code>，你将被要求模拟整个用户对象，尽管银行信息与<code class="fe oq or os ot b">PersonalDetails</code>无关。</p><p id="efeb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">所以，我们需要解决这个问题。但是怎么做呢？</p></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><h1 id="521c" class="oc mu iu bd mv od oe of my og oh oi nb ka oj kb ne kd ok ke nh kg ol kh nk om bi translated">让我们解决这个问题</h1><p id="37e1" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj on ll lm ln oo lp lq lr op lt lu lv in bi translated">有几种方法可以解决这个问题，但基本原理是相同的。</p><blockquote class="lw"><p id="4510" class="lx ly iu bd lz ma mb mc md me mf lv dk translated">我们只需要将相关信息传递给子组件。</p></blockquote><p id="a7a6" class="pw-post-body-paragraph la lb iu lc b ld mh jv lf lg mi jy li lj mj ll lm ln mk lp lq lr ml lt lu lv in bi translated">因此，我们将分解我们的数据对象，并将适当的部分仅传递给相应的组件。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/f6a2b54be3d63c7a3d29592692414c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTVgTG3lCHIfK3ZNOrwL2A.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">图片鸣谢:<a class="ae kz" href="https://medium.com/@learnstuff.io/interface-segregation-principle-dd885e59aec9" rel="noopener">https://medium . com/@ learn stuf . io/interface-segregation-principle-DD 885 e 59 AEC 9</a></p></figure><p id="95f2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">大概是这样的:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">User.js</p></figure><p id="0033" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们用新的键<code class="fe oq or os ot b">personalDetails</code>和<code class="fe oq or os ot b">bankingDetails</code>将用户数据分成两部分，并将这部分特定的数据传递给我们的子组件。</p></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><h1 id="ef9d" class="oc mu iu bd mv od oe of my og oh oi nb ka oj kb ne kd ok ke nh kg ol kh nk om bi translated">第二种方法</h1><p id="52e7" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj on ll lm ln oo lp lq lr op lt lu lv in bi translated">前面的解决方案很完美，但是如果你对数据没有控制权呢？也许是从一个遥远的地方拿来的。或者因为某种原因不想修改数据结构怎么办？</p><p id="24d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">别担心。我们可以应用另一种技术来解决这个问题:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">User.js</p></figure><p id="305f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们的子组件中，我们可以如下使用它:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">个人详细信息</p></figure><p id="59ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">并且:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">BankingDetails.js</p></figure><p id="7684" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们的子组件只得到它们需要的东西。它们更干净，更容易理解。</p><p id="a594" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们的组件不依赖于任何他们不需要的东西。</p><h1 id="2a76" class="oc mu iu bd mv od ox of my og oy oi nb ka oz kb ne kd pa ke nh kg pb kh nk om bi translated">棺材上的最后一颗钉子</h1><p id="94f9" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj on ll lm ln oo lp lq lr op lt lu lv in bi translated">至此，我们引入了<strong class="lc iv">接口分离原则</strong>的概念，以使我们的组件紧密。但是在我们之前的<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/applying-the-liskov-substitution-principle-in-react-3a0614a42a08">文章</a>中，关于<strong class="lc iv"> Liskov替换原则，</strong>我们发现我们当前的解决方案有一个问题，那就是任何东西都可以传递给子组件。</p><p id="e30f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们在项目中引入typescript并解决这个问题。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="7e40" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">同样，我们可以对<code class="fe oq or os ot b">BankingDetails</code>组件做同样的事情。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="ou ov l"/></div></figure><p id="c592" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们被迫只将相关数据传递给子组件。不再有你不想要的bug！</p><p id="c2b4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">多棒啊。:D</p></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><h1 id="1fb9" class="oc mu iu bd mv od oe of my og oh oi nb ka oj kb ne kd ok ke nh kg ol kh nk om bi translated">最后的想法</h1><p id="2954" class="pw-post-body-paragraph la lb iu lc b ld no jv lf lg np jy li lj on ll lm ln oo lp lq lr op lt lu lv in bi translated">这些只是指导你思考方式的原则，而不是构建你的应用的硬性规则。</p><p id="2895" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这些概念的知识会让你领先于他人。这些概念一定会帮助你理解编程的核心原则。</p><blockquote class="lw"><p id="a68c" class="lx ly iu bd lz ma mb mc md me mf lv dk translated">因为框架是暂时的，但概念是永久的</p></blockquote></div><div class="ab cl mm mn hy mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="in io ip iq ir"><p id="79d5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你喜欢这篇文章，就像我喜欢写它一样。祝您愉快！</p><p id="02d7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><strong class="lc iv">有话要说？通过</strong><a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="lc iv">LinkedIn</strong>T5】与我联系</a></p><h2 id="abd9" class="mt mu iu bd mv mw mx dn my mz na dp nb lj nc nd ne ln nf ng nh lr ni nj nk nl bi translated">资源</h2><ul class=""><li id="8eb8" class="nm nn iu lc b ld no lg np lj nq ln nr lr ns lv pc nu nv nw bi translated">stackify:<strong class="lc iv"/><a class="ae kz" href="https://stackify.com/interface-segregation-principle/" rel="noopener ugc nofollow" target="_blank">https://stackify.com/interface-segregation-principle/</a></li></ul></div></div>    
</body>
</html>