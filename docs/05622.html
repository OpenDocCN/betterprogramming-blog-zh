<html>
<head>
<title>Intro to @ngrx/component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">@ngrx/component简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/intro-to-ngrx-component-15c0dfd9b44a?source=collection_archive---------5-----------------------#2020-07-22">https://betterprogramming.pub/intro-to-ngrx-component-15c0dfd9b44a?source=collection_archive---------5-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e9b2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">改进NGRX项目的综合指南(第2部分)</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0216e00458c9c6c1889465884f012427.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIEH3_qC-Pgnv8t8Y56wIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure><p id="c9ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">新特性正在进入NGRX，其中之一是<a class="ae lr" href="https://ngrx.io/guide/component" rel="noopener ugc nofollow" target="_blank"> ngrx/component </a>。它带来了大量的机会使我们的编程更容易更快。显然，它的出现帮助我们摆脱了模板中的<code class="fe ls lt lu lv b"><a class="ae lr" href="https://angular.io/api/common/AsyncPipe" rel="noopener ugc nofollow" target="_blank">async</a></code>管道。而且，在引擎盖下，它最大限度地利用了角度生命周期。</p><p id="8f8f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将简单地探讨一下，同时，您将看到一些概念的基础，从而理解我们为什么要使用它。最后，我们将把它应用到一个用NGRX完成的简单项目中，从这个特性中获益。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="693a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用案例</h1><p id="2766" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">用例是用Angular和NGRX superpower构建的一个简单的待办事项列表，我们已经在第1部分中看到并改进了它。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/better-programming/refactoring-reducers-states-for-a-better-store-cdb355632fbf" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">重构归约器和状态以获得更好的存储</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">改进NGRX项目的综合指南(第1部分)</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kp nd"/></div></div></a></div></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="e2eb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">介绍</h1><p id="d0dd" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">@ngrx/components是什么？</p><p id="f71a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">来自文档:</p><blockquote class="ns nt nu"><p id="4b46" class="kv kw nv kx b ky kz jr la lb lc ju ld nw lf lg lh nx lj lk ll ny ln lo lp lq ij bi translated">组件是一组基本的反应式帮助器，用于支持完全反应式、完全无区域的应用程序。它们对渲染提供了更多的控制，并为角度应用提供了进一步的反应。</p></blockquote><p id="5f18" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">用简单的英语说:</p><blockquote class="ns nt nu"><p id="dfa8" class="kv kw nv kx b ky kz jr la lb lc ju ld nw lf lg lh nx lj lk ll ny ln lo lp lq ij bi translated">指令和管道消除了区域的使用，并改进了角度模板中可观察对象的处理。</p></blockquote><p id="02e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，有两个:</p><ul class=""><li id="f357" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">* <a class="ae lr" href="https://ngrx.io/guide/component/let" rel="noopener ugc nofollow" target="_blank"> ngrxLet </a></li><li id="d61a" class="nz oa iq kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><a class="ae lr" href="https://ngrx.io/guide/component/push" rel="noopener ugc nofollow" target="_blank"> ngrxPush </a></li></ul><p id="0378" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但在我们深入研究之前，让我们先澄清一下为什么需要更换<code class="fe ls lt lu lv b">async</code>管道:</p><blockquote class="ns nt nu"><p id="e6ea" class="kv kw nv kx b ky kz jr la lb lc ju ld nw lf lg lh nx lj lk ll ny ln lo lp lq ij bi translated">问题是<code class="fe ls lt lu lv b">async</code>管道只是将组件及其所有祖先标记为脏。它需要zone.js微任务队列耗尽，直到调用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://angular.io/api/core/ApplicationRef" rel="noopener ugc nofollow" target="_blank">ApplicationRef.tick</a></code>渲染所有脏的标记组件。</p><p id="ff81" class="kv kw nv kx b ky kz jr la lb lc ju ld nw lf lg lh nx lj lk ll ny ln lo lp lq ij bi translated">大量的动态和交互式用户界面受到区域变化检测的影响，可能会导致性能下降，甚至无法使用应用程序，但是<code class="fe ls lt lu lv b">async</code>管道在无区域模式下不工作。</p></blockquote></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="8b9a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">关键概念</h1><h2 id="d586" class="on me iq bd mf oo op dn mj oq or dp mn le os ot mp li ou ov mr lm ow ox mt oy bi translated">1.NgZone</h2><p id="6ffa" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">总之，感谢<code class="fe ls lt lu lv b"><a class="ae lr" href="https://angular.io/guide/zone" rel="noopener ugc nofollow" target="_blank">NgZone</a></code> Angular让我们能够自动检测组件的变化，目的是更新我们的HTMLs。很明显，在CPU处理方面是有成本的。</p><p id="261b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">检测用户事件、请求和定时器发生的变化的问题与异步有共同之处。尽管如此，我们使用<code class="fe ls lt lu lv b">Observable</code>的任何时候，都知道正确的时间来检测变化并呈现在我们的UI中。这改变了一切。</p><p id="0652" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一些例子，这样我们可以澄清所有这些关于更新HTMLs的概念。</p><p id="3f0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">普通/普通javascript: </strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">如果您想检测普通/普通javascript中的变化，您应该这样做。</p></figure><p id="f328" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">角度，默认配置:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用Angular的默认配置，我们不需要做任何与变化检测相关的事情。</p></figure><p id="a556" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">有角度，无NgZone: </strong></p><p id="8b6a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">角度禁用区</p><ol class=""><li id="a0e9" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq pb of og oh bi translated"><code class="fe ls lt lu lv b">polyfills.ts</code>中的<code class="fe ls lt lu lv b">zone.js</code>行注释:</li></ol><pre class="kg kh ki kj gt pc lv pd pe aw pf bi"><span id="743e" class="on me iq lv b gy pg ph l pi pj">//'zone.js/dist/zone';</span></pre><p id="a6a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.在<code class="fe ls lt lu lv b">src/main.ts</code>的<code class="fe ls lt lu lv b">noop</code>区域中的自举角度:</p><pre class="kg kh ki kj gt pc lv pd pe aw pf bi"><span id="3ab4" class="on me iq lv b gy pg ph l pi pj">platformBrowserDynamic().bootstrapModule(AppModule,{ ngZone:'noop'})</span></pre><p id="6036" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在<code class="fe ls lt lu lv b">NgZone</code>不再使用，所以检测不是自动的。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="13d8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">3.但是，我们可以手动触发它，它将正常工作，<code class="fe ls lt lu lv b">src/click-me/click-me.component.ts</code>:</p><pre class="kg kh ki kj gt pc lv pd pe aw pf bi"><span id="1a3b" class="on me iq lv b gy pg ph l pi pj"> ...</span><span id="2f24" class="on me iq lv b gy pk ph l pi pj">constructor(private changeDetector: ChangeDetectorRef) {}</span><span id="537c" class="on me iq lv b gy pk ph l pi pj"> ...</span><span id="bdf6" class="on me iq lv b gy pk ph l pi pj">onClickMe() {<br/>  this.clickMessage = ‘You are the best!’;<br/>  this.changeDetector.detectChanges();<br/>}</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">没有Angular中的NgZone，我们需要为检测变化而变魔术。</p></figure><p id="3f41" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">后端的计算量更少是主要优势。另一方面，停用部分内核让我们负责Angular的变化检测(这一点都不容易)。</p><p id="9f56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你想更深入，这里有一些非常好的读物。</p><div class="na nb gp gr nc nd"><a href="https://medium.com/better-programming/zone-js-for-angular-devs-573d89bbb890" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">每个Angular开发人员都应该知道的关于Zone.js的10件事</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">每个开发人员都应该了解Zone.js的基础知识</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="pl l no np nq nm nr kp nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://indepth.dev/do-you-still-think-that-ngzone-zone-js-is-required-for-change-detection-in-angular/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">你还认为Angular中的变化检测需要NgZone (zone.js)吗？</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">我看到的大多数文章都将Zone( zone.js)和NgZone与Angular中的变化检测紧密地联系在一起。虽然…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">深度开发</p></div></div><div class="nm l"><div class="pm l no np nq nm nr kp nd"/></div></div></a></div><h2 id="232a" class="on me iq bd mf oo op dn mj oq or dp mn le os ot mp li ou ov mr lm ow ox mt oy bi translated">2.Null和undefined是相同的，但不完全相同</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/5189249bd23b521a2dc9fa8a61b21b8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*Mpb3pmAgxoGHcVXFtFSEHw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清楚这一点很重要，对吗？</p></figure><h2 id="fcad" class="on me iq bd mf oo op dn mj oq or dp mn le os ot mp li ou ov mr lm ow ox mt oy bi translated">3.RxJS中的运算符DistinctUntilChanged</h2><p id="a45c" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated"><code class="fe ls lt lu lv b">distinctUntilChanged()</code>运算符忽略重复的连续发射。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/5c0807aadda5398eb89a90d156315558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHKRWi7xeTY7A6NVxN2b6Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">快速看一下它的大理石雕像是什么样子的。文档在此，<a class="ae lr" href="https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged" rel="noopener ugc nofollow" target="_blank">https://rxjs-dev . firebase app . com/API/operators/distinctUntilChanged</a></p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="07ef" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用ngrxLet</h1><p id="8ae2" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated"><a class="ae lr" href="https://ngrx.io/guide/component/let" rel="noopener ugc nofollow" target="_blank">这个</a>指令提供了一种将observables绑定到视图上下文(dom元素范围)的便捷方式。</p><h2 id="8469" class="on me iq bd mf oo op dn mj oq or dp mn le os ot mp li ou ov mr lm ow ox mt oy bi translated">在我们的项目中使用</h2><p id="3e2f" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated"><code class="fe ls lt lu lv b">todo-list.component.ts</code></p><pre class="kg kh ki kj gt pc lv pd pe aw pf bi"><span id="7fc2" class="on me iq lv b gy pg ph l pi pj">&lt;ng-container *ngrxLet=”todos$ as todos”&gt;</span><span id="07cf" class="on me iq lv b gy pk ph l pi pj">&lt;todo *ngFor=”let todo of todos” [todo]=”todo” (onRemoveTodo)=”removeTodo($event)”<br/>(onToggleTodo)=”toggleTodo($event)”&gt;<br/>&lt;/todo&gt;</span><span id="d66c" class="on me iq lv b gy pk ph l pi pj">&lt;/ng-container&gt;</span></pre><p id="f6c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://ngrx.io/guide/component/let#included-features" rel="noopener ugc nofollow" target="_blank">技术特征</a>:</p><ul class=""><li id="fceb" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">去掉了<code class="fe ls lt lu lv b">async</code>或<code class="fe ls lt lu lv b">ngrxPush</code>管的多种用途。</li></ul><p id="ffd3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">已核实。</p><ul class=""><li id="0c2d" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">统一了null和undefined的处理方式。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/ea0eac30ce1f938b87d9c94d87ea0243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*JSs2qK5ryYnZHQ6rEdkAyA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://github.com/ngrx/platform/blob/5353343d5996dbff5ba5359071d8f7afc8ab4b7c/modules/component/src/core/cd-aware/cd-aware_creator.ts#L48" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><ul class=""><li id="6bb7" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">一行中不同的相同值(<code class="fe ls lt lu lv b">distinctUntilChanged</code>运算符)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/b1d508985e591eb4ab93c9b2254f9694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgLRKvUkYgTAu89zZ07n7Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://github.com/ngrx/platform/blob/5353343d5996dbff5ba5359071d8f7afc8ab4b7c/modules/component/src/core/cd-aware/cd-aware_creator.ts#L63" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure><ul class=""><li id="c44e" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">无论<code class="fe ls lt lu lv b">zone.js</code>是否出现(<code class="fe ls lt lu lv b">detectChanges</code>或<code class="fe ls lt lu lv b">markForCheck</code>)，都会触发不同的变化检测。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/c6f27c6a143cb1820deb0a2a2c74e6ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*eRkfolVnTsMF-QmI8DD3lw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae lr" href="https://github.com/ngrx/platform/blob/5353343d5996dbff5ba5359071d8f7afc8ab4b7c/modules/component/src/core/cd-aware/creator_render.ts#L9" rel="noopener ugc nofollow" target="_blank">来源</a></p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="0e54" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">使用ngrxPush</h1><p id="486c" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated"><a class="ae lr" href="https://ngrx.io/guide/component/push" rel="noopener ugc nofollow" target="_blank">这根</a>管是<code class="fe ls lt lu lv b">async</code>管的替代物。它包含变更检测的智能处理，使我们能够在全区域和无区域模式下运行，而无需对代码进行任何更改。</p><h2 id="28e7" class="on me iq bd mf oo op dn mj oq or dp mn le os ot mp li ou ov mr lm ow ox mt oy bi translated"><strong class="ak">在我们项目中使用</strong></h2><p id="889d" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated"><code class="fe ls lt lu lv b">todo-list.component.html</code></p><pre class="kg kh ki kj gt pc lv pd pe aw pf bi"><span id="c4d3" class="on me iq lv b gy pg ph l pi pj">&lt;todo *ngFor=”let todo of todos$ | ngrxPush” [todo]=”todo” (onRemoveTodo)=”removeTodo($event)” (onToggleTodo)=”toggleTodo($event)”&gt;<br/>&lt;/todo&gt;</span></pre><p id="7187" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://ngrx.io/guide/component/let#included-features" rel="noopener ugc nofollow" target="_blank">技术特征</a>:</p><ul class=""><li id="c6ce" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">Observables &amp; promises检索它们的值并将其呈现给模板。</li></ul><p id="6021" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里都正确。</p><p id="3374" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:这个管子只有在我们使用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://ngrx.io/guide/store" rel="noopener ugc nofollow" target="_blank">Store</a></code>时才起作用。万一你出于什么原因想用它而不使用NGRX，那就不行了。</p><p id="8631" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我用代码给你解释一下。</p><p id="2b97" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe ls lt lu lv b">todo-list.component.ts</code></p><pre class="kg kh ki kj gt pc lv pd pe aw pf bi"><span id="556c" class="on me iq lv b gy pg ph l pi pj">ngOnInit() {</span><span id="6b82" class="on me iq lv b gy pk ph l pi pj">// this.todos$ = this.store.select(selectTodos);</span><span id="4092" class="on me iq lv b gy pk ph l pi pj">this.todos$ = <strong class="lv ir">of</strong>([{ id: “123”, text: “new task”, todo: true }]);</span></pre><p id="56dc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它仍然是一个可观察的列表，但是如果你不通过选择器来做，那么它就不会处理你的模板中的待办事项列表。</p><ul class=""><li id="5282" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">如果<code class="fe ls lt lu lv b">zone.js</code>存在或不存在(<code class="fe ls lt lu lv b">detectChanges</code>或<code class="fe ls lt lu lv b">markForCheck</code>)，则<code class="fe ls lt lu lv b">unify null</code>和<code class="fe ls lt lu lv b">undefined</code>的值和触发变化检测不同，以提高性能。</li></ul><p id="8779" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">和ngrxLet一样，他们甚至共享那部分代码。</p><ul class=""><li id="aa11" class="nz oa iq kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated">合并变更检测调用以提高性能</li></ul><p id="15ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了本文的简单起见，您必须将它视为一种聚合变更检测的方式，以使它更快。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ps"><img src="../Images/fb359bd0fb9ff0e0eb1f0de788382302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r_DQ5HhwP8PYpfq-SrcVEA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由作者提供。</p></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d09d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">而现在，两个<strong class="ak">* ngrxLet</strong>&amp;<strong class="ak">ngrxPush</strong></h1><p id="6b88" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated"><code class="fe ls lt lu lv b">src/main.ts</code>:</p><pre class="kg kh ki kj gt pc lv pd pe aw pf bi"><span id="e707" class="on me iq lv b gy pg ph l pi pj">platformBrowserDynamic().bootstrapModule(AppModule,{ ngZone:'noop'})</span></pre><p id="7fd9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它没有区域也能工作！</p><p id="e079" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:在我写这篇文章的时候，这个包是一个实验性的包，还在开发中，所以它可能会有一些变化。您可能需要停用<code class="fe ls lt lu lv b"><a class="ae lr" href="https://angular.io/guide/aot-compiler" rel="noopener ugc nofollow" target="_blank">AOT</a></code>编译，它将适用于Angular 8 . x版本。此外，Angular/components行为会因视图引擎或Ivy的不同而略有不同。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oz pa l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者提供的截图。</p></figure><p id="ab83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nv">此时回购(</em><a class="ae lr" href="https://stackblitz.com/edit/ngrx-custom-reducers-todo-list" rel="noopener ugc nofollow" target="_blank"><em class="nv">stack blitz</em></a><em class="nv">on branch feature/ngrx _ components _ stack blitz或</em><a class="ae lr" href="https://github.com/ackuser/ngrx-custom-reducers-todo-list/tree/feature/ngrx_components" rel="noopener ugc nofollow" target="_blank"><em class="nv">GitHub</em></a><em class="nv">on branch feature/ngrx _ components)</em></p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="523c" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">结论</h1><p id="779b" class="pw-post-body-paragraph kv kw iq kx b ky mv jr la lb mw ju ld le mx lg lh li my lk ll lm mz lo lp lq ij bi translated">我希望你现在已经知道了基本知识和一些关键概念来理解"<em class="nv"> @ngrx/component。此外，它的重要性以及我们取消使用<code class="fe ls lt lu lv b">async</code>管道的原因，这大大减少了幕后操作。</em></p><p id="77f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，不管Angular是否使用zone，关注点的分离对于性能和改进执行时间都是非常重要的。如果我们在无区域模式下，能够分析和衡量性能提升了多少，那就太好了。尝试将您的项目与NGRX的未来保持一致！</p><p id="df0e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将很快讨论NGRX的其他有趣主题，敬请关注！！！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><p id="a5a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我鼓励你看看更多的阅读材料:</p><div class="na nb gp gr nc nd"><a href="https://medium.com/ngconf/a-first-look-at-ngrx-component-f7fcbf83669a" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">@ngrx/component的第一印象</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">先看看最新的NgRx库，它重新思考了角度变化检测和可观察处理…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="pt l no np nq nm nr kp nd"/></div></div></a></div><div class="na nb gp gr nc nd"><a href="https://christiankohler.net/reactive-angular-with-ngrx-component" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">有ngrx/分量的无功角度</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">角度变化检测依赖于Zone.js，它在大多数情况下工作良好，但很难调试，可能会导致…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">christiankohler.net</p></div></div><div class="nm l"><div class="pu l no np nq nm nr kp nd"/></div></div></a></div></div></div>    
</body>
</html>