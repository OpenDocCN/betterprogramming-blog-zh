<html>
<head>
<title>5 and a Half Techniques for Effectively Writing Unit Tests in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中有效编写单元测试的5.5技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-and-a-half-techniques-for-effectively-writing-unit-tests-in-go-1b87b94abd21?source=collection_archive---------1-----------------------#2021-08-13">https://betterprogramming.pub/5-and-a-half-techniques-for-effectively-writing-unit-tests-in-go-1b87b94abd21?source=collection_archive---------1-----------------------#2021-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="71ad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这些技术帮助我在两年的时间里在生产中没有任何错误</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9aff3a97a13db9c9424cd8bf86b7f2f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vuB9DiUyDj19dRep"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张家瑜</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="31e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试一直是我的事情——有点像爱好。曾经有一段时间我对它念念不忘。</p><p id="ea90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我所有的项目必须有至少90%的单元测试覆盖率。您可能会猜测对代码库进行重大更改需要多少时间。但是，另一方面，得到一个带有一些与业务逻辑相关的bug的报告是很少见的。</p><p id="10b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数情况下，我只有与其他(微)服务或数据库的集成问题相关的错误。此外，添加新的业务不变量也很容易。之前已经有涵盖所有病例的测试了。</p><p id="6eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是确保这些测试最终是绿色的。我甚至经常不检查完整的运行(微)服务——有绿色的新旧单元测试就足够了。</p><p id="142b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一次，在做一个私人项目时，我不得不编写单元测试来覆盖一些模块。可能里面有100多个不同的Go结构，谁知道有多少函数。我花了整整一个周末。</p><p id="1afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个星期天的深夜，在我睡觉前，我设了一个闹钟叫醒我，因为我第二天要出差。我几乎没有睡觉。当你做梦的时候，这是一种奇怪的睡眠方式，但是你不知何故意识到你自己和你的环境。</p><p id="26df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的大脑整晚都很活跃。整个晚上，我都在梦想为我的闹钟编写单元测试。猜猜在每个单元测试执行中发生了什么？闹钟一直在响。就这样，整整一夜。</p><p id="c044" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦，对了，我差点忘了说。两年来，我们在生产中没有任何错误。应用程序仍然获取所有数据。它每周一发送所有的电子邮件。我甚至不知道我的Gitlab密码。</p><h1 id="6cf6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们将涵盖的内容</h1><p id="2f64" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了节省阅读整篇文章的时间，您可以直接查看以下主题:</p><ol class=""><li id="1b0b" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">单元测试和模拟(一般情况下)</li><li id="aae2" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">生成模拟</li><li id="75ed" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">界面的局部模拟</li><li id="9cd3" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">功能模拟</li><li id="0b22" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">套件和断言</li><li id="df9d" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">好处1:模仿HTTP服务器</li><li id="24dd" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">额外收获2:模仿SQL数据库</li></ol><h1 id="0e5a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">单元测试和模拟(一般情况下)</h1><p id="edf0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">正如我们在<a class="ae ky" href="https://martinfowler.com/bliki/UnitTest.html" rel="noopener ugc nofollow" target="_blank">的文章</a>和<a class="ae ky" href="https://twitter.com/martinfowler" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a>中看到的，我们可以区分两种类型的单元测试:</p><ol class=""><li id="4e8a" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><em class="ng">社交单元测试</em>是我们测试一个依赖于其他对象的单元的测试。如果要测试<code class="fe nh ni nj nk b">UserController</code>，就用与数据库通信的<code class="fe nh ni nj nk b">UserRepository</code>来测试。</li><li id="4423" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><em class="ng">独立单元测试</em>是我们测试一个完全独立的单元的测试。在这里，您将测试<code class="fe nh ni nj nk b">UserController</code>，它与受控的、被模仿的<code class="fe nh ni nj nk b">UserRepository</code>交互，为此您可以提供它在没有数据库的情况下究竟如何运行。</li></ol><p id="ce69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个项目中使用这两种方法都是合理的，我总是使用这两种方法。</p><p id="f2d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我编写社交单元测试，过程很简单——使用我模块中已经使用的任何东西，一起测试逻辑。但是，当谈到围棋中的嘲讽时，这不是一个标准的过程。</p><p id="8fa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://golangbot.com/inheritance/" rel="noopener ugc nofollow" target="_blank"> Go不支持继承，支持合成</a>。这意味着一个结构不扩展第二个结构，而是包含它。因此，Go不支持结构层次上的多态性，而是使用<a class="ae ky" href="https://golangbot.com/polymorphism/" rel="noopener ugc nofollow" target="_blank">接口</a>。</p><p id="afa9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，一旦你的结构直接依赖于一个结构的实例，或者某个函数期望一个特定的结构作为参数，那么祝你好运模仿那个结构。</p><p id="bb02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码示例中，我们有一个带有<code class="fe nh ni nj nk b">UserDBRepository</code>和<code class="fe nh ni nj nk b">AdminController</code>的简单案例。<code class="fe nh ni nj nk b">AdminController</code>直接依赖于<code class="fe nh ni nj nk b">UserDBRepository</code>的实例，它代表负责与数据库“对话”的存储库的实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AdminController依赖于UserDbRepository结构的实例的情况</p></figure><p id="7de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想为<code class="fe nh ni nj nk b">AdminController</code>编写单元测试，看看它是否会创建正确的JSON响应，我们有两种可能性:</p><ol class=""><li id="13f0" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">提供一个<code class="fe nh ni nj nk b">UserDBRepository</code> <em class="ng"> </em>的新实例，以及一个到<code class="fe nh ni nj nk b">AdminController</code> <em class="ng"> </em>的数据库连接，希望它是你需要传递的唯一依赖项。</li><li id="2191" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">不要提供任何东西，一旦开始运行测试，就只期待一个零指针异常。</li></ol><p id="7c81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这种情况，并且能够正确地测试我们的单元，我们需要确保我们的代码遵守以下原则:</p><ol class=""><li id="077e" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated"><a class="ae ky" href="https://medium.com/javarevisited/oop-good-practices-coding-to-the-interface-baea84fd60d3" rel="noopener">编程到界面</a></li><li id="c1a9" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://stackify.com/dependency-inversion-principle/" rel="noopener ugc nofollow" target="_blank">依存倒置原则</a></li></ol><p id="7afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们应用了这两个原则，我们的重构代码就会得到如下所示的形状，其中实际的<code class="fe nh ni nj nk b">AdminController</code>依赖于接口<code class="fe nh ni nj nk b">UserRepository</code>，而不指定它是数据库的存储库还是其他。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">AdminController依赖于UserRepository接口实例的情况</p></figure><p id="fe39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，现在当我们有了一个起点，让我们看看我们如何能最有效地嘲笑。</p><h1 id="25e0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">生成模拟</h1><p id="1c3b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有许多用于生成模拟的库，如果你愿意，你也可以创建自己的生成器。我喜欢来自<a class="ae ky" href="https://github.com/vektra" rel="noopener ugc nofollow" target="_blank"> Vektra </a>的<a class="ae ky" href="https://github.com/vektra/mockery" rel="noopener ugc nofollow" target="_blank">嘲弄</a>包装。它提供了由来自<a class="ae ky" href="https://github.com/stretchr" rel="noopener ugc nofollow" target="_blank"> Stretchr，Inc </a>的<a class="ae ky" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">evidence</a>包支持的模拟，这已经是一个足够好的继续使用它的理由了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有AdminController的简单用户历史界面</p></figure><p id="c4bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用<code class="fe nh ni nj nk b">UserRepository</code><em class="ng"/><em class="ng"/><code class="fe nh ni nj nk b">AdminController</code>回到前面的例子。每当有人向<code class="fe nh ni nj nk b">/users</code>端点发送请求时，<code class="fe nh ni nj nk b">AdminController</code>期望<code class="fe nh ni nj nk b">UserRepository</code>接口通过它们的<code class="fe nh ni nj nk b">Lastname</code>来过滤<code class="fe nh ni nj nk b">Users</code>。</p><p id="a4a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格来说，<code class="fe nh ni nj nk b">AdminController</code>并不关心<code class="fe nh ni nj nk b">UserRepository</code>如何找到结果。根据它是否获得了<code class="fe nh ni nj nk b">Users</code>或<code class="fe nh ni nj nk b">Error</code>的切片，只需将适当的响应从Gin包附加到<code class="fe nh ni nj nk b">Context</code>即可。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主Go文件</p></figure><p id="33d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我使用了来自<a class="ae ky" href="https://github.com/gin-gonic" rel="noopener ugc nofollow" target="_blank"> Gin-Gonic </a>的<a class="ae ky" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin </a>包进行布线，但是我们想使用哪个包来布线并不重要。我们将首先初始化<code class="fe nh ni nj nk b">UserRepository</code>的实际实现，将其传递给<code class="fe nh ni nj nk b">AdminController</code>，并在运行我们的服务器之前定义端点。</p><p id="ee69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们的文件夹结构可能如下所示:</p><pre class="kj kk kl km gt nn nk no np aw nq bi"><span id="acd1" class="nr lw it nk b gy ns nt l nu nv">user-service<br/>| cmd<br/>  | main.go<br/>| pkg<br/>  | user<br/>    | user.go<br/>    | admin_controller.go<br/>    | admin_controller_test.go</span></pre><p id="d3a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在文件夹<code class="fe nh ni nj nk b">user</code>中，我们可以执行mock命令来生成mock对象。</p><pre class="kj kk kl km gt nn nk no np aw nq bi"><span id="6eda" class="nr lw it nk b gy ns nt l nu nv">$ mockery --all --case=underscore</span></pre><p id="5b56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它检查包中的所有接口(您可以进一步修改这个选项)，并创建一个新的文件夹<code class="fe nh ni nj nk b">mocks</code>，在其中放置所有生成的文件。</p><pre class="kj kk kl km gt nn nk no np aw nq bi"><span id="2cca" class="nr lw it nk b gy ns nt l nu nv">user-service<br/>| cmd<br/>  | main.go<br/>| pkg<br/>  | user <br/>    | mocks <br/>      | user_repository.go<br/>    | user.go<br/>    | admin_controller.go<br/>    | admin_controller_test.go</span></pre><p id="431e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成文件的内容如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带有模拟结构的生成文件示例</p></figure><p id="d3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在一个项目中工作时，我喜欢把所有的命令都写在项目中的某个地方。有时，它可以是一只<code class="fe nh ni nj nk b">Makefile</code>或一只<code class="fe nh ni nj nk b">bash script</code>。但是在这里，我们可以在<code class="fe nh ni nj nk b">user</code>文件夹中添加额外的<code class="fe nh ni nj nk b">generate.go</code>文件，并将以下代码放入其中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">generate.go文件的内容。</p></figure><pre class="kj kk kl km gt nn nk no np aw nq bi"><span id="c0b7" class="nr lw it nk b gy ns nt l nu nv">user-service<br/>| cmd<br/>  | main.go<br/>| pkg<br/>  | user <br/>    | mocks <br/>      | user_repository.go<br/>    | user.go<br/>    | admin_controller.go<br/>    | admin_controller_test.go<br/>    | generate.go</span></pre><p id="a524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件包含一个特殊的<a class="ae ky" href="https://blog.golang.org/generate" rel="noopener ugc nofollow" target="_blank">注释</a>，从<code class="fe nh ni nj nk b">//go:generate.</code>开始，它包含一个用于执行其后代码的标志，一旦您在项目根文件夹中运行下面的命令，它将生成所有文件:</p><pre class="kj kk kl km gt nn nk no np aw nq bi"><span id="6ef4" class="nr lw it nk b gy ns nt l nu nv">$ go generate ./...</span></pre><p id="d28f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这两种方法给出了相同的结果——生成一个带有模仿对象的文件。因此，编写单独的单元测试不再是一个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成模拟的单元测试示例</p></figure><h1 id="a212" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">界面的局部模拟</h1><p id="9361" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有时，不需要模拟接口中的所有方法。或者，这个包不属于我们，所以我们不能生成文件。在我们的库中创建和保存文件也是没有意义的。</p><p id="25d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，有时候，在我们需要的时候，接口可以有很多方法。对于这种情况，我们仍然可以使用一个带有<code class="fe nh ni nj nk b">UserRepository</code>的例子。<code class="fe nh ni nj nk b">AdminController</code>只使用存储库中的一个函数，称为<code class="fe nh ni nj nk b">FilterByLastname</code>。</p><p id="cb92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们不需要任何其他方法来测试<code class="fe nh ni nj nk b">AdminController</code>。为此，让我们提供一些名为<code class="fe nh ni nj nk b">MockedUserRepository</code>的结构，如下例所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">手动创建的模拟对象。</p></figure><p id="3193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nh ni nj nk b">MockedUserRepository</code>实现接口<code class="fe nh ni nj nk b">UserRepository</code>。在我们将<code class="fe nh ni nj nk b">UserRepository</code>接口嵌入<code class="fe nh ni nj nk b">MockedUserRepository</code>时，我们确保了这一点。</p><p id="6547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的模拟对象期望在它的<em class="ng">中包含一些<code class="fe nh ni nj nk b">UserRepository</code>接口的实例。</em>如果没有定义该实例，默认情况下，它将是<code class="fe nh ni nj nk b">nill</code>。除此之外，它还有一个字段，这是一种函数。</p><p id="9e3a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该功能与<code class="fe nh ni nj nk b">FilterByLastname</code>具有相同的签名。<code class="fe nh ni nj nk b">FilterByLastname</code>方法附加在被模仿的结构上，它只是代理一个对私有字段的调用。现在，如果我们以下面的方式重写我们的测试，它可能看起来更直观:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在单元测试中使用手动创建的模拟。</p></figure><p id="73dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们通过使用<a class="ae ky" href="https://github.com/aws/aws-sdk-go" rel="noopener ugc nofollow" target="_blank"> AWS SDK </a>来测试我们的代码与<a class="ae ky" href="https://aws.amazon.com/console/" rel="noopener ugc nofollow" target="_blank"> AWS </a>服务(如SQS)的集成时，这种技术可能是有益的。在这种情况下，我们的<code class="fe nh ni nj nk b">SQSReceiver</code>依赖于<code class="fe nh ni nj nk b">SQSAPI</code>接口，它有…嗯，很多功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的SQSReceiver示例。</p></figure><p id="721a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以使用相同的技术并提供我们自己的模拟结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用手动创建的模拟来模拟与SQS队列的通信。</p></figure><p id="106a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，我不测试负责与数据库或外部服务建立连接的基础设施对象。为此，我在<a class="ae ky" href="https://martinfowler.com/articles/practical-test-pyramid.html" rel="noopener ugc nofollow" target="_blank">测试金字塔</a>的更高层次上编写测试。不过，如果真的需要测试这样的代码，这种方法对我很有帮助。</p><h1 id="b2dc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">功能模拟</h1><p id="e40e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在核心Go代码或任何其他包中，有许多有用的函数。我们可以在代码中直接使用这些函数，就像下面的<code class="fe nh ni nj nk b">ConfigurationRepository</code>一样。</p><p id="48e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个结构负责读取<code class="fe nh ni nj nk b">config.yml</code>文件并返回应用程序中到处使用的配置。<code class="fe nh ni nj nk b">ConfigurationRepository</code>从core Go包<a class="ae ky" href="https://pkg.go.dev/io/ioutil" rel="noopener ugc nofollow" target="_blank"> IOutil </a>中调用方法<a class="ae ky" href="https://pkg.go.dev/io/ioutil#ReadFile" rel="noopener ugc nofollow" target="_blank"> ReadFile </a>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置存储库的示例</p></figure><p id="2745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在像这样的代码中，如果我们想要测试<code class="fe nh ni nj nk b">GetConfiguration</code>，每个测试执行都不可避免地依赖于<code class="fe nh ni nj nk b">config.yml</code>文件的存在。</p><p id="0232" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们再次依赖于技术细节，比如从文件中读取。当类似这样的事情发生时，我想为这段代码提供一个单元测试，过去我使用了两种变体。</p><h2 id="ed50" class="nr lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">变体1:简单类型别名</h2><p id="672a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">第一个变化是为我们想要模仿的方法类型提供一个<a class="ae ky" href="https://yourbasic.org/golang/type-alias/" rel="noopener ugc nofollow" target="_blank">类型别名</a>。新类型表示我们希望在代码中使用的函数签名。<code class="fe nh ni nj nk b">ConfigurationRepository</code>应该依赖于这个新类型<code class="fe nh ni nj nk b">FileReaderFunc</code>而不是我们想要模仿的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单类型别名。</p></figure><p id="f786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，在初始化我们的应用程序时，我们会在创建<code class="fe nh ni nj nk b">ConfigurationRepository</code>时将Go核心包中的实际方法作为参数传递:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">配置存储库的初始化。</p></figure><p id="405a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以编写一个单元测试，如下面的代码示例所示。在这里，我们定义了一个新的reader函数，它返回我们在每种情况下控制的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用简单类型别名的单元测试示例。</p></figure><h2 id="f530" class="nr lw it bd lx nw nx dn mb ny nz dp mf li oa ob mh lm oc od mj lq oe of ml og bi translated">变体2:接口的复杂类型别名</h2><p id="165f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">第二个变体使用了相同的思想，但是在<code class="fe nh ni nj nk b">ConfigurationRepository</code>中使用了一个作为依赖项的接口。它不依赖于函数类型，而是依赖于一个接口<code class="fe nh ni nj nk b">FileReader</code>，该接口的方法与我们想要模仿的方法<code class="fe nh ni nj nk b">ReadFile</code>具有相同的签名。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重构的ConfigurationRepository，所以它依赖于接口中的函数。</p></figure><p id="b59d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们应该再次添加同一个类型别名<code class="fe nh ni nj nk b">FileReaderFunc</code>，但是这一次我们应该为该类型附加一个函数。是的，我们需要在方法中添加一个方法——我无法表达我有多喜欢Go中的这一部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">新的类型别名和方法。</p></figure><p id="764c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这一点来看，<code class="fe nh ni nj nk b">FileReaderFunc</code>类型实现了<code class="fe nh ni nj nk b">FileReader</code>接口。它拥有的唯一方法是代理对该类型实例的调用，即原始方法。当我们想要初始化应用程序时，它只带来最小的变化:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主应用程序文件。</p></figure><p id="17b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且，它不会对单元测试带来任何改变:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">单元测试的例子。</p></figure><p id="6a22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我更喜欢第二种变化，因为我更倾向于接口和结构而不是独立的函数。但是，这两种解决方案都是好的。</p><h1 id="bf06" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">套件和断言</h1><p id="2d2a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我需要再次提到<a class="ae ky" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">作证</a>包的伟大之处。除了嘲讽，这个库还提供了对<a class="ae ky" href="https://www.testmonitor.com/blog/test-case-test-suite-test-run-whats-the-difference" rel="noopener ugc nofollow" target="_blank">套件</a>和<a class="ae ky" href="https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests" rel="noopener ugc nofollow" target="_blank">断言</a>的支持。</p><p id="b62b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当测试的目的是检查一个没有任何依赖关系(或者至少没有被模仿的依赖关系)的简单函数或u struct时，我就对简单的单元测试使用断言。我发现这对未来的代码读者了解测试用例的思想很有帮助，也更明确。</p><p id="ed41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我唯一一次使用pure Go原生代码进行测试是在我的库不依赖于其他包的时候，所以要保持它“干净”否则，如果没有这类软件包的帮助，要覆盖所有的检查就太累了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">断言的例子</p></figure><p id="ef86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在需要测试复杂结构时使用的套件，至少有一个模拟的依赖项。这允许我定义一个代码，它应该在整个套件启动之前、每次测试之前、每次测试之后等等被执行。</p><p id="6462" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个套件运行之前，在大多数情况下，我初始化变量，这些变量在整个过程中是静态的。</p><p id="8f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果<code class="fe nh ni nj nk b">Context</code>或<code class="fe nh ni nj nk b">Request</code>没有保存任何特定于测试用例的数据，我在套件启动之前定义它们。如果测试可以改变它们的状态，我会在每次测试前用所有模仿的对象和主结构初始化它们。</p><p id="a425" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，在每次测试之后，有时我应该编写代码来关闭一些通道，销毁一些变量，或者断言发送到struct函数的调用次数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">套件示例</p></figure><h1 id="abc6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">好处1:模仿HTTP服务器</h1><p id="ffbc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">说到模仿HTTP服务器，我不认为这属于单元测试。尽管如此，有时有人可能有一个依赖于一些HTTP请求的代码结构，本节给出了在这些情况下的一些想法。</p><p id="9e5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们有一些<code class="fe nh ni nj nk b">UserAPIRepository</code>，它通过与外部API而不是数据库通信来发送和获取数据。这个结构可能看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UserAPIRepository的示例</p></figure><p id="0601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自然，我们也可以用模仿函数来处理这个问题，但是让我们继续玩这个游戏。为了对<code class="fe nh ni nj nk b">UserAPIRepository</code>进行单元测试，我们可以使用core Go <a class="ae ky" href="https://pkg.go.dev/net/http/httptest" rel="noopener ugc nofollow" target="_blank"> HTTPtest </a>包中的<a class="ae ky" href="https://pkg.go.dev/net/http/httptest#Server" rel="noopener ugc nofollow" target="_blank">服务器</a>的一个实例。</p><p id="0f5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个包为我们提供了一个简单的小型服务器，在本地的一些端口上工作，我们可以快速适应我们的测试用例并向它发送请求:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用模拟的HTTP服务器进行单元测试</p></figure><h1 id="9b69" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">额外收获2:模仿SQL数据库</h1><p id="b293" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">同样，与HTTP请求一样，我并不特别渴望编写测试SQL查询的单元测试。我总是问自己，如果我测试一个库或者一个模仿工具。</p><p id="f4fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，当我想检查一些SQL查询时，它可能被包装在一些结构中，就像这里的<code class="fe nh ni nj nk b">UserDBRepository</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UserDBRepository示例。</p></figure><p id="e22e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我决定为这类存储库编写单元测试时，我喜欢使用来自<a class="ae ky" href="https://github.com/DATA-DOG" rel="noopener ugc nofollow" target="_blank">数据狗</a>的包<a class="ae ky" href="https://github.com/DATA-DOG/go-sqlmock" rel="noopener ugc nofollow" target="_blank"> Sqlmock </a>。它足够简单并且有很好的文档:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用SQLmock进行单元测试</p></figure><p id="158c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当模拟实际的SQL查询太累人时，另一种方法可以是用一个小的SQLite文件包含测试数据。它应该与我们的常规SQL数据库具有相同的表结构。</p><p id="a34e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这也不是一个理想的解决方案，因为我们在不同的数据库引擎上测试我们的查询，我们可能应该依靠<a class="ae ky" href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping" rel="noopener ugc nofollow" target="_blank"> ORM </a>来避免双重集成。</p><p id="0f02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我创建了一个临时文件，并在每次测试执行之前将数据从SQLite文件复制到其中。它比较慢，但是像这样，我不能破坏我的测试数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">连接到临时SQLite文件</p></figure><p id="3b81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，单元测试现在看起来简单多了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">UserDBRepository的单元测试</p></figure></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="3433" class="lv lw it bd lx ly oo ma mb mc op me mf jz oq ka mh kc or kd mj kf os kg ml mm bi translated">结论</h1><p id="b481" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">用Go编写单元测试仍然比用其他语言更具挑战性，至少对我来说是这样。它需要准备代码，以便能够支持测试策略。</p><p id="6f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在某种程度上是一个令人愉快的部分——它比任何其他语言都更有助于我在编写代码时形成我的架构方法。它永远不会枯燥，而且它给人一种持续的快乐感，即使是在一千次单元测试之后。</p><p id="8f18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你对Go中的单元测试和嘲讽有什么体验？</p></div></div>    
</body>
</html>