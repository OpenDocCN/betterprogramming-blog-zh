<html>
<head>
<title>Swift Protocols With Associated Types and Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有相关类型和类属的Swift协议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-protocols-with-associated-types-and-generics-373b2927baed?source=collection_archive---------6-----------------------#2020-02-06">https://betterprogramming.pub/swift-protocols-with-associated-types-and-generics-373b2927baed?source=collection_archive---------6-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6162" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">高级协议</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f0e30814917730f86a0d7b0b2f75d31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Lasyvm6YzsRp3_lO"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Chris Ried 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="776d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们来看看臭名昭著的<code class="fe ls lt lu lv b">Protocol can only be used as a generic constraint because it has Self or associated type requirements</code>错误信息。</p><p id="4d88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swift文档将协议描述为“适合特定任务或功能的方法、属性和其他要求的蓝图。”使用协议来定义我们代码的不同部分的责任，使得它更容易阅读，并且有助于维护一个干净的架构。</p><p id="b060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管Swift非常适合面向对象编程，但它是作为面向协议的语言而设计的。正如苹果公司的Dave Abrahams在2015年WWDC上所说，“我们Swift有一句谚语。不要从一门课开始。从一个协议开始。”</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="037b" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">行动中的协议</h1><p id="52f4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">让我们通过为一个简单的在线钱包应用程序创建一些基本逻辑来看看协议是如何工作的。首先，我们肯定需要从服务器获取一些数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b670" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取数据后，我们将把它解析成某个对象。因为我们想保留我们的选项，所以使用关联类型是个好主意。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2f11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们从协议开始。现在，让我们提供具体的实现。由于我们正在构建一个在线钱包应用程序，我们将需要一个<code class="fe ls lt lu lv b">User</code>、<code class="fe ls lt lu lv b">Wallet</code>，以及它们相应的提取器和解析器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="bb25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下唯一要实现的就是这个逻辑的消费者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="21f0" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">问题是</h1><p id="fcb8" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如您所见，<code class="fe ls lt lu lv b">UserFetcher</code>和<code class="fe ls lt lu lv b">WalletFetcher</code>的实现非常相似，因此重构代码并使用泛型是有意义的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="bc00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样声明我们的<code class="fe ls lt lu lv b">dataParser</code>会导致一个错误:<code class="fe ls lt lu lv b">Protocol 'DataParsing' can only be used as a generic constraint because it has Self or associated type requirements</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试图通过专门化<code class="fe ls lt lu lv b">dataParser</code>来修复我们的错误会给我们带来另一个错误:<code class="fe ls lt lu lv b">Cannot specialize non-generic type 'DataParsing'</code>。</p><p id="a695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出现这个问题是因为编译器需要在编译时知道具体的类型。大多数Swift开发人员在其职业生涯的某个阶段都会遇到这种情况，如果您仍在阅读这篇文章，那么您很有可能就是其中之一。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="9fd2" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">解决方案</h1><p id="55f3" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">解决这个问题的常见方法是使用类型擦除。顾名思义，我们通过提供具有具体实现的包装器来消除类型信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="581b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以使用我们的<code class="fe ls lt lu lv b">GenericDataFetcher</code>并从<code class="fe ls lt lu lv b">UserFetcher</code>和<code class="fe ls lt lu lv b">WalletFetcher</code>中删除重复的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8e42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">唯一需要更新的是<code class="fe ls lt lu lv b">DataManager</code>代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="26ed" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">最后的想法</h1><p id="812f" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我描述的解决方案在Swift标准库中的多个地方使用。然而，它依赖于分配在堆上的闭包。因此，我建议你谨慎使用。因为它也增加了代码的复杂性，所以我尽量避免它，并且更喜欢以一种不需要这种变通方法的方式来重构代码。我们用来演示这个问题的例子肯定可以进行不同的重构，但这是另一篇文章的主题。</p><p id="50fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，如果您有任何意见或问题，请告诉我！</p></div></div>    
</body>
</html>