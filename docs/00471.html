<html>
<head>
<title>7 JavaScript Patterns Part 2: The Spread Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">7 JavaScript模式第2部分:扩展语法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/js-patterns-part-2-the-spread-syntax-9f7e66038c86?source=collection_archive---------4-----------------------#2019-05-27">https://betterprogramming.pub/js-patterns-part-2-the-spread-syntax-9f7e66038c86?source=collection_archive---------4-----------------------#2019-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="81f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是包含所有初级开发人员都应该知道的JavaScript模式的系列文章的第二篇</h2></div><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/ffc50f772986e74959609bc75f12350d.png" data-original-src="https://miro.medium.com/v2/format:webp/1*dkobBMlN8xVswrMjOks0fg.png"/></div></figure><p id="4aa1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm">* * * ES6及更高版本支持，浏览器支持</em> <a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> <em class="lm">文档</em> </a> <em class="lm"> *** </em></p><p id="fcbe" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">今天的文章涵盖了可能是最流行的ES6特性，spread语法。由于它的受欢迎程度，它已经被盖死了。所以我不打算深入细节，而是深入讨论不变性和继承。</p><h1 id="ead6" class="lo lp it bd lq lr ls lt lu lv lw lx ly jz lz ka ma kc mb kd mc kf md kg me mf bi translated">传播算子是什么样子的？</h1><p id="d3a4" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">顾名思义，spread操作符扩展它嵌入的对象的所有属性和值。如果你的对象是一个数组，它会分散它的元素。你可以看到下面的例子:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ml mm l"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="94c4" class="lo lp it bd lq lr mu lt lu lv mv lx ly jz mw ka ma kc mx kd mc kf my kg me mf bi translated">怎么解码？</h1><p id="7de7" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">你可能已经注意到了，你不能在任何地方传播任何东西。它只在用逗号分隔项目时有效。如果您尝试在其他地方做，可能会出现这种情况:</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="af7b" class="ne lp it na b gy nf ng l nh ni">var arr1 = [1, 2, 3]<br/>...arr1</span><span id="9f4a" class="ne lp it na b gy nj ng l nh ni">// Expects: Uncaught SyntaxError: Unexpected token ...</span></pre><p id="8110" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">扩展数组</strong>在几乎任何支持逗号的地方都是允许的。例如，在对象文字、数组文字和参数内部。你可以这样解码:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e94f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu">扩展对象</strong>只能在对象文字中使用，因为数组文字和参数不支持它们内部的属性名。查看下面的示例:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a9e5" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通过在文字中散布对象或数组，实际上是从散布属性中创建新的对象或数组。这就是我们所说的制作<strong class="ks iu">浅拷贝</strong>(稍后会有更多内容……)。最重要的是，当你用spread操作符创建一个对象的浅层副本时，你可以像上面的例子那样添加属性。我们已经将<em class="lm"> foo </em>属性添加到<em class="lm"> obj2 </em>中。而且，通过简单地覆盖它们来修改由spread对象给出的属性，如下例所示。</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="4bba" class="ne lp it na b gy nf ng l nh ni">console.log(obj2)<br/>// expects: {0: 1, 1: 2, 2: 3, foo: "bar"}</span><span id="6b16" class="ne lp it na b gy nj ng l nh ni">obj3 = {...obj2, foo: "lmao"}<br/>// expects: {0: 1, 1: 2, 2: 3, foo: "lmao"}</span></pre><h1 id="6d6a" class="lo lp it bd lq lr ls lt lu lv lw lx ly jz lz ka ma kc mb kd mc kf md kg me mf bi translated">有什么好处？</h1><blockquote class="nk nl nm"><p id="f1a2" class="kq kr lm ks b kt ku ju kv kw kx jx ky nn la lb lc no le lf lg np li lj lk ll im bi translated">旁注:我们将再次讨论按值/按引用。如果你想成为一名优秀的JS开发者，这是非常重要的。这是一些文档。</p></blockquote><h2 id="a887" class="ne lp it bd lq nq nr dn lu ns nt dp ly kz nu nv ma ld nw nx mc lh ny nz me oa bi translated">保持你的代码干燥</h2><p id="ff5e" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">如果你需要在一个参数中使用一个数组的所有元素，你可以只引用它一次。像这样:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="33f8" class="ne lp it bd lq nq nr dn lu ns nt dp ly kz nu nv ma ld nw nx mc lh ny nz me oa bi translated">不变</h2><p id="ff2a" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">不变性是一个编程原则，它认为一个对象永远不应该被添加属性修改。要更新一个对象，必须从原始对象创建一个新对象，并进行预期的更改。<a class="ae ln" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">这里有些文档</a>。不变性是区块链科技的关键概念之一，也是现代前端商店经理(如<a class="ae ln" href="https://vuex.vuejs.org" rel="noopener ugc nofollow" target="_blank"> Vuex </a>和Redux)非常重要的一部分。</p><p id="20f7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">JS传统上处理得很差。一方面<strong class="ks iu">，</strong>因为通过引用将对象分配给变量或属性是JavaScript的事情，这意味着JS不会复制一个它自己已经在内存中的对象，而是在任何可能需要这个对象的地方引用它，所以它可以在内存中只拥有一次。另一方面，在ES6之前，没有直观或一致的方法来实现不变性。</p><p id="79fb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">多亏了spread语法，它变得更好了。您可以复制对象，向其添加属性，并轻松覆盖现有属性。即使使用我们直观和一致的方法来实现不变性，JS仍然不是它的理想选择，因为spread语法只帮助创建对象的浅层副本(很快会有更多的介绍)。</p><p id="1c03" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我打赌你在想，<em class="lm">“好吧，这很好，但是这有什么用呢？”如果你曾经在React项目中使用过Redux，你可能会用到不变性。这就是reducers的全部工作:<strong class="ks iu">处理存储的不变性。</strong>对于reducers，我们经常使用spread语法来更新先前状态的浅层副本。阅读下面示例中的注释，看看发生了什么:</em></p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h2 id="7f76" class="ne lp it bd lq nq nr dn lu ns nt dp ly kz nu nv ma ld nw nx mc lh ny nz me oa bi translated">仿真陈述和观点</h2><p id="854f" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">如果你在Vue中使用了Vuex，setters的工作就是在幕后为你处理不变性。所以，如果你对React + Redux需要的不变性技巧不太适应，我建议你在Vue + Vuex中开始你的项目。它会帮你省去一大堆挫折。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="afa0" class="lo lp it bd lq lr mu lt lu lv mv lx ly jz mw ka ma kc mx kd mc kf my kg me mf bi translated">有什么你应该知道的怪癖吗？</h1><p id="c4e7" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">我能想到的只有两个:肤浅的复制和缺乏继承。</p><h2 id="3ec9" class="ne lp it bd lq nq nr dn lu ns nt dp ly kz nu nv ma ld nw nx mc lh ny nz me oa bi translated">浅册(终于！)</h2><p id="8568" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated"><strong class="ks iu"><em class="lm">TLDR；</em> </strong> <em class="lm"> <br/>注意嵌套对象，当你使用spread语法时它们保持相同的引用。</em></p><p id="333c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你在想，<em class="lm">“这又是关于价值和参考的，对吗？”我为你感到骄傲。你终于接受了你的信仰。在JS中，在某种程度上，它总是关于价值和参考。</em></p><p id="f3ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">进行浅层复制意味着您只是简单地复制值，还复制对对象的引用。换句话说，如果您的属性是对特定对象的引用，则该属性的副本将指向完全相同的对象。让我给你一个例子，它可能会导致错误:</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="538e" class="ne lp it na b gy nf ng l nh ni">var life_form1 = {kind: "human"}<br/>var person1 = {name: "Patrick Cyiza", life_form: life_form1}</span><span id="bcec" class="ne lp it na b gy nj ng l nh ni">console.log(person1)<br/>// expects {name: "Patrick Cyiza", life_form:{kind: "human"}}</span><span id="981b" class="ne lp it na b gy nj ng l nh ni">var dog1 = {...person1, name: "Rex"}<br/>console.log(dog1)<br/>// expects {name: "Rex", life_form:{kind: "human"}}</span><span id="6c82" class="ne lp it na b gy nj ng l nh ni">// well, Rex is not a human, he is a dog, lets change that<br/>dog1.life_form.kind = "dog"</span></pre><p id="1c41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你认为<strong class="ks iu"><em class="lm">person 1 . life _ form . kind</em></strong>现在的价值是多少？好吧，既然引用是从<strong class="ks iu"> <em class="lm"> person1 </em> </strong>复制到<strong class="ks iu"> dog1 </strong>的，那么它们的<strong class="ks iu"> <em class="lm"> life_form </em> </strong>属性引用的是同一个对象:从第一行开始的<strong class="ks iu"><em class="lm">life _ form 1</em></strong><em class="lm"/>变量。如果我们修改<strong class="ks iu"> <em class="lm"> dog1.life_form.kind，</em> </strong> <em class="lm"> </em>我们实际上改变了它的引用，影响了它的所有裁判。所以现在<strong class="ks iu"><em class="lm">person 1 . life _ form . kind</em></strong>就是<strong class="ks iu"><em class="lm"/></strong><em class="lm">。</em></p><p id="ee83" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你想避免这种情况，你应该使用<strong class="ks iu">深度复制模式</strong>、<strong class="ks iu">、</strong>，比如<strong class="ks iu"> JSON.parse </strong>和<strong class="ks iu"> JSON。Stringify </strong>，而不是spread语法。</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="cc41" class="ne lp it na b gy nf ng l nh ni">Obj1_copy = JSON.parse(JSON.stringify(Obj1))</span></pre><p id="a837" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae ln" href="https://medium.freecodecamp.org/copying-stuff-in-javascript-how-to-differentiate-between-deep-and-shallow-copies-b6d8c1ef09cd" rel="noopener ugc nofollow" target="_blank">更多详情请点击此处</a></p><h2 id="531d" class="ne lp it bd lq nq nr dn lu ns nt dp ly kz nu nv ma ld nw nx mc lh ny nz me oa bi translated">继承，或缺乏继承</h2><p id="b5a3" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated"><strong class="ks iu"><em class="lm">TLDR；</em> </strong> <em class="lm"> <br/>用spread语法复制一个对象只是复制该对象直接拥有的属性。继承的属性不会被复制，被复制对象的原型也不会被复制。</em></p><p id="35e9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你可能听说过ES6的课程。让我直截了当地告诉你，这些课程是不真实的。正如<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>所说，它是“【JavaScript现有的基于原型的继承之上的语法糖衣。”换句话说，这只是一个为了适应继承系统是经典的其他语言的开发者而添加的特性。<a class="ae ln" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" rel="noopener">更多关于古典的传承在这里。</a></p><p id="3564" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">实际上，JavaScript中没有现成的类，因为在JS <strong class="ks iu">中，所有不是原语的东西都是对象。</strong>是的！甚至数组和函数。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="ab gu cl kn"><img src="../Images/560c13ab9bba58cac689ce0a960fdfd9.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8LSVYpSvi0K1SZ7A24i2lw.jpeg"/></div></figure><p id="09ee" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就像我们之前说的，JS有一个<a class="ae ln" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance" rel="noopener ugc nofollow" target="_blank">基于原型的继承系统</a>。这只是意味着，既然一切都是对象，对象只是简单地相互继承。</p><p id="2d02" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有几种方法可以做到这一点，但由于这篇文章已经够长了，我们将只探讨一个简单的例子:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8a5b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如您所见，我没有显式地将<strong class="ks iu"><em class="lm">wheel _ count</em></strong><em class="lm"/>属性或<strong class="ks iu"> <em class="lm"> rapAboutIt </em> </strong>方法赋给<strong class="ks iu"> <em class="lm"> my_car </em> </strong>对象。既然<strong class="ks iu"> <em class="lm"> my_car </em> </strong>的原型是<strong class="ks iu"> <em class="lm"> Car </em> </strong>的对象，而<strong class="ks iu"> <em class="lm"> Car </em> </strong>具有那些属性，<strong class="ks iu"> <em class="lm"> my_car </em> </strong>就可以间接访问那些。换句话说，它继承了它们。</p><p id="920b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><em class="lm"> " </em>为什么这与扩展语法相关？"因为这不相关。说真的！我的意思是，spread语法不关心spread对象的原型。因此，它也不关心继承的属性。它只关心直接拥有的财产。让我们用一个例子来分解它:</p><p id="43e1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你会<strong class="ks iu"><em class="lm">console . log(my _ car)</em></strong>你会有下面的结果:</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="bcbc" class="ne lp it na b gy nf ng l nh ni">{model: "Civic Type R", brand: {name: "Honda", fonded: 1948}}</span></pre><p id="b39b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">那些是<strong class="ks iu">直接拥有的属性</strong>，但是我仍然可以访问<strong class="ks iu"> <em class="lm"> wheel_count </em> </strong>，因为他从<strong class="ks iu"> <em class="lm"> Car继承了它们。</em> </strong>照这样，你可以这样做:</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="e2a0" class="ne lp it na b gy nf ng l nh ni">my_car.wheel_count<br/>// expects: 4</span></pre><p id="c01e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是如果我将复制的<strong class="ks iu"> <em class="lm"> my_car </em> </strong>对象的展开语法如下:</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="5d2d" class="ne lp it na b gy nf ng l nh ni">my_other_car = {...my_car, model: "S200"}<br/>// expects: {model: "S200", brand: {name: "Honda", fonded: 1948}}</span></pre><p id="0c03" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><strong class="ks iu"> <em class="lm"> my_other_car </em> </strong>只能访问车型和品牌属性。不是遗传的，因为它不在乎。</p><pre class="ki kj kk kl gt mz na nb nc aw nd bi"><span id="b93b" class="ne lp it na b gy nf ng l nh ni">my_other_car.wheel_count<br/>// expects: undefined</span><span id="f92b" class="ne lp it na b gy nj ng l nh ni">my_other_car.rapAboutYourCar()<br/>// expects: TypeError: rapAboutYourCar is not a function</span></pre><p id="228a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所有那些深入的解释都是为了说一件事，而且只有一件事。如果你遇到需要复制一个对象并保持它的原型<strong class="ks iu">的时候，SPREAD语法是不够的！</strong></p><p id="b70a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">没有明显或常规的方法来克隆从其原型继承的对象。要实现这一点，您必须创建一个自定义函数，如下所示:</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="bc09" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一个进行浅层复制，第二个进行深层复制。如果需要，不要犹豫使用这个代码。如果你遇到任何问题，请在下面的评论中告诉我。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="e226" class="lo lp it bd lq lr mu lt lu lv mv lx ly jz mw ka ma kc mx kd mc kf my kg me mf bi translated">我们到此为止</h1><p id="8150" class="pw-post-body-paragraph kq kr it ks b kt mg ju kv kw mh jx ky kz mi lb lc ld mj lf lg lh mk lj lk ll im bi translated">下一个系列:<a class="ae ln" href="https://medium.com/@patick.cyiza/7-js-pattern-part-3-the-bracket-notation-f571c2548c0a" rel="noopener">括号符号</a></p><p id="9ecd" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae ln" href="https://medium.com/@patick.cyiza/7-js-patterns-junior-developers-should-know-well-1a0ad075338f" rel="noopener">点击此处查看完整系列</a></p></div></div>    
</body>
</html>