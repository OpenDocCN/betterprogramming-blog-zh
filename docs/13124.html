<html>
<head>
<title>Procedural Map Generation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的程序化地图生成</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/procedural-map-generation-in-python-174cd28daf24?source=collection_archive---------7-----------------------#2022-07-31">https://betterprogramming.pub/procedural-map-generation-in-python-174cd28daf24?source=collection_archive---------7-----------------------#2022-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="eaf3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们用细胞自动机创建一个只有几行代码的简单地图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/196001c6aaaa9b81b8e881d773d84e3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-trA8-rCj0xloF3Z"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@drwmrk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">安德鲁·斯图特斯曼</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d5be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://en.wikipedia.org/wiki/Computing" rel="noopener ugc nofollow" target="_blank">计算</a>中，程序生成通过算法<a class="ae kv" href="https://en.wikipedia.org/wiki/Algorithm" rel="noopener ugc nofollow" target="_blank">而非手动方式创建数据</a>，通常通过人工生成的资产和算法与计算机生成的随机性和处理能力相结合。</p><p id="468e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用细胞自动机，用几行代码创建一个简单的地图。这个自动机的规则是，如果一个单元格周围有四面以上的墙，它将创建一面墙。否则，它将生成一个地板。在我们的例子中，墙和地板的唯一区别是颜色:墙是黑色的，地板是白色的。</p><p id="373a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从导入所需的库和创建颜色常量开始。</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="7955" class="lx ly iq lt b be lz ma l mb mc">import numpy as np<br/>import pygame<br/>import time<br/># Set colors <br/>WALL_COLOR = (50, 50, 50)<br/>GRID_COLOR = (0, 0, 0)<br/>FLOOR_COLOR = (255, 255, 255)<br/>FLOOR_NEXT_COL = (0, 0, 255)</span></pre><p id="f6cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要定义<code class="fe md me mf lt b">update</code>函数，它将计算地板或墙壁周围的单元格数量，并根据前面解释的规则决定应该创建哪个资产。</p><p id="66e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们初始化一个临时的零矩阵，它将存储单元格在下一次迭代中的值，然后开始一个for循环，对每个单元格求和，计算其周围九个单元格的值。然后我们应用规则。我们将<code class="fe md me mf lt b">FLOOR_NEXT_COL</code>颜色分配给下一轮将被转化为墙壁的细胞。</p><p id="2173" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用pygame来绘制单元格，最后，我们将边界设置为墙壁。否则，在几次迭代中，地图将退化为只有楼层。</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="9aac" class="lx ly iq lt b be lz ma l mb mc">def update(screen, cells, size, with_progress=False):<br/>    # Create temporary matrix of zeros<br/>    temp = np.zeros((cells.shape[0], cells.shape[1]))<br/>    <br/>    for row, col in np.ndindex(cells.shape):<br/>        walls = np.sum(cells[row - 1:row + 2, col-1:col+2]) -   cells[row, col]      <br/>        color = FLOOR_COLOR if cells[row, col] == 0 else WALL_COLOR<br/>        <br/>        #Apply rules (if more than 4 walls create a wall, else a floor)<br/>        if walls &gt; 4:<br/>            temp[row, col] = 1<br/>            if with_progress:<br/>                color = WALL_COLOR  <br/>        else:<br/>            if cells[row, col] == 1:<br/>                if with_progress:<br/>                    color = FLOOR_NEXT_COL<br/>        <br/>        # Draw rectangles, using as backgorund the screen value.<br/>        pygame.draw.rect(screen, color, (col * size, row * size, size - 1, size - 1))   <br/>    <br/>    # Set borders to walls    <br/>    temp[0:60, 0] = 1<br/>    temp[0, 0:80] = 1<br/>    temp[0:60, 79] = 1<br/>    temp[59, 0:80] = 1  <br/>        <br/>    return temp</span></pre><p id="c288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以定义<code class="fe md me mf lt b">main</code>函数，如下所示:</p><pre class="kg kh ki kj gt ls lt lu bn lv lw bi"><span id="5240" class="lx ly iq lt b be lz ma l mb mc">def main():    <br/>    #Initialize pygame<br/>    pygame.init()<br/>    # Set size of cells<br/>    size=10<br/>    # Set size of screen<br/>    WIDTH = 800<br/>    HEIGHT = 600<br/>    # Set dimension of cells and their initial configuration<br/>    cells = np.random.choice(2, size=(60, 80), p=[0.38, 0.62])<br/>    cells[0:60, 0] = 1<br/>    cells[0, 0:80] = 1<br/>    cells[0:60, 79] = 1<br/>    cells[59, 0:80] = 1<br/>    <br/>    #Init surface/screen<br/>    screen = pygame.display.set_mode((WIDTH, HEIGHT))<br/>        <br/>    # Fill the screen with the grid<br/>    screen.fill(GRID_COLOR)<br/>    <br/>    update(screen, cells, size)<br/>    <br/>    #Update the full screen<br/>    pygame.display.flip()<br/>    #Update only portions of the screen<br/>    pygame.display.update()<br/>    <br/>    # Initialize running as false, so it won't immediately start the game<br/>    running = False<br/>    # Create infinite while loop to listen to keys <br/>    while True:<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                pygame.quit()<br/>            # If space key is pressed, change running in true/flase<br/>            elif event.type == pygame.KEYDOWN:<br/>                if event.key == pygame.K_SPACE:<br/>                    running = not running<br/>                    update(screen, cells, size)<br/>                    pygame.display.update()                    <br/>    <br/>        if running:<br/>            cells = update(screen, cells, size, with_progress=True)<br/>            pygame.display.update()<br/>        time.sleep(2)<br/><br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="d8df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们初始化pygame，设置单元格的大小和屏幕大小，然后是单元格的初始配置。这部分很重要。单元格被随机设置为墙壁或地板，但我们需要墙壁多于地板来创建平滑的地图，因此我们使用<code class="fe md me mf lt b">numpy random.choice</code>函数将墙壁的概率设置为62%，将地板的概率设置为38%。然后，我们必须将边界设置为墙壁，以避免算法退化。</p><p id="d4c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们只需要使用标准的pygame函数来更新和显示游戏。如果希望以不同的速度创建地图，可以更改睡眠时间。</p><p id="2d59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们启动代码。您可以使用空格键启动和停止自动机。</p><p id="47ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想要一个平滑均匀的贴图，你应该等待更多的迭代。否则，如果您喜欢参差不齐、支离破碎的地图，只需几步就足够了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/caa703caa5f337fc05c88819924253e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAg1JPOyOnypdMU7e56Zrg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure></div></div>    
</body>
</html>