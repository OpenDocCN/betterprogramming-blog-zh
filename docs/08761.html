<html>
<head>
<title>What’s New in SwiftUI 3.0?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI 3.0有什么新功能？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/whats-new-in-swiftui3-ios15-fa0e0d62235b?source=collection_archive---------0-----------------------#2021-06-09">https://betterprogramming.pub/whats-new-in-swiftui3-ios15-fa0e0d62235b?source=collection_archive---------0-----------------------#2021-06-09</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="35f7" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">降价支持、新的按钮样式、可定制的列表等等</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/db6c08b80e2aa4c5b2ca8dbd76a626df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qAWa-_-l86F7sW7j"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@fred_20?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Frédéricke Boies </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="d79b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI是苹果的声明式UI框架。在2021年WWDC奥运会上，它再次迎来了令人兴奋的新增强功能和特性，以及一些对我们有益的反对意见。</p><p id="7654" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI 3.0应该可以在iOS 15，iPadOS 15，macOS 12，watchOS 12上使用。</p><p id="0d07" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我们开始之前，值得注意的是,<code class="fe lw lx ly lz b">Info.plist</code>文件在Xcode 13项目结构中不再默认可见。相反，您必须从项目导航器选项卡中访问它。</p><p id="3dbf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在接下来的几个部分中，我们将看看iOS 15的SwiftUI的新功能(尽管其中大多数也将以某种形式在其他平台上工作)。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="f5ec" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">降价支持和新的AttributedString API</h1><p id="14eb" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">Markdown是一种用于编写格式化文本的通用语言。你可能在GitHub Readme文档中看到过很多。</p><p id="79a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从iOS 15开始，苹果将对<code class="fe lw lx ly lz b">Foundation</code>框架和SwiftUI提供Markdown支持。所以，你可以在SwiftUI <code class="fe lw lx ly lz b">Text</code>中用Markdown语法添加字符串，如下所示:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="07df" class="ni mi iu lz b gz nj nk l nl nm">Text("**Connect** on [Twitter](url_here)!")</span></pre><p id="3bd8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是一个正在运行的应用程序:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nn"><img src="../Images/b7c439c8e6f428075786cb9bd79bfb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9uwD5eGhcp6yy5U7vpulFg.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">作者截屏— SwiftUI文本降价</p></figure><p id="3a72" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想在上面的字符串中自定义一系列字符，SwiftUI有一个全新的<code class="fe lw lx ly lz b">AttributeString</code> API，UIKit有一个增强的<code class="fe lw lx ly lz b">NSAttributedString</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="cefe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以在SwiftUI文本中传递上面的<code class="fe lw lx ly lz b">AttributeString</code>，或者使用新的<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/foundation/attributescopes" rel="noopener ugc nofollow" target="_blank">AttributeScope</a></code>和<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/foundation/attributescopes/swiftuiattributes" rel="noopener ugc nofollow" target="_blank">SwiftUIAttributes</a></code>对其进行定制。</p><p id="ec96" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">查看<a class="nq nr ep" href="https://medium.com/u/3968fe272788?source=post_page-----fa0e0d62235b--------------------------------" rel="noopener" target="_blank">郑</a>关于如何在SwiftUI 中增加<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/ios-15-attributed-strings-in-swiftui-markdown-271204bec5c1">属性字符串的文章。</a></p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="0786" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">新按钮样式</h1><p id="e5ee" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">SwiftUI按钮现在变得更加强大了。我们有了新的角色和样式修改器。</p><p id="f36b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">ButtonRole</code>让您描述按钮的种类。它接受:</p><ul class=""><li id="3ba0" class="ns nt iu lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">cancel</code></li><li id="409d" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">destructive</code></li><li id="eff5" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">none</code></li><li id="97fc" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">some()</code>发布者。</li></ul><p id="d079" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">类似地，我们现在能够设计SwiftUI按钮的样式。通过使用<code class="fe lw lx ly lz b">buttonStyle</code>视图修改器，你可以应用<code class="fe lw lx ly lz b">BorderedButtonStyle</code>、<code class="fe lw lx ly lz b">BorderlessButtonStyle</code>、<code class="fe lw lx ly lz b">PlainButtonStyle</code>或<code class="fe lw lx ly lz b">DefaultButtonStyle</code>。</p><p id="f3ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="og">注意:这些样式也可以用它们的枚举对应物替换。</em></p><p id="84ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于<code class="fe lw lx ly lz b">BorderedButtons</code>，有一个新的<a class="ae kz" href="https://developer.apple.com/documentation/swiftui/borderedbuttonstyle/bordershape?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">边框形状</a>来描述你是否想要它作为<code class="fe lw lx ly lz b">capsule</code>、<code class="fe lw lx ly lz b">roundedRectangle</code>或<code class="fe lw lx ly lz b">automatic</code>。</p><p id="6cde" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面快速浏览一下iOS 15中可以应用于SwiftUI按钮的不同样式和角色类型:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oh"><img src="../Images/69631293f2f4000889a34bf9c735bc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXk28RiiPRTZiAth5m88Uw.png"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/iosdevie/0de04e6fe2ff1b5ae445746cf7b01d1f" rel="noopener ugc nofollow" target="_blank">要旨</a></p></figure><p id="16f0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">从上面的代码中可以明显看出，无边框按钮不符合当前操作系统的<code class="fe lw lx ly lz b">tint</code>颜色和<code class="fe lw lx ly lz b">automatic</code>样式。</p><p id="581d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="og">注意:为组容器设置一个样式修饰符(在我们的例子中是</em> <code class="fe lw lx ly lz b"><em class="og">VStack</em></code> <em class="og">)会将它应用到所有的按钮控件上。</em></p><p id="8e88" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有两个属性我们没有讨论:</p><ul class=""><li id="f5b8" class="ns nt iu lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">controlSize</code>从几个标准可用选项中选择按钮的尺寸。</li><li id="36b0" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">controlProminence</code> —这定义了不透明度。难怪最底部的按钮很突出。</li></ul><p id="89f7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了SwiftUI按钮控制的一系列变化，苹果还为SwiftUI展示了一个名为<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/corelocationui/locationbutton?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">LocationButton</a></code>的<code class="fe lw lx ly lz b">CoreLocationUI</code>按钮。它提供了标准化的当前位置用户界面，有助于快速获取位置坐标:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="d017" class="ni mi iu lz b gz nj nk l nl nm">LocationButton(.sendMyCurrentLocation) {</span><span id="3059" class="ni mi iu lz b gz oi nk l nl nm">// Fetch location with Core Location.</span><span id="bea3" class="ni mi iu lz b gz oi nk l nl nm">}.labelStyle(.titleAndIcon)</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="ead0" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">用于从URL加载图像的SwiftUI AsyncImage</h1><p id="a08b" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">以前，在图像中显示远程URL需要设置一个加载器并执行异步任务。处理不同的加载状态只会增加越来越多的样板代码。</p><p id="b345" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">谢天谢地，SwiftUI 3.0带来了<code class="fe lw lx ly lz b">AsyncImage</code>来抽象整个过程。</p><p id="3c47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它是这样工作的:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="25e8" class="ni mi iu lz b gz nj nk l nl nm">AsyncImage(url: URL(string: &lt;url_here&gt;)!)</span></pre><p id="66fa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以通过访问<code class="fe lw lx ly lz b">content</code>参数来自定义输出图像。此外，您也可以使用<code class="fe lw lx ly lz b">placeholder</code>参数来设置加载视图。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/a322ab5922c7b587f53e0b77ed5a25fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xdpYw7pI8mleW8wJIVqqkw.gif"/></div></div></figure><p id="8156" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您还可以使用来自<code class="fe lw lx ly lz b">content</code>块的<code class="fe lw lx ly lz b">AsyncImagePhase</code>枚举来处理结果的不同状态。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="b933" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">AsyncImage</code>让你指定<code class="fe lw lx ly lz b">transcation</code>，在那里你可以传递一个动画。</p><p id="3af4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有另一个<code class="fe lw lx ly lz b">scale</code>参数，不仅可以让你控制大小，还可以方便地放大和缩小。看一看:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oj"><img src="../Images/a322ab5922c7b587f53e0b77ed5a25fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*xdpYw7pI8mleW8wJIVqqkw.gif"/></div></div></figure><p id="7d9e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于<code class="fe lw lx ly lz b">AsyncImage</code>使用了<code class="fe lw lx ly lz b">URLSession</code>，它提供了开箱即用的缓存支持(尽管您现在还不能编写自定义缓存)。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="75da" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">SwiftUI TextField获得更好的键盘管理</h1><p id="b401" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在iOS 15中，我们有了一个新的属性包装器(<code class="fe lw lx ly lz b">@FocusState</code>)来以编程方式管理当前的活动字段。这将在登录和注册表单中非常有用，因为开发人员现在可以突出显示特定的文本字段。</p><p id="7e7f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了在SwiftUI中实现对<code class="fe lw lx ly lz b">TextField</code>的编程聚焦，我们需要在<code class="fe lw lx ly lz b">focusedStated</code>修饰符中绑定<code class="fe lw lx ly lz b">FocusState</code>。它进行布尔检查以确定<code class="fe lw lx ly lz b">FocusState</code>是否绑定到同一个视图。</p><p id="3fe6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个例子:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ok"><img src="../Images/b9efc2824322ee04cd5b14e02bd2be9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/1*W1Oy9shNP24MTEm9U6XHdw.gif"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/iosdevie/415728c7de0e111dd3c02bbee18db092" rel="noopener ugc nofollow" target="_blank">要旨</a></p></figure><p id="322a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意<code class="fe lw lx ly lz b">submitLabel</code>视图修改器。这让我们用一堆其他选项来设置键盘返回按钮。</p><p id="2bb9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前，SwiftUI TextField <code class="fe lw lx ly lz b">FocusState</code>在第一个iOS 15测试版中无法在<code class="fe lw lx ly lz b">Forms</code>中工作。</p><h2 id="6b44" class="ni mi iu bd mj ol om dn mn on oo dp mr lj op oq mt ln or os mv lr ot ou mx ov bi translated">新的onSubmit视图修饰符和onCommit的弃用</h2><p id="225b" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">因为我们为TextField提供了更好的焦点管理，所以我们有了一种新的处理结果的方式也就不足为奇了。回车键的<code class="fe lw lx ly lz b">onCommit</code>回调是不推荐使用的，并且有一个<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/swiftui/texteditor/onsubmit(of:_:)?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">onSubmit</a></code>视图修饰符。此修饰符用于处理视图层次结构中的文本字段结果。</p><p id="5daa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个例子:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="6543" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="og">注意:您可以使用</em> <code class="fe lw lx ly lz b"><em class="og">.onSubmit(of:)</em></code> <em class="og">选择指定视图类型。此外，将</em> <code class="fe lw lx ly lz b"><em class="og">submitScope</em></code> <em class="og">设置为</em> <code class="fe lw lx ly lz b"><em class="og">true</em></code> <em class="og">可以确保不返回该层次结构的结果。</em></p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="2838" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">SwiftUI列表现在可以搜索了</h1><p id="ca65" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在前两次迭代中，SwiftUI列表中缺少搜索功能。在iOS 15中，苹果给列表带来了一个<code class="fe lw lx ly lz b">searchable</code>修饰符。</p><p id="6ffb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要记住的关键事情是:要将一个列表标记为<code class="fe lw lx ly lz b">searchable</code>，您需要将它包装在一个<code class="fe lw lx ly lz b">NavigationView</code>中。</p><p id="e96f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是带有搜索视图的SwiftUI列表的第一个视图:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><p id="65df" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">有几件事需要考虑:</p><ul class=""><li id="44c2" class="ns nt iu lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">searchable</code>允许您指定一组搜索建议。点击它们将在搜索栏中显示<code class="fe lw lx ly lz b">searchCompletion</code>文本。</li><li id="ca2d" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">自动<code class="fe lw lx ly lz b">placement</code>根据苹果平台决定搜索栏的位置。</li><li id="79dc" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated">如果您还没有注意到，我们现在可以直接在列表中传递<code class="fe lw lx ly lz b">Binding</code>数组，并为每一行获取一个绑定值。SwiftUI <code class="fe lw lx ly lz b">TextField</code>中需要一个绑定值。以前，在列表中设置一个<code class="fe lw lx ly lz b">TextField</code>经常会导致整个视图层次的重载。幸运的是，<code class="fe lw lx ly lz b">Lists</code>中对<code class="fe lw lx ly lz b">Binding</code>数组的支持消除了这个问题。</li></ul><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ow"><img src="../Images/6c02f7c4c222ff59305de04e8f732688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yV2NuiHdBIIne7JInpwgjQ.gif"/></div></div></figure><p id="2e54" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了显示搜索结果，我们可以使用上面讨论过的<code class="fe lw lx ly lz b">onSubmit</code>修饰符，或者设置一个实时过滤的计算属性，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ox"><img src="../Images/f56eecafffb3b7c206b89b39f0b3a510.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dM0QLgbRW5bjQ1yb9D2z6g.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/iosdevie/66e5797931b909b53c540873e1960769" rel="noopener ugc nofollow" target="_blank">要旨</a></p></figure><p id="b47b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">还有一个环境值<code class="fe lw lx ly lz b">isSearching</code>，用于跟踪用户是否正在与搜索视图交互。您可以使用它在覆盖图或其他视图中显示/隐藏搜索结果。</p><p id="36dd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将<code class="fe lw lx ly lz b">onSubmit</code>修饰符用于嵌套的SwiftUI列表会很有趣。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="19ee" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">SwiftUI列表拉至刷新</h1><p id="68e8" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><em class="og">拉刷新</em>是另一个缺失的特性。这迫使我们使用<code class="fe lw lx ly lz b">UIViewRepresentable</code> <a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/pull-to-refresh-in-swiftui-6604f54a01d5">的变通方法</a>。使用iOS 15，你可以用<code class="fe lw lx ly lz b">refreshable</code>修饰符把它集成到几行代码中，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oy"><img src="../Images/5bc6247e2d6857c9ce4b486dc4590e8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*N67qMyAF7ttyemPT8bRo4Q.gif"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://gist.github.com/iosdevie/af2df84e9b44f239b7f4b05a9d541880" rel="noopener ugc nofollow" target="_blank">要点</a></p></figure><p id="b958" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以获取网络请求，就像在refreshable修饰符中使用<code class="fe lw lx ly lz b">async/await</code>一样，并显示结果。</p><p id="ecbc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前，本地SwiftUI Pull to Refresh在SwiftUI网格或滚动视图上不工作。然而，它确实带来了一些可定制性。有一个<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/swiftui/refreshaction?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">RefreshAction</a></code>环境值来手动触发刷新。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="0502" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">SwiftUI列出滑动动作</h1><p id="9d81" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><em class="og">滑动来执行动作</em>是另一个被请求的特性，我们今年通过新的<code class="fe lw lx ly lz b">swipeActions</code>修改器得到了它。</p><p id="9953" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这是全新按钮风格的滑动动作:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="no np l"/></div></figure><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oz"><img src="../Images/f4a0629175b2b1e995cc624bc8948e52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z7aDCOwn25NsKmu2Y2fCWQ.gif"/></div></div></figure><p id="99b5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，滑动动作将从屏幕的后缘显示。但是，我们也可以将它们配置为从前端工作。简单地使用这个:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="db3f" class="ni mi iu lz b gz nj nk l nl nm">.swipeActions(edge: .leading)</span></pre><p id="b3e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们还可以通过链接多个修改器来支持两侧的滑动动作。</p><p id="7f48" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，第一次推送操作在完整推送时触发。但是你可以通过设置<code class="fe lw lx ly lz b">allowsFullSwipe</code>为<code class="fe lw lx ly lz b">false</code>来改变这一点。</p><p id="4570" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">目前，推送操作不适用于绑定数组列表。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="39a1" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">列表、选项卡、警告和工作表的更多修饰符</h1><p id="7d9d" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">SwiftUI List无疑在今年得到了最大的升级。如果搜索视图、刷新和滑动操作还不够，还有更多方法可以自定义您的列表:</p><ul class=""><li id="f2ec" class="ns nt iu lc b ld le lg lh lj nu ln nv lr nw lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">listRowSeparator</code>和<code class="fe lw lx ly lz b">listSectionSeparator</code>显示或隐藏分隔线。</li><li id="646b" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">listRowSeparatorTint</code>和<code class="fe lw lx ly lz b">listSectionSeparatorTint</code>分别为每行和每段添加色调。</li><li id="dc11" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">.insetStyle(alternatesRowBackgrounds:)</code>针对macOS。</li><li id="0569" class="ns nt iu lc b ld ob lg oc lj od ln oe lr of lv nx ny nz oa bi translated"><code class="fe lw lx ly lz b">badges</code>设置在SwiftUI列表行的右侧。iOS 15的SwiftUI TabViews也有这个功能。</li></ul><p id="7955" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">SwiftUI警报视图现已弃用。相反，我们有了新的<code class="fe lw lx ly lz b">.alert</code>修改器。<code class="fe lw lx ly lz b">.alert</code>也为<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/swiftui/texteditor/alert(ispresented:error:actions:)?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">error</a></code>对话框带来了一个变种。</p><p id="f5b3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有一个<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/swiftui/anyview/interactivedismissdisabled(_:)?changes=latest_minor" rel="noopener ugc nofollow" target="_blank">interactiveDismissDisabled</a></code>功能，开发者可以选择阻止表单和表格的撤销。这里有一个简单的例子:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pa"><img src="../Images/21e3e43898106cdba1a57f059da5f14d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QTo9_JeyEYNFO80vdvDelQ.gif"/></div></div></figure></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="1e81" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">并发性的任务修饰符</h1><p id="b92d" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">以前，当获取视图数据时，许多SwiftUI开发人员会求助于<code class="fe lw lx ly lz b">onAppear</code>。</p><p id="cd2f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在iOS 15中，苹果带来了一个全新的<code class="fe lw lx ly lz b">task</code>修改器，让你的数据异步加载。当附加的SwiftUI视图被破坏时自动取消任务的能力使得任务修改器成为一个非常方便的工具。</p><p id="9974" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过按需加载更多数据来创建一个无止境的滚动列表是<code class="fe lw lx ly lz b">task</code>修饰符的一个完美用例。这对于完成<code class="fe lw lx ly lz b">NavigationLink</code>目的地视图的繁重工作也很方便(遗憾的是没有改进)。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="3629" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">全新SwiftUI材料结构</h1><p id="ff54" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe lw lx ly lz b">Material</code>结构用于通过给视图添加透明度和活力来混合前景元素和背景。我们以下列方式使用它:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="975f" class="ni mi iu lz b gz nj nk l nl nm">.background(.regularMaterial)<br/>.background(.thinMaterial)<br/>.background(.ultraThinMaterial)<br/>.background(.thickMaterial)<br/>.background(.ultraThicknMaterial)</span></pre><p id="fee2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">或者，您可以在材质中设置一个形状，如下所示:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj pb"><img src="../Images/0ccc0130209c348cc85e6020d18e99a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obJffFUMKFHpdo_OHL-Yhg.png"/></div></div></figure><p id="e1b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">基本上，材质类型表示背景类型通过前景元素的程度。这是在视觉上模糊SwiftUI视图的一个很好的替代方法。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="46cf" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">新画布和时间线视图</h1><p id="da18" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">SwiftUI里的一个<code class="fe lw lx ly lz b">drawRect</code>失踪了两年。最后，苹果以<code class="fe lw lx ly lz b">Canvas</code> API和更多的形式带来了它。</p><p id="fb95" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Canvas API为绘制路径和形状提供了现成的支持。因此，您可以通过在SwiftUI应用程序中设置遮罩、转换和应用滤镜来创建丰富的图形。最精彩的部分？是GPU加速的。</p><p id="f6ce" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，<code class="fe lw lx ly lz b">TimelineView</code>引入了构建实时更新的动态视图的能力。我们在去年的SwiftUI文本中看到了计时器发布者的一瞥。</p><p id="914b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是<code class="fe lw lx ly lz b">TimelineView</code>将它带到了另一个层次，它允许您包装任何SwiftUI视图，并通过<code class="fe lw lx ly lz b"><a class="ae kz" href="https://developer.apple.com/documentation/swiftui/timelineschedule" rel="noopener ugc nofollow" target="_blank">TimelineSchedule</a></code>设置可以定期或在特定时间配置的时间表。时间线视图就像应用程序中的小部件。</p><p id="0679" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在WWDC 2021上，苹果展示了一系列使用SwiftUI构建的普通iOS应用。我很确定TimelineViews在其中一些作品中扮演了重要角色。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="c38b" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">排除故障</h1><p id="abf4" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">SwiftUI现在为调试<a class="ae kz" href="https://twitter.com/luka_bernardi/status/1402045202714435585" rel="noopener ugc nofollow" target="_blank">视图层次</a>提供内置支持。</p><p id="0016" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在视图主体内调用以下函数将打印上次重新加载时修改的SwiftUI视图:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="d922" class="ni mi iu lz b gz nj nk l nl nm">let _ = Self._printChanges()</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="d3d7" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="629a" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">在本文中，我们看到了在WWDC 2021上宣布的一些主要SwiftUI功能。但是仍然有很多值得期待的，比如在macOS中使用SwiftUI <code class="fe lw lx ly lz b">Table</code>或者为<code class="fe lw lx ly lz b">CoreData</code>使用<code class="fe lw lx ly lz b">SectionedFetchRequest</code>属性包装器来增加SwiftUI应用的并发性。</p><p id="9a0e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">暂时就这样了。感谢阅读。</p></div></div>    
</body>
</html>