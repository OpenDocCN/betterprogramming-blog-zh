<html>
<head>
<title>Implementing React Redux Store With Persistence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用持久性实现React Redux存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-react-redux-store-with-persistence-44a030bbbf94?source=collection_archive---------0-----------------------#2022-04-26">https://betterprogramming.pub/implementing-react-redux-store-with-persistence-44a030bbbf94?source=collection_archive---------0-----------------------#2022-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4405" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">具有持久性的集中式应用状态存储</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8ac1cce912f6aefb9c497251967bbfca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VF0mAJHXVG-VkrhIQwxWqw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@tjevans?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂姆·埃文斯</a>在<a class="ae kv" href="https://unsplash.com/s/photos/save?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="6e5d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是React Redux？</h1><p id="68fa" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">React Redux是一个集中式状态，它允许您将状态从单个组件中分离出来。这使您可以轻松地跨组件共享和同步应用程序状态，从而消除不必要的状态链。</p><p id="3d0a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我将介绍以下内容，以便在任何React应用程序中设置Redux Store。这个项目的完整资源库将在文章末尾链接。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3350" class="mu kx iq mq b gy mv mw l mx my">1. <a class="ae kv" href="#d103" rel="noopener ugc nofollow">Creating the Redux Store</a><br/>2. <a class="ae kv" href="#4aca" rel="noopener ugc nofollow">Modifying State with Reducers</a><br/>3. <a class="ae kv" href="#93cf" rel="noopener ugc nofollow">Importing State and Reducers into Components</a><br/>    1. <a class="ae kv" href="#deb2" rel="noopener ugc nofollow">Function Component</a><br/>    2. <a class="ae kv" href="#1c0c" rel="noopener ugc nofollow">Class Component</a><br/>4. <a class="ae kv" href="#fff7" rel="noopener ugc nofollow">Adding Persistence</a></span></pre><h1 id="d103" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">创建Redux存储</h1><p id="7eea" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了将Redux商店添加到我们的应用程序中，我们首先需要导入React-Redux和Redux工具包。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="40cc" class="mu kx iq mq b gy mv mw l mx my">npm i react-redux @reduxjs/toolkit</span></pre><p id="5842" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们现在准备建立我们的Redux商店。Redux存储由两个主要组件组成，存储本身和一个数据片。store本质上是一个包装器，负责将数据切片注入到应用程序中。数据片本身就是状态和归约者所在的地方。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="b5b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们从创建数据切片开始。我们使用Redux Toolkit中的方法<code class="fe ng nh ni mq b">createSlice</code>，来创建数据切片。该方法接受一个JSON对象，其中包含我们的数据片名称、initialState对象和reducers对象。</p><p id="ff2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当导出我们的数据切片时，我们创建两个导出语句。一个用于reducer方法，<code class="fe ng nh ni mq b">DataSlice.actions</code>，另一个默认导出用于数据切片本身，<code class="fe ng nh ni mq b">DataSlice.reducer</code>。这个默认的导出可能会有点混乱，因为它看起来似乎只应该是reducer方法。默认导出是传递到redux存储包装器中的内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">反应数据切片</p></figure><p id="38e1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们有了数据切片，我们可以创建我们的商店。这个存储非常简单，通过将我们的数据片传递给Redux Toolkit <code class="fe ng nh ni mq b">configureStore</code>方法来创建。然后，我们导出我们的商店，稍后注入到我们的应用程序中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Redux商店</p></figure><p id="b51e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦我们的商店被创建，我们需要把它注入到我们的应用程序。我们通过将应用程序包装在React-Redux的<code class="fe ng nh ni mq b">Provider</code>组件中来实现这一点。提供者组件将我们的存储作为一个道具，允许我们稍后将其导入到我们的组件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将Redux Store注入应用程序</p></figure><h1 id="4aca" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">用减速器修改状态</h1><p id="e983" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">减速器方法由两个参数组成，<code class="fe ng nh ni mq b">state</code>和<code class="fe ng nh ni mq b">actions</code>。状态将始终是应用程序的当前状态，并自动传入。Actions是一个JSON对象，由两个变量组成，<code class="fe ng nh ni mq b">type</code>和<code class="fe ng nh ni mq b">payload</code>。类型将被自动设置为您的数据切片和reducer方法的名称，在我们的例子中是<code class="fe ng nh ni mq b">dataSlice/updateMessage</code>。有效负载将由我们从组件传递到reducer方法的数据组成。</p><p id="a38f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">需要记住的一个要点是，有效载荷只能包含一个数据点。因此，如果我们需要将多个值传递给reducer方法，我们需要使用JSON对象将它们传递给有效负载。</p><p id="45b6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当用redux更新状态时，我们不需要担心变异动作。Redux将自动处理状态中的克隆和创建新对象。因此，我们能够直接更新我们的reducers中的状态。</p><h1 id="93cf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">将状态和减速器导入组件</h1><p id="7a6c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在我们已经设置好了状态和还原器，我们可以将它们导入到我们的组件中。根据函数或类组件的使用，有不同的方法来导入状态和归约器。我将从展示钩子在功能组件中的使用开始。</p><h2 id="deb2" class="mu kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">功能成分</h2><p id="1099" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将使用React Redux中的两个钩子<code class="fe ng nh ni mq b">useSelector</code>和<code class="fe ng nh ni mq b">useDispatch</code>将我们的状态和reducers导入到我们的函数组件中。<code class="fe ng nh ni mq b">useSelector</code>钩子允许我们从数据切片中选择某个状态值，并将其保存为局部变量。<code class="fe ng nh ni mq b">useDispatch</code>钩子让我们能够直接从组件内部调用reducers。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将Redux状态和Reducers导入功能组件</p></figure></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h2 id="1c0c" class="mu kx iq bd ky nl nm dn lc nn no dp lg lx np nq li mb nr ns lk mf nt nu lm nv bi translated">类别组件</h2><p id="af90" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">至于类组件，我们无法使用hook，所以将使用不同的方法。这种导入状态和归约器的方法也适用于函数组件，但是，我强烈推荐使用hook方法。</p><p id="003b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于类组件，我们将利用React-Redux中的<code class="fe ng nh ni mq b">connect</code>方法。该方法类似于常用于导入样式的<code class="fe ng nh ni mq b">withStyles</code>方法。connect方法最多接受两个参数，一个用于状态导入，另一个用于还原器。</p><p id="4306" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将分别使用<code class="fe ng nh ni mq b">mapStateToProps</code>和<code class="fe ng nh ni mq b">mapDispatchToProps</code>方法导入state和reducers。这两种方法都将返回一个对象，该对象包含组件所需的状态和reducers。mapStateToProps有两个参数，<code class="fe ng nh ni mq b">state</code>和<code class="fe ng nh ni mq b">ownProps</code>。state参数是自动填充的，是来自我们的数据切片的状态对象，ownProps可用于传入本地状态属性。mapDispatchToProps有一个单独的<code class="fe ng nh ni mq b">dispatch</code>参数，该参数由类似于<code class="fe ng nh ni mq b">useDispatch</code>钩子的分派方法自动填充。</p><p id="68f2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，connect方法将状态和reducers绑定到我们的props，允许我们使用<code class="fe ng nh ni mq b">this.props.&lt;state or reducer&gt;</code>访问它们。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将Redux状态和Reducers导入类组件</p></figure><h1 id="fff7" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">添加持久性</h1><p id="3058" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这一节中，我将介绍如何向Redux存储添加持久性，以便在页面刷新时保存数据。这对于Redux本身来说是不必要的，只是取决于您的用例。</p><p id="6d36" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当向我们的应用程序添加持久性时，我们首先需要导入一个额外的库Redux Persist。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8090" class="mu kx iq mq b gy mv mw l mx my">npm i redux-persist</span></pre><p id="1238" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦我们安装了Redux Persist，我们将需要对我们的Redux存储和index.html文件进行一些更改。让我们从我们的Redux商店开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Redux store with Redux Persist</p></figure><p id="d525" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">乍一看，这与我们最初的商店实现有很大不同。主要的变化是分别在Redux Persist <code class="fe ng nh ni mq b">persistReducer</code>和<code class="fe ng nh ni mq b">persistStore</code>方法中包装我们的数据切片和存储。</p><p id="52fe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe ng nh ni mq b">persistReducer</code>方法允许我们传入我们的数据片和一个持久化配置。这个配置允许我们控制如何保存我们的存储。要记住的主要配置是存储将被持久化的位置。在这个例子中，我们通过使用下面的import <code class="fe ng nh ni mq b">import storage from ‘redux-persist/lib/storage'</code>来使用浏览器的本地存储。</p><p id="0880" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的商店有很多选择，在这里都可以找到<a class="ae kv" href="https://github.com/rt2zz/redux-persist#storage-engines" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="994b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">除了配置我们的数据切片，我们还需要向存储添加一些额外的配置。这种配置是中间件的形式。持久性使用可序列化检查来确保我们存储的数据是可序列化的。但是，我们不希望对Redux Persist本身执行的某些操作执行这种检查。</p><p id="3994" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦我们的中间件建立起来，我们就把我们的存储包装在<code class="fe ng nh ni mq b">persistStore</code>中，允许它被Redux Persist管理。我们还需要导出我们的存储以及从<code class="fe ng nh ni mq b">persistStore</code>返回的这个新的持久化器。既然我们的商店已经为持久性重新配置了，我们需要将我们的persistor注入到我们的应用程序中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将Redux Persistor注入应用程序</p></figure><p id="a882" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了注入我们的persistor，我们将使用Redux Persist提供的<code class="fe ng nh ni mq b">PersitGate</code>组件。这个组件将是我们的<code class="fe ng nh ni mq b">Provider</code>组件的一个子组件，包含我们应用程序的其余部分。</p><h1 id="4980" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">包装东西</h1><p id="41a7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们已经成功地将一个Redux商店添加到react应用程序中，并为我们的商店添加了持久性。正如承诺的，这个项目的回购可以在下面找到。有两个分支，<code class="fe ng nh ni mq b">main</code>和<code class="fe ng nh ni mq b">react-persist</code>。Main有基本的redux设置，而react-persist有持久性添加。</p><div class="nw nx gp gr ny nz"><a href="https://github.com/EJOzyazgan/React-Redux-Setup" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">GitHub-EJOzyazgan/React-Redux-Setup:React中基本Redux设置的示例报告</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.co</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div></div></div>    
</body>
</html>