<html>
<head>
<title>Test-Driven Development Attempt With Jest and Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest和Angular的测试驱动开发尝试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/test-driven-development-attempt-with-jest-and-angular-7e064b76ca2d?source=collection_archive---------3-----------------------#2020-03-31">https://betterprogramming.pub/test-driven-development-attempt-with-jest-and-angular-7e064b76ca2d?source=collection_archive---------3-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5a45" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Jest中的测试驱动开发可能吗？Jest比Karma更好还是更快？什么是开玩笑的快照测试？让我们找出答案。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90f0e7a0f35de2cc5d9ba42df97c5fb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BY40RaUbwDgyFQ6unLcvHA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用Jest作为测试框架编写角度代码</p></figure><p id="0b72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几个月前，我和一个同事一起工作。我们正在使用Karma和Jasmine进行有角度的前端概念验证，一切都很顺利。我的同事告诉我,<a class="ae lu" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>要好得多。我很惊讶，但由于没有人知道所有的事情，对你的工作方式持批评态度总是好的，我愿意相信他。这让我很好奇。有没有更好的办法？</p><p id="397a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当时，我还在开发一个大型前端应用程序，进行了1000多次角度测试。运行所有这些测试非常慢。这让我想到，Jest能解决这个问题吗？Jest也允许我以测试驱动的方式工作吗？你猜怎么着，现在几个月过去了，我一直在我的网站上玩Jest。我发现了一些有趣的见解，我在这里与你分享这些。</p><p id="af12" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇文章的结构如下:</p><ul class=""><li id="fb0f" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">测试驱动开发简介</li><li id="e34e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Jest:历史和优点</li><li id="0ce8" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">快照测试:UI测试和属性匹配器</li><li id="96e5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">Jest和Karma的速度比较</li><li id="4558" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">结论</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9952" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">前端代码中的TDD今年是哪一年？</h1><p id="915e" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我不是想让你相信编写测试很重要。我已经过了那个阶段了。我相信以一种非常结构化的方式来解决问题会带来最好的结果。让我告诉你如何做到这一点。</p><p id="fce9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我将通过应用被称为测试驱动开发(TDD)的软件开发过程向您展示我是如何做到这一点的。让我们从定义开始，之后，我将展示如何用Angular编写这样的代码，使用Jest作为我们的测试框架。</p><blockquote class="nn no np"><p id="5cef" class="ky kz nq la b lb lc ju ld le lf jx lg nr li lj lk ns lm ln lo nt lq lr ls lt im bi translated">“测试驱动开发(TDD)是一种软件开发过程，它依赖于一个非常短的开发周期的重复:需求被转化为非常具体的测试用例，然后代码被改进以便通过测试。”</p><p id="5111" class="ky kz nq la b lb lc ju ld le lf jx lg nr li lj lk ns lm ln lo nt lq lr ls lt im bi translated">— <a class="ae lu" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="d06d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基本上，当我们以这种方式编写代码时，一切都归结为:我们编写了一个测试，它失败了，因为它还没有实现。然后我们编写足够的代码来通过这个测试。当测试通过时，我们检查这是否是可满足的代码。如果不是，我们使用重构步骤清理它。</p><p id="198e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一次迭代之后，我们100%确定我们得到了我们想要的。更重要的是，当我们继续这样做的时候，情况依然如此。我们过去写的每一个测试都是我们100%确定的。</p><p id="204a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想看看我们过去写的东西还能用吗？只要做测试，他们就会支持你。</p><p id="b4b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为个人，你可能会想，“我知道我写的是什么，我确信它是有用的。”然而，当你在一个更大的组织中工作时，当它不工作时，你假设它工作的机会增加了。测试给了你和你的团队一些东西，在某些事情确实出错的情况下——例如，在外部包升级或者大的重构期间(或者它甚至可能是一个缺失的特性)。</p><p id="ed76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些测试记录了系统的整个工作过程。从长远来看，这是应该走的路。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="0558" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">遇见笑话</h1><h2 id="2260" class="nu mr it bd ms nv nw dn mw nx ny dp na lh nz oa nc ll ob oc ne lp od oe ng of bi translated">测试框架的起源</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/c131cb838b17f01327791a3baf531def.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GRtG0AWt6LX6y9JX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae lu" href="https://unsplash.com/@noguidebook?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瑞秋</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的一张小丑照片</p></figure><p id="1251" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Jest是一个由脸书维护的JavaScript测试框架。笑话的重点在于它的简单。它可以与Babel、TypeScript、React、Node、Angular、Vue等技术协同工作。</p><h2 id="0bec" class="nu mr it bd ms nv nw dn mw nx ny dp na lh nz oa nc ll ob oc ne lp od oe ng of bi translated">笑话的优点</h2><p id="2cf9" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">Jest旨在强化以下几点:</p><ul class=""><li id="cdc0" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu">配置</strong> : Jest旨在打破常规。这并不是100%正确的，因为你仍然需要到处配置一些东西。然而，Medium上已经有大量的<a class="ae lu" href="https://medium.com/angular-in-depth/integrate-jest-into-an-angular-application-and-library-163b01d977ce" rel="noopener">文章</a>介绍了如何使用Jest创建和设置Angular应用程序。所以我不打算在这里谈这个。</li><li id="9eff" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">快照:这是一个非常有用的工具，可以确保你的用户界面没有意外的改变。当我给你一个例子的时候，它会变得更清楚。我已经给了你一个我喜欢它们的原因:你可以很快看到(例如，在一个拉请求中)你的模板发生了什么变化。</li><li id="4d38" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">隔离</strong>:每个测试都在它们的进程中运行，这意味着它们可以被并行化。这大大提高了它们的速度。他们也不需要像Karma test runner这样的浏览器。当您必须运行1000多个测试时，这无疑是一个很大的改进。</li><li id="038a" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">API:他们有很好的文档。然而。我注意到我不必一直检查文档。这意味着它非常直观，这是我所欣赏的。</li></ul><p id="1ef3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最重要的是，它开箱即用，具有覆盖范围、简单模仿、观察插件和异常上下文。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="953e" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">快照测试</h1><p id="3e31" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">好吧，先说我在《因果报应》里没见过的。这是对我来说最突出的事情。为什么要使用快照？</p><blockquote class="nn no np"><p id="d266" class="ky kz nq la b lb lc ju ld le lf jx lg nr li lj lk ns lm ln lo nt lq lr ls lt im bi translated">"当你想确保你的用户界面不会发生意外变化时，快照测试是一个非常有用的工具."——<a class="ae lu" href="https://jestjs.io/docs/en/snapshot-testing" rel="noopener ugc nofollow" target="_blank">玩笑</a></p></blockquote><p id="32df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这有点难以理解。先说我的一个例子。我们将从一个基本测试开始，然后继续。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="44c8" class="nu mr it oi b gy om on l oo op"><strong class="oi iu"><em class="nq">it</em></strong>("should render", () =&gt; {<br/>  fixture.detectChanges();<br/>  <strong class="oi iu"><em class="nq">expect</em></strong>(fixture).toMatchSnapshot();<br/>});</span></pre><p id="af70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好的，你可以这么做。它告诉我们组件应该呈现。快照放在一个文件夹中，您可以在那里看到它。让我向您展示这样一个快照文件的内容。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="a2ae" class="nu mr it oi b gy om on l oo op">// Jest Snapshot v1, <a class="ae lu" href="https://goo.gl/fbAQLP" rel="noopener ugc nofollow" target="_blank">https://goo.gl/fbAQLP</a></span><span id="1151" class="nu mr it oi b gy oq on l oo op">exports[`BlogpostComponent should render 1`] = `<br/>&lt;app-blogpost&gt;<br/>  <br/>&lt;/app-blogpost&gt;<br/>`;</span></pre><p id="219e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很好，这很容易开始。我们的测试为我们生成了快照。我们从绿色测试开始——这是一个好的开始。但是让我们重构一下，因为测试描述非常糟糕。</p><p id="6920" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Jest还支持内嵌快照。让我们使用它们，因为我喜欢在测试本身中包含所有信息。我给你看！</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="596b" class="nu mr it oi b gy om on l oo op"><strong class="oi iu"><em class="nq">it</em></strong>("renders my empty blogpost component", () =&gt; {<br/>  fixture.detectChanges();<br/>  <strong class="oi iu"><em class="nq">expect</em></strong>(fixture).toMatchInlineSnapshot();<br/>});</span></pre><p id="efd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们现在运行这个。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="3164" class="nu mr it oi b gy om on l oo op"><strong class="oi iu"><em class="nq">it</em></strong>("renders my empty blogpost component", () =&gt; {<br/>  fixture.detectChanges();<br/>  <strong class="oi iu"><em class="nq">expect</em></strong>(fixture).toMatchInlineSnapshot(`<br/>    &lt;app-blogpost&gt;<br/>      <br/>    &lt;/app-blogpost&gt;<br/>  `);<br/>});</span></pre><p id="26d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那好多了。我们的测试描述完全符合预期。但是现在说不通。如果我们只有一个空组件，实际的好处是不清楚的。让我们进入下一个测试驱动的步骤。</p><p id="acea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将测试改为一个空的div，上面有一些bootstrap样式。这是我们想要实施的下一步。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="868c" class="nu mr it oi b gy om on l oo op"><strong class="oi iu"><em class="nq">it</em></strong>("renders a blogpost with a full width container", () =&gt; {<br/>  fixture.detectChanges();<br/>  <strong class="oi iu"><em class="nq">expect</em></strong>(fixture).toMatchInlineSnapshot(`<br/>    &lt;app-blogpost&gt;<br/>      &lt;div class="container-fluid"&gt;</span><span id="d361" class="nu mr it oi b gy oq on l oo op">      &lt;/div&gt;<br/>    &lt;/app-blogpost&gt;<br/>  `);<br/>});</span></pre><p id="1420" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们现在运行测试，看看它做什么。我们看到它失败了，这是合乎逻辑的，因为我们还没有实现它。它还允许我们查看预期快照和实际快照之间的差异。</p><p id="0a9c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我也会给你看:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b43523618545afd7a153b6fc9a200258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*wKRHQgHZKYACZKQv6Eo_rw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预期与实际</p></figure><p id="0b4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们继续讨论实现。</p><p id="0fd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在组件HTML文件中放入了以下代码:</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="9dd4" class="nu mr it oi b gy om on l oo op">&lt;div class="container-fluid"&gt;</span><span id="9431" class="nu mr it oi b gy oq on l oo op">&lt;/div&gt;</span></pre><p id="a0de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一次运行测试时，我几乎100%确定它会成功。然而，它没有！</p><p id="6326" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，Jest至少让我看到了不同之处。让我们调查一下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/0de4578595cdfeed02368ebb1fc8a9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*CrR8H1OYB4sTm2OiIJ0f8g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">预期与实际</p></figure><p id="2c45" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的反应？那不是我所期望的。但它是有效的HTML，是一回事。这使得完全测试驱动有点困难，因为我必须习惯用格式化程序的方式编写代码。</p><p id="e8ac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在最初的失望之后，我接受了当前的快照，我的测试现在成功了。我觉得没什么可学的了，所以我将组件开发的其余部分作为练习。</p><p id="d90a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你愿意，进入第三步，给测试添加越来越多的细节(比如自己实现一篇博客文章或任何其他组件)。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="c6e7" class="nu mr it oi b gy om on l oo op"><strong class="oi iu"><em class="nq">it</em></strong>("renders a blogpost with a full width container", () =&gt; {<br/>  fixture.detectChanges();<br/>  <strong class="oi iu"><em class="nq">expect</em></strong>(fixture).toMatchInlineSnapshot(`<br/>    &lt;app-blogpost&gt;<br/>      &lt;div<br/>        class="container-fluid"<br/>      /&gt;<br/>    &lt;/app-blogpost&gt;<br/>  `);<br/>});</span></pre><p id="19a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快照测试是识别应用程序中意外接口变化的理想方法。根据Jest，您应该了解一些<a class="ae lu" href="https://jestjs.io/docs/en/snapshot-testing#best-practices" rel="noopener ugc nofollow" target="_blank">最佳实践</a>，以便有效地使用它:</p><ul class=""><li id="7c4e" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated"><strong class="la iu">将快照视为代码</strong>:提交快照，并将其作为常规代码评审过程的一部分进行评审。</li><li id="3300" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">测试应该是确定性的</strong>:对一个没有改变的组件多次运行相同的测试，每次都会产生相同的结果。否则，您的模板将在不同的运行中发生变化，从而导致意外的失败。例如，通过使用固定的日期来尽可能避免这种情况。</li><li id="eb77" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><strong class="la iu">使用描述性的快照名称</strong>:避免类似<code class="fe ot ou ov oi b">should render</code>的东西。描述你期望从你的测试中得到什么，就像你应该为你所写的每一个测试所做的那样。确保你的意图是明确的。</li></ul><h2 id="f579" class="nu mr it bd ms nv nw dn mw nx ny dp na lh nz oa nc ll ob oc ne lp od oe ng of bi translated">具有内联快照的属性匹配器</h2><p id="2d96" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我将给出一个例子来展示快照测试的威力，这是我非常喜欢的一个例子。在下面的例子中，我检查了一个包含我所期望的所有内容的对象。这太棒了。</p><p id="857c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种快照很容易适应预期的变化(例如，当我们添加一个新的字段或者当我们改变数组的顺序时)。这使得再次以测试驱动的方式工作成为可能。这很好。</p><p id="c3ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不再有构建复杂组件的麻烦，只需以易读的格式提供您需要的所有信息。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="e309" class="nu mr it oi b gy om on l oo op"><strong class="oi iu"><em class="nq">expect</em></strong>(dataEmitted).toMatchInlineSnapshot(`<br/>  Array [<br/>    Object {<br/>      "category": "frontend",<br/>      "publicationDate": 2020-03-21T00:00:00.000Z,<br/>      "title": "my frontend blogpost.fr",<br/>      "url": "www.medium.com/life-is-fun",<br/>    },<br/>    Object {<br/>      "category": "backend",<br/>      "publicationDate": 2020-02-15T00:00:00.000Z,<br/>      "title": "my backend blogpost.fr",<br/>    },<br/>  ]<br/>`);</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="adf3" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">速度:因果报应与笑话</h1><p id="051e" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">首先，我必须写一些测试来试验它们。写完这些测试之后，我想知道加速的幅度会有多大。让我们比较一下我对因果报应和笑话的结果。</p><p id="211e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Karma浏览器测试了运行大约2000个测试所花费的总时间(在我的机器上几乎是80秒)。如果你想一想，这并不慢。运行20个Jest测试大约需要4秒钟。使用简单的数学，认为运行1000个测试在玩笑中比在Karma中更快是愚蠢的。</p><p id="ba16" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你认为这是从一个测试框架转移到另一个框架的原因，请三思。如果我是诚实的，我喜欢笑话，我没有理由不使用它。我认为<em class="nq">这个</em>的特殊原因根本不是搬家的好理由。</p><p id="a02c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你用的是老版本的Angular，我建议你升级到最新版本。这将比转换测试框架更有意义。</p><pre class="kj kk kl km gt oh oi oj ok aw ol bi"><span id="9d5f" class="nu mr it oi b gy om on l oo op">&gt; jest</span><span id="dbbc" class="nu mr it oi b gy oq on l oo op">...</span><span id="ce4c" class="nu mr it oi b gy oq on l oo op">Test Suites: 8 passed, 8 total<br/>Tests:       20 passed, 20 total<br/>Snapshots:   12 passed, 12 total<br/>Time:        4.0s<br/>Ran all test suites.</span></pre></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bc2b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="4555" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">在使用Jest几个月之后，我觉得关于这个框架我还有很多需要发现的地方。然而，在使用这个框架之前，我也获得了一些问题的答案。我想我可以用一句话来概括我的答案:</p><p id="bb83" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一边的草并不总是更绿。</p><p id="401e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这对我来说有两个主要原因:</p><ul class=""><li id="d1b2" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">我期望Jest比使用Karma快得多。但说实话，事实并非如此。例如，与从角度7移动到角度9相比，结果相当令人失望。</li><li id="6380" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">快照测试不是圣杯。你还需要其他的测试。然而，它们被证明是相当有用的，而且肯定增加了一些东西。我仍在探索如何充分利用它们。这当然是对其他测试的一个很好的补充，而不是替代。</li></ul><h2 id="436d" class="nu mr it bd ms nv nw dn mw nx ny dp na lh nz oa nc ll ob oc ne lp od oe ng of bi translated">我还会继续用Jest吗？</h2><p id="3ef9" class="pw-post-body-paragraph ky kz it la b lb ni ju ld le nj jx lg lh nk lj lk ll nl ln lo lp nm lr ls lt im bi translated">我肯定会的。我确实喜欢很多《孽债》里没有的东西。我发现Jest的模拟功能非常具有可读性。此外，快照测试为语言增加了一些东西。总的来说，我发现Jest非常容易使用，这也是有人能给我的最好的理由，让我选择Jest而不是Karma。</p></div></div>    
</body>
</html>