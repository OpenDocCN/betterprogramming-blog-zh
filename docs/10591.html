<html>
<head>
<title>Optimize Your Python Codebases by Almost 3x With __slots__</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用__slots__将您的Python代码库优化近3倍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optimize-your-python-programs-for-free-with-slots-4ff4e1611d9d?source=collection_archive---------8-----------------------#2022-01-17">https://betterprogramming.pub/optimize-your-python-programs-for-free-with-slots-4ff4e1611d9d?source=collection_archive---------8-----------------------#2022-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e1bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过添加一行代码来提高执行速度和内存使用率</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5d32c2be63867204636968ca2e851252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LCAaANYzdNbRnlF4"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gillyberlin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">吉利</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="06f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Python是最受欢迎的编程语言之一，但与其他语言相比，它的效率也很低。Python对象是时间和内存性能的主要瓶颈。</p><p id="2094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于它的动态类型系统和可变对象，解释器不能像编译器那样为更静态的语言优化程序执行。这是因为你没有给它任何关于你实际上要用你的程序做什么的提示。让我给你看一个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无槽类人</p></figure><p id="b2a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，您可以看到Python如何允许您为对象分配未声明的属性。但是，这种增加的功能也有不好的一面。解释器不能预先知道对象有多大，因此它必须考虑最终的操作，就像上面显示的那样。</p><h2 id="170a" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">Python的默认行为</h2><p id="e212" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">默认情况下，Python将对象的属性存储在可变字典中，可以通过<code class="fe mv mw mx my b">__dict__</code>属性访问该字典。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="6416" class="lx ly it my b gy nd ne l nf ng"># Before setting the "country" attribute<br/>&gt;&gt;&gt; print(person.__dict__)</span><span id="9ac6" class="lx ly it my b gy nh ne l nf ng">{'name': 'Hans', 'age': 30}</span><span id="84fc" class="lx ly it my b gy nh ne l nf ng"># After setting the "country" attribute<br/>&gt;&gt;&gt; print(person.__dict__)</span><span id="58a8" class="lx ly it my b gy nh ne l nf ng">{'name': 'Hans', 'age': 30, 'country': 'Germany'}</span></pre><p id="336a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，对象<code class="fe mv mw mx my b">__dict__</code>中添加了一个新条目。然后将通过字典查找访问它们，如这里的<a class="ae ky" href="https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/slot/slot.md#lookup-procedure-in-mro--1" rel="noopener ugc nofollow" target="_blank">所述</a>。还要注意，Python字典占据了相当大的空间。下面是空元组、列表和字典的内存需求的快速比较:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台输出(所有大小都以字节为单位):</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3d9f" class="lx ly it my b gy nd ne l nf ng">Size of tuple:       56<br/>Size of list:        72<br/>Size of dictionary: 248</span></pre><p id="294a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，Python字典是一个非常庞大的数据结构。现在，让我们看看另一种方法。</p><h2 id="531b" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">Python的__slots__是什么</h2><p id="9c31" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">Python提供了定义类属性<code class="fe mv mw mx my b">__slots__</code>的可能性，但是这如何影响创建的对象呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">开槽类人</p></figure><p id="7bbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将<code class="fe mv mw mx my b">Person</code> class' <code class="fe mv mw mx my b">__slots__</code>属性定义为一组字符串，每个字符串代表<code class="fe mv mw mx my b">Person</code>对象的一个属性。请注意，您也可以使用列表来声明属性，但是<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/optimize-your-python-programs-with-tuples-704f176c956d">元组更有效</a>。“开槽”类不允许新属性被添加到它们的实例中。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="e76e" class="lx ly it my b gy nd ne l nf ng">&gt;&gt;&gt; person.country = 'Germany'</span><span id="6674" class="lx ly it my b gy nh ne l nf ng">AttributeError: 'Person' object has no attribute 'country'</span></pre><p id="7c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义<code class="fe mv mw mx my b">__slots__</code>禁止了<code class="fe mv mw mx my b">__dict__</code>属性的创建，您可以从下面的错误中看到:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="de81" class="lx ly it my b gy nd ne l nf ng"># Slotted classes don't have __dict__<br/>&gt;&gt;&gt; print(person.__dict__)</span><span id="a51e" class="lx ly it my b gy nh ne l nf ng">AttributeError: 'Person' object has no attribute '__dict__'</span><span id="3291" class="lx ly it my b gy nh ne l nf ng"># Slotted classes have __slots__ instead<br/>&gt;&gt;&gt; print(person.__slots__)</span><span id="e413" class="lx ly it my b gy nh ne l nf ng">('name', 'age')</span></pre><p id="0ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会深入讨论使用<code class="fe mv mw mx my b">__slots__</code>的属性查找是如何工作的实现细节，但是如果你有兴趣，可以看一看<a class="ae ky" href="https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/slot/slot.md#slot" rel="noopener ugc nofollow" target="_blank">这个指南</a>。简而言之，Python几乎可以直接访问对象属性，而不必执行耗时的查找。</p><h2 id="c9ea" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">__网__对_ _槽_ _</h2><p id="58fc" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">您可能会惊讶地发现，除了<code class="fe mv mw mx my b">__slots__</code>声明之外，开槽类和非开槽类都编译成完全相同的Python字节码。下面是一个使用<a class="ae ky" href="https://godbolt.org/" rel="noopener ugc nofollow" target="_blank">编译器资源管理器</a>的具体例子，这是一个非常棒的工具，可以让你详细了解源代码是如何编译的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非时隙类</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">开槽类</p></figure><p id="1caf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，性能差异不在于字节码，而在于Python如何处理它。特别是，我们对<code class="fe mv mw mx my b">LOAD_ATTR</code>和<code class="fe mv mw mx my b">STORE_ATTR</code>操作感兴趣，它们分别调用C函数<code class="fe mv mw mx my b">PyObject_GetAttr()</code>和<code class="fe mv mw mx my b">PyObject_SetAttr()</code>，从<code class="fe mv mw mx my b"><a class="ae ky" href="https://github.com/python/cpython/blob/be578e0c063dad1dbb273f86d5bc77e4e6f14583/Python/ceval.c" rel="noopener ugc nofollow" target="_blank">ceval.c</a></code> <a class="ae ky" href="https://github.com/python/cpython/blob/be578e0c063dad1dbb273f86d5bc77e4e6f14583/Python/ceval.c" rel="noopener ugc nofollow" target="_blank">源文件</a>中可以看到。</p><p id="09be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">原来，Python虚拟机(PVM)执行的这些操作依赖于用于描述内置类型的<code class="fe mv mw mx my b"><a class="ae ky" href="https://docs.python.org/3/c-api/type.html#c.PyTypeObject" rel="noopener ugc nofollow" target="_blank">PyTypeObject</a></code> C struct的两个属性，即<code class="fe mv mw mx my b"><a class="ae ky" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getattro" rel="noopener ugc nofollow" target="_blank">tp_getattro</a></code>和<code class="fe mv mw mx my b"><a class="ae ky" href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_setattro" rel="noopener ugc nofollow" target="_blank">tp_setattro</a></code>。这些字段存储检索或设置给定名称的对象属性的函数。在下面的Python源代码示例中，您可以看到它们是如何用于获取对象属性的。别担心，我已经添加了一些评论，这样你可以更好地理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python源代码中的PyObject_GetAttr()函数。</p></figure><p id="8715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，有趣的部分来了:存储在<code class="fe mv mw mx my b">tp_getattro</code>和<code class="fe mv mw mx my b">tp_setattro</code>字段中的默认getter和setter函数分别是<code class="fe mv mw mx my b">PyObject_GenericAttr()</code>和<code class="fe mv mw mx my b">PyObject_GenericSetAttr()</code>。从Python <a class="ae ky" href="https://docs.python.org/3/c-api/object.html#c.PyObject_GenericSetAttr" rel="noopener ugc nofollow" target="_blank">文档</a>来看，这些函数首先寻找一个<a class="ae ky" href="https://realpython.com/python-descriptors/" rel="noopener ugc nofollow" target="_blank">数据描述符</a>通过内存地址偏移量直接访问属性，速度非常快。如果没有找到这样的描述符，Python会继续在实例属性字典<code class="fe mv mw mx my b">__dict__</code>中查找，这样会慢一些。我不打算把重点放在查找实现上，因为它相当复杂，但是如果您感兴趣，可以查看Python源代码中的<code class="fe mv mw mx my b"><a class="ae ky" href="https://github.com/python/cpython/blob/main/Objects/object.c" rel="noopener ugc nofollow" target="_blank">object.c</a></code> <a class="ae ky" href="https://github.com/python/cpython/blob/main/Objects/object.c" rel="noopener ugc nofollow" target="_blank">文件</a>。然而，下面是该过程的伪代码概述:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="4b8b" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">基准</h2><p id="61cd" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">既然我们已经讨论了槽式类和非槽式类之间的区别，是时候做一些实际的基准测试来突出使用<code class="fe mv mw mx my b">__slots__</code>的优势了。对于速度基准，我将使用Python的内置模块<code class="fe mv mw mx my b"><a class="ae ky" href="https://docs.python.org/3/library/timeit.html" rel="noopener ugc nofollow" target="_blank">timeit</a></code>。</p><p id="44f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个代码片段，它测量了创建这两个类的实例所需的时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f8c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是输出结果:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3b1e" class="lx ly it my b gy nd ne l nf ng">SlottedClass:    0.19703685840140678<br/>NonSlottedClass: 0.2519917337005609</span></pre><p id="bea8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，时隙类只占用了非时隙类测试运行时间的78%。速度提高了22%!</p><p id="b694" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至于调用<code class="fe mv mw mx my b">add</code>函数，下面是基准测试结果:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="9f1f" class="lx ly it my b gy nd ne l nf ng">SlottedClass:    0.10773063939923304<br/>NonSlottedClass: 0.12706781459928607</span></pre><p id="dd6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非时隙类占用时隙类所需时间的118%。像以前一样，我们只需在类定义中添加一行就可以明显提高性能。</p><p id="1ed7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">分槽类不仅在代码执行速度方面更好，而且在内存使用方面也更好。事实上，在本例中，添加<code class="fe mv mw mx my b">__slots__</code>将实例大小减少了1/3。注意，使用<code class="fe mv mw mx my b">pympler.asizeof</code>模块中的<code class="fe mv mw mx my b">asizeof()</code>函数比内置的<code class="fe mv mw mx my b">__sizeof__()</code>方法更能让我们了解一个对象占用了多少内存。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="6fc9" class="lx ly it my b gy nd ne l nf ng">print(f'Slotted: {asizeof(SlottedInstance)}')<br/>print(f'Non-Slotted: {asizeof(NonSlottedInstance)}')</span><span id="bf4a" class="lx ly it my b gy nh ne l nf ng">Slotted:     112<br/>Non-Slotted: 328</span></pre><p id="9ea6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过在类的开头添加<code class="fe mv mw mx my b">__slots__</code>实现了三倍的内存使用优化，太棒了！让我们试试更重的课程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="45d9" class="lx ly it my b gy nd ne l nf ng">Slotted: 440<br/>Non-Slotted: 904</span></pre><p id="7e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使在这个测试中，时隙类也比非时隙类表现出色2倍。</p><h1 id="c492" class="ni ly it bd lz nj nk nl mc nm nn no mf jz np ka mi kc nq kd ml kf nr kg mo ns bi translated">结论</h1><p id="81fe" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">总而言之，很明显<code class="fe mv mw mx my b">__slots__</code>极大地提高了Python程序的性能，无论是在速度还是内存使用方面。每当你不需要添加或删除实例属性时，你应该总是使用槽类，我不明白你为什么要这样做。</p><p id="7f3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使优化并不总是至关重要的，特别是对于测试或概念验证，自由时间和空间优化肯定不会有什么坏处。然而，使用分槽类的真正好处在生产代码中是显而易见的，在生产代码中，只需在Python类中添加一行代码，就可以获得明显更好的性能。</p><p id="e3a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么这不是Python中的默认行为？我个人不知道，但这背后一定有原因。也许他们只是想让这种语言开箱即用，尽可能灵活。</p><p id="7394" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。感谢阅读！</p><p id="c049" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对Python的进一步性能优化感兴趣，我强烈建议您看看下面的故事:</p><div class="nt nu gp gr nv nw"><a rel="noopener  ugc nofollow" target="_blank" href="/speed-up-your-python-codebases-with-c-extensions-94859875eb70"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">用C扩展加速你的Python代码库</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">给你的Python程序带来C语言的速度</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">better编程. pub</p></div></div><div class="of l"><div class="og l oh oi oj of ok ks nw"/></div></div></a></div></div></div>    
</body>
</html>