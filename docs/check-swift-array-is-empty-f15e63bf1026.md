# 检查 Swift 数组是否为空:最佳实践回顾

> 原文：<https://betterprogramming.pub/check-swift-array-is-empty-f15e63bf1026>

## 看哪个更快，是空的还是？计数== 0

![](img/83ea599b4245db335655393636a1ecc2.png)

奥利弗·科尔在 [Unsplash](https://unsplash.com/s/photos/empty?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上的照片

假设你是一家软件开发公司的本科生暑期实习生，你刚刚开始学习 Swift 编程，你写了一些如下这样的代码。

幸运的是(或者不幸的是)，你的代码被你的团队领导，一位资深的 iOS 开发者，在你每周与他一对一的会议中审查了。

当他看到这几行代码时，他开始微笑，并说:“从技术上讲，你的代码是正确的，这是毫无疑问的。然而，这不是最佳做法，”低声说道。

他立刻停止了说话，转向你，等着轮到你问为什么。虽然他迫不及待地分享了一些见解(也就是某种定义上的炫耀)，但他不得不假装平静，毕竟他是一名高级开发人员。

你开始有点皱眉，让自己看起来很困惑(你最好这样做，因为这可能是你的主管所期待的)，然后你问:“你能澄清一下你所说的最佳实践是什么意思吗？”

他对这个问题非常满意，通过你的眼镜，他看到了一双渴望知识、洞察力和专业技能的眼睛。

“嗯，要检查一个数组是否为空，应该直接访问`isEmpty`属性，复杂度为 O(1)。但是，如果您访问`count`属性，它将导致整个数组的迭代，以找出数组的元素数，这是 O(n)复杂度。”

他说话时一直在点头。“也就是说，对您的问题的简短回答是，最佳实践是使用`isEmpty`，而不是将`count`属性与 0 进行比较。”

他说话的时候，你跟他一样的步调不停的点头(这么多行为技巧要学……)。当他讲完后，你问:“为什么访问`isEmpty`是 O(1)运算？”

他给你解释了，虽然你其实不是很懂。您的对话继续进行，并就此话题提出了更多的后续问题。你整整一个小时的会议就是用来讨论这个的。

当你离开他的办公室时，你看起来仍然很困惑，因为有太多的新信息涌入。尽管如此，您学到了一些重要的东西:使用`isEmpty`而不是`count == 0`来检查数组是否为空— *最佳实践*！

然而，当你回到办公室坐下时，你开始怀疑`isEmpty`是否总是胜过`count == 0`。

由于 Xcode 就在您面前，您决定运行一些简单的实验来比较这两种方法的性能。毕竟数据不会骗你！

# 模拟结果

下表显示了模拟结果。用于产生结果的代码可以在 GitHub 上找到[。](https://gist.github.com/ycui1/0cdd666d11556530c238ee2176ffe604)

发生的事情是，创建了一系列整数数组，元素的数量从 0、1、10 一直到 10，000，000。

对于每个操作，`count == 0`和`isEmpty`，它运行 10，000 次以生成可靠的性能时间。

对于各种阵列类型，两种方法的性能相似

令人惊讶的是，您发现即使数组中有 1000 万个整数,`isEmpty`也没有胜过`count == 0`。

显然，这些结果不支持您的主管告诉您的关于访问`count`属性的 O(n)复杂度与访问`isEmpty`属性的 O(1)复杂度的对比。

你对结果不太确定，又做了一次实验。尽管如此，还是获得了类似的结果。

因此，您进一步对数组`String`和`Dictionary`进行了比较。同样，两种方法的性能相当。

这些结果似乎支持了是否使用`isEmpty`或`count == 0`来检查数组是否为空并不重要，因为两者速度一样快。

# 说明

虽然你的上司的辩解听起来是对的，但当你看到这些结果时，你不得不怀疑为什么会发生这种事。

在这里，我试着给出我的解释，可能不全面。因此，如果你有什么想说的，请随时留下你的评论。

从[官方文档](https://developer.apple.com/documentation/swift/array/1688398-isempty)中可以很清楚地看出，访问`isEmpty`属性是一个 O(1)操作，这一点我们毫无疑问。

如上所示，模拟结果支持这样的观点，即`count == 0`的性能与`isEmpty`相当，这表明访问 count 属性也是一个 O(1)操作。可能吗？

答案是肯定的。但是为什么呢？这仅仅是因为`Array`符合 [RandomAccessCollection](https://developer.apple.com/documentation/swift/randomaccesscollection) 协议。下面是来自官方文档的该协议的概述。

> 随机访问集合可以将索引移动任意距离，并在 O(1)时间内测量索引之间的距离。
> 
> 因此，随机访问和双向收集之间的根本区别在于，依赖于索引移动或距离测量的操作可以显著提高效率。
> 
> 例如，随机访问集合的 count 属性在 O(1)中计算，而不需要迭代整个集合。

从最后一句可以看出，它清楚地说明了随机访问集合的`count`属性是 O(1)运算。

因为对于作为随机访问集合的`Array`来说，`count`和`isEmpty`属性都是 O(1)操作，所以我们应该期望，为了检查数组是否为空，`count == 0`和`isEmpty`方法具有相似的性能。

# 快速旁注

与当前讨论相关的是检查`Set`和`String`是否为空的正确方法。

我可以告诉你`Set`的`count`属性是[官方文档](https://developer.apple.com/documentation/swift/set/3018378-count)中所说的 O(1)运算。因此，使用`count == 0`和`isEmpty`检查`Set`是否为空没有明显的区别。

但是，`String`作为一个字符集合不符合上述 RandomAccessCollection 协议，使其`count`属性成为 O(n)运算。

因此，使用`isEmpty`来检查`String`是否为空，而不是使用`count == 0`，这确实是最佳实践。

# 结论

许多 Swift 程序员，尤其是资深程序员，可能会有这样的印象:使用`isEmpty`是确定数组是否为空的最佳实践。

然而，这里提供的数据支持`count == 0`有可比的性能。因此，当快速数组被检查为空时，没有坚实的理由反对使用`count == 0`。