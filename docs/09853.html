<html>
<head>
<title>Reconstructing an API Specification Through Observation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过观察重构API规范</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/reconstructing-an-api-specification-through-observation-d7bd7b0e5b6d?source=collection_archive---------7-----------------------#2021-10-21">https://betterprogramming.pub/reconstructing-an-api-specification-through-observation-d7bd7b0e5b6d?source=collection_archive---------7-----------------------#2021-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ee4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过观察请求来构建安全的API</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ec9898e200fa0606493e626aa251447a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hvKedvZE2r3dGzyY"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@nejc_soklic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nejc sokli</a>拍摄的照片</p></figure><p id="b44b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API在现代微服务架构中无处不在。它们使得从外部应用程序消费数据变得容易，并减少了开发人员需要编写的代码量。总的结果是更容易交付有用的软件产品。然而，API的流行意味着它们代表了一个很大的攻击面。事实上，<a class="ae ky" href="https://www.gartner.com/en/webinars/4002323/api-security-protect-your-apis-from-attacks-and-data-breaches" rel="noopener ugc nofollow" target="_blank"> Gartner预测</a>到2022年，API攻击将成为企业web应用程序最常见的攻击媒介。同样，IBM的一份报告发现三分之二的数据泄露可以追溯到错误配置的API。</p><p id="8af8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，企业需要采取主动的方法来确保他们对API的使用是安全的。不幸的是，由于现代应用程序的复杂性、第三方代码依赖性和文档的缺乏，API可观察性是一个巨大的挑战。通常，企业对于他们的生产应用程序没有任何API规范。因此，与安全相关的错误配置未被发现，应用程序在生产中使用各种不推荐的“僵尸API”和未记录的“影子API”。</p><p id="f3bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决这个问题的基本第一步是创建一个API规范，并用它来审计和记录您的应用程序使用的API。理想情况下，我们可以简单地通过观察真实应用程序中的API流量来创建API规范。在过去，没有简单的、可伸缩的、开源的工具能够做到这一点。现在，我们有了<a class="ae ky" href="https://apiclarity.io/" rel="noopener ugc nofollow" target="_blank">API clarity</a>——一个用于Kubernetes (K8s)集群的开源API流量可见性工具。它是专门为解决这一差距而构建的，并支持通过观察进行API重构。</p><p id="fdda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我们将看看什么是API重构以及APIClarity如何解决API可观测性问题。然后，我们将通过一个在K8s上运行的基于微服务的应用程序来使用APIClarity的实际例子。</p><h1 id="22e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">API重构的重要性</h1><p id="ffaf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">简而言之，API重构就是通过观察进出API的流量来构建API规范。如果做得好，API重构可以让您了解微服务使用的API，并使您能够评估API安全风险。一旦建立了规范，相同的工具可以将运行时流量与规范进行比较，以检测偏差。</p><p id="a0a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">API规范的关键组成部分包括:</p><ul class=""><li id="3cde" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">参数检测(路径、头参数、查询参数、请求体参数和cookies)</li><li id="55b5" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">对象引用</li><li id="10fa" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">文件传输</li><li id="210b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">安全性定义</li></ul><p id="788e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理想情况下，API重建工具需要以符合OpenAPI规范(OAS)的格式量化这些组件，而不会给应用程序带来不必要的开销或复杂性。在APIClarity之前，有几个工具部分解决了API重构用例，但是没有全面的开源解决方案。其他一些API可见性工具包括:</p><ul class=""><li id="0f92" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">Optic  —一个可扩展的、与语言无关的开源工具。它对于在部署之前记录、审查和批准API很有用。</li><li id="5915" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://swagger.io/tools/swaggerhub/" rel="noopener ugc nofollow" target="_blank"> SwaggerHub </a> —一个将API流量转换为OAS的流行工具。</li><li id="bb0b" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated"><a class="ae ky" href="https://www.cloudvector.com/api-shark/" rel="noopener ugc nofollow" target="_blank"> CloudVector API Shark </a> —可以监控多服务环境，并根据运行时流量生成OAS规范。</li><li id="48f8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">Imvision  —用于多服务环境的强大API可见性和文档工具。</li></ul><p id="af42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Optic不是为监视多服务环境而构建的，SwaggerHub也没有与运行时环境集成。API Shark和Imvision都不是开源的。上述工具都不能完全满足API重构的需要。</p><h1 id="b29b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">APIClarity如何解决API重构和可见性挑战</h1><p id="ef95" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">APIClarity填补了其他工具留下的空白，提供了一个健壮的、开源的、可扩展的多服务API可见性和重构解决方案。它可以使用服务网格框架轻松集成到现有环境中。使用APIClarity，开发人员可以导入一个API规范或者根据观察重新构建一个API规范。开发人员还可以实时监控所有API流量，无需更改代码或工作负载。</p><p id="58b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，它是如何工作的呢？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/56ff8c9a7e0e15037440e2c8465dff4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lwt8puO4A6il-mFw.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://github.com/apiclarity/apiclarity/blob/master/diagram.jpg" rel="noopener ugc nofollow" target="_blank">图像来源</a></p></figure><ul class=""><li id="78f2" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">APIClarity部署在现有的K8s集群中</li><li id="30a1" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">API流量从集群中的pod镜像到APIClarity的OpenAPI规范引擎</li><li id="e4c8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">规范引擎监控内部和外部流量，并记录API事件</li><li id="503a" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">APIClarity基于API流量学习规范并构建API规范</li><li id="0afd" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">用户审阅、编辑和批准规范</li><li id="81e8" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">APIClarity提醒用户注意安全问题，或者观察到的API和批准的API规范之间是否存在任何偏差</li></ul><h1 id="3482" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">APIClarity在行动:一个演练</h1><p id="c972" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们知道了什么是APIClarity，让我们深入我们的教程，看看它在K8s集群和基于微服务的应用程序中的运行情况。在这里，我们将:</p><p id="49db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)在我们的K8s集群中部署<a class="ae ky" href="https://microservices-demo.github.io/" rel="noopener ugc nofollow" target="_blank"> Sock Shop app </a>。虽然我们将使用Sock Shop作为我们的示例应用程序，但是您可以将自己的应用程序部署到您的集群中，并继续使用。<br/> 2)在我们的K8s集群中部署APIClarity并配置监控<br/> 3)观察APIClarity仪表板上的API流量<br/> 4)查看并创建API规范，并查看生成的Swagger格式的OpenAPI规范。<br/> 5)识别与API规范的偏差以及影子和僵尸API的使用。<br/> 6)查看和过滤API事件</p><h2 id="6b28" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">先决条件</h2><p id="e830" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要跟进，您需要:</p><ul class=""><li id="7a0d" class="ms mt it lb b lc ld lf lg li mu lm mv lq mw lu mx my mz na bi translated">定义了缺省值<code class="fe nt nu nv nw b">StorageClass</code>的Kubernetes集群</li><li id="86fc" class="ms mt it lb b lc nb lf nc li nd lm ne lq nf lu mx my mz na bi translated">Istio 1.10或更高版本，安装在集群上</li></ul><p id="c200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您的K8s集群可以部署在您喜欢的任何平台上，包括minikube。虽然APIClarity支持代理API流量的多个集成，但您需要<a class="ae ky" href="https://istio.io/latest/docs/setup/getting-started/#download" rel="noopener ugc nofollow" target="_blank">下载并安装Istio </a>。</p><h2 id="5dde" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">在K8s集群中部署Sock Shop应用程序</h2><p id="c7a0" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们将使用流行的<a class="ae ky" href="https://microservices-demo.github.io/" rel="noopener ugc nofollow" target="_blank"> Sock Shop微服务应用</a>作为我们的测试应用。通过14个不同的微服务和一个交互式前端，这是在K8s集群中测试API流量的一个很好的方法。</p><p id="61f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)创建<code class="fe nt nu nv nw b">sock-shop</code>名称空间。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="0db8" class="nh lw it nw b gy ob oc l od oe">kubectl create namespace sock-shop</span></pre><p id="8e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)为<code class="fe nt nu nv nw b">sock-shop</code>名称空间启用Istio注入。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="4002" class="nh lw it nw b gy ob oc l od oe">kubectl label namespaces sock-shop istio-injection=enabled</span></pre><p id="230f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)在集群中部署Sock Shop演示应用程序。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="02de" class="nh lw it nw b gy ob oc l od oe">kubectl apply -f <a class="ae ky" href="https://raw.githubusercontent.com/microservices-demo/microservices-demo/master/deploy/kubernetes/complete-demo.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/microservices-demo/microservices-demo/master/deploy/kubernetes/complete-demo.yaml</a></span></pre><p id="2558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)获取<code class="fe nt nu nv nw b">front-end</code>服务的节点端口。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="fe68" class="nh lw it nw b gy ob oc l od oe">kubectl describe svc front-end -n sock-shop | grep NodePort:</span></pre><p id="88f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出应该如下所示:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="7da3" class="nh lw it nw b gy ob oc l od oe">NodePort:                 &lt;unset&gt;  30001/TCP</span></pre><p id="7403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5)在浏览器中连接到<code class="fe nt nu nv nw b">http://&lt;node_IP&gt;:&lt;NodePort&gt;</code>。使用我们上面的例子，如果我们的节点的IP是192.168.49.2，浏览到<code class="fe nt nu nv nw b">http://192.168.49.2:30001</code>。如果不知道自己节点的IP，可以用<code class="fe nt nu nv nw b">kubectl get nodes -o yaml</code>或者<code class="fe nt nu nv nw b">minikube ip</code>来验证。如果一切正常，袜子店演示应用程序应该加载。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/0622dfb8ac5e9fde637aeab423e1dc9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UTxbesB-3TnNMjdU.png"/></div></div></figure><h2 id="232c" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">在我们的K8s集群中部署APIClarity并配置监控</h2><p id="eca9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们需要在集群中部署APIClarity。</p><p id="65f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)我们首先将GitHub存储库克隆到我们的主目录:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="436b" class="nh lw it nw b gy ob oc l od oe">cd ~<br/>git clone <a class="ae ky" href="https://github.com/apiclarity/apiclarity" rel="noopener ugc nofollow" target="_blank">https://github.com/apiclarity/apiclarity</a></span></pre><p id="04b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)接下来，导航至<code class="fe nt nu nv nw b">apiclarity</code>目录。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="9dfb" class="nh lw it nw b gy ob oc l od oe">cd apiclarity</span></pre><p id="9639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)使用<code class="fe nt nu nv nw b">kubectl</code>部署APIClarity。使用默认的apiclarity.yaml，名称空间将是<code class="fe nt nu nv nw b">apiclarity</code>。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="6483" class="nh lw it nw b gy ob oc l od oe">kubectl apply -f deployment/apiclarity.yaml</span></pre><p id="0e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)确认pod正在运行。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="8736" class="nh lw it nw b gy ob oc l od oe">kubectl get pods -n apiclarity</span></pre><p id="53ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出应该如下所示:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="bd49" class="nh lw it nw b gy ob oc l od oe">NAME                          READY   STATUS    RESTARTS   AGE<br/>apiclarity-679949b687-x25pb   1/1     Running   0          16m<br/>apiclarity-postgresql-0       1/1     Running   0          16m</span></pre><p id="1598" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5)初始化并更新<code class="fe nt nu nv nw b">wasm-filters</code>子模块:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="e238" class="nh lw it nw b gy ob oc l od oe">git submodule init wasm-filters<br/>git submodule update wasm-filters</span></pre><p id="e944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6)导航到<code class="fe nt nu nv nw b">wasm-filters</code>文件夹:</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="a663" class="nh lw it nw b gy ob oc l od oe">cd wasm-filters</span></pre><p id="9d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7)运行wasm <code class="fe nt nu nv nw b">./deploy.sh</code>脚本，以便特使wasm过滤器可以捕获来自我们袜子店的流量。该脚本接受多个名称空间作为输入参数，例如<code class="fe nt nu nv nw b">./deploy.sh &lt;namespace_one&gt; &lt;namespace_two&gt; &lt;namespace_three&gt;</code>，但是对于这个演示，我们只需要指定<code class="fe nt nu nv nw b">sock-shop</code>名称空间。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="2cac" class="nh lw it nw b gy ob oc l od oe">./deploy.sh sock-shop</span></pre><p id="0791" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">8)为APIClarity配置端口转发。</p><pre class="kj kk kl km gt nx nw ny nz aw oa bi"><span id="3c38" class="nh lw it nw b gy ob oc l od oe">kubectl port-forward -n apiclarity svc/apiclarity 9999:8080</span></pre><p id="6253" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">9)使用网络浏览器连接到<code class="fe nt nu nv nw b"><a class="ae ky" href="http://localhost:9999." rel="noopener ugc nofollow" target="_blank">http://localhost:9999</a></code> <a class="ae ky" href="http://localhost:9999." rel="noopener ugc nofollow" target="_blank">处的APIClarity GUI。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/9737d3333b615404d8f5e8f12e179808.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0z3KcTjgAGnrIpPk.png"/></div></div></figure><h2 id="c8e2" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">观察APIClarity仪表板上的API流量</h2><p id="b28b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，是时候产生流量了。首先点击袜子商店应用程序中不同的按钮和菜单。</p><p id="62b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">亲提示:API流量越多越好！更多流量=更多观察=更深入的可见性。对于我们演示的这一部分，我们只需要一点点流量，但是在生产中要记住这个原则。</p><p id="3ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Sock Shop中生成一些API流量后，返回到APIClarity仪表板。您会注意到APIClarity记录了所有不同的API调用。在下面的例子中，我们可以看到对<code class="fe nt nu nv nw b">catalogue</code>端点的17次调用，对<code class="fe nt nu nv nw b">carts</code>的8次调用，以及对<code class="fe nt nu nv nw b">user</code>的3次调用。我们还可以看到APIClarity是如何开始绘制API使用情况的。在我们产生更多的流量和创建我们的API规范之后，这些图表将变得更加有趣和有用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/56bba3753ff03bdfa4a7ac0db3ae5ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z_YGjDzPI19dY3Wk.png"/></div></div></figure><h2 id="7d8a" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">在Swagger中查看和创建API规范并查看文档</h2><p id="d671" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在，让我们根据我们拥有的相对较小的流量创建一个API规范。</p><p id="aab8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1)单击“最常用的API”之一我就用<code class="fe nt nu nv nw b">catalogue</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/0a415091979119813da8aad4e08f7f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4of0owzaNedzRQGn.png"/></div></div></figure><p id="5727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2)单击“重建”选项卡，然后单击“查看”</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/a7f0b7dd5cc6c0f761fe81cf1535ffda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YGO-BPb1HP5LZfFh.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/dcd26d3a5d8b2381ee1a95a7036558e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z8DkrQrQjN2E7a5P.png"/></div></div></figure><p id="32ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3)在这里，我们可以查看API路径、添加参数和合并条目。我将添加一个<code class="fe nt nu nv nw b">example_param</code>并审核和批准路径。在这里，你可以随意试验你的选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e353bcf8624b2c79ce4f788eaf61c214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BouEGsKgXvPIpp2y.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/030bb7b24f24e2944fef7355ca39dbe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j677aUpGYK9A9uks.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ac8c48433b08b15d87bf61cea3f48a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A_Nbb5cnTEgjIz8v.png"/></div></div></figure><p id="368b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4)现在，我们有了一个OAS API规范。我们可以直接从APIClarity GUI中查看Swagger中的API文档。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2d21446fb782dc15d7d5d7bd023b77ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0sKPyBn1MT_KRWql.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2263b8a306408567dbc1e9f67ea2129a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eUWJT24SaHN1Z4Or.gif"/></div></div></figure><h2 id="ee74" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">识别与API规范的偏差</h2><p id="6baf" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">现在我们有了一个API规范作为基线，APIClarity可以标记与规范的偏差，以帮助检测安全问题和隐藏API。要了解其工作原理，请返回到Sock Shop GUI并进行更多的实验。单击一些您上次没有使用的功能或过滤器。如果您创建了订单，请将其删除。这里的关键是执行一些规范中没有的动作。这些将被标识为“差异”</p><p id="7d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这里我对不符合我的规范的<code class="fe nt nu nv nw b">catalogue</code>端点进行了多次调用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/e8f146eed635268d4bb6a9be259d22fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RFGW0jJ8ErRBO4jG.png"/></div></div></figure><p id="b7c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过单击一个特定的差异来深入查看，并查看与规格有什么不同。这里我们可以看到检测到偏差，因为我的API调用缺少一些参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/feaac54f1461ac53f9b745a3fda76df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-m0AEIC-HWJrSXiY.gif"/></div></div></figure><p id="eaed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个有文档记录的API调用的例子，其参数不同于规范。但是，如果API调用根本没有记录在规范中呢？在这种情况下，APIClarity会将其标记为影子API。</p><p id="4385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是这个API调用<code class="fe nt nu nv nw b">carts</code>路径所发生的情况。在我们创建规范的时候，我们只观察到一个GET和一个POST，所以这就是文档记录的内容。因此，删除调用超出了规范，被标记为影子API。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/74d1eff126a79c6dd7bc57574a500004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gEus9hDCwdOCdG6J.gif"/></div></div></figure><p id="7b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所料，这是一个合法的API调用，我应该记录下来。这个场景为我们提供了一个实际的例子，说明为什么在创建API规范之前让APIClarity捕获大量流量是有用的。</p><h2 id="3d77" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">查看和过滤API事件</h2><p id="d6b8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们还可以用APIClarity查看和过滤API事件。</p><p id="5612" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看事件，请单击事件图标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/28cde56ecf1bcbae8cb149aabb7186cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rAI2UHl285C0aVJV.png"/></div></div></figure><p id="cdfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，您将看到给定时间段内所有API事件的详细列表(“最后一天”是默认值)。我们还可以深入查看单个事件，就像我们在控制面板中所做的那样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/d6a57b477c70194952df13de9d556d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kt158EtmEsEEmzQb.gif"/></div></div></figure><p id="033f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您可以应用高级过滤器来搜索特定的API事件。例如，我们可以通过应用<code class="fe nt nu nv nw b">Spec of type is shadow</code>过滤器来创建APIClarity观察到的所有影子API调用的列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/1ca92b81a67f28121aac7726e9b43abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IReKj8hy5sbazc3X.gif"/></div></div></figure><p id="50e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">僵尸API的检测也是类似的。我们将修改过滤器来寻找<code class="fe nt nu nv nw b">Spec of type is zombie</code>。如果我们的一个调用是对规范中一个不推荐的API的调用，那么我们会在这里看到它。</p><p id="acc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以混合搭配过滤器和排序结果，以实现各种不同的视图。这样，您就可以深入应用程序中的API事件。</p></div><div class="ab cl of og hx oh" role="separator"><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok ol"/><span class="oi bw bk oj ok"/></div><div class="im in io ip iq"><h1 id="62ca" class="lv lw it bd lx ly om ma mb mc on me mf jz oo ka mh kc op kd mj kf oq kg ml mm bi translated">最后的想法</h1><p id="019f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">作为一个<a class="ae ky" href="https://github.com/apiclarity/apiclarity" rel="noopener ugc nofollow" target="_blank">开源项目</a>，APIClarity继续发展并接受来自开发者社区的贡献。</p><p id="d1bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这个演练！这里我们只是触及了表面，对于APIClarity的API重构和流量监控有几个有趣的用例。除了提高API的可见性和安全性，它还支持模糊测试、客户机/服务器代码生成以及改进内部和面向用户的文档等用例。</p></div></div>    
</body>
</html>