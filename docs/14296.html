<html>
<head>
<title>3 Tips to Write Good Unit Tests for Your Team</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为你的团队编写好的单元测试的3个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-tips-to-write-good-unit-tests-for-your-team-65df94acfc79?source=collection_archive---------0-----------------------#2022-11-26">https://betterprogramming.pub/3-tips-to-write-good-unit-tests-for-your-team-65df94acfc79?source=collection_archive---------0-----------------------#2022-11-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4122" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你的测试失败了。又来了？没有窃听器。您更改了一个实现细节，您的应用程序仍然工作，但是您的测试被破坏了。单元测试没有价值吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6a84b6fb3756777fdf9f819746bde5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j-PzAaxNWusP656u"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的battle creek咖啡烘焙师拍摄</p></figure><p id="11ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">软件工程师讨厌编写单元测试。</p><p id="7dd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管单元测试有多烦人，我们都知道单元测试有利于创建一个健壮的、功能良好的系统。它是自动化测试中最有价值的类型之一。</p><p id="c42a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，单元测试是测试函数行为的自动化测试方法。</p><p id="a88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试应该独立于其他测试结果。它们应该能够在任何平台或机器上运行。你应该能够在你母亲的计算机上运行你的单元测试可执行文件，即使它还没有连接到互联网。</p><p id="e45b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你是一名软件工程师，你可能会接触到一个单元测试系统。即使您在运行测试套件后得到一个绿色的复选标记，也需要正确地创建测试套件，否则会导致假阳性。</p><p id="e779" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多团队需要学习如何进行适当的单元测试；有些人看不到创造它们的价值。例如，许多工程师只测试函数的快乐路径，但需要考虑不快乐或复杂的测试用例。</p><p id="dd1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论编写一个好的单元测试的最佳实践和陷阱，这样你的团队就可以获得单元测试的所有好处。</p><h1 id="9050" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">基于行为而不是实现来编写测试套件</h1><p id="014c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">测试维护是团队尝试采用单元测试的主要障碍之一。</p><p id="b013" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工程师经常被惹恼；当测试套件太脆弱时，开发会变得非常缓慢，当他们稍微改变或重构代码库时，就会失败。</p><p id="44a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由代码库或重构的微小变化导致的测试套件中断代表脆弱的还是健壮的测试套件？</p><p id="49a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">答案是视情况而定</em>。</p><p id="78f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于实现的测试使得测试套件很难维护。此外，仅仅通过试图改变实现细节，您将会得到错误的否定。</p><p id="2414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者更糟的是，您会生成误报，当您破坏应用程序代码时，这可能不会失败。</p><p id="a026" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当涉及到单元测试时，您应该防止它们与您正在测试的代码的内部过于耦合。这样，测试对变化更有弹性，允许开发人员在需要时调整内部实现和重构，同时提供有价值的反馈和安全网。</p><p id="0636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过测试行为而不是实现，您可以重构代码以进行改进，并通过运行您的测试来立即验证您是有意还是无意地改变了它的行为方式。</p><p id="6fe5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您创建了一个随机服务，它有一个返回下一个随机字符串的<code class="fe mt mu mv mw b">getNext</code>函数:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="c5f8" class="nb lw it mw b be nc nd l ne nf">trait Random { def getNext(): String}</span></pre><pre class="ng mx mw my bn mz na bi"><span id="4b58" class="nb lw it mw b be nc nd l ne nf">class RandomImpl(state: State) extends Random { <br/>  override def getNext(): string = state.getNext(100) // get the next random in the state class with 100 as the initial value <br/>}</span></pre><pre class="ng mx mw my bn mz na bi"><span id="545e" class="nb lw it mw b be nc nd l ne nf">"getNext" should { <br/>  "returns the correct string" in { <br/>    val mockState = mock[State] <br/>    val implementation = new RandomImpl(mockState) <br/>    val next = implementation.getNext() (mockState.getNext(100)).returns("hello") <br/>    next should equal("hello") verify(mockState.getNext(100), times(1)) <br/>  } <br/>}</span></pre><p id="3e7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将我们的单元测试暴露给<code class="fe mt mu mv mw b">getNext</code>的实现，而不是<code class="fe mt mu mv mw b">getNext</code>的结果(行为)。</p><p id="8604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在迪士尼流媒体服务开发支付应用系统时，我们的团队要求对我编写的每个功能进行单元测试。我意识到其中一个工程师会为一个实现编写300多个测试套件。虽然看起来我们覆盖了许多分支，但是每个重构或者实现中的小变化都会破坏一些测试套件。每一个新的特性变化和修补程序对开发者来说都是一场噩梦。这些测试提供的价值很小，因为每个代码库的改变也需要改变现有的测试套件。</p><p id="53bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一种防止实现测试的方法是采用测试驱动开发。</p><p id="790e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试驱动开发是在编写实现之前先编写测试的概念。该过程包括以下内容:</p><ul class=""><li id="9508" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">首先编写测试(基于您系统的行为)。这个测试一开始不能工作也不能编译。</li><li id="8a71" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">编写您的实现，然后确保您的测试变成绿色。</li><li id="670a" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">重构代码中的任何重复，而不需要再次接触测试——仅仅是让测试工作起来。</li></ul><p id="ec09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试套件不应该查看方法内部来了解它在做什么。如果您避免直接测试被调用的私有方法，将会有所帮助。如果您对发现您的私有代码是否被测试感兴趣，请使用代码覆盖工具。然而，稍后您会看到为什么良好的代码覆盖率不一定意味着健壮的应用程序。</p><p id="0ebe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑你的方法应该提供的行为和它可以遵循的分支。理想情况下，您应该测试所有的实现路线都展示了预期的行为。</p><p id="4832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当PM能够理解您的测试套件正在做什么时，您知道您的单元测试是基于行为而不是实现编写的。</p><p id="4293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个总的原则是看你的行为覆盖是否足够好。</p><h1 id="61d3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">测试不应该重复实现逻辑</h1><p id="46a3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个常见的错误是当我们想要测试的相同方法也在断言中使用时。</p><p id="4fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您不应该使用方法本身(或它使用的任何内部代码)来动态生成预期的结果。预期的结果应该被硬编码到您的测试用例中，以保持不变，即使实现发生了变化。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="eb65" class="nb lw it mw b be nc nd l ne nf">object Util { <br/>  def split(str: String): List[String] = str.split(",") <br/>} <br/><br/>"testing split method" in { <br/>  Util.split("ABC, def,") should equal to ("ABC, def," .split(",")) <br/>}</span></pre><p id="9bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是有问题的，因为测试代码几乎是实现代码的翻版。如果测试和实现都是同一个人写的，他们可能会在两个地方犯同样的错误。但是由于测试反映了实现，测试仍然可能通过，这将您置于一个可怕的境地:实现是错误的，但是测试欺骗了您，使您认为不是这样。</p><p id="6b87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，你应该争取高价值，低，努力测试。这意味着您将测试函数抽象为一个简单的单行程序，创建一个有用的通用测试，我们可以重复使用。</p><p id="dcf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当我们在Scala中测试JSON编码器和解码器时，我们可以创建一个泛型方法来调用encode和decode，以查看该模型是否与我们传入的原始模型相同。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="9e4e" class="nb lw it mw b be nc nd l ne nf">trait Test { <br/>  def encodeDecode[A:Encoder:Decoder](model:A) = { <br/>    decode[A](model.asJson).map{_ should equal(model)} <br/>  } <br/>}</span></pre><p id="8676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个关键的好处是减少了测试套件中重复代码的数量。因为通常，当我们需要改变测试中的某些行为时，如果我们不将这些测试套件行为集中到一个中，我们可能会错过其中的一个。</p><h1 id="840a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">不要太关注代码覆盖率</h1><p id="2370" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">覆盖率非常有用，因为它让开发人员知道测试覆盖了他们代码的多少百分比。检查他们代码的哪些部分没有被单元测试覆盖也很方便。然而，拥有良好的覆盖率并不意味着你的测试是穷尽的。</p><p id="e7e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码覆盖率就像一个卫生因素。保健因素是一个元素，如果缺少了它，就会降低你作为开发人员的信心。</p><p id="6cb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该从一个“<em class="ms">玻璃半空</em>”的角度来看待代码覆盖率。</p><p id="cff9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用覆盖率来找到您的系统中仍然需要测试的部分。然后，确定您是否应该采取措施来覆盖错过的测试套件。</p><p id="8b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">认为逐行覆盖是“<em class="ms">的必要但不充分。</em>“想象一下，在尽可能懒惰的同时仍然实现完整的逐行覆盖，你会发现编写一组不充分的测试是多么容易。</p><p id="24e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">85%的覆盖率是很好的目标。<em class="ms">85%以上开始有收益递减。</em></p><p id="1276" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？因为达到100%的覆盖率需要开发人员引入一些复杂性——通过在代码中创建抽象，比如接口。</p><p id="f827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，代码覆盖率导致开发人员根据实现而不是行为来编写他们的单元测试。你会看到许多单元测试包含了太多多余的断言，因为他们希望代码覆盖率达到100%。</p><p id="ba47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以引入<a class="ae ky" href="https://www.geeksforgeeks.org/software-engineering-integration-testing/" rel="noopener ugc nofollow" target="_blank">集成测试</a>来确保所有的组件和部件都被正确连接，而不是添加更多的单元测试来膨胀您的整个测试套件。</p><p id="1a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我经常看到团队试图对代码库或主流程的入口点进行单元测试，并模仿其他所有依赖项，因为他们想要达到100%的代码覆盖率。然而，主功能或主流程最好不要进行单元测试，而是进行集成测试。将您的控制器和服务视为一个黑盒，并运行一些集成测试，以确保所有的依赖交互都正确运行。</p><p id="c50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">单元测试只同时测试一个代码单元，但是产品代码与许多其他编码组件交互。因此，将您的单元测试与另一个自动化测试结合起来总是一个好主意，以确保bug不会被引入到生产环境中。</p><h1 id="df88" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="5a14" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每个人都可以写一个单元测试。然而，编写一个好的单元测试是复杂的。它需要耐心和对您想要创建这样一个测试套件的内容和原因的整体理解。</p><p id="7d39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一般的经验法则，你应该测试你的函数和系统的行为，而不是实现。把你的功能当作一个黑盒。创建一个存根并关注函数的输出。</p><p id="c5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在编写单元测试时保持干燥，并在测试套件中保持业务逻辑的一致性。抵制让你的测试变得花哨的冲动。让它们非常简单，你的测试套件将会是最好的。</p><p id="238c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，减少对代码覆盖率的关注。它是一个很好的工具，可以告诉你应该考虑哪些方法。然而，追求100%的代码覆盖率会导致开发过程变慢，并使您的代码库变得不必要的复杂。</p><p id="171d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你发现哪些方法、最佳实践和原则对编写单元测试有用？请在下面评论它们！</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="0bfc" class="lv lw it bd lx ly oc ma mb mc od me mf jz oe ka mh kc of kd mj kf og kg ml mm bi translated">关于单元测试的更多资源</h1><ul class=""><li id="2edb" class="nh ni it lb b lc mn lf mo li oh lm oi lq oj lu nm nn no np bi translated">13个有用的单元测试技巧(<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/13-tips-for-writing-useful-unit-tests-ca20706b5368">链接</a>)</li><li id="bbe0" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">如果您想以正确的方式了解更多关于单元测试的知识，请查看Katrina Owen关于单元测试的介绍(<a class="ae ky" href="https://vimeo.com/68730418" rel="noopener ugc nofollow" target="_blank">链接</a></li></ul><p id="094a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">原载于2022年11月26日</em><a class="ae ky" href="https://pathtosenior.substack.com/p/how-to-write-a-great-unit-test-with" rel="noopener ugc nofollow" target="_blank"><em class="ms"/></a><em class="ms">。</em></p></div></div>    
</body>
</html>