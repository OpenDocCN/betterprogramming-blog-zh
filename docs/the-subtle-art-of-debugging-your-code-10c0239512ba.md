# 调试代码的微妙艺术

> 原文：<https://betterprogramming.pub/the-subtle-art-of-debugging-your-code-10c0239512ba>

## 以及如何不受挫折地掌握它

![](img/099369ec21c28a9161fa9a03dd8213ef.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由 [James Wainscoat](https://unsplash.com/@tumbao1949?utm_source=medium&utm_medium=referral) 拍摄

计算机科学中有一个最终且不可避免的事实:机器只会做我们要求的事情。直接的后果是，如果有一个失败点，那么它必须是我们，人类。

对自己诚实的确是成熟和谦逊的一大标志。但是对于一个程序员来说，这样的品质是一种强烈的需求。它是软件开发的基础。如果不承认我们可能出错，我们将无法调试任何一行代码。永远不会。

# 知道诀窍

一个熟练的游戏玩家和一个新手有着非常不同的风格。同样的，一个高级程序员通常有一个非常有效的思维模式，在很短的时间内解决问题——而大多数时候，初级程序员仍然没有任何想法。

经验是关键，但也要谦虚和沉稳的神经。即使是大三学生，如果知道窍门，也有很高的几率有效追踪 bug。

## 你错了，就是这样

第一步也是最重要的一步是认识到你错了。正确的态度可以创造奇迹。在决定在哪里，做什么，为什么之前，冷静你的神经，冷却你的沮丧，让它沉淀下来:你错了。你把它编码了。机器只执行。虫子就在那里，藏在你的眼前。

## 让它繁殖

如果你不能重现 bug，那么你就不知道该做什么。没有“有时”，没有怀疑的余地，只有数学上的确定性。你必须能够以 100%的概率随心所欲地重现 bug。

注意:这并不意味着你理解了这个问题。目的是有一个清晰的方法来测试你在下面的分析中将要做出的假设。

## 阅读错误，全部阅读

许多程序员发现调试很无聊，所以他们跳到一个解决方案，使用试错法并对他们的代码进行随机修改。这不是调试，是随机探索！*散弹枪调试* (名副其实)跳过分析，只导致挫败感。由于我们没有读取堆栈跟踪，这给人一种移动更快且不浪费时间的错觉。

但是猜对的几率真的很低，试的越多越生气。感谢其他开发人员，我们得到了(希望如此)一个关于我们偶然发现的错误的完整信息堆栈。完整地阅读它会给出宝贵的提示:导致错误的行，哪里出错了，事情应该如何发展——加上失败点内外的一整套嵌套和嵌套调用。

有时这还不够，因为代码的语义可能处于更高或更低的层次。或者甚至可能没有错误跟踪，代码会无声无息地失败，这对开发人员来说是最可怕的噩梦之一。

## 分割和封闭

与编码中的许多其他事情一样，调试是一件孤立的事情。你必须找出问题并解决它。当我被问到 bug 在哪里，而我还没有分析它时，我通常会说，“如果我知道 bug 在哪里，就不会有 bug 了。”修理是容易的部分。

隔离至关重要。如果把和 bug 无关的都剪掉，剩下的确实是 bug。如果不是，很有可能你不是在追踪 bug，而是它的影子。我认为知道问题在哪里是解决 bug 的 80%。其余的通常非常简单，即使解决方案很复杂。

## 从你的错误中学习

这听起来像是老生常谈。但是当然，了解过去发生的事情可能对你未来有所帮助。

这里是你对自己了解的一切适合的地方。如果你是一个懒惰的家伙，也许看看复制粘贴。如果你知道你不喜欢某个特定的库、框架或 API，就从那里开始。如果您不喜欢阅读文档，那么这次可以适当地查看一下。对自己诚实。又来了。

## 诅咒，大笑，哭泣

你需要一个安全阀。您更喜欢什么并不重要:找到整个调试团队都满意的东西，让它摆脱挫败感。

调试是一项令人筋疲力尽的任务，由一连串的失败组成，直到你正确理解发生了什么，为什么会发生，以及如何让它不发生。为了保持低紧张度，吐出来！

# 你的思维缺陷，你的代码缺陷

切到具体点之后，对你来说还是没有任何意义。你的思想可能没有抓住重点，实际上是跳过了。

我们的大脑注定要追求一个目标。它总是试图培养和巩固假设，而不是承认错误和改变立场。以下大部分提示都是我们思维链中的薄弱环节。我们把注意力集中在意图上，而忽略了结构和语法。或者低估复杂的部分，只是假设它们很好。我们一直在这样做，当我们不太注意地检查代码时也是如此。因为大脑不想深入细节或浪费精力一遍又一遍地做同样的分析。

## 打字稿

现在的 ide 有一个集成的拼写检查器，这是有确切原因的。在没有帮助的日子里，最糟糕的错误来自数字 *1* 而不是字母 *l* 。最近，仍然会发生尾随的 *s* 被丢弃或者下划线、破折号或大小写问题。

你的大脑头脑中有一个清晰的意图和一个自动完成快速阅读插件，所以它猜测单词而不是实际阅读它们。底线:使用拼写检查，有意义的变量名，并尽可能自动完成。并选择合适的 IDE 使它们可用。

## 复制粘贴

瘟疫。无论是来自自我抄袭、堆栈溢出、学长的代码、现有的代码片段，还是任何符合你口味的东西:复制-粘贴总是有味道的，只是因为代码没有马上适合粘贴的地方。改编把一切都搞砸了。即使通过 CPD 工具和自愿应用 DRY 原则可以减少分解代码的机会，仍然有一些空间留给复制粘贴错误。

可能的话不要粘贴代码。如果有，前后再检查一遍。并且当你发现一个 bug 的时候，再检查两遍。最后但同样重要的是:你把所有的信任都放在你复制的代码的原作者身上。那他们一定是真的配得上。

## 参考与价值

有时候是编程语言在欺骗你。人们经常忘记，文字、变量和对象之间有很大的区别。大多数时候，对象是通过引用来访问和分配的，这可能会产生有趣的结果。记得自己大三的时候用缓冲对象填充循环缓冲区。糟透了。此外，这取决于语言。下流？

## 递归和循环

渴望或认为在威尼斯并不意味着在威尼斯。也许你们很亲近，有时候会被表象欺骗。但是当涉及到循环和递归时，总是对索引、顺序、终止子句持怀疑态度。意识到你离预期的指数只有一步之遥没什么特别的。或者索引完全错误，滚动另一个列表。或者甚至永远循环或者根本不循环。

## 准布尔

**If*从句往往过于简单，无法考察。但是布尔转换隐藏了太多的技巧！当你检查不是布尔型的东西的真实性时，会发生许多有趣的事情。取决于语言、空集合、负数、类型不安全转换——没人能确定。它们有时是真的，有时是假的。如有疑问，明确，投，直接查值。*

## *计时*

*有时代码会显示一个不稳定的 bug。无论你做什么，你都不能稳定地复制它。扪心自问，这是否与共享资源有关。他们的访问可能在时间上冲突。不要只考虑明显的 I/O 问题。这也可能发生在线程和任务访问元素列表、高速缓存管理等时。在这些情况下，强烈建议配对。调试点没有帮助(因为带有附加调试的执行有不同的计时)。此外，在这里而不是在那里记录日志可能会改变时间，产生破坏性影响。*

## *编码和加密*

*您的代码具有一些编码、解码或加密功能。如果结果不好，那么密切关注处理阶段。精确的字节数组和字符串非常微妙，甚至一个字节的错误都可能扰乱整个过程。如果有疑问，试着减少复杂性。在整个过程中仔细检查变量值。并再次阅读文档。最后，也许放弃一个关于堆栈溢出的问题。对于一个愚蠢的问题，得到一个令人不快的答案总比没有编码解码要好。*

## *遗留代码*

*显然，如果您在一个小时前编写它，代码会更适合这个任务。但是如果它是一个月前创作的，听起来可能有点陈旧。一年前，情况会更糟。最坏的情况:超过一年，作者不再在你的公司工作，没有规范和文档。真棒。也许你到处都能看到死代码。有一些有趣的部分，没人知道他们在做什么，但他们仍然在那里，因为“上次我们碰它时，所有东西都坏了，我们无法交付整整一周。”*

*在一些遗漏的重构、错误的使用、部分修改和误解的集成之后，bug 可能就在那里。勇敢而精确。别说了。慢慢来。也许重写，或者充分分析，使之成为你的。与其死于坏疽，不如成为腐烂手臂的前主人。*

## *现状核实*

*你确定这是正在执行的代码吗？这是我调试经历中最搞笑的时刻。你打电话给某人是因为“他们是追踪所有错误的聪明的开发者。”他们已经站在你身后五分钟了，嚼着饼干。他们刚刚加入这个过程，对上下文毫无概念，他们扔下一个炸弹:“你确定这真的来自你正在阅读的源代码吗？”*

*说真的，可能会有手动拷贝、错误编译、失败编译、分发、打包“悄悄”失败，以及导致您运行不同版本代码的其他多种原因。如果有这种可能，添加一些你可以很容易得到反馈的东西(著名的`printf("here")`)。当然在代码中你知道它是被执行的。只要意识到构建没有成功，你就可以省去十年令人兴奋的、无意义的假设和诅咒。*

# *太高，太低*

*给你的错误令人费解。您不知道它来自哪里，并且它很少或根本没有提到您的源代码。很有可能它并不直接出现在您的代码中，而是出现在以下偷偷摸摸的情况中。*

## *错误的配置*

*在某个地方，你正在破坏一个库、框架或者你所依赖的其他软件。有一些低的东西被一个(天真的)错误打破了。这太天真了，以至于写文档的人都无法预见。或者这个错误太天真，不值得一提。博士太无聊了，你只看了一半。长话短说，仔细检查外部依赖的引用。这次不要跳过医生。或者以防万一，提出一个关于堆栈溢出的问题。*

## *空白页*

*事情不会发生。你认为你做得很好。同样，你可能会天真地把它搞得一团糟，以至于你试图膨胀的所有东西都不起作用——没有堆栈跟踪，安静而优雅。是时候深入分析日志了。也许是为了(再次)正确地阅读文档。*

*如果你仔细想想，实际上这两个问题源于同一个临界点:阅读文档需要时间。而且一点都不好玩。但是，读得深(足够)就省了很多傻错误。此外，编写文档并不有趣。原谅那些写了一份没有提到你的特殊雪花案例的文件的开发者。*

# *包扎*

*代码很有趣，但是如果它不工作，那就一点都不有趣了——尤其是如果你的工作和月收入取决于它的质量。我们经历的所有缺陷都源自同一位代码作者。保持谦逊的态度。怀疑是你的朋友。*

*最后一个想法。积极的一面是，通过编写你的程序，你创造了一些以前没有的东西。你创作了程序中所有其他的好东西。他们确实在工作，即使没人关心。不要被虫子卡住。你有创造的力量。*