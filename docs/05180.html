<html>
<head>
<title>Custom Swift Property Wrappers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义Swift属性包装</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swift-property-wrapper-8a14b137f67?source=collection_archive---------13-----------------------#2020-06-17">https://betterprogramming.pub/swift-property-wrapper-8a14b137f67?source=collection_archive---------13-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5097" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">大写字符串、最大和等的属性包装器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/b79b13d71804982ca173cfc2f3383fd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*OzAmvGw5YTcuZsW1pYL3mw.jpeg"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">图片由作者提供</p></figure><p id="a3c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了Swift 5.1，开发人员获得了一个非常有用的工具，属性包装器，它允许我们将行为和逻辑直接附加到我们的属性上。对于附加逻辑，我们可以使用用<code class="fe ln lo lp lq b">@propertyWrapper</code>属性注释的类或结构。每个属性包装器类型应该包含一个名为<code class="fe ln lo lp lq b">wrappedValue</code>的存储属性。让我们看几个使用案例，了解我们可以用这种仪器做什么，以及它看起来如何。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="6d22" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated"><strong class="ak">大写</strong></h1><p id="d46d" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">假设我们有string属性，我们希望文本总是大写。让我们用属性包装器来做这件事:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="044f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们仔细看看我们做了什么:</p><ol class=""><li id="e122" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">我们用<code class="fe ln lo lp lq b">@propertyWrapper</code>注释创建了结构。</li><li id="5d67" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">我们用<code class="fe ln lo lp lq b">get</code>和<code class="fe ln lo lp lq b">set</code>添加了所需的<code class="fe ln lo lp lq b">wrappedValue</code>。</li><li id="96eb" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">我们使用默认的初始化器，它允许我们通过赋值来初始化属性包装器。我们将在下面看到如何使用自定义初始化器。</li><li id="3247" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">我们添加了一个带有<code class="fe ln lo lp lq b">@Uppercased</code>注释的属性。</li></ol><p id="f145" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，通过四个简单的步骤，我们可以创建一个属性包装器，并将可重用的属性逻辑保存在一个地方。太棒了。现在让我们通过添加泛型和自定义初始化器来使任务复杂化。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="109c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">最大总和</h1><p id="b741" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">在这种情况下，我们将使用泛型和自定义初始化器创建一个具有最大限制的<code class="fe ln lo lp lq b">Double</code>属性。让我们看看代码示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ae93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，这似乎与前面的例子有几个不同之处:</p><ol class=""><li id="5372" class="mx my iq kt b ku kv kx ky la mz le na li nb lm nc nd ne nf bi translated">我们添加了一个类型为<code class="fe ln lo lp lq b">Comparable</code>的泛型值，它有助于将属性包装器用于不同的类型，如<code class="fe ln lo lp lq b">Double</code>、<code class="fe ln lo lp lq b">Int</code>和<code class="fe ln lo lp lq b">CGFloat</code>。</li><li id="f91a" class="mx my iq kt b ku ng kx nh la ni le nj li nk lm nc nd ne nf bi translated">我们将默认初始化器从<code class="fe ln lo lp lq b">wrappedValue</code>替换为<code class="fe ln lo lp lq b">(initialValue value: Value, maxValue: Value)</code>。因此，注释看起来有所不同。现在我们必须调用初始化器来初始化属性<code class="fe ln lo lp lq b">@MaxSum(initialValue: 150.0, maxValue: 100.0)</code>。</li></ol><p id="ff62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，属性包装器似乎是一个更强大的工具。像大多数工具一样，它也有局限性。我们不能使用几个属性包装器<strong class="kt ir"> <em class="nl"> </em> </strong>来理解和规避这个限制。让我们再添加一个简短的属性包装器<strong class="kt ir"> </strong>，从值中删除所有数字。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fdf2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在到了极限。如果我们写<code class="fe ln lo lp lq b">@Uppercased @DigitsCleaner var value: String</code>，我们将得到一个错误，因为不支持多个属性包装器。但是如果您真的需要使用两个属性包装器，您可以再创建一个属性包装器，在这里您可以再添加一个注释。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5d32" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="cdc0" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">总的来说，我可以说属性包装器是强大的工具，有很大的潜力，可以帮助你的代码更整洁，可读性更好。喜欢使用属性包装器。</p></div></div>    
</body>
</html>