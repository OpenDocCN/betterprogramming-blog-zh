<html>
<head>
<title>Node.js’s ‘fs’ Module: Writing Files and Directories</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js的“fs”模块:编写文件和目录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/node-js-fs-module-writing-files-and-directories-da70190376c?source=collection_archive---------12-----------------------#2019-12-17">https://betterprogramming.pub/node-js-fs-module-writing-files-and-directories-da70190376c?source=collection_archive---------12-----------------------#2019-12-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="220c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将文件系统引入您的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34a3b9a07f6485c7e4cb724ad8b87a95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SsFzQMC46qi4UXFi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克尔·贾斯蒙德在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="80e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作文件和目录是任何程序的基本操作。因为Node.js是一个服务器端平台，可以直接与运行它的计算机交互，所以操作文件的能力是一个基本特性。</p><p id="c190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Node.js的库中内置了一个<code class="fe lv lw lx ly b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。它支持基本的文件和目录操作，比如操作和打开目录中的文件。</p><p id="18f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以对文件做同样的事情。它可以同步和异步地做到这一点。它有一个支持承诺的异步API函数。此外，它还可以显示文件的统计数据。</p><p id="85ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有我们能想到的文件操作都可以用内置的<code class="fe lv lw lx ly b">fs</code>模块来完成。在这篇文章中，我们将使用<code class="fe lv lw lx ly b">fs</code>模块中的函数来写文件，使用<code class="fe lv lw lx ly b">write</code>系列函数来写文件。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="367e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">fs。写</h1><p id="81f8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">write函数有两个版本，一个用于将文本写入磁盘，另一个用于将二进制数据写入磁盘。</p><p id="b0fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">write</code>函数的文本版本让我们可以异步地将文本写到磁盘上。这需要一些争论。</p><p id="6cc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是文件描述符——一个标识文件的数字。</p><p id="9df3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是写入文件的字符串。如果传入的值不是字符串，则将其转换为字符串。</p><p id="47a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是文件开始写入的位置。如果传入的值不是数字，那么它从当前位置开始。</p><p id="606e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四个参数是一个字符串，该字符串具有要写入的文件的字符编码，默认为<code class="fe lv lw lx ly b">utf8</code>。最后一个参数是带有三个参数的回调函数。</p><p id="191e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个是有错误对象的<code class="fe lv lw lx ly b">err</code>对象，如果有错误，它不是<code class="fe lv lw lx ly b">null</code>。</p><p id="538e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是<code class="fe lv lw lx ly b">written</code>参数，一个整数，指定有多少字节被写入文件系统。不一定和写的字符串字符数一样。</p><p id="2d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是<code class="fe lv lw lx ly b">string</code>参数，它包含写入的字符串。</p><p id="f460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Linux上，位置写在追加模型中不起作用。在Windows上，如果文件描述符是1，代表标准输出，那么默认情况下，包含非ASCII字符的字符串将不会正确呈现。</p><p id="bca3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">write</code>函数，我们可以先使用<code class="fe lv lw lx ly b">open</code>函数来获取您想要写入的文件的文件描述符，然后我们可以通过将文件描述符传递给<code class="fe lv lw lx ly b">write</code>函数来写入文件。例如，如果我们想写入路径为<code class="fe lv lw lx ly b">./files/file.txt</code>的文件，我们可以这样写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="554c" class="nh mh it ly b gy ni nj l nk nl">const fs = require("fs");</span><span id="1862" class="nh mh it ly b gy nm nj l nk nl">fs.open("./files/file.txt", "r+", (err, fd) =&gt; {<br/>  if (err) throw err;<br/>  fs.write(fd, "abc", 0, "utf8", (err, written, string) =&gt; {<br/>    console.log(err, written, string);<br/>    fs.close(fd, err =&gt; {<br/>      if (err) throw err;<br/>    });<br/>  });<br/>});</span></pre><p id="ebf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们应该得到如下所示的输出:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e2d3" class="nh mh it ly b gy ni nj l nk nl">null 3 abc</span></pre><p id="648a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们首先用<code class="fe lv lw lx ly b">open</code>函数打开文件。我们传入了<code class="fe lv lw lx ly b">r+</code>标志，这样我们就可以写入文件。然后，我们在回调函数中获得文件描述符<code class="fe lv lw lx ly b">fd </code>，并将其传递给<code class="fe lv lw lx ly b">open</code>函数。有了<code class="fe lv lw lx ly b">fd</code>文件描述符，我们可以将它传递给<code class="fe lv lw lx ly b">write</code>函数。</p><p id="b1b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">write</code>函数的第二个参数中，我们指定要将字符串<code class="fe lv lw lx ly b">abc</code>写入文件。在第三个参数中，我们指定我们想把它写在位置0，第四个参数指定字符串的字符编码应该是UTF-8。</p><p id="5163" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个参数中的回调将得到写操作的结果。从那里，我们从输出中知道三个字节和字符串<code class="fe lv lw lx ly b">‘abc’ </code>被写入文件。</p><p id="1831" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了<code class="fe lv lw lx ly b">r+</code>标志，还有许多其他可能的系统标志，包括:</p><ul class=""><li id="4d46" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'a'</code> —打开一个追加文件，这意味着将数据添加到现有文件中。如果文件不存在，则创建该文件。</li><li id="9a5e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'ax'</code> —与<code class="fe lv lw lx ly b">'a'</code>相似，但如果路径存在，则会引发异常。</li><li id="ecc1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'a+'</code> —打开文件进行读取和追加。如果文件不存在，则创建该文件。</li><li id="10da" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'ax+'</code> —与<code class="fe lv lw lx ly b">'a+'</code>相似，但如果路径存在，则会引发异常。</li><li id="bad5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'as'</code> —以同步模式打开附加文件。如果文件不存在，则创建该文件。</li><li id="6f04" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'as+'</code> —以同步模式打开文件进行读取和追加。如果文件不存在，则创建该文件。</li><li id="1d9c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'r'</code> —打开文件进行阅读。如果文件不存在，将引发异常。</li><li id="d87a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'r+'</code> —打开文件进行读写。如果文件不存在，将引发异常。</li><li id="73c8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'rs+'</code> —以同步模式打开文件进行读写。</li><li id="e015" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'w'</code> —打开文件进行写入。文件被创建(如果不存在)或覆盖(如果存在)。</li><li id="9f95" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'wx'</code> —与<code class="fe lv lw lx ly b">'w'</code>类似，但如果路径存在则失败。</li><li id="3b0c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'w+'</code> —打开文件进行读写。文件被创建(如果不存在)或覆盖(如果存在)。</li><li id="7e37" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">'wx+'</code> —类似于<code class="fe lv lw lx ly b">'w+'</code>，但是如果路径存在，就会抛出异常。</li></ul><p id="d9d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">write</code>函数的二进制版本允许我们异步地将文本写到磁盘上。这需要一些争论。</p><p id="f571" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是文件描述符，它是一个标识文件的数字。</p><p id="3c6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是buffer对象，它可以是Buffer、TypedArray或DataView类型。</p><p id="f4d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是<code class="fe lv lw lx ly b">offset</code>，它决定了要写入的缓冲区部分。</p><p id="ee44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四个参数是<code class="fe lv lw lx ly b">length</code>参数，它指定写入的字节数，最后一个参数是<code class="fe lv lw lx ly b">position</code>，它是一个整数，描述了<code class="fe lv lw lx ly b">write</code>函数开始写入的位置。</p><p id="d48e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个参数是一个回调函数——一个接受<code class="fe lv lw lx ly b">err</code>参数的函数，它有一个error对象。如果发生错误，第二个是<code class="fe lv lw lx ly b">bytesWritten</code>参数，它获取写入磁盘的字节数，第三个是<code class="fe lv lw lx ly b">buffer</code>对象，它包含写入磁盘的二进制数据。</p><p id="7a91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="31aa" class="nh mh it ly b gy ni nj l nk nl">const fs = require("fs");</span><span id="1930" class="nh mh it ly b gy nm nj l nk nl">fs.open("./files/binaryFile", "w", (err, fd) =&gt; {<br/>  if (err) throw err;<br/>  fs.write(fd, new Int8Array(8), 0, 8, 0, (err, bytesWritten, buffer) =&gt; {<br/>    console.log(err, bytesWritten, buffer);<br/>    fs.close(fd, err =&gt; {<br/>      if (err) throw err;<br/>    });<br/>  });<br/>});</span></pre><p id="4d70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果运行它，我们会得到以下输出:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="94cd" class="nh mh it ly b gy ni nj l nk nl">null 8 Int8Array [<br/>  0, 0, 0, 0,<br/>  0, 0, 0, 0<br/>]</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ed9f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">fs.writeSync</h1><p id="f6d3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">write</code>功能的同步版本是<code class="fe lv lw lx ly b">writeSync</code>功能。有一个写二进制数据的版本和一个写文本数据的版本。</p><p id="b562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">writeSync</code>函数的文本版本让我们可以异步地将文本写到磁盘上。这需要一些争论。</p><p id="2f22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是文件描述符，它是一个标识文件的数字。</p><p id="3f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是将被写入文件的字符串。如果传入的值不是字符串，它将被转换为字符串。</p><p id="a751" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是文件开始写入的位置。如果传入的值不是数字，那么它从当前位置开始。</p><p id="19c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四个参数是一个字符串，它包含要写入的文件的字符编码，默认为<code class="fe lv lw lx ly b">utf8</code>。返回写入的字节数。</p><p id="e4d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用文本版本的<code class="fe lv lw lx ly b">writeSync</code>函数，如下面的代码所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8259" class="nh mh it ly b gy ni nj l nk nl">const fs = require("fs");</span><span id="0be8" class="nh mh it ly b gy nm nj l nk nl">const fd = fs.openSync("./files/file.txt", "r+");<br/>const numBytesWritten = fs.writeSync(fd, "abc", 0, "utf8");<br/>console.log(numBytesWritten);</span></pre><p id="8a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该在<code class="fe lv lw lx ly b">console.log</code>语句中得到3，因为写了3个字节。</p><p id="c813" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">writeSync</code>函数的二进制数据版本有五个参数。它将文件描述符作为第一个参数。第二个参数是<code class="fe lv lw lx ly b">buffer</code>对象，可以是Buffer、TypedArray或DataView对象。</p><p id="6ed5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是<code class="fe lv lw lx ly b">offset</code>，它是一个整数，指定了<code class="fe lv lw lx ly b">writeSync</code>函数将开始写入的缓冲区部分。</p><p id="9f3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第四个参数是<code class="fe lv lw lx ly b">length</code>参数，它指定了写入的字节数。</p><p id="c2f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一个参数是<code class="fe lv lw lx ly b">position</code>，它是一个整数，描述了<code class="fe lv lw lx ly b">writeSync</code>函数开始写入的位置。返回写入的字节数。</p><p id="c8e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用二进制版本的<code class="fe lv lw lx ly b">writeSync</code>函数，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6da8" class="nh mh it ly b gy ni nj l nk nl">const fs = require("fs");</span><span id="3a8a" class="nh mh it ly b gy nm nj l nk nl">const fd = fs.openSync("./files/binaryFile", "w");<br/>const numBytesWritten = fs.writeSync(fd, new Int8Array(8), 0, 8, 0);<br/>console.log(numBytesWritten);</span></pre><p id="88f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该在<code class="fe lv lw lx ly b">console.log</code>语句中得到8，因为写入了8个字节。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/6f651fefb4662f39ac327e1a67e8a24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M4An6o4ZDJMSsrXi"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@leo_leo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">莱奥莱奥</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2389" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">fs.writeFile</h1><p id="d6f4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">fs.writeFile</code>函数以一种不太复杂的方式编写文件。它需要四个参数。</p><p id="05d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是对文件的引用，它可以是字符串路径、缓冲区对象、URL对象或文件描述符，后者是标识文件的整数。</p><p id="60b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是要写入文件的数据，可以是string、Buffer对象、TypedArray或DataView对象。第三个参数用于传入带有几个选项的对象。</p><p id="397b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三件事可以设置:编码、模式和标志:</p><ul class=""><li id="f9da" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">编码指定了正在写入的文本的字符编码，默认为<code class="fe lv lw lx ly b">utf8</code>。</li><li id="abb4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">模式是一个整数，默认为<code class="fe lv lw lx ly b">0o666</code>。该模式设置文件权限和粘滞位，但仅在文件已经创建的情况下。<code class="fe lv lw lx ly b">0o666</code>表示既可读又可写。</li><li id="b489" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">flag选项指定正在写入的文件的读取或写入选项。上面列出的对于这个论点都是有效的。最后一个参数是回调函数，这个函数接受一个<code class="fe lv lw lx ly b">err</code>对象，如果存在错误，这个对象不是<code class="fe lv lw lx ly b">null</code>。</li></ul><p id="d07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想用<code class="fe lv lw lx ly b">writeFile</code>函数写入路径为<code class="fe lv lw lx ly b">./files/file.txt</code>的文件，我们可以这样写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d5bf" class="nh mh it ly b gy ni nj l nk nl">const fs = require("fs");</span><span id="ebce" class="nh mh it ly b gy nm nj l nk nl">fs.writeFile(<br/>  "./files/file.txt",<br/>  "abc",<br/>  { encoding: "utf8", mode: 666, flag: "w" },<br/>  err =&gt; console.log(err)<br/>);</span></pre><p id="133f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个参数中，我们传入文件的字符串路径。然后，在第二个参数中，我们传入了要写的内容。第三个参数包含编码选项，使用<code class="fe lv lw lx ly b">mode</code>选项写入文件的文件权限，以及用于设置文件打开模式的<code class="fe lv lw lx ly b">flag</code>。如果文件写入成功。上面的<code class="fe lv lw lx ly b">console.log</code>语句应该输出<code class="fe lv lw lx ly b">null</code>，并且您可以看到您写到磁盘上的文件的内容。</p><p id="aff4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当一个文件描述符被传入<code class="fe lv lw lx ly b">writeFile</code>函数的第一个参数时，其行为与传入其他对象来引用该文件略有不同。如果将文件描述符传递给第一个参数，该文件不会被替换。</p><p id="a583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果用文件描述符多次调用<code class="fe lv lw lx ly b">writeFile</code>函数，那么写入文件的项将被追加到文件中，而不是覆盖现有的内容。因此，如果第一个<code class="fe lv lw lx ly b">writeFile</code>调用传入了文件描述符<code class="fe lv lw lx ly b">1</code>和内容<code class="fe lv lw lx ly b">a</code>，第二个<code class="fe lv lw lx ly b">writeFile</code>调用传入了文件描述符<code class="fe lv lw lx ly b">1</code>和内容<code class="fe lv lw lx ly b">b</code>，那么我们在文件描述符为<code class="fe lv lw lx ly b">1</code>的文件中得到<code class="fe lv lw lx ly b">ab</code>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="029b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">fs.writeFileSync</h1><p id="6a88" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">有一个名为<code class="fe lv lw lx ly b">writeFileSync</code>的<code class="fe lv lw lx ly b">writeFile</code>同步版本，它采用与<code class="fe lv lw lx ly b">writeFile</code>函数相同的参数，只是没有回调。它返回<code class="fe lv lw lx ly b">undefined</code>。我们可以在下面的函数中使用它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6d0a" class="nh mh it ly b gy ni nj l nk nl">const fs = require("fs");</span><span id="dbdb" class="nh mh it ly b gy nm nj l nk nl">fs.writeFileSync("./files/file.txt", "abc", {<br/>  encoding: "utf8",<br/>  mode: 666,<br/>  flag: "w"<br/>});</span></pre><p id="3741" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行上面的代码后，您应该看到以给定路径写入磁盘的文件中的内容。</p><p id="f269" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作文件和目录是任何程序的基本操作。因为Node.js是一个服务器端平台，可以直接与运行它的计算机交互，所以能够操作文件是一个基本特性。幸运的是，Node.js的库中内置了一个<code class="fe lv lw lx ly b">fs</code>模块。</p><p id="b7a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有许多功能，可以帮助操纵文件和文件夹。在这段代码中，我们使用了<code class="fe lv lw lx ly b">fs</code>模块中的函数来编写文件，使用了<code class="fe lv lw lx ly b">write</code>系列函数来编写文件。我们使用<code class="fe lv lw lx ly b">open</code>和<code class="fe lv lw lx ly b">write</code>函数首先打开文件以获取文件描述符，然后将内容写入文件。它有单独的版本来处理文本和二进制文件。</p><p id="3070" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个名为<code class="fe lv lw lx ly b">writeSync</code>的函数的同步版本，它接受相同的参数，没有回调。它还有一个文本和二进制版本。为了更方便地写入文件，我们可以使用<code class="fe lv lw lx ly b">writeFile</code>和<code class="fe lv lw lx ly b">writeFileSync</code>函数，在给定对文件的引用(如路径字符串或URL对象)的情况下，可以写入文本和二进制文件。<code class="fe lv lw lx ly b">writeFile</code>为异步，<code class="fe lv lw lx ly b">writeFileSync</code>为同步。</p></div></div>    
</body>
</html>