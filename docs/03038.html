<html>
<head>
<title>5 JavaScript Tips to Make You a Better Programmer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让你成为更好的程序员的5个JavaScript技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-javascript-tips-to-make-you-a-better-coder-f5de38cf782b?source=collection_archive---------5-----------------------#2020-01-16">https://betterprogramming.pub/5-javascript-tips-to-make-you-a-better-coder-f5de38cf782b?source=collection_archive---------5-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0386" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些代码提示让您的JavaScript更具可读性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/88163a38e51456b2917478b2182a87e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ujeElwPqj10c8BR0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artem Sapegin </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="2d21" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">伟大的程序员为人类写代码，而不是为计算机。一个很好的经验法则是遵循它来对待你的代码库，就好像下一个接手项目的人是一个知道你住在哪里的疯子。如果这是真的，你肯定会想一丝不苟地保持简洁，写出高质量的代码。</p><p id="c17d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多方法可以优化我们的JavaScript代码。这篇文章将揭示常见的陷阱，以及如何通过编写更容易理解的代码来避免它们。</p><p id="0286" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是编写更好的JavaScript的五个技巧。不要全信，因为观点可能会有所不同，但是这些是团队普遍认同的最佳实践。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8975" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.使用。地图或者。forEach而不是for循环</h1><p id="a7ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每个复杂的应用程序都需要大量的数据集循环，通常是数组或对象。有了循环，代码很快变得不可读，难以理解。</p><p id="391e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，看看下面的代码，告诉我你更喜欢哪一个。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在数组上循环</p></figure><p id="8fc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码遍历数字数组，并将每个数字打印到控制台。</p><p id="451d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果我们有更复杂的数组，比如对象数组呢？使用<code class="fe mz na nb nc b">map</code>、<code class="fe mz na nb nc b">filter</code>、<code class="fe mz na nb nc b">reduce</code>进行迭代。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这是打印到控制台的内容。结果是一样的，但是使用函数式编程方法，代码要干净得多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/0293b6d5df85de9a7a5b674ccf470b62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jjyahLLvydjf_ervVZAb5g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在数组上循环</p></figure><p id="b928" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe mz na nb nc b">for</code>循环的唯一例外是当我们迭代对象时。这是因为<code class="fe mz na nb nc b">forEach</code>、<code class="fe mz na nb nc b">map</code>、<code class="fe mz na nb nc b">reduce</code>和<code class="fe mz na nb nc b">filter</code>是我们只能对数组调用的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">错误:" TypeError: dogs.map不是函数"</p></figure><p id="a716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在对象循环的情况下，我们可以使用<code class="fe mz na nb nc b">for...in</code>循环。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在循环中用<strong class="ak">循环狗</strong></p></figure><p id="5ede" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代对象的更好方法是使用以下方法:</p><ul class=""><li id="7464" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe mz na nb nc b">Object.keys</code> —返回给定对象自己的可枚举属性<strong class="lb iu">名称</strong>的数组，按照与普通循环相同的顺序迭代</li><li id="851a" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe mz na nb nc b">Object.values</code> —返回给定对象自己的可枚举属性<strong class="lb iu">值</strong>的数组，顺序与<code class="fe mz na nb nc b">for...in</code>循环提供的顺序相同</li><li id="4f49" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe mz na nb nc b">Object.entries</code> —返回给定对象的<strong class="lb iu">自己的可枚举字符串键属性</strong> <code class="fe mz na nb nc b">[key, value]</code>对的数组，顺序与<code class="fe mz na nb nc b">for...in</code>循环提供的顺序相同。</li></ul><p id="bfdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述方法从对象中获取键或值，将它们放入一个数组中，并返回该数组作为结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将dogs对象转换为包含Object.values()的数组</p></figure><p id="b3a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们有了一个数组，我们可以迭代这些值，用<code class="fe mz na nb nc b">map</code>或<code class="fe mz na nb nc b">forEach</code>来获取这些值。</p><p id="cb16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有几种不同的方法来迭代不同目标的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">遍历对象的多种方式</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a9d8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.默认情况下使用常量</h1><p id="cec4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">const</code>和<code class="fe mz na nb nc b">let</code>的区别很简单。<code class="fe mz na nb nc b">const</code>是不可变的，而<code class="fe mz na nb nc b">let</code>允许我们重新分配变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">let vs. const</p></figure><p id="a4a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认情况下使用<code class="fe mz na nb nc b">const</code>，认知负荷会减少，因为我们不需要追逐和猜测每个变量代表什么。每当我们改变变量时就使用<code class="fe mz na nb nc b">let</code>。</p><p id="f233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下面的例子为例。我们可能会更早地宣布我们的名字，并多次改变它。我们可能会遇到一些使用<code class="fe mz na nb nc b">const</code>可以避免的意外错误。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">变异变量</p></figure><p id="32ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">支持默认使用<code class="fe mz na nb nc b">const</code>的理由如下:</p><ul class=""><li id="2c4a" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">它避免了由非自愿重新分配引起的副作用。</li><li id="f04e" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">它提供了更好的开发者体验，因为它消除了不确定性。看到<code class="fe mz na nb nc b">const</code>变量的开发人员可以相信它不会被重新分配。</li><li id="0ac9" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe mz na nb nc b">const</code>更符合函数式编程和不可变状态。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a7ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.避免嵌套闭包</h1><p id="df09" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">理解JavaScript中的闭包是最重要的。我们每天都在使用闭包。花点时间找出下面代码中的闭包。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将所有名称格式化为小写</p></figure><p id="2f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你找到结尾了吗？这里有一个提示:闭包位于第4行。记住，闭包从外部函数捕获变量。</p><p id="f009" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经确定了闭包是什么，问题是我们如何改进代码。这是一段相对简单的代码，它将数组中的所有名称格式化为小写。</p><p id="9974" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:避免<em class="nu"> </em>嵌套闭包。</p><p id="12db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个避免嵌套闭包的简单例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">避免嵌套闭包</p></figure><p id="f4c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意我们把闭包放在了一个函数表达式中。这样我们的代码更容易理解和推理。以下面的代码为例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计算平均分数</p></figure><p id="ae37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码遍历对象数组，然后将分数和舍入值相加得到一个整数。虽然这是可以理解的，但我们仍然可以改进代码。总有改进的空间。</p><p id="add8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何通过简单地将分数求和逻辑提取到它自己的函数表达式中来改进代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="57d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想更深入地了解为什么避免嵌套闭包是一个好主意，请阅读Kent C. Dodds的文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="989c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.避免嵌套的if</h1><p id="163a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">嵌套语句是迄今为止最大的代码味道。嵌套if语句很容易导致不可维护的代码库。帮你自己和你的团队一个忙，避免嵌套<code class="fe mz na nb nc b">if</code>语句。</p><p id="3664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当通过嵌套<code class="fe mz na nb nc b">if</code>语句来检查条件时，这是一种幼稚的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">嵌套的if语句</p></figure><p id="87e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花一点时间想想如何改进这段代码。这是我想到的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">避免嵌套的if语句</p></figure><p id="ac43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从七行代码减少到三行。这是一个巨大的进步。因为这三个条件都必须被评估为<code class="fe mz na nb nc b">true</code>，所以我们可以使用<code class="fe mz na nb nc b">&amp;&amp;</code>操作符。<code class="fe mz na nb nc b">&amp;&amp;</code>代表<code class="fe mz na nb nc b">and</code>。另一种选择是使用双管操作器<code class="fe mz na nb nc b">||</code>，代表<code class="fe mz na nb nc b">or</code>。<code class="fe mz na nb nc b">&amp;&amp;</code>和<code class="fe mz na nb nc b">||</code>的区别在于所有的<code class="fe mz na nb nc b">&amp;&amp;</code>条件都必须满足，而<code class="fe mz na nb nc b">||</code>只需要满足一个条件就可以执行<code class="fe mz na nb nc b">if</code>语句。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用管道<strong class="ak"> || </strong>运算符</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7546" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.用变量代替复杂的if子句；</h1><p id="b15f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可能有一段时间，我们会发现自己处于有多个复杂的<code class="fe mz na nb nc b">if</code>语句的情况下。看一看下面的详细代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">详细的if语句</p></figure><p id="ec92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种代码产生的认知负荷很大。我强烈提倡尽可能最好的开发者体验。你会如何改进代码？这是我想到的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ff09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将比较放在单独的变量中，代码更容易理解和推理。这需要额外的几秒钟，但是通过在整个代码库中利用最佳实践，从长远来看，我们提高了开发人员的生产力。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f79a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="0e82" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢阅读，希望这篇文章对你有用。把你的代码当成艺术。你要尽可能清晰地表达自己——不要给误解留下空间。</p><p id="ace0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解我最新内容的最好方式是通过我的<a class="ae ky" href="https://wholesomedev.substack.com/welcome" rel="noopener ugc nofollow" target="_blank">简讯</a>。成为第一个得到通知的人。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/bf98059c6ba9f84a5c16721789483ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dds734n3RiKUVOqyHK0Aqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我的<a class="ae ky" href="https://wholesomedev.substack.com/welcome" rel="noopener ugc nofollow" target="_blank">简讯</a>。成为第一个得到通知的人。</p></figure></div></div>    
</body>
</html>