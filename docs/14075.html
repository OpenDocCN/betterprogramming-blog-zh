<html>
<head>
<title>How To Avoid Lengthy UITableView Protocol Conformances Using a Swift Package</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Swift软件包避免冗长的UITableView协议一致性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-lengthy-uitableview-protocol-conformances-using-a-swift-package-5553b3c9e3cb?source=collection_archive---------1-----------------------#2022-11-02">https://betterprogramming.pub/how-to-avoid-lengthy-uitableview-protocol-conformances-using-a-swift-package-5553b3c9e3cb?source=collection_archive---------1-----------------------#2022-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2921" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Swift 5中表格视图的开发突飞猛进</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b070a0b748b786007de2959c745a5b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fMtS5usPoFB2awKF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@szolkin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">谢尔盖·佐尔金</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="f7cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何更快更容易地创建表格视图及其单元格。我们将通过利用协议、继承和抽象来做到这一点。到本文结束时，您将拥有一个生产就绪的机制，可以自由集成到您的iOS应用程序中。</p><p id="4828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，当处理一个新的表格视图时，我们将从这个开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="b91a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="89e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在文章中的计划如下:</p><ol class=""><li id="044a" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">创建一个可重用的库来处理表格视图。</li><li id="910f" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">基于它创建一个示例应用程序。</li></ol><p id="6282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成的库和示例应用程序的源代码可以在文章的底部找到。事不宜迟，我们开始吧。</p><h1 id="55be" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">我们开始吧</h1><p id="1235" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">首先，让我们定义一个<code class="fe ni nj nk nl b">TableRowModel</code>协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="3c71" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">属性将保存一个特定的<code class="fe ni nj nk nl b">UITableViewCell</code>的重用标识符。</li><li id="f1a3" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">当<code class="fe ni nj nk nl b">UITableView</code>的<code class="fe ni nj nk nl b">didSelectRowAtIndexPath</code>方法触发时，将调用<code class="fe ni nj nk nl b">onSelection</code>闭包。</li><li id="86b6" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">我们在协议扩展中为闭包提供了一个默认的<code class="fe ni nj nk nl b">nil</code>值，所以单元只在需要时才实现这个属性。</li></ol><p id="dd7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，让我们通过创建一个<code class="fe ni nj nk nl b">TableHeaderFooterModel</code>来同样表示一个<code class="fe ni nj nk nl b">UITableViewHeaderFooterView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="721a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们只指定一个<code class="fe ni nj nk nl b">identifier</code>作为要求。</p><p id="4af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成<code class="fe ni nj nk nl b">UITableViewCell</code>和<code class="fe ni nj nk nl b">UITableHeaderFooterView</code>表示后，现在让我们对表格视图的一部分建模:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="2d7f" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">就像<code class="fe ni nj nk nl b">UITableView</code>中的任何部分都可以有一个<code class="fe ni nj nk nl b">UITableViewHeaderFooter</code>一样，这里我们有一个之前创建的<code class="fe ni nj nk nl b">TableHeaderFooterModel</code>属性。</li><li id="3591" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">类似地，我们有一个行数组，每行代表一个<code class="fe ni nj nk nl b">UITableViewCell</code>。</li><li id="c9e5" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">最后，我们对页脚做同样的事情。</li><li id="6ccc" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">默认情况下，初始化器将为页眉和页脚设置<code class="fe ni nj nk nl b">nil</code>值。</li></ol><p id="8063" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经完成了所有的基本表示，让我们创建一个<code class="fe ni nj nk nl b">UITableViewCell</code>的基类，我们应用程序中的所有具体单元格都将继承它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="e92d" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">我们实现了一个初始化器，将<code class="fe ni nj nk nl b">selectionStyle</code>设置为<code class="fe ni nj nk nl b">.none</code>，并调用方法<code class="fe ni nj nk nl b">setupSubviews()</code>。</li><li id="f76b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">我们定义了一个方法<code class="fe ni nj nk nl b">setupSubviews()</code>，它需要在子类中被覆盖。当一个子类实现这个方法时，它会在一个初始化器中被自动调用，减少了我们要做的工作量。</li><li id="6eb8" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">我们用<code class="fe ni nj nk nl b">setup(with rowModel: TableRowModel)</code>方法做同样的事情。当我们想用数据配置一个单元格时，我们将在一个特定的单元格外调用这个方法。</li></ol><p id="30c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们通过实现一个<code class="fe ni nj nk nl b">BaseHeaderFooterView</code>来完成基类的设置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像我们在<code class="fe ni nj nk nl b">BaseTableViewCell</code>中做的一样，这里我们有<code class="fe ni nj nk nl b">setupSubviews()</code>和<code class="fe ni nj nk nl b">setup(with headerFooterModel)</code>方法供子类覆盖。</p><p id="302d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成这个库只剩下一件事:负责一个<code class="fe ni nj nk nl b">UITableView</code>—<code class="fe ni nj nk nl b">TableDirector</code>的实际对象。</p><h1 id="212f" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">TableDirector实现</h1><p id="ee13" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">首先，让我们创建一个定义了<code class="fe ni nj nk nl b">UITableView</code>属性的<code class="fe ni nj nk nl b">TableDirector</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="6621" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">我们保留对一个<code class="fe ni nj nk nl b">UITableView</code>的弱引用，因为不需要强引用来保持它的活动:一个特定的<code class="fe ni nj nk nl b">UIViewController</code>将保留一个<code class="fe ni nj nk nl b">UITableView</code>。</li><li id="2603" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">我们将<code class="fe ni nj nk nl b">tableview</code>的<code class="fe ni nj nk nl b">dataSource</code>和<code class="fe ni nj nk nl b">delegate</code>属性都设置为<code class="fe ni nj nk nl b">self</code>。</li></ol><p id="a6bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们需要实现<code class="fe ni nj nk nl b">UITableViewDelegate</code>和<code class="fe ni nj nk nl b">UITableViewDataSource</code>，以避免在将来实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d6e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们将这些方法与内容结合之前，让我们创建几个属性以及一个用于注册单元格的辅助函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="8c9e" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">属性将保存一个<code class="fe ni nj nk nl b">TableSection</code>模型的数组。一旦设置了属性，我们就使用<code class="fe ni nj nk nl b">TableRowModel</code>和<code class="fe ni nj nk nl b">TableHeaderFooterModel</code>的<code class="fe ni nj nk nl b">identifier</code>属性注册所有的<code class="fe ni nj nk nl b">UITableViewCell</code>和<code class="fe ni nj nk nl b">UITableViewHeaderFooterView</code>。</li><li id="031c" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">我们添加了<code class="fe ni nj nk nl b">onCellSelection</code>和<code class="fe ni nj nk nl b">onCellWillDisplay</code>闭包，以便消费者(尤其是视图控制器)可以在需要时对单元生命周期和事件做出反应。</li><li id="8362" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">sections</code>属性的<code class="fe ni nj nk nl b">didSet</code>中使用了<code class="fe ni nj nk nl b">classFromString</code>帮助器方法来获得一个<code class="fe ni nj nk nl b">UITableViewCell</code>或<code class="fe ni nj nk nl b">UITableViewHeaderFooterView</code>的特定重用标识符。</li></ol><p id="4d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在所有的属性都设置好了，让我们用真正的内容填充那些<code class="fe ni nj nk nl b">UITableViewDataSource</code>和<code class="fe ni nj nk nl b">UITableViewDelegate</code>方法。</p><p id="ebbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先从数据源方法开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="3b2d" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">很简单，在<code class="fe ni nj nk nl b">numberOfSections</code>方法中，我们返回<code class="fe ni nj nk nl b">sections</code>属性的<code class="fe ni nj nk nl b">count</code>。</li><li id="09ca" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">同样，在<code class="fe ni nj nk nl b">numberOfRowsInSection</code>方法中，我们在一个特定的<code class="fe ni nj nk nl b">section</code>中返回<code class="fe ni nj nk nl b">rowModels</code>的<code class="fe ni nj nk nl b">count</code>。</li><li id="5d47" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">cellForRowAt</code>方法中，我们获得一个与当前<code class="fe ni nj nk nl b">IndexPath</code>相关的<code class="fe ni nj nk nl b">rowModel</code>并使一个<code class="fe ni nj nk nl b">BaseTableViewCell</code>出队。然后，我们在单元格上调用<code class="fe ni nj nk nl b">setup(with rowModel)</code>方法并返回它。</li></ol><p id="1b7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据源完成后，现在让我们处理委托方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="24a0" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">didSelectRow</code>方法中，除了具体的<code class="fe ni nj nk nl b">TableRowModel</code>的<code class="fe ni nj nk nl b">onSelection</code>闭包之外，我们还调用了<code class="fe ni nj nk nl b">TableDirector</code>的<code class="fe ni nj nk nl b">onCellSelection</code>闭包。出于灵活性，我们有两个版本，因为有时API消费者只会对选择的<code class="fe ni nj nk nl b">IndexPath</code>感兴趣，而不是实际的模型。有了这两个版本，我们有了更多的选择。</li><li id="a0f2" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">willDisplayCell</code>方法中，我们触发<code class="fe ni nj nk nl b">onCellWillDisplay</code>闭包。</li><li id="c6aa" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">viewForHeader</code>方法中，我们试图为一个特定的<code class="fe ni nj nk nl b">IndexPath</code>获取一个<code class="fe ni nj nk nl b">headerModel</code>。如果它存在，我们将一个特定的<code class="fe ni nj nk nl b">BaseTableHeaderView</code>出队，调用它的<code class="fe ni nj nk nl b">setup(with headerModel)</code>方法，并返回它。否则，我们返回<code class="fe ni nj nk nl b">nil</code>。</li><li id="807e" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">viewForFooter</code>方法中，我们执行与<code class="fe ni nj nk nl b">viewForHeader</code>中相同的步骤。</li><li id="a094" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">willDisplayHeaderView</code>方法中，我们为标题设置可视配置。</li><li id="eba0" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">如果对于<code class="fe ni nj nk nl b">IndexPath</code>存在头部模型，<code class="fe ni nj nk nl b">heightForHeader</code>方法使用一个<code class="fe ni nj nk nl b">UITableView.automaticDimension</code>值。否则，它使用一个高度<code class="fe ni nj nk nl b">1</code>。</li><li id="c6f7" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">类似的逻辑也发生在<code class="fe ni nj nk nl b">heightForFooter</code>方法中。</li></ol><p id="b2e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们终于完成了库的实现。现在是时候在真正的app中使用了！</p><h1 id="5ac5" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">示例应用程序</h1><p id="4f9a" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们的应用程序是一个单屏幕应用程序，显示一个<code class="fe ni nj nk nl b">UITableView</code>填充可用空间:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="0486" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望用数据填充表格视图，所以让我们首先创建具体的<code class="fe ni nj nk nl b">TableRowModel</code>。</p><p id="71c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从一个左右两边都有标签的单元格开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="bb98" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">我们指定模型应该是来自<code class="fe ni nj nk nl b">LeftRightTitlesTableViewCell</code>的<code class="fe ni nj nk nl b">reuseIdentifier</code>。</li><li id="834f" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">我们定义了<code class="fe ni nj nk nl b">leftTitle</code>、<code class="fe ni nj nk nl b">rightTitle</code>属性，分别显示在<code class="fe ni nj nk nl b">leftLabel</code>和<code class="fe ni nj nk nl b">rightLabel</code>中。此外，我们添加了<code class="fe ni nj nk nl b">TableRowModel</code>的<code class="fe ni nj nk nl b">onSelection</code>属性，因为我们将对这个特定单元格的点击做出反应。</li><li id="af26" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">LeftRightTitlesTableViewCell</code>中，我们将模型的值赋给<code class="fe ni nj nk nl b">setup(with rowModel) </code>方法中的<code class="fe ni nj nk nl b">leftLabel</code>和<code class="fe ni nj nk nl b">rightLabel</code>。</li><li id="b850" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ni nj nk nl b">setupSubviews()</code>方法只负责布局和约束。</li></ol><p id="bc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完成一种类型的单元格后，让我们创建另一种:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="9210" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">模型被指示使用<code class="fe ni nj nk nl b">TitleSwitchTableViewCell</code>的<code class="fe ni nj nk nl b">reuseIdentifier</code>。</li><li id="2ab3" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">添加了<code class="fe ni nj nk nl b">title</code>、<code class="fe ni nj nk nl b">isOn</code>和<code class="fe ni nj nk nl b">onSwitchValueChanged</code>属性来设置标签的标题和<code class="fe ni nj nk nl b">UISwitch</code>的初始状态，并对开关值的变化做出反应。</li><li id="421e" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">setup(with rowModel)</code>方法中，我们像之前一样配置单元。</li><li id="54a8" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">当开关的值改变时，触发<code class="fe ni nj nk nl b">stateSwitchHandler</code>方法，并调用模型的<code class="fe ni nj nk nl b">onSwitchValueChanged</code>闭包。]</li><li id="1041" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ni nj nk nl b">setupSubviews</code>方法布置子视图并设置约束。</li></ol><p id="42d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们开始将单元集成到<code class="fe ni nj nk nl b">UITableView</code>之前，为了完整起见，让我们也实现一个<code class="fe ni nj nk nl b">UITableViewHeaderFooterView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="582d" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">该模型将使用<code class="fe ni nj nk nl b">TitleHeaderView</code>的<code class="fe ni nj nk nl b">reuseIdentifier</code>。</li><li id="f345" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">在<code class="fe ni nj nk nl b">setup(with headerModel)</code>方法中，我们用文本配置一个标签。</li><li id="7c8d" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ni nj nk nl b">setupSubviews()</code>方法布置标签并设置约束。</li></ol><p id="4a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了！单元格和标题都完成了。现在我们要把它们整合成一个<code class="fe ni nj nk nl b">UITableView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="c55e" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">我们在<code class="fe ni nj nk nl b">ViewController</code>中初始化一个惰性<code class="fe ni nj nk nl b">TableDirector</code>属性。</li><li id="8212" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">添加<code class="fe ni nj nk nl b">isSwitchOn</code>属性来保存待实现<code class="fe ni nj nk nl b">TitleSwitchTableViewCell</code>中开关的当前值。</li></ol><p id="a0bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表格视图工作的唯一一步是进给<code class="fe ni nj nk nl b">TableDirector</code>部分。让我们这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><ol class=""><li id="f483" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">我们在<code class="fe ni nj nk nl b">viewDidLoad()</code>中调用<code class="fe ni nj nk nl b">setupSections()</code>方法(我们现在将创建它)。</li><li id="f6c3" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ni nj nk nl b">setupSections()</code>方法为<code class="fe ni nj nk nl b">tableDirector</code>设置部分。</li><li id="a906" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ni nj nk nl b">createFirstSection()</code>方法创建一个带有标题和三个<code class="fe ni nj nk nl b">LeftRightTitlesTableViewCell</code>的部分。</li><li id="3249" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">为了使<code class="fe ni nj nk nl b">LeftRightTitlesTableViewCell</code>的创建更快且可重用，使用了<code class="fe ni nj nk nl b">createLeftRightCellModel(leftTitle:rightTitle:)</code>方法。它实现了基本的<code class="fe ni nj nk nl b">onSelection</code>闭包，每次选择一个单元格时都会打印<code class="fe ni nj nk nl b">leftTitle</code>和<code class="fe ni nj nk nl b">rightTitle</code>。</li><li id="92bb" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated"><code class="fe ni nj nk nl b">createSecondSection()</code>方法创建了另一个带有标题和一个<code class="fe ni nj nk nl b">TitleSwitchTableViewCell</code>的部分。它还实现了更新<code class="fe ni nj nk nl b">ViewController</code>的<code class="fe ni nj nk nl b">isSwitchOn</code>属性的<code class="fe ni nj nk nl b">onSwitchValueChanged</code>闭包。</li></ol><p id="19d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果我们构建并运行，我们会看到布局:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/f400b80251c4fe873f36aa044c3b5642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8H4BDPid5IhlK3x4azlPA.png"/></div></div></figure><p id="a01a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从现在开始，要创建包含单元格的表格视图，我们只需执行以下步骤:</p><ol class=""><li id="c29d" class="lx ly it lb b lc ld lf lg li lz lm ma lq mb lu mc md me mf bi translated">创造一个具体的<code class="fe ni nj nk nl b">TableRowModel</code>。</li><li id="b24b" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">创造一个具体的<code class="fe ni nj nk nl b">BaseTableViewCell</code>。</li><li id="7ded" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">向<code class="fe ni nj nk nl b">ViewController</code>添加一个<code class="fe ni nj nk nl b">TableDirector</code>属性，并为其分配一个表格视图。</li><li id="45c2" class="lx ly it lb b lc mg lf mh li mi lm mj lq mk lu mc md me mf bi translated">设置<code class="fe ni nj nk nl b">TableDirector</code>的章节属性。</li></ol><h1 id="ddb6" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">资源</h1><p id="85ca" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">示例应用程序的源代码可在<a class="ae ky" href="https://github.com/zafarivaev/TableDirector-Example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。另外，我准备了一个现成的Swift包，你可以在这里访问<a class="ae ky" href="https://github.com/zafarivaev/TableDirector" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4f95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你觉得这个教程很有用，现在你使用<code class="fe ni nj nk nl b">UITableView</code> s和<code class="fe ni nj nk nl b">UITableViewCell</code> s将花费更少的时间。</p><p id="0030" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>