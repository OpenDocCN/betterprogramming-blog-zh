<html>
<head>
<title>C++ Memory Pool and Small Object Allocator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++内存池和小对象分配器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/c-memory-pool-and-small-object-allocator-8f27671bd9ee?source=collection_archive---------3-----------------------#2021-11-15">https://betterprogramming.pub/c-memory-pool-and-small-object-allocator-8f27671bd9ee?source=collection_archive---------3-----------------------#2021-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1ebb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解在C++中如何控制小对象的内存分配/释放以避免内存碎片</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67d0dc3edf4c9621e2f85708325abaaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M8tRQk3MnUTXtMf7"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@harrisonbroadbent?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈里森·布罗德本特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="1d08" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">概述—我们为什么需要内存池</h1><p id="9bfc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">了解动态内存分配/释放的工作原理有助于我们理解为什么我们的内存会变得支离破碎。</p><p id="e83d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">内存碎片指的是<em class="ms">小内存块</em>在较大内存块之间分配的情况。可以想象，这种情况会导致系统无法分配内存，即使总的来说，我们的可用空间比需要的多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/98616f850f61d49c2f7eddce99d1bcda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lh1VVE3jfbhx81dquDSz1Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">碎片化的记忆(作者图片)</p></figure><p id="afa7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在上图中，尽管我们总共有230 MB的空闲空间，但我们不能分配超过100 MB的空间，因为当我们分配内存时，它必须是连续的。</p><ul class=""><li id="8ca9" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm mz na nb nc bi translated">另一种方式也是正确的，我们有许多小的未使用的内存块，但这不是一个很大的问题，因为总数可能小到我们可以忽略</li></ul><p id="a8c8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请阅读下面的帖子，了解C++如何分配和释放内存的细节。在不同的抽象层次上发生的事情将在下面的文章中详细讨论:</p><div class="nd ne gp gr nf ng"><a href="https://towardsdatascience.com/c-memory-allocation-deallocation-for-data-processing-1b204fb8a9c" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">用于数据处理的C++内存分配/释放</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">理解如何管理内存将有助于我们更明智地分配/释放内存。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">towardsdatascience.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div><h2 id="24c4" class="nv la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">小对象分配可能会导致碎片</h2><p id="fdf2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们绝对不希望在我们的应用程序中出现内存碎片。但是，我们需要注意什么才能避免呢？</p><p id="ce93" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">最可能的原因是我们的应用程序中频繁的小对象分配。当小物体的寿命比大物体的长时，尤其如此。</p><blockquote class="oh oi oj"><p id="77db" class="lr ls ms lt b lu mn ju lw lx mo jx lz ok mp mc md ol mq mg mh om mr mk ml mm im bi translated">与其他高级编程语言一样，C++的问题在于我们不太清楚是否在应用程序中为小对象分配内存。</p></blockquote><p id="7449" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们肯定会知道，当我们使用带<code class="fe on oo op oq b">new</code>和<code class="fe on oo op oq b">delete</code>运算符的原始指针以及<code class="fe on oo op oq b">std::unique_ptr</code>和<code class="fe on oo op oq b">std::shared_ptr</code>这样的智能指针时，我们是动态分配内存的，但是当我们使用C++标准库或第三方库提供的其他函数如Boost、<strong class="lt iu"> </strong>等时，，我们必须阅读文档或有时阅读代码(当然，如果是开源软件)。</p><p id="b96c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一些例子是任何类型的包装器，如<code class="fe on oo op oq b">std::any</code>和<code class="fe on oo op oq b">std::function</code>，它们使用C++中的类型擦除技术，这必须创建所包含对象的副本，导致动态分配。</p><p id="3ade" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果我们不小心，我们可能会在没有意识到的情况下将应用程序中的内存碎片化。即使是像<code class="fe on oo op oq b">std::vector</code>这样常用的STL容器，当用于小规模数据的少量元素时，如果它长时间保持活动状态(即不是函数中的局部变量),也会导致碎片。</p><p id="fd57" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于类型擦除、任何类型等的所有细节。你可以在这篇文章的末尾找到其他的文章来讨论。</p><p id="907b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以通过使用内存池来缓解这个问题，这将在下面的部分中讨论。我还将展示一个用例，在这个用例中，我们可以将内存池用于任何类型类的小对象优化，比如<code class="fe on oo op oq b">std::any</code>。</p><h1 id="7c53" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">内存池</h1><p id="dd3c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">内存池是一种内存管理技术，用于分配固定大小的内存，而不是由C++中的<code class="fe on oo op oq b">std::malloc</code>或<code class="fe on oo op oq b">new</code>操作符提供的可变大小的内存分配。</p><p id="556e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">关于内存碎片，其思想是，内存池允许我们预先分配连续的内存块，并将它们用于小对象，而不是在内存中分配(小对象的)内存。下图说明了不同之处。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/26c96a0d89bd793350c6d15b7ae0c33f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dDfoG-mUGxj_3DA30Y7IjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">可变大小的分配会导致分段(图片由作者提供)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/35a57c8dc3a6ba0fc6cbac00e867d2bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epPy0ZIjbhMQQ_EV74UsQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">内存池中的固定大小分配可能会改善这种情况(图片由作者提供)</p></figure><h2 id="f9a0" class="nv la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">它是如何工作的？</h2><p id="4967" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">内存池的工作原理是将内存分成块，并将块分成块/段。相同大小的对象可以使用一个池。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi os"><img src="../Images/b623b96734baf4ee603cd4576c96e56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*w02xQFBFvALqNrmiRs1v8Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">块和块/段(作者图片)</p></figure><p id="5df0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上图展示了一个8字节对象的内存池，其中一个块可以有5个块。块0、块1和块2可以分开在不同的存储位置。一个块中的块是连续的，你可以把它们看作一个由五个8字节数据组成的数组。</p><p id="1779" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">您可以编写自己的内存池，也可以使用任何适合您需要的库。对于本文，我们将使用<a class="ae ky" href="https://theboostcpplibraries.com/boost.pool" rel="noopener ugc nofollow" target="_blank"> Boost的池</a>。</p><h2 id="3f96" class="nv la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">同类型的水池</h2><p id="e026" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Boost的池支持不同的类型，有些提供低级别的控制，有些提供更多的抽象。它还支持我们可以用于STL容器的分配器类型。</p><p id="95e7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">对于我们这里的例子，我们将使用Boost的Singleton池，它的生存期是，直到我们的应用程序退出。</p><p id="4d4b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们实例化单例池时，我们需要指定块的大小。默认情况下，块大小是32 x块大小，我们可以通过设置模板参数来改变大小。</p><p id="6e99" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当一个块被完全使用时，Singleton池将会自动增加一个新的块，这意味着块的大小是原来的64倍。如果我们不设置可以在模板参数中设置的最大允许大小，它将会一直翻倍。</p><p id="c88b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在下面的例子中，我们有一个名为Coordinate的类，我们将频繁地为它分配具有不同生存期的内存。所以我们决定使用默认的、无限制块大小的单例池。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="3fd4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为此，我们可以使用Boost的单体池创建一个内存池，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="37e0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">空结构<code class="fe on oo op oq b">coordinate_pool</code>是一个标记，由单体池内部使用。</p><p id="a2b9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要分配和释放内存，我们可以简单地如下操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="01e3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">请注意，上面的代码只分配内存，而不构造对象。由于分配的内存是未初始化的，当您试图访问它时，您会看到一些随机数。要构建对象，我们需要手动完成，例如使用<code class="fe on oo op oq b">placement new</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="3d2d" class="nv la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">隐藏新建和删除运算符</h2><p id="bb7b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">上面的代码不方便，因为我们需要始终记住写3个步骤:</p><ul class=""><li id="04a2" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm mz na nb nc bi translated">分配内存</li><li id="6748" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">构建我们的对象</li><li id="2f2f" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">空闲存储器</li></ul><p id="4d18" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了解决这个问题，我们可以隐藏<code class="fe on oo op oq b">new</code>和<code class="fe on oo op oq b">delete</code>操作符。当你使用<code class="fe on oo op oq b">new</code>操作符来分配内存和构造一个对象时，编译器把它翻译成两个步骤:</p><ul class=""><li id="69cd" class="mu mv it lt b lu mn lx mo ma mw me mx mi my mm mz na nb nc bi translated">对全局<code class="fe on oo op oq b">::operator new</code>函数的调用</li><li id="1b51" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">对匹配构造函数的调用</li></ul><blockquote class="oh oi oj"><p id="d404" class="lr ls ms lt b lu mn ju lw lx mo jx lz ok mp mc md ol mq mg mh om mr mk ml mm im bi translated">所以，当人们说<code class="fe on oo op oq b">std::malloc</code>和new的区别在于new会在为它分配内存后构造对象时，这并不是魔术。</p></blockquote><p id="415d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">假设我们有下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="55ca" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">幕后发生的事情是编译器将第9行翻译成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="5e52" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">类似地，当我们调用delete操作符时，编译器将其翻译成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="2896" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">首先通过调用对象的析构函数来销毁对象，然后调用<code class="fe on oo op oq b">global ::operator delete</code>函数来释放内存。那么，这对简化我们的代码有什么帮助呢？</p><p id="95a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以通过在类中添加同名的静态函数来隐藏全局<code class="fe on oo op oq b">new</code>和<code class="fe on oo op oq b">delete</code>函数。</p><blockquote class="oh oi oj"><p id="5d13" class="lr ls ms lt b lu mn ju lw lx mo jx lz ok mp mc md ol mq mg mh om mr mk ml mm im bi translated">通过这样做，我们可以控制从哪里分配内存。</p></blockquote><p id="dd46" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以如下重写我们的<code class="fe on oo op oq b">Coordinate</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="44f2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们现在可以从上面创建的单体池中分配内存。这些函数不仅在我们手动使用<code class="fe on oo op oq b">new</code>和<code class="fe on oo op oq b">delete</code>操作符时被调用，</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="97d7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">而且当我们使用<code class="fe on oo op oq b">std::unique_ptr</code>时也是如此，比如在下面的代码中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><h2 id="0843" class="nv la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">各种类型/大小的游泳池</h2><p id="f7b7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以为不同大小的对象创建多个池。通过这样做，我们可以管理不同大小的对象。例如，对于1字节对象、4字节对象和12字节对象，我们可以有3个池。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="3da6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然后，我们可以根据对象的大小选择要分配内存的位置。我们可以在下面关于为<code class="fe on oo op oq b">Any</code>类型优化小对象的章节中看到如何使用这种技术。</p><h2 id="b9b5" class="nv la it bd lb nw nx dn lf ny nz dp lj ma oa ob ll me oc od ln mi oe of lp og bi translated">释放内存</h2><p id="7669" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通过使用内存池，我们仍然可以将未使用的内存返回给系统。但是我们不返回未使用的块，而是返回整个块。如果我们有一个完全未使用的块，我们可以通过调用<code class="fe on oo op oq b">singleton_coordinate_pool::release_memory()</code>来释放内存。</p><h1 id="27c1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">任何类型的小对象优化</h1><p id="2ba7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在<a class="ae ky" href="https://debby-nirwan.medium.com/passing-any-type-in-c-like-in-python-to-simplify-our-code-3af72347282d" rel="noopener">关于任何类型的文章</a>中，我写道C++标准鼓励任何类型的实现，以避免小对象的动态内存分配。这是为了避免内存碎片，因为像<code class="fe on oo op oq b">std::any</code>这样的任何类型实现都可以包装任何大小的对象，包括像字节这样的小对象。</p><p id="3ec4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">解决方案是就地构造小对象。在这种情况下，还有一种方法可以避免内存碎片。我们可以使用我们在前面几节中讨论过的内存池。</p><p id="5505" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以将运算符<code class="fe on oo op oq b">new</code>和<code class="fe on oo op oq b">delete</code>函数添加到我们的<code class="fe on oo op oq b">Any</code>类型实现中，以允许我们从内存池中分配内存，如下面的代码所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="a38e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以创建多个池，并根据所包含对象的大小分配/释放内存。如果大小足够大，在我们的例子中大于32字节，我们从堆/自由存储中分配内存。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="d943" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里需要注意的一点是，我们有额外的8字节数据来存储虚拟指针(<code class="fe on oo op oq b">vptr</code>)，因为我们在<code class="fe on oo op oq b">Any</code>类型中使用了虚函数。</p><p id="1f01" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">有了这个实现，我们在为小对象分配内存时就不用担心内存碎片了。您可以为您的应用程序调整“小”的大小，这里只是一个例子。</p><h1 id="9ddc" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">关键要点</h1><ul class=""><li id="43a2" class="mu mv it lt b lu lv lx ly ma pa me pb mi pc mm mz na nb nc bi translated">如果我们不小心，我们可能会在用C++编码时导致内存碎片</li><li id="df56" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">当使用C++库时，不清楚我们是否动态分配内存</li><li id="6e41" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">C++没有自动垃圾收集，所以我们需要知道我们在用内存做什么</li><li id="2263" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">避免碎片的一个可能的方法是使用内存池</li><li id="312c" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">内存池的工作原理是分配内存块并将它们分成固定大小的块</li><li id="fba3" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">我们可以通过隐藏类中的全局<code class="fe on oo op oq b">::operator new</code>和<code class="fe on oo op oq b">::operator delete</code>函数来提高抽象性</li><li id="f2e5" class="mu mv it lt b lu ov lx ow ma ox me oy mi oz mm mz na nb nc bi translated">这种技术可以在<code class="fe on oo op oq b">Any</code>型包装器中用于小对象优化。</li></ul><h1 id="4682" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">有用的链接</h1><div class="nd ne gp gr nf ng"><a href="https://towardsdatascience.com/c-type-erasure-wrapping-any-type-7f8511634849" rel="noopener follow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">C++类型擦除:包装任何类型</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">了解如何用C++编写类中任何类型的包装器，以提高代码的抽象层次。</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">towardsdatascience.com</p></div></div><div class="np l"><div class="pd l nr ns nt np nu ks ng"/></div></div></a></div></div></div>    
</body>
</html>