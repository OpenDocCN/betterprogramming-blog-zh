<html>
<head>
<title>5 TypeScript Libraries to Improve Your Codebase</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">5个类型脚本库来改进您的代码库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/5-typescript-libraries-to-improve-your-codebase-d26f74a5c3?source=collection_archive---------0-----------------------#2022-09-19">https://betterprogramming.pub/5-typescript-libraries-to-improve-your-codebase-d26f74a5c3?source=collection_archive---------0-----------------------#2022-09-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3a08" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">增加你对静态打字的信心</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d61f8c51651dc51583a181445aed1f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C24eNZfu0CT5fSTBt6IugA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="a1e4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在过去的几年里，TypeScript语言除了成长之外什么也没做。它被评为许多web开发人员最喜欢的语言。不得不在普通的JavaScript代码库中工作的情况越来越少。</p><p id="40ea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，有时TypeScript并没有被充分利用。铸件过多或使用<code class="fe lu lv lw lx b">any</code>是最常见的错误。</p><p id="0ef8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，我们将看到一个库列表，它将增强您的TypeScript体验，并增加您对其静态类型的信心。这些最小化的库将提升任何开发人员的人机工程学。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="53ec" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">1.佐德</h1><p id="7dac" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">TypeScript的薄弱环节是只在编译时进行验证。一旦它被解析和构建，所有类型都被移除。在以下情况下，这可能会导致一些不希望出现的错误:</p><ul class=""><li id="0d28" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">编译器信任开发人员的一些假设(使用<code class="fe lu lv lw lx b">any</code>、<code class="fe lu lv lw lx b">ts-expect-error</code>、造型等)</li><li id="6f64" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">网络返回的REST架构与预期的不同。</li></ul><p id="0bfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个后者的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e681" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，编译器相信网络将返回一个带有<code class="fe lu lv lw lx b">name</code>和<code class="fe lu lv lw lx b">email</code>属性的JSON <code class="fe lu lv lw lx b">User</code>对象。如果那被证明不是真的，我们将在生产中面临一些问题。不幸的是，这只能在运行时发现。</p><p id="fd4a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">zod</code>,我们可以定义一个在运行时也将被验证的模式。</p><p id="3122" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看使用<code class="fe lu lv lw lx b">zod</code>对前面代码的重构</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e444" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以选择如何处理错误。在上面的例子中,<code class="fe lu lv lw lx b">UserSchema.parse</code>将在运行时抛出一个错误。</p><p id="b78c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过使用<code class="fe lu lv lw lx b">safeParse</code>方法，我们可以选择不抛出错误。它非常适合在sentry上记录问题，而不会破坏用户体验。</p><p id="c3b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Zod非常强大，我们也可以通过使用<code class="fe lu lv lw lx b">z.infer</code>从模式中提取类型。我们可以在整个代码中传播该模式。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8c2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总之，它是一个强大的库，可以确保您的类型没有一个是不正确的，这可能会导致许多代码不一致。</p><p id="d356" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其他一些重要事实:</p><ul class=""><li id="d9f2" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">它很小:8kb缩小+压缩</li><li id="594e" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">零依赖性</li><li id="7332" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">不变的</li><li id="a028" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">简洁、可链接的界面</li><li id="034d" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">功能方法</li><li id="92cd" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">也适用于普通的JavaScript！不需要使用TypeScript。</li></ul><h2 id="9874" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">要求</h2><ul class=""><li id="72e8" class="nc nd it la b lb mx le my lh oe ll of lp og lt nh ni nj nk bi translated">TypeScript 4.1和更高版本</li><li id="a7ff" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">启用严格模式</li></ul><h2 id="cd71" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">装置</h2><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="78bb" class="ns mg it lx b gy ol om l on oo">npm install --save-dev zod</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="73f5" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">2.微小不变量</h1><p id="3389" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">有时，在代码中的某些地方，您可以确定可空值不是空值。在TypeScript的严格模式下，如果不进行空检查，它就会出错。为了绕过它，有一个本地的<code class="fe lu lv lw lx b">!</code>操作符。</p><p id="06e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cc6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以上是一个不好的实践，因为有时那些开发人员的假设可能是错误的。</p><p id="b5fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TypeScript为此提供了一个名为<code class="fe lu lv lw lx b">Asssertion Functions</code>的原生特性。<code class="fe lu lv lw lx b">tiny-invariant</code>库就建立在它的上面。</p><p id="9be0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以给<code class="fe lu lv lw lx b">tiny-invariant</code>一个假设和一个要抛出的消息，如果那是<code class="fe lu lv lw lx b">falsy</code>。只要不满足这些假设，它就会在运行时抛出异常。你可以稍后在哨兵或任何其他供应商赶上。这将增加对代码库的信心，并检测任何不一致的地方。</p><p id="a6c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个使用示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="67eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码库变得更加灵活和简洁。我们现在可以安全地清除大量多余的<code class="fe lu lv lw lx b">if</code>语句。</p><p id="112b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个包是最小的，你可以选择实现你自己的<code class="fe lu lv lw lx b">invariant</code>功能，如果你喜欢的话。</p><h2 id="ff2d" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">要求</h2><ul class=""><li id="8ee8" class="nc nd it la b lb mx le my lh oe ll of lp og lt nh ni nj nk bi translated">启用严格模式(否则毫无意义)</li></ul><h2 id="b588" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">装置</h2><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="1832" class="ns mg it lx b gy ol om l on oo">npm install --save-dev tiny-invariant</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="117d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">3.铅字节</h1><p id="8040" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">TypeScript最强大的功能之一是映射类型。如果你想掌握它，可以在这里找到我的文章。</p><p id="f8c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">TypeScript附带了一些实用程序，但是它们是有限的，只是作为一个起点。因此，最肯定的是，您的代码库中有一组实用工具。可能是在一个<code class="fe lu lv lw lx b">utils.d.ts</code>里，你可以从一个项目带到另一个项目。这绝对没问题，但是，还有其他方法可以解决这个问题。</p><p id="cd17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以使用许多库类型的实用程序。小心一些现在已经死了的像<code class="fe lu lv lw lx b">ts-toolbet</code>。它们提供了久经考验的类型，减少了编写新映射所花费的时间。通过观察npm趋势，你可以发现<code class="fe lu lv lw lx b">type-fest</code>是如何主导这个领域的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/429d88c417753dd67bcbf467fbc86023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tABIwNix_hF0qWSa-pJP5Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">https://npmtrends.com/<a class="ae op" href="https://npmtrends.com/" rel="noopener ugc nofollow" target="_blank">的搜索</a></p></figure><p id="649b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子。TypeScript本机<code class="fe lu lv lw lx b">Optional</code>实用程序非常有限。它只是让我们将所有属性标记为可选的。它缺乏粒度。</p><p id="4e74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看看<code class="fe lu lv lw lx b">type-fest</code>附带了哪些用例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="654b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以看到，要做到这一点，我们需要多么强大和多么少的代码。因为所有类型在编译时都被移除了，所以这不会增加包的大小。</p><p id="a0d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，所有这些类型的库实用程序都有一些要求和限制。所以您可能被迫更新到一个更新的TypeScript版本，或者要求您的代码在<code class="fe lu lv lw lx b">strict mode</code>上。</p><h2 id="6cfb" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">型式试验的要求</h2><ul class=""><li id="b8cc" class="nc nd it la b lb mx le my lh oe ll of lp og lt nh ni nj nk bi translated">TypeScript 4.7及以上版本</li><li id="8e8a" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">严格模式</li></ul><h2 id="a4a2" class="ns mg it bd mh nt nu dn ml nv nw dp mp lh nx ny mr ll nz oa mt lp ob oc mv od bi translated">装置</h2><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="5280" class="ns mg it lx b gy ol om l on oo">npm install --save-dev <strong class="lx iu">type-fest</strong></span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4425" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">4.ts变形</h1><p id="96c9" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">在很多不同的场景中，对代码执行静态分析是有用的。你可以使用<code class="fe lu lv lw lx b">jscodeshift</code>甚至<code class="fe lu lv lw lx b">babel</code>来实现。然而，对类型有更多的了解可能会更方便。</p><p id="fdc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">出于这个目的，您只能使用TypeScript编译器，它可以转化为一个陡峭的学习曲线。但愿<code class="fe lu lv lw lx b">ts-morph</code>项目早就开始了。它提供了一种以编程方式导航和操作TypeScript代码的更简单的方法。</p><p id="9973" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是如何实现的？</p><ul class=""><li id="2a57" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">通过围绕编译器API提供一些包装器。</li><li id="caa6" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">允许回退到编译器API</li><li id="8951" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">首先在内存中执行所有更改，只有在收到指令时才发出代码</li></ul><p id="7889" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个简单的例子，在这个例子中，将检查一个枚举，并在它确实存在的情况下对其进行更改。</p><p id="de0d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装非常简单</p><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="bb67" class="ns mg it lx b gy ol om l on oo">npm install --save-dev <strong class="lx iu">ts-morph</strong></span></pre><p id="ae4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以创建我们的<code class="fe lu lv lw lx b">example.ts</code>文件来运行我们的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5c52" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那我们只需要运行它</p><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="fcc2" class="ns mg it lx b gy ol om l on oo">npx ts-node example.ts</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="c03d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">5.类型-文档</h1><p id="e004" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">文档过程是构建API时的一个关键方面。它帮助其他开发人员快速掌握您的应用程序所公开的内容。通常每种语言都有自己构建文档的过程。</p><p id="2f61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了TypeScript，就没有内置的工具，这就是<code class="fe lu lv lw lx b">TypeDoc</code>诞生的原因。它使用代码注释来构建HTML或JSON格式的文档。它是可扩展的，支持多种配置。</p><p id="6e18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个工具带有方便的文档，可以在<a class="ae op" href="https://typedoc.org/" rel="noopener ugc nofollow" target="_blank">https://typedoc.org</a>找到。有一些简单的例子可以学习掌握这个工具。</p><p id="5074" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个如何给方法添加注释的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5392" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/8a2841e8238b14cec9a275df83cec2b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zwq7lpOJsOOuCNf3p-pBMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">生成的文档示例</p></figure><p id="2a6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你从盒子里得到很多:</p><ul class=""><li id="8d2a" class="nc nd it la b lb lc le lf lh ne ll nf lp ng lt nh ni nj nk bi translated">干净的界面</li><li id="b494" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">面包屑</li><li id="ceae" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">侧向导航</li><li id="0bae" class="nc nd it la b lb nl le nm lh nn ll no lp np lt nh ni nj nk bi translated">容易定制的CSS，以适应你的喜好</li></ul><p id="c9d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装置</p><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="699b" class="ns mg it lx b gy ol om l on oo">npm install typedoc --save-dev</span></pre><p id="c439" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了生成文档，它需要知道<code class="fe lu lv lw lx b">tsconfig.json</code>配置文件。它将根据给程序指定的入口点来扣除它。</p><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="e3ba" class="ns mg it lx b gy ol om l on oo">typedoc src/index.ts</span></pre><p id="3271" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以定义多个入口点</p><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="aeac" class="ns mg it lx b gy ol om l on oo">typedoc src/package1/index.ts src/package2/index.ts</span></pre><p id="db24" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以传递一个文件夹，而不是传递一个文件，TypeDoc将使用<code class="fe lu lv lw lx b">entryPointStrategy</code>来寻找一个<code class="fe lu lv lw lx b">index</code>文件。</p><p id="80d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种策略使得为工作区生成文档变得容易，只需运行</p><pre class="kj kk kl km gt oh lx oi oj aw ok bi"><span id="2dfd" class="ns mg it lx b gy ol om l on oo">// ✅ it will check in each package folder for an index.ts file<br/>typedoc --entryPointStrategy packages .</span></pre></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="d4d4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">包裹</h1><p id="8bbd" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">就是这样，这五个不同的TypeScript库中的任何一个都有可能提高您的任何项目的人机工程学。如前所述，有些可能很容易实现。这将归结为你的发展能力和优先事项。</p><p id="f589" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯</p><div class="os ot gp gr ou ov"><a rel="noopener  ugc nofollow" target="_blank" href="/es2022-features-javascript-a9f8f5dcba5a"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd iu gy z fp pa fr fs pb fu fw is bi translated">ES2022有什么新功能？4个最新的JavaScript特性</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">新ES13规格概述</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">better编程. pub</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj ks ov"/></div></div></a></div></div></div>    
</body>
</html>