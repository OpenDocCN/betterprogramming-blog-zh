<html>
<head>
<title>Demystifying Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭秘Spring Boot</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/demystifying-spring-boot-245e71feffc0?source=collection_archive---------5-----------------------#2020-12-02">https://betterprogramming.pub/demystifying-spring-boot-245e71feffc0?source=collection_archive---------5-----------------------#2020-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b4ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Spring Boot API开发的基础</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/c04a16e4f02250650b13177d19be9a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*AbiX4LwtSNozoyfypcKvEg.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">图片来源:Sprint Boot</p></figure><p id="325a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">后端框架的世界比前端框架的世界要罕见得多。你总是听说JavaScript和它的风格，比如React、Vue和Angular ( <em class="lq">咳咳</em>)。在YouTube上，前端视频的数量以秒为单位成倍增长，对于包括我在内的许多人来说，我们可能听到的第一种后端语言是PHP。我花了一段时间才意识到Python可以做类似Flask和Django的事情。但是，我没有看到这些像JavaScript和一般的Python和Java语言一样淹没我的通知。</p><p id="1537" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当浏览职位描述时，尤其是在我的国家，雇主要求的最常见的后端框架之一是<a class="ae lr" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot </a>。到这个时候，当我决定学习这个看似流行的框架时，我已经习惯了Flask和Express这样的框架。根据我的经验，我可以说这次旅行并不有趣。</p><p id="592e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我遇到的问题:</p><ol class=""><li id="1b79" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">春天和Spring Boot——到底有什么区别？</li><li id="c6e0" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">春天是古老的，这些年发行了相当多的版本。大多数代码片段不是被否决就是过时了。</li><li id="f0f7" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">要完成在Express或Flask中可以轻松完成的简单任务，需要做大量的工作。这一切的意义何在？</li><li id="4418" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">Java语法可能会变得复杂。</li><li id="0343" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">创建复杂程度不同的Spring项目有很多方法。</li><li id="8961" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated">对为什么使用某些语法的解释过于复杂。</li></ol><p id="303e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你和我一样，有这些问题，甚至是第一次学习Spring，这篇文章肯定会在你的编程之旅中帮助你。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="d6ef" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">什么是Spring Boot？</h1><p id="3a9c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">要回答这个问题，你需要知道什么是<a class="ae lr" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank">弹簧</a>。Spring是一个用于企业级应用程序的Java框架。它附带了许多工具，可以针对这种类型的开发进行配置。Spring允许的最常见的开发类型之一是创建web应用程序——尤其是API开发。当它变成配置地狱时，问题就出现了！启动任何类型的应用程序都需要大量的配置。</p><p id="fbe8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后Spring Boot来了。Spring团队意识到他们的开发人员运行如此多的配置是多么乏味。有了所有这些配置，甚至在开发开始之前就很容易出错。Spring Boot允许你抽象(隐藏)这些配置。因此，您可以获得一个预配置的模板应用程序。这将是你的起点。您可能想知道，“如果我想改变这些配置呢？”嗯，这就是Spring Boot的魅力所在——你可以随时更改它们，但大多数时候默认模板就是你所需要的，你可以在那里添加或删除你认为合适的任何内容。您甚至可以组合不同的模板(例如，Spring Web和Spring Security)。</p><p id="d59a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始吧。这篇文章将集中在获得Spring Boot的基础下来。主要的焦点是web应用程序，尤其是RESTful应用程序(API开发)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="1f93" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">什么是API？</h1><p id="736f" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">一个<em class="lq">应用程序编程接口</em>或<em class="lq"> API </em> <strong class="kw iu"> <em class="lq"> </em> </strong>是一个软件中介，允许两个应用程序相互对话。它们促进了程序之间的交流。它本质上是一个对特定服务的请求。这项服务理解您的请求，并根据您的要求做出适当的回应。</p><p id="a03a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，一个服务员接受你的订单，并根据你的要求给你一顿饭。</p><p id="9cd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个项目，我们将创建一个REST API。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="854d" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创建一个Spring Boot项目</h1><p id="57a8" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">由于Spring需要大量的配置，Spring团队创建了一个工具，您可以在其中生成多种配置。这些配置可以叠加起来创建您的起始项目。</p><p id="6cf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们访问<a class="ae lr" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start.spring.io/</a>产生我们的Spring Boot项目。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/cb049c24c5b8941fe1f02c9766bb54e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*isimKGwS5woeMvCRmcqzyA.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">打开页面。作者截图来自<a class="ae lr" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank">https://start.spring.io/</a></p></figure><p id="1939" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一页上面是我们将设立我们的Spring Boot项目。默认情况下，它附带了设置示例。我们将主要坚持默认设置。对于这个项目，我们将修改元数据并向项目添加依赖项。</p><h2 id="fd41" class="np mo it bd mp nq nr dn mt ns nt dp mx ld nu nv mz lh nw nx nb ll ny nz nd oa bi translated">该项目</h2><p id="2ef5" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">Java有两个包管理器，<a class="ae lr" href="https://maven.apache.org/what-is-maven.html" rel="noopener ugc nofollow" target="_blank"> Maven </a>和<a class="ae lr" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> Gradle </a>。</p><ul class=""><li id="e713" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp ob ly lz ma bi translated">maven——这是Java的行业标准包管理器。</li><li id="d744" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp ob ly lz ma bi translated">Gradle——Gradle比Maven更新，构建时间也更快。这在原生Android开发中使用。</li></ul><p id="f85c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于这个项目，我们将使用<em class="lq"> </em> Maven。</p><h2 id="c5a3" class="np mo it bd mp nq nr dn mt ns nt dp mx ld nu nv mz lh nw nx nb ll ny nz nd oa bi translated">项目元数据关键术语</h2><ul class=""><li id="07ea" class="ls lt it kw b kx nf la ng ld oc lh od ll oe lp ob ly lz ma bi translated"><strong class="kw iu"> Group </strong> —这是我们的项目将被放置的包的名称。惯例是给它一个你所代表的组织的反向域名。默认显示<em class="lq"> com.example </em>，这将是<em class="lq">example.com</em>的反向域名。如果你为一家公司工作，你会使用他们的反向域名，例如<em class="lq"> com.google </em>。我们将把我们的小组命名为<em class="lq"> com.starting </em>。</li><li id="c669" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp ob ly lz ma bi translated"><strong class="kw iu">工件</strong> —这是我们组中的包的名称，它将包含我们应用程序的主要代码。这就是<code class="fe of og oh oi b">public static void main</code>所在的位置。这个项目的工件是<em class="lq">基础</em>。</li><li id="f563" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp ob ly lz ma bi translated"><strong class="kw iu">包名</strong> —当组和工件字段被填充时，该字段将被自动填充。这是最初的包装。将它命名为组加工件是惯例。因此，这个项目被命名为<em class="lq"> com.starting.basics </em>。</li></ul><p id="a19d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">选择您的计算机系统支持的Java版本。较新的Java版本向后兼容旧版本。就我而言，在撰写本文时，我已经安装了最新版本的Java。但是为了简单起见，我将使用Java 8。</p><h2 id="b3f8" class="np mo it bd mp nq nr dn mt ns nt dp mx ld nu nv mz lh nw nx nb ll ny nz nd oa bi translated">属国</h2><p id="a9c9" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">依赖关系是那些默认配置。对于这个项目，我们将只使用一个依赖项:Spring Web依赖项。</p><ul class=""><li id="19c2" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp ob ly lz ma bi translated">Spring Web——包含构建Web应用程序所需的一切。在这种情况下，这是一个RESTful服务。它自带内置服务器。这个服务器是Apache Tomcat。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/13682d2cd48bae3ddaa44b119df058d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dx9xCziKmPiKkDjswox9bQ.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">最终配置。作者截图来自https://start.spring.io/<a class="ae lr" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="053f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的配置应该看起来如上图所示。</p><p id="9637" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在已经生成了我们的Spring Boot项目。这应该以. zip文件的形式出现。提取文件。记住地点——这非常重要。</p><p id="5e66" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我可能忘记了包括一些将在本文中用到的软件:</p><ol class=""><li id="7abe" class="ls lt it kw b kx ky la lb ld lu lh lv ll lw lp lx ly lz ma bi translated">IntelliJ  —我的Java集成开发环境。其他的也可以使用，但是我将要展示的过程主要是针对IntelliJ的。</li><li id="e56e" class="ls lt it kw b kx mb la mc ld md lh me ll mf lp lx ly lz ma bi translated"><a class="ae lr" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank">邮递员</a> —用于测试API</li></ol><p id="90f2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">IntelliJ来了，我们将使用它进行开发。我们将在IntelliJ中打开之前提取的项目。</p><p id="c565" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们将:</p><p id="1d9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">转到文件&gt;打开。然后选择并打开先前提取的包含项目的文件夹。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/a03159d5c4ac95342c1c0479974e0ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*wdbogBYn4FigMrOAuQjKGw.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="a218" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在打开时，它应该自动开始安装我们在Spring Initialzr中决定的依赖项。这些依赖项都存储在一个<code class="fe of og oh oi b">pom.xml</code>文件中。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="55fc" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">项目结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/a21f418db96a421615b3f56b2b52c656.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*ak8_dJ6AErzoRQXOjrlgMw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者截图</p></figure><p id="22e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上是一个Spring Boot项目的结构。我们的代码存储在<code class="fe of og oh oi b">src</code>文件夹中，它带有存储在<code class="fe of og oh oi b">test</code>文件夹中的内置测试。<code class="fe of og oh oi b">mvnw.cmd</code>本质上是这个本地包的Maven。记住Maven是我们在这个项目中使用的包管理器。你可以把它想象成一个npm (Node.js包管理器)或pip (Python包管理器),但只是本地安装——如果你愿意，你也可以全局安装。</p><p id="6be1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看<code class="fe of og oh oi b">pom.xml</code>。它位于项目的根目录中。如前所述，这是我们所有依赖项的存储位置，类似于Node中的<code class="fe of og oh oi b">package.json</code>。这个文件还存储了关于我们项目的一般配置和信息。你的<code class="fe of og oh oi b">pom.xml</code>看起来应该和下面的类似。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5969" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，它是XML格式的。在XML文件内部，您可以看到我们之前给出的相同的<code class="fe of og oh oi b">groupId</code>、<code class="fe of og oh oi b">artifactId</code>和<code class="fe of og oh oi b">description</code>。在父标记中，我们有一个项目模板，我们从它那里继承，在这个项目中使用。</p><p id="a5ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们所有的依赖关系都可以在<code class="fe of og oh oi b">dependencies</code>标签中找到。也可以在这里添加新的依赖项。</p><p id="d680" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们导航到我们的<code class="fe of og oh oi b">src</code>文件夹(我们的源代码所在)并进入<code class="fe of og oh oi b">com.starting.basics</code>。这个包和我们在Spring Initalzr中创建的包是一样的。在这个包中，我们应该有我们的主文件，<code class="fe of og oh oi b">BasicApplication.java</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="6e79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个带有main方法的基本Java类。这是我们应用程序的入口点。<code class="fe of og oh oi b">@SpringBootApplication</code>正是这个Spring Boot应用程序。这是一个为类提供一些功能的注释。Spring Boot有很多注解。这个特定的注释是对三个常规Spring注释的抽象，这三个注释合并成了一个。正如我之前强调的，Spring Boot是为了简化Spring开发而设计的。以前，您必须用<code class="fe of og oh oi b">@Configuration</code>、<code class="fe of og oh oi b">@EnableAutoConfiguration</code>和<code class="fe of og oh oi b">@ComponentScan</code>来注释这个类(本文或项目不需要这些知识)。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="3c27" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">创建静止控制器</h1><p id="ae53" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">所有这些的目的是创建一些API。为此，我们需要创建一个控制器。控制器只是处理传入请求并对该请求执行一些操作的服务。为此，我们将创建另一个类。</p><p id="e038" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe of og oh oi b">com.starting.basics</code>内部，创建一个<code class="fe of og oh oi b">RestApiController</code>类。这个类将会在我们的<code class="fe of og oh oi b">com.starting.basics</code>包中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/5b74cf4ecd975a1c115f7acf2af09b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*oQ9Y5D98iu6GEg8mAfYYRQ.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="1b9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要首先告诉Spring它是一个REST控制器。这是通过将<code class="fe of og oh oi b">@RestController</code>添加到<code class="fe of og oh oi b">RestApiController</code>类来实现的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/298eabcb375d30c4c236cc29ae2819ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*RrhY317wOzhYLA8-_oKGfA.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="e859" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong> IntelliJ应该处理自动完成和自动包导入，如上所示。</p><p id="e01d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Spring Boot的使用需要大量的包装进口。</p><p id="df00" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们需要添加第一个端点。这将是一个<code class="fe of og oh oi b">GET</code>请求。</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="fb90" class="np mo it oi b gy or os l ot ou">@RequestMapping(value = "/home",method = RequestMethod.<em class="lq">GET</em>)<br/>public String index(){<br/>    return "hello world";<br/>}</span></pre><p id="bb0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个方法可以添加到我们的<code class="fe of og oh oi b">RestApiController</code>类中。<code class="fe of og oh oi b">@RequestMapping</code>注释告诉Spring我们正在创建一个端点。该值指示附加到根URL的路径(&lt;根url &gt; + &lt;值&gt;)。<code class="fe of og oh oi b">RequestMethod.<em class="lq">GET</em></code>添加到方法参数中，告诉它我们正在进行的请求的类型。同样，你也可以用<code class="fe of og oh oi b">POST</code>、<code class="fe of og oh oi b">PUT</code>、<code class="fe of og oh oi b">PATCH</code>或<code class="fe of og oh oi b">DELETE</code>、<em class="lq">、</em>来代替<code class="fe of og oh oi b">GET</code>、<em class="lq">。如果没有指定方法，默认情况下，它将接受所有方法请求。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="57c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的代码现在应该看起来像上面的代码片段。</p><p id="fb3b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们最终运行我们的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2eb7eed30721e7437668e5917dbf0719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*-8HYViHOqMUWRniOYYholw.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="b823" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当您运行这段代码时，它将在<a class="ae lr" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080/ </a>上启动Tomcat Apache服务器。这将是我们的根URL。然而，因为我们有了那个<code class="fe of og oh oi b">@RequestMapping</code>值，所以我们访问端点的URL是<a class="ae lr" href="http://localhost:8080/home" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/home</a>。</p><p id="ed34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们在浏览器中导航到http://localhost:8080/home。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/4236b9a7d7e694f67acee7dc7fcb7214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRhG5B2qpP9rSzyufYwtOg.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者截图</p></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="a8ec" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">基础知识</h1><p id="b005" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">之前，我们使用请求映射来创建一个<code class="fe of og oh oi b">GET</code>请求。但是有一些速记语法可以达到同样的效果。除了使用<code class="fe of og oh oi b">@RequestMapping</code>，我们还可以使用<code class="fe of og oh oi b">@GetMapping</code>。</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="f517" class="np mo it oi b gy or os l ot ou">@GetMapping("/home2")<br/>public String index2(){<br/>    return "hello world 2";<br/>}</span></pre><p id="e849" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将上面的代码添加到控制器中。这是我们之前所做的简写语法。其他请求类型也有类似的方法，例如<code class="fe of og oh oi b">@PostMapping</code>。将它添加到我们的代码中之后，让我们重新运行我们的应用程序。</p><p id="8683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们转到<a class="ae lr" href="http://localhost:8080/home2" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/home 2</a>，我们将看到以下输出:</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="44f5" class="np mo it oi b gy or os l ot ou">hello world 2</span></pre><p id="4618" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在要做一个<code class="fe of og oh oi b">POST</code>请求。这需要一个邮递员。</p><p id="05c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在Spring Boot创建一个<code class="fe of og oh oi b">POST</code>请求，我们必须决定我们希望在请求体中包含什么。假设我们想要将一个雇员添加到一个假设的数据库中。我们希望我们的员工有一个<em class="lq"> </em> ID、名、姓和电子邮件地址。</p><p id="3178" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请求正文示例如下所示:</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="f21a" class="np mo it oi b gy or os l ot ou">{</span><span id="f73a" class="np mo it oi b gy ov os l ot ou">"eid": 1,</span><span id="76b3" class="np mo it oi b gy ov os l ot ou">"firstName":"jordan",</span><span id="edc3" class="np mo it oi b gy ov os l ot ou">"lastName": "williams",</span><span id="07eb" class="np mo it oi b gy ov os l ot ou">"email": "test@gmail.com"</span><span id="c1b7" class="np mo it oi b gy ov os l ot ou">}</span></pre><p id="b472" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建将被添加到控制器中的方法。</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="052b" class="np mo it oi b gy or os l ot ou">@PostMapping("/employee")<br/>public Employee addEmpoyee(@RequestBody Employee employee){<br/>    return employee;<br/>}</span></pre><p id="2f55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用<code class="fe of og oh oi b">@PostMapping</code>是因为它是一个<code class="fe of og oh oi b">POST</code>请求。我们通过<code class="fe of og oh oi b">@RequestBody</code>注释指定一个参数将出现在主体中。在这里我们有一个<code class="fe of og oh oi b">employee</code>对象。我们必须创建一个<code class="fe of og oh oi b">Employee</code>类。这个类将拥有与请求体中需要传递的属性相同的所有属性。同样的<code class="fe of og oh oi b">Employee</code>类是这个方法的返回类型。在Spring中，对象在返回时被转换成JSON。这个过程被称为材料化。</p><p id="da4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe of og oh oi b">com.starting.basics</code>包中，创建<code class="fe of og oh oi b">Employee</code>类，如下面的代码片段所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="8fdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们的<code class="fe of og oh oi b">Employee</code>班。</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="d782" class="np mo it oi b gy or os l ot ou">private int eid;<br/>private String firstName;<br/>private String lastName;<br/>private String email;</span></pre><p id="4559" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些属性构成了我们请求主体的蓝图。您的请求体需要与这些属性具有相同的名称，否则它不会附加到其特定的属性。来自发送的请求的JSON被序列化过程转换成<code class="fe of og oh oi b">employee</code>对象。</p><p id="b102" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置器是必需的，因为这是将主体中传递的值绑定到<code class="fe of og oh oi b">employee</code>对象的原因。吸气剂只是在必要时便于使用。</p><p id="a3b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们进入邮差和发送它的请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/a872ab57e60aecc58c5df82c2eb041c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*cOMONFJkUdrdvhu74du_rw.gif"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由作者生成的屏幕共享</p></figure><p id="baf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Postman中，我们必须提供在<code class="fe of og oh oi b">Employee</code>类中指定的所有字段。它获取所有这些字段并将它们存储在一个<code class="fe of og oh oi b">employee</code>对象中。如果一个字段拼写错误，它将不会被正确绑定到<code class="fe of og oh oi b">employee</code>对象的属性，JSON中的那个键将显示<code class="fe of og oh oi b">null</code>。</p><p id="562f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建API的另一个重要部分是使用状态代码。状态代码是普遍接受的代码，代表服务器上发生的操作。</p><p id="0ce0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe of og oh oi b">ResponseEntity</code>类在Spring Boot创建状态代码。这个类有静态和非静态声明。两者都将被显示。</p><p id="7225" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们创建另一个<code class="fe of og oh oi b">get</code>端点<code class="fe of og oh oi b">/restresponsecodes</code>。</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="04fe" class="np mo it oi b gy or os l ot ou">@GetMapping("/restresponsecodes")<br/>public ResponseEntity responses(){<br/><br/>    return new ResponseEntity("created response code ", HttpStatus.<em class="lq">OK</em>);<br/>}</span></pre><p id="3fc0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们返回了一个响应实体。该对象将显示在响应正文中的响应消息作为其第一个参数。在这个例子中，我放置了一个字符串。它很可能是一个已经被序列化为JSON的对象。第二个参数包含状态代码，由enum类<code class="fe of og oh oi b">HttpStatus</code>表示。在本例中，我们在该枚举下使用了<code class="fe of og oh oi b">OK</code>常量。如果您知道您的HTTP状态代码，您会知道<code class="fe of og oh oi b">OK</code>由状态代码201表示。还有其他几个常量可以使用，如<code class="fe of og oh oi b">NOT_FOUND</code>、<code class="fe of og oh oi b">BAD_REQUEST</code>、<code class="fe of og oh oi b">UNAUTHORIZED</code>等。，它们都有各自代表的状态码<em class="lq">。</em>它是一个包含所有HTTP状态码的enum。</p><p id="d396" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ow"><img src="../Images/16e6417f89749d966977a2e0e89ed9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mVKLow9l0H7bNuHRmkWqew.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">作者截图</p></figure><p id="87d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一种实现方法是使用<code class="fe of og oh oi b">ResponseEntity</code>类的静态方法。</p><p id="8aed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将用<code class="fe of og oh oi b">/restresponsecodes2</code>创建这个替代端点。</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="e219" class="np mo it oi b gy or os l ot ou">@GetMapping("/restresponsecodes2")<br/>public ResponseEntity responses2(){<br/><br/>    return ResponseEntity.<em class="lq">ok</em>("created");<br/>}</span></pre><p id="ac30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用静态方法<code class="fe of og oh oi b">.ok</code>。这相当于我们在前面的例子中所做的，但是我们使用了<code class="fe of og oh oi b">.ok</code>方法。这与放置<code class="fe of og oh oi b">HttpStatus.<em class="lq">OK</em></code>和<em class="lq">是一样的。我们现在需要做的就是声明在响应体中输出什么消息。在这种情况下，消息是<code class="fe of og oh oi b">“created”</code>。</em></p><p id="49dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这些静态的<code class="fe of og oh oi b">ResponseEntity</code>方法中，有一些要求你显式地给方法附加一个主体。</p><p id="41b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看下面的端点。</p><pre class="kj kk kl km gt on oi oo op aw oq bi"><span id="aca4" class="np mo it oi b gy or os l ot ou">@GetMapping("/restresponsecodes3")<br/>public ResponseEntity responses3(){<br/><br/>    return ResponseEntity.<em class="lq">badRequest</em>().body("something went wrong");<br/>}</span></pre><p id="7719" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于一个不好的请求，您必须在JSON中显式地为它放置一个包含您想要返回的消息的主体。</p><p id="ac32" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi ox"><img src="../Images/f7eb2e0739cc4238ee87812d0c14d6d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZK6FvZu0EA35g8dkpCJfqg.png"/></div></div></figure></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="ce2c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="db46" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">现在你知道了。你刚刚为Spring Boot打下了基础！这些是关于如何创建REST API的一些要点。接下来，我们将学习创建一个连接到数据库的CRUD应用程序。</p><div class="oy oz gp gr pa pb"><a href="https://medium.com/better-programming/demystify-spring-boot-part-2-dc957069b584" rel="noopener follow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">揭开Spring Boot的神秘面纱(下)</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">在Spring中构建一个连接到MariaDB数据库的API</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">medium.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ko pb"/></div></div></a></div></div></div>    
</body>
</html>