<html>
<head>
<title>What Should I Do If the Database Table is Locked?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库表被锁了怎么办？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-should-i-do-if-the-database-table-is-locked-fb8139079e8?source=collection_archive---------10-----------------------#2022-05-17">https://betterprogramming.pub/what-should-i-do-if-the-database-table-is-locked-fb8139079e8?source=collection_archive---------10-----------------------#2022-05-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c31b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解决此使用案例的故障排除和解决流程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5fabec65a89bdc229f78dc4397719eb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*23rPvfvX0EVqp3BQ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">多梅尼科·洛亚在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="876f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在程序员的职业生涯中，总会出现数据库表被锁的情况，前几天又碰到了。</p><p id="f0e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于业务需求突然，各部门都在批量操作导出数据，数据库还没有做到读写分离。结果是数据库中的一个表被锁定！</p><p id="ed6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用户反映系统部分功能无法使用。执行紧急调查以定位数据库表被锁定，然后执行紧急处理。</p><p id="c863" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将与您分享类似紧急情况的故障排除和解决过程。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b29e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">故障描述</strong></h1><p id="1327" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">用户在一个正常运行的页面上报告了一个502错误，于是他立即检查服务是否正常，数据库是否正常。</p><p id="84cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在控制台上，我看到数据库CPU猛增，积累了大量未提交的事务。有些交易已经被封锁了很长时间。基本定位是数据库层有问题。</p><h1 id="d543" class="mc md it bd me mf mz mh mi mj na ml mm jz nb ka mo kc nc kd mq kf nd kg ms mt bi translated"><strong class="ak">解决方案</strong></h1><p id="34e9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">看阻塞交易列表，发现有锁表现象。本想用控制台直接结束被阻塞的事务，但控制台账号权限有限，于是通过客户端登录相应账号杀死锁表事务，避免了情况恶化。</p><p id="eac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想象一个场景，这当然是软件工程师职业生涯中都会遇到的场景:一个本来正常运行的程序，突然有一天数据库的表被锁了，业务无法正常运行，那么如何快速定位表后是哪个事务锁，如何结束相应的事情？</p><p id="45a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个也是最简单的方法是重启MySQL。没错，网管解决问题的神器——就是“<strong class="lb iu">重启</strong>”。至于后果，能不能跑，要三思而后行！</p><p id="4a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重启可以解决锁表问题，但对于线上商家显然不可行。</p><p id="29eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看不停止服务的解决方案:</p><h2 id="c075" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated"><strong class="ak">第一步:检查表格使用情况</strong></h2><p id="89e5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当遇到数据库阻塞的问题时，必须首先检查表是否在使用中。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="2662" class="ne md it nr b gy nv nw l nx ny">show open tables where in_use &gt; 0 ;</span></pre><p id="15f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果查询结果为空，那么该表没有被使用，说明不是锁表的问题。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="b525" class="ne md it nr b gy nv nw l nx ny">mysql&gt;  show open tables where in_use &gt; 0 ;<br/>Empty set (0.00 sec)</span></pre><p id="3d79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果查询结果不为空，将出现以下结果:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="2298" class="ne md it nr b gy nv nw l nx ny">mysql&gt;  show open tables where in_use &gt; 0 ;<br/>+----------+-------+--------+-------------+<br/>| Database | Table | In_use | Name_locked |<br/>+----------+-------+--------+-------------+<br/>| test     | t     |      1 |           0 |<br/>+----------+-------+--------+-------------+<br/>1 row in set (0.00 sec)</span></pre><p id="5cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">意味着该表(测试)正在被使用，此时需要进一步调查。</p><h2 id="3ae9" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated"><strong class="ak">第二步:检查流程</strong></h2><p id="e125" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">查看数据库的当前进程，看看是否有任何缓慢的SQL或阻塞的线程。</p><p id="b9e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行SQL:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="a23b" class="ne md it nr b gy nv nw l nx ny">show processlist;</span></pre><p id="bdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个命令只显示当前用户运行的线程，当然，前提是根用户能够看到所有线程。</p><h2 id="14e8" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated"><strong class="ak">第三步:检查所有当前正在运行的事务</strong></h2><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="f635" class="ne md it nr b gy nv nw l nx ny">SELECT * FROM information_schema.INNODB_TRX;</span></pre><h2 id="b432" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated"><strong class="ak">步骤4:检查出现的当前锁</strong></h2><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="621d" class="ne md it nr b gy nv nw l nx ny">SELECT * FROM information_schema.INNODB_LOCKs;</span></pre><h2 id="7aca" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated"><strong class="ak">第五步:查询锁等待的对应关系</strong></h2><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="8e59" class="ne md it nr b gy nv nw l nx ny">SELECT * FROM information_schema.INNODB_LOCK_waits;</span></pre><p id="7c98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看事务表<code class="fe nz oa ob nr b">INNODB_TRX</code>中是否有被锁定的事务线程，看ID是否在<code class="fe nz oa ob nr b">show processlist</code>的睡眠线程中。如果是，说明这个睡眠的线程事务还没有提交或者回滚，而是被卡住了，需要手动杀死。</p><p id="b936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在搜索结果中，如果在事务表中发现了很多任务，最好把它们都干掉。</p><h2 id="691d" class="ne md it bd me nf ng dn mi nh ni dp mm li nj nk mo lm nl nm mq lq nn no ms np bi translated"><strong class="ak">第六步:终止交易</strong></h2><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="fd28" class="ne md it nr b gy nv nw l nx ny">kill some_pid;</span></pre><p id="05a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在相应的线程执行了kill命令后，后续事务可以正常处理。</p><p id="9e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于紧急情况，通常直接操作第一、二、六步。</p><p id="9453" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据库锁设计的初衷是为了处理并发问题。作为多个用户共享的资源，当并发访问发生时，数据库需要合理控制资源的访问规则，而锁是用来实现这些访问规则的重要数据结构。</p><p id="e88e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据锁定的范围，MySQL中的锁大致可以分为三类:全局锁、表级锁和行锁。MySQL中有两种类型的表级锁:一种是表锁，另一种是元数据锁(MDL)。</p><p id="36c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">表锁是在服务器层实现的。像<code class="fe nz oa ob nr b">alter table</code>这样的语句使用了表锁，而忽略了存储引擎的锁机制。表锁由<code class="fe nz oa ob nr b">lock tables … read/write</code>实现，对于InnoDB，一般使用行级锁。毕竟，锁定整个表对范围的影响太大了。</p><p id="d34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个表级锁是MDL(元数据锁)，用于在并发条件下维护数据一致性，保证读写的正确性。它不需要显式使用，而是在访问表时自动添加。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2192" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的锁表场景是当事务操作处于<strong class="lb iu">状态等待表元数据锁</strong>时。</p><p id="2544" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MySQL在执行<code class="fe nz oa ob nr b">alter table</code>等DDL操作时，有时会出现等待表元数据锁的等待场景。</p><p id="b6a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦<code class="fe nz oa ob nr b">alter table table_name</code>的操作被卡在等待表元数据锁定状态，对该表的任何后续操作(包括读取)都无法进行，因为在打开表阶段，它们也会进入等待表元数据锁定等待队列。</p><p id="96e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果核心表有一个锁定的等待队列，将会产生灾难性的后果。</p><ul class=""><li id="4d88" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">场景1:一个长事务运行，阻塞DDL，然后阻塞同一个表上的所有后续操作。通过<code class="fe nz oa ob nr b">show processlist</code>可以看到桌子上有正在进行的操作(包括读取)。此时，<code class="fe nz oa ob nr b">alter table</code>语句无法获得元数据排他锁，将等待。</li><li id="2776" class="oc od it lb b lc ol lf om li on lm oo lq op lu oh oi oj ok bi translated">场景2:为了提交事务，阻塞DDL，然后阻塞同一个表上的所有后续操作。通过<code class="fe nz oa ob nr b">show processlist</code>看不到表上的任何操作，但实际上有未提交的事务，可以在<code class="fe nz oa ob nr b">information_schema.innodb_trx</code>中查看。在事务完成之前，表上的锁不会被释放，并且alter table也不能获得元数据的排他锁。</li></ul><p id="76e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理方法:通过<code class="fe nz oa ob nr b">select * from information_schema.innodb_trx\G;</code>找到未提交事物的sid，然后将其杀死，让其回滚。</p><ul class=""><li id="2136" class="oc od it lb b lc ld lf lg li oe lm of lq og lu oh oi oj ok bi translated">场景3:显式事务失败操作获取锁，但不释放它</li></ul><p id="4ad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nz oa ob nr b">show processlist</code>之前，我看不到表上的任何操作，也看不到<code class="fe nz oa ob nr b">information_schema.innodb_trx</code>中正在进行的任何事务。很可能在一个显式事务中，对表执行了一个失败的操作(比如查询一个不存在的字段)，此时事务没有启动，但是失败语句获取的锁仍然有效，没有释放。失败的语句可以在<code class="fe nz oa ob nr b">performance_schema.events_statements_current</code>表中找到。</p><p id="418d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理方法:通过<code class="fe nz oa ob nr b">performance_schema.events_statements_current</code>找到它的sid，杀死会话，或者杀死DDL所在的会话。</p><p id="7c1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之<code class="fe nz oa ob nr b">alter table</code>的说法很危险(核心是未提交事务或者长事务导致的)。在操作之前，确保要操作的表上没有正在进行的操作、没有未提交的事务和没有显式的事务。中的错误语句。</p><p id="0067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果有一个<code class="fe nz oa ob nr b">alter table</code>维护任务在无人监管的情况下运行，最好通过<code class="fe nz oa ob nr b">lock_wait_timeout</code>设置超时时间，避免长时间的元数据锁等待。</p><p id="4d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在练习的过程中尽量避免锁表的情况，当然这需要一定经验的支持。</p><p id="5987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但更重要的是，如果发现锁表，一定要能够快速反应，快速解决问题，避免影响正常业务，避免事态进一步恶化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="5157" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读这篇文章。如果你在这篇文章中发现任何错误，请告诉我。</p></div></div>    
</body>
</html>