<html>
<head>
<title>Create a Scalable SwiftUI MVVM Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个可扩展的SwiftUI MVVM项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-scalable-swiftui-mvvm-project-f9afe3c2fcbf?source=collection_archive---------1-----------------------#2022-09-15">https://betterprogramming.pub/create-a-scalable-swiftui-mvvm-project-f9afe3c2fcbf?source=collection_archive---------1-----------------------#2022-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用MVVM架构制作一个文档完整、组织有序、可扩展的SwiftUI项目，让您的代码审查人员惊叹不已。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3757eb34e849249414cb3a7da7fa158.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oNNwDIDVgZLQEMFe"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">马丁·桑切斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1943" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">SwiftUI是苹果公司构建的蓬勃发展的新框架，它建立在他们的开源编码语言Swift之上。尽管SwiftUI在功能上仍需与UIKit保持一定的距离，但它为开发人员提供了创建视图的声明性语法。因此，它可以有漂亮的、可伸缩的代码来创建漂亮的UI。</p><p id="e55c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始构建一个优化的项目。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="6514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MVVM(模型、视图、视图-模型)架构有三种主要的数据结构:</p><ul class=""><li id="47a6" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><strong class="ky ir">视图</strong>是显示视图模型属性的UI。用户与视图交互，视图通过调用视图模型来处理用户的交互。</li><li id="8735" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><strong class="ky ir">视图模型</strong>封装了视图的逻辑，包括进行API调用，处理事件或数据，存储重要的属性。</li><li id="8522" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><strong class="ky ir">模型</strong>代表数据。它们是从API结果创建的对象，用于保存用户信息，或者是应用程序中的抽象对象。</li></ul><p id="b8fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过创建一个示例视图、视图模型和模型系统来开始我们的优化项目。在这个过程中，我将分享一些技巧来帮助您保持它的可伸缩性和文档化。</p><h1 id="363e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">构建完美的模型</h1><p id="9544" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们从模型开始。因为你是用Swift写的，所以你需要决定是使用类还是结构。</p><p id="04e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">类</strong>是按引用传递的；而<strong class="ky ir">结构</strong>是按值传递的。</p><p id="4c78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Apple建议您使用structs有几个原因，包括内存安全和降低复杂性。然而，<a class="ae kv" href="https://medium.com/@paulwall_21/why-does-apple-push-for-structs-e511e8c8124e" rel="noopener">的选择取决于你</a>。</p><p id="c1f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的例子中，我已经创建了一个<code class="fe nk nl nm nn b">Food</code>模型，它有一个名字，以及它是否是我的最爱。我准备用它做一个app，展示我所有喜欢的食物。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7732" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生了很多事。但是让我们注意一下事情是如何设置的:</p><ul class=""><li id="9142" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">这个<code class="fe nk nl nm nn b">Food</code>结构有一个包含<code class="fe nk nl nm nn b">/** */</code>的多行文档。在文档的扩展讨论中，使用双反勾符号提供了到<code class="fe nk nl nm nn b">FoodView</code>的链接。</li><li id="6b8e" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">每个物业都有单行的<code class="fe nk nl nm nn b">///</code>文档。每个方法都有多行文档。</li><li id="5216" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">一个<code class="fe nk nl nm nn b">// MARK: — </code>语句描述了属性和方法。我们将用它来区分属性、方法、初始化器、嵌套类/结构/枚举以及其他类型的实现。</li><li id="56b8" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">一个计算属性<code class="fe nk nl nm nn b">emoji</code>返回一个基于食物名称的表情符号。如果您想要显示仅与模型相关的内容，那么将计算的属性或函数封装在模型的逻辑中是一个很好的实践。当我们写<code class="fe nk nl nm nn b">FoodView</code>的时候，你会看到它的好处。</li><li id="0917" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">这个模型也有有用的方法，比如<code class="fe nk nl nm nn b">eat()</code>。</li></ul><p id="5689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！模型非常简单。如果您正在使用<code class="fe nk nl nm nn b">Codable</code>，您可能还想在您的模型中手动实现<code class="fe nk nl nm nn b">CodingKeys</code>、<code class="fe nk nl nm nn b">encode(to:)</code>和<code class="fe nk nl nm nn b">init(from:)</code>。</p><h1 id="359c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">在视图模型中准备逻辑</h1><p id="81ef" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在，我们的视图模型将采用一组<code class="fe nk nl nm nn b">Food</code>模型，它将允许我们显示和更改它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ac14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里需要注意的是:</p><ul class=""><li id="a840" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">FoodViewModel</code>符合<code class="fe nk nl nm nn b">ObservableObject</code>，为我们提供了<code class="fe nk nl nm nn b">@Published</code>包装器，使我们能够保持应用程序的最新状态。</li><li id="8142" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">出于个人偏好，我使用了<code class="fe nk nl nm nn b">// MARK: — </code>来划分包装和非包装属性。</li><li id="f6e7" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">已发布的属性<code class="fe nk nl nm nn b">allFoods</code>提供对我所有食物的访问。像这样加载/保存数据的一个好地方是在视图模型中。</li><li id="b216" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">toggleFavorite(food:)</code>接受一个<code class="fe nk nl nm nn b">Binding&lt;Food&gt;</code>对象，所以我可以通过引用更新食物的喜爱状态(因为结构是按值传递的)。</li></ul><h1 id="6776" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">打造伟大的观点</h1><p id="de8c" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated"><code class="fe nk nl nm nn b">FoodView</code>会显示用户喜欢的食物。我们将从一个滚动视图开始，它列出了一堆项目，显示食物对象。</p><p id="48a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于食物对象是独立的，我将创建一个<em class="nq">支持视图</em>来显示那个对象。我使用支持视图，以便我的<code class="fe nk nl nm nn b">body</code>属性美观、整洁、易读。</p><p id="9636" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一看:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="791f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它显示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/6c7ad35d75436da0dc5f1a9859c6ec13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KQRP06OOFnFQI8RzilmmA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的FoodView，显示一个显示所有食物的开关，以及项目列表。</p></figure><p id="14df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于上述观点的几点提示:</p><ul class=""><li id="4d73" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">分隔符<code class="fe nk nl nm nn b">// MARK: —</code>分隔包装属性、主体视图和支持视图。</li><li id="ab72" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">我将单个项目提取到一个支持视图中，以帮助提高<code class="fe nk nl nm nn b">body</code>的可读性和速度。将视图提取到变量/方法也使得调试更加容易，因为SwiftUI编译器通常很难编译大型的嵌套视图。</li><li id="6e0c" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">最后的润色，比如将食物的名字大写，在视图中用来改善外观。在模型或视图模型中使用计算属性来提高代码可读性是一个很好的实践。</li></ul><p id="c0c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们结束了。我们已经设置了基本的MVVM项目，并进行了一些优化。让我们在此基础上，添加一些额外的细节。</p><h1 id="41dd" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">全球单身族</h1><p id="e551" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在，我们需要一个对象来传递全局信息。我使用一个<code class="fe nk nl nm nn b">Global</code> <code class="fe nk nl nm nn b">@EnvironmentObject</code> singleton来处理这个问题。</p><p id="f7d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常情况下，你会希望在<code class="fe nk nl nm nn b">Global</code>中存储应用程序使用的信息。在我的大多数应用中，我将用户数据存储在一个<code class="fe nk nl nm nn b">activeUser</code>属性中。下面是一个简单的<code class="fe nk nl nm nn b">Global</code>类的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7c45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的视图中，我使用以下代码来定义环境对象，并将其传递给我的根视图:</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="7090" class="nw mo iq nn b gy nx ny l nz oa">let global = Global()<br/>...<br/>MyMainRootView().environmentObject(global)</span></pre><p id="8e4b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，要在“我的所有子视图”中访问我的全局对象:</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="c608" class="nw mo iq nn b gy nx ny l nz oa">/// <em class="nq">The Global </em>`EnvironmentObject`<em class="nq">.<br/></em>@EnvironmentObject <strong class="nn ir"><em class="nq">var</em></strong> global: Global</span></pre><p id="5b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有关如何在您的视图中实现<code class="fe nk nl nm nn b">EnvironmentObject</code>的更多信息，请查看<a class="ae kv" href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-use-environmentobject-to-share-data-between-views" rel="noopener ugc nofollow" target="_blank">这篇关于Swift的文章</a>。</p><p id="e9ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我经常在我的项目中使用<code class="fe nk nl nm nn b">Global</code>,所以我创建了一个代码片段来帮助提高速度。</p><p id="1bd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码片段非常适合输入带有可选占位符的预写代码。查看Sarunw 的这篇文章，了解更多关于在Xcode中创建自己的代码片段的信息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/74fa74cdc6d814e76c96edb31d9a3b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MXCFAEH0P-RMCzcbcyzKPw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我使用代码片段来快速添加全局、视图模型或其他属性。</p></figure><h1 id="9879" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">视图模型协议和依赖注入</h1><p id="9b50" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">到目前为止，我们已经定义了一个视图模型来帮助管理与<code class="fe nk nl nm nn b">FoodView</code>相关的各种逻辑。但是许多项目将使用多视图模型。因此，我们需要一种方法来抽象我们的视图模型，以遵守单一的<code class="fe nk nl nm nn b">ViewModel</code>协议。</p><p id="66ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在构建我们的<code class="fe nk nl nm nn b">ViewModel</code>协议时，我们要记住的一件事是我们偶尔需要访问我们的<code class="fe nk nl nm nn b">Global</code>对象。理想情况下，我们会将一个<code class="fe nk nl nm nn b">global</code>实例传递给视图模型的初始化器。</p><p id="6139" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，如果你试图这样做，你会遇到一些问题。您不能将<code class="fe nk nl nm nn b">global</code>传递给视图模型的初始化器，因为<code class="fe nk nl nm nn b">global</code>只有在视图的属性(包括视图模型)被初始化之后<em class="nq">才可用。</em></p><p id="71e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着我们必须<em class="nq">注入</em>对象作为视图模型的依赖。由于我们正在研究一个通用的视图模型协议，我们可以对这个依赖注入进行编码，这样我们创建的每个视图模型都会自动支持<code class="fe nk nl nm nn b">global</code>注入:</p><pre class="kg kh ki kj gt ns nn nt nu aw nv bi"><span id="73aa" class="nw mo iq nn b gy nx ny l nz oa">protocol ViewModel: ObservableObject {</span><span id="6e05" class="nw mo iq nn b gy oc ny l nz oa">  // MARK: - Properties</span><span id="9632" class="nw mo iq nn b gy oc ny l nz oa">  /// The global instance.<br/>  var global: Global? { get set }<br/>}</span><span id="80bf" class="nw mo iq nn b gy oc ny l nz oa">extension ViewModel {</span><span id="c632" class="nw mo iq nn b gy oc ny l nz oa">  // MARK: - Methods</span><span id="fcb4" class="nw mo iq nn b gy oc ny l nz oa">  /**<br/>   Prepares the view model with the global instance.</span><span id="0e3a" class="nw mo iq nn b gy oc ny l nz oa">   - parameter global: The global instance, taken from a `View`<br/>   */<br/>  func prepare(with global: Global) {<br/>    self.global = global<br/>  }<br/>}</span></pre><p id="66fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我在所有项目中用来定义<code class="fe nk nl nm nn b">ViewModel</code>协议的代码(有额外的文档)。</p><p id="e8cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个视图模型协议配备了一个新方法<code class="fe nk nl nm nn b">prepare(with:)</code>，它允许您为视图模型提供一个<code class="fe nk nl nm nn b">Global</code>实例。在<code class="fe nk nl nm nn b">onAppear(perform:)</code>中调用它，您将能够在您的视图模型中访问您的<code class="fe nk nl nm nn b">global</code>对象！</p><h1 id="2b2a" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">构建您的项目</h1><p id="cdb0" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">您可以按照自己喜欢的方式组织和构建项目。由于我们的项目是基于MVVM体系结构构建的，因此我们可以将其内容组织到模型、视图模型和视图文件夹中。剩余的内容可以放在其他文件夹中:</p><ul class=""><li id="ddbd" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">Lifecycle</code>文件夹，存放<code class="fe nk nl nm nn b">AppDelegate</code>、<code class="fe nk nl nm nn b">yourApp</code>或<code class="fe nk nl nm nn b">Global</code>等全app相关文件。</li><li id="acbb" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">Utilities</code>文件夹，用于帮助方法、额外协议等。</li><li id="3e68" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">Extensions</code>，用于Swift和模块扩展。</li><li id="62bc" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">Components</code>，用于小型、高度可重用(不依赖视图模型)的SwiftUI视图。</li><li id="abb9" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">View Modifiers</code>，用于自定义视图修改器。</li><li id="7620" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">Styles</code>，为<code class="fe nk nl nm nn b">ButtonStyles</code>、<code class="fe nk nl nm nn b">MenuStyles</code>、<code class="fe nk nl nm nn b">PickerStyles</code>、<code class="fe nk nl nm nn b">TextFieldStyles</code>等。</li><li id="b03b" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">Enumerations</code>，用于项目范围的枚举。</li><li id="d63a" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated"><code class="fe nk nl nm nn b">Assets</code>，如果您希望对与您项目的资产目录不兼容的任何资产进行分组。</li></ul><p id="125d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我在本文中构建的项目的结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a3fdc7d705dd2d2d8f409d58aefe92ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*l0hX6rE5fIse8kdmmbENFA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的项目结构。模型、视图和视图模型放置在各自的文件夹中。</p></figure><p id="d6e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想回顾构建了什么，或者你想用它作为模板，你可以在GitHub 上查看整个项目<a class="ae kv" href="https://github.com/benlmyers/MVVM-SwiftUI" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一个额外的、更大规模的例子，下面是我的个人项目<code class="fe nk nl nm nn b">Flowductive</code>的结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/c84a458bd8ebe8714e90cb21935ab96f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*UuouIgxQNxwaioDE7bQntA.png"/></div></figure><p id="052b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个项目使用相同的MVVM架构，但是跨平台代码被分成基于需求的<code class="fe nk nl nm nn b"><strong class="ky ir">Platform</strong></code>和<code class="fe nk nl nm nn b"><strong class="ky ir">Shared</strong></code>目录。如果您对编写多平台代码感兴趣，我将在不久的将来撰写关于多平台开发的文章。</p><p id="62e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>