<html>
<head>
<title>Using Synchronization Primitives in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用同步原语</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-synchronization-primitives-in-go-mutex-waitgroup-once-2e50359cb0a7?source=collection_archive---------12-----------------------#2019-10-15">https://betterprogramming.pub/using-synchronization-primitives-in-go-mutex-waitgroup-once-2e50359cb0a7?source=collection_archive---------12-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c6c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索互斥、WaitGroup和Once并举例说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da910b66001b0e7e2f26c568a6f71e2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nR7DEX5BpkkUOWF1ql0nAw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@hollymandarich?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">霍利·曼达里奇</a>在<a class="ae ky" href="https://unsplash.com/s/photos/go?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到适可而止Go！</p><p id="5672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是关于<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go编程语言</a>的系列文章的第二篇，在这篇文章中，我将介绍一些最常用的Go标准库包，例如<a class="ae ky" href="https://golang.org/pkg/encoding/json/" rel="noopener ugc nofollow" target="_blank">编码/json </a>、<a class="ae ky" href="https://golang.org/pkg/io/" rel="noopener ugc nofollow" target="_blank"> io </a>、<a class="ae ky" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank"> net/http </a>、<a class="ae ky" href="https://golang.org/pkg/sync/" rel="noopener ugc nofollow" target="_blank"> sync </a>等。我计划保持这些相对简短和例子驱动。</p><p id="68a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了Goroutines和通道之外，让我们看看Go在<code class="fe lv lw lx ly b"><a class="ae ky" href="https://godoc.org/sync" rel="noopener ugc nofollow" target="_blank">sync</a></code> <a class="ae ky" href="https://godoc.org/sync" rel="noopener ugc nofollow" target="_blank">包</a>中提供的一些底层同步结构。有很多，但是我们将通过例子来探索<code class="fe lv lw lx ly b">WaitGroup</code>、<code class="fe lv lw lx ly b">Mutex</code>和<code class="fe lv lw lx ly b">Once</code>。</p><p id="f5fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub 上有<a class="ae ky" href="https://github.com/abhirockzz/just-enough-go" rel="noopener ugc nofollow" target="_blank">的代码示例。</a></p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f147" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">等待组</h1><p id="d4a5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你的程序需要等待一堆Goroutines完成，使用<code class="fe lv lw lx ly b">WaitGroup</code>进行协调。它类似于Java中的一个<code class="fe lv lw lx ly b">CountDownLatch</code>。让我们看一个例子。</p><p id="bda6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望并行打印主目录中的所有文件。使用<code class="fe lv lw lx ly b">WaitGroup</code>指定等待的任务/go routine的数量。</p><p id="a9b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，它与主目录中的文件/目录数量相同。我们使用<code class="fe lv lw lx ly b">Wait()</code>来阻塞，直到<code class="fe lv lw lx ly b">WaitGroup</code>计数器变为零。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2a6a" class="nh mh it ly b gy ni nj l nk nl">...<br/>func main() {<br/>    homeDir, err := os.UserHomeDir()<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    filesInHomeDir, err := ioutil.ReadDir(homeDir)<br/>    if err != nil {<br/>        panic(err)<br/>    }<br/>    var wg sync.WaitGroup<br/>    wg.Add(len(filesInHomeDir))<br/>    for _, file := range filesInHomeDir {<br/>        go func(f os.FileInfo) {<br/>            defer wg.Done()<br/>        }(file)<br/>    }<br/>    wg.Wait()<br/>}<br/>...</span></pre><p id="618b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行该程序:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ff9a" class="nh mh it ly b gy ni nj l nk nl">curl https://raw.githubusercontent.com/abhirockzz/just-enough-go/master/sync/wait-group-example.go -o wait-group-example.go<br/>go run wait-group-example.go</span></pre><p id="9f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在用户主目录中找到的每一个<code class="fe lv lw lx ly b">os.FileInfo</code>都会产生一个Goroutine，一旦我们打印出它的名字，计数器就会使用<code class="fe lv lw lx ly b">Done</code>递减。程序在主目录的所有内容被覆盖后退出。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2a74" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">互斥（体）…</h1><p id="9d12" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">Mutex</code>是一个共享锁，你可以用它来提供对你的代码的某些部分的独占访问。在这个简单的例子中，我们有一个在<code class="fe lv lw lx ly b">incr</code>函数中使用的共享/全局变量<code class="fe lv lw lx ly b">accessCount</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ca87" class="nh mh it ly b gy ni nj l nk nl">func incr() {<br/>    mu.Lock()<br/>    defer mu.Unlock()<br/>    accessCount = accessCount + 1<br/>}</span></pre><p id="b2a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，<code class="fe lv lw lx ly b">incr</code>功能受到了<code class="fe lv lw lx ly b">Mutex</code>的保护。因此，一次只有一个Goroutine可以访问它。我们向它扔了多枚手榴弹。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="570d" class="nh mh it ly b gy ni nj l nk nl">loop := 500<br/>for i := 1; i &lt;= loop; i++ {<br/>        go func(c int) {<br/>            wg.Add(1)<br/>            defer wg.Done()<br/>            incr()<br/>        }(i)<br/>}</span></pre><p id="961a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你运行这个，你将总是得到相同的结果，即<code class="fe lv lw lx ly b">Final = 500</code>(因为for循环运行500次迭代)。要运行该程序:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ba4f" class="nh mh it ly b gy ni nj l nk nl">curl https://raw.githubusercontent.com/abhirockzz/just-enough-go/master/sync/mutex-example.go -o mutex-example.go<br/>go run mutex-example.go</span></pre><p id="8c8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe lv lw lx ly b">incr</code>功能中注释(或删除)以下行，并在本地机器上运行程序，然后再次运行程序:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a858" class="nh mh it ly b gy ni nj l nk nl">mu.Lock()<br/>defer mu.Unlock()</span></pre><p id="fc25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到可变的结果，例如<code class="fe lv lw lx ly b">Final = 474</code>。</p><p id="d9a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我鼓励你仔细阅读<code class="fe lv lw lx ly b"><a class="ae ky" href="https://golang.org/pkg/sync/#RWMutex" rel="noopener ugc nofollow" target="_blank">RWMutex</a></code>。这是一种特殊的锁，可用于允许并发读取，但允许同步(单个写入方)写入。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7b3a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一次</h1><p id="5e64" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">它允许你定义一个在你的程序生命周期中只执行一次的任务。</p><p id="6202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这对于类似<code class="fe lv lw lx ly b">Singleton</code>的行为非常有用。它有一个单独的<code class="fe lv lw lx ly b">Do</code>函数，让您传递另一个您只打算执行一次的函数。让我们看一个例子。</p><p id="8285" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您正在使用Go <code class="fe lv lw lx ly b">net/http</code>包构建一个REST API，并且您希望只有在调用HTTP处理程序时才执行一段代码(例如，获取一个DB连接)。</p><p id="1156" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以用<code class="fe lv lw lx ly b">once.Do</code>包装该代码，并确信它只会在第一次调用处理程序时运行。</p><p id="209f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个我们只想执行一次的函数:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f4aa" class="nh mh it ly b gy ni nj l nk nl">func oneTimeOp() {<br/>    fmt.Println("one time op start")<br/>    time.Sleep(3 * time.Second)<br/>    fmt.Println("one time op started")<br/>}</span></pre><p id="8027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们在HTTP处理程序中所做的——注意<code class="fe lv lw lx ly b">once.Do(oneTimeOp)</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3050" class="nh mh it ly b gy ni nj l nk nl">func main() {<br/>    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {<br/>        fmt.Println("http handler start")<br/>        once.Do(oneTimeOp)<br/>        fmt.Println("http handler end")<br/>        w.Write([]byte("done!"))<br/>    })<br/>    log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><p id="25af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行代码并访问REST端点。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="783f" class="nh mh it ly b gy ni nj l nk nl">curl https://raw.githubusercontent.com/abhirockzz/just-enough-go/master/sync/once-example.go -o once-example.go<br/>go run once-example.go</span></pre><p id="933f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从不同的终端:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d0f3" class="nh mh it ly b gy ni nj l nk nl">curl localhost:8080<br/>//output - done!</span></pre><p id="2b97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您第一次访问它时，返回速度会有点慢，您会在服务器中看到以下日志:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ff0d" class="nh mh it ly b gy ni nj l nk nl">http handler start<br/>one time op start<br/>one time op end<br/>http handler end</span></pre><p id="7ad7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果再次运行(任意次数)，功能<code class="fe lv lw lx ly b">oneTimeOp</code>将不会被执行。检查日志以确认。</p><p id="0856" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一块就这么多了。我将非常乐意接受您希望我涵盖的特定Go主题的建议。</p></div></div>    
</body>
</html>