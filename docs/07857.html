<html>
<head>
<title>6 Tips for Creating Helm Charts in Kubernetes Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Kubernetes应用程序中创建舵图的6个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-tips-for-creating-helm-charts-in-kubernetes-applications-452a37446f31?source=collection_archive---------3-----------------------#2021-02-26">https://betterprogramming.pub/6-tips-for-creating-helm-charts-in-kubernetes-applications-452a37446f31?source=collection_archive---------3-----------------------#2021-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1394" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建、维护和控制舵图发布，减少错误和代码问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29c6ccc7732d0dcfd6efa4f82fa15974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vjs0B43_-ILG594O"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">威廉·艾文在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="4fa8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>是一个编排工具，用于运行、自动化和管理容器化应用程序的生命周期。Kubernetes管理的所有资源都需要以YAML或JSON格式定义，并由Kubernetes API服务器处理。</p><p id="97de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Kubernetes部署应用程序通常需要定义多个资源(这高度依赖于应用程序本身)，比如配置映射、秘密部署和服务资源。这些资源都需要使用Kubernetes API服务器来创建。此外，有些资源需要按照特定的顺序创建，或者需要等待其他资源创建成功。</p><p id="3e0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes没有为应用程序的资源提供打包解决方案。幸运的是，一个叫做<a class="ae ky" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> Helm </a>的工具提供了开箱即用的特性。</p><p id="2ef2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以考虑Helm Kubernetes应用程序的包管理器。Helm将部署给定应用程序所需的Kubernetes资源打包到一个称为图表的单元中。Helm chart不仅封装了Kubernetes资源，还可以明确定义这些资源的创建顺序。</p><p id="cfb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是使用Helm部署Kubernetes服务的主要优势:</p><ul class=""><li id="662c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">它降低了部署微服务的复杂性。</li><li id="5cbe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它简化了部署脚本和文件(都是在YAML定义的)。</li><li id="29d7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它提高了部署和回滚的效率。</li><li id="e932" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它提供了一种将Kubernetes资源作为一个单元进行版本控制的方法。</li></ul><p id="08aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了能够使用Helm将应用程序部署到Kubernetes集群，您需要为应用程序创建Helm图表，并确保该图表对Kubernetes集群可用。可以使用Helm命令行引导新图表，如下所示:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="84c8" class="mo mp it mk b gy mq mr l ms mt">$&gt; helm create service-x</span></pre><p id="8a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义的图表将用于部署您的应用程序。因此，确保所有图表版本都具有一定程度的质量(例如，图表没有语法错误)是很重要的。</p><p id="7616" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将强调在开发和创建容器化应用程序的舵图时需要考虑的六个主题。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="b191" class="nb mp it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated"><strong class="ak"> 1。为每个已定义的资源定义单元测试</strong></h1><p id="6f42" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">确保Helm图表的一致性和健壮性是很重要的——特别是如果该图表是为外部使用而开发的，比如MySQL和NGINX的公共图表。幸运的是，通过简单地为舵图及其所有资源定义单元测试，实现这一点是一件简单的任务。</p><p id="2434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">helm-unittest 是一个helm插件，它使我们能够为Helm图表定义单元测试，并使用YAML格式的测试文件进行测试。该插件提供的主要功能有:</p><ol class=""><li id="2f43" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">单元测试是用纯YAML语法定义的(测试易于阅读和理解)。</li><li id="866f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">它不需要Kubernetes集群，可以在本地执行。</li><li id="1b4b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">它测试图表值和发布配置。</li><li id="29b8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">它支持快照来控制资源文件中的更改。</li></ol><p id="3339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始为您的图表开发测试用例，您必须完成以下两项任务:</p><ul class=""><li id="b729" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">安装头盔插件:</li></ul><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="1fed" class="mo mp it mk b gy mq mr l ms mt">$ helm plugin install https://github.com/lrills/helm-unittest</span></pre><ul class=""><li id="8491" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">开始创建和编写测试用例。测试用例需要存储在你的图表的根目录下(即<code class="fe ny nz oa mk b">$YOUR_CHART/tests/deployment_test.yaml</code>)。</li></ul><p id="14ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试用例以纯YAML格式定义。例如，下面的YAML文件代表了一个测试用例，它验证了一个部署资源的属性，比如副本数量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="abe9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，您可以为其他Kubernetes资源定义测试用例，比如服务、配置映射和pods。关于支持的语法的更多信息可以在GitHub 上找到<a class="ae ky" href="https://github.com/lrills/helm-unittest/blob/master/DOCUMENT.md" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="11ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行和执行已定义的测试用例可以通过执行以下命令来完成:</p><pre class="kj kk kl km gt mj mk ml mm aw mn bi"><span id="e7b7" class="mo mp it mk b gy mq mr l ms mt">$&gt; helm unittest $YOUR_CHART_NAME</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="c84e" class="nb mp it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated"><strong class="ak"> 2。集成图表的持续集成管道</strong></h1><p id="da83" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated"><a class="ae ky" href="https://github.com/lrills/helm-unittest" rel="noopener ugc nofollow" target="_blank"> helm-unittest </a>提供了一种编写和定义Helm chart单元测试的方法，但是它没有自动执行这些单元测试，也没有涵盖我们需要考虑的其他方面，例如:</p><ol class=""><li id="05d6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">检查/林挺图表资源。</li><li id="89e3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">测试图表安装。</li></ol><p id="70e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个名为ct <strong class="lb iu"> </strong>的工具是为基于拉取请求的测试和林挺掌舵图而设计的。这个工具将使用户能够确保一个干净和绿色的舵轮图的主要分支。在合并源代码变更之前，应该发现所有的错误和语法问题。</p><p id="fb50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ct <strong class="lb iu"> </strong>基本上是一个命令行应用。但是，它也支持通过环境变量或配置文件定义命令行标志。它还支持混合的CLI标志、环境变量和配置文件。在这种情况下，以下优先顺序适用:</p><ol class=""><li id="562e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">CLI标志</li><li id="4f0f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">环境变量</li><li id="01dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">配置文件</li></ol><p id="6b2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将ct <strong class="lb iu"> </strong>命令行与在pull请求上执行的CI管道集成起来是一项简单的任务。完成这个任务的一个方法是利用下面的<a class="ae ky" href="https://github.com/helm/chart-testing-action" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>。下面是一个GitHub动作工作流程的例子，可以用于林挺和测试舵图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="ff0a" class="nb mp it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated"><strong class="ak"> 3。自动化图表发布</strong></h1><p id="58a8" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">每当舵轮图发生变化时，自动发布海图是很重要的。图表发布的自动化将实现不同环境中应用程序部署的自动化，以及端到端集成测试的自动化。幸运的是，这个任务也很简单，我们有几个选项来完成这个任务。</p><p id="85aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">选择在哪里发布图表时，一个重要的问题是图表是需要公开访问还是只需要内部访问。</p><p id="8891" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这三个选项可用于发布舵图:</p><ol class=""><li id="727b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">运行您自己的<a class="ae ky" href="https://chartmuseum.com/" rel="noopener ugc nofollow" target="_blank"> chartmuseum </a>实例——chart museum是一个开源的Helm chart服务器。如果您希望能够灵活地推动舵图，并且拥有运行服务器所需的资源，请使用此选项来托管您的图表。chartmuseum支持几个本地特性，比如在AWS中存储图表和身份验证。</li><li id="0a4b" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">使用其中一个托管服务来托管Helm charts —如果您不想自己管理charts服务器，但仍然希望拥有私有图表，您可以选择使用主机charts服务器的可用选项之一，例如<a class="ae ky" href="https://jfrog.com/" rel="noopener ugc nofollow" target="_blank"> JFrog </a>平台(JFrog也可以选择自托管)。使用JFrog，您可以构建Helm chart存储库，并在几分钟内开始向其发布图表。此外，只需执行一个<code class="fe ny nz oa mk b">curl</code>命令就可以将图表推送到存储库。</li><li id="3bc6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">使用Git-Pages在GitHub上发布舵图——有几个选项可以在集中式图表服务器上发布公共舵图，如<a class="ae ky" href="http://chartcenter" rel="noopener ugc nofollow" target="_blank"> chartcenter </a>。然而，我更喜欢简单地用GitHub页面发布Helm公共图表。该选项仅在图表应该是公共的情况下才适用，因为GitHub没有提供实现GitHub页面认证的本机方式。通过将下面的<a class="ae ky" href="https://github.com/helm/chart-releaser-action" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>与为应用程序实现的GitHub工作流集成，可以完成这项任务。</li></ol></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="d3ff" class="nb mp it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated"><strong class="ak"> 4。处理图表机密</strong></h1><p id="a6bd" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">Helm charts封装了所有的Kubernetes资源，包括存储应用程序配置的配置图。一些配置通常被视为敏感数据，应受到保护，不得公开共享或提交给图表的源代码。因此，在构建舵图时，处理以下两点非常重要:</p><ol class=""><li id="88fe" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">将配置与秘密分开——Kubernetes提供了一个名为<em class="od">秘密</em>的资源，其工作方式与<code class="fe ny nz oa mk b">configmap</code>完全相同，只是它以编码的形式存储数据。应该使用这种资源类型而不是配置映射来存储和管理所有应用程序机密，例如数据库连接信息或API密钥和机密。通过这一更改，我们可以确保秘密不会以纯文本的形式存储在Kubernetes集群上。</li><li id="05b6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">使用<a class="ae ky" href="https://github.com/jkroepke/helm-secrets" rel="noopener ugc nofollow" target="_blank"> helm-secrets </a>插件来管理图表机密——第一点仅涉及机密如何存储在Kubernetes集群上。我们仍然可以在<code class="fe ny nz oa mk b">values.yaml</code>文件中添加秘密的值，并以纯文本形式将它们传递给舵图。更危险的是，我们可以将<code class="fe ny nz oa mk b">valus.yaml</code>文件提交给Git存储库。谢天谢地，我们可以使用helm-secrets <strong class="lb iu"> </strong>插件来处理和管理加密格式的秘密。这个插件支持两个存储秘密的选项。第一个也是默认的是<a class="ae ky" href="https://github.com/mozilla/sops/" rel="noopener ugc nofollow" target="_blank"> Mozilla/sops </a>后端，第二个是<a class="ae ky" href="http://vaultproject.io/" rel="noopener ugc nofollow" target="_blank"> Hashicorp Vault </a>。此外，它同时支持多个密钥管理解决方案，如PGP、AWS KMS和GCP KMS。</li></ol></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="abb9" class="nb mp it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated"><strong class="ak"> 5。设置图表相关性</strong></h1><p id="4aa8" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">有些应用程序不是作为独立服务运行的，它们依赖于其他服务或第三方工具。例如，需要将数据保存在数据库中的应用程序依赖于数据库，并且应该在部署应用程序本身之前就可以使用数据库。</p><p id="7194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这些依赖项都是由Helm部署和管理的，那么如果定义了每个图表的依赖项，就有可能简化部署。Helm将确保首先部署依赖项并且这些依赖项可用，然后部署应用程序。当试图自动化这个步骤时，不需要手动部署这些依赖项，甚至不需要重新发明轮子。图表的依赖关系可以在<code class="fe ny nz oa mk b">Chart.yaml</code>文件中定义，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="a181" class="nb mp it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated"><strong class="ak"> 6。注意特定于Kubernetes的配置</strong></h1><p id="aba6" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">由于Helm chart用于呈现和创建所需的Kubernetes资源，因此需要确保创建的资源支持以最佳方式运行应用程序。例如，图表应该支持在零停机时间推出新资源。以下三个主题有助于提高舵图的质量:</p><ol class=""><li id="bb7d" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">选择运行工作负载容器的资源——Kubernetes为创建和管理工作负载容器提供了多种资源，例如部署、StatefulSets和DaemonSets。根据应用程序的性质，需要选择工作负载资源类型。例如，如果应用程序需要在每个Kubernetes节点上运行，那么DaemonSet资源就是所需的资源类型。另一方面，如果应用程序持久保存数据并维护其身份，则StatefulSet是这种情况下使用的资源类型。有关受支持工作负载的更多信息，可在文档中找到<a class="ae ky" href="https://kubernetes.io/docs/concepts/workloads/" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="8dc9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">维护Kubernetes配置以支持零停机部署。Kubernetes提供就绪性和活性探针配置，以便能够确定正在运行的pod的健康状况。该功能使Kubernetes能够在pod被识别为不健康时自动从崩溃中恢复，并使Kubernetes能够在将更新滚动到零时最大限度地减少停机时间。</li><li id="c8ef" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">公开服务——对于为API或web接口提供HTTP服务器的应用程序来说，考虑如何使用这些接口是很重要的。是仅供内部使用还是准备公开曝光？关于这个问题，Kubernetes提供了服务对象，使我们能够公开集群内部(集群IP)或集群外部(节点端口或负载平衡器)的服务。入口控制器也可以用于在集群外部公开服务。</li></ol></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="8f1f" class="nb mp it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><p id="3d98" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">Helm是Kubernetes resources的软件包经理。使用Helm图表，您可以将几个Kubernetes资源分组，并将它们作为一个单元应用到Kubernetes集群上，以部署给定的应用程序。Helm charts简化了Kubernetes集群上的部署过程。然而，维护一个稳定和强大的掌舵图需要的不仅仅是将Kubernetes资源分组到一个包中。</p></div></div>    
</body>
</html>