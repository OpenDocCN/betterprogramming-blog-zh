<html>
<head>
<title>How to Convert Your iOS Network Layer to Work With Combine or Async/await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何转换您的iOS网络层以使用Combine或Async/await</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-convert-your-ios-network-layer-to-work-with-combine-or-async-await-869364313bd3?source=collection_archive---------2-----------------------#2021-11-25">https://betterprogramming.pub/how-to-convert-your-ios-network-layer-to-work-with-combine-or-async-await-869364313bd3?source=collection_archive---------2-----------------------#2021-11-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe29" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使网络层适应不同的接口</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e3e978ad4b89dfe9cc83cee84ca7a7a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MweyOL_AEmRNlWto"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@azevdoluana?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Luana Azevedo </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="6664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今年，Swift引入了新的<code class="fe lv lw lx ly b">async</code>和<code class="fe lv lw lx ly b">await</code>关键字。有了它们，我们现在有三种方法来执行网络操作:</p><ul class=""><li id="209a" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">通过使用旧的回调模型</li><li id="eec8" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">通过使用<code class="fe lv lw lx ly b">Combine</code></li><li id="7d5b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">通过使用<code class="fe lv lw lx ly b">async-await</code></li></ul><p id="00b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某些情况下，我们很早就对一种技术做出了决定，并试图在我们应用程序的所有模块中使用它:例如，如果我们从<code class="fe lv lw lx ly b">Combine</code>开始，我们可能希望在任何地方都使用<code class="fe lv lw lx ly b">Combine</code>。</p><p id="20ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法具有一致性的明显优势:我们不必考虑如何实现某些东西，当探索代码库时，加入项目的人不会对多种技术感到惊讶。</p><p id="0fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一致性的代价是灵活性。我们希望在每种情况下都使用最好的工具。我们可以拥有要求我们对事件流使用<code class="fe lv lw lx ly b">Combine</code>的模块，以及其他可以对一次性操作使用回调的模块。</p><p id="dafd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我们将探讨如何将网络层从一种技术转换为另一种技术。网络层只是一个例子:每当你需要将一个API从一种技术转换到另一种技术时，我们可以利用这些技术。</p><h1 id="62bb" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用回调</h1><p id="1e48" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">我们用于异步操作的第一项技术是基于回调的技术。我们访问一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlsession" rel="noopener ugc nofollow" target="_blank">URLSession</a></code>对象，并使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlsession/1407613-datatask" rel="noopener ugc nofollow" target="_blank">dataTask(with:completionHandler:)</a></code>方法获得一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/foundation/urlsessiondatatask" rel="noopener ugc nofollow" target="_blank">URLSessionDataTask</a></code>对象。可以通过调用<code class="fe lv lw lx ly b">.resume()</code>方法来启动任务。</p><p id="868c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型的实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="010f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这段代码中，我们有一个通用的<code class="fe lv lw lx ly b">CallbackNetworkService</code>，我们可以用它来对后端执行<code class="fe lv lw lx ly b">GET</code>请求。</p><p id="7aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过传递一个<code class="fe lv lw lx ly b">URLSession</code>对象来配置服务。</p><p id="405c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">get&lt;T: Decodable&gt;(url:callback:)</code>方法创建<code class="fe lv lw lx ly b">URLRequest</code>对象，它调用<code class="fe lv lw lx ly b">dataTask(with:callback:)</code>方法，然后在任务上调用<code class="fe lv lw lx ly b">resume()</code>。</p><p id="eed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数响应处理代码都致力于管理错误。</p><ol class=""><li id="85fa" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu nm mf mg mh bi translated">我们检查网络是否返回了错误。</li><li id="3f62" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">我们检查后端是否返回了错误。</li><li id="814b" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">我们验证我们有一些数据要解码。</li><li id="007f" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">我们试图解码数据。如果解码成功，我们用对象调用<code class="fe lv lw lx ly b">callback</code>。</li><li id="d3b9" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu nm mf mg mh bi translated">否则，我们会通知调用者发生了解码错误或未知错误。</li></ol><h2 id="cf91" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">使用回拨消费</h2><p id="4068" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">一旦我们有了网络服务，我们就想使用它。假设我们想在一个<code class="fe lv lw lx ly b">Profile</code>模块中检索一个用户的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="85b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Profile</code>模块需要一个具有以下接口的服务:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3c3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们编写代码连接应用程序所有模块的复合根可以创建一个简单的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="noopener ugc nofollow" target="_blank">Adapter</a></code>来连接两个接口。当两个接口共享相同的技术时，代码非常简单。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="252b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">适配器得到一个<code class="fe lv lw lx ly b">CallbackNetworkService</code>作为<code class="fe lv lw lx ly b">init</code>参数，它符合<code class="fe lv lw lx ly b">CallbackUserService</code>。它通过创建<code class="fe lv lw lx ly b">URL</code>并调用<code class="fe lv lw lx ly b">networkService.get</code>方法来实现<code class="fe lv lw lx ly b">getUser(id:callback:)</code>。</p><p id="6ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设两个回调共享相同的签名，我们可以将<code class="fe lv lw lx ly b">UserService</code>的回调作为<code class="fe lv lw lx ly b">NetworkService</code>的回调来传递。通常，我们可能需要转换由<code class="fe lv lw lx ly b">NetworkService</code>获得的<code class="fe lv lw lx ly b">Result</code>并手动调用<code class="fe lv lw lx ly b">UserService</code>回调。</p><h2 id="3d94" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">用联合收割机消费</h2><p id="e222" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">现在想象一下<code class="fe lv lw lx ly b">Profile</code>模块正在使用Combine。那样的话，<code class="fe lv lw lx ly b">UserService</code>界面就不一样了，看起来是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法只接受一个用户标识符并返回一个发布者。</p><p id="e2be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在执行网络请求之前，<code class="fe lv lw lx ly b">CallbackToCombineAdapter</code>必须创建一个发布者。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="87ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们将在本文中看到的所有适配器，适配器的设置都是相同的。我们定义一个符合服务协议的类型，我们传递一个<code class="fe lv lw lx ly b">networkService</code>，我们通过创建<code class="fe lv lw lx ly b">URL</code>来实现协议一致性。我们不打算在下面的适配器中讨论这一部分。</p><p id="82f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当实现协议时，我们创建一个可以执行网络的发布者。我们创建一个<code class="fe lv lw lx ly b">Deferred</code>发布者:它接受一个返回发布者的闭包。当收到订阅时，执行闭包。我们需要这样做，因为有一些发布者一返回就发布，比如<code class="fe lv lw lx ly b">Just</code>或<code class="fe lv lw lx ly b">Fail</code>发布者，但是对于这个用例，我们需要等到有东西订阅了发布者才发布网络请求。</p><p id="74d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们创建一个<code class="fe lv lw lx ly b">Future</code>:一个最终将发布一个值的发布者。发布者的主体实际上通过调用<code class="fe lv lw lx ly b">networkService</code>来执行网络请求。<code class="fe lv lw lx ly b">Future</code>发布者给了我们一个<code class="fe lv lw lx ly b">promise</code>，它共享了<code class="fe lv lw lx ly b">NetworkService</code>回调的相同签名，因此我们可以将它用作<code class="fe lv lw lx ly b">networkService</code>本身的回调。</p><h2 id="0177" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">使用异步Await消费</h2><p id="e356" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在<code class="fe lv lw lx ly b">Profile</code>模块使用异步await的情况下，我们需要将网络服务转换为以下接口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e0be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可将<code class="fe lv lw lx ly b">networkService</code>转换为<code class="fe lv lw lx ly b">AsyncAwaitUserService</code>的适配器代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="996f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实现适配器，我们需要将<code class="fe lv lw lx ly b">networkService.get</code>方法包装在<code class="fe lv lw lx ly b">withCheckedThrowingContinuation</code>闭包中。这个API允许我们将基于回调的异步API转换成异步等待API。<code class="fe lv lw lx ly b">continuation</code>是一个对象，它让我们<code class="fe lv lw lx ly b">resume</code>用一个值来执行，或者让我们通过抛出一个错误来中断执行。</p><p id="37b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据使用情况，我们可以使用其他版本的<code class="fe lv lw lx ly b">withXXXContinuation</code> API:</p><ul class=""><li id="3bd1" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">withCheckedThrowingContinuation</code>:可以在身体可以抛出错误的时候使用。名字的<code class="fe lv lw lx ly b">checked</code>部分告诉我们，这个函数将执行一些检查，以确保每个分支都调用延续一次，并且只调用一次。</li><li id="065e" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">withCheckedContinuation</code>:当机体不能抛出错误时可以使用。名称的<code class="fe lv lw lx ly b">checked</code>部分告诉我们，该函数将执行一些检查，以确保每个分支调用continuation一次，且仅一次。</li><li id="4554" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">withUnsafeThrowingContinuation</code>:可以用在身体会扔错误的时候。名称的<code class="fe lv lw lx ly b">unsafe</code>部分意味着API不做任何事情来确保每个执行分支调用一次延续。</li><li id="ad58" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated"><code class="fe lv lw lx ly b">withUnsafeContinuation</code>:可以用在身体不能投出错误的时候。名称的<code class="fe lv lw lx ly b">unsafe</code>部分意味着API不做任何事情来确保每个执行分支调用一次延续。</li></ul><h1 id="e779" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用联合收割机</h1><p id="e03d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">现在让我们假设已经使用<code class="fe lv lw lx ly b">Combine</code>实现了网络层。在这种情况下，使用的<code class="fe lv lw lx ly b">URLSession</code>方法是<code class="fe lv lw lx ly b">dataTaskPublisher</code>，它不需要调用<code class="fe lv lw lx ly b">resume()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码实现了与前面的网络服务相同的功能。我们创建一个<code class="fe lv lw lx ly b">dataTaskPublisher</code>，传递一个<code class="fe lv lw lx ly b">URLRequest</code>。我们尝试将结果映射到<code class="fe lv lw lx ly b">Data</code>，对其进行解码。在这样做的同时，我们还验证后端没有引发任何错误。最后，我们将<code class="fe lv lw lx ly b">erase</code>转换为<code class="fe lv lw lx ly b">AnyPublisher</code>。</p><p id="c3bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看看如何消耗它。</p><h2 id="dd38" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">使用回拨消费</h2><p id="09c7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">第一个接口是<code class="fe lv lw lx ly b">CallbackUserService</code>。适配器看起来像这样。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1c07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与以前的适配器的主要区别是我们需要处理<code class="fe lv lw lx ly b">Combine</code>订阅。为此，适配器需要是一个<code class="fe lv lw lx ly b">class</code>，并且它需要拥有一个<code class="fe lv lw lx ly b">Set&lt;AnyCancellable&gt;</code>来存储订阅。</p><p id="a91b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当收到发布的值时，通过订阅发布者并调用带有<code class="fe lv lw lx ly b">.success</code>值的回调来实现<code class="fe lv lw lx ly b">getUser</code>方法。如果我们收到一个失败的完成，我们用一个<code class="fe lv lw lx ly b">.failure</code>值调用回调。</p><blockquote class="nz oa ob"><p id="38aa" class="kz la oc lb b lc ld ju le lf lg jx lh od lj lk ll oe ln lo lp of lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>这是一个简单的实现，目的是让例子简短易懂。另一个更通用的实现可以收集接收到的值，并在成功完成时调用回调。</p></blockquote><h2 id="e93a" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">用联合收割机消费</h2><p id="9215" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当客户端也在使用Combine时，适配器准备发布器并转发它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，适配器不必处理订阅。<code class="fe lv lw lx ly b">CombineUserService</code>实现准备URL并将发布者返回给调用者。</p><h2 id="bd23" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">使用异步等待进行消费</h2><p id="3cd2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">最后，让我们看看如何将组合服务转换为异步等待服务。</p><p id="0a9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样对于这个转换，我们需要使用<code class="fe lv lw lx ly b">withCheckedThrowingContinuation</code> API。下面的代码显示了如何使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="15b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个适配器必须处理订阅，所以它是一个拥有自己的一组<code class="fe lv lw lx ly b">Cancellable</code>的<code class="fe lv lw lx ly b">class</code>。<code class="fe lv lw lx ly b">continuation</code>API用于将订阅打包给发布者。</p><p id="c7f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了<code class="fe lv lw lx ly b">continuation</code>对象，我们就可以模仿回调实现，当发布者发送一个值时使用<code class="fe lv lw lx ly b">continuation.resume(returning:)</code> API，当我们收到一个带有错误的<code class="fe lv lw lx ly b">completion</code>时使用<code class="fe lv lw lx ly b">continuation.resume(throwing:)</code> API。</p><h1 id="2314" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用异步等待</h1><p id="0b60" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">这个包的最后一项技术是新的async-await API。它可以简化我们的代码，而且，<a class="ae ky" href="https://www.swiftbysundell.com/articles/making-async-system-apis-backward-compatible/" rel="noopener ugc nofollow" target="_blank">从Xcode 13.2 </a>开始，它已经被移植到iOS 13上。</p><p id="36e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AsyncAwaitNetworkService</code>看起来是这样的</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="66dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe lv lw lx ly b">URLSession</code>的<code class="fe lv lw lx ly b">data</code>方法来发出请求。如果请求失败，我们<code class="fe lv lw lx ly b">throw</code>一个错误。否则，我们得到我们的数据和<code class="fe lv lw lx ly b">URLResponse</code>对象。然后，我们检查状态代码，以了解后端是否返回了错误。如果一切正常，我们尝试解码对象。</p><p id="a11a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用各种<code class="fe lv lw lx ly b">Profile</code>的服务来消费它。</p><h2 id="d061" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">使用回拨消费</h2><p id="62e2" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">第一个适配器将async-await范式转换为回调模型。为了在非异步函数中执行一些异步等待函数，我们需要使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://developer.apple.com/documentation/swift/task" rel="noopener ugc nofollow" target="_blank">Task</a></code> API。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="35a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来关注一下<code class="fe lv lw lx ly b">Task</code> API。我们用它来包装网络服务<code class="fe lv lw lx ly b">async</code>的<code class="fe lv lw lx ly b">get</code>方法的调用。当该方法完成时，我们可能有一个有效的<code class="fe lv lw lx ly b">User</code>，我们用一个<code class="fe lv lw lx ly b">success</code>值调用回调。</p><p id="c3a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在出现错误的情况下，我们捕获它，并使用错误本身调用回调。</p><h2 id="20a5" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">用联合收割机消费</h2><p id="f8da" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated"><code class="fe lv lw lx ly b">AsyncAwaitToCombineAdapter</code>和回调的非常相似。我们仍然需要产生一个发布者，并且我们必须使用<code class="fe lv lw lx ly b">Task</code> API将异步等待代码转换成可以被<code class="fe lv lw lx ly b">Combine</code>使用的东西。</p><p id="e695" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ef96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码与<code class="fe lv lw lx ly b">CallbackToCombineAdapter</code>的结构相同。我们创造<code class="fe lv lw lx ly b">Deferred</code>和<code class="fe lv lw lx ly b">Future</code> <code class="fe lv lw lx ly b">Publishers</code>进入<code class="fe lv lw lx ly b">Combine</code>世界。一旦我们有了来自<code class="fe lv lw lx ly b">Future</code>发布者的<code class="fe lv lw lx ly b">promise</code>，我们就使用<code class="fe lv lw lx ly b">Task</code> API来执行异步工作。<code class="fe lv lw lx ly b">Task</code>的主体与<code class="fe lv lw lx ly b">AsyncAwaitToCallbackAdapter</code>的主体非常相似:当异步函数完成时，我们使用承诺来发布结果。</p><h2 id="d9b0" class="nn mo it bd mp no np dn mt nq nr dp mx li ns nt mz lm nu nv nb lq nw nx nd ny bi translated">异步等待消费</h2><p id="d32b" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">最后一个适配器很简单。我们有相同的技术，代码非常直观。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6f64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一要做的事情是调用<code class="fe lv lw lx ly b">networkService.get</code>方法，使用<code class="fe lv lw lx ly b">try await</code>关键字。</p><h1 id="3f08" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="6b02" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在今天的文章中，我们探讨了可以用来执行网络请求的各种技术。我们讨论了基本的回调模型、使用Combine的实现和使用async-await的实现。</p><p id="f80e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们讨论了如何将它们从一种技术转换成另一种技术。通过转换网络服务，我们探索了各种帮助我们完成任务的苹果API，如<code class="fe lv lw lx ly b">Deferred</code>和<code class="fe lv lw lx ly b">Future</code>发布者，以及<code class="fe lv lw lx ly b">Task</code>和<code class="fe lv lw lx ly b">Continuation</code> API。</p><p id="8ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">知道如何将界面从一个世界转换到另一个世界是很重要的。我们已经在<code class="fe lv lw lx ly b">URLSession</code>和网络请求的上下文中看到了这些技术，但是它们可以应用于我们可能遇到的每一个异步API。</p></div></div>    
</body>
</html>