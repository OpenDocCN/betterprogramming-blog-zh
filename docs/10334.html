<html>
<head>
<title>REST API Consumption in React With Fetch, Axios, and Axios Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React With Fetch、Axios和Axios挂钩中的REST API消耗</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rest-api-consumption-in-react-with-fetch-axios-and-axios-hooks-d9dd14b43c8b?source=collection_archive---------1-----------------------#2021-12-29">https://betterprogramming.pub/rest-api-consumption-in-react-with-fetch-axios-and-axios-hooks-d9dd14b43c8b?source=collection_archive---------1-----------------------#2021-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8ea2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么时候在你的应用中使用Fetch和Axios？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cb3cf619cc042451709c7ab072537059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nBv1vzHHU7QnI4x_"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Rob Fuller 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="28f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React中有多种使用REST API的方法，但是在这篇博客中，我们将关注如何使用两种最流行的方法来使用REST API:</p><ul class=""><li id="3f45" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Axios(一个基于承诺的HTTP客户端)</li><li id="edf9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Fetch API(浏览器内置的web API)。</li></ul><p id="9255" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也用<strong class="ky ir"> </strong> <code class="fe mg mh mi mj b"><a class="ae kv" href="https://github.com/simoneb/axios-hooks" rel="noopener ugc nofollow" target="_blank">axios-hooks</a></code>来讨论Axios <strong class="ky ir"> </strong>的钩子版本。</p><p id="b308" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们创建一个示例react应用程序来演示React应用程序中Rest API的使用。</p><p id="b320" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序能够调用一个给出随机用户信息的<a class="ae kv" href="https://randomuser.me/api/?results=20" rel="noopener ugc nofollow" target="_blank">端点</a>。目前，我们只打印用户的全名和电子邮件。</p><pre class="kg kh ki kj gt mk mj ml bn mm mn bi"><span id="104c" class="mo mp iq mj b be mq mr l ms mt">import React,{useEffect,useState} from "react";<br/><br/>const RenderUserInfo = (props) =&gt; {<br/>    const { name, email } = props;<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;p&gt;Name: {name}&lt;/p&gt;<br/>            &lt;p&gt;Email: {email}&lt;/p&gt;<br/>        &lt;/div&gt;<br/>    );<br/>};<br/><br/>const UserList = () =&gt; {<br/><br/>    const [userList,setUserList] = useState([])<br/>    <br/>    const apiCall=()=&gt;{<br/>        // API logic goes here<br/>    }<br/>    <br/>    useEffect(()=&gt;{<br/>        apiCall()<br/>    },[])<br/><br/>    return (&lt;div&gt;<br/>            {userList.map((item, index) =&gt; (<br/>                &lt;RenderUserInfo name={item.name} email={item.email} key={index} /&gt;<br/>            ))}<br/>        &lt;/div&gt;<br/>    );<br/>};<br/><br/>export default function App() {<br/>    return (<br/>        &lt;div className="App"&gt;<br/>            &lt;h1&gt;Hey there! hope this is fun :)&lt;/h1&gt;<br/>            &lt;UserList /&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}</span></pre><p id="f4e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，UI部分已经准备好了，现在我们需要编写逻辑来调用API并在<code class="fe mg mh mi mj b">userList</code> <strong class="ky ir"> <em class="mu">中设置数据。</em> </strong>让我们同时使用<code class="fe mg mh mi mj b">Fetch</code>和<code class="fe mg mh mi mj b">Axios</code>来实现<code class="fe mg mh mi mj b">apiCall()</code>的功能。</p><h1 id="946c" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated"><strong class="ak">获取</strong></h1><p id="8a31" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated"><code class="fe mg mh mi mj b">fetch()</code> API是一个内置的JavaScript方法，用于从服务器或API端点获取资源。它类似于<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank">XMLHttpRequest</a></code>，但是<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> fetch API </a>提供了一个更加强大和灵活的特性集。</p><p id="8df8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它定义了诸如<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>和<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" rel="noopener ugc nofollow" target="_blank"> HTTP Origin header </a>语义等概念，取代了它们在别处的单独定义。</p><p id="d910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">fetch()</code> API方法总是接受一个强制参数，它是您想要获取的资源的路径或URL。它返回一个指向请求响应的承诺，不管请求是否成功。您也可以选择传入一个init options对象作为第二个参数。</p><p id="7d8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦获取了响应，有几个内置的方法可以用来定义主体内容是什么以及应该如何处理它。</p><pre class="kg kh ki kj gt mk mj ml bn mm mn bi"><span id="e1e9" class="mo mp iq mj b be mq mr l ms mt">const apiCall=()=&gt;{<br/>    fetch("https://randomuser.me/api/?results=20")<br/>        .then((response) =&gt; response.json())<br/>        .then((dataArr) =&gt; {<br/>            setUserList(dataArr.results.map((item) =&gt; ({<br/>                    name: item.name.first + " " + item.name.last,<br/>                    email: item.email<br/>                })));<br/>        });<br/>}</span></pre><p id="eaeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们从一个以JSON形式返回数据的URL获取数据，然后在<code class="fe mg mh mi mj b">userList</code>中设置它。使用<code class="fe mg mh mi mj b">fetch()</code>的最简单形式是只接受一个参数，即您想要获取的资源的路径，然后返回一个包含获取请求响应的承诺。这个响应是一个对象。</p><p id="0f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该响应只是一个常规的HTTP响应，而不是实际的JSON。为了从响应中获取JSON主体内容，我们必须使用响应上的<code class="fe mg mh mi mj b">json()</code>方法将响应更改为实际的JSON。</p><h1 id="0436" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">Axios</h1><p id="9682" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">Axios是一个易于使用的基于promise的HTTP客户端，用于浏览器和node.js。由于Axios是基于promise的，我们可以利用async，并等待更多可读的异步代码。有了Axios，我们获得了拦截和取消请求的能力，它还有一个内置功能，可以提供客户端保护，防止跨站点请求伪造。</p><p id="a734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用Axios实现同样的<code class="fe mg mh mi mj b">apiCall</code>功能。</p><pre class="kg kh ki kj gt mk mj ml bn mm mn bi"><span id="b37a" class="mo mp iq mj b be mq mr l ms mt">const apiCall=()=&gt;{<br/>    const apiUrl = "https://randomuser.me/api/?results=20"<br/>    axios.get(apiUrl).then((dataArr) =&gt;{<br/>        setUserList(dataArr.results.map((item) =&gt; ({<br/>            name: item.name.first + " " + item.name.last,<br/>            email: item.email<br/>        })));<br/>    });<br/>}</span></pre><p id="7165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mu"> Axios是第三方库，所以请使用以下命令安装它:</em></p><pre class="kg kh ki kj gt mk mj nr ns aw nt bi"><span id="02eb" class="nu mp iq mj b gy nv nw l nx mt">npm install axios</span></pre><p id="319c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的代码块中，我们发出一个GET请求，该请求返回一个包含用户数据的承诺。随着承诺的完成，我们将数据赋给一个状态变量<code class="fe mg mh mi mj b">userList</code>。</p><h1 id="d15e" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated"><strong class="ak">轴钩</strong></h1><p id="13a6" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated"><a class="ae kv" href="https://github.com/simoneb/axios-hooks" rel="noopener ugc nofollow" target="_blank"> Axios-Hooks </a> <strong class="ky ir"> </strong>提供了一种更简洁的方式来使用带有钩子的Axios，代码行更少。它拥有所有预先编写的钩子，可以利用Axios的所有功能，并且内置了对服务器端渲染的支持。</p><p id="01df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从下面的例子来理解带有axios挂钩的GET请求是什么样子的:</p><pre class="kg kh ki kj gt mk mj ml bn mm mn bi"><span id="80b2" class="mo mp iq mj b be mq mr l ms mt">import useAxios from 'axios-hooks'<br/><br/>function App() {<br/>  const [{ data, loading, error }, refetch] = useAxios(<br/>    'https://reqres.in/api/users?delay=1'<br/>  )<br/><br/>  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;<br/>  if (error) return &lt;p&gt;Error!&lt;/p&gt;<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={refetch}&gt;refetch&lt;/button&gt;<br/>      &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="4697" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，在组件挂载时，它自动触发一个API调用，并将<code class="fe mg mh mi mj b">data</code>、<code class="fe mg mh mi mj b">load</code>中的结果设置为真，直到API调用正在进行，并将收到的错误放入API调用中。</p><p id="45f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了手动控制API的调用，我们需要做一个小的改变，钩子看起来像这样:</p><pre class="kg kh ki kj gt mk mj ml bn mm mn bi"><span id="b1ff" class="mo mp iq mj b be mq mr l ms mt">import useAxios from 'axios-hooks'<br/><br/>function App() {<br/>  const [{ data, loading, error }, refetch] = useAxios(<br/>    {<br/>      url: 'https://reqres.in/api/users/1',<br/>      method: 'GET'<br/>    },<br/>    { manual: true }<br/>  )<br/>  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;<br/>  if (error) return &lt;p&gt;Error!&lt;/p&gt;<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={refetch}&gt;refetch&lt;/button&gt;<br/>      &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="bd23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，只有当我们调用<code class="fe mg mh mi mj b">refetch</code>函数时，API才会被调用。</p><p id="82bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，使用<code class="fe mg mh mi mj b">axios-hooks</code>，代码行数将会大幅减少。同时，它提供了<code class="fe mg mh mi mj b">data</code>、<code class="fe mg mh mi mj b">loading</code>和<code class="fe mg mh mi mj b">error</code>，所以我们也不用担心状态管理。</p><p id="0714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看使用axios-hooks对我们的原始示例所做的更改:</p><pre class="kg kh ki kj gt mk mj ml bn mm mn bi"><span id="2efc" class="mo mp iq mj b be mq mr l ms mt">import useAxios from 'axios-hooks'<br/><br/>function App() {<br/>  const [{ data, loading, error }, refetch] = useAxios(<br/>    {<br/>      url: 'https://reqres.in/api/users/1',<br/>      method: 'GET'<br/>    },<br/>    { manual: true }<br/>  )<br/>  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;<br/>  if (error) return &lt;p&gt;Error!&lt;/p&gt;<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={refetch}&gt;refetch&lt;/button&gt;<br/>      &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="d0a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们仔细观察上面的代码，我们会注意到我们没有使用<code class="fe mg mh mi mj b">useState</code>和<code class="fe mg mh mi mj b">useEffect</code>。</p><p id="e5b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在沙盒上玩上面所有的<a class="ae kv" href="https://codesandbox.io/s/fetch-axios-and-axios-hooks-medium-w448q?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">代码。</a></p><h1 id="2cdc" class="mv mp iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">获取与Axios</h1><p id="0546" class="pw-post-body-paragraph kw kx iq ky b kz nm jr lb lc nn ju le lf no lh li lj np ll lm ln nq lp lq lr ij bi translated">我们来谈谈Fetch和Axios对多种功能的支持有多好。</p><ol class=""><li id="e3c2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ny ly lz ma bi translated"><strong class="ky ir">安装</strong> — Axios是一个独立的第三方软件包，可以轻松安装。Fetch内置于大多数现代浏览器中；因此不需要安装。</li><li id="41d9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated"><strong class="ky ir">基本语法</strong> —从语法上来说，Fetch和Axios都非常简单。但是Axios支持开箱即用地将响应转换为JSON，所以在使用Axios时，我们跳过了将响应转换为JSON的步骤，不像<code class="fe mg mh mi mj b">Fetch()</code>那样，我们仍然必须将响应转换为JSON。</li><li id="ac98" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated"><strong class="ky ir">处理响应超时</strong> —在Axios中，通过使用请求对象中的<code class="fe mg mh mi mj b">timeout</code>选项，设置响应超时非常容易。但是在Fetch中，要做到这一点并不容易。通过使用<code class="fe mg mh mi mj b">AbortController()</code>接口，Fetch提供了一个类似的特性，但是它需要更多的时间来实现，并且可能会变得混乱。</li><li id="6a98" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated"><strong class="ky ir">拦截HTTP请求</strong> — Axios允许开发者拦截HTTP请求。当我们需要将HTTP请求从应用程序更改到服务器时，就需要HTTP拦截器。拦截器使我们能够通过在一个地方编写代码来为每个请求响应创建一个中间件。</li><li id="5fed" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated"><strong class="ky ir">同时发出多个请求</strong> — Axios允许我们使用<code class="fe mg mh mi mj b">axios.all()</code>方法发出多个HTTP请求。<code class="fe mg mh mi mj b">fetch()</code>提供了同样的特性，通过使用<code class="fe mg mh mi mj b">promise.all()</code>方法，我们可以在其中发出多个<code class="fe mg mh mi mj b">fetch()</code>请求。</li><li id="15fb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ny ly lz ma bi translated"><strong class="ky ir">浏览器兼容性</strong> — Axios拥有广泛的浏览器支持。Fetch只支持Chrome 42+，Firefox 39+，Edge 14+，Safari 10.1+。</li></ol></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="60f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Axios和fetch在使用API方面同样出色，但是对于较小的应用程序，最好使用Fetch。对于大规模的应用程序，总是使用Axios，并考虑使用<code class="fe mg mh mi mj b">axios-hooks</code>，因为它使代码更加清晰。</p><p id="4d72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请在<a class="ae kv" href="https://medium.com/@sahdevgarg" rel="noopener"> Medium </a>或<a class="ae kv" href="https://www.linkedin.com/in/sahdev-garg-9961b0b4/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我，获取新的技术更新。</p><p id="59c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来读取<a class="ae kv" href="https://medium.com/@sahdevgarg/python-code-formatter-black-4d9349cad92d" rel="noopener"> Python代码格式化程序</a>。</p></div></div>    
</body>
</html>