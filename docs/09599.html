<html>
<head>
<title>The Fastest and Most Efficient Way to Calculate Fibonacci Series in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript计算斐波那契数列最快最有效的方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/fibonacci-algorithm-in-javascript-45743f3a0ff6?source=collection_archive---------2-----------------------#2021-09-15">https://betterprogramming.pub/fibonacci-algorithm-in-javascript-45743f3a0ff6?source=collection_archive---------2-----------------------#2021-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="76f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">既不是递归，也不是迭代，比奈的公式是最棒的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c45194cd01a38439ad53280b4fc4d9db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zYlQ4ussTNGaJr0j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">澳大利亚八月在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="5f19" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">斐波那契是什么？</h1><p id="ff6d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">斐波纳契数或斐波纳契数列是一个数字序列，它是通过将数前面的两个<em class="mn">数相加计算出来的。它也被称为黄金比例，在自然界中广泛存在。</em></p><p id="b559" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们从索引<code class="fe mt mu mv mw b">n = 0</code>开始对序列进行计数，其值为<code class="fe mt mu mv mw b">0</code>，<code class="fe mt mu mv mw b">n = 1</code>为<code class="fe mt mu mv mw b">1</code>。</p><p id="cc8c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">因此，下一个元素(<code class="fe mt mu mv mw b">n = 2</code>)是<code class="fe mt mu mv mw b">1</code>(之前的值是<code class="fe mt mu mv mw b">0 + 1</code>)。第3个元素(<code class="fe mt mu mv mw b">n = 3</code>)是<code class="fe mt mu mv mw b">2</code>(如<code class="fe mt mu mv mw b">1 + 1</code>)，第4个是<code class="fe mt mu mv mw b">3</code> ( <code class="fe mt mu mv mw b">1 + 2</code>)，第5个是<code class="fe mt mu mv mw b">5</code> ( <code class="fe mt mu mv mw b">2 + 3</code>)等等</p><p id="ab9b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">该公式定义为</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="cae1" class="nb la it mw b gy nc nd l ne nf">F(n) = F(n-2) + F(n-1) //<!-- --> for <!-- -->n &gt; 2, <!-- -->e.g. <!-- -->F(2) = F(0) + F(1)</span></pre><p id="0e46" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">前21个数字是:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="d168" class="nb la it mw b gy nc nd l ne nf">0<!-- -->,<!-- -->1<!-- -->,<!-- -->1<!-- -->,<!-- -->2<!-- -->,<!-- -->3<!-- -->,<!-- -->5<!-- -->,<!-- -->8<!-- -->,<!-- -->13<!-- -->,<!-- -->21<!-- -->,<!-- -->34<!-- -->,<!-- -->55<!-- -->,<!-- -->89<!-- -->,<!-- -->144<!-- -->,<!-- -->233<!-- -->,<!-- -->377<!-- -->,<!-- -->610<!-- -->,<!-- -->987<!-- -->,<!-- -->1597<!-- -->,<!-- -->2584<!-- -->,<!-- -->4181<!-- -->,<!-- -->6765</span></pre><p id="20a3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">任何算法都应该为相同的输入返回相同的值。基本上，我们要寻找的是传递序列索引号(<code class="fe mt mu mv mw b">n</code>)并得到相应的值作为回报。示例:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="208e" class="nb la it mw b gy nc nd l ne nf">fibonacci(0);  // returns: 0<br/>fibonacci(1);  // returns: 1<br/>fibonacci(2);  // returns: 1<br/>fibonacci(5);  // returns: 5<br/>fibonacci(10); // returns: 55<br/>fibonacci(20); // returns: 6765</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="eb15" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">递归算法</h1><p id="f2b6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最简单和最容易的算法是递归算法。所有递归算法的工作原理都是一样的。该函数调用自身并传递先前计算的结果。</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="7502" class="nb la it mw b gy nc nd l ne nf">function fibonacci(element) {<br/>    if (element === 0) return 0;<br/>    if (element === 1) return 1;<br/>    <br/>    return fibonacci(element - 2) + fibonacci(element - 1);<br/>}</span></pre><p id="0f54" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">递归算法的缺点是每次都需要重新计算所有以前的值。因此，它不是非常有效，并且时间复杂度是指数级的:<code class="fe mt mu mv mw b">O(2^N)</code>。</p><h1 id="466f" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">记忆递归算法</h1><p id="aa48" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以用一种叫做记忆化的技术来大大加速我们之前的算法。基本上，我们将在内存中保存之前计算的值，即我们将使用额外的<code class="fe mt mu mv mw b">cache</code>变量来存储之前的结果。</p><p id="8354" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们只需要添加<code class="fe mt mu mv mw b">if (cache[element]) return cache[element];</code>，初始化它，然后如下传递:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="a019" class="nb la it mw b gy nc nd l ne nf">function fibonacci(element, cache = []) {<br/>    if (element === 0) return 0;<br/>    if (element === 1) return 1;<br/>    if (cache[element]) return cache[element];<br/>    <br/>    cache[element] = fibonacci(element - 2, cache) + fibonacci(element - 1, cache);</span><span id="cf5c" class="nb la it mw b gy ns nd l ne nf">    return cache[element];<br/>}</span></pre><h1 id="a902" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">迭代算法</h1><p id="fb98" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然带记忆的递归算法可以工作，但它仍然很慢。因此，我们可以重构代码，使用迭代算法。</p><p id="3a24" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们只需要记住，前两个元素<code class="fe mt mu mv mw b">0</code>和<code class="fe mt mu mv mw b">1</code>不能计算，所有接下来的都是前两个元素的和。为了得到<code class="fe mt mu mv mw b">n</code>元素，我们可以做一个<code class="fe mt mu mv mw b">for</code>循环来得到我们需要的东西:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="ef93" class="nb la it mw b gy nc nd l ne nf">function fibonacci(element) {<br/>    const sequence = [0, 1];</span><span id="800f" class="nb la it mw b gy ns nd l ne nf">    for (i = 2; i &lt;= element; i++) {<br/>        sequence[i] = sequence[i - 2] + sequence[i - 1];<br/>    }</span><span id="84ca" class="nb la it mw b gy ns nd l ne nf">    return sequence[element];<br/>}</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="c222" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">基准</h1><p id="ee77" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们计算递归算法调用元素<code class="fe mt mu mv mw b">n = 20</code>的<code class="fe mt mu mv mw b">fibonacci()</code>函数的次数，那么我们得到<code class="fe mt mu mv mw b">21891</code>调用！</p><p id="f54b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">记忆化可以对同一个元素进行多次函数调用，直到<code class="fe mt mu mv mw b">39</code>——令人印象深刻。</p><p id="c340" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">然而，这两种递归算法都与迭代算法相去甚远！</p><p id="53f3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以比较每种算法与基准测试软件的工作速度，基准测试软件将向我们展示<code class="fe mt mu mv mw b">operations/second</code>，即一秒钟内可以执行多少次测试。越高越好。下面是一个在<a class="ae ky" href="https://jsben.ch/natyu" rel="noopener ugc nofollow" target="_blank"> jsben.ch </a>中完成的基准测试示例和结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/29bf7f3fe524e81e91d6f9a8ce1e6eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Of1EWakhcq6K6bakulVeDg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基准测试结果n = 10。作者图片</p></figure><p id="2cbd" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以看到对于<code class="fe mt mu mv mw b">fibonacci(10)</code>带记忆的递归算法，迭代算法速度性能达到85.56%，递归算法性能达到32.08%。</p><p id="cee7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">当我们将<code class="fe mt mu mv mw b">n</code>增加到一个更高的数字时，这个数字下降得更多，示例<code class="fe mt mu mv mw b">fibonacci(15)</code>给出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/e07ac8d526090a391a01385a212273e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVwdz54jKOVflfXI96ANDQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基准测试结果n = 15。作者图片</p></figure><p id="87d9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">那真是令人印象深刻！</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="d1bc" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">请看比奈的公式</h1><p id="8af6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，我们已经比较了三种计算斐波那契数列的方法，但是还有一种更好的方法…那就是<a class="ae ky" href="http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html" rel="noopener ugc nofollow" target="_blank">比奈公式</a>。</p><p id="8e25" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">雅克·菲利普·玛丽·比奈是一位法国数学家，他提出了一个计算斐波那契数的公式。实际上，莱昂哈德·欧拉和亚伯拉罕·德莫佛之前使用的是同一个公式，但是比奈得到了所有的荣誉，现在这个公式被命名为比奈公式:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/1f260ba4fc468b4c915fc7215ef888e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/0*Jf4hqXioWrgoHQ1f.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">比奈公式</p></figure><p id="2a36" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以把它转换成JavaScript:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="13e6" class="nb la it mw b gy nc nd l ne nf">function binet(n) {    <br/>    return Math.round((Math.pow((1 + Math.sqrt(5)) / 2, n) - Math.pow((1 - Math.sqrt(5)) / 2, n)) / Math.sqrt(5));<br/>}</span></pre><p id="0ec3" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">或者由于常量值较少，例如5的平方根约等于:<code class="fe mt mu mv mw b">2.23606797749979</code>我们可以预先计算它们，并将公式简化为:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="d8cd" class="nb la it mw b gy nc nd l ne nf">function binet(n) {<br/>    return Math.round((Math.pow(1.618033988749895, n) - Math.pow(-0.6180339887498949, n)) / 2.23606797749979);<br/>}</span></pre></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="e70e" class="kz la it bd lb lc nn le lf lg no li lj jz np ka ll kc nq kd ln kf nr kg lp lq bi translated">再次进行基准测试</h1><p id="9962" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦我们用Binet的公式更新我们的<a class="ae ky" href="https://jsben.ch/Coore" rel="noopener ugc nofollow" target="_blank">基准，结果如下:</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/155f3b3859a46e1a29e8d6a0f10c01a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2i3ULr6Tb-ckpK21LYsnbg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">用比奈公式对结果进行基准测试。作者图片</p></figure><p id="578d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">正如所料，比奈的公式是最快的，因为它不依赖于以前的斐波纳契数。</p><h1 id="00d1" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">摘要</h1><p id="5d7e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">虽然递归算法是一个流行的计算机科学话题，可能是一个流行的面试问题，但在速度和效率方面，它远不及迭代算法和比奈公式。事实上，比奈是最快的。</p><p id="59f9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">因此，如果你正在寻找性能使用比奈的公式。然而，如果速度不是问题，那么递归算法更简单和优雅。</p><p id="5406" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">感谢阅读。</p></div></div>    
</body>
</html>