<html>
<head>
<title>Date Formatting With Kotlin Multiplatform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin多平台进行日期格式化</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/date-formatting-with-kotlin-multiplatform-1329a2b75bb?source=collection_archive---------4-----------------------#2022-06-20">https://betterprogramming.pub/date-formatting-with-kotlin-multiplatform-1329a2b75bb?source=collection_archive---------4-----------------------#2022-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e284" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用1)本地库或2) kotlinx.datetime编写一个简单的多平台日期格式化程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e446554b5b37671d0b6a38707968cf65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SRiyISlgTk-ji6FR"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@towfiqu999999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Towfiqu barbhuiya </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="41b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">格式化日期常常让人觉得难以实现。就我个人而言，每次我必须将日期转换为某种格式时，我都会对自己说——又是现在？我们以前不是这样做的吗？应该有一种方法可以编写一次这种代码，而不必再为它费心。</p><p id="6137" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">日期格式要求的一个简单例子是，如果(你猜对了)当前日期是2022年6月18日，我们必须显示文本<em class="ls"> 18.06.2022 </em>。应该很容易在多个平台上实现，对吗？当然可以。但是如果你为Android和iOS写代码，你必须写两次“相同”的格式逻辑，例如，在两个独立的代码库中。</p><p id="5b77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，我们可以利用<a class="ae kv" href="https://kotlinlang.org/lp/mobile/" rel="noopener ugc nofollow" target="_blank">Kotlin multi platform Mobile</a>(KMM)，这使我们能够编写一次相同的代码，并在多个平台上使用。</p><p id="df80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我不会详细介绍KMM。让我们直奔主题，深入研究代码。</p><p id="3b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将提出两种选择:</p><ol class=""><li id="127d" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">一个纯粹用Kotlin编写的通用格式化程序，在这里我们将向<code class="fe mc md me mf b">commonMain</code>、<code class="fe mc md me mf b">androidMain</code>和<code class="fe mc md me mf b">iosMain</code>添加代码，从而引入特定于平台的逻辑；</li><li id="86e3" class="lt lu iq ky b kz mg lc mh lf mi lj mj ln mk lr ly lz ma mb bi translated">使用一个名为<code class="fe mc md me mf b">kotlinx-datetime</code>的多平台库(在这里查看回购<a class="ae kv" href="https://github.com/Kotlin/kotlinx-datetime" rel="noopener ugc nofollow" target="_blank"/>)，我们将在<code class="fe mc md me mf b">commonMain</code>中保存所有代码。</li></ol><blockquote class="ml mm mn"><p id="07df" class="kw kx ls ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated">为了简洁起见，我将只关注支持<a class="ae kv" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank"> ISO 8601 </a>格式的时间戳，以及只支持一种日期格式，即<code class="fe mc md me mf b">dd.MM.yyyy</code>。</p></blockquote></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="8fec" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">我们自己的通用格式化程序</h1><p id="eabc" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">让我们定义这个放在<code class="fe mc md me mf b">commonMain</code>中的简单类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="cef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">(是的，</em> <code class="fe mc md me mf b"><em class="ls">DateTime</em></code> <em class="ls">对于这样一个职业来说并不是一个完美的名字。我们可以将其命名为</em> <code class="fe mc md me mf b"><em class="ls">Iso8601TimestampFormatter</em></code> <em class="ls">或类似的名称，但为了简洁起见，我选择了不同的名称。)</em></p><p id="b05c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">挺基础的。我们传入一个ISO 8601时间戳和一个格式(<code class="fe mc md me mf b">dd.MM.yyyy</code>)，它应该返回格式化的日期。</p><h2 id="ffa3" class="nx mz iq bd na ny nz dn ne oa ob dp ni lf oc od nk lj oe of nm ln og oh no oi bi translated">那么它在Android上看起来怎么样呢？</h2><p id="27d4" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">我们将利用<code class="fe mc md me mf b">java.time</code>API，尽管它要求我们的Android最低SDK为26(如果您想在较低的SDK版本上使用这些API，您可以使用<a class="ae kv" href="https://www.threeten.org/threetenbp/" rel="noopener ugc nofollow" target="_blank"> ThreeTen Backport </a>或<a class="ae kv" href="https://developer.android.com/studio/write/java8-support-table" rel="noopener ugc nofollow" target="_blank"> desugaring </a>)。</p><p id="029a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下内容应放在<code class="fe mc md me mf b">androidMain</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e7e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们使用<code class="fe mc md me mf b">ZonedDateTime</code> API解析我们的时间戳，然后通过<code class="fe mc md me mf b">DateTimeFormatter</code>用我们的格式格式化它。</p><h2 id="0099" class="nx mz iq bd na ny nz dn ne oa ob dp ni lf oc od nk lj oe of nm ln og oh no oi bi translated">那iOS呢？</h2><p id="e658" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">我们将参考<code class="fe mc md me mf b">Foundation</code>框架，而不是使用在iOS上无法访问的Java库。它包含了我们进行日期格式化所需的所有东西(当然还有更多<a class="ae kv" href="https://developer.apple.com/documentation/foundation?language=objc" rel="noopener ugc nofollow" target="_blank">和</a>)。</p><p id="d678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将以下内容放入<code class="fe mc md me mf b">iosMain</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="9d44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们创建了一个<code class="fe mc md me mf b">NSDateFormatter</code>的实例，并设置了时区、地区和格式。最后，我们调用<code class="fe mc md me mf b">stringFromDate()</code>来获取格式化的字符串。</p><p id="dbc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会问——为什么不使用像<code class="fe mc md me mf b">DateFormatter</code>、<code class="fe mc md me mf b">TimeZone</code>之类的Swift APIs呢？？TL；DR是，在KMM目前的状态下，我们无法从Kotlin代码中导入任何纯Swift模块。然而，导入Objective-C API(<code class="fe mc md me mf b">NS…</code>)就可以了。更多信息见<a class="ae kv" href="https://kotlinlang.org/docs/native-objc-interop.html" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><h2 id="d148" class="nx mz iq bd na ny nz dn ne oa ob dp ni lf oc od nk lj oe of nm ln og oh no oi bi translated">来测试一下吧！✅</h2><p id="ed92" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">因为我们的测试是独立于平台的，所以只将它们放在<code class="fe mc md me mf b">commonTest</code>中就足够了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="def3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们要求Android Studio运行测试时，我们被要求使用一个特定的目标(取决于我们的项目是如何配置的):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/dd93ca4f147ba444a7feaa67e3f1c46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*1AC-gRP_tN4BDA2gBS3qFg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在DateTimeTests中运行所有测试时Android Studio的屏幕截图</p></figure><p id="8ad2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常你会在<code class="fe mc md me mf b">:testDebugUnitTest</code>和<code class="fe mc md me mf b">iosX64</code>之间做出选择。无论运行哪一个，我们都可以看到测试通过了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/7b37f0908583530a0b5ff27e39fc66d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*v6c2SWjk-569ziJV04fvog.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">试验结果</p></figure><p id="532a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不想通过Android Studio的弹出窗口运行测试(或者不得不浪费宝贵的时间在弹出窗口中选择不同的选项)，你可以简单地运行命令<code class="fe mc md me mf b">$ ./gradlew :shared:allTests</code>，它将在所有可能的目标上执行项目中的所有测试。</p><h2 id="34ba" class="nx mz iq bd na ny nz dn ne oa ob dp ni lf oc od nk lj oe of nm ln og oh no oi bi translated">好吧，酷，但是如果可以避免的话，我真的不想写依赖于平台的代码</h2><p id="d49a" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">让我们看看我们是否能避免这一点，然后！Kotlin/JetBrains的优秀人员创建了<code class="fe mc md me mf b"><a class="ae kv" href="https://github.com/Kotlin/kotlinx-datetime" rel="noopener ugc nofollow" target="_blank">kotlinx-datetime</a></code>库，我们接下来会看到这个库。</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="b88f" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">使用kotlinx-datetime进行跨平台日期格式化</h1><p id="a04d" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">我推荐阅读这个库的GitHub页面上的文档。至于我们的工作，让我们通过将依赖项添加到我们的<code class="fe mc md me mf b">commonMain</code>源集中来开始吧:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ca1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们使用<code class="fe mc md me mf b">Instant</code>和<code class="fe mc md me mf b">LocalDateTime</code>从时间戳中查找日、月、年，最后以字符串形式返回格式化的日期:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><blockquote class="ml mm mn"><p id="0e08" class="kw kx ls ky b kz la jr lb lc ld ju le mo lg lh li mp lk ll lm mq lo lp lq lr ij bi translated"><code class="fe mc md me mf b">zeroPrefixed()</code>扩展函数是我创建的一个函数，用来规避Kotlin的标准库<a class="ae kv" href="https://stackoverflow.com/a/23088000/554002" rel="noopener ugc nofollow" target="_blank">中目前没有非JVM <code class="fe mc md me mf b">String.format()</code>等价函数的事实</a>，否则我们可以轻松地将整数格式化为带前缀零的字符串。你可以在这里找到<code class="fe mc md me mf b">zeroPrefixed()</code> <a class="ae kv" href="https://gist.github.com/gosr/5dca7ac82c85acd617a2e8660e6a7080" rel="noopener ugc nofollow" target="_blank">的代码</a>。</p></blockquote><h2 id="448a" class="nx mz iq bd na ny nz dn ne oa ob dp ni lf oc od nk lj oe of nm ln og oh no oi bi translated">编写测试(为什么不呢？)</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><h1 id="e565" class="my mz iq bd na nb nc nd ne nf ng nh ni jw nj jx nk jz nl ka nm kc nn kd no np bi translated">结论</h1><p id="a928" class="pw-post-body-paragraph kw kx iq ky b kz nq jr lb lc nr ju le lf ns lh li lj nt ll lm ln nu lp lq lr ij bi translated">我们研究了两种编写在Android和iOS上都能工作的日期格式化逻辑的方法。</p><p id="908e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法需要特定于平台的逻辑，使我们能够直接使用日期时间模式/格式。然而，我们被迫编写代码来迎合每个单独的平台。</p><p id="70a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，需要较少代码的方法是后者。它依赖于一个第三方库，该库目前不支持格式化各种日期时间模式/格式，这就是为什么我们必须自己编写该部分。从好的方面来看，它是一个多平台库，我们不必担心任何特定于平台的API。</p><p id="e022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你在Kotlin中为多种平台编码时有乐趣！</p></div></div>    
</body>
</html>