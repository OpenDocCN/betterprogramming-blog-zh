<html>
<head>
<title>Understanding the Factory Method Design Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解工厂方法设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-factory-method-design-pattern-f5ec631c99d8?source=collection_archive---------5-----------------------#2021-01-04">https://betterprogramming.pub/understanding-the-factory-method-design-pattern-f5ec631c99d8?source=collection_archive---------5-----------------------#2021-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">分离遵循开闭原则的构建代码(OCP)</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8c799cd8177ab825c382e68622506218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xkuAV6TKPdO8sXRPdlG6Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@christopher__burns?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯多夫·伯恩斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/factory?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ea73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在《<a class="ae ky" href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/ref=sr_1_2?dchild=1&amp;keywords=Design+Patterns%3A+Elements+of+Reusable+Object-Oriented+Software&amp;qid=1608215228&amp;sr=8-2" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素</a> <em class="lv">》一书中描述了23种经典的设计模式这些模式为软件开发中经常重复出现的特定问题提供了解决方案。</em></p><p id="9f59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将描述工厂方法模式是如何工作的，以及何时应该应用它。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5666" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">工厂方法:基本思想</h1><blockquote class="mv mw mx"><p id="3d5c" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">“<em class="it">工厂方法模式</em>是一个<a class="ae ky" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">创建模式</a>，它使用工厂方法来处理创建对象的问题，而不必指定将要创建的对象的确切类。这是通过调用工厂方法(在接口中指定并由子类实现，或者在基类中实现并可选地由派生类重写)来创建对象，而不是通过调用构造函数来实现的</p><p id="370f" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">— <a class="ae ky" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">维基百科</a></p><p id="1c10" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">"定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法让类将实例化推迟到子类。</p><p id="aa7f" class="kz la lv lb b lc ld ju le lf lg jx lh my lj lk ll mz ln lo lp na lr ls lt lu im bi translated">——Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides，“设计模式:可重用面向对象软件的元素”</p></blockquote><p id="30e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多情况下，我们需要从可能的对象列表中创建不同类型的对象，而这些对象是事先不知道的。自然的趋势是创建一个<code class="fe nb nc nd ne b">factoryManager</code>类，允许我们基于参数获得不同类型的对象。然而，这种解决方案有两个严重的缺点，我们将在本文中描述:</p><p id="a6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.它打破了开放-封闭原则，导致代码不干净，当软件扩展时不容易维护。</p><p id="3e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.<code class="fe nb nc nd ne b">factoryManager</code>类被附加到您想要构建的所有类型的对象上，创建被称为<em class="lv">意大利面条代码</em>的代码。</p><p id="a084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码显示了一个经典问题，其中有一个<code class="fe nb nc nd ne b">create</code>方法，该方法基于作为参数传递的参数返回一个类型的对象:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="836c" class="nj me it ne b gy nk nl l nm nn">function create(type) {<br/>  switch(type){<br/>    case '0': return new Object1();<br/>    case '1': return new Object2();<br/>    case '2': return new Object3();<br/>    default: return new Object4();<br/>  }<br/>}</span></pre><p id="acbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂方法模式允许更清晰的代码，因为它避免了上面提到的问题。这个模式的UML图如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/d120e877a8a1b56b6fc7b9af08b79dcc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7p-k_qujk5DGIQhKItfww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“设计模式:可重用面向对象软件的元素”一书中的UML图</p></figure><ul class=""><li id="7832" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><strong class="lb iu"> Creator </strong>是一个抽象类，声明了<code class="fe nb nc nd ne b">factoryMethod</code>，负责生成一个<code class="fe nb nc nd ne b">Product</code>对象。这个类不执行对象的具体实现。相反，这个责任被委托给了<code class="fe nb nc nd ne b">ConcreteCreator1</code>和<code class="fe nb nc nd ne b">ConcreteCreator2</code>。</li><li id="8d90" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><strong class="lb iu">混凝土创建器1 </strong>和<strong class="lb iu">混凝土创建器2 </strong>用混凝土对象创建逻辑覆盖<code class="fe nb nc nd ne b">factoryMethod</code>。</li></ul><p id="249e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构成此模式的类如下:</p><ul class=""><li id="f81c" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">Product</code>是所有可创建对象的公共接口。</li><li id="eacc" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">ConcreteProductOne</code>和<code class="fe nb nc nd ne b">ConcreteProductTwo</code>是<code class="fe nb nc nd ne b">Product</code>接口的实现。</li><li id="667f" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b"><strong class="lb iu">Creator</strong></code>是一个抽象类，其中声明了<code class="fe nb nc nd ne b">factoryMethod</code>方法，它将负责生成一个<code class="fe nb nc nd ne b">Product</code>类型的对象。该对象的具体实现不由该类执行，但是责任被委托给了<code class="fe nb nc nd ne b">ConcreteCreator1</code>和<code class="fe nb nc nd ne b">ConcreteCreator2</code>类。</li><li id="8b3a" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe nb nc nd ne b">ConcreteCreator1</code>和<code class="fe nb nc nd ne b">ConcreteCreator2</code>通过创建具体对象覆盖<code class="fe nb nc nd ne b">factoryMethod</code>。</li></ul><p id="1f48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">澄清由于这种模式的名称而经常被误解的几点是很重要的:</p><p id="e50d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.该模式不实现负责创建特定对象的工厂方法。相反，责任被委托给实现抽象类的子类。</p><p id="6ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.该模式是<a class="ae ky" href="https://medium.com/better-programming/design-patterns-template-method-5400dde7bb72" rel="noopener">模板方法模式</a>的一个特例，它将算法中变量的责任委托给具体的类。在工厂方法模式的情况下，创建对象的责任被委托给实现接口的类。</p><p id="c8c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.<code class="fe nb nc nd ne b">factoryMethod</code>方法不必每次都创建新的实例，但可以从内存缓存、本地存储等返回这些对象。重要的是这个方法必须返回一个实现<code class="fe nb nc nd ne b">Product</code>接口的对象。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c00b" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">工厂方法模式:何时使用</h1><ol class=""><li id="fd55" class="np nq it lb b lc od lf oe li of lm og lq oh lu oi nv nw nx bi translated">模式工厂方法解决的问题很容易识别:客户必须使用的对象事先并不知道，但是这种知识直接依赖于另一个用户与系统的交互(最终用户或系统)。需要这种模式的传统例子是当用户从选项列表中选择一个对象类型时。</li><li id="f1fd" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oi nv nw nx bi translated">如果需要扩展内部组件(创建的对象的数量)，而不需要附加代码，而是有一个必须实现的接口，并且只能通过创建一个与要包含的新对象及其特定创建者相关的类来扩展。</li></ol></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0892" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">工厂方法模式:优点和缺点</h1><p id="520b" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">工厂方法模式有许多优点，可以总结为以下几点:</p><ul class=""><li id="31ed" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">代码更易于维护，因为它减少了客户端类和它们的依赖项之间的耦合。</li><li id="ea06" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">干净的代码，因为开闭原则得到了保证，因为可以引入新的具体类<code class="fe nb nc nd ne b">Product</code>，而不必破坏现有的代码。</li><li id="2c23" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">更干净的代码，因为单责任原则(SRP)得到了尊重，因为创建具体的<code class="fe nb nc nd ne b">Product</code>的责任被转移到具体的创建者类，而不是拥有这一责任的客户端类。</li></ul><p id="e4eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，工厂方法模式的主要缺点是增加了代码的复杂性和所需类的数量。这是应用设计模式时一个众所周知的缺点——在代码中获得抽象必须付出的代价。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c6e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">工厂方法模式示例</h1><p id="3416" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">接下来我们将举例说明工厂方法模式应用的两个例子:</p><ol class=""><li id="be51" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu oi nv nw nx bi translated">工厂方法模式的基本结构:在这个例子中，我们将把理论上的UML图翻译成TypeScript代码，以便识别模式中涉及的每个类。</li><li id="5caa" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oi nv nw nx bi translated">快餐店的一个服务点(POS ),其中工厂方法<em class="lv"> </em>模式将被错误地应用，从而导致被称为<em class="lv">简单工厂</em>的软件模式(不是通过设计),其中OCP <em class="lv"> </em>不被遵守。然而，当不需要多余的抽象时，这种编程技术非常有用。虽然，当你想扩大项目规模时，要付出的代价是很高的。</li><li id="6448" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oi nv nw nx bi translated">应用工厂方法模式解决前面的问题。</li></ol><p id="690d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例将展示使用TypeScript实现这种模式。我们选择了TypeScript而不是JavaScript来实现这个实现——后者缺少接口或抽象类，因此实现接口和抽象类的责任将落在开发人员身上。</p><h2 id="0f97" class="nj me it bd mf om on dn mj oo op dp mn li oq or mp lm os ot mr lq ou ov mt ow bi translated">示例1:工厂方法模式的基本结构</h2><p id="115b" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">在第一个例子中，我们将把理论上的UML图转换成TypeScript来测试这种模式的潜力。这是要实现的图表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/abcd71b4b7d342872da8d9ff1b315c37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmbP1kG7sTmBs5PsTC2jCw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工厂方法模式基本结构的类图</p></figure><p id="44e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们要定义我们问题的接口(<code class="fe nb nc nd ne b">Product</code>)。因为它是一个接口，所以定义了所有特定产品(<code class="fe nb nc nd ne b">ConcreteProduct1</code>和<code class="fe nb nc nd ne b">ConcreteProduct2</code>)中必须实现的所有方法。因此，我们问题中的<code class="fe nb nc nd ne b">Product</code>接口相当简单，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品. ts</p></figure><p id="60da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们希望在问题中构建的对象必须实现之前定义的接口。因此，创建了具体的类<code class="fe nb nc nd ne b">ConcreteProduct1</code>和<code class="fe nb nc nd ne b">ConcreteProduct2</code>，它们满足了<code class="fe nb nc nd ne b">Product</code>接口并实现了<code class="fe nb nc nd ne b">operation</code>方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土制品1.ts</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土制品2.ts</p></figure><p id="d25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步是定义抽象类<code class="fe nb nc nd ne b">Creator</code>，其中必须定义一个抽象类<code class="fe nb nc nd ne b">factoryMethod</code>，它将被委托给具体类来创建具体对象的实例。真正重要的是它必须返回一个<code class="fe nb nc nd ne b">Product</code>类的对象。</p><p id="c983" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，已经定义了使用<code class="fe nb nc nd ne b">factoryMethod</code>抽象方法的操作方法。执行的<code class="fe nb nc nd ne b">factoryMethod</code>方法将是定义它的具体类的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Creator.ts</p></figure><p id="05ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">负责创建具体对象的类被称为<code class="fe nb nc nd ne b">ConcreteCreator</code>。每个<code class="fe nb nc nd ne b">ConcreteCreator</code>类都实现了<code class="fe nb nc nd ne b">factoryMethod</code>方法，其中<code class="fe nb nc nd ne b">ConcreteProduct1</code>或<code class="fe nb nc nd ne b">ConcreteProducto2</code>类的新对象是根据已经使用的<code class="fe nb nc nd ne b">Creator</code>类创建的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土制品1.ts</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">混凝土制品2.ts</p></figure><p id="4c35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将看到类<code class="fe nb nc nd ne b">Client</code>或<code class="fe nb nc nd ne b">Context</code>如何选择哪些对象是在没有先验知识的情况下创建的，以及这种模式如何保持OCP。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户</p></figure><h2 id="d6c6" class="nj me it bd mf om on dn mj oo op dp mn li oq or mp lm os ot mr lq ou ov mt ow bi translated">示例2:餐馆的POS(简单工厂)</h2><p id="979d" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">在这个例子中，将开发一个不满足工厂方法模式的解决方案，但是使用一个负责构建任何对象的<code class="fe nb nc nd ne b">FactoryManager</code>类。这个解决方案打破了OCP——除了在创建对象时使用意大利面条式的代码。有趣的是，同一个例子被重构为下面这个使用工厂方法模式的例子。</p><p id="8bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里提出的解决方案不是一种设计模式，而是一种在行业中广泛使用的解决方案。事实上，它被称为<em class="lv">简单工厂</em>并且随着应用程序的扩展存在严重的问题。</p><p id="c5af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要构建的应用程序是一个简单的应用程序，允许您创建不同类型的对象:<code class="fe nb nc nd ne b">Pizza</code>、<code class="fe nb nc nd ne b">Burger</code>或<code class="fe nb nc nd ne b">Kebab</code>。</p><p id="105a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些对象的创建事先并不知道，而是依赖于用户交互。<code class="fe nb nc nd ne b">ProductManager</code>类负责通过<code class="fe nb nc nd ne b">createProduct</code>方法构建某个类的对象。</p><p id="35f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是第一个提议的UML图。事先已经观察到该解决方案的两个问题:</p><ol class=""><li id="1d2a" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu oi nv nw nx bi translated"><code class="fe nb nc nd ne b">ProductManager</code>类与系统的高度耦合。</li><li id="628c" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu oi nv nw nx bi translated"><code class="fe nb nc nd ne b">ProductManager</code>类的<code class="fe nb nc nd ne b">createProduct</code>方法中的意大利面条式代码，它是用一个<code class="fe nb nc nd ne b">switch-case</code>构建的，当你想扩展到其他类型的产品时，这个<code class="fe nb nc nd ne b">switch-case</code>会打破OCP。</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/44b9711c26e5792bd843cae93bb8d4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTqlvo3bT4cisBlH1QZkYw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单工厂</p></figure><p id="8c87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他示例一样，我们将逐步展示实现该解决方案的代码。<code class="fe nb nc nd ne b">Product</code>接口与工厂方法模式提出的解决方案中使用的接口完全相同。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品. ts</p></figure><p id="0cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步包括您想要在这个问题中创建的每个特定对象的实现:<code class="fe nb nc nd ne b">Burger</code>、<code class="fe nb nc nd ne b">Kebab</code>和<code class="fe nb nc nd ne b">Pizza</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汉堡. ts</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烤肉串</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">披萨. ts</p></figure><p id="9cd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们实现了<code class="fe nb nc nd ne b">ProductManager</code>类，它负责根据类型参数创建每个对象类型。使用了一个<code class="fe nb nc nd ne b">enum</code>类型，它允许我们在使用<code class="fe nb nc nd ne b">switch-case</code>语句时避免使用字符串。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品经理. ts</p></figure><p id="6a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，有必要显示使用了<code class="fe nb nc nd ne b">productManager</code>类的<code class="fe nb nc nd ne b">Client</code>或<code class="fe nb nc nd ne b">Context</code>类。显然，从<code class="fe nb nc nd ne b">Client</code>类中，没有观察到该类下有违反干净代码原则的强耦合代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">index.ts</p></figure><h2 id="e69a" class="nj me it bd mf om on dn mj oo op dp mn li oq or mp lm os ot mr lq ou ov mt ow bi translated">示例3:餐馆POS(工厂方法)</h2><p id="322d" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">在这个例子中，我们将处理例2中提出的问题(餐馆的POS ),并使用工厂方法模式提出解决方案。这个解决方案的目标是避免在<code class="fe nb nc nd ne b">productManager</code>类中产生的混乱代码，并尊重OCP。</p><p id="1b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，遵循与我们在前面的例子中介绍的方法相同的方法，我们将从查看UML图开始，它将帮助我们识别这个模式的每个部分。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/df271eb118e7ef82a8db40b46560fbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AxszharDjB21rflYcUcPdQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">工厂方法</p></figure><p id="b1dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们想要构建的对象将是那些对应于<code class="fe nb nc nd ne b">Pizza</code>、<code class="fe nb nc nd ne b">Burger</code>和<code class="fe nb nc nd ne b">Kebab</code>类的对象。这些类实现了<code class="fe nb nc nd ne b">Product</code>接口。这部分代码与上一个示例中的代码完全相同。但是，让我们回顾一下代码，记住它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">产品. ts</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">汉堡. ts</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">烤肉串</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">披萨. ts</p></figure><p id="77cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在UML图的另一边，我们可以找到<code class="fe nb nc nd ne b">creator</code>类。让我们从回顾<code class="fe nb nc nd ne b">Creator</code>类开始，它负责定义<code class="fe nb nc nd ne b">factoryMethod</code>方法，该方法必须返回实现<code class="fe nb nc nd ne b">Product</code>接口的对象。此外，我们将有<code class="fe nb nc nd ne b">someOperation</code>方法，它利用了在每个具体的creator类中开发的<code class="fe nb nc nd ne b">factoryMethod</code>抽象方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Creator.ts</p></figure><p id="119e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然需要定义每一个特定的<code class="fe nb nc nd ne b">BurgerCreator</code>、<code class="fe nb nc nd ne b">KebabCreator</code>和<code class="fe nb nc nd ne b">PizzaCreator</code> creator类，它们将创建每一个特定的对象(注意:记住，没有必要总是创建一个对象——如果我们有一个从中检索缓存实例的数据结构，也将实现该模式)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">BurgerCreator.ts</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">KebabCreator.ts</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PizzaCreator.ts</p></figure><p id="4812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要完成的最后一步是应用我们开发的模式，使用来自<code class="fe nb nc nd ne b">Client</code>或<code class="fe nb nc nd ne b">Context</code>类的模式。值得注意的是，<code class="fe nb nc nd ne b">Client</code>函数不需要任何关于<code class="fe nb nc nd ne b">Creator</code>或要创建的对象类型的知识，这允许它将责任完全委托给特定的类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy oz l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">index.ts</p></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="f2ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我创建了三个<code class="fe nb nc nd ne b">npm scripts</code>，通过它们可以执行本文中的代码:</p><pre class="kj kk kl km gt nf ne ng nh aw ni bi"><span id="3108" class="nj me it ne b gy nk nl l nm nn">npm run example1<br/>npm run example2<br/>npm run example3</span></pre><p id="aa91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub回购可用<a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/factory-method-pattern" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="184e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="21a2" class="pw-post-body-paragraph kz la it lb b lc od ju le lf oe jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">工厂方法是一种设计模式，它尊重OCP，并使用多态性将创建对象的责任委托给特定的类。这允许我们有一个更干净和更可伸缩的代码。它主要解决当需要创建依赖于客户机与系统的交互的不同类型的对象时，以及当事先不知道客户机将创建哪个对象时出现的问题。</p><p id="d74e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这种模式最重要的不是它的具体实现，而是能够认识到这种模式可以解决的问题以及何时可以应用它。具体的实现是最不重要的，因为这将取决于所使用的编程语言。</p></div></div>    
</body>
</html>