<html>
<head>
<title>Atomic MySQL Read-write Operations With Go 1.19</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go 1.19中的原子MySQL读写操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/atomic-mysql-read-write-operations-with-go-1-19-3bd04b11f888?source=collection_archive---------7-----------------------#2022-08-11">https://betterprogramming.pub/atomic-mysql-read-write-operations-with-go-1-19-3bd04b11f888?source=collection_archive---------7-----------------------#2022-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c97" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我保持事物同步的方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e4a419d74a0087a9712f40e50154c1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z0YKvKLfm6H8BaYn"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由Mackenzie Marco通过unsplash提供</p></figure><p id="3954" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是否曾经在亚马逊上购买了一件商品，然后收到一封电子邮件，通知你由于没有存货，你的订单被取消了？</p><p id="bc2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我试过几次。作为一个购买产品的消费者，这可能不是什么大事。阅读电子邮件并等待库存补充，然而，开发人员需要编写所有代码来支持该功能。</p><p id="5ff8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我告诉您，您可以通过同步读写来放弃实现这样的过程，那会怎么样？默认情况下，Go web服务器是多线程的。每个请求都会产生一个Go例程。考虑到这一点，我们应该预测多线程环境中出现的错误。如本段开头所举的例子。</p><p id="d57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将定义一个HTTP端点来执行特定商品的销售。销售过程将减少商品的数量，如果没有剩余的商品，它将返回一个错误。我将使用<code class="fe ls lt lu lv b">github.com/go-sql-driver/mysql</code>作为我的数据库驱动程序。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="b117" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">设置MYSQL</h1><p id="bd77" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在编写任何Go代码之前，我将设置测试环境。请注意，本节显示的所有代码都是MYSQL命令。我将从定义一个名为<code class="fe ls lt lu lv b">Stock</code>的MYSQL数据库开始:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="69b2" class="ne me iq lv b gy nf ng l nh ni">CREATE DATABASE Stock;</span></pre><p id="85dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我将添加一个包含两列的表格。一个用于产品ID，另一个用于产品的库存数量:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="9c71" class="ne me iq lv b gy nf ng l nh ni">CREATE TABLE `Inventory` (<br/> `ProductID` INT,<br/> `Count` INT COMMENT 'Will store product count'<br/>) ENGINE=InnoDB;</span></pre><p id="3a7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该表将负责跟踪库存盘点。然后，我将向表中添加一个商品，库存数量为<code class="fe ls lt lu lv b">1</code>:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="a754" class="ne me iq lv b gy nf ng l nh ni">INSERT INTO Inventory(ProductID, Count) VALUES (10, 1);</span></pre><p id="0243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一件事，请确保您有MySQL凭证(用户名，密码)能够访问上面定义的表。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6184" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Go代码</h1><p id="66fb" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">首先，我将定义我的<code class="fe ls lt lu lv b">app</code>类型，以及包含我将用来管理状态的字段。下面是<code class="fe ls lt lu lv b">app</code>式:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="7a1a" class="ne me iq lv b gy nf ng l nh ni">type App struct {<br/>  Db      *sql.DB<br/>  mu      *sync.Mutex<br/>  Timeout atomic.Bool<br/>}</span></pre><p id="9fa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是每个字段的预期用途:</p><ul class=""><li id="ca91" class="nj nk iq ky b kz la lc ld lf nl lj nm ln nn lr no np nq nr bi translated"><code class="fe ls lt lu lv b">Db</code>:存储MySQL数据库连接</li><li id="68dd" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ls lt lu lv b">mu</code>:明星秀，将启用同步操作</li><li id="8e9a" class="nj nk iq ky b kz ns lc nt lf nu lj nv ln nw lr no np nq nr bi translated"><code class="fe ls lt lu lv b">Timeout</code>:一个原子变量，稍后我将使用它来模拟较低的网络吞吐量。</li></ul><p id="b08a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我定义了应用程序，就该初始化它并设置适当的字段了。我从MySQL驱动程序页面复制了示例代码来设置我的数据库连接。</p><p id="9946" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我将变量<code class="fe ls lt lu lv b">db</code>赋给了我的结构字段<code class="fe ls lt lu lv b">Db</code>。我将<code class="fe ls lt lu lv b">mu</code>指定为一个指向互斥体的指针，这个变量在main函数中声明。这对于内存管理非常理想，因为当程序停止时，main函数会返回。下面是主函数最初的样子:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="1ca2" class="ne me iq lv b gy nf ng l nh ni">func main() {</span><span id="4d6a" class="ne me iq lv b gy nx ng l nh ni"> db, err := sql.Open("mysql", "root:password@/<strong class="lv ir">Stock</strong>")<br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/> var mu sync.Mutex</span><span id="2ed1" class="ne me iq lv b gy nx ng l nh ni"> db.SetConnMaxLifetime(time.Minute * 3)<br/> db.SetMaxOpenConns(10)<br/> db.SetMaxIdleConns(10)</span><span id="18dd" class="ne me iq lv b gy nx ng l nh ni">  _ = App{Db: <strong class="lv ir">db</strong>, mu: &amp;<strong class="lv ir">mu</strong>}<br/>}</span></pre><p id="0fd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我有了一个基本的设置，是时候开始编写我的HTTP处理程序了。HTTP处理程序将是一个类型为<code class="fe ls lt lu lv b">App</code>的方法，因为这将允许我从处理程序中管理和访问状态。处理程序将调用另一个方法来执行销售操作。这个方法将被称为<code class="fe ls lt lu lv b">PerformPurchase</code>。下面是处理程序的定义:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="cfba" class="ne me iq lv b gy nf ng l nh ni">func (a *App) BuyItem(w http.ResponseWriter, r *http.Request) {</span><span id="500b" class="ne me iq lv b gy nx ng l nh ni">  id, amount, err := <strong class="lv ir">GetQuery</strong>(r)</span><span id="d1d5" class="ne me iq lv b gy nx ng l nh ni">  if err != nil {<br/>    w.WriteHeader(http.StatusBadRequest)<br/>    w.Write([]byte("Nope!"))<br/>    return<br/>  }</span><span id="6bca" class="ne me iq lv b gy nx ng l nh ni">  ctx, _ := context.WithTimeout(r.Context(), 30*time.Second)</span><span id="ab17" class="ne me iq lv b gy nx ng l nh ni">  err = a.<strong class="lv ir">PerformPurchase</strong>(ctx, id, amount)</span><span id="16db" class="ne me iq lv b gy nx ng l nh ni">  if err != nil {<br/>    w.WriteHeader(http.StatusInternalServerError)<br/>    w.Write([]byte("Nope!"))</span><span id="80a4" class="ne me iq lv b gy nx ng l nh ni">    return<br/>  }</span><span id="9155" class="ne me iq lv b gy nx ng l nh ni">  w.Write([]byte("Ok"))<br/>}</span></pre><p id="3a2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理程序调用的第一个函数是<code class="fe ls lt lu lv b">GetQuery</code>。这是从请求中提取用户输入的函数。以下是<code class="fe ls lt lu lv b">GetQuery</code>的代码:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="69f3" class="ne me iq lv b gy nf ng l nh ni">func GetQuery(r *http.Request) (id int, amount int, err error) {</span><span id="c446" class="ne me iq lv b gy nx ng l nh ni"> amount, err = strconv.Atoi(r.FormValue("amount"))</span><span id="03d2" class="ne me iq lv b gy nx ng l nh ni"> if err != nil {<br/>   return<br/> }</span><span id="c590" class="ne me iq lv b gy nx ng l nh ni"> id, err = strconv.Atoi(r.FormValue("id"))</span><span id="0425" class="ne me iq lv b gy nx ng l nh ni"> if err != nil {<br/>   return<br/> }</span><span id="4d33" class="ne me iq lv b gy nx ng l nh ni">  return<br/>}</span></pre><p id="4d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果传递了无效的整数，该函数将返回错误。这是防止SQL查询注入的理想方法。我选择使用命名变量来保持代码的整洁，想象一下每次我想做一个<code class="fe ls lt lu lv b">return</code>时就写3个变量。最后，这里是<code class="fe ls lt lu lv b">PerformPurchase</code>的定义:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="9296" class="ne me iq lv b gy nf ng l nh ni">const (<br/>  <strong class="lv ir">StockError</strong> = "Stock is finished"<br/>)</span><span id="b69f" class="ne me iq lv b gy nx ng l nh ni">func (a *App) <strong class="lv ir">PerformPurchase</strong>(ctx context.Context, id, amount int) error {</span><span id="739b" class="ne me iq lv b gy nx ng l nh ni"> if a.<strong class="lv ir">Timeout</strong>.Load() {<br/>   time.Sleep(5 * time.Second)<br/> }</span><span id="ec72" class="ne me iq lv b gy nx ng l nh ni"> rows, err := a.Db.QueryContext(<br/>             ctx, <br/>             "SELECT Count FROM Inventory WHERE ProductID=<strong class="lv ir">?</strong>",    <br/>            <strong class="lv ir"> id</strong>,<br/> )</span><span id="47f6" class="ne me iq lv b gy nx ng l nh ni"> if err != nil {<br/>   return err<br/> }<br/> defer rows.Close()</span><span id="4c7c" class="ne me iq lv b gy nx ng l nh ni"> var <strong class="lv ir">stock</strong> int</span><span id="de27" class="ne me iq lv b gy nx ng l nh ni"> if rows.Next() {<br/>   if err := rows.Scan(&amp;<strong class="lv ir">stock</strong>); err != nil {<br/>     // Check for a scan error...<br/>     return err<br/>   }<br/> }</span><span id="b4fd" class="ne me iq lv b gy nx ng l nh ni"> if <strong class="lv ir">stock &lt;= 0</strong> {<br/>   return errors.New(<strong class="lv ir">StockError</strong>)<br/> }</span><span id="68fe" class="ne me iq lv b gy nx ng l nh ni"> _, err = a.Db.ExecContext(<br/>       ctx, <br/>       "UPDATE Inventory SET Count = Count - ? WHERE ProductID = ?",<br/>        amount, <br/>        id,<br/> )<br/> <br/> if err != nil {<br/>   return err<br/> }</span><span id="0887" class="ne me iq lv b gy nx ng l nh ni"> return nil</span><span id="6772" class="ne me iq lv b gy nx ng l nh ni">}</span></pre><p id="d513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，前面声明的<code class="fe ls lt lu lv b">Timeout</code>字段用于强制函数等待5秒钟。这是为了模拟执行第一个MySQL查询时可能出现的低网络吞吐量。我将在下一节回到这个领域。</p><p id="0c88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数检索商品的记录并检查库存数量是否大于0，如果不是，它将返回一个错误。如果stock高于0，该函数将执行一个查询来更新库存数量，减少请求中指定的数量。现在我的应用程序组件已经定义好了，我将编写一个测试来执行两个同时的购买请求。</p><p id="f115" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是主函数的最终版本，带有<code class="fe ls lt lu lv b">http</code>的附加功能:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="3699" class="ne me iq lv b gy nf ng l nh ni">func main() {</span><span id="10cf" class="ne me iq lv b gy nx ng l nh ni"> db, err := sql.Open("mysql", "root:password@/Stock")<br/> if err != nil {<br/>  log.Fatal(err)<br/> }<br/> var mu sync.Mutex</span><span id="6375" class="ne me iq lv b gy nx ng l nh ni"> db.SetConnMaxLifetime(time.Minute * 3)<br/> db.SetMaxOpenConns(10)<br/> db.SetMaxIdleConns(10)</span><span id="b6bd" class="ne me iq lv b gy nx ng l nh ni"> app := App{Db: db, mu: &amp;mu}</span><span id="0ed0" class="ne me iq lv b gy nx ng l nh ni"> http.HandleFunc("/buy", app.BuyItem)<br/> log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span></pre><h1 id="68c5" class="md me iq bd mf mg ny mi mj mk nz mm mn jw oa jx mp jz ob ka mr kc oc kd mt mu bi translated">测试</h1><p id="0056" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">测试将首先执行<code class="fe ls lt lu lv b">PerformPurchase</code>作为Goroutine。对于这个调用，<code class="fe ls lt lu lv b">Timeout</code>将被设置为true，这将使Go例程在执行前等待5秒钟。同样，这是为了模拟一个糟糕的网络。在这5秒钟内，我将调用主线程上的<code class="fe ls lt lu lv b">PerformPurchase</code>并检查消息<code class="fe ls lt lu lv b">Stock is finished</code>中的错误。如果没有错误或返回另一个错误，测试将失败。下面是我的测试代码:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="80a2" class="ne me iq lv b gy nf ng l nh ni">func TestPerformPurchase(t *testing.T) {</span><span id="bdd9" class="ne me iq lv b gy nx ng l nh ni"> db, err := sql.Open("mysql", "root:password@/Stock")<br/> if err != nil {<br/>   log.Fatal(err)<br/> }</span><span id="500d" class="ne me iq lv b gy nx ng l nh ni"> var mu sync.Mutex</span><span id="31fe" class="ne me iq lv b gy nx ng l nh ni"> app := App{Db: db, mu: &amp;mu}</span><span id="870b" class="ne me iq lv b gy nx ng l nh ni"> ctx := context.Background()</span><span id="1a02" class="ne me iq lv b gy nx ng l nh ni"> // Launch buy<br/> app.<strong class="lv ir">Timeout</strong>.Store(<strong class="lv ir">true</strong>)<br/> <strong class="lv ir">go app.PerformPurchase</strong>(ctx, 10, 1)</span><span id="6669" class="ne me iq lv b gy nx ng l nh ni"> // Timeout would be false for first invocation without this<br/> time.Sleep(2 * time.Second)</span><span id="06d9" class="ne me iq lv b gy nx ng l nh ni"> app.<strong class="lv ir">Timeout</strong>.Store(<strong class="lv ir">false</strong>)<br/> err = app.<strong class="lv ir">PerformPurchase</strong>(ctx, 10, 1)<br/> if err <strong class="lv ir">== </strong>nil || err.Error() <strong class="lv ir">!=</strong> StockError {<br/>  t.Fatalf("expected error %v, but got %v", StockError, err)<br/> }</span><span id="d3f3" class="ne me iq lv b gy nx ng l nh ni">}</span></pre><p id="5916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在进行测试:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/d66e4256f7fc10ae89b1532c37208125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*yC9dKNEJPmHqAKok.gif"/></div></figure><p id="eb0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在第一个测试中看到的，第二次调用<code class="fe ls lt lu lv b">PerformPurchase</code>返回了成功，尽管它是最后调用的。提示测试失败。测试在第二次运行时也通过了。魔法测试是一个可怕的迹象，在这种情况下，它通过了，因为<code class="fe ls lt lu lv b">Count</code>列已经被设置为0，并将返回期望的错误。为了解决这个问题，我将返回到函数<code class="fe ls lt lu lv b">PerformPurchase</code>并在函数的开头添加一个锁。我将用下面的代码来实现这一点:</p><pre class="kg kh ki kj gt na lv nb nc aw nd bi"><span id="93b6" class="ne me iq lv b gy nf ng l nh ni">func (a *App) PerformPurchase(ctx context.Context, id, amount int) error {</span><span id="1265" class="ne me iq lv b gy nx ng l nh ni"> a.mu.Lock()<br/> <strong class="lv ir">defer</strong> a.mu.Unlock()<br/> ...<br/>}</span></pre><p id="e6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过推迟解锁互斥体的调用，我可以避免由于代码崩溃或提前返回而导致的任何死锁。在重新测试之前，我将更新<code class="fe ls lt lu lv b">Inventory</code>表，将项目计数设置回1。这将防止假阳性的发生，正如第一次测试所观察到的那样。下面是运行中的新代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/50bec0180fd3fd5104ec26bec80e502a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*_s_7HXslarYHY-NP.gif"/></div></figure><p id="e02e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你注意到了，测试花了大约5秒，和我的超时时间一样。</p><h1 id="d025" class="md me iq bd mf mg ny mi mj mk nz mm mn jw oa jx mp jz ob ka mr kc oc kd mt mu bi translated">结论</h1><p id="d468" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">解决这个问题还有其他方法。一种方法是让SQL查询为您执行所有这些检查，或者更新数据库设置以适应您的用例。然而，并不是每个人都在使用SQL，所以我提供了一个应用程序级的解决方案。</p><p id="758a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以与其他数据库提供商互换的解决方案。我知道这种解决方案在Kubernetes这样的环境中是无效的，因为那里有多个独立的应用程序实例在运行。在这种情况下，分布式锁将是解决方案，这也将是我下一篇文章的主题。你可以在这里找到这篇文章<a class="ae kv" href="https://github.com/cheikhshift/medium_examples/tree/main/atomic-sql" rel="noopener ugc nofollow" target="_blank">使用的代码。</a></p><h1 id="9f29" class="md me iq bd mf mg ny mi mj mk nz mm mn jw oa jx mp jz ob ka mr kc oc kd mt mu bi translated">参考链接</h1><div class="oe of gp gr og oh"><a href="https://wtools.io/generate-sql-create-table" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">创建表格-在线MySQL生成器</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">该表单允许您为创建表生成sql:生成您生成的sql可以在下面看到。贝塔-它的意思是…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">wtools.io</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://github.com/go-sql-driver/mysql" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">GitHub-Go-SQL-Driver/mysql:Go MySQL Driver是一个用于Go(golang)数据库/sql的MySQL驱动程序…</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">一个MySQL-Driver for Go的数据库/sql包轻量级和快速的原生Go实现。没有C绑定，只是纯粹的Go…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov kp oh"/></div></div></a></div></div></div>    
</body>
</html>