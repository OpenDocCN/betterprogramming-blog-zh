# 为什么大多数软件开发人员发现递归如此困难

> 原文：<https://betterprogramming.pub/why-most-software-developers-find-recursion-so-difficult-9c22075c24fb>

## 以及为什么它不再像过去那样流行了

![](img/10f6f0e08d1b3bf015263f9e2492536a.png)

照片由[普里西拉·杜·普里兹](https://unsplash.com/@priscilladupreez?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄。

不久前，递归还很流行。它代表了一种有效地编写几行代码的方法，可以在很少的内存资源上高效地操作。

大多数有效的*divide et impera**算法都是基于递归以及树抓取和图遍历的。快进到今天，许多软件工程师已经工作多年，却没有编写过一个递归函数。这是为什么呢？*

# *强大而高效*

*递归的最大问题是，它的设计、实现和维护比基于循环的解决方案要复杂得多。如今，编程(尤其是在 web 项目中)越来越接近于做自己工作的库的集成，而不是从头开始开发真正的代码。*

*在这个挑选和集成的时代，配置、流和 lambdas 似乎更适合业务逻辑任务。递归可以在优化的库中找到，或者在我们刚刚使用的对象下找到。*

*最简单的递归算法的例子是排序，我们总是在高层使用，但从来不用编码。Mergesort 和其他最优效率排序策略利用了递归。但是，同样，我们只是调用`some_array.sort()`，仅此而已。*

# *描绘递归是困难的*

*递归背后不可思议的事实是，我们的大脑无法自然地描绘它。循环和管道可以被想象成现实世界中执行一组指令的代理，我们可以选择作为例子的对象，具有我们想要编码的设计的相同模式的自然隐喻。但是递归利用了真正抽象的自调用思想。这打破了过程代码的简单性，用可重入调用隐藏了重复的任务。*

*递归需要设计一个函数来调用它自己来分割和执行一个重复的任务。这隐藏了三个嵌套的问题:*

1.  *支持嵌套调用的输入变量和工作变量必须相同。*
2.  *递归必须以一致的方式终止，并在所有嵌套级别向上游返回一个结果到最终调用。*
3.  *根据需要，业务逻辑可以位于递归调用之前或之后。*

*经常发生的情况是，当你专注于其中一个问题时，你解决了它，却打破了另一个问题。*

## *想象递归*

*设计自调用通常是最容易的部分，但仍然需要注意力和经验。扰乱对“平均”数据进行操作的实际代码意味着危及整个算法。自我反馈是很棘手的:你可以对整个过程的步骤有一个清晰的概念，但这只是一点点帮助。此外，设计终止用例的方式会影响整个算法，反之亦然。紧绷纠结。*

*可能最简单的比喻就是想象递归需要克隆。单个克隆是递归函数调用的范围。它有自己的程序指令集，由站在它左边的另一个“实体”(可能是另一个克隆体)调用。它考虑如何处理它保存的数据。它们可能需要一些调整，它们可能很好，或者数据的子集可能需要另一个克隆做更多的工作。在对数据进行处理后，如果它们没问题，它就可以将结果传递给涉及它的人。*

*在数据子集需要更多工作的情况下，它必须保存其片段和结果，并将一个(或多个)子集提供给位于其右侧的一个(或多个)克隆。然后它坐下来等待结果。一旦右边的克隆完成，东西就被返回，我们的克隆可以执行一些其他的活动(如果需要的话),并为左边的克隆准备它自己的结果。*

## *溢出和数据管理*

*终止条款和内存管理是关键的方面。如果您正在处理的数据不符合您的设计，并且您进行的验证不够好，您可能会陷入无限递归中。这会导致堆栈溢出。一个著名网站的好名字，但在这里我们谈论的是溢出递归数的限制。*

*事实上，在等待内部调用返回时，每个递归级别都需要保留资源。因此，如果你在递归中走得太远，堆栈迟早会被填满。而且，一眼就能实现给定递归函数作用域所需的内存量是很复杂的。*

# *高层，低层*

*在今天的高级编程中，使用 streams 和 lambdas 这样的工具的机会要高得多。它们带有抽象的概念，但在这种情况下，对它们的特性有具体的需求。因此，他们在那里。JavaScript 程序员在许多情况下广泛利用它们(在 Java 和 Python 中也发生过)。*

*正如已经提到的，在低层次上，仍然是最简单的算法实现。因此，很可能在 c 语言编写的程序库中发现递归。*

## *有效性和可读性的问题*

*同样的动机再次浮出水面。库和低级代码仍然在性能(大-O 复杂性等)受限的环境中运行。)重要。这并不是因为我们运行在低资源上(过去其他栈也是这样)，而是因为任务运行了太多次，以至于 big-O 因素是相关的。*

*在高级代码中，我们比过去拥有更多的资源，这使得从 *NlogN* 到 *N2* 进行业务逻辑任务变得没有意义。此外，如果算法需要，我们可以集成一个库来为我们做这件事。*

*最后，递归是隐式的，支持单行调用。你看不到任何代码块，没有花括号，没有缩进来警告你这段代码是递归的。此外，它的可读性本来就很复杂，因为终止条件可能不符合您的预期，在业务逻辑之间，在之前或之后。这取决于任务。*

# *最后的想法*

*递归总是很可怕，需要我们在正确处理它之前灵活运用我们的大脑。稳定的神经和大量的练习可以帮助你找到正确的态度来正确地编写代码。但是请注意，编写基于循环的解决方案或导入第三方组件的简单性可能会抵消自己设计和实现它的净优势。*