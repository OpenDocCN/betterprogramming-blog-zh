<html>
<head>
<title>How I Rendered a Massive List in React Without Memory and CPU Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在没有内存和CPU问题的情况下在React中渲染一个巨大的列表</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-rendered-a-massive-list-in-react-without-memory-and-cpu-issues-7ac6fe6a697b?source=collection_archive---------3-----------------------#2019-10-28">https://betterprogramming.pub/how-i-rendered-a-massive-list-in-react-without-memory-and-cpu-issues-7ac6fe6a697b?source=collection_archive---------3-----------------------#2019-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c992" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">没有延迟，没有滞后——以下是我是如何做到的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c56860f25020a4ab20f799e4a26a5fb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H_6MBVm6rQC_iRFq62jVCg.jpeg"/></div></div></figure><h1 id="1ea0" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">庞大的名单</h1><p id="7c25" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我曾经遇到过这样一种情况，我不得不在一个列表中呈现大量的条目。每当我想呈现一个巨大的列表或表格时，React中所面临的问题让我感到绝望。</p><p id="0af6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">根据我计划呈现的列表项和列表的长度，我面临以下问题:</p><ol class=""><li id="2758" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">呈现列表花费太多时间(CPU问题)</li><li id="6c6c" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">滚动时有很大的延迟(内存问题)</li><li id="d27d" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">整个应用程序变得缓慢</li></ol></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="24ec" class="kr ks iq bd kt ku nf kw kx ky ng la lb jw nh jx ld jz ni ka lf kc nj kd lh li bi translated">我尝试过但没用的东西</h1><p id="05e8" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我意识到造成延迟的不是大量的元素，而是呈现的DOM元素。</p><p id="43c5" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">所以我想我应该把数组分成多个块，先渲染一个块。每当用户点击列表的底部，我会呈现下一个。</p><p id="3718" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">但这并不奏效。用户体验不好。当你到达底部时，我还在渲染下一个块，中间有一个延迟。尽管它正在杀死UX，我用一些黑客修复了它。但实际问题是这样的:每当我添加一个块时，呈现列表的大小都会增加，用户在滚动时会面临同样的延迟问题。</p><p id="1f7b" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我的第二个尝试是:每当我添加一个数据块时，我会删除前一个。是这样吗？是的，它扩展并解决了内存问题，但它杀死了UX。每当我滚动时，滚动条上下移动，因为当我移除前一个块时，项目的位置发生了变化，我觉得应该出现在列表中的项目正在消失。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="b9f7" class="kr ks iq bd kt ku nf kw kx ky ng la lb jw nh jx ld jz ni ka lf kc nj kd lh li bi translated">我最终是如何解决的</h1><p id="58ad" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">从以前的尝试中得到的教训是，当用户滚动时，元素的位置永远不应该改变，只呈现视图上可见的内容可以解决CPU和内存问题。</p><p id="a557" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">嗯，我唯一的选择是将数组分成不同的块，并为每个块放置一个容器，而不是直接呈现项目。当我移除容器中的物品时，如果它不在视图中，就有必要保持每个容器的高度。</p><p id="93c9" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这个问题基于数组的分割和每个块的大小。大小很重要，因为如果数组中有10，000个元素，如果我的块大小是10，那么我将呈现1，000个容器div。</p><p id="38cf" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">这时我想，“为什么我不能在这里实现二叉树？”我递归地将数组一分为二，直到每个块都有最少数量的元素。这样，如果父容器在视图中不可见，那么它的所有子容器将被自动移除，同时保持每个元素的位置。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="aae9" class="kr ks iq bd kt ku nf kw kx ky ng la lb jw nh jx ld jz ni ka lf kc nj kd lh li bi translated">React中的实现</h1><p id="3363" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一旦我明白了逻辑，实现它就相当简单了。我不打算在这里解释所有的代码，因为那样太冗长了。取而代之的是，我将简单地引导你通过这个流程。</p><p id="1cef" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">让我们把你的清单当作一个组件。当数据列表被提供给列表时，数据将经历这些过程。</p><ol class=""><li id="433e" class="mk ml iq ll b lm mf lp mg ls mm lw mn ma mo me mp mq mr ms bi translated">我们将获取列表数据并递归地分割它，直到一个块达到最少的条目，然后我们将存储它。</li><li id="84cb" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">可见性检查:在处理过的数据中，我们将基于列表组件的<code class="fe nk nl nm nn b">scrollTop</code>通过递归循环来更新每个容器的可见性。我本可以只在第一步中完成，但是我之所以要把它分开，是因为每当有滚动事件触发时，这个函数就会被调用。</li><li id="efbf" class="mk ml iq ll b lm mt lp mu ls mv lw mw ma mx me mp mq mr ms bi translated">我们将把可见性检查函数绑定到列表组件的<code class="fe nk nl nm nn b">onScroll</code>。</li></ol><p id="3a7c" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">仅此而已。现在，我们有了list，它能够在没有内存和CPU问题的情况下呈现大量的列表项。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="a64b" class="kr ks iq bd kt ku nf kw kx ky ng la lb jw nh jx ld jz ni ka lf kc nj kd lh li bi translated">工作演示和NPM图书馆</h1><p id="c0ce" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我认为让别人写我已经写好的代码是没有意义的，所以我创建了一个NPM库并主持了一个工作演示。</p><p id="95dc" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><a class="ae no" href="http://react-eternal-list.rinas.in" rel="noopener ugc nofollow" target="_blank">工作演示</a></p><p id="f990" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">NPM图书馆:<a class="ae no" href="https://www.npmjs.com/package/react-eternal-list" rel="noopener ugc nofollow" target="_blank">React-永恒列表</a></p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="9298" class="kr ks iq bd kt ku nf kw kx ky ng la lb jw nh jx ld jz ni ka lf kc nj kd lh li bi translated">结论</h1><p id="c105" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">二叉树方法非常有效。我尝试了多达100，000个元素，它仍然工作顺利。即使我花了一些时间来实现这一点，这是值得的努力。即使它只是一个列表，学习曲线也很好，现在我可以在未来的UI开发中使用这种方法。</p><p id="66b2" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">感谢您的关注。你有不同的意见吗？我总是很高兴得到反馈。</p></div></div>    
</body>
</html>