<html>
<head>
<title>React Navigation 5: Stack, Tab, and Drawer All in One</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React导航5:堆栈、标签和抽屉合二为一</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-navigation-5-stack-tab-drawer-all-in-one-ead723188056?source=collection_archive---------1-----------------------#2020-07-21">https://betterprogramming.pub/react-navigation-5-stack-tab-drawer-all-in-one-ead723188056?source=collection_archive---------1-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="17da" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">设置React本机应用程序的导航，实现无缝屏幕转换</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c54e8676cf841bc2f500fa591af17340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SMs2qTpSchDqfOxAH06mBg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">安娜斯塔西娅·彼得罗娃在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="80c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React导航为您的React原生应用程序在iOS和Android上提供无缝路由和导航。最近参加了React Native的课程，我了解到有很多有用的功能可以通过导航添加到你的应用程序中，其中大部分我将在这里解释。</p><h2 id="0533" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">我们将会做什么</h2><ul class=""><li id="d358" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated">分别浏览堆栈、标签和抽屉导航器</li><li id="35a5" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">将它们结合起来，在React原生应用的屏幕上进行转换</li></ul><p id="2ad1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>对于本文，我将使用React Navigation的最新稳定版本，即v5。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="1525" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">什么是React导航？</h1><p id="4e9e" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">以同样的方式在网络浏览器中处理往返——在那里推送和弹出路线——React Navigation推送和弹出你的应用程序的路线。它的特别之处在于，它包括了我们今天在手机上看到和喜爱的屏幕切换时的流畅动画。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="4d65" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">安装</h1><p id="2b1b" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">如果您还没有这样做，让我们安装<code class="fe nw nx ny nz b"><a class="ae kv" href="https://reactnavigation.org/docs/getting-started" rel="noopener ugc nofollow" target="_blank">react-navigation</a></code>包。如果您使用Expo，还需要运行<code class="fe nw nx ny nz b">expo install</code>命令来安装它的依赖项！</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="10d1" class="ls lt iq nz b gy oe of l og oh">npm install @react-navigation/native</span><span id="cb70" class="ls lt iq nz b gy oi of l og oh">expo install react-native-gesture-handler react-native-reanimated react-native-screens react-native-safe-area-context @react-native-community/masked-view</span><span id="9d03" class="ls lt iq nz b gy oi of l og oh"><strong class="nz ir">OR if you using yarn:</strong></span><span id="f19d" class="ls lt iq nz b gy oi of l og oh">yarn add @react-navigation/native</span></pre></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="223c" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">设置</h1><p id="f5a0" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">首先，我们将使用一个<a class="ae kv" href="https://reactnavigation.org/docs/stack-navigator/" rel="noopener ugc nofollow" target="_blank">堆栈导航器</a>。我之前提到过React导航推送和弹出路线，它这样做是从堆栈<em class="oj">中的<em class="oj">到</em>和<em class="oj">。</em></em></p><p id="0407" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">堆栈导航器是一个包含应用程序路线的堆栈，默认情况下，您的第一个屏幕是您的根屏幕。当您切换应用程序的屏幕时，新的屏幕会放在堆栈的顶部。</p><p id="5c3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要开始使用React导航，我们需要单独安装<code class="fe nw nx ny nz b">react-navigation-stack</code>包:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="8f42" class="ls lt iq nz b gy oe of l og oh">npm install --save react-navigation-stack</span></pre><p id="0476" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在准备修改我们的<code class="fe nw nx ny nz b">App.js/App.tsx</code>文件来使用堆栈。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="fceb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">App.js/tsx</h2><p id="8357" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">上面有几点说明:</p><ul class=""><li id="41e4" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">首先，我们导入所有的屏幕，就像您通常在任何React/React本机应用程序中所做的那样</li><li id="0b07" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">然后，我们使用<code class="fe nw nx ny nz b">createStackNavigator</code>初始化我们的堆栈，并使用它们的组件为我们应用程序的每个屏幕创建一个堆栈屏幕</li><li id="f543" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">最后，我们用<code class="fe nw nx ny nz b">NavigationContainer</code>包装我们的堆栈屏幕，它负责管理我们应用程序的状态</li></ul></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="f71e" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">使用</h1><h2 id="4f2c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">HomeScreen.tsx</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="995b" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">堆栈中的每个屏幕都将导航作为道具，因此每个屏幕都可以访问导航的<code class="fe nw nx ny nz b">navigate()</code>功能</li><li id="aacb" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><code class="fe nw nx ny nz b">navigate()</code>功能的第一个参数是指屏幕的名称(在<code class="fe nw nx ny nz b">App.tsx</code>中设置)。第二个参数是可选的，保存我们需要在屏幕之间传递的任何细节。在本例中，我们传递一个用户ID和名称。</li></ul><h2 id="205c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">DetailsScreen.tsx</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="828c" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">在<code class="fe nw nx ny nz b">DetailsScreen</code>中，我们正在访问从<code class="fe nw nx ny nz b">HomeScreen.tsx</code>传入的相同路线参数。</li></ul><h2 id="ca7a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">ContactScreen.tsx</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="6e45" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">工作演示</h1><p id="301c" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">我们现在应该有一个带有基本导航的React本机应用程序，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/8c7bb492d02ec590b06a4f6e465d076f.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*kPJ24OIXPk9OHb8kLjkkWQ.gif"/></div></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="cbce" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">临时演员</h1><p id="14c0" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">到目前为止，我们已经通过按钮点击为React本地应用提供了一些基本的导航功能。但是，我们还可以添加一些其他内容，因此下一节将重点介绍:</p><ul class=""><li id="1357" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">页眉样式</li><li id="384f" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">在选项卡中导航</li><li id="7d39" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">浏览侧边抽屉</li></ul><p id="8e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们开始吧！</p><h2 id="e3e8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">页眉样式</h2><p id="1286" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">为了给我们的应用程序标题添加一些样式，我们有两个选项:</p><ul class=""><li id="c152" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">给<code class="fe nw nx ny nz b">Stack.Navigator</code>添加一些默认样式。此处添加的任何样式将应用于堆栈的所有屏幕。</li><li id="14cf" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">给每个屏幕添加一些样式——如果你不想让所有的屏幕看起来都一样，这很有用。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="f81a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，我们选择了两个选项。在<code class="fe nw nx ny nz b">HomeScreen</code>中指定的样式将覆盖在<code class="fe nw nx ny nz b">Stack.Navigator</code>中指定的样式。所以你最终应该为<code class="fe nw nx ny nz b">HomeScreen</code>选择一种背景色，为所有其他屏幕选择另一种背景色。</p><h2 id="a081" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">标签导航</h2><p id="453a" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">标签可以在今天的大多数应用程序中找到，所以我们的应用程序也应该有一些！与堆栈一样，我们需要单独安装这个包:</p><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="32d2" class="ls lt iq nz b gy oe of l og oh">npm install @react-navigation/bottom-tabs</span><span id="4cb6" class="ls lt iq nz b gy oi of l og oh">OR</span><span id="5539" class="ls lt iq nz b gy oi of l og oh">yarn add @react-navigation/bottom-tabs</span></pre><p id="2bd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要修改我们的<code class="fe nw nx ny nz b">App.tsx</code>，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="f685" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated"><code class="fe nw nx ny nz b">Tab.Navigator</code>的<code class="fe nw nx ny nz b">screenOptions</code>道具允许多种配置，其中之一就是<code class="fe nw nx ny nz b">tabBarIcon</code>。在上面的例子中，我们根据激活的路线分配图标。</li></ul><h2 id="a179" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">抽屉导航</h2><pre class="kg kh ki kj gt oa nz ob oc aw od bi"><span id="7ca2" class="ls lt iq nz b gy oe of l og oh">npm install @react-navigation/drawer</span><span id="cb72" class="ls lt iq nz b gy oi of l og oh">OR</span><span id="db1b" class="ls lt iq nz b gy oi of l og oh">yarn add @react-navigation/drawer</span></pre><ul class=""><li id="2c99" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">drawer的实现非常简单，和选项卡一样，您只需用<code class="fe nw nx ny nz b">Drawer.Navigator</code>替换<code class="fe nw nx ny nz b">NavigationContainer</code>的内容。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="785e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您现在点击并从左侧滑动，将会出现一个带有项目<code class="fe nw nx ny nz b">Home</code>、<code class="fe nw nx ny nz b">Details</code>和<code class="fe nw nx ny nz b">Contact</code>的抽屉导航。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="edfb" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">把所有的放在一起</h1><p id="baa8" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">如果你能走到这一步，太棒了！到目前为止，我们已经了解了如何通过React Navigation提供的三个主要导航器来实现导航——堆栈、选项卡和抽屉。但是现在大多数应用程序同时使用了<em class="oj">和</em>所有这些功能，那么我们该怎么做呢？</p><p id="1757" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您尝试向<code class="fe nw nx ny nz b">NavigatorContainer</code>添加多个导航器，它会产生一个错误，说已经有一个导航器了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/96fb72222e4a20b2c90016f611475b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chzeIszudlOkUVyRZQp74w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">塞巴斯蒂安·赫尔曼在<a class="ae kv" href="https://unsplash.com/s/photos/frustration?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="60f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的第一个想法可能是将选项卡导航器移动到<code class="fe nw nx ny nz b">HomeScreen</code>中。然而，这意味着几件事:</p><ul class=""><li id="d5f4" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">我们的<code class="fe nw nx ny nz b">HomeScreen</code>内容将会丢失，因为它将被选项卡导航功能所取代</li><li id="b4b4" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">我们可能会有一个无限循环，因为<code class="fe nw nx ny nz b">HomeScreen</code>会自己导航</li><li id="e80a" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated">我们必须在所有屏幕上添加标签导航器，以确保在通过标签导航时不会丢失它们</li></ul><p id="61cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个更好的选择是创建一个单独的<code class="fe nw nx ny nz b">MainScreen</code>组件来保存我们的<code class="fe nw nx ny nz b">Home</code>、<code class="fe nw nx ny nz b">Details</code>和<code class="fe nw nx ny nz b">Contact</code>的选项卡导航器代码。</p><p id="704d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们现在就做吧！</p><h2 id="082f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">MainScreen.tsx</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><ul class=""><li id="f21c" class="ml mm iq ky b kz la lc ld lf om lj on ln oo lr ms mt mu mv bi translated">我们还对<code class="fe nw nx ny nz b">App.tsx</code>做了一点小小的改动，以确保抽屉导航中的<code class="fe nw nx ny nz b">Home</code>标签指向<code class="fe nw nx ny nz b">MainScreen</code>，它现在处理我们的标签。</li></ul><h2 id="5ef8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">App.tsx</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="55df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于我们的<code class="fe nw nx ny nz b">initialRouteName</code>被设置为<code class="fe nw nx ny nz b">Home</code>，我们的<code class="fe nw nx ny nz b">MainScreen</code>将默认拾取并渲染<code class="fe nw nx ny nz b">Home</code>。</p><h2 id="3ed2" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">栈呢？</h2><p id="8fca" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">最后，为了将我们的<code class="fe nw nx ny nz b">Stack.Navigator</code>添加到我们的应用程序中，我创建了两个子contact组件，并将一个<code class="fe nw nx ny nz b">Stack.Navigator</code>添加到我们的父组件<code class="fe nw nx ny nz b">ContactScreen</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对用户来说，这将简单地导航到<code class="fe nw nx ny nz b">ContactA</code>或<code class="fe nw nx ny nz b">ContactB</code>。唯一的区别是在幕后，它将属于在<code class="fe nw nx ny nz b">ContactScreen</code>中创建的堆栈——这也是一个如何嵌套导航器的好例子。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="f855" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">最终产品</h1><p id="3364" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">我们现在有了一个React本地应用程序，它通过React导航包使用堆栈、选项卡和抽屉导航器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/400a3e7c41a6d4dfd990b6742caf5cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOl9mH7Atje9t9plBJrnEA.png"/></div></div></figure></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="388f" class="ni lt iq bd lu nj nk nl lx nm nn no ma jw np jx md jz nq ka mg kc nr kd mj ns bi translated">摘要</h1><p id="cfa7" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf nt lh li lj nu ll lm ln nv lp lq lr ij bi translated">React导航提供了一种简单的方法来处理整个React本机应用程序的导航。借助堆栈、标签和抽屉，在屏幕间切换轻而易举。</p><h2 id="bcdb" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">有用的链接</h2><ul class=""><li id="5f92" class="ml mm iq ky b kz mn lc mo lf mp lj mq ln mr lr ms mt mu mv bi translated"><a class="ae kv" href="https://github.com/nats12/react-native-navigation-demo" rel="noopener ugc nofollow" target="_blank"> GitHub回购</a></li><li id="980e" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><a class="ae kv" href="https://github.com/react-navigation/react-navigation/tree/main/example" rel="noopener ugc nofollow" target="_blank"> React导航回购包括一个演示</a></li><li id="f14c" class="ml mm iq ky b kz mw lc mx lf my lj mz ln na lr ms mt mu mv bi translated"><a class="ae kv" href="https://wix.github.io/react-native-navigation/docs/playground-app/" rel="noopener ugc nofollow" target="_blank">游乐场app </a></li></ul></div></div>    
</body>
</html>