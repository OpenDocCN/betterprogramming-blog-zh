<html>
<head>
<title>How To Use Kubernetes’ Job and CronJob</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Kubernetes的Job和CronJob</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/tutorial-how-to-use-kubernetes-job-and-cronjob-1ef4ffbc8e84?source=collection_archive---------0-----------------------#2020-01-10">https://betterprogramming.pub/tutorial-how-to-use-kubernetes-job-and-cronjob-1ef4ffbc8e84?source=collection_archive---------0-----------------------#2020-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d1d7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">安排代码在您的容器化环境中运行</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9d91e2b5353e31c4b77fbb38039bb892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v4ode3iAY7BJWgBjYwdGTg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@grantritchie?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">格兰特·里奇</a>在<a class="ae kv" href="https://unsplash.com/s/photos/environment?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎来到<a class="ae kv" href="https://itnext.io/kubernetes-in-a-nutshell-blog-series-c3a97fce9445" rel="noopener ugc nofollow" target="_blank"/>博客系列的另一部分“一言以蔽之的Kubernetes”。到目前为止，我们已经讨论了Kubernetes资源(对象)，比如<code class="fe ls lt lu lv b">Deployment</code> s、<code class="fe ls lt lu lv b">Service</code> s、<code class="fe ls lt lu lv b">Volume</code> s等。</p><p id="2379" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博客中，我们将探索<code class="fe ls lt lu lv b">Job</code>和<code class="fe ls lt lu lv b">CronJob</code>。借助示例，您将了解到:</p><ul class=""><li id="9ecf" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">如何使用这些组件。</li><li id="abc3" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">指定时间限制、并发性等约束。</li><li id="3015" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">处理故障等。</li></ul><p id="b8d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">代码(YAML的很多)在GitHub 上有<a class="ae kv" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6839" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">库伯内特工作</h1><p id="36ad" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">您可以使用Kubernetes <code class="fe ls lt lu lv b">Job</code>来运行批处理、ETL作业、特别操作等。它从一个<code class="fe ls lt lu lv b">Pod</code>开始，并让它运行到完成。这与其他<code class="fe ls lt lu lv b">Pod</code>控制器如<code class="fe ls lt lu lv b">Deployment</code>或<code class="fe ls lt lu lv b">ReplicaSet</code>完全不同。</p><p id="1eeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一如既往，我们将在实践中学习。所以，让我们开始吧！</p><h2 id="496f" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated">你好工作！</h2><p id="2aca" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">下面是一个典型的<code class="fe ls lt lu lv b">Job</code>清单:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="0421" class="no ms iq lv b gy oe of l og oh">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: job1<br/>spec:<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: job<br/>          image: busybox<br/>          args:<br/>            - /bin/sh<br/>            - -c<br/>            - date; echo sleeping....; sleep 90s; echo exiting...; date<br/>      restartPolicy: Never</span></pre><p id="3bc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个<code class="fe ls lt lu lv b">Job</code>将简单地启动一个<code class="fe ls lt lu lv b"><a class="ae kv" href="https://hub.docker.com/_/busybox" rel="noopener ugc nofollow" target="_blank">busybox</a></code>容器，该容器简单地执行一些shell命令。让我们创建这个<code class="fe ls lt lu lv b">Job</code>并调查发生了什么</p><p id="a8ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简单起见，YAML文件直接从<a class="ae kv" href="https://github.com/abhirockzz/kubernetes-in-a-nutshell" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中引用，但是您也可以将该文件下载到您的本地机器上，并以同样的方式使用它。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="e9d1" class="no ms iq lv b gy oe of l og oh">kubectl apply -f <a class="ae kv" href="https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/jobs/job1.yaml" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/jobs/job1.yaml</a></span></pre><p id="f0c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查<code class="fe ls lt lu lv b">Job</code>及其相关的<code class="fe ls lt lu lv b">Pod</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="f678" class="no ms iq lv b gy oe of l og oh">kubectl get job/job1</span><span id="f677" class="no ms iq lv b gy oi of l og oh">NAME   COMPLETIONS   DURATION   AGE<br/>job1   0/1           8s         8s</span></pre><p id="52b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该在<code class="fe ls lt lu lv b">Running</code>状态下看到一个<code class="fe ls lt lu lv b">Pod</code>，例如:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="9d5e" class="no ms iq lv b gy oe of l og oh">kubectl get pod -l=job-name=job1</span><span id="0ec6" class="no ms iq lv b gy oi of l og oh">job1-bptmd 1/1  Running</span></pre><p id="5cc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您检查<code class="fe ls lt lu lv b">Pod</code>日志，您应该会看到类似如下的内容:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="b5c0" class="no ms iq lv b gy oe of l og oh">kubectl logs &lt;pod_name&gt;</span><span id="7791" class="no ms iq lv b gy oi of l og oh">Thu Jan  9 10:10:35 UTC 2020<br/>sleeping....</span></pre><p id="4de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">90后再检查一下工作。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="cc43" class="no ms iq lv b gy oe of l og oh">kubectl get job/job1</span><span id="9d93" class="no ms iq lv b gy oi of l og oh">NAME   COMPLETIONS   DURATION   AGE<br/>job1   1/1           95s        102s</span></pre><p id="7a82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Job</code>跑了90秒多一点，而<code class="fe ls lt lu lv b">COMPLETIONS</code>反映出一个<code class="fe ls lt lu lv b">Pod</code>成功完成。这也将反映在<code class="fe ls lt lu lv b">Pod</code>日志中。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="9564" class="no ms iq lv b gy oe of l og oh">Thu Jan  9 10:10:05 UTC 2020<br/>sleeping....<br/>exiting...<br/>Thu Jan  9 10:11:35 UTC 2020</span></pre><p id="5f9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，<code class="fe ls lt lu lv b">Pod</code>状态应该变为<code class="fe ls lt lu lv b">Completed</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="7050" class="no ms iq lv b gy oe of l og oh">kubectl get pod -l=job-name=job1</span><span id="faaf" class="no ms iq lv b gy oi of l og oh">job1-bptmd 0/1  Completed</span></pre><p id="c3d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果所有的<code class="fe ls lt lu lv b">Job</code>只是创建一个<code class="fe ls lt lu lv b">Pod</code>来运行一个容器，为什么我们不能使用一个普通的旧<code class="fe ls lt lu lv b">Pod</code>？</p><p id="ab4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为如果容器发生故障，Kubernetes可以重启一个<code class="fe ls lt lu lv b">Job</code>，而隔离的<code class="fe ls lt lu lv b">Pod</code>不会发生这种情况。除此之外，作业控制器还提供了许多其他功能，我们将继续探索这些功能。</p><p id="263f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要删除这个<code class="fe ls lt lu lv b">Job</code>，只需运行<code class="fe ls lt lu lv b">kubectl delete job/job1</code>。</p><h2 id="cca0" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated">强制执行时间限制</h2><p id="3d93" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">例如，您正在运行一个批处理作业，由于某种原因，它需要很长时间才能完成。这可能是不可取的。您可以通过设置规范中的<code class="fe ls lt lu lv b">activeDeadlineSeconds</code>属性来限制<code class="fe ls lt lu lv b">Job</code>继续运行的时间。</p><p id="9312" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="2f3b" class="no ms iq lv b gy oe of l og oh">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: job2<br/>spec:<br/>  activeDeadlineSeconds: 5<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: job<br/>          image: busybox<br/>          args:<br/>            - /bin/sh<br/>            - -c<br/>            - date; echo sleeping....; sleep 10s; echo exiting...; date<br/>      restartPolicy: Never</span></pre><p id="b98e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<code class="fe ls lt lu lv b">activeDeadlineSeconds</code>已被设置为5秒，而容器进程已被指定运行10秒。</p><p id="9dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe ls lt lu lv b">Job</code>，等待几秒钟(~10秒)并检查<code class="fe ls lt lu lv b">Job</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="b5e5" class="no ms iq lv b gy oe of l og oh">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/jobs/job2.yaml</span><span id="2f7f" class="no ms iq lv b gy oi of l og oh">kubect get job/job2 -o yaml</span></pre><p id="2662" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">向下滚动检查<code class="fe ls lt lu lv b">status</code>字段，您将看到<code class="fe ls lt lu lv b">Job</code>由于<code class="fe ls lt lu lv b">DeadlineExceeded</code>而处于<code class="fe ls lt lu lv b">Failed</code>状态。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="36ab" class="no ms iq lv b gy oe of l og oh">status:<br/>  conditions:<br/>  - lastProbeTime: "2020-01-09T10:57:13Z"<br/>    lastTransitionTime: "2020-01-09T10:57:13Z"<br/>    message: Job was active longer than specified deadline<br/>    reason: DeadlineExceeded<br/>    status: "True"<br/>    type: Failed</span></pre><p id="61d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要删除作业，只需运行<code class="fe ls lt lu lv b">kubectl delete job/job2</code>。</p><h2 id="f74a" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated">处理故障</h2><p id="c1d2" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果由于容器故障(进程退出)或<code class="fe ls lt lu lv b">Pod</code>故障而出现问题，该怎么办？让我们通过模拟一次失败来尝试一下。</p><p id="7155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在此<code class="fe ls lt lu lv b">Job</code>中，容器打印<code class="fe ls lt lu lv b">date</code>、<code class="fe ls lt lu lv b">sleep</code>s 5秒，并以<em class="oj">状态1 </em>退出以模拟故障。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="7163" class="no ms iq lv b gy oe of l og oh">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: job3<br/>spec:<br/>  backoffLimit: 2<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: job<br/>          image: busybox<br/>          args:<br/>            - /bin/sh<br/>            - -c<br/>            - date; echo sleeping....; sleep 5s; exit 1;<br/>      restartPolicy: OnFailure</span></pre><p id="38d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，<code class="fe ls lt lu lv b">restartPolicy: OnFailure</code>与之前设置为<code class="fe ls lt lu lv b">Never</code>的示例不同。我们一会儿将回到这一点。</p><p id="776f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe ls lt lu lv b">Job</code>并关注该工作的特定<code class="fe ls lt lu lv b">Pod</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="f1b5" class="no ms iq lv b gy oe of l og oh">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/jobs/job3.yaml</span><span id="fe8f" class="no ms iq lv b gy oi of l og oh">kubectl get pod -l=job-name=job3 -w</span></pre><p id="bcf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到类似下面的内容:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="ea20" class="no ms iq lv b gy oe of l og oh">NAME                                     READY   STATUS              RESTARTS   AGE<br/>job3-qgv4b                               0/1     ContainerCreating   0          4s<br/>job3-qgv4b                               1/1     Running             0          6s<br/>job3-qgv4b                               0/1     Error               0          12s<br/>job3-qgv4b                               1/1     Running             1          17s<br/>job3-qgv4b                               0/1     Error               1          22s<br/>job3-qgv4b                               0/1     CrashLoopBackOff    1          34s<br/>job3-qgv4b                               1/1     Running             2          40s<br/>job3-qgv4b                               1/1     Terminating         2          40s<br/>job3-qgv4b                               0/1     Terminating         2          45s<br/>job3-qgv4b                               0/1     Terminating         2          51s</span></pre><p id="1470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe ls lt lu lv b">Pod</code>状态是如何转变的。</p><ul class=""><li id="36c9" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">它从拉动和运行容器开始。</li><li id="960c" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">它转换到<code class="fe ls lt lu lv b">Error</code>状态，因为它以状态1退出(休眠5秒后)。</li><li id="6b30" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">它再次回到<code class="fe ls lt lu lv b">Running</code>状态(注意<code class="fe ls lt lu lv b">RESTARTS</code>计数现在是1)。</li><li id="908a" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">不出所料，它再次进入<code class="fe ls lt lu lv b">Error</code>状态，并再次重启- <code class="fe ls lt lu lv b">RESTARTS</code>计数现在为2。</li><li id="03c4" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">最后是<code class="fe ls lt lu lv b">terminated</code>。</li></ul><p id="d8aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes(具体来说是作业控制器)为我们重启了容器，因为我们指定了<code class="fe ls lt lu lv b">restartPolicy: OnFailure</code>。</p><p id="38fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是可能会有一种情况，这种情况可能会无限期地持续下去，所以我们使用<code class="fe ls lt lu lv b">backoffLimit: 2</code>对此加以限制，这将确保Kubernetes在将这个<code class="fe ls lt lu lv b">Job</code>标记为<code class="fe ls lt lu lv b">Failed</code>之前只重试两次。</p><p id="39eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这是一个重启容器的例子。在<code class="fe ls lt lu lv b">Pod</code>出现故障的情况下，作业控制器也可以创建一个新的<code class="fe ls lt lu lv b">Pod</code>。</p><p id="2694" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您检查<code class="fe ls lt lu lv b">Job</code>状态...</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="b3f9" class="no ms iq lv b gy oe of l og oh">kubectl get job/job3 -o yaml</span></pre><p id="0174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…您会看到，由于<code class="fe ls lt lu lv b">BackoffLimitExceeded</code>，它有<code class="fe ls lt lu lv b">Failed</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="d1dd" class="no ms iq lv b gy oe of l og oh">status:<br/>  conditions:<br/>  - lastProbeTime: "2020-01-09T11:16:24Z"<br/>    lastTransitionTime: "2020-01-09T11:16:24Z"<br/>    message: Job has reached the specified backoff limit<br/>    reason: BackoffLimitExceeded<br/>    status: "True"<br/>    type: Failed</span></pre><p id="a2d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Never</code>中的<code class="fe ls lt lu lv b">restartPolicy</code>表示出错时不会重启容器或创建新的<code class="fe ls lt lu lv b">Pod</code>。另外，<code class="fe ls lt lu lv b">backoffLimit</code>的默认限值是<code class="fe ls lt lu lv b">6</code>。</p><p id="7acf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要删除此作业，只需运行<code class="fe ls lt lu lv b">kubectl delete job/job3</code>。</p><h2 id="678e" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated">越多越好</h2><p id="555e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">有些情况下，你可能希望<code class="fe ls lt lu lv b">Job</code>带动不止一个<code class="fe ls lt lu lv b">Pod</code>来完成任务。</p><p id="19cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，考虑一个场景，您正在运行一个批处理作业来处理来自一个数据库的记录——让多个<code class="fe ls lt lu lv b">Pod</code>分担负载肯定会有所帮助。</p><p id="45ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种方法是让每个<code class="fe ls lt lu lv b">Pod</code>按顺序运行，记录外部源(例如另一个数据库表)中处理的行数，另一个<code class="fe ls lt lu lv b">Pod</code>可以从那里开始。</p><p id="ceda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以通过在<code class="fe ls lt lu lv b">Job</code>规范中添加<code class="fe ls lt lu lv b">completions</code>属性来实现。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="8ad7" class="no ms iq lv b gy oe of l og oh">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: job4<br/>spec:<br/>  completions: 2<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: job<br/>          image: busybox<br/>          args:<br/>            - /bin/sh<br/>            - -c<br/>            - date; echo sleeping....; sleep 10s; echo exiting...; date<br/>      restartPolicy: Never</span></pre><p id="603e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe ls lt lu lv b">Job</code>并关注它的进展。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="7464" class="no ms iq lv b gy oe of l og oh">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/jobs/job4.yaml</span><span id="7895" class="no ms iq lv b gy oi of l og oh">kubectl get job/job4 -w</span></pre><p id="8ce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到类似这样的内容:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="9973" class="no ms iq lv b gy oe of l og oh">NAME   COMPLETIONS   DURATION   AGE<br/>job4   0/2           3s         3s<br/>job4   1/2           20s        20s<br/>job4   2/2           37s        37s</span></pre><p id="e831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们已经将<code class="fe ls lt lu lv b">completions</code>设置为2:</p><ul class=""><li id="68c3" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">两个<code class="fe ls lt lu lv b">Pod</code>一个接一个地被实例化(按顺序)。</li><li id="130b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">只有在两个<code class="fe ls lt lu lv b">Pod</code>都运行完成后，<code class="fe ls lt lu lv b">Job</code>才被标记为<code class="fe ls lt lu lv b">Completed</code>(成功)。否则，就会出现故障条件(如上所述)。</li></ul><p id="b325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们也检查一下<code class="fe ls lt lu lv b">Pod</code>日志。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="78ad" class="no ms iq lv b gy oe of l og oh">kubectl get pods -l=job-name=job4<br/>kubect logs &lt;pod_name&gt;</span></pre><p id="f473" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您看到两个<code class="fe ls lt lu lv b">Pod</code>的日志，您将能够确认它们按顺序一个接一个地启动(并且每个运行了大约10秒)。</p><p id="7fde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Pod</code> 1的日志。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="c8e7" class="no ms iq lv b gy oe of l og oh">Thu Jan  9 11:31:57 UTC 2020<br/>sleeping....<br/>exiting...<br/>Thu Jan  9 11:32:07 UTC 2020</span></pre><p id="9feb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Pod</code> 2的日志。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="5cb9" class="no ms iq lv b gy oe of l og oh">Thu Jan  9 11:32:15 UTC 2020<br/>sleeping....<br/>exiting...<br/>Thu Jan  9 11:32:25 UTC 2020</span></pre><p id="75f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以并行的方式运行批处理怎么样，所有的<code class="fe ls lt lu lv b">Pod</code>被一次实例化(而不是顺序地)？</p><p id="2389" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了处理这种情况，我们的处理逻辑需要相应地调整，因为在选择哪组工作项以及如何更新它们的完成状态方面，并行<code class="fe ls lt lu lv b">Pod</code>之间需要协调。</p><p id="eb24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不会深入探讨这个问题，但我希望你能从需求方面了解这个想法。</p><p id="a6a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，这可以通过使用<code class="fe ls lt lu lv b">parallelism</code>和<code class="fe ls lt lu lv b">completions</code>来实现。这里有一个例子:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="ebcf" class="no ms iq lv b gy oe of l og oh">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: job5<br/>spec:<br/>  completions: 3<br/>  parallelism: 3<br/>  template:<br/>    spec:<br/>      containers:<br/>        - name: job<br/>          image: busybox<br/>          args:<br/>            - /bin/sh<br/>            - -c<br/>            - date; echo sleeping....; sleep 10s; echo exiting...; date<br/>      restartPolicy: Never</span></pre><p id="b28b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用<code class="fe ls lt lu lv b">parallelism</code>属性，我们能够对一次可以运行的<code class="fe ls lt lu lv b">Pod</code>的最大数量设置上限。在这种情况下，由于<code class="fe ls lt lu lv b">parallelism</code>被设置为3，这意味着:</p><ul class=""><li id="b2aa" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">三个<code class="fe ls lt lu lv b">Pod</code>将同时被实例化。</li><li id="1387" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">只有三个都运行完成时，<code class="fe ls lt lu lv b">Job</code>才会被标记为<code class="fe ls lt lu lv b">Completed</code>(成功)。否则，故障条件适用(如上所述)。</li></ul><h2 id="e992" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated">一旦你完成了</h2><p id="6ad3" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">ttlSecondsAfterFinished</code>指定<code class="fe ls lt lu lv b">Job</code>完成后自动删除的秒数(可以是<code class="fe ls lt lu lv b">Completed</code>或<code class="fe ls lt lu lv b">Failed</code>)。这也删除了依赖实体，例如由<code class="fe ls lt lu lv b">Job</code>产生的<code class="fe ls lt lu lv b">Pod</code>。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="26f4" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">克朗乔布</h1><p id="88ab" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">一个<code class="fe ls lt lu lv b">CronJob</code>对象允许您安排<code class="fe ls lt lu lv b">Job</code>的执行，而不是手动启动它们。</p><p id="1e63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Cron" rel="noopener ugc nofollow" target="_blank"> Cron </a>格式按计划运行作业。基本上，<code class="fe ls lt lu lv b">CronJob</code>是一个更高层次的抽象，它内嵌了一个<code class="fe ls lt lu lv b">Job</code>模板(如上所示)以及一个时间表(cron格式)和其他属性。</p><p id="9c06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建一个简单的每分钟重复一次的<code class="fe ls lt lu lv b">CronJob</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="7c09" class="no ms iq lv b gy oe of l og oh">apiVersion: batch/v1beta1<br/>kind: CronJob<br/>metadata:<br/>  name: cronjob1<br/>spec:<br/>  schedule: "*/1 * * * *"<br/>  jobTemplate:<br/>    spec:<br/>      template:<br/>        spec:<br/>          containers:<br/>            - name: cronjob<br/>              image: busybox<br/>              args:<br/>                - /bin/sh<br/>                - -c<br/>                - date; echo sleeping....; sleep 5s; echo exiting...;<br/>          restartPolicy: Never</span></pre><p id="0e3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">jobTemplate</code>部分与<code class="fe ls lt lu lv b">Job</code>部分相同。它只是嵌入在这个<code class="fe ls lt lu lv b">CronJob</code>规格中。这与我们在<code class="fe ls lt lu lv b">Job</code>示例中使用的容器相同。</p><p id="0a74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<code class="fe ls lt lu lv b">CronJob</code>并检查它:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="4588" class="no ms iq lv b gy oe of l og oh">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/jobs/cronjob1.yaml</span><span id="955c" class="no ms iq lv b gy oi of l og oh">kubectl get cronjob/cronjob1</span></pre><p id="4538" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="99d7" class="no ms iq lv b gy oe of l og oh">NAME       SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE<br/>cronjob1   */1 * * * *   False     0        &lt;none&gt;          4s</span></pre><p id="1991" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">跟踪这个<code class="fe ls lt lu lv b">CronJob</code>产生的<code class="fe ls lt lu lv b">Job</code>。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="c7fb" class="no ms iq lv b gy oe of l og oh">kubectl get job -w</span><span id="e211" class="no ms iq lv b gy oi of l og oh">NAME                  COMPLETIONS   DURATION   AGE<br/>cronjob1-1578572340   0/1           2s         2s<br/>cronjob1-1578572340   1/1           11s        11s<br/>cronjob1-1578572400   0/1                      0s<br/>cronjob1-1578572400   0/1           0s         0s<br/>cronjob1-1578572400   1/1           10s        10s<br/>cronjob1-1578572460   0/1                      0s<br/>cronjob1-1578572460   0/1           0s         0s<br/>cronjob1-1578572460   1/1           11s        11s</span></pre><p id="c4ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每分钟都有一个新的<code class="fe ls lt lu lv b">Job</code>被创建，它运行了大约10秒钟。您还可以检查由<code class="fe ls lt lu lv b">Job</code>创建的个人<code class="fe ls lt lu lv b">Pod</code>的日志(就像您在前面的例子中所做的那样)。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="6c07" class="no ms iq lv b gy oe of l og oh">kubectl get pod -l=job-name=&lt;job_name&gt;<br/>kubectl logs &lt;pod_name&gt;</span></pre><p id="03d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<code class="fe ls lt lu lv b">schedule</code>属性之外，还有其他(可选)<code class="fe ls lt lu lv b">CronJob</code>属性。让我们来看看其中的一个。</p><h2 id="f265" class="no ms iq bd mt np nq dn mx nr ns dp nb lf nt nu nd lj nv nw nf ln nx ny nh nz bi translated">并行政策</h2><p id="b2a7" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">它有三个可能的值— <code class="fe ls lt lu lv b">Forbid</code>、<code class="fe ls lt lu lv b">Allow</code>和<code class="fe ls lt lu lv b">Replace</code>。</p><p id="cfed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您不想同时执行您的<code class="fe ls lt lu lv b">Job</code>，请选择<code class="fe ls lt lu lv b">Forbid</code>。当按照时间表触发一个<code class="fe ls lt lu lv b">Job</code>并且一个<code class="fe ls lt lu lv b">Job</code>实例已经在运行时，当前的迭代被跳过。</p><p id="3cdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您选择<code class="fe ls lt lu lv b">Replace</code>作为并发策略，当前运行的<code class="fe ls lt lu lv b">Job</code>将被停止，一个新的<code class="fe ls lt lu lv b">Job</code>将被生成。</p><p id="d976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">指定<code class="fe ls lt lu lv b">Allow</code>将让多个<code class="fe ls lt lu lv b">Job</code>实例并发运行。</p><p id="ce76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="cea4" class="no ms iq lv b gy oe of l og oh">apiVersion: batch/v1beta1<br/>kind: CronJob<br/>metadata:<br/>  name: cronjob2<br/>spec:<br/>  schedule: "*/1 * * * *"<br/>  concurrencyPolicy: Allow<br/>  jobTemplate:<br/>    spec:<br/>      template:<br/>        spec:<br/>          containers:<br/>            - name: cronjob<br/>              image: busybox<br/>              args:<br/>                - /bin/sh<br/>                - -c<br/>                - date; echo sleeping....; sleep 90s; echo exiting...;<br/>          restartPolicy: Never</span></pre><p id="a579" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以创建这个<code class="fe ls lt lu lv b">CronJob</code>，然后跟踪单个的<code class="fe ls lt lu lv b">Job</code>来观察行为。</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="0710" class="no ms iq lv b gy oe of l og oh">kubectl apply -f https://raw.githubusercontent.com/abhirockzz/kubernetes-in-a-nutshell/master/jobs/cronjob2.yaml</span><span id="0de1" class="no ms iq lv b gy oi of l og oh">kubectl get job -w</span></pre><p id="88ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于时间表是每一分钟，容器运行90秒，您将看到多个<code class="fe ls lt lu lv b">Job</code>同时运行。这种重叠是可能的，因为我们已经应用了<code class="fe ls lt lu lv b">concurrencyPolicy: Allow</code>。</p><p id="f7fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会看到类似这样的内容:</p><pre class="kg kh ki kj gt oa lv ob oc aw od bi"><span id="88aa" class="no ms iq lv b gy oe of l og oh">cronjob2-1578573480   0/1                      0s<br/>cronjob2-1578573480   0/1           0s         0s<br/>cronjob2-1578573540   0/1                      0s<br/>cronjob2-1578573540   0/1           0s         0s<br/>cronjob2-1578573480   1/1           95s        95s</span></pre><p id="7198" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，作业<code class="fe ls lt lu lv b">cronjob2-1578573540</code>在<code class="fe ls lt lu lv b">cronjob2-1578573480</code>完成之前被触发。</p><p id="4d84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">CronJob</code>的其他属性有:</p><ul class=""><li id="41b6" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">作业历史:<code class="fe ls lt lu lv b">successfulJobsHistoryLimit</code>和<code class="fe ls lt lu lv b">failedJobsHistoryLimit</code>可用于指定您希望为失败和完成的<code class="fe ls lt lu lv b">Job</code>保留多少历史</li><li id="6005" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">由<code class="fe ls lt lu lv b">startingDeadlineSeconds</code>指定的开始截止日期。</li><li id="e80d" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">由<code class="fe ls lt lu lv b">suspend</code>指定暂停。</li></ul></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="2eaa" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="f1c7" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">这就是“果壳中的库伯内特”系列的这一部分。敬请关注更多内容。</p><p id="07fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我真的希望你喜欢这篇文章，并从中学到了一些东西。很高兴收到您的反馈意见。</p></div></div>    
</body>
</html>