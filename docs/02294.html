<html>
<head>
<title>Using Promises for Async Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中使用承诺进行异步编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-promises-for-async-programming-in-javascript-b544f1c4c4ca?source=collection_archive---------12-----------------------#2019-11-19">https://betterprogramming.pub/using-promises-for-async-programming-in-javascript-b544f1c4c4ca?source=collection_archive---------12-----------------------#2019-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5e12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用promise对象保持代码运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/90250a1e73e05bc751fdaa2a28b8ab10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cI8R6E-Z8lr7g4XpoHFuzw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@maxchen2k?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max陈</a>在<a class="ae ky" href="https://unsplash.com/s/photos/promise?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="3580" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为JavaScript是单线程语言，同步代码一次只能执行一行。这意味着，如果同步代码运行的时间超过了瞬时时间，那么它将停止其余代码的运行，直到正在运行的代码结束。为了防止运行时间不确定的代码阻碍其他代码的运行，我们需要异步代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b1d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">承诺</h1><p id="2cf0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要在JavaScript中做到这一点，我们可以在代码中使用承诺。承诺是代表一个过程的对象，该过程运行的时间不确定，并且可能导致成功或失败。为了在JavaScript中创建承诺，我们使用了一个<code class="fe mz na nb nc b">Promise</code>对象，它是创建承诺的构造函数。<code class="fe mz na nb nc b">Promise</code>构造函数采用一个名为executor函数的函数，该函数有<code class="fe mz na nb nc b">resolve</code>和<code class="fe mz na nb nc b">reject</code>参数。这两个参数都是我们调用的函数，要么履行承诺(这意味着用某个值成功地结束它)，要么拒绝承诺(这意味着返回某个错误值并将承诺标记为失败)。函数的返回值被忽略。所以，承诺不能回报承诺之外的任何东西。</p><p id="8ae8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以在JavaScript中定义一个承诺，如下所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a287" class="nh md it nc b gy ni nj l nk nl">const promise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve('abc'), 1000);<br/>});</span></pre><p id="a8ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码创建了一个承诺，该承诺在一秒钟后用值<code class="fe mz na nb nc b">abc</code>实现。因为我们在executor函数中运行<code class="fe mz na nb nc b">setTimeout</code>来在一秒钟内解析带有值<code class="fe mz na nb nc b">abc</code>的承诺，所以这是异步代码。我们不能在<code class="fe mz na nb nc b">setTimeout</code>的回调函数内返回值<code class="fe mz na nb nc b">abc</code>，所以我们必须调用<code class="fe mz na nb nc b">resolve('abc')</code>来取回解析后的值。我们可以通过使用<code class="fe mz na nb nc b">then</code>函数来访问已履行承诺的解析值。<code class="fe mz na nb nc b">then</code>函数接受一个回调函数，该函数将已履行承诺的解析值作为参数。你可以在那里得到价值，然后用它做你想做的事情。例如，我们可以这样做:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="57a7" class="nh md it nc b gy ni nj l nk nl">const promise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve('abc'), 1000);<br/>});</span><span id="6023" class="nh md it nc b gy nm nj l nk nl">promise.then((val) =&gt; {<br/>  console.log(val);<br/>})</span></pre><p id="dcdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们应该看到<code class="fe mz na nb nc b">abc</code>被记录。正如我们所看到的，当通过调用<code class="fe mz na nb nc b">resolve</code>函数实现承诺时，承诺将提供值。</p><p id="63cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺有三种状态。它可以是待定的，这意味着承诺已经实现或被拒绝。它可以实现，这意味着操作成功完成。或者可以拒绝，说明承诺操作失败。</p><p id="63cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个待定的承诺既可以有值地履行，也可以因某种错误而被拒绝。当一个承诺被履行时，相应的解析值被<code class="fe mz na nb nc b">then</code>函数获取，传递给<code class="fe mz na nb nc b">then</code>函数的回调函数被调用。如果一个承诺被拒绝，那么我们可以有选择地用<code class="fe mz na nb nc b">catch</code>函数捕捉错误，这个函数也接受一个带有错误的回调函数。<code class="fe mz na nb nc b">then</code>和<code class="fe mz na nb nc b">catch</code>函数都返回承诺，所以它们可以链接在一起。</p><p id="3c37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以这样写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="d87f" class="nh md it nc b gy ni nj l nk nl">const promise = (num) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      if (num === 1) {<br/>        resolve('resolved')<br/>      } else {<br/>        reject('rejected')<br/>      }<br/>    }, 1000);<br/>  });<br/>}</span><span id="5265" class="nh md it nc b gy nm nj l nk nl">promise(1)<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })</span><span id="6ff8" class="nh md it nc b gy nm nj l nk nl">promise(2)<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })</span></pre><p id="9d51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们有一个函数<code class="fe mz na nb nc b">promise</code>,当<code class="fe mz na nb nc b">num</code>为1时，它返回一个JavaScript promise，该函数使用值<code class="fe mz na nb nc b">resolved</code>来实现该承诺，否则拒绝该承诺并返回错误<code class="fe mz na nb nc b">rejected</code>。所以我们跑:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9df7" class="nh md it nc b gy ni nj l nk nl">promise(1)<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })</span></pre><p id="8589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe mz na nb nc b">then</code>函数运行，由于<code class="fe mz na nb nc b">num</code>为1，所以<code class="fe mz na nb nc b">promise(1)</code>函数调用返回的承诺得到履行，解析后的值在<code class="fe mz na nb nc b">val</code>中设置。所以当我们运行<code class="fe mz na nb nc b">console.log(val)</code>时，我们得到<code class="fe mz na nb nc b">resolved</code>日志。当我们运行下面的代码时:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="67b7" class="nh md it nc b gy ni nj l nk nl">promise(2)<br/>  .then((val) =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })</span></pre><p id="0ea2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe mz na nb nc b">catch </code>函数运行，因为<code class="fe mz na nb nc b">promise(2)</code>函数调用返回的承诺被拒绝，被拒绝的错误值可在error中设置。所以当我们运行<code class="fe mz na nb nc b">console.log(error)</code>时，我们得到<code class="fe mz na nb nc b">rejected</code>日志。</p><p id="4656" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个JavaScript promise对象有以下属性:<code class="fe mz na nb nc b">length</code>和<code class="fe mz na nb nc b">prototype</code>。对于构造函数参数的数量，<code class="fe mz na nb nc b">length</code>总是将其值设置为1，也就是1。<code class="fe mz na nb nc b">prototype</code>属性表示承诺对象的原型。</p><p id="b9ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">promise还有一个<code class="fe mz na nb nc b">finally</code>方法来运行代码，不管promise是被履行还是被拒绝，代码都会运行。<code class="fe mz na nb nc b">finally</code>方法将回调函数作为参数，无论承诺的结果如何，您想要运行的任何代码都会在这里运行。例如，如果我们运行:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2b23" class="nh md it nc b gy ni nj l nk nl">Promise.reject('error')<br/>  .then((value) =&gt; {<br/>    console.log(value);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })<br/>  .finally(() =&gt; {<br/>    console.log('finally runs');<br/>  })</span></pre><p id="d03e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录了<code class="fe mz na nb nc b">error</code>和<code class="fe mz na nb nc b">finally runs</code>，因为最初的承诺被拒绝，原因是<code class="fe mz na nb nc b">error</code>。然后运行<code class="fe mz na nb nc b">finally</code>方法回调中的任何代码。</p><p id="7b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用承诺编写异步代码的主要好处是，我们可以使用它们来顺序运行异步代码。为此，我们可以用<code class="fe mz na nb nc b">then</code>函数链接承诺。<code class="fe mz na nb nc b">then</code>函数接受一个回调函数，该函数在承诺兑现时运行。当承诺被拒绝时，还需要第二次辩论。为了链接承诺，我们必须返回另一个承诺作为<code class="fe mz na nb nc b">then</code>函数的第一个回调函数的返回值。它可以返回其他值，比如nothing，如果我们不想将另一个承诺与现有的承诺联系起来的话。我们可以返回一个值，这个值将在下一个<code class="fe mz na nb nc b">then</code>函数中被解析和检索。它还会引发错误。然后由<code class="fe mz na nb nc b">then</code>返回的承诺被拒绝，抛出的错误作为值。它还可以返回一个已经履行或被拒绝的承诺，当一个<code class="fe mz na nb nc b">then</code>函数在它之后被链接时，它将获得履行的值，或者在<code class="fe mz na nb nc b">catch</code>函数的回调中获得一个错误原因。</p><p id="2499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以这样写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bc06" class="nh md it nc b gy ni nj l nk nl">Promise.resolve(1)<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>    return Promise.resolve(2)<br/>  })<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>  })</span><span id="42c6" class="nh md it nc b gy nm nj l nk nl">Promise.resolve(1)<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>    return Promise.reject('error')<br/>  })<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch(error =&gt; console.log(error));</span><span id="8759" class="nh md it nc b gy nm nj l nk nl">Promise.resolve(1)<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>    throw new Error('error');<br/>  })<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch(error =&gt; console.log(error));</span></pre><p id="74b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一个例子中，我们将承诺链接起来，它们都解析为一个值。所有的承诺都已经分解成了价值观。在第二个和最后一个例子中，我们拒绝第二个承诺或者抛出一个错误。他们都做同样的事情。第二个承诺被拒绝，错误原因会被记录在<code class="fe mz na nb nc b">catch</code>函数的回调中。我们还可以链接待定的承诺，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a4b3" class="nh md it nc b gy ni nj l nk nl">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(1), 1000);<br/>});</span><span id="8cc3" class="nh md it nc b gy nm nj l nk nl">const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(2), 1000);<br/>});</span><span id="1746" class="nh md it nc b gy nm nj l nk nl">promise1<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>    return promise2;<br/>  })<br/>  .then(val =&gt; {<br/>    console.log(val);<br/>  })<br/>  .catch(error =&gt; console.log(error));</span></pre><p id="5b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个<code class="fe mz na nb nc b">then</code>函数的回调返回了<code class="fe mz na nb nc b">promise2</code>，这是一个待定承诺。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a68" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">方法</h1><p id="c238" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">JavaScript承诺有以下方法。</p><h2 id="4027" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">Promise.all(可重复)</h2><p id="cca8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接受一个iterable对象，让我们在一些计算机上并行运行多个承诺，在另一些计算机上串行运行。这对于运行多个不依赖于彼此价值观的承诺来说非常方便。它接受一个带有承诺列表的iterable，通常是一个数组，然后返回一个<code class="fe mz na nb nc b">Promise</code>,当iterable中的承诺被解析时，这个值被解析。</p><p id="19d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以编写如下代码来运行带有<code class="fe mz na nb nc b">Promise.all</code>的多个承诺:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="e999" class="nh md it nc b gy ni nj l nk nl">const promise1 = Promise.resolve(1);<br/>const promise2 = 2;<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(3), 1000);<br/>});<br/>Promise.all([promise1, promise2, promise3])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  });</span></pre><p id="a70f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，那么<code class="fe mz na nb nc b">console.log</code>应该记录<code class="fe mz na nb nc b">[1,2,3]</code>。正如我们所看到的，只有在所有承诺都实现后，它才返回一个解析的值。如果它们中的一些被拒绝，那么我们将得不到任何已解析的值。相反，我们将得到被拒绝的承诺返回的任何错误值。它将在第一个被拒绝的承诺处停止，并将该值发送给<code class="fe mz na nb nc b">catch</code>函数的回调。例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="95f5" class="nh md it nc b gy ni nj l nk nl">const promise1 = Promise.resolve(1);<br/>const promise2 = Promise.reject(2);<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; reject(3), 1000);<br/>});<br/>Promise.all([promise1, promise2, promise3])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  })<br/>  .catch(error =&gt; {<br/>    console.log(error);<br/>  });</span></pre><p id="4edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们从<code class="fe mz na nb nc b">catch</code>函数的回调中的<code class="fe mz na nb nc b">console.log</code>得到2。</p><h2 id="1532" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><code class="fe mz na nb nc b">Promise.allSettled</code></h2><p id="9834" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">Promise.allSettled</code>返回一个承诺，该承诺在所有给定承诺被解决或拒绝后解决。它接受一个带有承诺集合的iterable对象，例如，一个承诺数组。返回承诺的解析值是每个承诺最终状态的数组。例如，假设我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c907" class="nh md it nc b gy ni nj l nk nl">const promise1 = Promise.resolve(1);<br/>const promise2 = Promise.reject(2);<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; reject(3), 1000);<br/>});<br/>Promise.allSettled([promise1, promise2, promise3])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  })</span></pre><p id="3d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，那么我们会得到一个包含三个条目的数组，每个条目都是一个对象，它具有已履行承诺的<code class="fe mz na nb nc b">status</code>和<code class="fe mz na nb nc b">value</code>属性，以及一个对象，它具有被拒绝承诺的<code class="fe mz na nb nc b">status</code>和<code class="fe mz na nb nc b">reason</code>属性。比如上面的代码会记录<code class="fe mz na nb nc b">{status: “fulfilled”, value: 1}</code>、<code class="fe mz na nb nc b">{status: “rejected”, reason: 2}</code>、<code class="fe mz na nb nc b">{status: “rejected”, reason: 3}</code>。成功承诺记录<code class="fe mz na nb nc b">fulfilled</code>状态，拒绝承诺记录<code class="fe mz na nb nc b">rejected</code>状态。</p><h2 id="750c" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><code class="fe mz na nb nc b">Promise.race</code></h2><p id="4b4e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">Promise.race</code>方法返回一个承诺，该承诺解析为首先实现的承诺的解析值。它接受一个带有承诺集合的iterable对象，例如，一个承诺数组。如果传入的iterable为空，那么返回的承诺将永远处于待定状态。如果iterable对象包含一个或多个非承诺值或已经完成的承诺，那么<code class="fe mz na nb nc b">Promise.race</code>将返回到这些条目中的第一个。例如，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5519" class="nh md it nc b gy ni nj l nk nl">const promise1 = Promise.resolve(1);<br/>const promise2 = Promise.resolve(2);<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(3), 1000);<br/>});<br/>Promise.race([promise1, promise2, promise3])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  })</span></pre><p id="b6b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们看到<code class="fe mz na nb nc b">1</code>被记录。这是因为<code class="fe mz na nb nc b">promise1</code>是第一个被解决的问题，因为它在下一行运行之前就被解决了。同样，如果我们在数组中有一个非承诺值作为参数传入，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ef20" class="nh md it nc b gy ni nj l nk nl">const promise1 = 1;<br/>const promise2 = Promise.resolve(2);<br/>const promise3 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(3), 1000);<br/>});<br/>Promise.race([promise1, promise2, promise3])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  })</span></pre><p id="cd78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到同样的记录，因为我们传递给<code class="fe mz na nb nc b">Promise.race</code>方法的是数组中的非承诺值。同步代码总是在异步代码之前运行，所以同步代码在哪里并不重要。如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="4c5d" class="nh md it nc b gy ni nj l nk nl">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(1), 2000);<br/>});</span><span id="cc8c" class="nh md it nc b gy nm nj l nk nl">const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(2), 1000);<br/>});</span><span id="b81f" class="nh md it nc b gy nm nj l nk nl">const promise3 = 3;<br/>Promise.race([promise1, promise2, promise3])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  })</span></pre><p id="968c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录了<code class="fe mz na nb nc b">3</code>,因为<code class="fe mz na nb nc b">setTimeout</code>将回调函数放在队列中稍后运行，所以它将比同步代码晚运行。</p><p id="c1d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，如果我们有:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="b8db" class="nh md it nc b gy ni nj l nk nl">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(1), 2000);<br/>});<br/>const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(2), 1000);<br/>});</span><span id="8a9e" class="nh md it nc b gy nm nj l nk nl">Promise.race([promise1, promise2])<br/>  .then((values) =&gt; {<br/>    console.log(values);<br/>  })</span></pre><p id="1940" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们在控制台日志中得到<code class="fe mz na nb nc b">2</code>，因为一秒钟内解决的承诺将比两秒钟内解决的承诺更早解决。</p><h2 id="999d" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><code class="fe mz na nb nc b">Promise.reject</code></h2><p id="bb8f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">返回一个被拒绝的承诺。用一个作为<code class="fe mz na nb nc b">Error</code>实例的对象来拒绝一个承诺是很有用的。例如，如果我们有以下代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="7481" class="nh md it nc b gy ni nj l nk nl">Promise.reject(new Error('rejected'))<br/>  .then((value) =&gt; {<br/>    console.log(value);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })</span></pre><p id="69e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe mz na nb nc b">rejected</code>日志。</p><h2 id="b24a" class="nh md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated"><code class="fe mz na nb nc b">Promise.resolve</code></h2><p id="d929" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">Promise.resolve</code>返回一个承诺，该承诺被解析为传递给<code class="fe mz na nb nc b">resolve</code>函数的参数的值。我们也可以传入一个带有<code class="fe mz na nb nc b">then</code>属性的对象，它的值是一个承诺的回调函数。如果值有一个<code class="fe mz na nb nc b">then</code>方法，那么承诺将由<code class="fe mz na nb nc b">then</code>函数实现的值来实现。也就是说，<code class="fe mz na nb nc b">then</code>函数的值的函数的第一个参数与<code class="fe mz na nb nc b">resolve</code>相同，第二个参数与<code class="fe mz na nb nc b">reject.</code>相同。例如，我们可以这样写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9d86" class="nh md it nc b gy ni nj l nk nl">Promise.resolve(1)<br/>  .then((value) =&gt; {<br/>    console.log(value);<br/>  })</span></pre><p id="0040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录了<code class="fe mz na nb nc b">1</code>,因为<code class="fe mz na nb nc b">1</code>是我们传递给<code class="fe mz na nb nc b">resolve</code>函数的值，用来返回带有解析值<code class="fe mz na nb nc b">1</code>的承诺。</p><p id="4b91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们传入一个带有<code class="fe mz na nb nc b">then</code>方法的对象，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="abeb" class="nh md it nc b gy ni nj l nk nl">Promise.resolve({<br/>    then(resolve, reject) {<br/>      resolve(1);<br/>    }<br/>  })<br/>  .then((value) =&gt; {<br/>    console.log(value);<br/>  })</span></pre><p id="8cba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们记录值<code class="fe mz na nb nc b">1</code>。这是因为<code class="fe mz na nb nc b">Promise.resolve</code>函数将运行<code class="fe mz na nb nc b">then</code>函数，并且设置为<code class="fe mz na nb nc b">then</code>属性的函数的<code class="fe mz na nb nc b">resolve</code>参数将被假定为一个像promise中的<code class="fe mz na nb nc b">resolve</code>函数那样被调用的函数。如果我们改为调用传入对象中的<code class="fe mz na nb nc b">then</code>函数内的<code class="fe mz na nb nc b">reject</code>函数，那么我们会得到一个被拒绝的承诺，如下面的代码所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="ab94" class="nh md it nc b gy ni nj l nk nl">Promise.resolve({<br/>    then(resolve, reject) {<br/>      reject('error');<br/>    }<br/>  })<br/>  .then((value) =&gt; {<br/>    console.log(value);<br/>  })<br/>  .catch((error) =&gt; {<br/>    console.log(error);<br/>  })</span></pre><p id="4aef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，由于承诺被拒绝，我们记录了<code class="fe mz na nb nc b">error</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4482" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">异步和等待</h1><p id="add5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>，我们可以缩短承诺代码。在<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>之前，我们必须使用<code class="fe mz na nb nc b">then</code>函数，我们必须将回调函数作为所有<code class="fe mz na nb nc b">then</code>函数的参数。这使得代码很长，因为我们有很多承诺。相反，我们可以使用<code class="fe mz na nb nc b">async</code>和<code class="fe mz na nb nc b">await</code>语法来替换<code class="fe mz na nb nc b">then</code>函数及其相关的回调函数。例如，我们可以缩短以下代码:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="9012" class="nh md it nc b gy ni nj l nk nl">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(1), 2000);<br/>});</span><span id="ffe7" class="nh md it nc b gy nm nj l nk nl">const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(2), 1000);<br/>});</span><span id="e250" class="nh md it nc b gy nm nj l nk nl">promise1<br/>  .then((val1) =&gt; {<br/>    console.log(val1);<br/>    return promise2;<br/>  })<br/>  .then((val2) =&gt; {<br/>    console.log(val2);<br/>  })</span></pre><p id="9e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">收件人:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="bfe0" class="nh md it nc b gy ni nj l nk nl">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(1), 2000);<br/>});<br/>const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(2), 1000);<br/>});</span><span id="68d6" class="nh md it nc b gy nm nj l nk nl">(async () =&gt; {<br/>  const val1 = await promise1;<br/>  console.log(val1)<br/>  const val2 = await promise2;<br/>  console.log(val2)<br/>})()</span></pre><p id="08b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe mz na nb nc b">await</code>替换了<code class="fe mz na nb nc b">then</code>和回调。然后，我们可以将每个承诺的解析值指定为变量。注意，如果我们使用<code class="fe mz na nb nc b">await</code>作为我们的承诺代码，那么我们必须把<code class="fe mz na nb nc b">async</code>放在函数签名中，就像我们在上面的例子中所做的那样。为了捕捉错误，我们使用了<code class="fe mz na nb nc b">catch</code>子句，而不是在最后链接<code class="fe mz na nb nc b">catch</code>函数。此外，我们在<code class="fe mz na nb nc b">catch</code>子句之后使用<code class="fe mz na nb nc b">finally</code>子句，而不是在底部链接<code class="fe mz na nb nc b">finally</code>函数来运行代码。</p><p id="b365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8a44" class="nh md it nc b gy ni nj l nk nl">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve(1), 2000);<br/>});<br/>const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; reject('error'), 1000);<br/>});</span><span id="29f3" class="nh md it nc b gy nm nj l nk nl">(async () =&gt; {<br/>  try {<br/>    const val1 = await promise1;<br/>    console.log(val1)<br/>    const val2 = await promise2;<br/>    console.log(val2)<br/>  } catch (error) {<br/>    console.log(error)<br/>  } finally {<br/>    console.log('finally runs');<br/>  }</span><span id="e1d0" class="nh md it nc b gy nm nj l nk nl">})()</span></pre><p id="4936" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们获得了分配给变量的承诺的解析值，而不是在<code class="fe mz na nb nc b">then</code>函数的回调中获得值，就像上面的<code class="fe mz na nb nc b">const response = await promise1</code>行一样。此外，我们使用了<code class="fe mz na nb nc b">try...catch...finally</code>块来捕捉被拒绝承诺的错误，并使用了<code class="fe mz na nb nc b">finally</code>子句而不是传入回调的<code class="fe mz na nb nc b">finally</code>函数来创建无论承诺发生什么情况都运行的代码。</p><p id="4d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像其他任何使用承诺的函数一样，<code class="fe mz na nb nc b">async</code>函数总是返回承诺，不能返回其他任何东西。在上面的例子中，我们展示了我们可以用比使用回调作为参数传入的<code class="fe mz na nb nc b">then</code>函数更短的方式来链接承诺。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eb61" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述</h1><p id="ac9b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有了承诺，我们可以轻松地编写异步代码。承诺是代表一个过程的对象，该过程运行的时间不确定，并且可能导致成功或失败。为了在JavaScript中创建承诺，我们使用了一个<code class="fe mz na nb nc b">Promise</code>对象，它是创建承诺的构造函数。</p><p id="f8fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">Promise</code>构造函数采用一个名为executor函数的函数，该函数有<code class="fe mz na nb nc b">resolve</code>和<code class="fe mz na nb nc b">reject</code>参数。这两个参数都是我们调用的函数，要么履行承诺(这意味着用某个值成功地结束它)，要么拒绝承诺(这意味着返回某个错误值并将承诺标记为失败)。函数的返回值被忽略。所以，承诺不能回报承诺之外的任何东西。</p><p id="5652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">承诺是有约束力的，因为承诺会回报承诺。promises的<code class="fe mz na nb nc b">then</code>函数可以抛出一个错误，返回已解析的值，或者返回其他待定、已履行或被拒绝的承诺。</p></div></div>    
</body>
</html>