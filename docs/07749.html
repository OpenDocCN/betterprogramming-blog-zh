<html>
<head>
<title>3 Special Methods for Object String Formatting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中对象字符串格式化的3种特殊方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/3-special-methods-for-object-string-formatting-in-python-c020150d624c?source=collection_archive---------12-----------------------#2021-02-15">https://betterprogramming.pub/3-special-methods-for-object-string-formatting-in-python-c020150d624c?source=collection_archive---------12-----------------------#2021-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6f81" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以用户友好的方式格式化Python定制对象</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ffe9c4331f6bec02db3c204f33048b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*93dGpXMhUlS3Ttnk"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科林·阿姆斯特朗在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Python中，下划线在属性名中使用时具有特殊的含义。一种特殊的形式是使用两对双下划线，一个在属性名之前，另一个在属性名之后，这被称为特殊方法或魔术方法。</p><p id="8176" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们大多数人知道的第一个特殊方法可能是初始化方法<code class="fe lv lw lx ly b">__init__</code>，它用于创建Python对象。以下代码向您展示了一个示例:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="e373" class="md me it ly b gy mf mg l mh mi">class Student:<br/>    def __init__(self, name):<br/>        self.name = name</span></pre><p id="2cc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建该类的实例对象时，只需在交互式控制台中键入对象变量，即可检查该对象:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="23fb" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; student0 = Student("John Smith")<br/>&gt;&gt;&gt; student0<br/>&lt;__main__.Student at 0x11883aa60&gt;</span></pre><p id="1a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这个对象的信息并不十分有趣，它仅仅显示了它的类和它的内存地址。为了更有趣，我们应该考虑自定义类的字符串格式化方法。具体来说，我们将在本文中讨论三种特殊的方法。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="27df" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">__repr__方法</h1><p id="f5b9" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated"><code class="fe lv lw lx ly b">__repr__</code>方法与对象的表示有关。如上所示，Python对象在交互式控制台中打印出它的表示字符串。以下代码揭示了这一特性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重写repr()方法</p></figure><p id="43d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，我们应该为<code class="fe lv lw lx ly b">__repr__</code>特殊方法返回一个字符串。如果返回一个非字符串，会遇到一个<code class="fe lv lw lx ly b">TypeError</code>，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/08d1e782e22e8a5327e46dfd4e7cae11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*yVZOh1NlNu7RSYIof1xgIg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非字符串的TypeError</p></figure><p id="fc25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，突出的问题是我们应该为对象返回什么字符串？根据经验，我们应该返回一个字符串，用户可以使用它来重新构造对象(例如，创建一个与被检查对象具有相同值的对象)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">覆盖__repr__</p></figure><p id="d338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用更新后的代码，我们可以在交互式控制台中检查对象，如下所示。如您所见，表示字符串是一个有效的Python表达式，使用它我们可以创建一个<code class="fe lv lw lx ly b">Student</code>对象:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="f722" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; student0 = Student("John Smith")<br/>&gt;&gt;&gt; student0<br/>Student('John Smith')</span></pre><p id="2c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们可以使用内置的<code class="fe lv lw lx ly b">repr()</code>方法来检索表示字符串。与此相关，人们可能希望通过将字符串表示发送到内置的<code class="fe lv lw lx ly b">eval()</code>函数来重新构造另一个对象:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="000b" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; student1 = eval(repr(student0))<br/>&gt;&gt;&gt; student1<br/>Student('John Smith')</span></pre><p id="c2d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顺便提一下，我们使用f-string来内插对象的属性，并使用<code class="fe lv lw lx ly b">!r</code>来指定我们想要字符串的原始表示，因为默认情况下f-string将调用<code class="fe lv lw lx ly b">__str__</code>方法来检索内插变量的值。在这种情况下，省略<code class="fe lv lw lx ly b">!r</code>将使字符串本身代替引号内的字符串。考虑下面的代码作为一个简单的例子——显然，后一个字符串不能用来创建一个<code class="fe lv lw lx ly b">Student</code>对象:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="d437" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; name = "John Smith"<br/>&gt;&gt;&gt; print(f"Student({name!r})")<br/>Student('John Smith')<br/>&gt;&gt;&gt; print(f"Student({name})")<br/>Student(John Smith)</span></pre><p id="577c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要注意的事情是，有时提供一个允许对象重建的有意义的字符串是不实际的。在这种情况下，我们通常使用<code class="fe lv lw lx ly b">&lt;&gt;</code>来封装实例的类和一些摘要信息。下面的代码向您展示了内置类的示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些内置类的表示</p></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="bc23" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">__str__方法</h1><p id="3fc9" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">另一个与对象格式化相关的有趣的特殊方法是<code class="fe lv lw lx ly b">__str__</code>方法。下面的代码向您展示了如何在自定义类中重写它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">覆盖__str__</p></figure><p id="e04a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于修改后的类，让我们看看它何时被调用。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="1e7c" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; print(student0)<br/>__str__ is called<br/>&gt;&gt;&gt; str(student0)<br/>'__str__ is called'<br/>&gt;&gt;&gt; f"{student0}"<br/>'__str__ is called'</span></pre><p id="1633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，至少有三种情况会导致调用<code class="fe lv lw lx ly b">__str__</code>特殊方法。具体来说，<code class="fe lv lw lx ly b">print()</code>函数、<code class="fe lv lw lx ly b">str()</code>函数(这是意料之中的，因为它只是一个语法糖)和f字符串插值变量都将调用对象的底层<code class="fe lv lw lx ly b">__str__</code>方法。</p><p id="ece0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我们知道使用<code class="fe lv lw lx ly b">__str__</code>方法的情况，但问题是实现该方法的最佳实践是什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">__str__的正确实施</p></figure><ul class=""><li id="9e14" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">对于如何定义从<code class="fe lv lw lx ly b">__str__</code>方法返回的字符串，没有通用的方法。</li><li id="3385" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">原则是我们应该返回一些关于实例对象的描述。在大多数情况下，我们只提供实例对象的属性。</li></ul><p id="dca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这几点，需要注意的是，如果你的类没有定义<code class="fe lv lw lx ly b">__str__</code>方法，Python会寻找<code class="fe lv lw lx ly b">__repr__</code>是否实现。如果是的话，任何调用<code class="fe lv lw lx ly b">__str__</code>的东西都会转而调用<code class="fe lv lw lx ly b">__repr__</code>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="a3f5" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">__format__方法</h1><p id="9e2b" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">与对象字符串格式化相关的另一个重要的特殊方法是<code class="fe lv lw lx ly b">__format__</code>方法。下面的代码显示了自定义类中此方法的签名:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">覆盖__format__</p></figure><p id="a117" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们之前所做的那样，让我们首先看看调用该方法的常见情况:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="2db9" class="md me it ly b gy mf mg l mh mi">&gt;&gt;&gt; student0 = Student("John Smith")<br/>&gt;&gt;&gt; f"{student0}"<br/>'__format__ is called'<br/>&gt;&gt;&gt; format(student0)<br/>'__format__ is called'<br/>&gt;&gt;&gt; print(student0)<br/>&lt;__main__.Student object at 0x114a92c10&gt;<br/>&gt;&gt;&gt; str(student0)<br/>'&lt;__main__.Student object at 0x114a92c10&gt;'</span></pre><p id="5c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">f字符串和内置的<code class="fe lv lw lx ly b">format()</code>方法都可以调用<code class="fe lv lw lx ly b">__format__</code>方法。让我们以f弦为例向你展示<code class="fe lv lw lx ly b">__format__</code>是如何运作的。</p><p id="d8c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能会注意到，与<code class="fe lv lw lx ly b">__repr__</code>和<code class="fe lv lw lx ly b">__str__</code>方法不同，<code class="fe lv lw lx ly b">__format__</code>方法有一个名为<code class="fe lv lw lx ly b">format_spec</code>的附加参数。此参数定义如何将对象格式化为字符串。让我们看看下面代码片段中的一些自定义规范:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自定义格式</p></figure><ul class=""><li id="25c7" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated">我们定义了两个自定义规范。当规格为<code class="fe lv lw lx ly b">i</code>，代表首字母时，我们返回学生的首字母。</li><li id="dbd4" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">另一个规范是<code class="fe lv lw lx ly b">C</code>，代表大写，我们返回学生名字的大写形式。</li><li id="2c22" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">除了这两个规范，我们还为适用的字符串格式指定了默认的内置格式。</li><li id="da11" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated">回想一下，当我们使用f-string时，我们在冒号后指定格式要求。在我们的例子中，当我们指定规范为<code class="fe lv lw lx ly b">i</code>和<code class="fe lv lw lx ly b">C</code>时，我们确实得到了想要的格式。</li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9598" class="mq me it bd mr ms mt mu mv mw mx my mz jz na ka nb kc nc kd nd kf ne kg nf ng bi translated">结论</h1><p id="52fc" class="pw-post-body-paragraph kz la it lb b lc nh ju le lf ni jx lh li nj lk ll lm nk lo lp lq nl ls lt lu im bi translated">在本文中，我们回顾了Python中三种基本的特殊格式化方法。这里有一个快速回顾。</p><ul class=""><li id="c19c" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">__repr__</code>方法显示一个字符串表示，只要有可能，它就是一个有效的Python表达式，可以用来创建一个类似的对象。当不适用时，考虑使用“<code class="fe lv lw lx ly b">&lt;&gt;</code>”来提供课程信息和其他有意义的功能。</li><li id="3bde" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">__str__</code>方法是提供对象的描述信息。</li><li id="caad" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe lv lw lx ly b">__format__</code>方法是提供基本格式规范之外的自定义格式规范。如果您希望您的对象对于不同的用例有不同的字符串表示，这可能会很有帮助。</li></ul></div></div>    
</body>
</html>