<html>
<head>
<title>10 Python and R Tricks for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据科学家的10个Python和R技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-tips-and-tricks-for-data-scientists-vol-4-76b0b732a94f?source=collection_archive---------2-----------------------#2021-04-04">https://betterprogramming.pub/10-tips-and-tricks-for-data-scientists-vol-4-76b0b732a94f?source=collection_archive---------2-----------------------#2021-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b907" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Pandas中输入缺失值，用mode替换分类变量，等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/03f86aaec8d2ccedf4a56a0d6ee4a776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oTozi4OMFpuYySQ3"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@amadejtauses?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿马德·陶塞斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><div class="kz la gp gr lb lc"><a href="https://jorgepit-14189.medium.com/membership" rel="noopener follow" target="_blank"><div class="ld ab fo"><div class="le ab lf cl cj lg"><h2 class="bd iu gy z fp lh fr fs li fu fw is bi translated">用我的推荐链接加入媒体-乔治皮皮斯</h2><div class="lj l"><h3 class="bd b gy z fp lh fr fs li fu fw dk translated">阅读乔治·皮皮斯(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="lk l"><p class="bd b dl z fp lh fr fs li fu fw dk translated">jorgepit-14189.medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq ks lc"/></div></div></a></div><p id="8503" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们已经开始为数据科学家撰写一系列关于技巧和诀窍的文章，主要是用Python和r编写的。(如果你错过了，这里有<a class="ae ky" href="https://predictivehacks.com/10-tips-and-tricks-for-data-scientists-vol-1/" rel="noopener ugc nofollow" target="_blank">第1卷</a>、<a class="ae ky" href="https://predictivehacks.com/10-tips-and-tricks-for-data-scientists-vol-2/" rel="noopener ugc nofollow" target="_blank">第2卷</a>和<a class="ae ky" href="https://predictivehacks.com/10-tips-and-tricks-for-data-scientists-vol-3/" rel="noopener ugc nofollow" target="_blank">第3卷</a>。)</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="dc95" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">计算机编程语言</h1><h2 id="4acf" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">1.如何将数据从Google Drive导入Colab</h2><p id="9f35" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated"><a class="ae ky" href="https://colab.research.google.com/notebooks/intro.ipynb" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>在数据科学社区中越来越受欢迎。使用<a class="ae ky" href="https://colab.research.google.com/github/BetoBob/NLTK-Book-Resource/blob/master/setup.ipynb" rel="noopener ugc nofollow" target="_blank"> Colab Jupyter笔记本</a>，你可以安装你的Google Drive，这样你就可以直接从中获取数据。让我们看看你怎么做。您应该打开笔记本，键入以下命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b2a38f6b7ae093af43ac0756c476e760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/0*eLG2SqBW5GzPdB2g.png"/></div></figure><p id="5840" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">它会向您发送一个链接，通过输入令牌来授权您的Google Drive，您就完成了。然后你会在你的文件下看到一个名为<code class="fe oe of og oh b">gdrive</code>的文件夹:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/663925dc1e6d0ae72a1b1167e11a48d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SFTpiMSEwzCnZJJP.png"/></div></div></figure><p id="234e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，如果你想得到文件的确切路径，你可以右击并选择“复制路径”，它通常以<code class="fe oe of og oh b">/content/gdrive/MyDrive/</code>开始。</p><h2 id="c7e7" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">2.如何估算熊猫的缺失值</h2><p id="8948" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">我们将提供一个示例，说明如何按照以下规则估算<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>中的缺失值:</p><ul class=""><li id="e0ba" class="oj ok it lt b lu lv lx ly ma ol me om mi on mm oo op oq or bi translated">如果变量是数字，则用平均值估算缺失值。</li><li id="0b3a" class="oj ok it lt b lu os lx ot ma ou me ov mi ow mm oo op oq or bi translated">如果变量为<code class="fe oe of og oh b">object</code> <code class="fe oe of og oh b">dtype</code>，则用模式对缺失值进行插补。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/42686a6808430674ce4a443261d82fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/0*efwrlr4xN3PkQaBn.png"/></div></figure><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="1441" class="nm mv it oh b gy pe pf l pg ph">for i in df.columns:<br/>    if (df[i].dtype=='object'):<br/>        df[i].fillna(df[i].mode()[0], inplace=True)<br/>    elif (df[i].dtype=='float64' or df[i].dtype=='int64'):<br/>        df[i].fillna(df[i].mean(), inplace=True)<br/> <br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/73f32a1ded156d33581906f32d3dc0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/0*q1Nacw--t6kRU-nm.png"/></div></figure><h2 id="9466" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">3.如何用熊猫读写gzip/zip文件</h2><p id="3503" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">我们可以把熊猫数据框写成gzip和zip文件。例如:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="a545" class="nm mv it oh b gy pe pf l pg ph">#lets use this sample dataframe<br/>df=pd.DataFrame({'A':[1,2,3,4]})</span></pre><p id="c294" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">保存为gzip或者zip </strong></p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="10d2" class="nm mv it oh b gy pe pf l pg ph"># save it as gzip<br/>df.to_csv("dataframe.csv.gz", index=False, compression="gzip")</span><span id="eb76" class="nm mv it oh b gy pj pf l pg ph"># save it as gzip<br/>df.to_csv("dataframe.csv.zip", index=False, compression="zip")</span></pre><p id="32a1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">用熊猫读取gzip/zip文件</strong></p><p id="a49a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">熊猫也可以阅读包含CSV的gzip/zip文件。</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="d084" class="nm mv it oh b gy pe pf l pg ph">pd.read_csv('dataframe.csv.gz')</span></pre><h2 id="dbc7" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">4.如何用熊猫读写不带头文件的CSV文件</h2><p id="ec1d" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated"><strong class="lt iu">无标题阅读</strong></p><p id="af13" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">假设您有以下不带列名的CSV文件。让我们看看如何用熊猫来阅读它。假设<code class="fe oe of og oh b">my_file.csv</code>是:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="330e" class="nm mv it oh b gy pe pf l pg ph">George,25 <br/>Maria,30 <br/>John,18</span></pre><p id="3efd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以如下阅读该文件:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="8e51" class="nm mv it oh b gy pe pf l pg ph">import pandas as pd <br/>df = pd.read_csv("my_file.csv", header=None) <br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/291c7b7c9aa5d3ee8e42059a468dd86a.png" data-original-src="https://miro.medium.com/v2/resize:fit:458/format:webp/0*e8NDeTP1hsjq1ohT.png"/></div></figure><p id="a27e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们想为我们的列名指定特定的名称:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="1188" class="nm mv it oh b gy pe pf l pg ph">df1 = pd.read_csv("my_file.csv", header=None, names=['colA', 'colB']) <br/>df1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/ab1ab397e9cb72123edbd208946f97dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/0*OWv2cVAeHPsc5SOD.png"/></div></figure><p id="134a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">无标题写入</strong></p><p id="7225" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，假设我们想将这个数据帧写入一个CSV文件，但是没有头。</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="4442" class="nm mv it oh b gy pe pf l pg ph">df.to_csv('filename.csv', header=False, index=False)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/79c805cf520f43dfb31bbf4e998f7dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/0*UK6AwPa2UyBmHR-l.png"/></div></figure><p id="4ca3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以看到，<code class="fe oe of og oh b">filename.csv</code>是没有头的。</p><h2 id="c904" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">5.Python中不同值的累积计数</h2><p id="1c98" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">有时需要对列表/向量的不同值进行滚动计数。换句话说，我们只想添加列表/向量中出现的任何新元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="3b7e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">输出</strong></p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="c127" class="nm mv it oh b gy pe pf l pg ph">mylist  CumDistinct<br/>0      e            1<br/>1      a            2<br/>2      a            2<br/>3      b            3<br/>4      a            3<br/>5      b            3<br/>6      c            4<br/>7      d            5<br/>8      e            5</span></pre><h2 id="d864" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">6.Python中连续事件的计数</h2><p id="c0b4" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">我们将展示一个简单实用的例子，说明如何对连续事件进行计数:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="68db" class="nm mv it oh b gy pe pf l pg ph">import pandas as pd</span><span id="c900" class="nm mv it oh b gy pj pf l pg ph">df = pd.DataFrame({'Score':['win', 'loss', 'loss', 'loss', 'win', 'win', 'win', 'win', 'win', 'loss', 'win', 'loss', 'loss']})</span></pre><p id="5d7c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">通过下面的代码，我们将得到Streak的列:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="0c13" class="nm mv it oh b gy pe pf l pg ph">df['Streak'] = df['Score'].groupby((df['Score'] != df['Score'].shift()).cumsum()).cumcount() + 1 </span><span id="75d0" class="nm mv it oh b gy pj pf l pg ph">df</span></pre><p id="91cf" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">输出</strong></p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="b6b2" class="nm mv it oh b gy pe pf l pg ph">Score  Streak<br/>0    win       1<br/>1   loss       1<br/>2   loss       2<br/>3   loss       3<br/>4    win       1<br/>5    win       2<br/>6    win       3<br/>7    win       4<br/>8    win       5<br/>9   loss       1<br/>10   win       1<br/>11  loss       1<br/>12  loss       2</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d6c5" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">稀有</h1><h2 id="8189" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">7.R中不同值累积计数</h2><p id="3838" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">有时需要对列表/向量的不同值进行滚动计数。换句话说，我们只想添加列表/向量中出现的任何新元素。</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="fec3" class="nm mv it oh b gy pe pf l pg ph"># assume that this is our vector<br/>x=c("e", "a","a","b","a","b","c", "d", "e")<br/> <br/># we apply the "cumsum(!duplicated(x))" command<br/>data.frame(Vector=x,<br/>CumDistinct=cumsum(!duplicated(x)))</span></pre><p id="0c0a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">输出</strong></p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="7285" class="nm mv it oh b gy pe pf l pg ph">Vector CumDistinct<br/>1      e           1<br/>2      a           2<br/>3      a           2<br/>4      b           3<br/>5      a           3<br/>6      b           3<br/>7      c           4<br/>8      d           5<br/>9      e           5</span></pre><h2 id="fad8" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">8.计数R中的连续事件</h2><p id="b552" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">假设有一个轮盘赌，返回红色(50%)和黑色(50%)。我们将模拟N=1，000，000卷，并分别记录红色和黑色条纹。使我们的生活变得更容易的R函数是<a class="ae ky" href="https://www.rdocumentation.org/packages/base/versions/3.5.3/topics/rle" rel="noopener ugc nofollow" target="_blank"> rle </a>，但是如果我们想要跟踪跑步记录，那么我们还需要使用seq<strong class="lt iu">T17】函数。我们还添加了另一个列，称为<code class="fe oe of og oh b">EndOfStreak</code> <strong class="lt iu"> </strong>，它指示连续条纹是否已经结束。</strong></p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="3646" class="nm mv it oh b gy pe pf l pg ph">library(tidyverse)<br/> <br/># number of simulations<br/>n&lt;-1000000<br/> <br/># set a random seed for reproducibility<br/>set.seed(5)<br/> <br/># create the data frame<br/>df&lt;-tibble(Rolls=seq(1:n), Outcome=sample(c("Red", "Black"),n,replace = TRUE, prob = c(0.5,0.5)))%&gt;%<br/>  mutate(Streak=sequence(rle(Outcome)$lengths), EndOfStreak=ifelse(lead(Outcome)==Outcome, "No", "Yes"))<br/> <br/>df%&gt;%print(n=20)</span></pre><p id="0031" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><strong class="lt iu">输出</strong></p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="aa38" class="nm mv it oh b gy pe pf l pg ph"># A tibble: 1,000,000 x 4<br/>   Rolls Outcome Streak EndOfStreak<br/>   &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;      <br/> 1     1 Black        1 Yes        <br/> 2     2 Red          1 No         <br/> 3     3 Red          2 Yes        <br/> 4     4 Black        1 No         <br/> 5     5 Black        2 Yes        <br/> 6     6 Red          1 No         <br/> 7     7 Red          2 No         <br/> 8     8 Red          3 No         <br/> 9     9 Red          4 Yes        <br/>10    10 Black        1 No         <br/>11    11 Black        2 No         <br/>12    12 Black        3 No         <br/>13    13 Black        4 Yes        <br/>14    14 Red          1 Yes        <br/>15    15 Black        1 No         <br/>16    16 Black        2 No         <br/>17    17 Black        3 Yes        <br/>18    18 Red          1 No         <br/>19    19 Red          2 No         <br/>20    20 Red          3 No</span></pre><h2 id="d241" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">9.用平均值替换缺失值</h2><p id="9248" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">假设您正在处理一个带有缺失值的数据框，并且您想要用相应列的平均值替换它们。让我们考虑以下数据帧:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="7fab" class="nm mv it oh b gy pe pf l pg ph">df&lt;-data.frame(id=seq(1,10), ColumnA=c(10,9,8,7,NA,NA,20,15,12,NA), <br/>           ColumnB=factor(c("A","B","A","A","","B","A","B","","A")),<br/>           ColumnC=factor(c("","BB","CC","BB","BB","CC","AA","BB","","AA")),<br/>           ColumnD=c(NA,20,18,22,18,17,19,NA,17,23)<br/>)<br/> <br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/943fce467e2dae2cb2d3597bce30b963.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/0*pawWBhJFVzuKW45A.png"/></div></figure><p id="7d17" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">显然，我们只想考虑数值变量。让我们看看如何在一行代码中实现它。</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="6cea" class="nm mv it oh b gy pe pf l pg ph">df[sapply(df, is.numeric)] &lt;- lapply(df[sapply(df, is.numeric)], function(x) ifelse(is.na(x), mean(x, na.rm = TRUE), x))</span><span id="7333" class="nm mv it oh b gy pj pf l pg ph">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi po"><img src="../Images/6a3c15a7d15db3b76fa4f501d9a4b164.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/0*TMw3aSjmpPWYXUat.png"/></div></figure><h2 id="7c28" class="nm mv it bd mw nn no dn na np nq dp ne ma nr ns ng me nt nu ni mi nv nw nk nx bi translated">10.用模式替换分类变量</h2><p id="1d9f" class="pw-post-body-paragraph lr ls it lt b lu ny ju lw lx nz jx lz ma oa mc md me ob mg mh mi oc mk ml mm im bi translated">在数据科学项目中，通常用模式替换分类变量的缺失值。让我们看下面的例子:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="e53c" class="nm mv it oh b gy pe pf l pg ph">df&lt;-data.frame(id=seq(1,10), ColumnA=c(10,9,8,7,NA,NA,20,15,12,NA), <br/>           ColumnB=c("A","B","A","A","","B","A","B","","A"),<br/>           ColumnC=c("","BB","CC","BB","BB","CC","AA","BB","","AA"),<br/>           ColumnD=c(NA,20,18,22,18,17,19,NA,17,23)<br/>)<br/> <br/>df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/aa9bb65bdf5e3b1eac9f6a82158e962c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/0*PHTftE1ZPLXeDC4t.png"/></div></figure><p id="e488" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">注意B列和C列是<code class="fe oe of og oh b">Character</code>列。还要注意，r中没有模式函数，所以让我们来构建它:</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="c822" class="nm mv it oh b gy pe pf l pg ph">getmode &lt;- function(v){<br/>  v=v[nchar(as.character(v))&gt;0]<br/>  uniqv &lt;- unique(v)<br/>  uniqv[which.max(tabulate(match(v, uniqv)))]<br/>}</span></pre><p id="946b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在让我们将所有的<code class="fe oe of og oh b">Character</code>变量的空字符串替换为它们对应的列模式。最后，我们应该将<code class="fe oe of og oh b">character</code>变量转换成<code class="fe oe of og oh b">factors</code>。</p><pre class="kj kk kl km gt pa oh pb pc aw pd bi"><span id="e144" class="nm mv it oh b gy pe pf l pg ph">df[sapply(df, is.character)] &lt;- lapply(df[sapply(df, is.character)], function(x) ifelse(x=="", getmode(x), x))<br/>df[sapply(df, is.character)] &lt;- lapply(df[sapply(df, is.character)], as.factor)</span><span id="9d19" class="nm mv it oh b gy pj pf l pg ph">df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/753444bdf204aa3896865042f89c0e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/0*7382ztriFF24PJha.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/81cc909e495b19ac634c9a71c14bc437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cTg7hmQUULDrE7Ku.png"/></div></div></figure><p id="9f6a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如我们所看到的，我们用相应的模式替换了空字符串。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="6007" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><em class="pr">最初发表于</em><a class="ae ky" href="https://predictivehacks.com/10-tips-and-tricks-for-data-scientists-vol-4/" rel="noopener ugc nofollow" target="_blank"><em class="pr"/></a><em class="pr">。</em></p></div></div>    
</body>
</html>