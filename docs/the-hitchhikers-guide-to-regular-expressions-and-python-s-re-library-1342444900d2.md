# 正则表达式和 Python 的 re 库的指南

> 原文：<https://betterprogramming.pub/the-hitchhikers-guide-to-regular-expressions-and-python-s-re-library-1342444900d2>

## 不要惊慌

![](img/0e9f02cfdc1a410a1f0a1d8f5398e987.png)

我的标题灵感

上周，我发现自己在不知道正则表达式是什么的情况下，试图找到一个字符串中的所有数字，这很难看。正是一行又一行超具体的、重复的陈述伤害了我打字的灵魂。想到一定有更好的方法，我做了任何优秀程序员都会做的事情；我在谷歌上搜索了更好的方法。我在 StackOverflow 上找到了很多简短的回答，都用到了 Python 的 re 库，但是没有一个解释清楚发生了什么。因此，我进行了尽职调查并浏览了文档，结果却发现一篇难以置信的冗长、密集的文章，花去了我全部的精力去解析。我的意思是，这是一篇文章，我引用它的话，“要了解更多信息和更温和的介绍，请参考[正则表达式 HOWTO](https://docs.python.org/3/howto/regex.html#regex-howto) ”如果你翻到那一页，你会发现，在我看来，这是一个同样充满敌意的陈述(或者是温柔的反义词),但是例子稍微多一点！

因此，我希望让这个世界处于一个比我发现时稍微好一点的状态——一个初出茅庐的数据科学家对你需要了解的关于正则表达式和 Python 的 re 库的简单综合。

# 什么是正则表达式？Python 的 re 库是什么？

这个综合有两个部分:正则表达式和 Python 的 re 库。我将它们分开是因为正则表达式是一个跨语言的工具，而 Python 的 re 库是这个工具的一个非常常见的特定于 Python 的实现。

正则表达式可以用数学方法总结(而且很漂亮):它们告诉你一个字符串是否在一个*正则*集合中，其中正则集合被定义为包含可以用正则表达式表达的元素的集合。

换句话说，您可以使用正则表达式来测试字符串是否符合某种格式(比如电子邮件的格式)或者是否包含某种字符序列。

# 正则表达式的基础

这几乎是曾经或将会存在的每一封电子邮件(按照当前的电子邮件法律规定):

```
r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"
```

这个看起来可怕的东西是一个正则表达式，也称为 regex，我希望在本节结束时，我们能够准确地解析它所说的内容。如果您已经熟悉正则表达式，可以跳过这一部分。否则，我们开始吧。

正则表达式使用某些特殊字符和字符分组，例如:

```
.  ^  $  *  +  ?  {m}  {m, n}  \  [...]  |  (...)  \s  \S  \w  \d
```

其中大部分属于三个主要类别之一:字符集、修饰符和锚点。这些分类基本上只是指定您希望正则表达式如何理解您想要的字符串或模式的方法。

我们在本节中的目标是使用每个分类来构建一个匹配字符串`galaxy`的正则表达式。但是，为了进行更多的练习，当你通读这些描述和例子时，你可以拿出例子并用这个网站来测试你自己，我发现这个网站在我刚入门或需要进行理智检查时非常有用。

## 锚告诉正则表达式在哪里寻找匹配

*   `^`将匹配字符串的开头(它也有另外一个意思，不过我们以后再说！).例如，正则表达式`^a`会告诉你`abc`包含一个匹配项或者`aaaaaaaxyz`包含一个匹配项(第一个 *a* 在两者中都是匹配项)。然而，`ba`不是一个匹配，因为它不是以 a 开头的。
*   `$`将匹配字符串的结尾。例如，正则表达式`a$`会告诉你`cba`包含一个匹配项，但“aaaaaaaaah”不包含。

让我们用目前已知的字符构建一个正则表达式:

```
^gy$
```

这将只认为字符串`gy`是匹配的，因为它是唯一以 *g* 开头，以 *y* 结尾的字符串，中间没有其他内容。我们将很快看到如何修改正则表达式，使字符串`galaxy`匹配，但它不是这个正则表达式的匹配。

## 字符集匹配字符，顾名思义

*   `.`将匹配任何字符(除了新行)。例如，正则表达式`a.`会认为`as`匹配，或者`a2`，或者`aq`，或者*是一个*，后面跟有你能想到的任何其他字符。
*   `[a-z]`(或`[abcd]`或`[0-9]`)将匹配括号中指定的任何字符。重要的是，虽然通常我们会想到用逗号列出元素，比如`[1, 2, 3, 4]`，但是正则表达式却识别`[1234]`。你也可以把两个范围串在一起，像`[a-z1-9]`。因此，正则表达式`[A-Z1-4]`会将`A`或`1G3HZ`识别为包含多个匹配，但不识别`z99`(因为它区分大小写)。

现在我们可以在以前的正则表达式的基础上进行构建:

```
^g.[xX]y$
```

这仍然迫使我们的正则表达式只匹配以 e 开头或结尾的字符组，但是现在一个匹配也可以包含任何字符，后跟一个小写字母或大写字母 *x* 。所以，`goXy`是匹配的，`g8xy`也是，甚至还有`g?Xy`等很多例子。我们离`galaxy`越来越近了！

## 修饰语修饰前面字符的含义

*   `*`将匹配前一个字符 0 次或更多次。例如，`ab*`将匹配`a`、`ab`、`abb`等等，因为每个都有 0 个或更多的 b 实例。
*   `+`跟`*`差不多，但是 1 倍或者更多倍。因此，正则表达式`ab+`将匹配`ab`、`abb`、`abbb`等等，但不匹配`a`，因为`b`有 0 个实例。
*   `?`类似于`*`，但是 0 或 1 次，所以正则表达式`ab?`将只匹配`a`或`ab`。
*   `\`有几分熟悉；它转义了特殊字符的含义，比如`*`，所以您也可以匹配这些字符，而不用使用方括号。
*   注:`+`、`?`、`*`的含义在方括号内更改；一般来说，当在括号内时，它们没有特殊的含义，而是代表要匹配的字符本身。在这一节的最后将给出一个例子。要记住的一个例外是`^`，当它被放在方括号内的开头时:这意味着一个集合的补集——所有不是表达式所描述的字符。当它被直接放在方括号内时，就有了这个意思，就像在 regex `[[^abc]a-z]`中一样，它将匹配包含从 d 到 z(小写)范围内的任何字母的任何字符串。

我们可以在以前的正则表达式的基础上更进一步，非常非常接近匹配`galaxy`。

```
^g.[alxX]+y$
```

通过将 *a* 和 *l* 添加到我们的方括号中，我们可以在我们的字符串中使用这些字母，并且在方括号后添加`+`意味着该选择中的至少一个字母必须出现一次或多次。`galaxy`终于匹配了！值得一提的是，`gaallaaxxy`也是匹配的，`goloxy`也是。我们的正则表达式还有改进的空间，下面的工具可以提供帮助。但是，已经达到了我们的主要目标——匹配“银河”——我将把它留给你。

## 要注意的其他字符或组:

*   `{m}`，其中 *m* 是一个整数，将仅精确匹配前面字符的 *m* 个重复。
*   `{m, n}`将匹配尽可能少的 *m 个*和尽可能多的 *n 个*重复，尽可能贪婪(匹配尽可能多的字符串)。
*   `{m, n}?`将匹配少至 *m* 和多至 *n* 的重复，但**并不**贪婪，因此将匹配尽可能少的字符串。
*   `|`用于`or`，这在很多情况下都是正确的，因此您可以从正则表达式 *A* 和 *B* 创建一个新的正则表达式，这样新的正则表达式就可以匹配 *A* 或 *B* ，如下所示:

```
A | B
```

*   `(regex)`会把里面所有的人物当做一个大组或者让你能够检索到某些匹配(或者称为一个捕获组，这有点超出了本文的范围，但是非常酷！).
*   `\d`将匹配所有数字。
*   `\D`将匹配所有非数字。
*   `\s`将匹配所有空白字符(空格、制表符等。).
*   `\S`将匹配所有非空白字符。

还有很多方法可以改变特殊字符的含义来对字符进行分组，但是为了节省时间和保持头脑清醒，我暂时不考虑这些方法。一旦您对这里介绍的内容感到满意，我强烈建议您进一步研究正则表达式符号。

最后，还可以结合正则表达式。一般来说，如果 *A* 和 *B* 是正则表达式， *a* 是 *A* 的匹配项， *b* 是 *B* 的匹配项，那么`AB`(*A*和 *B* 的串联)是正则表达式，`ab`是`AB`的匹配项。

有了我们到目前为止已经学过的符号，以及我们已经学过的关键概念，我们终于可以(付出相当大的努力)分解描述电子邮件的正则表达式了！

```
r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"
```

*   `r"(` … `)”`表示里面有一个正则表达式。
*   `^[a-zA-Z0–9_.+-]+@`表示字母、数字、破折号、加号或下划线的任意组合，+表示这必须出现 1 次或更多次。毕竟，电子邮件必须在 *@* 之前至少有一个字符！开头的克拉(^)只允许以此格式开头的字符串算作有效的电子邮件，因为' ###foo@bar.com '不会是电子邮件。
*   `[a-zA-Z0-9-]+`表示字母数字字符和破折号的任意组合，同样必须在点(*之前至少出现一次。*)。
*   `\.[a-zA-Z0-9-.]+$`通过用反斜杠转义`.`的特殊含义并允许字母数字/虚线域名的任意组合来结束我们的电子邮件，这些组合必须在结尾(用`+`表示)至少出现一次(用`$`表示)。

# Python re 库的基础知识

终于！在这一节中，我们将只讨论库中的一些方法。还有其他的，但是我们将只关注那些你最迫切需要知道的。还有正则表达式对象类型(比如 Match)，我就不深入讨论了，只是让你知道一个方法返回那个类型。除非在同一个文件中反复使用同一个正则表达式，否则在正则表达式中使用正则表达式对象并不比只使用字符串更有效。但是，如您所知，您可能会看到一些文档使用与 regex 对象相关的方法(比如 BeautifulSoup 文档，它经常使用`re.compile([regex])`)。方法上！

*   在传递给它的字符串中查找第一个匹配，并返回一个匹配对象。这个对象将有一个布尔值`true`，您可以将它传递给其他的正则表达式。我可以看到这在一个`if`语句(`if re.search([regex], [string]):`)中非常有用，尤其是如果您想在一个模式中找到一些特定的信息。你甚至可以把 Match 对象变成一个字典！(例如，如果给你一串地址，你想为每一个地址找一本字典，包括第一行、第二行、城市、州、邮政编码等等。)
*   `re.findall()`类似于 re.search，但是会以字符串列表的形式返回所有不重叠的匹配。
*   `re.VERBOSE()`用于编写跨多行注释的正则表达式，以便

```
r"([a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"
```

变得越来越清晰

```
re.VERBOSE([a-zA-Z0-9_.+-]+  # email user-name
           @                 # the @ symbol
           [a-zA-Z0-9-]+     # the domain name
           \.[a-zA-Z0-9-.]+$ # the top-level domain
           )
```

该方法将忽略注释符号(' # ')之后的所有内容，直到行尾，因此您可以随心所欲地进行注释，并帮助其他人解除正则表达式的神秘性(万岁！).(你把它作为一个参数传递给像`re.search()`这样寻找匹配的方法。)

*   `re.MULTILINE()`用于让`^`在多行字符串的每一行的开头工作，而不仅仅是字符串的开头。因此，您可以使用这种方法在每一行的开头查找匹配项，而不必将一个多行字符串分成许多单独的字符串。(类似于`re.VERBOSE`，您将它作为一个参数传递给类似于`re.search()`的方法来寻找匹配。)
*   在这个库中，这可能是我最喜欢的方法。它使得对文本的解析。很多。更简单。例如，如果您正在解析一篇新闻文章，并且您想要使用的所有单词的列表，而不是使用典型的`.split()`方法和一堆`if`语句，那么您可以在 regex `[,:;“”!.*] | \b`上拆分。换句话说，在所有点或空白上分割。它像普通的`str.split()`方法一样返回一个列表。这有多简单？

最后一点:之前，我指定正则表达式可以告诉你一个字符串是否在正则集中。你可能问过自己，“什么是非正则集？”这是一个很好的问题！某些字符串不能写成正则表达式，比如“一系列的 *a* s，后面跟着同样数量的 *b* s，以及一半数量的 *c* s，”要找到这些，你需要一个更强大的工具，叫做上下文无关语法！

编辑:大声对 [@grahamhome333](http://twitter.com/grahamhome333) 说出来，我在解释邮件示例时忘记了第一克拉！