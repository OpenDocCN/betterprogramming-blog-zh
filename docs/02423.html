<html>
<head>
<title>The Comprehensive List of JavaScript String Methods (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript字符串方法的完整列表(第1部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/full-list-of-javascript-string-methods-part-1-ddad113de018?source=collection_archive---------5-----------------------#2019-11-29">https://betterprogramming.pub/full-list-of-javascript-string-methods-part-1-ddad113de018?source=collection_archive---------5-----------------------#2019-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2865" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们看了每一种可以用来操作字符串的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/243180c94f1b94288ac72570be51aee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NTKNOL_-CtnuhRAt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@wx1993?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Raychan </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2a44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串是JavaScript中一个重要的全局对象。它们代表一系列字符。它们可以被各种操作符使用，比如比较操作符，并且有各种方法可以用来操作它们。有不同的方法来操作字符串，在不同的位置查找字符串的各个部分，以及修剪和替换字符串。随着JavaScript规范的每一次发布，都会添加更多的方法来使字符串搜索和操作变得更加容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="2eb3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">静态方法</h1><p id="80d9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">调用静态方法无需创建字符串或对象。有以下几种方法:</p><h2 id="2148" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><code class="fe nl nm nn no b">String.fromCharCode()</code></h2><p id="9bbe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用<code class="fe nl nm nn no b">fromCharCode</code>方法，我们可以构造一个字符串，方法是传入一个以逗号分隔的HTML字符代码列表或十六进制Unicode字符代码作为参数，并获得一个返回实际字符的字符串。例如，我们可以写:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="66ca" class="mz md it no b gy nt nu l nv nw">const str = String.fromCharCode(38, 8226)</span></pre><p id="2cb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们用<code class="fe nl nm nn no b">console.log</code>登录<code class="fe nl nm nn no b">str</code>时，我们得到<code class="fe nl nm nn no b">&amp;•</code>。我们可以传入十六进制字符代码，如下面的代码:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="43ce" class="mz md it no b gy nt nu l nv nw">const str = String.fromCharCode(<!-- -->0x0026<!-- -->, <!-- -->0x2022<!-- -->)</span></pre><p id="0cd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们用<code class="fe nl nm nn no b">console.log</code>记录<code class="fe nl nm nn no b">str</code>时，我们也得到了<code class="fe nl nm nn no b">&amp;•</code>。</p><h2 id="9cd9" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.fromCodePoint()</h2><p id="a15b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">String.fromCodePoint()</code>方法返回一个字符串，该字符串由您在参数中输入的字符代码给出。代码点可以是HTML字符代码或十六进制Unicode字符代码。例如，我们可以写:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="ed93" class="mz md it no b gy nt nu l nv nw">const str = String.fromCodePoint(38, 8226)</span></pre><p id="1b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们用<code class="fe nl nm nn no b">console.log</code>记录<code class="fe nl nm nn no b">str</code>时，我们得到<code class="fe nl nm nn no b">&amp;•</code>。我们可以传入十六进制字符代码，如下面的代码:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="108c" class="mz md it no b gy nt nu l nv nw">const str = String.fromCodePoint(<!-- -->0x0026<!-- -->, <!-- -->0x2022<!-- -->)</span></pre><p id="c704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们用<code class="fe nl nm nn no b">console.log</code>记录<code class="fe nl nm nn no b">str</code>时，我们也得到<code class="fe nl nm nn no b">&amp;•</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="16e2" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实例方法</h1><p id="b485" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">字符串的实例方法在字符串文字或字符串对象上调用。他们对被调用的字符串的实例做一些事情。</p><h2 id="7d3d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.charAt()</h2><p id="1713" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">charAt</code>返回位于字符串索引处的字符。</p><p id="5e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="0855" class="mz md it no b gy nt nu l nv nw">const str = "Hello";<br/>const res = str.charAt(0); // 'H'</span></pre><h2 id="076a" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.charCodeAt()</h2><p id="716f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">charCodeAt</code>返回位于字符串索引处的UTF-16字符代码。</p><p id="558d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3c81" class="mz md it no b gy nt nu l nv nw">const str = "Hello";<br/>const res = str.charCodeAt(0); // 72</span></pre><h2 id="222d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.codePointAt()</h2><p id="1a1d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">codePointAt</code>返回位于字符串索引处的UTF-16编码码位的码位值。</p><p id="c65c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="acf6" class="mz md it no b gy nt nu l nv nw">const str = "Hello";<br/>const res = str.<!-- -->codePointAt<!-- -->(0); // 72</span></pre><h2 id="1760" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.concat()</h2><p id="ef3f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">concat</code>方法组合两个字符串并返回一个新的字符串。例如，我们可以写:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="a4ce" class="mz md it no b gy nt nu l nv nw">const str1 = "Hello";<br/>const str2 = " World";<br/>const res = str1.<!-- -->concat<!-- -->(str2); // 'Hello World'</span></pre><h2 id="9b3d" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.endsWith()</h2><p id="ced1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">endsWith</code>检查一个字符串是否以你传入的子字符串结尾。</p><p id="4bab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="7604" class="mz md it no b gy nt nu l nv nw">const str = "Hello world.";<br/>const hasHello = str.endsWith("world."); // trueconst str2 = "Hello world.";<br/>const hasHello2 = str.endsWith("abc"); // false</span></pre><h2 id="ae20" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.includes()</h2><p id="01a5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">includes</code>检查传入的子串是否在字符串中。如果在字符串中，它返回<code class="fe nl nm nn no b">true</code>，否则返回<code class="fe nl nm nn no b">false</code>。</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="28fa" class="mz md it no b gy nt nu l nv nw">const str = "Hello";<br/>const hasH = str.includes('H'); // true<br/>const hasW = str.includes('W'); // false</span></pre><h2 id="ca39" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.indexOf()</h2><p id="78e4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">indexOf</code>查找子字符串第一次出现的索引。如果没有找到，则返回-1。</p><p id="f51c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="cfff" class="mz md it no b gy nt nu l nv nw">const str = "Hello Hello.";<br/>const hasHello = str.indexOf("Hello"); // 0<br/>const hasHello2 = str.indexOf("abc"); // -1</span></pre><h2 id="4854" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.lastIndexOf()</h2><p id="e638" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">lastIndexOf</code>查找子字符串最后一次出现的索引。如果没有找到，则返回-1。</p><p id="b320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="87fb" class="mz md it no b gy nt nu l nv nw">const str = "Hello Hello.";<br/>const hasHello = str.lastIndexOf("Hello"); // 6<br/>const hasHello2 = str.lastIndexOf("abc"); // -1</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/0c6ca057db6a8ed1bd6c2b4047aab282.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DPDFS4w-uIlvVtT0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕斯卡尔·贝纳登在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h2 id="fd26" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.localeCompare()</h2><p id="4cf8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">localeCompare</code>方法通过使用地区规则比较字符串的优先顺序来比较一个字符串是否在另一个之前。调用此方法的一般语法是:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="9712" class="mz md it no b gy nt nu l nv nw">referenceStr.localeCompare(compareString, locales, options)</span></pre><p id="ba55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<code class="fe nl nm nn no b">referenceStr</code>是否在<code class="fe nl nm nn no b">compareStr</code>之前，它返回以下值:</p><ul class=""><li id="b746" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">当<code class="fe nl nm nn no b">referenceStr </code>出现在<code class="fe nl nm nn no b">compareStr</code>之前时为负</li><li id="b760" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">当<code class="fe nl nm nn no b">referenceStr </code>发生在<code class="fe nl nm nn no b">compareStr</code>之后时为正</li><li id="4160" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">如果它们相等，则返回0</li></ul><p id="db4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法的第一个参数是要比较的字符串。</p><p id="2c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法的第二个参数可以选择一个区域设置字符串或区域设置字符串数组，它们是带有可选Unicode扩展键的BCP 47语言标记。Unicode扩展键，包括<code class="fe nl nm nn no b">"big5han"</code>、<code class="fe nl nm nn no b">"dict"</code>、<code class="fe nl nm nn no b">"direct"</code>、<code class="fe nl nm nn no b">"ducet"</code>、<code class="fe nl nm nn no b">"gb2312"</code>、<code class="fe nl nm nn no b">"phonebk"</code>、<code class="fe nl nm nn no b">"phonetic"</code>、<code class="fe nl nm nn no b">"pinyin"</code>、<code class="fe nl nm nn no b">"reformed"</code>、<code class="fe nl nm nn no b">"searchjl"</code>、<code class="fe nl nm nn no b">"stroke"</code>、<code class="fe nl nm nn no b">"trad"</code>、<code class="fe nl nm nn no b">"unihan"</code>在我们的区域设置字符串中也是允许的。它们指定了我们想要用来比较字符串的排序规则。但是，当第二个参数的选项中有与此重叠的字段时，该参数中的选项将覆盖第一个参数中指定的Unicode扩展键。</p><p id="6afa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以通过在第一个参数中将<code class="fe nl nm nn no b">kn</code>添加到您的区域设置字符串中来指定数字排序规则。例如，如果我们想比较数字串，那么我们可以写:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="9bfe" class="mz md it no b gy nt nu l nv nw">console.log('10'.localeCompare('2', 'en-u-kn-true'));</span></pre><p id="b9d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们得到一个，因为我们在构造函数的区域字符串中指定了<code class="fe nl nm nn no b">kn</code>。这使得排序器比较数字，10跟在2后面。</p><p id="e26e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以用<code class="fe nl nm nn no b">kf</code>扩展键指定是大写字母还是小写字母应该首先排序。可能的选项有<code class="fe nl nm nn no b">upper</code>、<code class="fe nl nm nn no b">lower</code>或<code class="fe nl nm nn no b">false</code>。<code class="fe nl nm nn no b">false</code>表示区域设置的默认值将是选项。该选项可以在区域设置字符串中设置，方法是将其作为Unicode扩展键添加到区域设置字符串中，如果两者都提供了，那么<code class="fe nl nm nn no b">option</code>属性将优先。例如，要使大写字母优先于小写字母，我们可以写:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="ae9a" class="mz md it no b gy nt nu l nv nw">console.log('Able'.localeCompare('able', 'en-ca-u-kf-upper'));</span></pre><p id="044a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将首先对大写字母的同一个单词进行排序。当我们运行<code class="fe nl nm nn no b">console.log</code>时，我们得到-1，因为我们在‘能力’中有一个大写的‘A’，在‘能力’中有一个小写的‘A’另一方面，如果我们改为在构造函数中传递<code class="fe nl nm nn no b">en-ca-u-kf-lower</code>，如下面的代码所示:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="77e2" class="mz md it no b gy nt nu l nv nw">console.log('Able'.localeCompare('able', 'en-ca-u-kf-lower'));</span></pre><p id="249e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在<code class="fe nl nm nn no b">console.log</code>之后我们得到一个，因为<code class="fe nl nm nn no b">kf-lower</code>意味着我们将小写字母的同一个单词排在大写字母的前面。</p><p id="1455" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法的第三个参数可以选择接受一个可以具有多个属性的对象。对象接受的属性有<code class="fe nl nm nn no b">localeMatcher</code>、<code class="fe nl nm nn no b">usage</code>、<code class="fe nl nm nn no b">sensitivity</code>、<code class="fe nl nm nn no b">ignorePunctuation</code>、<code class="fe nl nm nn no b">numeric</code>和<code class="fe nl nm nn no b">caseFirst</code>。<code class="fe nl nm nn no b">numeric</code>与区域设置字符串中Unicode扩展键的<code class="fe nl nm nn no b">kn</code>选项相同，<code class="fe nl nm nn no b">caseFirst</code>与<code class="fe nl nm nn no b">kf</code>选项相同。<code class="fe nl nm nn no b">localeMatcher</code>选项指定要使用的语言环境匹配算法。可能的值是<code class="fe nl nm nn no b">lookup</code>和<code class="fe nl nm nn no b">best fit</code>。查找算法搜索区域设置，直到找到符合正在比较的字符串的字符集的区域设置。<code class="fe nl nm nn no b">best fit</code>查找可能比<code class="fe nl nm nn no b">lookup</code>算法更适合的语言环境。</p><p id="acd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">usage</code>选项指定排序器是用于排序还是搜索字符串。默认选项是<code class="fe nl nm nn no b">sort</code>。</p><p id="9a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">敏感度选项指定比较字符串的方式。可能的选项有<code class="fe nl nm nn no b">base</code>、<code class="fe nl nm nn no b">accent</code>、<code class="fe nl nm nn no b">case</code>和<code class="fe nl nm nn no b">variant</code>。<code class="fe nl nm nn no b">base</code>比较字母的基数，忽略重音。比如<code class="fe nl nm nn no b">a</code>和<code class="fe nl nm nn no b">b</code>不一样，<code class="fe nl nm nn no b">a</code>和<code class="fe nl nm nn no b">á</code>一样，<code class="fe nl nm nn no b">a</code>和<code class="fe nl nm nn no b">Ä</code>T35一样。 <code class="fe nl nm nn no b">accent</code>指定字符串只有在基本字母或重音不同时才不同，忽略大小写。所以，<code class="fe nl nm nn no b">a</code>不等同于<code class="fe nl nm nn no b">b</code>，而<code class="fe nl nm nn no b">a</code>等同于<code class="fe nl nm nn no b">A</code>。<code class="fe nl nm nn no b">a</code>和<code class="fe nl nm nn no b">á</code>不一样。</p><p id="2f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">case</code>选项指定基本字母或大小写不同的字符串被认为是不相等的，因此<code class="fe nl nm nn no b">a</code>不会与<code class="fe nl nm nn no b">A</code>相同，<code class="fe nl nm nn no b">a</code>不会与<code class="fe nl nm nn no b">c</code>相同，但是<code class="fe nl nm nn no b">a</code>与<code class="fe nl nm nn no b">á</code>相同。<code class="fe nl nm nn no b">variant</code>表示具有不同基本字母、重音符号、其他标记或大小写的字符串被视为不相等。例如，<code class="fe nl nm nn no b">a</code>不会与<code class="fe nl nm nn no b">A</code>相同，<code class="fe nl nm nn no b">a</code>不会与<code class="fe nl nm nn no b">c</code>相同，但<code class="fe nl nm nn no b">a</code>也不会与<code class="fe nl nm nn no b">á</code>相同。</p><p id="7c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">ignorePunctuation</code>指定排序字符串时是否应忽略标点符号。这是一个布尔属性，默认值是<code class="fe nl nm nn no b">false</code>。</p><h2 id="b798" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.match()</h2><p id="4a88" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">match</code>方法在给定要匹配的正则表达式的情况下检索字符串的子字符串匹配。<code class="fe nl nm nn no b">match</code>方法将正则表达式作为参数。它可以是正则表达式文字，也可以是<code class="fe nl nm nn no b">RegExp</code>对象。如果没有给定正则表达式，我们将得到一个空字符串数组。如果正则有<code class="fe nl nm nn no b">g</code>标志，那么一个字符串中的所有匹配都将被返回到数组中。否则，将只返回第一个。</p><p id="eedb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">匹配项作为数组返回。例如，我们可以使用<code class="fe nl nm nn no b">i</code>标志进行不区分大小写的搜索:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="43d2" class="mz md it no b gy nt nu l nv nw">const str = 'foo';<br/>const re = /foo/i;<br/>const found = str.match(re);<br/>console.log(found);</span></pre><p id="cc37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们运行上面的代码，我们会得到:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="beb9" class="mz md it no b gy nt nu l nv nw">[<br/>  "foo"<br/>]</span></pre><p id="cf55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe nl nm nn no b">console.log</code>的声明上面来看。</p><p id="1a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们打开和关闭<code class="fe nl nm nn no b">g</code>标志，我们会得到不同的结果。如果正则有<code class="fe nl nm nn no b">g</code>标志，那么一个字符串中的所有匹配都将被返回到数组中。否则，将只返回第一个。如果我们打开了<code class="fe nl nm nn no b">g</code>标志，如下面的代码所示:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="11fc" class="mz md it no b gy nt nu l nv nw">const str = 'The quick brown fox jumps over the lazy dog. It barked.';<br/>const globalRe = /[A-Z]/g;<br/>const globalFound = str.match(globalRe);<br/>console.log(globalFound);<br/>console.log(JSON.stringify(globalFound, (key, value) =&gt; value, 2));</span></pre><p id="aa32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3570" class="mz md it no b gy nt nu l nv nw">[<br/>  "T",<br/>  "I"<br/>]</span></pre><p id="d018" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的<code class="fe nl nm nn no b">console.log</code>语句来看。但是，如果我们删除了<code class="fe nl nm nn no b">g</code>标志，如下面的代码所示:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="3ec1" class="mz md it no b gy nt nu l nv nw">const re = /[A-Z]/;<br/>const found = str.match(re);<br/>console.log(found);<br/>console.log(JSON.stringify(found, (key, value) =&gt; value, 2));</span></pre><p id="ebfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="f96e" class="mz md it no b gy nt nu l nv nw">[<br/>  "T"<br/>]</span></pre><p id="9c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的<code class="fe nl nm nn no b">console.log</code>语句来看。</p><h2 id="ffb1" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">String.matchAll()</h2><p id="ed39" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nl nm nn no b">matchAll</code>方法将返回通过向<code class="fe nl nm nn no b">matchAll</code>方法的参数传递正则表达式找到的所有结果。它返回一个迭代器，将结果的数组作为数组条目。例如，如果我们使用以下代码进行全局搜索:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="fc8d" class="mz md it no b gy nt nu l nv nw">const str = 'The quick brown fox jumps over the lazy dog. It barked.';<br/>const globalRe = /[A-Z]/g;<br/>const globalFound = [...str.matchAll(globalRe)];<br/>console.log(globalFound);<br/>console.log(JSON.stringify(globalFound, (key, value) =&gt; value, 2));</span></pre><p id="591d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="fe89" class="mz md it no b gy nt nu l nv nw">[<br/>  [<br/>    "T"<br/>  ],<br/>  [<br/>    "I"<br/>  ]<br/>]</span></pre><p id="90f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果正则表达式中没有全局标志来进行全局搜索，如下面的代码所示:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="fbec" class="mz md it no b gy nt nu l nv nw">const re = /[A-Z]/;<br/>const found = [...str.matchAll(re)];<br/>console.log(found);<br/>console.log(JSON.stringify(found, (key, value) =&gt; value, 2));</span></pre><p id="5c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到:</p><pre class="kj kk kl km gt np no nq nr aw ns bi"><span id="8a74" class="mz md it no b gy nt nu l nv nw">[<br/>  [<br/>    "T"<br/>  ]<br/>]</span></pre><p id="e75d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<code class="fe nl nm nn no b">console.log</code>的声明上面来看。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="233e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">字符串是JavaScript中一个重要的全局对象。它们代表一系列字符。有一些方法可以操作字符串，在不同的位置查找字符串的各个部分，以及修剪和替换字符串。随着JavaScript规范的每一次发布，都会添加更多的方法来使字符串搜索和操作比以往更加容易。请继续关注名单的第二部分。</p></div></div>    
</body>
</html>