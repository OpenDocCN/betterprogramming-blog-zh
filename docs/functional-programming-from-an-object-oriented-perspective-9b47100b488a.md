# 从面向对象的角度看函数式编程

> 原文：<https://betterprogramming.pub/functional-programming-from-an-object-oriented-perspective-9b47100b488a>

## 为什么我正在慢慢抛弃面向对象的过去

![](img/ee6249a4607a4c949d14d22b562a5884.png)

图片由 [StockSnap](https://pixabay.com/users/stocksnap-894430/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2557571) 发自 [Pixabay](https://pixabay.com/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=2557571) 。

C 编程语言可能是一种函数式编程语言(这方面过去是，现在可能仍然是依赖于实现的)。在大多数主机系统上，如果你把括号从函数中去掉，它只是一个指向函数的指针。你可以把它作为一个参数传入，或者从一个函数中返回，并通过给它加上括号来取消引用。唯一的问题是返回类型和去引用函数指针的参数经常在混乱中丢失。

这些都是我在研究 XLISP 的源代码时学到的，XLISP 是一个用 c 语言编写的实验性 LISP 解释器。作者大卫·米夏埃尔·贝兹煞费苦心地识别不同类型的函数，并提供必要的类型和类型转换，以便能够使用这些函数并使代码可以合理地理解。

函数式编程的其他用户在将他们的代码变得可读性更强方面并不那么成功。在许多方面，C++编程是对这种自由开放的函数式编程风格的一种反应。如果我们考虑 C++如何实现对象，它为每个“虚拟”函数维护一个函数指针列表，这个函数指针列表可以被子类修改，这就是它如何实现多态性的。

但是这种在运行时确定函数的方法是非常严格的。只有类的非静态方法可以被覆盖，它们必须通过子类化来覆盖。这允许了一种狭窄的编程风格，在这种风格中，我们可以对事物进行分类，并定义它们的行为分歧的方式。它允许代码重用，方法是将公共行为放在基类中，这些行为只能通过调用被覆盖的方法以非常特定的方式进行更改。

有了 Java 8，事情又回到了原点。它引入了使用单一抽象方法(SAM)类的函数式编程风格。这使用了 Java 面向对象架构的函数覆盖功能来创建函数对象。

对我来说，面向对象编程的最大缺点之一是不能一般性地捕捉许多常见模式。以“工厂”模式为例。Java 标准库中没有`Factory`类，尽管它可能是最常用的模式之一。我上过的`Factory`课多得数都数不过来。

当然，`Factory`对象本质上是面向对象的，因为它返回实现接口或扩展基类的对象。但是，本质上，它是一个“供应商”地图(一个不需要参数但会返回某些内容的函数)。假设你有一个`Car`接口和一堆实现它的类，工厂应该接受一些符号值并返回一辆特定类型的汽车。传统实现使用`switch`基于枚举或`String`值返回新值:

但是这包含了所有类型和选项的知识。要添加它，你必须添加到类本身。

如果你用函数的方式来做这件事，你不需要给工厂类型或选项的知识:

工厂的所有知识都可以外化，工厂可以在不修改代码的情况下进行扩展。

以下是如何使用这两个工厂的方法:

因此`FunctionalFactory`需要花费更多的努力来构建，但是它也是可扩展的，不需要修改工厂类。这满足了 SOLID 的“开闭原则”，因为它很容易扩展，但不需要修改。

这显然是一个简单的例子，你可能在任何人的库中都找不到`FunctionalFactory`类。但是，如果您开始考虑我们在编码时从供应商、消费者、谓词和函数的角度执行的操作，您也许能够找到解决您反复遇到的代码重用问题的新方法。

[](https://github.com/rkamradt/functionaldemo) [## rkamradt/功能演示

### 与我的文章配套的代码从面向对象的角度看函数式编程 GitHub 拥有超过 5000 万…

github.com](https://github.com/rkamradt/functionaldemo)