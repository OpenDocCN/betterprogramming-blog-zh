<html>
<head>
<title>How To Speed Up GitHub Actions by Avoiding Unnecessary Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何通过避免不必要的工作来加快GitHub的动作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-speed-up-github-actions-by-avoiding-unnecessary-work-b51f02c6392b?source=collection_archive---------2-----------------------#2022-05-24">https://betterprogramming.pub/how-to-speed-up-github-actions-by-avoiding-unnecessary-work-b51f02c6392b?source=collection_archive---------2-----------------------#2022-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">更新自述文件后，为您的GitHub操作节省时间，而不仅仅是运行作业</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7c000ae87906a2f0bd8915c615b3ecb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vOHI9B5npHP5pA4f"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@grstocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> GR Stocks </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="20a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">曾经有一段时间，如果你使用GitHub，你必须使用第三方CI/CD工具，如Jenkins或Travis CI。好在时代变了。</p><p id="7cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub Actions使软件工作流程自动化变得容易，无需使用第三方CI/CD工具。该社区已经创建了许多可重用的操作，您可以合并这些操作来构建自己的工作流。</p><p id="f663" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在GitHub上运行工作流有多种方式。最常见的是推送事件，它通常会触发配置项工作流。在某些时候，您的工作流会遇到问题，包括以下问题:</p><ul class=""><li id="17b6" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">与代码类似，工作流也可能随着时间而增长。不得不将工作流更改推送到GitHub来测试它们是否工作可能会变得很烦人(然后你意识到你有一个缩进错误，所以你不得不再次推)。</li><li id="0536" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">除了时间方面，还有成本方面:您的GitHub订阅包含每月有限的CI/CD分钟数(例如，团队计划为3000分钟)。</li></ul><p id="9825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我想分享一些如何更快、更有效地开发和执行GitHub工作流的方法，从而节省时间和金钱。</p><h1 id="bea0" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">忽略不必要的路径和分支</h1><p id="8b35" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">假设我们更新了自述文件，提交了更改，然后推它。在更新工作流文件之前，您会在GitHub上看到以下内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/248bae8349d69e67e4d14befa98a77de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DqNtGS3k25MSj8WRDE9QkQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一些GitHub作业运行了，尽管这毫无意义</p></figure><p id="43b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，即使实际的应用程序代码根本没有改变，代码还是被构建、测试和链接了。让我们用<code class="fe nh ni nj nk b">ci-ignore-paths.yml</code>更新我们的GitHub工作流。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7f06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在用更新的自述文件再次推送更改，我们会看到所有的GitHub工作流都被跳过了。这次没有构建、测试或测试任何代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/c37ea5eeeda4ae88bd3d7d209bb09b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tsj8a1z3WdX2ejBX0dqrg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这次没有执行自定义GitHub工作流</p></figure><p id="8b23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这已经是一个进步，但我们还可以做得更好。目前，GitHub不支持基于pull请求修改的文件的工作流步骤和作业的条件执行。不过，一个名为paths-filter的便捷GitHub操作可以帮助我们实现这一点。</p><p id="ee42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的工作流包含两个任务:一个是确定变更(例如，检查是否应该测试<code class="fe nh ni nj nk b">functions</code>项目)，另一个是实际执行我们想要的操作(例如，运行<code class="fe nh ni nj nk b">functions</code>项目的测试)。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="0537" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">有条件地跳过步骤和作业</h1><p id="a01a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">使用GitHub工作流，我们可以自动化很多事情:构建、测试、林挺、格式化、部署等等。然而，这可能会耗费时间和信用。有些任务只有在某些情况下才有意义。</p><p id="be1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您通常希望仅在合并到主分支时进行部署。类似地，如果您在一个特性分支上，那么您可以验证代码格式和样式，但是在主分支上这可能是不必要的。</p><p id="64b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe nh ni nj nk b">if</code>条件来有条件地运行或跳过步骤或整个作业。下面的工作流包含一个跳过主分支上的林挺步骤的作业，因为这不应该阻止进一步的步骤，如构建或部署我们的应用程序。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/966418bcd0742d1254756a22c548b5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiPHcIOXGLXO0Ncw9vXaPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">推进到主分支时，跳过了“Lint代码”步骤</p></figure><h2 id="132c" class="np mk it bd ml nq nr dn mp ns nt dp mt li nu nv mv lm nw nx mx lq ny nz mz oa bi translated">使用类似<a class="ae ky" href="https://nx.dev" rel="noopener ugc nofollow" target="_blank"> Nx </a>的monorepo工具，只构建和测试受影响的部分</h2><p id="ea29" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">Nx可以缓存构建和测试等任务的结果。如果使用Nx来触发一个任务，它将检查是否有会破坏该更改的代码更改(例如，更改一个规范文件或<code class="fe nh ni nj nk b">package.json</code>)。如果没有这样的变化，Nx将重用缓存，从而节省宝贵的时间。</p><p id="abe3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的工作流包含一个包含几个步骤的作业，包括构建、测试和林挺应用程序。使用Nx(云)时，我们将受益于智能重建功能。假设您有一个monorepo，带有一个客户端应用程序和多个特性库。如果您更改了某个特性库中的代码，我们应该只为直接受影响的代码(库本身以及使用它的任何其他应用程序或库)运行任务。下面是如何做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="d286" class="np mk it bd ml nq nr dn mp ns nt dp mt li nu nv mv lm nw nx mx lq ny nz mz oa bi translated">在本地运行GitHub工作流</h2><p id="782a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">如果我们能在本地运行GitHub工作流不是很好吗？毕竟，我们如何调试问题而不推动每一个小的变化，从而浪费大量的CI时间？</p><p id="e894" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于简单的工作流，可以尝试手动调用这些步骤，但是在某些时候会变得混乱或复杂，例如，由于本地设置或缺少环境变量。</p><p id="608a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实证明，这并不太难！我们所需要的就是<a class="ae ky" href="https://www.docker.com" rel="noopener ugc nofollow" target="_blank"> Docker </a>和一个叫做<a class="ae ky" href="https://github.com/nektos/act" rel="noopener ugc nofollow" target="_blank"> act </a>的有用命令行工具。虽然它不是100%准确，但act与实际情况非常接近。使用act，我们可以运行将在Docker容器中执行的单个作业或工作流。在我的Mac上，这相当快，有点类似于直接在GitHub上运行工作流。</p><p id="8624" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行<code class="fe nh ni nj nk b">ci_web</code>作业，我们需要运行以下命令:</p><pre class="kj kk kl km gt ob nk oc od aw oe bi"><span id="f563" class="np mk it nk b gy of og l oh oi">act -j ci_web</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/ebbeb169edd424a1f3226695fca94a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LmiYIrCjASDiKBpO4ReqvQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用act运行GitHub工作流时的终端输出</p></figure><h1 id="bac5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="7391" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">感谢您阅读这篇短文。</p><p id="c65c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，有几种方法可以加速GitHub工作流的开发和执行。Act尤其有助于避免不必要的向GitHub推送提交。</p><p id="0d9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也有更多的建议吗？</p><p id="9eb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请在评论中告诉我。</p></div></div>    
</body>
</html>