<html>
<head>
<title>Creating a Web Service API Using Rust Rocket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust Rocket创建Web服务API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-a-web-server-using-rust-rocket-1e4939e582df?source=collection_archive---------1-----------------------#2022-06-06">https://betterprogramming.pub/creating-a-web-server-using-rust-rocket-1e4939e582df?source=collection_archive---------1-----------------------#2022-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a384" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在本教程中，我们将介绍如何使用Rust的Rocket web框架来创建一个简单的web服务器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/3710b3edfca61e45747294ee7de1e8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*ndgrvzhCJuMNnLykc5-GeQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">作者图片</p></figure><p id="dba5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Rust是一种非常通用的语言，从游戏引擎到整个网站都有很多应用。Rust也有一个活跃而健康的社区，开发了许多有用的软件包。在本教程中，我们将看到其中一个名为Rocket的包，它将自己描述为:</p><blockquote class="ln lo lp"><p id="06c8" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">“Rust的web框架使编写<em class="iq">快速</em>变得简单，保护web应用程序而不牺牲灵活性、可用性或类型安全性”</p></blockquote><p id="d280" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我出身于一个专业背景的人，一旦你习惯了一些东西，我发现Rust的火箭很容易掌握——其中大部分都与Rust作为一种语言有关，而不是框架本身。</p><p id="9784" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将创建一个简单的web服务器，它使用Rocket返回关于当前或未来日期的信息，但是当您更熟悉Rust时，这将使您能够创建更高级的web服务器/应用程序。这个web服务器将处理简单的GET和POST请求，因此我们可以更好地理解Rocket如何处理接收和返回信息。</p><p id="d801" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个火箭教程，所以我将假设一些初学者的知识，但你可能会跟随，即使你还不舒服。如果你还没有，一定要安装货物，锈包管理器。如果你还没有，更多关于货物的信息可以在这里  <em class="lq">找到<a class="ae lu" href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html" rel="noopener ugc nofollow" target="_blank"> <em class="lq">。</em></a></em></p><p id="848e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您希望只是有一个示例可以遵循，那么最终的代码可以在本教程的末尾找到。</p><h1 id="7d9c" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">安装</h1><p id="a86f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">首先，我们需要使用Cargo创建一个新项目。如果您安装了cargo，可以从命令行使用以下命令来完成此操作:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="c215" class="mx lw iq mt b gy my mz l na nb">$ cargo new rust_web_server --bin</span></pre><p id="2a81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将为我们生成Rust二进制程序的基础。该命令创建的新目录应该如下所示:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="7155" class="mx lw iq mt b gy my mz l na nb">rust_web_server/<br/>├─ src/<br/>│  ├─ main.rs<br/>├─ Cargo.toml</span></pre><p id="5626" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe nc nd ne mt b">Cargo.toml</code>文件是我们添加依赖项的地方。在我们的例子中，我们希望添加Rocket、Serde (Serde将用于反序列化JSON请求)和Chrono(一个时间库)。添加了这些依赖项后，您的<code class="fe nc nd ne mt b">Cargo.toml</code>应该看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/d258b8b2be887191f85aa3d47e17e73d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNleCVosC7aKK58WsHuXKQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">Cargo.toml</p></figure><p id="862d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你愿意，你可以把你所有的代码放在<code class="fe nc nd ne mt b">main.rs </code>文件中，但是我喜欢把它分开，这样感觉起来更有条理，尤其是当你开始添加更多的路线和功能的时候。您可以根据自己的喜好构建它，但我将使用以下结构:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="2756" class="mx lw iq mt b gy my mz l na nb">rust_web_server/<br/>├─ src/<br/>│  ├─ main.rs<br/>│  ├─ routes/<br/>│  │  ├─ mod.rs<br/>│  │  ├─ date.rs<br/>│  ├─ services/<br/>│  │  ├─ mod.rs<br/>│  │  ├─ date.rs<br/>├─ Cargo.toml</span></pre><p id="41da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">routes文件夹是我们为GET/POST请求编写代码的地方，而services文件夹是我们存储每个路由所需的任何逻辑的地方。在Rust中，我们可以把相关的东西拆分成模块，需要用<code class="fe nc nd ne mt b">mod.rs</code>文件来告诉编译器那个模块包括什么。</p><h1 id="f143" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">火箭基础</h1><p id="0165" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在，您需要运行cargo build命令来安装依赖项。完成后，打开<code class="fe nc nd ne mt b">main.rs</code>,我们就可以创建web服务器了。我们将从<code class="fe nc nd ne mt b">main.rs</code>的一条路线开始，这样我们可以看到Rocket是如何工作的，但是我们将把它移动到routes文件夹中合适的位置。继续删除文件中的当前内容，并替换为以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">main.rs</p></figure><p id="295d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这段代码中，我们正在导入Rocket。然后我们在<code class="fe nc nd ne mt b">/</code>声明一个GET路由，这意味着无论我们在哪里装载它，它都是默认路由。在Rocket中，我们总是用结构<code class="fe nc nd ne mt b">[#type(“/location”)]</code>声明路由，后面跟着一个函数，它处理任何逻辑并返回我们想要发送回来的值。在这个例子中，我们返回字符串<code class="fe nc nd ne mt b">Hello, welcome to the api!</code>。</p><p id="9494" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们使用<code class="fe nc nd ne mt b">#[launch]</code>启动web服务器，并声明rocket函数，如上所示。在此功能中，我们可以在某个位置安装路线，例如默认的<code class="fe nc nd ne mt b">/</code>或<code class="fe nc nd ne mt b">/api</code>。无论我们在这个位置安装了什么路线，都可以通过到那个位置加上路线的位置来访问。因此，在我们的示例中，我们将通过前往<code class="fe nc nd ne mt b">server_address/api/</code>来访问我们的路线。</p><p id="e7bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是Rust的Rocket web框架工作的基础。如果您运行命令<code class="fe nc nd ne mt b">cargo run</code>，它应该编译并启动web服务器(可能在<code class="fe nc nd ne mt b">127.0.0.1:8000</code>)。现在，如果您在浏览器中打开一个新标签并导航到该地址，您将得到一个404错误。这是因为我们在/api位置安装了我们的路由。如果您将/api添加到地址的末尾(<code class="fe nc nd ne mt b">127.0.0.1:8000/api</code>，那么您应该会看到我们的<code class="fe nc nd ne mt b">say_hello()</code>函数返回的消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/8971d7cf121c9460e9959a417419ab6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*ABRLKQ-C3WB4HODyMlcV9Q.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">结果</p></figure><p id="4fa9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经看到了Rocket是如何工作的，让我们将路线移动到适当的位置，并添加一些实际的逻辑。</p><h1 id="a6a7" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">Rocket获取请求和响应</h1><p id="d154" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在<code class="fe nc nd ne mt b">routes/date.rs</code>里面，我们来添加一条新路线。该路径将以JSON格式返回当前日期。然而，实际的逻辑将在<code class="fe nc nd ne mt b">services/date.rs</code>中，而<code class="fe nc nd ne mt b">routes/date.rs</code>将只处理请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">路线/日期</p></figure><p id="4d81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们创建一个<code class="fe nc nd ne mt b">Date</code>结构，它可以被序列化和反序列化为JSON。然后，我们在<code class="fe nc nd ne mt b">/date/get-current-date</code>创建一个<code class="fe nc nd ne mt b">GET</code>路由，通过调用<code class="fe nc nd ne mt b">services/date.rs</code>中的<code class="fe nc nd ne mt b">get_current_date()</code>函数并将其转换为JSON，返回一个JSON序列化的<code class="fe nc nd ne mt b"> Date</code>对象。</p><p id="d19d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要实际使用这条路线，我们需要进入<code class="fe nc nd ne mt b">routes/mod.rs</code>并添加一行:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="674b" class="mx lw iq mt b gy my mz l na nb">pub mod date;</span></pre><p id="1a6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这让编译器知道我们想要使用<code class="fe nc nd ne mt b">date.rs</code>模块。对<code class="fe nc nd ne mt b">services/mod.rs</code>做同样的操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">服务/日期</p></figure><p id="9658" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的日期服务中，我们使用Chrono——Rust的时间库。为了使用我们的<code class="fe nc nd ne mt b">date</code>对象，我们需要从我们的date route导入它。然后，我们创建返回类型为<code class="fe nc nd ne mt b">Date</code>的函数<code class="fe nc nd ne mt b">get_current_date()</code>。我们使用Chrono获取当前的UTC时间，然后从中获取年、月和日。最后，我们将它分配给一个名为<code class="fe nc nd ne mt b">current_date</code>的<code class="fe nc nd ne mt b">Date</code>对象，并将它返回给我们的route，route将把它转换成JSON，并将JSON返回给调用route的任何地方。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a7254108ecfbcc6f332a32f6512d21c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*m-BgpKsyllPDbhfzfjzAjg.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">结果</p></figure><h1 id="9cb7" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">火箭发布请求和响应</h1><p id="a974" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在我们已经了解了如何使用Rust的Rocket创建GET请求，您可能想知道我们如何使用API调用中发送的数据。为了向您展示如何操作，我们将创建一个POST路由，该路由将获取表示日期的JSON数据，并返回一个月后的日期。</p><p id="d79d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就像我们的<code class="fe nc nd ne mt b">get-current-date</code>路线一样，让我们在<code class="fe nc nd ne mt b">routes/date.rs</code>中创建一个日期加月份的路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">路线/日期</p></figure><p id="ee1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个POST请求看起来与我们之前的GET请求有点不同。<code class="fe nc nd ne mt b">format = ‘json’</code>部分告诉Rocket，它只希望发送JSON数据。<code class="fe nc nd ne mt b">data = ‘&lt;date&gt;’</code>告诉Rocket在关联函数中期待一个名为date的变量，该变量将把数据发送到路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">服务/日期</p></figure><p id="c9f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的date_plus_month服务中，我们接受一个类型为<code class="fe nc nd ne mt b">Json&lt;Date&gt;</code>的可变日期变量，这意味着它是JSON，但必须与我们的date结构具有相同的结构。然后，我们在现有月份的基础上增加一个月，如果超过了12，则将其设置为1，这意味着如果超过了12月，则将其设置为1月。在这种情况下，我们还要加上一年。然后，我们将它赋给一个新的Date struct，就像我们对GET route所做的那样，连同其他JSON值一起，并将它返回到在route中调用它的地方，在那里它被转换成JSON并返回给调用者。</p><p id="008b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，只要确保将它添加到<code class="fe nc nd ne mt b">main.rs</code>中的<code class="fe nc nd ne mt b">routes!</code>宏中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">main.rs</p></figure><p id="f7af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在运行了<code class="fe nc nd ne mt b">cargo run</code>之后，我们可以使用<a class="ae lu" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>通过发送与我们的<code class="fe nc nd ne mt b">Date</code> struct相同的JSON来测试路由。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi no"><img src="../Images/c7a142584cf55f7602dd870b270023ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jBXvHg1ZEdN9mNLEKuDB9w.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">邮递员结果</p></figure><p id="92cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，成功了！我们发送了日期03/06/2022，并获得了03/07/2022。</p><p id="e6c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是所有的最终代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">main.rs</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">路线/车型和服务/车型</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">路线/日期</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">服务/日期</p></figure><h1 id="adff" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">摘要</h1><p id="8a45" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">现在，您对如何在Rust的Rocket web框架中处理请求和响应有了基本的了解。当然，您可以创建比我们在这里所做的更高级的web服务器和API，但是它是如何完成的仍然与此非常相似。</p><p id="40a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这个例子已经帮助你更好地理解Rocket是如何工作的，并且你现在可以使用你的新知识创建令人惊奇的web服务器！</p></div></div>    
</body>
</html>