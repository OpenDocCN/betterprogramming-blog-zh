<html>
<head>
<title>Understanding the Iterator Pattern in JavaScript and Typescript using Symbol.Iterator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用符号理解JavaScript和Typescript中的迭代器模式。迭代程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-iterator-pattern-in-javascript-typescript-using-symbol-iterator-ab400d46b14a?source=collection_archive---------6-----------------------#2019-12-16">https://betterprogramming.pub/understanding-the-iterator-pattern-in-javascript-typescript-using-symbol-iterator-ab400d46b14a?source=collection_archive---------6-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cc1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">for…of的引擎盖下是什么？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d6b09abc1656a9003f0dcaf91ba6c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9n31vseTTM2JjsJX7z53w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">亚历山大·安德鲁斯在<a class="ae ky" href="https://unsplash.com/s/photos/medium?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种模式具有不可思议的潜力，可以将我们的数据结构从算法中分离出来。</p><p id="2bb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在各种编程语言中被广泛实现。比如Java有<strong class="lb iu"> Iterable接口</strong>。</p><p id="0af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些语言中，有高级控制结构允许你迭代对象，而不需要创建<strong class="lb iu">迭代器模式</strong>(因为它们默认提供)。然而，修改这种内部模式以使用该语言的全部潜力，而不需要像Java那样冗长，可能是有用的。</p><p id="4310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您需要了解迭代器模式。如果你不知道，至少读一下我写的这篇文章，因为解释这篇文章的例子来自上一篇文章。</p><p id="a62f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ES6引入了一种与JavaScript数据结构交互的新方式:迭代。迭代器模式有两个核心概念:</p><ol class=""><li id="1424" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">Iterable 是一种数据结构，它提供了一种向公众公开其数据的方式。在JavaScript中，实现基于一个键为<code class="fe me mf mg mh b">Symbol.iterator</code>的方法。真的，<code class="fe me mf mg mh b">Symbol.iterator</code>是迭代器的工厂。</li><li id="5c90" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated"><strong class="lb iu">迭代器</strong>是一个包含指向迭代中下一个元素的指针的结构。</li></ol><p id="9ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，iterable必须是一个带有函数迭代器的对象，函数迭代器的键是<code class="fe me mf mg mh b">Symbol.iterator</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/d3410537a19d1c4edf4b9edf8148c366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SB92sVK0TKaP6OM2xnowg.png"/></div></div></figure><p id="92f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，迭代器必须是带有名为next的函数的对象，该函数返回带有键的对象:</p><ul class=""><li id="a68e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mo mb mc md bi translated"><code class="fe me mf mg mh b">value</code>:迭代中的当前项。</li><li id="b633" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu mo mb mc md bi translated"><code class="fe me mf mg mh b">done</code> : <code class="fe me mf mg mh b">true</code>如果迭代结束，则<code class="fe me mf mg mh b">false</code>否则。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/a4ff46c75c84e0602b1bde398da4739d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6Rl8bgXt7YNYIkEiH8ZVA.png"/></div></div></figure><p id="70e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，前面的代码定义了一个iterable和一个iterator，用法如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/c95fbc3b4681432f1b014d4a9381f595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUEGIJb-W0_-Bwl8xY-83A.png"/></div></div></figure><p id="b0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你使用一个<code class="fe me mf mg mh b">for-of</code>循环时，语言使用了一个iterable，并创建了它的迭代器。它继续调用<code class="fe me mf mg mh b">next()</code>，直到<code class="fe me mf mg mh b">done</code>为真。</p><p id="b502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript中有一个列表可以直接使用这些概念:</p><ul class=""><li id="faf0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mo mb mc md bi translated">数组内每个元素的<code class="fe me mf mg mh b">Arrays</code>和<code class="fe me mf mg mh b">TypedArrays</code>。</li><li id="1e73" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu mo mb mc md bi translated"><code class="fe me mf mg mh b">Strings</code>统领各个人物。</li><li id="fec6" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu mo mb mc md bi translated"><code class="fe me mf mg mh b">Sets</code>越过他们的元素。</li><li id="adfb" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu mo mb mc md bi translated"><code class="fe me mf mg mh b">Maps</code>超过它的键值对。</li></ul><p id="98d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是JavaScript中使用iterables的一些其他结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/183311427ea3aa68c55e982781c163cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SUNH-jvX1OaL_9tMbRf3w.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/d26b7f1782802f28b7022f472ead9ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p2DximEvaiItlsmoMDomOQ.png"/></div></div></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="9873" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">第一个例子:单词集合</h1><p id="660e" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">现在让我们看看如何使用JavaScript/TypeScript符号实现这种模式。在这种情况下，我创建了一个问题，其中有一个名为<code class="fe me mf mg mh b">WordsCollection</code>的类，它定义了一个单词列表(<code class="fe me mf mg mh b">items</code>)及其一组get和add方法(<code class="fe me mf mg mh b">getItems</code>和<code class="fe me mf mg mh b">addItem</code>)。该类由使用控制结构的<code class="fe me mf mg mh b">client</code>使用，如<code class="fe me mf mg mh b">for</code>或<code class="fe me mf mg mh b">forEach</code>。UML图显示了这个带有经典迭代器模式的场景:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/e72958e18fbe4fc6e5db2108dca6be25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4UfhA3tic0ZeDYaB.jpg"/></div></div></figure><p id="4967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这个UML图保持了与定制迭代器的兼容性，并实现了本地迭代器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/bef6fa512d6421853a0313b1b681bcb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SpMtRjShyX2irpGt.jpg"/></div></div></figure><p id="a918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们从无需实例化任何类就能本机使用迭代器的客户机开始。它将直接从for-of循环开始执行迭代。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/453194ee67d8366f5298f5044bacdebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7j2i5U0jyy6XP-APOTQ5A.png"/></div></div></figure><p id="1979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，语言清理器上迭代器的本机使用，因为它与编程语言的控制结构集成在一起。</p><p id="98fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是相关的<code class="fe me mf mg mh b">WordsCollection</code>代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/8c5fb71b480442906d8137856dbd63ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1nQW2pru0u_5LvRpTlAnQ.png"/></div></div></figure><p id="ed23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先要观察的是，我们需要实现两个接口:</p><ul class=""><li id="a9e3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu mo mb mc md bi translated"><strong class="lb iu">聚合器</strong>用于自定义可迭代，定义对象可迭代的必要方法。这里我们必须实现迭代器的构造方法。</li><li id="583e" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu mo mb mc md bi translated"><strong class="lb iu">迭代器</strong>由语言原生使用，是定义函数<code class="fe me mf mg mh b">[Symbol.iterator]: ()</code>的迭代器。</li></ul><p id="c432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本机迭代器的关键是本机迭代器的工厂函数——而不是直接实现它，它是在一个新的类中提取的，保持代码像以前的解决方案一样干净(<code class="fe me mf mg mh b">NativeAlphabeticalOrderIterator</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/baeca0773bb21941d828f01323147cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*62rCLfhJ7Oyj0JuzTqKdug.png"/></div></div></figure><p id="6cc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，本地迭代器和定制迭代器都从实现其余方法的抽象迭代器扩展了它们的<code class="fe me mf mg mh b">next()</code>方法。迭代器中的<code class="fe me mf mg mh b">next()</code>方法之间的主要区别是返回值。这是因为在本机迭代器中必须满足<code class="fe me mf mg mh b">Iterator</code>接口，它返回一个<code class="fe me mf mg mh b">IteratorResult</code>，而<code class="fe me mf mg mh b">CustomIterator</code>直接返回值。</p><p id="c0c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些代码甚至可以被重构，与其他设计模式一起使用，比如<a class="ae ky" href="https://carloscaballero.io/design-patterns-template-method/" rel="noopener ugc nofollow" target="_blank">模板方法</a>或<a class="ae ky" href="https://carloscaballero.io/stategy-pattern-in-javascript-typescript/" rel="noopener ugc nofollow" target="_blank">策略</a>。然而，我不希望添加这些模式使这个例子变得复杂。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/70fa63f4c38863b9210311e1bdffedf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fpQhe6wjOtW44nrzCEmRAA.png"/></div></div></figure><p id="4fb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端从<code class="fe me mf mg mh b">WordsCollection class</code> ( <em class="od">单一责任</em>)的内部结构中分离出来，你可以扩展软件实现新的迭代器(<em class="od">打开/关闭</em>)。</p><p id="9df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用了<code class="fe me mf mg mh b">Iterator</code>模式之后，我创建了两个npm脚本来运行这里显示的代码示例。</p><p id="fd7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">npm run example1-problem</code> <br/> <code class="fe me mf mg mh b">npm run example1-iterator-solution-1</code></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="49d3" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">示例:中型与开发型</h1><p id="6fa3" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">想象一下，我们必须创建一个软件，允许我们向社交网络中的联系人发送电子邮件，并考虑到我们将区分发送的邮件类型。在我们的人脉网络中，我们有两类联系人:朋友和同事。发送的电子邮件有多正式取决于联系人。</p><p id="f9f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一开始我们有来自两个著名社交网络的联系人:Dev.to和Medium。每个社交网络的数据结构的实现是不同的，因为在Dev.to中使用一个<code class="fe me mf mg mh b">array</code>来维护联系人，而在Medium中使用一个<code class="fe me mf mg mh b">Map</code>。</p><p id="d303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在下面的gif中找到使用我们整个结构的客户端(我已经给出了一个小的CLI示例)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/cd22d9bcda12f70c393b4d0f90ee2baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SYr5M9EO9UIBZxvm.gif"/></div></div></figure><p id="7715" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的UML图中，您可以看到针对这个问题提出的使用<code class="fe me mf mg mh b">CustomIterator</code>的解决方案:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/bc1d9256a251e02be5761b2020100c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GXFj7GBzekOSaF1x.jpg"/></div></div></figure><p id="8e77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是与包含本机迭代器的解决方案相关的图表。我们继续保持与定制迭代器的兼容性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mq"><img src="../Images/457068e0dc6c795a5cfeea4c968f1ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oi9coPqmVqfMJGJo.jpg"/></div></div></figure><p id="7572" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发解耦软件的主要优势在于，当我们的软件增长时，它不会受到变化的影响。事实上，我们应用程序的客户端仍然是同一段代码，因为它是基于接口并使用依赖注入构建的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/0124f68823d47b8d05280d7048282179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVMGu3IDbQSwyosVl0UAUg.png"/></div></div></figure><p id="312d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">sendSpamToFriends</code>和<code class="fe me mf mg mh b">sendSpamToCoworkers</code>方法使用迭代器，无论是自定义的还是本地的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/1761891429e553f96a0739ab98210bb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hYv380IDwsoBNeFhIYS9Tg.png"/></div></div></figure><p id="a6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个方法中，我们使用自定义和本地迭代器。原生迭代器的创建被委托给迭代器工厂，以区分朋友或同事。</p><p id="6f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">社交网络(dev.to或medium)必须通过<code class="fe me mf mg mh b">Iterable &lt;Profile&gt;</code>类型的对象创建本地迭代器来满足<code class="fe me mf mg mh b">SocialNetwork</code>接口。这是与社交网络相关的代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/01e999661cbd5c54a828b7dc97047e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pb61cugkh3PbIPPuPw9NEw.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/57dc8ec5a56a9c1fe53a3bcfeef7365c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UomKF-Nt40_9sYdQMkgKYg.png"/></div></div></figure><p id="3c7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个社交网络(dev.to或medium)都必须通过使用<code class="fe me mf mg mh b">Iterable type &lt;Profile&gt;</code>的对象创建本地迭代器来满足<code class="fe me mf mg mh b">SocialNetwork</code>接口。</p><p id="3833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是与迭代器相关的代码。两个迭代器(自定义迭代器和本地迭代器)都是从父迭代器扩展而来的，在父迭代器中实现了共同的方法。虽然在我们的例子中，<code class="fe me mf mg mh b">Iterator</code>接口有几个方法，但是我们只需要实现<code class="fe me mf mg mh b">next()</code>方法。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/f35c9ca80fddb0ad53702849213da811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BdQ9bfthOaBDY9vihHWrGA.png"/></div></div></figure><p id="a82d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与Medium关联的迭代器对应于与dev.to相同的接口:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/dc81fef27cda5da26bcc43578e2c4340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Otzc8d8U0BCDiKAdDWMWrQ.png"/></div></div></figure><p id="1b42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在应用了<code class="fe me mf mg mh b">Iterator</code>模式和CLI界面之后，我创建了一个npm脚本来运行这里显示的例子。</p><p id="51a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">npm run example2-iterator-solution1</code></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="3293" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">结论</h1><p id="2b50" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">迭代器模式可以帮助您避免项目中的耦合代码。当集合中有多种算法和数据结构时，迭代器模式非常适合。您的代码将会更加整洁，因为您应用了两个著名的原则:<strong class="lb iu">单一责任</strong>和<strong class="lb iu">打开/关闭</strong>。</p><p id="91c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时我们对了解我们正在开发的编程语言感兴趣。我们想要检查<strong class="lb iu">迭代器模式</strong>是否是固有实现的，就像在JavaScript(贯穿本文)、Python或PHP等语言中一样。</p><p id="3264" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最重要的事情不是实现我所展示的模式，而是能够识别这个特定模式可以解决的问题，以及何时可以或不可以实现所述模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p></div></div>    
</body>
</html>