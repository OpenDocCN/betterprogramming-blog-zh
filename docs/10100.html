<html>
<head>
<title>Design Patterns — Factory vs. Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式——工厂与战略</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-patterns-factory-vs-strategy-f45db68f0088?source=collection_archive---------2-----------------------#2021-11-29">https://betterprogramming.pub/design-patterns-factory-vs-strategy-f45db68f0088?source=collection_archive---------2-----------------------#2021-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2dee" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解实现差异</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f03f6de607f09e72b0dac054e5a2163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UgkDOZl5cbrBV_9qc-oiw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.freeimages.com/es/photographer/chamleo-61920" rel="noopener ugc nofollow" target="_blank">钱利奥</a>在<a class="ae ky" href="https://www.freeimages.com/" rel="noopener ugc nofollow" target="_blank">免费图片</a>上的照片</p></figure><p id="fa85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几天前我意识到一些问题可以同时使用设计模式工厂和策略来解决，然后我开始思考这些模式实现中的真正区别是什么。</p><p id="78d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，两种实现都会根据我们的需要在运行时返回不同的对象实例，它们可以用来解决业务问题或执行算法。</p><p id="fb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我总是更喜欢直接进入动手部分，而不是理论解释，我将开始创建一个示例，重构它，实现这两种模式来改进代码，最后，我们可以研究其他细节。</p><h1 id="05b9" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">这个例子</h1><p id="6243" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这个应用程序有一个负责运送产品的组件，它使用一个非常简单的实现，这个实现基于一个类，每个类有一个方法，正如我们在下面看到的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="69e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种实现是有效的，但并不理想，因为如果我们添加更多不同类型的运输，类会变得很大，并且每次我们需要调整或更改任何现有的运输方式时，都会更改相同的类。</p><p id="b867" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这肯定会成为未来的瓶颈。</p><p id="5336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了改进代码，我们可以开始将类分成多个其他类，因为它们基本上只用于以不同的方式运输产品，我们可以创建一个接口，为每种运输创建一个类，并确保这些类实现接口并实现方法来运输产品</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="aeac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于每一种新的shipping类型，我们只需要创建一个新的类，实现接口，并实现Ship方法，而不必更改任何其他现有的shipping类。</p><p id="0224" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要改变现有的运输方式，我们不需要改变同样的大类了，这很好。</p><p id="f0fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但无论如何，它仍然可以改进，想象一下我们想要避免考虑我们应该使用哪个类，而不是我们更喜欢有一个组件来为我们处理所有的创建过程，在这种情况下，我们可以使用工厂。</p><h1 id="e23b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">工厂</h1><p id="a2db" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当使用工厂设计模式时，组件将根据提供的信息处理实例化过程，并为我们返回具体类的实例，而不是实例化具体类。</p><p id="2654" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我使用一个enum来定义我希望拥有哪种类型的shipping实例，而<code class="fe mu mv mw mx b">ShippingFactory</code>类将负责根据输入实例化正确的类，并将其返回给调用者:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4848" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消费者可以使用工厂，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象一下，我们希望只有一个组件来发布产品，但是我们需要根据调用方法的组件来发布产品，在这种情况下，我们可以使用策略</p><h1 id="e8a0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated"><strong class="ak">策略</strong></h1><p id="dde6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当使用一个策略时，我们有策略地在运行时将一个具体的类直接注入到组件中。</p><p id="23dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个策略类，它实现相同的接口，并调用注入的具体类实现的方法。</p><p id="2a76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，我们不需要提供任何输入参数，我们只需要在调用组件之前注入正确的实例，策略类将执行它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="96fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消费者可以通过这种简单的方法使用该策略:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="57bf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">考虑</h1><p id="80e2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">尽管我们可以在实现中找到一些相似之处，但它们有许多不同之处。</p><p id="1844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">工厂模式是一种创造模式，而战略是一种行为模式，这意味着它们是使用不同的方法创建的。</p><p id="c9a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这两种方法来解决现实生活中的问题，但是在使用它们之前，我们可以检查哪种方法更简单，更有效地解决我们的问题。</p><p id="2c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这些模式有很多信息来源，对于你可以使用的所有其他相关模式，我真的很喜欢在<a class="ae ky" href="https://refactoring.guru/design-patterns" rel="noopener ugc nofollow" target="_blank">重构大师</a>那里查看它们。</p><p id="b01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里的目的是展示模式的一个非常简单的实现，并讨论明显的区别，对我来说它必须是简单的。</p><p id="0903" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你认为我可以给这篇文章添加更多的信息，请随时联系我，感谢你的阅读。</p></div></div>    
</body>
</html>