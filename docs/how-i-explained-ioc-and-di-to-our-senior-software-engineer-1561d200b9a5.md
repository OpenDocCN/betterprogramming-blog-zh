# 我如何向我们的高级软件工程师解释 IoC 和 DI

> 原文：<https://betterprogramming.pub/how-i-explained-ioc-and-di-to-our-senior-software-engineer-1561d200b9a5>

## 控制反转和依赖注入是你经常听到但可能从未完全理解的两个术语？下面是假人教程！

![](img/9404bc1a6d96312f0d643b93423cea67.png)

控制反转和依赖注入是现代软件开发中经常听到的两个热门词汇。至少在我开始职业生涯的时候是这样。这就是为什么我花了相当多的时间来研究这个话题。我很惊讶我们的高级软件工程师没有…

我不得不在审查我的一些代码时向他解释。我仍然记得他的反应:

> 就这样？这么容易吗？多年来，我一直对这种东西感到困惑，而你只是在一个简短的电话中向我解释了它？

如果连我过去几年的良师益友、我的重要同事都不明白这个概念，我想可能有必要写下另一个解释:

## *反转控制*和*依赖注入*为*假人*！

假设你想写一段代码来记录你在电脑前花了多少时间。您可能会想到一个简单的 API，如下所示:

如果我的同事在几年前实现了这个接口，它看起来应该是这样的:

简单明了。这个类唯一需要做的事情是一个`Stopwatch`实例。

> 该类需要一个`Stopwatch`的实例。
> 
> 这个类依赖于一个`Stopwatch`。
> 
> `Stopwatch`是`ComputerTimeTracker`类的一个依赖项。

到目前为止，一切顺利。现在让我们对代码做一点修改:

唯一改变的是构造函数。

不是*在构造函数中创建*的实例，而是*将*注入到构造函数中。

> 我们*将`Stopwatch`注入*到构造函数中。
> 
> 我们*将*的*依赖*的`Stopwatch`注入到构造函数中。
> 
> 我们刚刚做了一个依赖注入。

我只想说清楚:这就是全部！依赖注入意味着向需要依赖的人提供依赖，而不是让他们自己创建依赖。

无论是通过类构造函数、通过属性还是通过 setter-method 注入依赖项，都没有关系。你所做的只是注入一个依赖。

再次引用我同事的话:

> 我想我们必须讨论一下。现在我需要在创建一个`ComputerTimeTracker`实例之前创建一个`Stopwatch`实例。太糟糕了。那不是代码味吗？*面向对象编程*总是夸*信息隐藏*，现在却不得不了解一个`Stopwatch`？当我在构造函数中创建实例时，我只需要创建我的`ComputerTimeTracker`，它会为我处理剩下的事情。我不想知道实现细节，我只想用类。综上所述:`Stopwatch`应该由`ComputerTimeTracker`控制。

注意他已经使用了*控制*这个词。我会把这个想法想得更远一点:

在我同事的方法中，我们有明确的*控制顺序:*

> 类`ComputerTimeTracker`正在控制`Stopwatch`。
> 
> 控制`Stopwatch`是`ComputerTimeTracker`的责任。

现在请注意我们注入`Stopwatch`的方法发生了什么变化:

> 我们，`ComputerTimeTracker`的用户，在控制`Stopwatch`。
> 
> 控制`Stopwatch`是用户的责任。

你可能已经注意到了。通过注入依赖性，我们颠倒了控制的顺序。我们将控制`Stopwatch`的责任从类转移到了类的用户身上。这就是控制的倒置。再说一遍:真的就这些了！

既然行话已经不再神秘，我们可以谈谈为什么我们可能更喜欢依赖注入的方法。让我们进一步增强我们的示例代码:

我所做的改变只是将类依赖关系`Stopwatch`换成了接口依赖关系`IStopwatch`。这样，类`ComputerTimeTracker`就不依赖于。NET 框架，但是*松散地耦合*到任何实现接口`IStopwatch`的实例。现在对我们最大的好处是:

# 单元测试！

我们通过一个接口注入到一个类中的所有依赖关系都可以被*模仿*。那是超级方便的。考虑以下使用案例:

*   你开始追踪
*   你在电脑前度过 42 小时
*   你停止追踪
*   你检查花费的时间

当在`ComputerTimeTracker`的构造函数中创建了`Stopwatch`实例时，为那个用例编写单元测试是困难的。你无法真正取代它。当你无法取代它时，你就无法控制`Stopwatch`。所以你得等 42 小时。有了依赖注入，你可以简单地注入一个模拟的`Stopwatch`到类中，只是为了测试。

# 结论

依赖注入和控制反转是每个开发人员都应该知道的重要概念。他们有点炒作，经常被误解。但是如果你花一些时间去真正挖掘它，你会发现它们实际上是多么的简单。

为什么他们会被大肆宣传呢？因为它们使我能够为我的代码编写可读的单元测试。这已经为我卖出去了。

但是这里还有更多我没有提到的好处:*依赖关系的动态替换*或者使用 *IoC 容器。但是这些是另一篇文章的主题…*

有什么概念是你不明白的吗？让我知道！:-)

感谢阅读！