<html>
<head>
<title>How to Build Infinite Scroll in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中创建无限卷轴</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/infinite-scrolling-in-react-839bbade153f?source=collection_archive---------15-----------------------#2020-02-07">https://betterprogramming.pub/infinite-scrolling-in-react-839bbade153f?source=collection_archive---------15-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6a18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这比你想象的要容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c662ea44071cb06366ea4a7f39b1b99a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Kn53lcXoZHqyCENBG6_Cg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@taypaigey?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">泰勒·威尔科克斯</a>在<a class="ae ky" href="https://unsplash.com/s/photos/scroll?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9510" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近到处都是。无限滚动是刷新时愤怒的来源，也是试图入睡时浪费无数时间的提醒。</p><p id="055e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，这么高的使用率，你可能想把它包含在你的app里。</p><p id="70ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法很简单:</p><ol class=""><li id="4b6b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">创建一个事件侦听器，它查看您当前在窗口对象中的位置。</li><li id="0d0f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">确保它不会听起来太难，因为你只希望出现少量的新元素，而不是几千个。</li></ol></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f30c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">功能组件</h1><h2 id="2db6" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">1.让我们从添加事件监听器开始</h2><p id="2aa3" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">使用功能组件，我们必须引入带有空数组的<code class="fe oa ob oc od b">useEffect</code>作为第二个参数，这实际上是功能组件中新的<code class="fe oa ob oc od b">componentDidMount</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/f0452b13d8dad65f9126fa0c8990b524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBOHxjF-0_TxYlxBNLqhzQ.png"/></div></div></figure><p id="ae4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要构建出<code class="fe oa ob oc od b">handleScroll</code>函数。只需将它添加到类中的<code class="fe oa ob oc od b">loadMore</code>中，并保持原样以用于函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/ba5d2ef01950e409766e4a4a42f9a1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iYqs45Umc7qDa95cas59g.png"/></div></div></figure><p id="e701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多方法可以创建<code class="fe oa ob oc od b">handleScroll</code>函数——上面的方法是监听<code class="fe oa ob oc od b">innerHeight</code>和<code class="fe oa ob oc od b">scrollTop</code>的当前位置，并检查它是否大于<code class="fe oa ob oc od b">offsetHeight</code>。</p><p id="2d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当你将<em class="mj">滚动过底部的</em>时，它才会被触发，让浏览器以轻微的弹性运动拉起整个页面。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h2 id="a9c4" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">2.不要听得太认真。什么？</h2><p id="13ba" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">如果你看看我们设计事件监听器的方式，<code class="fe oa ob oc od b">loadMore</code>会在你喘口气之前发出很多声音。所以我们稍微后退一点，创建一个<code class="fe oa ob oc od b">useState</code>，它会告诉我们是否/何时到达<code class="fe oa ob oc od b">loadMore </code>——用一个小缓冲区在事件和负载之间创建一些滞后。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/ddef620e1b545a4cada9b6b32d28f92a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0f4BHbMh5UkTrvpB4R8iZA.png"/></div></div></figure><p id="f53b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们创建的第一个事件监听器将只有<code class="fe oa ob oc od b">setIsLoading(true)</code>。</p><p id="ee6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第11行添加了另一个事件监听器，它将监听<code class="fe oa ob oc od b">isLoading</code>中的变化。当<code class="fe oa ob oc od b">isLoading</code>改变时，它会检查<code class="fe oa ob oc od b">isLoading</code>是否为<code class="fe oa ob oc od b">true</code>，然后加载更多元素。</p><p id="d44d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，重要的是要注意，如果在你到达页面底部之前是<code class="fe oa ob oc od b">false</code>，那么<code class="fe oa ob oc od b">isLoading</code>应该只变成<code class="fe oa ob oc od b">true</code>。因此，每次到达底部时，只应调用一次<code class="fe oa ob oc od b">useEffect</code>事件监听器。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="515d" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">类别组件</h1><h2 id="4f6b" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">1.添加事件监听器</h2><p id="47fb" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">在功能模型中，我们将初始事件侦听器添加到</p><p id="5f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oa ob oc od b">useEffect(() =&gt; {},[])</code>，本质上是一个<code class="fe oa ob oc od b">componentDidMount</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/12a0902dbe32fc8da79534525b2a0094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-fXOgZwHv7CixxBMmYOsyA.png"/></div></div></figure><p id="1e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，检查用户是否在页面底部。</p><h2 id="60f4" class="nj ms it bd mt nk nl dn mx nm nn dp nb li no np nd lm nq nr nf lq ns nt nh nu bi translated">2.听得太认真了</h2><p id="eca6" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">现在，我们遇到了和以前一样的问题(我们加载的太多了)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/a2b767c2e9d92fd7d2d607d30d0615eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-QIuMTnbIu9vpxPhoU9hg.png"/></div></div></figure><p id="4579" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们创建了一个名为<code class="fe oa ob oc od b">isLoading</code>的状态。如果<code class="fe oa ob oc od b">isLoading</code>为真，我们返回并退出函数，根本不检查<code class="fe oa ob oc od b">scrollTop</code> / <code class="fe oa ob oc od b">clientHeight</code> / <code class="fe oa ob oc od b">scrollHeight</code>。</p><p id="b668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保在<code class="fe oa ob oc od b">loadMore</code>中首先是<code class="fe oa ob oc od b">setState({ isLoading: false})</code>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="494e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="0571" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">这一切都是基于这样一个假设，即您正在从头开始构建它。但是如果您想走更简单的路线，只导入一个库，这也很容易。</p><div class="oj ok gp gr ol om"><a href="https://www.npmjs.com/package/react-infinite-scroller" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">反应-无限-滚动</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">ES6中用于React的无限滚动组件</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">www.npmjs.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>