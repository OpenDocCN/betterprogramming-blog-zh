<html>
<head>
<title>4 Nice and Simple React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">4个漂亮简单的反应挂钩</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-nice-and-simple-react-hooks-1272d41f0df?source=collection_archive---------1-----------------------#2020-08-02">https://betterprogramming.pub/4-nice-and-simple-react-hooks-1272d41f0df?source=collection_archive---------1-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c50d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">useDebounce、useWhenVisible、useTimeout和useInterval</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/230ed6b02a8dcfcd44e01e985d64df98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N0vjjy7nRU8DvFCF"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@tata186?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tatiana Rodriguez </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="74de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React已经成为在浏览器中构建应用程序的最流行的库之一。虽然它是由脸书发明的，但它是开源的，任何人都可以免费使用。数百万开发人员已经在使用React构建令人惊叹的企业应用程序。新的脸书网站完全由React和Relay组成，我们已经看到微软等其他大公司在Azure DevOps等应用程序中使用React。</p><p id="20c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">React在2019年2月推出了16.8版本的钩子。它们允许您使用状态和其他React特性，而无需编写类。钩子允许您将一段有状态逻辑封装到一个可重用的“钩子”中，然后您可以在您的组件中使用它。</p><blockquote class="ls"><p id="502d" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">"钩子允许你在不改变组件层次结构的情况下重用有状态逻辑."— <a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React的文档</a></p></blockquote><p id="0eb1" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">我收集了一些我日常使用的非常有用的钩子。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="1bf5" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">使用反跳</h1><p id="6b35" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">有了这个简洁的钩子，您将能够延迟一个值的去抖——就像您可以通过正常的去抖来延迟一个函数的执行。这个想法非常相似:我们在钩子中定义了一些局部状态，我们只在去抖动函数开始运行时更新这些状态。</p><p id="f38a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常适合这种挂钩的情况是，您想要对快速变化的值做出反应，但是您的反应可能是异步的或缓慢的，因此您只想对您能够消费的最新值做出反应。这里有一个例子:</p><h2 id="4fd9" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">履行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用反钩</p></figure><h2 id="53a6" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">使用</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">useDebounce用法示例</p></figure><p id="6e46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，只有当用户停止输入超过500毫秒时，<code class="fe nz oa ob oc b">debouncedSearchTerm</code>才会更新并运行我们的效果。如果他们再次开始输入，我们会在他们停止时再次运行该效果。通过这种方式，我们可以确保每次击键都不会向服务器发出请求。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="d8f9" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">使用可见时间</h1><p id="4ffa" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">对于无限滚动这样的实现特性来说，这是一个非常有用的钩子，当用户滚动时，可以获取更多的数据。这个钩子允许您监听特定的元素，当该元素在视窗中可见时，将调用一个回调函数来通知您。然后，您可以使用这个回调作为获取更多数据的触发器。</p><p id="13b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户向下翻页时，它对于延迟加载图像或触发动画也很有用。</p><p id="a0a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">钩子利用浏览器中的<code class="fe nz oa ob oc b">IntersectionObserver</code> API来观察一个元素，然后在元素相交时调用提供的回调函数(在屏幕上可见)。</p><h2 id="80a5" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">履行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用可见挂钩</p></figure><h2 id="0735" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">使用</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">useWhenVisible用法示例</p></figure><p id="33e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码所做的就是每当最后一个元素出现在视窗中时更新<code class="fe nz oa ob oc b">offset</code>，触发我们的效果运行并获取下一组待办事项。简单易行。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="1b77" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">使用超时</h1><p id="a6ad" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这个钩子可以让你以声明的方式使用普通的<code class="fe nz oa ob oc b">setTimeout</code>行为，只要你想在做某事之前等待。这在很多情况下非常有用，通过使用钩子，您永远不必担心内存泄漏或奇怪的错误，因为您忘记了清除超时。</p><h2 id="432f" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">履行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用超时挂钩</p></figure><p id="bcfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们为回调函数创建一个ref。然后我们用一个效果来记住最新的回调函数。然后我们使用一个效果来设置计时器，并在之后进行清理。它的巧妙之处在于，你可以简单地通过将<code class="fe nz oa ob oc b">null</code>作为延迟传入来取消一个正在运行的超时，因为它将清除超时并且<em class="od">而不是</em>安排一个新的超时(第15行)。</p><h2 id="770d" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">使用</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">useTimeout用法示例</p></figure><p id="9b2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这不容易读，我不知道什么是。简单，声明性，易于使用。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="dde7" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">使用间隔</h1><p id="20c1" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这和<code class="fe nz oa ob oc b">useTimeout</code>很像。我已经把<code class="fe nz oa ob oc b">setTimeout</code>的妹妹(<code class="fe nz oa ob oc b">setInterval</code>)列为挂钩。它们的实现和API看起来几乎一样，所以我只向您展示代码:</p><h2 id="674c" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">履行</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用区间挂钩</p></figure><p id="5cf2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在服务器上进行任何类型的轮询以获得新数据，那么<code class="fe nz oa ob oc b">useInterval</code>非常有用。如果你不能控制API，你就不能仅仅实现像WebSockets这样的东西来把数据推送到客户端。相反，您可以使用这个钩子来设置轮询。</p><p id="46f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你有一个协作购物清单应用程序，当你在杂货店把东西放进篮子里时，你和你的S.O .可以从清单上划掉它们。在这种情况下，获取新数据是绝对必要的，这样你就不会在收银台遇到两件相同的商品，或者因为你认为你的S.O .已经获取而完全忘记。</p><h2 id="22e5" class="nl mp iq bd mq nm nn dn mu no np dp my lf nq nr na lj ns nt nc ln nu nv ne nw bi translated">使用</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">useInterval用法示例</p></figure><p id="aca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个非常简单的例子，说明如何每五秒钟轮询一次API以获取新数据，从而保持视图的更新。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="2165" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">结论</h1><p id="d0f9" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我希望你喜欢这些例子，并且有一天能在你的应用中使用它们。</p><p id="e2e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>