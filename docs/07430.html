<html>
<head>
<title>How to Create an Extension for Your Open API Specification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为您的开放API规范创建扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-an-extension-for-your-open-api-specification-fc5f51c82bb8?source=collection_archive---------15-----------------------#2021-01-13">https://betterprogramming.pub/how-to-create-an-extension-for-your-open-api-specification-fc5f51c82bb8?source=collection_archive---------15-----------------------#2021-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="026e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当你需要一些OAS不能处理的东西时，你会怎么做？当然是创建自己的扩展！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96e28f841a0ef61eb483aa772fa27bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1dV1bvHp7OTmYHAE3BTqw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://pixabay.com/users/timhill-5727184/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=5436525" rel="noopener ugc nofollow" target="_blank">蒂姆·希尔</a>从<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=5436525" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄。</p></figure><p id="90e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2021年将是API 年<a class="ae ky" href="https://medium.com/better-programming/its-2021-this-is-where-your-focus-should-be-in-tech-73deeb0b1eb" rel="noopener">。我们将专注于聚合一个标准(提供公共API)并加快我们的创新速度。</a></p><p id="f62d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着我们对使用<a class="ae ky" href="https://www.openapis.org" rel="noopener ugc nofollow" target="_blank">开放API规范</a> (OAS)的API设计的关注，我们将遇到一些需要自动化但目前还不可能的场景。也许这种自动化对您和您的公司来说是定制的，或者也许它是您想要提供给任何地方的开发人员的一种服务。我们如何着手实现这种自动化？通过使用一个<em class="lv">延长件</em>。</p><p id="6d85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://swagger.io/docs/specification/openapi-extensions/" rel="noopener ugc nofollow" target="_blank">扩展</a>是向OAS添加功能的简单方法。您向文件添加一些属性，实现一个处理程序来读取它并采取行动，并获得自动化的好处！</p><p id="23d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其从概念上解释什么是扩展，今天我将带你创建一个全新的扩展。我们将做一个扩展来增强我们不久前做的<a class="ae ky" href="https://medium.com/better-programming/dynamic-test-generation-with-open-api-spec-3-0-10dacd7866c2" rel="noopener">邮差合同测试生成器</a>。</p><p id="7c31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试生成器很棒，但是它依赖于种子数据才能正常工作。这意味着在执行之前，特定的数据必须在数据库中，以便测试可以使用它。</p><p id="80ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这造成了一点问题，因为它增加了进入的障碍。如果有一种方法可以在测试本身中使用测试生成的数据，那就太好了。这意味着当生成器执行<code class="fe lw lx ly lz b">POST</code>来创建一个新实体时，它可以在对<code class="fe lw lx ly lz b">GET</code>的后续请求中使用该实体的<code class="fe lw lx ly lz b">id</code>或者用<code class="fe lw lx ly lz b">PUT</code>进行更新。</p><p id="6825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过构建一个扩展来从头到尾解决这个问题。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/1b5bf7386b18c2f16381c6d7395a00e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gdISPsK7d5-IvyVS.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mi">照片由</em> <a class="ae ky" href="https://unsplash.com/@imagesbykayla?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="mi">凯拉农</em> </a> <em class="mi">上</em> <a class="ae ky" href="https://unsplash.com/s/photos/search?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> <em class="mi">下</em> </a> <em class="mi">。</em></p></figure><h1 id="1dd4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">识别业务问题</strong></h1><p id="943f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在我们的例子中，我们希望能够在后续生成的测试中使用由生成的测试所创建的值。业务问题可以这样陈述:“我想在测试中使用动态变量，这样我就不必依赖于种子数据了。”</p><p id="8ba0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您确定了业务问题，您就想要提出一个如何最好地解决它的计划。在我们的例子中，这涉及到在其他请求中使用由测试生成器创建的值。</p><p id="e7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们必须能够保存响应值并在其他请求中使用它们。记住这一点，我们应该能够开始下一步:定义模式。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/483e591fd29335d9a61eda6ade59b01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rSL_bH37gWFhEVkz.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mi">照片由</em> <a class="ae ky" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1149962" rel="noopener ugc nofollow" target="_blank"> <em class="mi">免费提供——照片由</em><a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1149962" rel="noopener ugc nofollow" target="_blank"><em class="mi">Pixabay</em></a><em class="mi">提供</em> </a> <em class="mi">。</em></p></figure><h1 id="80dd" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">定义扩展模式</strong></h1><p id="ea1a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">要使用动态变量，我们需要知道什么时候<em class="lv">保存</em>和<em class="lv">消耗</em>它们。</p><h2 id="2911" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">保存动态变量</h2><p id="adbc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了保存动态测试中的变量，我们需要知道何时何地从响应中获取值。在我们的例子中，特定端点上的某些响应代码将产生我们想要的值。</p><p id="e2c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要识别两部分数据:变量的名称和在哪里找到它。我们还需要让我们的处理程序知道我们想要保存一个变量。</p><p id="cf41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">考虑到这一点，以下模式支持我们的业务需求:</p><pre class="kj kk kl km gt ns lz nt nu aw nv bi"><span id="717b" class="ng mk it lz b gy nw nx l ny nz">x-postman-variables: <br/>  - type: save <br/>    name: myVariable <br/>    path: .id</span></pre><p id="96e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个模式，<code class="fe lw lx ly lz b">type</code>将告诉处理程序我们想要保存这个变量。<code class="fe lw lx ly lz b">name</code>将是Postman中变量的名称。<code class="fe lw lx ly lz b">path</code>将是响应中属性的JSON路径。您可以看到，我们还将扩展做成一个数组，以防我们需要存储来自单个响应的多个值。</p><p id="4e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以在特定端点的特定响应下将扩展添加到我们的开放API规范中。我们可以参考<a class="ae ky" href="https://github.com/allenheltondev/gopher-holes-unlimited/" rel="noopener ugc nofollow" target="_blank"> Gopher Holes Unlimited </a>示例API规范。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/fd19f86ec2e9e19e5b75f80122c41474.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QAdBB5Qw2WZHcC_f.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mi">在Gopher Holes Unlimited OAS中使用扩展的示例</em></p></figure><h2 id="e291" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">消费动态变量</h2><p id="c1d9" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">既然我们已经正确地保存了变量，那么接下来就是在后续的测试中使用它们了。使用开放API规范，我们能够定义请求中使用的参数。</p><p id="da2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们希望在后续请求中使用变量，所以我们应该确保用扩展来丰富我们的OAS <code class="fe lw lx ly lz b">parameters</code>。每次我们使用参数时，测试生成器都会提取当前的Postman变量值，并在测试中使用它。</p><p id="26fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消费这些值要比保存它们容易得多，因为我们只需要知道变量名。这将我们引向以下模式:</p><pre class="kj kk kl km gt ns lz nt nu aw nv bi"><span id="f4b2" class="ng mk it lz b gy nw nx l ny nz">x-postman-variables: <br/>  - type: load<br/>    name: myVariable</span></pre><p id="15e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这个模式，<code class="fe lw lx ly lz b">type</code>表示我们正在加载值，<code class="fe lw lx ly lz b">name</code>告诉我们的处理程序我们想要哪个变量。这样，我们就定义了扩展定义！</p><p id="bdf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将该示例添加到我们的OAS中将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/951007b380a93baec75f81d7c27cb1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qYyr8o72aLr4Znt0.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mi">在Gopher Holes中无限制使用变量的示例</em></p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ae43" class="mj mk it bd ml mm oa mo mp mq ob ms mt jz oc ka mv kc od kd mx kf oe kg mz na bi translated"><strong class="ak">实现处理程序</strong></h1><p id="4b3a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">定义了扩展的模式后，现在是时候编写解释这些值的代码了。毕竟，OAS文档只是一个定义。它实际上不做任何事情。</p><p id="61cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的扩展专门用于<a class="ae ky" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>，所以我们的处理程序将从<a class="ae ky" href="https://github.com/allenheltondev/postman-contract-test-generator" rel="noopener ugc nofollow" target="_blank">契约测试生成器</a>集合中的预请求和测试脚本中编写。</p><h2 id="97ce" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">保存扩展变量</h2><p id="ec5a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">契约测试生成器已经查看了每个端点上每个方法允许的响应。为了实现我们扩展的逻辑，我们将绑定到现有的功能中。</p><p id="c8f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们保存每个方法的响应时，处理程序将寻找扩展并将变量保存到测试的一个<code class="fe lw lx ly lz b">variables</code>属性中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/d825ba190e80ab60d201e3a07adf0458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*B3Jp2_JOJaposnPJ.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mi">“保存变量”处理程序逻辑从我们的扩展中读取</em></p></figure><p id="95c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到它正在保存定义了<code class="fe lw lx ly lz b">save</code>类型的变量。</p><h2 id="4fbd" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">将响应值作为变量保存</h2><p id="1602" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">现在是实际工作的时候了:在定义的路径上从响应中获取值，并将其保存到Postman集合变量中。</p><p id="7685" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，这不是一个非常困难的代码片段。它只是使用我们在步骤1中保存的内容:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/583647ac6e7ada619ad75a3c4c043348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DcjUTQdFfO7pDMIY.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mi">将响应值保存到Postman变量中</em></p></figure><p id="4d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看看我们所做的，你会发现我们正一点一点地走向我们想要的财产。如果我们在响应中找到它，这个值将被保存到一个集合变量中。如果找不到值，断言就会失败，让我们的测试知道出错了。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6e1e" class="mj mk it bd ml mm oa mo mp mq ob ms mt jz oc ka mv kc od kd mx kf oe kg mz na bi translated">使用响应值</h1><p id="6462" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我们拼图的最后一块是在需要的时候加载我们刚刚保存的值。测试生成器中已经存在一个函数，它用OAS提供的示例替换参数。</p><p id="11f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过我们扩展，我们将修改逻辑，以便在必要时使用集合变量的值。如果我们在集合变量中找不到值，我们就回到这个例子。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/3a138ace9018350bd0d7e4f9f36caa2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y40-E-kJIDzsE2rC.jpg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="mi">将持久变量加载到可用参数中</em></p></figure><p id="02db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在这里看到，代码正在为任何保存类型为<code class="fe lw lx ly lz b">load</code>的参数寻找我们的<code class="fe lw lx ly lz b">x-postman-variables</code>扩展。如果有，它将使用集合变量。如果没有，它将从示例中提取。</p><p id="ebee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">针对查询参数和标题的代码也已更新。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="90e0" class="mj mk it bd ml mm oa mo mp mq ob ms mt jz oc ka mv kc od kd mx kf oe kg mz na bi translated"><strong class="ak">试试看</strong></h1><p id="9825" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">就是这样！有了处理程序的实现，一切都可以正常工作了。</p><p id="3364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为您的开放API规范构建一个扩展就是这么简单。只需三个简单的步骤:</p><ol class=""><li id="93d3" class="of og it lb b lc ld lf lg li oh lm oi lq oj lu ok ol om on bi translated">找出问题所在。</li><li id="1bc0" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">定义模式。</li><li id="b7cf" class="of og it lb b lc oo lf op li oq lm or lq os lu ok ol om on bi translated">实现处理程序。</li></ol><p id="550c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，如果您希望您的扩展被其他人使用，您将需要记录使用情况(就像我在这里所做的！).</p><p id="c185" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你受到启发，做出自己的扩展。可能性是无限的。处理程序甚至不需要在Postman中！它可以是你的<a class="ae ky" href="https://medium.com/better-programming/how-to-build-a-ci-cd-pipeline-in-aws-in-5-minutes-and-58-seconds-4de156477042" rel="noopener"> CI管道</a>中的一个脚本，你的AWS CloudFormation脚本中的一个定制资源，甚至是一个小小的按需桌面应用。</p><p id="2943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您采取哪种方式，都一定会让整个开发团队的生活变得更加轻松。</p><p id="f733" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，走出去，建立一些扩展！如果你还没有，试试<a class="ae ky" href="https://github.com/allenheltondev/postman-contract-test-generator" rel="noopener ugc nofollow" target="_blank">测试生成器</a>。比以往任何时候都好！</p></div></div>    
</body>
</html>