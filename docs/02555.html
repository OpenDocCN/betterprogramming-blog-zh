<html>
<head>
<title>Orchestrating a Rails Docker Deployment in Swarm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swarm中编排Rails Docker部署</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/orchestrating-rails-docker-deployment-in-swarm-474aa6b8d35b?source=collection_archive---------11-----------------------#2019-12-08">https://betterprogramming.pub/orchestrating-rails-docker-deployment-in-swarm-474aa6b8d35b?source=collection_archive---------11-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7df6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Swarm Orca gem简化您的Docker swarm部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/53081289c7fe4171d092f944d3ac8b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yrPfI6ari9Vp5T5LEZ87Pg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由特雷弗·科尔曼在<a class="ae ky" href="https://unsplash.com/s/photos/orca?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="68f4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><strong class="ak">背景</strong></h1><p id="e933" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Swarm Orca 是一个简单的Ruby gem，它可以帮助你像在本地部署一样部署到多个Swarm集群。</p><p id="0c76" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Docker是可以用来简化软件部署过程的工具之一。在我看来，使用Docker进行软件部署的最大优势是它提供了一种简单的方法来打包软件及其依赖项，包括操作系统。因此，不需要在主机服务器上安装这些依赖项(唯一需要的依赖项是Docker本身)。</p><p id="2dcc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Docker附带的另一个工具是Swarm，这是一个开源的容器编排平台。它是Docker的本地集群引擎。Swarm提供了一种构建高可用Docker集群和以高可用模式部署服务的方法。</p><p id="8423" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用Swarm，您可以定义您的服务以及这些服务的副本数量。Swarm将确保每个服务的状态总是符合要求，如果一个容器关闭，Swarm将尝试重新创建该容器——或者甚至尝试在一个Docker节点关闭的情况下重新定位服务。</p><p id="2055" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用Swarm进行部署非常简单，可以通过以下步骤进行描述:</p><ul class=""><li id="8ac6" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">使用<code class="fe nb nc nd ne b">docker-compose</code>文件定义群组堆栈</li><li id="d14a" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">用<code class="fe nb nc nd ne b">docker stack</code>命令创建Docker栈</li></ul><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="4152" class="no la it ne b gy np nq l nr ns">docker stack deploy --compose-file docker-compose.yml ${stack_name}</span></pre><p id="c21a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦命令<code class="fe nb nc nd ne b">docker stack deploy</code>被执行，Swarm将创建堆栈文件中定义的服务，然后在集群中寻找一个空闲节点来部署(创建容器)每个定义的服务，并确保服务配置得到满足。</p><p id="dd14" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">例如，您可以在部署或推出服务的过程中定义容器的替换顺序。您还可以为每个已定义的服务、日志记录驱动程序和其他配置定义副本的数量。</p><p id="3fb1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦您开始管理多个微服务或Docker堆栈的部署，并开始通过测试、试运行和生产支持多个环境，从配置角度来看，事情将变得更加复杂。部署过程中会出现新的挑战。这些挑战列举如下:</p><ul class=""><li id="75e9" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">Docker服务可以通过定义环境变量来配置。这些变量的值可以在Docker堆栈中定义。对于大多数变量来说，这是可以的；但是，对于敏感信息，我们需要为这些变量提供加密/解密工具。</li><li id="0394" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">部署过程的自动化:为了保持Docker部署简单，需要自动化服务部署步骤，例如，将堆栈文件复制到Swarm manager节点，如果需要，提取部署所需的Docker映像，并执行Docker命令来创建服务。</li><li id="bee2" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">支持多种环境需要将服务的配置值从堆栈文件中分离出来，以便能够在多个环境中使用相同的堆栈，而无需复制这些文件。</li><li id="ea1e" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">支持多种环境需要将组合堆栈文件转换为模板，以便我们可以为不同的环境提供不同的配置——例如，在需要将服务部署到具有不同日志记录驱动程序和相同堆栈文件的两个环境的情况下。</li><li id="3a70" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">对于像MySql这样在RDMS中持久化数据的应用程序，需要在推出新版本之前运行数据库模式迁移，以实现零停机部署。不幸的是，我们不能将数据库迁移定义为另一种服务，因为Swarm数据库迁移容器将在完成迁移后停止运行，因此Swarm将一直尝试重启它们。另一个原因是我们希望通过数据库迁移来阻止部署，以确保只有在数据库迁移成功完成后才部署新代码——否则，部署过程将会失败。</li><li id="9256" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">需要将所有的配置值存储在版本控制中，这样我们就可以跟踪谁在做更改，这些更改是何时做的，以及为什么要做更改？</li><li id="afd9" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">以与生产相同的方式支持开发环境中的本地部署。</li></ul><p id="2ccc" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">市场上有一些解决上述挑战的解决方案，如<a class="ae ky" href="https://www.portainer.io/" rel="noopener ugc nofollow" target="_blank"> Portainer </a>和<a class="ae ky" href="https://rancher.com/docs/rancher/v1.3/en/swarm/" rel="noopener ugc nofollow" target="_blank"> Rancher </a>。</p><p id="8cac" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，并非所有的挑战都能在一个解决方案中解决。因此，我开始开发一个命令行工具来解决上述所有挑战，并为开发人员提供一种简单的方法来使用Swarm将服务部署到本地和生产环境中。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="480d" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated"><strong class="ak">宝石特征</strong></h1><p id="0b58" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">因为我主要使用Rails应用程序，所以我关心的是实现这个工具来支持Rails应用程序部署。然而，该工具可用于部署第三方服务，如Nginx、MySQL和Redis。它还可以用来部署非Rails应用程序。</p><p id="b674" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面详细描述了我想在该工具的第一个版本中包含的主要特性:</p><ul class=""><li id="4bc4" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">该工具必须支持多阶段部署:这意味着该工具应该能够用于将同一组服务部署到多个环境中，包括本地开发和生产环境。</li><li id="ffd0" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">该工具应该能够管理和组织所有支持的环境和应用程序的配置项/文件。</li><li id="19f5" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">支持Docker-stack模板:这个特性对于支持多阶段非常重要，因为它有助于减少托管Docker-stack文件的数量。例如，我们可以只为每个受支持的阶段呈现一个模板，而不是为每个受支持的阶段提供Docker堆栈。</li><li id="c775" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">支持加密密钥生成以及对配置项进行加密和解密。能够在文件系统中存储加密的敏感数据，并且仅在Docker主机上的部署期间解密这些值。</li><li id="a826" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">支持Rails数据库操作，比如数据库、创建迁移和种子。</li><li id="adc0" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">提供一种为应用程序加载自定义种子的方法。如果您将特定于客户的种子保存在应用程序源代码之外，这个特性会很有用。</li><li id="c47f" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">为执行部署提供简单灵活的命令行，允许对单个堆栈、自定义数量的堆栈或所有堆栈执行部署。</li></ul><p id="b379" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了构建具有这些特性的工具，我决定构建一个能够处理Swarm部署的Ruby gem，并且我还决定利用<a class="ae ky" href="https://capistranorb.com/" rel="noopener ugc nofollow" target="_blank"> Capistrano </a>，这是一个用Ruby编写的远程服务器自动化和部署工具。Capistrano将帮助我实现我想开发的大部分功能。</p><p id="4ff2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我将部署宝石命名为<a class="ae ky" href="https://github.com/wshihadeh/swarm_orca" rel="noopener ugc nofollow" target="_blank">虫群虎鲸</a>、<em class="of">T5，在<a class="ae ky" href="https://github.com/wshihadeh/swarm_orca" rel="noopener ugc nofollow" target="_blank"> GitHub </a>和<a class="ae ky" href="https://rubygems.org/gems/swarm_orca" rel="noopener ugc nofollow" target="_blank">RubyGems.org</a><em class="of">上很容易找到。</em>请随意尝试并给我反馈。</em></p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="da46" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated"><strong class="ak">用Swarm Orca建立一个示例项目</strong></h1><p id="719c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在下一节中，我将尝试展示如何使用<a class="ae ky" href="https://github.com/wshihadeh/swarm_orca" rel="noopener ugc nofollow" target="_blank"> Swarm Orca </a> <em class="of"> </em>建立一个新项目，并将其部署到本地开发环境中。我建立的orca项目将包括(仅为了简单起见)三个服务，它们是:</p><ul class=""><li id="a89a" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">关系型数据库</li><li id="5cbb" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">Nginx</li><li id="a105" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">示例-rails-app</li></ul><p id="c6c4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这个项目的第一步是用下面的命令在本地安装gem。</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="f481" class="no la it ne b gy np nq l nr ns">➜  ~/ gem install swarm_orca</span></pre><p id="51bf" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一旦您安装了gem，就会安装<code class="fe nb nc nd ne b">orca</code>命令行，您可以用下面的命令创建一个新项目:</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="69b8" class="no la it ne b gy np nq l nr ns">#orca new ORCA_DIRECTORY_NAME GIT_FORK DOCKER_NETWORK<br/>➜  ~/ orca new  orca_test wshihadeh orca_test_network</span></pre><ul class=""><li id="3fbd" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated"><code class="fe nb nc nd ne b">ORCA_DIRECTORY_NAME</code>是项目文件夹名</li><li id="239c" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated"><code class="fe nb nc nd ne b">GIT_FORK</code>是你的Git叉名吗</li><li id="c272" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated"><code class="fe nb nc nd ne b">DOCKER_NETWORK</code>是将部署服务的Docker网络的名称</li></ul><p id="8485" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">上面的命令将创建一个样例Orca项目，其中包含启动本地部署所需的所有文件和一些预定义的堆栈。</p><p id="ce24" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面是默认情况下将创建的文件列表。如Nginx，MySQL Redis等。</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="e77c" class="no la it ne b gy np nq l nr ns">➜  ~/ orca new  orca_test wshihadeh orca_test_network                                                                                                                                                                      <br/>Start Generating orca files<br/>      create  .gitignore<br/>      create  .ruby-version<br/>      create  README.md<br/>      create  capistrano/Capfile<br/>      create  nginx/Dockerfile<br/>      create  nginx/nginx.conf<br/>      create  redis/Dockerfile<br/>      create  redis/redis.conf<br/>      create  capistrano/config/deploy/template_stage.rb<br/>      create  capistrano/Gemfile<br/>      create  .ruby-gemset<br/>      create  capistrano/config/deploy.rb<br/>      create  application_stack/docker-stack-elasticsearch.yml.erb<br/>      create  application_stack/docker-stack-errbit.yml.erb<br/>      create  application_stack/docker-stack-mysql.yml.erb<br/>      create  application_stack/docker-stack-nginx.yml.erb<br/>      create  application_stack/docker-stack-rabbitmq.yml.erb<br/>      create  application_stack/docker-stack-redis.yml.erb</span></pre><ul class=""><li id="280f" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">支持的Docker-stack文件可以在<code class="fe nb nc nd ne b">application_stack</code>文件夹下找到。这些堆栈应该是ERB堆栈模板。</li><li id="7cb9" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">支持的环境配置项可以在<code class="fe nb nc nd ne b">capistrano/config/deploy/${env}.rb</code>下找到。</li><li id="08a6" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">共享部署配置可以在<code class="fe nb nc nd ne b">capistrano/config/deploy.rb</code>中找到。</li><li id="8a19" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">自定义Docker映像和配置文件可以在<code class="fe nb nc nd ne b">${service_name}</code>下找到，例如Nginx或Redis。</li></ul><p id="a5cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">新的命令输出还将包括后续步骤的说明。</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="c694" class="no la it ne b gy np nq l nr ns">Complete!<br/>Next step is to create development stage file from the<br/> template file use the following commands to do it<br/>cd orca_test/capistrano<br/>gem install bundler<br/>bundle install<br/>cd orca_test/capistrano/config/deploy<br/>cp template_stage.rb local.rb<br/>Replace all ${VAR} with a valid value<br/>Read Readme for more information</span></pre><p id="452c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">为了能够在本地部署我们的服务，我们需要执行上面提供的说明，然后执行以下操作:</p><ul class=""><li id="4ddd" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">创建本地舞台。</li></ul><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="2c22" class="no la it ne b gy np nq l nr ns">➜  ~/ pwd<br/>orca_test/capistrano/config/deploy<br/>➜  ~/ cp template_stage.rb local.rb</span></pre><ul class=""><li id="dd80" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">因为我们不打算只支持默认应用中的MySQL和Nginx，所以我清理了<code class="fe nb nc nd ne b">local.rb</code>，只包含这些配置。我们必须在文件顶部定义服务者和用户，并且只保留<code class="fe nb nc nd ne b">Nginx</code>、<code class="fe nb nc nd ne b">MySQL</code>和<code class="fe nb nc nd ne b">swarm_manager</code>角色。需要添加<code class="fe nb nc nd ne b">deploy_to</code>，因为默认的<code class="fe nb nc nd ne b">deploy_to</code>在我的本地机器上不存在(我们也可以创建默认的<code class="fe nb nc nd ne b">deploy_to</code>文件夹，也就是<code class="fe nb nc nd ne b">/home/deploy/orca</code>)。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="ada2" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">由于我们的项目不叫<code class="fe nb nc nd ne b">orca</code>并且我们在本地有不同的部署路径，我们需要覆盖<code class="fe nb nc nd ne b">deploy.rb</code>中的一些默认配置。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="409e" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">提交更改，并将其推送到您的分支。</li><li id="1cd2" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">现在我们已经为部署做好了准备，只需使用以下命令之一进行部署:</li></ul><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="6755" class="no la it ne b gy np nq l nr ns"># For deploying all stacks <br/>s➜  ~/  bundle exec cap local deploy:setup deploy:all<br/># For deploying only mysql<br/>s➜  ~/  bundle exec cap local deploy:setup deploy:mysql<br/># For deploying only nginx<br/>s➜  ~/  bundle exec cap local deploy:setup deploy:nginx<br/># For deploying only nginx and mysql <br/>s➜  ~/  bundle exec cap local deploy:setup deploy:nginx deploy:mysql<br/># For deploying only nginx and mysql<br/>s➜  ~/ <!-- -->DEPLOYED_STACKS='<!-- -->nginx mysql<!-- -->' <!-- -->bundle exec cap local deploy:auto</span></pre><ul class=""><li id="aa60" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">您还可以通过将以下环境变量添加到部署命令行，使用复制策略而不是Git来执行本地部署:</li></ul><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="6413" class="no la it ne b gy np nq l nr ns">s➜  ~/ SCM=copy bundle exec cap local deploy:setup deploy:all</span></pre><p id="48ab" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下一步是将Rails应用程序添加到Orca中，并尝试将其部署到本地环境中。假设我们有一个具有以下Docker映像的Rails应用程序，<code class="fe nb nc nd ne b">wshihadeh/simple_rails</code>可以配置以下环境变量:<code class="fe nb nc nd ne b">RAILS_ENV</code>、<code class="fe nb nc nd ne b">RAILS_LOG_TO_STDOUT</code>、<code class="fe nb nc nd ne b">DATABASE_URL</code>和<code class="fe nb nc nd ne b">LOG_LEVEL</code>。</p><ul class=""><li id="82f2" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">集成该应用程序的第一步是为新应用程序创建Docker-stack模板，并用文件名<code class="fe nb nc nd ne b">application_stack/docker-stack-simple_rails.erb</code>保存它。该文件的内容应该类似于以下内容:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="6729" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">下一步是用下面的<code class="fe nb nc nd ne b">simple_rails</code>应用程序信息更新<code class="fe nb nc nd ne b">capistrano/config/deploy.rb</code>。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="9062" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe nb nc nd ne b">db_apps_stacks_mapping</code>是一个散列对象，它定义了连接到数据库的支持堆栈和应用程序的列表。散列的关键字是栈名，这需要匹配栈模板文件名。例如，堆栈<code class="fe nb nc nd ne b">simple_railS</code>应该在<code class="fe nb nc nd ne b">application_stack/docker-stack-simple_rails.erb</code>中定义。键值可以是堆栈中使用数据库的应用程序列表的空数组。由于<code class="fe nb nc nd ne b">simple_rails</code>只有一个Rails应用程序，我们可以将其设置为与<code class="fe nb nc nd ne b">simple_rails</code>相同的值。</p><ul class=""><li id="d8ba" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">用<code class="fe nb nc nd ne b">simple_rails</code>应用程序的配置更新本地阶段。唯一需要的环境变量是<code class="fe nb nc nd ne b">stack_name</code>。只有当您希望支持数据库迁移时，才需要<code class="fe nb nc nd ne b">${application}_database_url</code>。其余的变量取决于应用程序及其堆栈模板文件。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="7725" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们还需要更新本地stage来拥有应用程序角色。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="27a4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用角色<code class="fe nb nc nd ne b">simple_rails</code>，我们允许将应用程序部署到本地环境，使用角色<code class="fe nb nc nd ne b">simple_rails_db</code>，我们允许在本地环境中执行数据库迁移。在登台和生产环境中，这些角色可以分布在多个Docker节点上，以便在部署期间平衡负载。</p><ul class=""><li id="c465" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">要在本地部署<code class="fe nb nc nd ne b">simple_rails</code>，我们需要首先创建数据库和种子，然后部署应用程序。这些操作可以通过以下命令完成:</li></ul><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="b239" class="no la it ne b gy np nq l nr ns">bundle exec cap local deploy:setup<br/>bundle exec cap local deploy:create_simple_rails_dbs<br/>bundle exec cap local deploy:migrate_simple_rails_dbs<br/>bundle exec cap local deploy:seed_simple_rails_dbs<br/>bundle exec cap local deploy:simple_rails</span></pre><p id="fde0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">任务<code class="fe nb nc nd ne b">deploy:simple_rails</code>将自动执行数据库迁移——因此，它只在第一次部署时需要。</p><ul class=""><li id="77e9" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">在最后一步中，我们以纯文本的形式存储了<code class="fe nb nc nd ne b">simple_rails_database_url</code>。这不是一个好的做法，因为任何有权访问回购的人都可以找到数据库密码。因此，在这一步，我们将生成一个加密密钥并加密<code class="fe nb nc nd ne b">simple_rails_database_url</code>变量。</li></ul><p id="68df" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">使用下面的命令，我们可以生成一个新的加密密钥。请确保保护此密钥，不要发布它。</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="4afc" class="no la it ne b gy np nq l nr ns">➜ : orca gen_enc_key                                                                                                                                     <br/>Encryption Key: 6764f56ee9e24f3bf5903a394ce1081a7921f212bf017182149219fdc82f21d4</span></pre><p id="9440" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">要加密配置项，我们可以使用以下命令:</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="74c9" class="no la it ne b gy np nq l nr ns">➜ : orca encrypt $KEY mysql2://root:mysql@mysql/simple_rails_local<br/>OQ8VXMq5Hz/xlygPmphrtVVpOcE</span></pre><p id="5fe5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在使用加密密钥进行重新部署之前，我们需要为本地环境更新应用程序的配置。</p><p id="423d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">应用程序配置上唯一需要的更改是将<code class="fe nb nc nd ne b">simple_rails_database_url</code>配置重命名为<code class="fe nb nc nd ne b">encrypted_imple_rails_database_url</code>，并将其分配给加密值。Swarm Orca将在部署期间负责解密这个值。</p><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="fa9f" class="no la it ne b gy np nq l nr ns">encrypted_simple_rails_database_url: 'OQ8VXMq5Hz/xlygPmphrtVVpOcE',</span></pre><ul class=""><li id="fb13" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">现在我们已经完成了应用程序<code class="fe nb nc nd ne b">simple_rails</code>的重新配置，我们可以将它重新部署到本地环境中。这次唯一不同的是，我们需要在部署命令行中提供加密密钥，以便能够解密Docker主机上的值。可以使用以下命令行执行部署:</li></ul><pre class="kj kk kl km gt nk ne nl nm aw nn bi"><span id="090e" class="no la it ne b gy np nq l nr ns">➜ : export ENCRYPTION_KEY=$key<br/>➜ : export SCM=copy<br/>➜ : bundle exec cap local deploy:setup deploy:simple_rails</span></pre><ul class=""><li id="f705" class="ms mt it lt b lu mn lx mo ma mu me mv mi mw mm mx my mz na bi translated">通过在<code class="fe nb nc nd ne b">capistrano/config/deploy</code>下创建新的stage文件，可以简单地集成新的环境。这可以通过复制配置文件并在新文件中更新所需的配置来完成，例如服务器IP甚至应用程序配置。</li><li id="0001" class="ms mt it lt b lu nf lx ng ma nh me ni mi nj mm mx my mz na bi translated">改进和自动化解决方案的最后一步是构建Jenkins管道，用于自动化Jenkins的部署。以下Jenkins文件是使用Swarm Orca定义部署管道的示例文件。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="1e86" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">结论</h1><p id="b743" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Docker containers和Swarm简化了软件部署过程，但它们没有解决我们在管理遵循微服务架构的软件部署时面临的所有挑战。</p><p id="9103" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">市场上有一些解决这些挑战的解决方案，但大多数都需要花费一些精力来设置服务器或将其安装在Swarm上。</p><p id="f6cd" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Swarm Orca 是一个简单的Ruby gem，它可以帮助您以与本地部署相同的方式部署到Swarm集群。gem支持部署到多个集群、加密配置项和运行数据库迁移等功能。</p></div></div>    
</body>
</html>