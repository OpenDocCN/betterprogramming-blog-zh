<html>
<head>
<title>Building an E-Commerce API Using Nestjs, SQLite, and TypeORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nestjs、SQLite和TypeORM构建电子商务API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-an-e-commerce-api-using-nestjs-sqlite-and-typeorm-25a7978de666?source=collection_archive---------4-----------------------#2022-04-01">https://betterprogramming.pub/building-an-e-commerce-api-using-nestjs-sqlite-and-typeorm-25a7978de666?source=collection_archive---------4-----------------------#2022-04-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="580e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是一种让顾客享受购物体验的迷人方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b85b73987e8603e3a305d28cdf559ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BBfEKYLqfUOrw8Aa.png"/></div></div></figure><h1 id="934a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="08e0" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Nestjs是一个先进的Node.js框架，用于开发高效、可靠和可伸缩的服务器端应用程序。</p><p id="db72" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">很容易与NoSQL和SQL数据库集成，如MongoDB、<a class="ae mn" href="https://arctype.com/postgres/connect/yugabyte-postgres" rel="noopener ugc nofollow" target="_blank"> Yugabyte </a>、<a class="ae mn" href="https://arctype.com/sqlite/connect/sqlite-gui" rel="noopener ugc nofollow" target="_blank"> SQLite </a>、<a class="ae mn" href="https://arctype.com/postgres/connect/client-postgres" rel="noopener ugc nofollow" target="_blank"> Postgres </a>、<a class="ae mn" href="https://arctype.com/mysql/connect/client-mysql" rel="noopener ugc nofollow" target="_blank"> MySQL </a>等。它支持流行的对象关系映射器，如TypeORM Sequelize和Mongoose。</p><p id="5f1a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在本教程中，我们将使用SQLite和TypeORM创建一个电子商务应用程序。我们还将了解一个强大的SQL客户端和数据库管理工具<a class="ae mn" href="https://arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype </a>。</p><p id="8a31" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我们开始吧！</p><h1 id="95e6" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">先决条件</h1><p id="20dc" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">本教程是让您入门的实践演示。确保您满足以下要求:</p><ul class=""><li id="06f3" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated">您已经安装了<a class="ae mn" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">节点</a> ( &gt; = 10.13.0，v13除外)</li><li id="00f2" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated">您已经掌握了JavaScript的基础知识</li><li id="4017" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mn" href="https://arctype.com/" rel="noopener ugc nofollow" target="_blank"> Arctype </a>已安装</li></ul><h1 id="210d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">项目设置</h1><p id="ce61" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要开始使用Nestjs，请使用下面的命令安装Nestjs CLI:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="6da8" class="nh kv it nd b gy ni nj l nk nl">npm i -g @nestjs/cli</span></pre><p id="0b63" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">安装完成后，使用下面的命令创建一个Nestjs项目:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="126b" class="nh kv it nd b gy ni nj l nk nl">nest new ecommerce</span></pre><p id="a6ad" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">选择您的npm作为包管理器，点击enter按钮，然后等待Nest安装运行这个应用程序所需的包。</p><p id="1867" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">安装完成后，使用以下命令将目录更改为项目文件夹:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fa2c" class="nh kv it nd b gy ni nj l nk nl">cd ecommerce</span></pre><p id="91cb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后在您喜欢的文本编辑器或IDE中打开项目目录。之后，打开一个新的终端，使用下面的命令在开发模式下运行服务器(这将启用热重装，并允许我们在控制台上看到可能的错误):</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="63c8" class="nh kv it nd b gy ni nj l nk nl">npm run start:dev</span></pre><h1 id="cb9c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">安装依赖项</h1><p id="6b2c" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">服务器启动并运行后，打开一个新的终端窗口，这样您就不会退出服务器。这将允许您在整个教程中看到对代码库所做的更改的效果。</p><p id="04c5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在安装以下依赖项:</p><ul class=""><li id="6856" class="mo mp it lo b lp mi ls mj lv mq lz mr md ms mh mt mu mv mw bi translated"><a class="ae mn" href="https://www.npmjs.com/package/passport" rel="noopener ugc nofollow" target="_blank">护照</a></li><li id="1c43" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mn" href="https://www.passportjs.org/packages/passport-local/" rel="noopener ugc nofollow" target="_blank">护照-当地</a></li><li id="e8f2" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mn" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> Jwt </a></li><li id="4107" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mn" href="http://npmjs.com/package/passport-jwt" rel="noopener ugc nofollow" target="_blank">护照-智威汤逊</a></li><li id="008a" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mn" href="https://www.npmjs.com/package/sqlite3" rel="noopener ugc nofollow" target="_blank"> SQLIte3 </a></li><li id="34bf" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mn" href="https://www.npmjs.com/package/typeorm" rel="noopener ugc nofollow" target="_blank">字体</a></li><li id="354a" class="mo mp it lo b lp mx ls my lv mz lz na md nb mh mt mu mv mw bi translated"><a class="ae mn" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank"> Bcrypt </a></li></ul><p id="9d3f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您可以使用下面的命令来完成此操作:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="dbad" class="nh kv it nd b gy ni nj l nk nl">npm install --save @nestjs/passport passport passport-local @nestjs/jwt passport-jwt @nestjs/typeorm typeorm sqlite3 bcrypt</span></pre><p id="1de9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后用下面的命令安装开发依赖项:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ea0e" class="nh kv it nd b gy ni nj l nk nl">npm install --save-dev @types/passport-local @types/passport-jwt @types/bcrypt</span></pre><p id="f21f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可以在国家预防机制安装软件包的时候喝杯咖啡。一旦安装完成，我们就动手干吧。</p><h1 id="0358" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建应用程序模块</h1><p id="ff7f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有了运行应用程序所需的所有必需的包，让我们继续创建应用程序模块。为了构建一个干净且易于维护的应用程序，您将为该应用程序中实现的所有特性生成单独的模块。</p><p id="6355" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">因为这是一个电子商务应用程序，所以您将拥有身份验证、购物车、产品和订单。所有这些都将在它们自己独立的模块中。让我们从认证模块开始。</p><h2 id="3fc7" class="nh kv it bd kw nm nn dn la no np dp le lv nq nr lg lz ns nt li md nu nv lk nw bi translated">创建验证模块</h2><p id="27dd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用以下命令生成身份验证模块:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="80ee" class="nh kv it nd b gy ni nj l nk nl">nest g module auth</span></pre><p id="1b09" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上面的命令在项目的src目录中创建一个auth文件夹，其中包含必要的样板文件，并在项目根模块(<code class="fe nx ny nz nd b">app.module.ts </code>文件)中注册该模块。</p><p id="1ce2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，使用下面的命令创建一个产品、购物车和订单模块:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ba8b" class="nh kv it nd b gy ni nj l nk nl">#Create a product module<br/>nest g module product<br/><br/>#Create cart module<br/>nest g module cart<br/><br/>#Create cart module<br/>nest g module order</span></pre><p id="84c4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上面的代码将在项目的src文件夹中创建一个product、cart和order文件夹，并在项目的根app模块中注册这些模块。</p><h1 id="df8b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">设置TypeORM和SQLite数据库</h1><p id="ce65" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">安装好app模块后，设置TypeORM将您的应用程序连接到SQLite数据库并创建您的模块实体。首先，打开<code class="fe nx ny nz nd b">app.module.ts</code>，用下面的代码片段配置SQLite数据库:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="853d" class="nh kv it nd b gy ni nj l nk nl">imports: [<br/> …<br/> TypeOrmModule.forRoot({<br/>   type :"sqlite",<br/>   database: "shoppingDB",<br/>   entities: [__dirname + "/**/*.entity{.ts,.js}"],<br/>   synchronize: true<br/> })<br/>],<br/>…</span></pre><p id="56d3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，您使用TypeORM <code class="fe nx ny nz nd b">forRoot</code>将应用程序连接到SQLite数据库，指定数据库类型、数据库名称以及Nestjs可以找到模型实体的位置。</p><p id="74e7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">一旦服务器刷新，您应该看到在这个项目的根目录中创建了一个<code class="fe nx ny nz nd b">shoppingDB </code>文件。</p><h1 id="9edd" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建应用程序实体模型</h1><p id="5a2a" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有了数据库设置，让我们为应用程序模块创建实体模型。我们将从认证模块开始。使用以下命令在身份验证模块文件夹中生成一个实体文件:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="6369" class="nh kv it nd b gy ni nj l nk nl">nest generate class auth/user.entity –flat</span></pre><p id="db62" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后添加下面的代码片段，用下面的代码片段定义用户表属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="409b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在代码片段中，您导入了设置数据库表所需的装饰器。您还导入了您将很快创建的<code class="fe nx ny nz nd b">cartEntity</code>和<code class="fe nx ny nz nd b">orderEntity</code>类。使用<code class="fe nx ny nz nd b">typeorm </code>装饰器，我们定义了用户模型的数据库属性。</p><p id="c267" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，我们在用户实体与<code class="fe nx ny nz nd b">cartEntity</code>和<code class="fe nx ny nz nd b">orderEntity</code>之间创建了一对一和一对多的关系。通过这种方式，您可以将购物车商品与用户相关联。这同样适用于用户的订单。</p><p id="0de4" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，使用下面的命令创建产品实体类:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1da7" class="nh kv it nd b gy ni nj l nk nl">nest generate class product/product.entity –flat</span></pre><p id="7b4a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上述命令将在产品模块文件夹中生成一个<code class="fe nx ny nz nd b">product.entity.ts</code>文件。</p><p id="25b5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在用下面的代码片段配置产品表属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e32b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，我们配置了产品表的属性，并创建了与购物车实体的一对多关系。</p><p id="8db3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后用下面的命令创建购物车实体:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="4ab9" class="nh kv it nd b gy ni nj l nk nl">nest generate class cart/cart.entity –flat</span></pre><p id="6f4f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上面的命令将在cart模块文件夹中生成一个<code class="fe nx ny nz nd b">cart.entity.ts</code>文件。现在，将下面的代码片段添加到您为配置购物车表属性而创建的文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="7a93" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，您配置了cart表的属性，并在cart实体和用户实体之间创建了多对一关系。</p><p id="d76e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，使用下面的命令创建订单实体:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="c3a8" class="nh kv it nd b gy ni nj l nk nl">nest generate class order/order.entity –flat</span></pre><p id="7f33" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上述命令将在订单模块文件夹中生成一个<code class="fe nx ny nz nd b">order.entity.ts</code>文件。打开<code class="fe nx ny nz nd b">order.entity.ts</code>，用以下命令配置数据库表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="34f5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，您创建了用户实体之间的一对一关系以及与产品实体之间的一对多关系。</p><p id="48f2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">至此，您的数据库实体已经设置好并连接好了。现在创建您的业务逻辑来存储这些实体的记录。</p><h1 id="4804" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建应用服务</h1><p id="3090" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在为这个应用程序中的模块创建服务。在这里，您将允许管理员将产品添加到产品表，验证用户，允许用户将商店中的产品添加到购物车，并通过他们的购物车订购产品。</p><h2 id="3371" class="nh kv it bd kw nm nn dn la no np dp le lv nq nr lg lz ns nt li md nu nv lk nw bi translated">创建身份验证服务</h2><p id="82c6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">要创建身份验证服务，请运行以下命令为身份验证模块生成服务。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="cb98" class="nh kv it nd b gy ni nj l nk nl">nest generate service auth/service/auth --flat</span></pre><p id="6ac3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">上面的命令将在src/auth/service文件夹中生成一个<code class="fe nx ny nz nd b">auth.service.ts</code>文件。现在打开<code class="fe nx ny nz nd b">auth.service.ts</code>文件，添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="f51d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，您导入了<code class="fe nx ny nz nd b">InjectRepository</code>、<code class="fe nx ny nz nd b">Repository decorator</code>、<code class="fe nx ny nz nd b">JwtService</code>和<code class="fe nx ny nz nd b">bcrypt </code>模块。然后，使用<code class="fe nx ny nz nd b">InjectRepository </code>装饰器，使<code class="fe nx ny nz nd b">user.entity</code>类在auth服务中可用，提供在<code class="fe nx ny nz nd b">user.entity</code>中执行CRUD操作的方法。</p><p id="d267" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，创建一个注册方法，允许用户使用下面的代码片段在应用程序中注册:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="fa94" class="nh kv it nd b gy ni nj l nk nl">async signup(user: Users): Promise&lt;Users&gt; {<br/>       const salt = await bcrypt.genSalt();<br/>       const hash = await bcrypt.hash(user.password, salt);<br/>       user.password = hash<br/>       return await this.userRepository.save(user);<br/>   }</span></pre><p id="405e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在创建<code class="fe nx ny nz nd b">validateUser</code>方法来验证用户的详细信息，创建login方法来为经过身份验证的用户生成jwt令牌。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="b4f7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，我们可以实现我们的Passport本地身份验证策略。在auth module文件夹中创建一个名为<code class="fe nx ny nz nd b">local.strategy.ts</code>的文件，并添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="e426" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，您实现了一个<code class="fe nx ny nz nd b">passport-local</code>策略。没有配置选项，所以我们的构造函数简单地调用<code class="fe nx ny nz nd b">super()</code>而没有选项对象。</p><p id="1ffb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您还实现了<code class="fe nx ny nz nd b">validate()</code>方法。Passport将使用一组适当的特定于策略的参数为每个策略调用verify函数。对于<code class="fe nx ny nz nd b">local-strategy</code>，Passport需要一个带有以下签名的<code class="fe nx ny nz nd b">validate()</code>方法:<code class="fe nx ny nz nd b">validate(username: string, password:string): any</code>。</p><p id="6e48" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后在auth module文件夹中创建一个<code class="fe nx ny nz nd b">jwt-auth.guard.ts</code>文件，并使用下面的代码片段定义一个定制的auth guard:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="9296" class="nh kv it nd b gy ni nj l nk nl">import { Injectable } from '@nestjs/common';<br/>import { AuthGuard } from '@nestjs/passport';<br/><br/>@Injectable()<br/>export class LocalAuthGuard extends AuthGuard('local') {}</span></pre><p id="a305" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您将使用代码片段中创建的<code class="fe nx ny nz nd b">AuthGuard</code>来保护您的API路由免受未授权用户的攻击。</p><p id="ef0b" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在在auth module文件夹中创建一个<code class="fe nx ny nz nd b">jwt-strategy</code>文件来验证用户，并使用下面的代码片段为登录的用户生成jwt令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="8443" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后。在auth module文件夹的<code class="fe nx ny nz nd b">auth.module.ts</code>文件中配置jwt模块。在此之前，在同一个auth module文件夹中创建一个<code class="fe nx ny nz nd b">constants.ts</code>文件，用下面的代码片段定义一个jwt secret:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="6305" class="nh kv it nd b gy ni nj l nk nl">export const jwtConstants = {<br/>   secret: 'wjeld-djeuedw399e3-uejheuii33-4jrjjejei3-rjdjfjf',<br/>}</span></pre><p id="dc4e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您可以在生产中生成一个更安全的jwt秘密，但是出于演示的目的，我们将使用这个秘密。</p><p id="15c7" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，用下面的代码片段导入您的<code class="fe nx ny nz nd b">auth.module.ts</code>文件中所有需要的模块:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="3351" class="nh kv it nd b gy ni nj l nk nl">…<br/>import { JwtModule } from '@nestjs/jwt';<br/>import { jwtConstants } from './constants';<br/>import { JwtStrategy } from './jwt.strategy';<br/>import { PassportModule } from '@nestjs/passport';<br/>import { LocalStrategy } from './local.strategy';<br/>import { TypeOrmModule } from '@nestjs/typeorm';<br/>import { Users } from './user.entity';<br/>…</span></pre><p id="349d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后，在导入数组中，用下面的代码片段配置jwt:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="3d6c" class="nh kv it nd b gy ni nj l nk nl">…<br/>imports: [<br/>   PassportModule,<br/>   JwtModule.register({<br/>     secret: jwtConstants.secret,<br/>     signOptions: { expiresIn: '60m' },<br/>   }),<br/>…</span></pre><p id="7212" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，我们添加了<code class="fe nx ny nz nd b">PassModule</code>包来允许<code class="fe nx ny nz nd b">passport</code>处理用户的认证，并使用<code class="fe nx ny nz nd b">JwtModule register </code>方法配置了jwt。我们传递我们在常量文件中创建的秘密，并指定生成的令牌的到期时间(您可以根据用例减少或增加时间)。</p><h1 id="7ee1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建产品服务</h1><p id="c737" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">设置身份验证服务后，使用以下命令生成产品服务:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="20f0" class="nh kv it nd b gy ni nj l nk nl">nest generate service product/service/product</span></pre><p id="0630" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在在<code class="fe nx ny nz nd b">product</code>模块中打开由上述命令生成的<code class="fe nx ny nz nd b">product.service.ts</code>文件，并添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0fed" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，我们创建了CRUD服务。用户不能使用创建、更新和删除方法。只有管理员可以创建产品，删除或更新产品。</p><p id="3e28" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，打开<code class="fe nx ny nz nd b">product.module.ts</code>文件，使用下面的代码片段使产品实体可访问:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="1fc3" class="nh kv it nd b gy ni nj l nk nl">imports: [TypeOrmModule.forFeature([ProductEntity])],</span></pre><h1 id="ad0c" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建购物车服务</h1><p id="71b9" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">此时，管理员可以将产品添加到数据库中，经过身份验证的用户可以看到所有可用的产品。现在让我们允许用户将他们喜欢的商品添加到购物车中。首先，使用下面的命令生成一个购物车服务:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="cb15" class="nh kv it nd b gy ni nj l nk nl">nest generate service cart/service/cart –flat</span></pre><p id="1a06" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后打开该命令生成的<code class="fe nx ny nz nd b">cart.service.ts</code>文件，添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="6358" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您在上面的代码片段中导入了创建Nest.js服务所需的模块。因为您在购物车、用户和产品实体之间创建了关系，所以我们也在这里导入了它们。然后，创建一个构造器方法将这些实体绑定到<code class="fe nx ny nz nd b">CartService</code>类。现在，创建一个向购物车添加商品的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="1021" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，您创建了一个将<code class="fe nx ny nz nd b">productId</code>、<code class="fe nx ny nz nd b">quantity</code>和<code class="fe nx ny nz nd b">user </code>作为参数的<code class="fe nx ny nz nd b">addToCart</code>方法。然后检查<code class="fe nx ny nz nd b">user </code>的购物车中是否已经有该商品。如果是这样，您将增加数量并更新该项目的总价。否则，将商品添加到用户的购物车中。</p><p id="fc75" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，通过使用下面的代码片段在<code class="fe nx ny nz nd b">cart.module.ts</code>文件中注册<code class="fe nx ny nz nd b">cartEntity</code>、<code class="fe nx ny nz nd b">productEntity </code>、<code class="fe nx ny nz nd b">userentity</code>和<code class="fe nx ny nz nd b">productService </code>，使它们在<code class="fe nx ny nz nd b">cartService </code>中可访问:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0fc1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，创建一个<code class="fe nx ny nz nd b">getItemsInCart</code>方法，该方法将一个用户作为参数，返回属于特定用户的所有购物车。</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="d881" class="nh kv it nd b gy ni nj l nk nl">async getItemsInCard(user: string): Promise&lt;CartEntity[]&gt; {<br/>       const userCart = await this.cartRepository.find({ relations: ["item",'user'] });<br/>       return (await userCart).filter(item =&gt; item.user.username === user)<br/>   }</span></pre><h1 id="03c5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建订单服务</h1><p id="f710" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当用户完成购物后，他们可以订购购物车中的商品。使用以下命令生成订单服务:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="b6d5" class="nh kv it nd b gy ni nj l nk nl">nest generate service order/service/order –flat</span></pre><p id="59f8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在打开运行上述命令生成的<code class="fe nx ny nz nd b">order.service.ts</code>文件，并添加下面的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="a38c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">您在上面的代码片段中导入了创建Nest.js服务所需的模块。因为您在购物车、用户和产品实体之间创建了关系，所以我们也在这里导入了它们。然后，您创建了一个构造器方法来将这些实体绑定到<code class="fe nx ny nz nd b">OrderService </code>类。现在，创建一个方法来订购用户购物车中的商品。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="768d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后创建另一个方法，用下面的代码片段从数据库的订单数组中获取用户订单:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="5dbc" class="nh kv it nd b gy ni nj l nk nl">…<br/>async getOrders(user: string): Promise&lt;OrderEntity[]&gt; {<br/>       const orders = await this.orderRepository.find({ relations: ['user'] });<br/>       return orders.filter(order =&gt; order.user?.username === user)<br/>   }<br/>}</span></pre><p id="cbcd" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，打开<code class="fe nx ny nz nd b">order.module.ts</code>文件，使用下面的代码片段使用户、产品和购物车实体在<code class="fe nx ny nz nd b">orderService </code>中可访问:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h1 id="0ca7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">创建应用控制器</h1><p id="b7ad" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">成功创建应用程序服务后，让我们为应用程序服务创建API路由。</p><h2 id="4538" class="nh kv it bd kw nm nn dn la no np dp le lv nq nr lg lz ns nt li md nu nv lk nw bi translated">创建授权控制器</h2><p id="6261" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用以下命令生成一个身份验证控制器:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="7e2d" class="nh kv it nd b gy ni nj l nk nl">nest generate controller auth/controller/auth –flat</span></pre><p id="604f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在打开运行上述命令生成的<code class="fe nx ny nz nd b">auth.controller.ts</code>文件，用下面的代码片段配置授权路由:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="1ebb" class="nh kv it bd kw nm nn dn la no np dp le lv nq nr lg lz ns nt li md nu nv lk nw bi translated">创建产品控制器</h2><p id="57bf" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">配置授权控制器路由后，使用以下命令生成产品控制器:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="ca7b" class="nh kv it nd b gy ni nj l nk nl">nest generate controller product/controller/product –flat</span></pre><p id="dd50" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">打开运行上述命令生成的<code class="fe nx ny nz nd b">product.controller.ts</code>文件，用下面的代码片段配置产品路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0a46" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在上面的代码片段中，您为产品服务定义了CRUD路由。我们使用<code class="fe nx ny nz nd b">UseGuard </code>装饰器传递您的<code class="fe nx ny nz nd b">JwtAuthGaurd </code>来保护路由免受未授权用户的访问。</p><h2 id="ec93" class="nh kv it bd kw nm nn dn la no np dp le lv nq nr lg lz ns nt li md nu nv lk nw bi translated">创建购物车控制器</h2><p id="fcc1" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在，用下面的命令生成一个购物车控制器:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="d0ab" class="nh kv it nd b gy ni nj l nk nl">nest generate controller cart/controller/cart –flat</span></pre><p id="d420" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后打开运行上述命令生成的<code class="fe nx ny nz nd b">cart.controller.ts</code>文件，用下面的代码片段配置购物车路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><h2 id="76d1" class="nh kv it bd kw nm nn dn la no np dp le lv nq nr lg lz ns nt li md nu nv lk nw bi translated">创建订单控制器</h2><p id="9ec2" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">配置好购物车路线后，使用下面的命令创建一个订单控制器:</p><pre class="kj kk kl km gt nc nd ne nf aw ng bi"><span id="e63c" class="nh kv it nd b gy ni nj l nk nl">nest generate controller order/controller/order –flat</span></pre><p id="0ff9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">然后打开运行上述命令生成的<code class="fe nx ny nz nd b">order.controller.ts</code>文件，用下面的代码片段配置购物车路线:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oa ob l"/></div></figure><p id="0a11" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">至此，所有的API路由都已经配置好了。</p><h1 id="8ee3" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">测试应用程序</h1><p id="3818" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">现在让我们用Postman来测试它们。一些测试的结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oc"><img src="../Images/a25c63ab670ac44a47c4460612219529.png" data-original-src="https://miro.medium.com/v2/0*Qfv3W7wdxmYWAgUR"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oc"><img src="../Images/0bb3c569f0947bd18c4497b10d0539f0.png" data-original-src="https://miro.medium.com/v2/0*-vMnUvjL9iIB2wxR"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oc"><img src="../Images/f0b32dab48e4488082e7149ad06be5a9.png" data-original-src="https://miro.medium.com/v2/0*dAqBYP9u0oj_A-jX"/></div></figure><p id="2e29" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">请随意测试其他路线，并在Github上的这里使用代码<a class="ae mn" href="https://github.com/Claradev32/ecomerce" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="39c2" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">将Arctype连接到SQLite数据库</h1><p id="bbde" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Arctype 是一个SQL客户端和数据库管理工具，使用起来很有趣。它使您可以直观地显示数据库表，并且可以使用Arctype在数据库中执行CRUD操作目录。将Arctype连接到SQLite数据库是一个简单的过程。要开始，请按照以下步骤操作:</p><p id="b827" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">首先，启动Arctype。您将看到如下所示的屏幕，允许您添加凭据:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oc"><img src="../Images/02a0c0f8345041268b95e2602710ad5f.png" data-original-src="https://miro.medium.com/v2/0*vl2kNv1r-O_2C3vQ"/></div></figure><p id="d08c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">单击SQLite选项卡。这将打开下面的屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oc"><img src="../Images/7858074976e7ff04f37a4ab765269c73.png" data-original-src="https://miro.medium.com/v2/0*wBMlqoOYNlYZ-biq"/></div></figure><p id="af3c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">单击选择SQLite文件按钮并导航到您的项目文件夹。选择应用程序数据库文件，然后按“打开”按钮。按save按钮，您应该会看到您的数据库实体，如下面的截图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl oc"><img src="../Images/c7b2f661f7893e5703c15ea12dab571a.png" data-original-src="https://miro.medium.com/v2/0*UF0VgrANXMiDEbQu"/></div></figure><h1 id="472f" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="af8b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">通过构建一个演示项目，我们已经了解了如何使用Nestjs和SQLite数据库创建一个电子商务应用程序。首先，我们从介绍NestJS开始。然后，我们创建了一个NestJS应用程序，使用TypeORM将该应用程序连接到SQLite数据库，并执行CRUD操作。</p><p id="163c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，您已经获得了您所寻求的知识，可以随意向应用程序添加额外的功能。</p></div></div>    
</body>
</html>