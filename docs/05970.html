<html>
<head>
<title>Serving Static Assets in Django With Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与Kubernetes一起为Django的静态资产服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/static-assets-in-django-and-kubernetes-c05480d2e224?source=collection_archive---------8-----------------------#2020-08-21">https://betterprogramming.pub/static-assets-in-django-and-kubernetes-c05480d2e224?source=collection_archive---------8-----------------------#2020-08-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b32c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">姜戈、React和GKE的Kubernetes</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d3ed45f143397222223a734a5f062626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*YFG1TN4gg8Fgces8Jp9EhQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="3393" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文关注于部署静态资产的策略，特别是使用<a class="ae lr" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>工具链生成的资产。这些资产由部署在谷歌云<a class="ae lr" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> GKE </a>平台上的<a class="ae lr" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群中的<a class="ae lr" href="https://www.djangoproject.com/" rel="noopener ugc nofollow" target="_blank"> Django </a>提供服务。</p><p id="1643" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用的技术有Django，React，<a class="ae lr" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>，<a class="ae lr" href="https://cloud.google.com/sdk/gcloud" rel="noopener ugc nofollow" target="_blank"> gcloud </a>及其相关的CLIs，如<a class="ae lr" href="https://cloud.google.com/storage/docs/gsutil" rel="noopener ugc nofollow" target="_blank"> gsutil </a>。它探索了一个Docker构建管道的示例，该管道生成图像并将静态资产推送到gcloud bucket。这篇文章大量借用了谷歌自己的指南，名为“<a class="ae lr" href="https://cloud.google.com/python/django/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">在谷歌Kubernetes引擎上运行Django</a><em class="ls">”</em>(文章其余部分参考<em class="ls"> </em>为<em class="ls">Django GKE</em>)<em class="ls">。</em></p><p id="66dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们发现,《GKE指南》中有一些盲点，或者更确切地说，有一些具体的使用案例，这些都是指南中没有涉及到的，这里将解决其中的一些差距。本文中没有提到的内容都被假定在Django GKE指南中涵盖了(例如，创建GKE集群以及存储桶和数据库),所以如果您需要了解全貌，请参考该指南。</p><p id="c21b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文分为三个主要部分:React应用程序部分、Django部分以及构建和部署部分。本文中的所有内容都可以在<a class="ae lr" href="https://github.com/gitumarkk/django_react_k8s" rel="noopener ugc nofollow" target="_blank">django _ react _ k8s</a>GitHub资源库中找到。因此，我们将只看核心点，而不是进入如何设置它的细节。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9ff4" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">React应用程序设置</h1><p id="1fb8" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在<a class="ae lr" href="https://github.com/gitumarkk/django_react_k8s" rel="noopener ugc nofollow" target="_blank"> django_react_k8s </a>存储库中，静态资产可以在<code class="fe mx my mz na b">./static</code>文件夹中找到，并且是使用以下命令创建的。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b487" class="nf mb iq na b gy ng nh l ni nj">npx create-react-app static</span></pre><p id="2ddc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这将安装一个标准的React应用程序，但是我们需要做一些修改，以便在生产环境中为Django提供静态资产。第一组修改是安装允许我们定制create-react-app配置的包。可以通过运行以下命令来安装这些软件包:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="08fc" class="nf mb iq na b gy ng nh l ni nj">yarn add -D react-app-rewired customize-cra webpack-bundle-tracker@0.4.3 write-file-webpack-plugin</span></pre><ul class=""><li id="37d5" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">第一个包是<a class="ae lr" href="https://github.com/timarney/react-app-rewired" rel="noopener ugc nofollow" target="_blank"> react-app-rewired </a>，它会覆盖create-react-app webpack配置，而无需将其弹出。</li><li id="3329" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><a class="ae lr" href="https://github.com/arackaf/customize-cra" rel="noopener ugc nofollow" target="_blank"> customize-cra </a>与<a class="ae lr" href="https://github.com/timarney/react-app-rewired" rel="noopener ugc nofollow" target="_blank"> react-app-rewired </a>协同工作，并提供有用的实用程序来执行覆盖。</li><li id="56b3" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">webpack-bundle-tracker 将一些关于webpack编译过程的统计信息输出到一个文件中。在这种情况下，stats文件将提供一个接口，让Django知道已经生成的不同资产，包括它们在磁盘或云中的位置。这很有用，因为在产品构建过程中，文件名往往会被动态散列，在Django应用程序中硬编码更改会很麻烦。请注意，由于较新版本中的软件包存在缺陷，要安装的版本为0.4.3(请参见<a class="ae lr" href="https://github.com/owais/django-webpack-loader/issues/227" rel="noopener ugc nofollow" target="_blank">问题227 </a>)。</li><li id="4f4d" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><a class="ae lr" href="https://github.com/gajus/write-file-webpack-plugin" rel="noopener ugc nofollow" target="_blank">write-file-web pack-plugin</a>是一个方便的包，它在开发周期中将生成的静态文件写入文件系统。使用<code class="fe mx my mz na b">yarn start</code>允许从Django本地访问和提供静态内容。</li></ul><p id="221d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一组定制与React <code class="fe mx my mz na b">package.json</code>文件有关。它需要更新如下(阅读<a class="ae lr" href="https://github.com/timarney/react-app-rewired" rel="noopener ugc nofollow" target="_blank"> react-app-rewired </a>了解更多细节)。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="c981" class="nf mb iq na b gy ng nh l ni nj">"scripts": {<br/>  "start": "react-app-rewired start",<br/>  "build": "react-app-rewired build",<br/>  "test": "react-app-rewired test",<br/>  "eject": "react-app-rewired eject",<br/>}</span></pre><p id="47de" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了实际覆盖webpack设置，我们需要在静态文件夹中创建一个<code class="fe mx my mz na b">config-override.js</code>文件。它应该是这样的(查看<a class="ae lr" href="https://github.com/arackaf/customize-cra" rel="noopener ugc nofollow" target="_blank"> customize-cra </a>文档以了解更多细节)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8af3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您以前使用过React，或者如果您通读了各个包的文档，这应该非常简单。重要的修改在<code class="fe mx my mz na b">config.output.publicPath</code>设置中。在生产中，<code class="fe mx my mz na b">publicPath</code>应该指向Google云桶，否则，在开发周期中，应该是原始设置。此外，变量<code class="fe mx my mz na b">REACT_GCLOUD_BUCKET</code>在npm构建过程中被传入，并且是有用的，因为它允许设置不同的存储桶位置，例如，一个用于暂存，另一个用于生产部署。将<code class="fe mx my mz na b">output.path</code>改为<code class="fe mx my mz na b">buildPath</code>允许Django找到静态文件。</p><p id="ceb1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">需要对<code class="fe mx my mz na b">optimization.splitChunks.name</code>、<code class="fe mx my mz na b">optimization.runtimeChunk</code>和<code class="fe mx my mz na b">output.futureEmitAsset</code>进行配置，以使设置在Django中工作。我没有时间调查为什么会出现这种情况的根本原因。如果你知道，也许可以添加一条注释来说明原因。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0d4d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">Django设置</h1><p id="ce75" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">除了<code class="fe mx my mz na b">django-admin startproject</code>命令和生成的样板代码之外，还做了一些修改。唯一需要的Python包是<a class="ae lr" href="https://github.com/owais/django-webpack-loader" rel="noopener ugc nofollow" target="_blank"> django-webpack-loader </a>，它允许在django中透明地使用webpack。这可以通过运行<code class="fe mx my mz na b">pip install django-webpack-loader</code>来安装。如何设置它的文档可以在<a class="ae lr" href="https://github.com/owais/django-webpack-loader" rel="noopener ugc nofollow" target="_blank">django-web pack-loader</a>GitHub页面找到。然而，对于这个用例，对设置文件的修改应该如下:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="7d76" class="nf mb iq na b gy ng nh l ni nj">INSTALLED_APPS = [<br/>  ...,<br/>  'webpack_loader'<br/>]</span><span id="cf1f" class="nf mb iq na b gy oa nh l ni nj">REACT_STATIC_PATH = STATIC_PATH / 'dancelogue' / 'build'<br/>REACT_STATS_PATH = DANCELOGUE_STATIC_PATH / 'webpack-stats.json'</span><span id="a5f1" class="nf mb iq na b gy oa nh l ni nj">WEBPACK_LOADER = {<br/>  'DEFAULT': {<br/>     'CACHE': not DEBUG,<br/>     'BUNDLE_DIR_NAME': str(REACT_STATIC_PATH),<br/>     'STATS_FILE': str(REACT_STATS_PATH),<br/>     'POLL_INTERVAL': 0.1,<br/>     'TIMEOUT': None,<br/>     'IGNORE': [r'.+\.hot-update.js', r'.+\.map']<br/>  },<br/>}</span></pre><p id="c95d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，将<code class="fe mx my mz na b"> webpack_loader</code>包添加到已安装的应用程序中。接下来，使用<code class="fe mx my mz na b">WEBPACK_LOADER</code>变量设置配置加载器行为。在字典中，<code class="fe mx my mz na b">BUNDLE_DIR_NAME</code>应该指向React构建文件夹，即指向<code class="fe mx my mz na b">static/build/</code>而不是根静态文件夹，因为我们只对React构建过程的输出感兴趣。在构建文件夹中，可以找到使用React部分的<code class="fe mx my mz na b">webpack-bundle-tracker</code>生成的<code class="fe mx my mz na b">webpack-stats.json</code>。这个配置允许Django提供在<code class="fe mx my mz na b">yarn start</code>或<code class="fe mx my mz na b">yarn build</code>期间生成的散列文件。</p><p id="e499" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，Django需要知道收集静态文件的位置，以及在生产中从哪里提供这些文件。这是通过将以下内容添加到<code class="fe mx my mz na b">settings.py</code>文件来完成的。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="69af" class="nf mb iq na b gy ng nh l ni nj">STATICFILES_DIRS = [ REACT_STATIC_PATH / 'static' ]<br/>STATIC_ROOT = BASE_DIR / 'collectstatic'</span><span id="1a5d" class="nf mb iq na b gy oa nh l ni nj">if IS_DEPLOYED:<br/>  bucket = os.environ.get('GCLOUD_ASSET_BUCKET')<br/>  STATIC_URL = f'https://storage.googleapis.com/{bucket}/static/' else:<br/> STATIC_URL = '/static/'</span></pre><p id="9351" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mx my mz na b">STATICFILES_DIRS</code>告诉Django感兴趣的静态文件的位置，并被设置为React构建路径。哪该下决心<code class="fe mx my mz na b">static/build/static</code>。这有点复杂，但事实就是如此。接下来，<code class="fe mx my mz na b">STATIC_ROOT</code>非常简单，它只是告诉Django将静态文件收集到哪里。重要的一点是在部署时给Django提供静态文件的位置，如<code class="fe mx my mz na b">IS_DEPLOYED</code>变量所示。在这里，<code class="fe mx my mz na b">GCLOUD_ASSET_BUCKET</code>被设置为一个环境变量，在将staging从production buckets中分离出来时非常有用。<a class="ae lr" href="https://pypi.org/project/python-dotenv/" rel="noopener ugc nofollow" target="_blank"> python-dotenv </a>包可用于存储和读取环境变量。检查<a class="ae lr" href="https://github.com/gitumarkk/django_react_k8s" rel="noopener ugc nofollow" target="_blank"> django_react_k8s </a>以获得更多关于<code class="fe mx my mz na b">env</code>文件应该在<code class="fe mx my mz na b">./env/.env</code>下的详细信息。注意使用了<a class="ae lr" href="https://realpython.com/python-f-strings/" rel="noopener ugc nofollow" target="_blank"> python-f-strings </a>格式，所以至少需要Python 3.6。</p><p id="c04a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后需要修改的是Django应用程序的基本HTML文件，如下所示。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="209d" class="nf mb iq na b gy ng nh l ni nj">{% load render_bundle from webpack_loader %}</span><span id="5e76" class="nf mb iq na b gy oa nh l ni nj">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>    {% render_bundle 'vendor' %}<br/>    {% render_bundle 'main' %}<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7898" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更多可用的配置可以通过阅读django-webpack-loader 文档找到。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e190" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">测试设置</h1><p id="bf41" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在本地环境中测试应用程序非常简单。首先，运行<code class="fe mx my mz na b">yarn start</code>以确保它正在运行，默认的create-react-app页面可以在<code class="fe mx my mz na b"><a class="ae lr" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a></code>上看到。下一步是运行<code class="fe mx my mz na b">python manage.py runserver</code>，它应该在默认端口<code class="fe mx my mz na b">8000</code>上运行。导航到<code class="fe mx my mz na b"><a class="ae lr" href="http://localhost:8000/" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/</a></code>应该显示与默认的create-react-app页面完全相同的页面。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="90cd" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">构建和部署</h1><p id="10e5" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">在这一节中，与Django GKE指南有所重叠，后者更深入地介绍了如何部署到Kubernetes。本节将更多地关注于确保docker映像构建正确，一旦部署到集群中，就可以为静态资产提供服务。</p><h2 id="e58f" class="nf mb iq bd mc ob oc dn mg od oe dp mk le of og mm li oh oi mo lm oj ok mq ol bi translated">码头工人</h2><p id="27f8" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">首先要看的是<code class="fe mx my mz na b">Dockerfile</code>，如下:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="84a2" class="nf mb iq na b gy ng nh l ni nj">FROM python:3.6.11-slim<br/>ENV PYTHONUNBUFFERED 1<br/>RUN mkdir /django_react_k8s<br/>WORKDIR /django_react_k8s<br/>RUN pip install --upgrade pip<br/>COPY requirements.txt /django_react_k8s/<br/>RUN pip install -r requirements.txt<br/>COPY . /django_react_k8s/<br/>CMD python manage.py runserver 0.0.0.0:8000</span></pre><p id="8577" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个相当标准的配置，所以我不会详细介绍它。</p><p id="5598" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下一个文件是<code class="fe mx my mz na b">.dockerignorefile</code>。这很重要，因为它有助于保持docker图像较小，并防止敏感数据进入文件。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="56e2" class="nf mb iq na b gy ng nh l ni nj">... # standard excludes e.g. .git and such<br/># custom<br/>*Dockerfile*<br/>**/node_modules<br/>static<br/>!static/build/webpack-stats.json<br/>collectstatic<br/># env</span></pre><p id="1128" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这包括常见的忽略模式，以及一些特定于项目的模式。出于显而易见的原因，主要的例外是<code class="fe mx my mz na b">node_modules</code>。</p><p id="2df8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">静态文件夹被忽略，除了由感叹号指示的<code class="fe mx my mz na b">webpack-stats.json</code>文件。<code class="fe mx my mz na b">webpack-stats.json</code>是<code class="fe mx my mz na b">docker image</code>需要包含的唯一静态文件。其他一切，包括构建的静态资产的位置，都包含在stats文件中，如<code class="fe mx my mz na b">publicPath</code>中所定义的。这意味着如果中间有一个npm构建步骤，理论上每个Docker容器应该有一个唯一的stats文件。在实践中，我通常还会将<code class="fe mx my mz na b">env</code>文件添加到<code class="fe mx my mz na b">ignore</code>文件中，因为它包含API密钥等敏感数据，然后根据需要将其作为Kubernetes秘密或配置映射。</p><h2 id="076e" class="nf mb iq bd mc ob oc dn mg od oe dp mk le of og mm li oh oi mo lm oj ok mq ol bi translated">构建脚本</h2><p id="8163" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">下面是一个构建和部署管道的基本示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a2f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">构建阶段的步骤如下:</p><ul class=""><li id="9d56" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">使用<code class="fe mx my mz na b">rm -rf static/build/*</code>清理React构建文件夹。这可以防止旧文件在<code class="fe mx my mz na b">collectstatic</code>阶段被复制，并保持精简。</li><li id="bda2" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">通过删除所有已编译的文件来清理Python环境。</li><li id="eeac" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">运行npm构建命令，即<code class="fe mx my mz na b">REACT_GCLOUD_BUCKET={get_bucket(env)} npm run — prefix static build</code>。静态文件的桶是作为环境变量提供的，即<code class="fe mx my mz na b">REACT_GCLOUD_BUCKET</code>。由于该命令是在静态文件夹之外运行的，因此需要使用<code class="fe mx my mz na b">--prefix</code>参数来指示构建源，即静态文件的位置。这将在<code class="fe mx my mz na b">./static/build/</code>下生成静态文件，只有<code class="fe mx my mz na b">./static/build/webpack-stats.json</code>被复制到docker映像中。</li><li id="ac5a" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">然后构建docker映像。这是一个相当标准的流程，即<code class="fe mx my mz na b">docker build -t {get_docker_image(tag, env)} .</code>。</li></ul><p id="ab3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">部署阶段如下:</p><ul class=""><li id="3137" class="nk nl iq kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">清理静态文件夹，防止旧文件转移到服务器，即<code class="fe mx my mz na b">rm -rf collectstatic/*</code>。</li><li id="c930" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">使用<code class="fe mx my mz na b">python manage.py collectstatic -i node_modules — noinput</code>收集静态文件。忽略<code class="fe mx my mz na b">node_modules</code>很重要，因为它不再需要，并且在上传过程中为bucket增加了大量冗余。</li><li id="ed10" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">使用<code class="fe mx my mz na b">gsutil -m cp -Z -a public-read -r ./collectstatic/* gs://{get_bucket(env)}/static</code>将文件复制到gcloud bucket。该部分不同于<a class="ae lr" href="https://cloud.google.com/python/django/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> Django GKE指南</a>中规定的方法，该指南建议执行<code class="fe mx my mz na b">rsync</code>命令，该命令仅复制变更，而不是执行<code class="fe mx my mz na b">cp</code>命令，该命令执行完整的复制和替换。尽管<code class="fe mx my mz na b">rsync</code>可以工作，但是<code class="fe mx my mz na b">cp</code>在这个用例中更胜一筹，这完全是因为<code class="fe mx my mz na b">-Z</code>参数。根据文档，<code class="fe mx my mz na b">-Z</code>将gzip内容编码应用于文件上传。它不仅应用gzip编码，而且每当用户请求文件时，Google都会根据客户端提供的内容类型返回正确的文件。因此，不再需要使用webpack配置文件来生成gzipped资产，或者使用nginx(或类似的服务器)配置来提供gzipped资产——所有这些都为您完成了。第二个不同点是<code class="fe mx my mz na b">-a public-read</code>参数。Django GKE指南中没有提到这一点，但是它使得你复制到桶中的单个对象是公开的，而桶中的其他所有东西都是私有的。</li><li id="edb9" class="nk nl iq kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">最后，将docker图像推送到桶中，即<code class="fe mx my mz na b">docker push {get_docker_image(tag, env)}</code>。</li></ul><p id="b1dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是构建和部署阶段。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f3ad" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">库伯内特斯</h1><p id="e858" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">这一部分将简要强调Kubernetes部署阶段。因为它已经在<a class="ae lr" href="https://cloud.google.com/python/django/kubernetes-engine" rel="noopener ugc nofollow" target="_blank">姜戈GKE指南</a>中有所涉及，所以不会有太多关于它的细节。为了简单起见，在这种情况下的例子将是单个pod和指向该pod的服务，其中规范文件是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="70f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这非常简单，可以部署到Minikube集群(参见我以前关于<a class="ae lr" href="https://medium.com/@markgituma/kubernetes-local-to-production-with-django-2-docker-and-minikube-ba843d858817" rel="noopener"> Docker和Minikube </a>的文章)或GKE集群，正如<a class="ae lr" href="https://cloud.google.com/python/django/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> Django GKE指南</a>中所强调的。</p><p id="e896" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些文件位于本文的示例报告中，可以通过从根文件夹运行以下命令部署到集群中:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b620" class="nf mb iq na b gy ng nh l ni nj">kubectl apply -f k8/</span></pre><p id="cce7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您遵循GKE指南并已部署到集群，为了在不创建负载平衡器等的情况下查看部署的pod的运行情况，请运行以下<a class="ae lr" href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/" rel="noopener ugc nofollow" target="_blank">端口转发</a>命令:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="1ed2" class="nf mb iq na b gy ng nh l ni nj">kubectl port-forward &lt;name_of_pod&gt; 8000:8000</span></pre><p id="76d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您应该会在<code class="fe mx my mz na b">http://localhost:8000/</code>的开发环境中看到相同的结果。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="e905" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="3995" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">这篇文章很好地概述了在Django和Kubernetes应用程序中部署静态资产的一种方法。这种策略不仅与Kubernetes相关，也可以用于裸机安装。</p><p id="9a33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">主要的焦点是将静态内容从Django应用程序上下文中分离出来，从而创建一个关注点分离，其中一些责任被转移到Google云平台。该平台已针对内容交付进行了优化，因此应用程序可以专注于其他流量。不需要担心缓存失效，因为静态文件是散列的。因此，每当包含<code class="fe mx my mz na b">webpack-stats.json</code>文件的新部署推出时，假设文件中定义的资产存在于bucket中，用户将总是获得新资产，而旧资产将继续存在，以防需要对部署进行回滚。</p><p id="043d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你有任何问题或需要澄清的事情，你可以在<a class="ae lr" href="https://mbele.io/mark" rel="noopener ugc nofollow" target="_blank">https://mbele.io/mark</a>和我预约时间</p></div></div>    
</body>
</html>