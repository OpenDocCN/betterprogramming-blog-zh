<html>
<head>
<title>Find the Evil Commit in Your iOS Application With Git Bisect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Git二分查找iOS应用程序中的恶意提交</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/find-the-evil-commit-in-your-ios-application-with-git-bisect-488b1f414d98?source=collection_archive---------11-----------------------#2022-10-17">https://betterprogramming.pub/find-the-evil-commit-in-your-ios-application-with-git-bisect-488b1f414d98?source=collection_archive---------11-----------------------#2022-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e63e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用这个奇妙的功能节省时间</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9f0123e3ac9c327e53b45ac58fc96d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n2N7_2vcC9nb2Y19"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@jeshoots?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JESHOOTS.COM</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="8d4c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">动机</h1><p id="2639" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">了解如何轻松找到在iOS应用程序中引入错误的提交。</p><p id="a950" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您与许多开发人员一起在一个大型存储库上工作，并且每天都有复杂的提交，下面的技术会很有帮助。一旦找到提交，您就可以分析文件更改以确定bug的根本原因。</p><h1 id="66b8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">技术</h1><p id="982b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Git是一个源代码控制管理(SCM)系统，它提供了一个叫做<code class="fe mp mq mr ms b">git bisect</code>的有用命令。</p><blockquote class="mt mu mv"><p id="621b" class="lo lp mw lq b lr mk jr lt lu ml ju lw mx mm lz ma my mn md me mz mo mh mi mj ij bi translated"><em class="iq">这个命令使用二分搜索法算法来查找项目历史中哪个提交引入了bug。首先告诉它一个已知包含bug的“坏”提交，以及一个已知在引入bug之前的“好”提交。</em></p><p id="5487" class="lo lp mw lq b lr mk jr lt lu ml ju lw mx mm lz ma my mn md me mz mo mh mi mj ij bi translated">然后git二等分在这两个端点之间选择一个提交，并询问您所选择的提交是“好”还是“坏”它继续缩小范围，直到找到引入更改的确切提交。</p></blockquote><p id="bb4f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以执行一个手动测试来检查它对于每个迭代是“好”还是“坏”的提交，但是这是非常乏味的。相反，你能写一个测试或者脚本来检测这个错误吗？通常，即使您不知道是什么代码导致了问题，这也是可能的。</p><blockquote class="mt mu mv"><p id="5fb7" class="lo lp mw lq b lr mk jr lt lu ml ju lw mx mm lz ma my mn md me mz mo mh mi mj ij bi translated"><em class="iq">如果你有一个可以判断当前源代码好坏的脚本，你可以通过发出</em> <code class="fe mp mq mr ms b"><em class="iq">$ git bisect run my_script arguments</em></code>命令来对分</p></blockquote><p id="8723" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一旦您增强了现有的<code class="fe mp mq mr ms b">XCTestCase</code>，您就可以使用<code class="fe mp mq mr ms b">git bisect run xcodebuild test ...</code>通过UI测试来检测bug。然后Git可以自动执行每一次迭代，并会溢出第一次“坏”提交的信息。</p><p id="978a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了可读性，我建议将<code class="fe mp mq mr ms b">xcodebuild</code>命令外包到<code class="fe mp mq mr ms b">Makefile</code>中。</p><p id="0c6e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下面是一个<code class="fe mp mq mr ms b">Makefile</code>的例子:</p><pre class="kg kh ki kj gt na ms nb nc aw nd bi"><span id="e93c" class="ne kx iq ms b gy nf ng l nh ni">uitest:<br/>    xcodebuild test \<br/>      -project FlakyApp.xcodeproj \<br/>      -scheme FlakyAppUITests \<br/>      -sdk iphonesimulator \<br/>      -destination 'platform=iOS Simulator,name=iPhone 13'</span></pre><p id="6454" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在可以调用<code class="fe mp mq mr ms b">git bisect run make uitest</code>:)。</p><p id="4660" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">外包的另一个好处是，你可以调整<code class="fe mp mq mr ms b">xcodebuild</code>命令，仍然可以稳定地触发<code class="fe mp mq mr ms b">git bisect run</code>。例如，让我们通过指定<code class="fe mp mq mr ms b">-only-testing</code>选项，只运行一个测试来检测bug。</p><pre class="kg kh ki kj gt na ms nb nc aw nd bi"><span id="0199" class="ne kx iq ms b gy nf ng l nh ni">uitest:<br/>    xcodebuild test \<br/>      -project FlakyApp.xcodeproj \<br/>      -scheme FlakyAppUITests \<br/>      -sdk iphonesimulator \<br/>      -destination 'platform=iOS Simulator,name=iPhone 13' \<br/>      -only-testing "FlakyAppUITests/FlakyAppUITests/testExample"</span></pre><p id="37c8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个改动会让对分执行更快，你还是可以用<code class="fe mp mq mr ms b">git bisect run make uitest</code>触发。</p><h1 id="a842" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">例子</h1><p id="5572" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">以下简化的存储库包含一个iOS应用程序，在某个时候引入了一个bug。</p><div class="nj nk gp gr nl nm"><a href="https://github.com/MarcoEidinger/GitBisectXcodebuild" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fo"><div class="no ab np cl cj nq"><h2 class="bd ir gy z fp nr fr fs ns fu fw ip bi translated">GitHub——MarcoEidinger/gitbictionXcodebuild:演示如何使用git二分法进行xcodebuild测试</h2><div class="nt l"><h3 class="bd b gy z fp nr fr fs ns fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nu l"><p class="bd b dl z fp nr fr fs ns fu fw dk translated">github.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kp nm"/></div></div></a></div><p id="e768" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们只知道最后一个“好的”提交(<code class="fe mp mq mr ms b">2de359e</code>)和一个“坏的”提交，应用程序无法按预期工作(<code class="fe mp mq mr ms b">6e02ff9</code>)。</p><p id="71f9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个例子中，bug是SwiftUI Toggle的值不再是<code class="fe mp mq mr ms b">true</code>。我们可以更新<code class="fe mp mq mr ms b">FlakyAppUITests.swift</code>中的UI测试来检查这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/c70b0c4e1aa8a3bf21214d422077482b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EfdHU9gb3Tp-BIMeoIeS-g.png"/></div></div></figure><p id="30d9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，让我们开始平分提交。</p><pre class="kg kh ki kj gt na ms nb nc aw nd bi"><span id="e642" class="ne kx iq ms b gy nf ng l nh ni">git bisect start 6e02ff9f1e319fe095a9dcfec092f76c3005355c 2de359e2ce524d9d4e8276595cc3c70ae9311996</span></pre><p id="1cce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Git告诉我们，要找到罪魁祸首，大致需要两步。</p><pre class="kg kh ki kj gt na ms nb nc aw nd bi"><span id="8d4b" class="ne kx iq ms b gy nf ng l nh ni">Bisecting: 3 revisions left to test after this (roughly 2 steps)<br/>[7e68c4102f3d68310285fe58acbcf9d21503ff51] maybe</span></pre><p id="6ed9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后，我们告诉Git为每次迭代运行<code class="fe mp mq mr ms b">make uitest</code>。</p><pre class="kg kh ki kj gt na ms nb nc aw nd bi"><span id="0892" class="ne kx iq ms b gy nf ng l nh ni">git bisect run make uitest</span></pre><p id="c781" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Git开始处理…</p><pre class="kg kh ki kj gt na ms nb nc aw nd bi"><span id="0e7b" class="ne kx iq ms b gy nf ng l nh ni">** TEST SUCCEEDED ** [9.950 sec]</span><span id="4f5f" class="ne kx iq ms b gy oc ng l nh ni">Bisecting: 1 revision left to test after this (roughly 1 step)<br/>[65c0d1ac4489241306692be4a7addbb38703aff3] maybe !</span><span id="5634" class="ne kx iq ms b gy oc ng l nh ni">...</span><span id="6b7d" class="ne kx iq ms b gy oc ng l nh ni">** TEST FAILED **</span><span id="9d29" class="ne kx iq ms b gy oc ng l nh ni">make: *** [uitest] Error 65<br/>Bisecting: 0 revisions left to test after this (roughly 0 steps)<br/>[c8da8ee9fa48736b63bdbec0e1e1a179612396b3] maybe</span><span id="942a" class="ne kx iq ms b gy oc ng l nh ni">...</span><span id="f326" class="ne kx iq ms b gy oc ng l nh ni">65c0d1ac4489241306692be4a7addbb38703aff3 is the first bad commit<br/>commit 65c0d1ac4489241306692be4a7addbb38703aff3<br/>Author: Marco Eidinger &lt;<a class="ae kv" href="mailto:eidingermarco@gmail.com" rel="noopener ugc nofollow" target="_blank">eidingermarco@gmail.com</a>&gt;<br/>Date:   Wed Apr 20 08:45:34 2022 +0200</span><span id="6574" class="ne kx iq ms b gy oc ng l nh ni">maybe !</span><span id="23ae" class="ne kx iq ms b gy oc ng l nh ni">FlakyApp/ContentView.swift | 2 +-<br/> 1 file changed, 1 insertion(+), 1 deletion(-)</span></pre><p id="deef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">瞧，我们知道第一个错误提交是<code class="fe mp mq mr ms b">65c0d1a</code>！</p><p id="2193" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们知道了哪个提交是罪魁祸首，我们调用下面的提交来返回到最初的<code class="fe mp mq mr ms b">HEAD</code>。</p><pre class="kg kh ki kj gt na ms nb nc aw nd bi"><span id="e761" class="ne kx iq ms b gy nf ng l nh ni">git bisect reset</span></pre><p id="fecf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意:在这个简化的例子中，我们可以使用<code class="fe mp mq mr ms b">git blame</code>来识别提交和根本原因，因为提交很少，而且提交非常小。但是想象一下，有50次提交，每一次都有10次以上的文件更改，每次都有100行！</p><ul class=""><li id="9663" class="od oe iq lq b lr mk lu ml lx of mb og mf oh mj oi oj ok ol bi translated">当您不知道是什么代码导致了问题，并且正在处理一个大型且频繁更新的项目时,<code class="fe mp mq mr ms b">git bisect</code>是完美的选择。</li><li id="bf66" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated">利用测试来自动化<code class="fe mp mq mr ms b">git bisect</code>。</li><li id="2c93" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated">对于iOS应用程序，使用<code class="fe mp mq mr ms b">xcodebuild test</code>。</li><li id="197c" class="od oe iq lq b lr om lu on lx oo mb op mf oq mj oi oj ok ol bi translated">对于Swift包，您也可以使用<code class="fe mp mq mr ms b">xcodebuild</code>或<code class="fe mp mq mr ms b">swift test</code>。</li></ul></div><div class="ab cl or os hu ot" role="separator"><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow ox"/><span class="ou bw bk ov ow"/></div><div class="ij ik il im in"><p id="e565" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="mw">最初发布于</em><a class="ae kv" href="https://blog.eidinger.info/git-bisect-run-xcodebuild" rel="noopener ugc nofollow" target="_blank"><em class="mw">https://blog . ei dinger . info</em></a><em class="mw">。</em></p></div></div>    
</body>
</html>