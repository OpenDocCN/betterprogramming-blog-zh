<html>
<head>
<title>How to Handle Errors With Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Express处理错误</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/error-handling-with-express-6b8deedf5438?source=collection_archive---------7-----------------------#2020-02-14">https://betterprogramming.pub/error-handling-with-express-6b8deedf5438?source=collection_archive---------7-----------------------#2020-02-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="73ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">查看默认事件处理程序以及如何使用自定义处理程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/efcf286adee2bee328230547a32d1da1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0kBFiupuAolMDqaRrPPrw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jordanmcgee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔丹·麦基</a>在<a class="ae ky" href="https://unsplash.com/s/photos/unexpected?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="2f8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与任何其他应用程序一样，我们必须让<a class="ae ky" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>应用程序准备好处理错误，如意外输入或文件错误。</p><p id="59ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究如何用Express处理错误。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="964a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">捕捉错误</h1><p id="f70a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">错误处理是同步和异步处理出现的任何错误的过程。Express附带了一个默认的错误处理程序，这样我们就不必自己编写了。</p><p id="5458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们在路由处理程序中抛出如下错误:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7544" class="ne md it na b gy nf ng l nh ni">app.get('/', (req, res, next) =&gt; {<br/>  throw new Error('error');<br/>});</span></pre><p id="3962" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快车会赶上它并继续前进。我们应该看到<code class="fe nj nk nl na b">error</code>而不是应用崩溃。</p><p id="cb9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于异步错误，我们必须调用<code class="fe nj nk nl na b">next</code>来传递错误，表达如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="13d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将在<code class="fe nj nk nl na b">setTimeout</code>回调中抛出一个错误，并且<code class="fe nj nk nl na b">catch</code>块通过传递错误的<code class="fe nj nk nl na b">next</code>调用来调用内置的错误处理程序。</p><p id="fa22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到<code class="fe nj nk nl na b">error</code>而不是应用崩溃。</p><p id="636d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们必须抓住被拒绝的承诺。我们可以这样做:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="a013" class="ne md it na b gy nf ng l nh ni">app.get('/', (req, res, next) =&gt; {<br/>  Promise<br/>    .reject('error')<br/>    .catch(next)<br/>});</span></pre><p id="83d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，使用<code class="fe nj nk nl na b">async</code>和<code class="fe nj nk nl na b">await</code>语法，我们可以编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b5ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到<code class="fe nj nk nl na b">error</code>显示出来，而不是应用程序崩溃，出现堆栈跟踪。</p><p id="a42d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的逻辑也适用于具有事件处理程序链的路由。我们可以如下调用<code class="fe nj nk nl na b">next</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="055f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该看到<code class="fe nj nk nl na b">error</code>和堆栈跟踪一起显示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/c66fb1e7e5b83ab734b24e397261661a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l6Vj9egGQz71_ETu"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ericmuhr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃里克·穆尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f18f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">默认错误处理程序</h1><p id="e9ea" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们调用<code class="fe nj nk nl na b">next</code>时，默认的错误处理程序捕捉错误，而不是用自定义的错误处理程序来处理它。</p><p id="6249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生产环境中不显示堆栈跟踪。如果我们想发送一个不同的默认响应，我们必须编写自己的错误处理程序。</p><p id="7113" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">路由处理程序、中间件和错误处理程序之间的唯一区别是，错误处理程序在包含错误数据的请求参数之前有一个<code class="fe nj nk nl na b">err</code>参数。</p><p id="f868" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以编写一个带有自定义事件处理程序的简单路由，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6dc2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，我们在路由下面有错误处理程序。顺序很重要。它必须位于我们想要处理的所有路由之下，以便调用错误处理程序。</p><p id="d8bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以编写多个自定义错误处理程序，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="714a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面我们知道的是，如果第一个错误处理程序中的<code class="fe nj nk nl na b">req.xhr</code>为真，那么它将发送<code class="fe nj nk nl na b">Fail!</code>响应，而不会继续第二个错误处理程序。否则通过调用<code class="fe nj nk nl na b">next</code>调用第二个。</p><p id="a48e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，如果我们在路由处理程序中的<code class="fe nj nk nl na b">setTimeout</code>前添加<code class="fe nj nk nl na b">req.foo = true</code>，那么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到<code class="fe nj nk nl na b">Fail!</code>。否则，我们得到<code class="fe nj nk nl na b">Error!</code>。</p><p id="2852" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">调用<code class="fe nj nk nl na b">next</code>会跳到错误处理程序，即使链中还有其他路由处理程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="adec" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="da50" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了处理错误，如果没有定义自定义事件处理程序，我们应该调用<code class="fe nj nk nl na b">next</code>将错误处理委托给默认事件处理程序。</p><p id="576f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以通过创建一个在<code class="fe nj nk nl na b">req</code>、<code class="fe nj nk nl na b">res</code>和<code class="fe nj nk nl na b">next</code>之前有<code class="fe nj nk nl na b">err</code>参数的函数来定义我们自己的错误处理函数。<code class="fe nj nk nl na b">err</code>参数有从<code class="fe nj nk nl na b">next</code>传来的错误对象。</p><p id="e633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误处理程序必须放在所有常规路由处理代码之后，这样它们才能运行。</p><p id="97a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以有多个错误处理器。如果我们对它调用<code class="fe nj nk nl na b">next</code>，那么它将继续下一个错误处理程序。</p></div></div>    
</body>
</html>