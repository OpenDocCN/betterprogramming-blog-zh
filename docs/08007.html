<html>
<head>
<title>The 7 Different Forms of OperationQueue in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中7种不同形式的操作队列</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-beauty-of-operationqueue-in-swift-8398fc5fb013?source=collection_archive---------5-----------------------#2021-03-15">https://betterprogramming.pub/the-beauty-of-operationqueue-in-swift-8398fc5fb013?source=collection_archive---------5-----------------------#2021-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6b2e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">OperationQueue中的DispatchGroup、DispatchWorkItem、DispatchWorkItemFlags、DispatchSemaphore、addDependency和addBarrierBlock</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b4a4e1feef2834ba697c8587ca80f4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U7mcLUX837dWLeju"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Nathalie Désirée Mottet 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="676d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">OperationQueue</code>类是GCD(大中央调度)上的高级抽象。它根据优先级和就绪状态执行排队的<code class="fe lv lw lx ly b">Operation</code>对象。本文描述了在<code class="fe lv lw lx ly b">OperationQueue</code>中管理异步任务的不同方法的优点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="871b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.使用OperationQueue的DispatchGroup</h1><p id="085b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了等待一组排队的任务，我们可以使用<code class="fe lv lw lx ly b">OperationQueue</code>的<code class="fe lv lw lx ly b">DispathGroup</code>。根据苹果的文档:</p><blockquote class="nd ne nf"><p id="9524" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">分派组是一种阻塞线程直到一个或多个任务完成执行的方式。您可以在所有指定任务完成之前无法取得进展的地方使用此行为。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="2dda" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">创建该组是为了等待<code class="fe lv lw lx ly b">asyncBlock</code>任务。</li><li id="cc7f" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">队列将每个异步任务添加到组中，以便在任务完成时处理结果。</li></ul><p id="fadc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="c668" class="oe mh it ly b gy of og l oh oi">async block #1 start</span><span id="5701" class="oe mh it ly b gy oj og l oh oi">async block #2 start</span><span id="092f" class="oe mh it ly b gy oj og l oh oi">async block #2 end</span><span id="4ed0" class="oe mh it ly b gy oj og l oh oi">async block #1 end</span><span id="cfc0" class="oe mh it ly b gy oj og l oh oi">async block #3 start</span><span id="146c" class="oe mh it ly b gy oj og l oh oi">async block #3 end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c5ee" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.DispatchGroup的enter()、leave()和wait()</h1><p id="4921" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了管理异步任务，我们还可以注册<code class="fe lv lw lx ly b">DispathGroup</code>的<code class="fe lv lw lx ly b">enter</code>、<code class="fe lv lw lx ly b">leave</code>和<code class="fe lv lw lx ly b">wait</code>事件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4183" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个想法很简单，对吗？创建一个组，注册一堆<code class="fe lv lw lx ly b">enter</code>事件，任务完成后注册<code class="fe lv lw lx ly b">leave</code>。所有工作完成后，小组会自动执行您需要它执行的操作！</p><p id="4b58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="fc2a" class="oe mh it ly b gy of og l oh oi">async block #1 start</span><span id="ee90" class="oe mh it ly b gy oj og l oh oi">async block #2 start</span><span id="b202" class="oe mh it ly b gy oj og l oh oi">async block #1 end</span><span id="f592" class="oe mh it ly b gy oj og l oh oi">async block #2 end</span><span id="2bdc" class="oe mh it ly b gy oj og l oh oi">async block #3 start</span><span id="034a" class="oe mh it ly b gy oj og l oh oi">async block #3 end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ba01" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.使用DispatchWorkItemFlags障碍</h1><p id="a021" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">DispatchWorkItemFlags</code>是一个工作项目的一组行为。包含<code class="fe lv lw lx ly b">assignCurrentContext</code>、<code class="fe lv lw lx ly b">barrier</code>、<code class="fe lv lw lx ly b">detached</code>、<code class="fe lv lw lx ly b">enforceQoS</code>、<code class="fe lv lw lx ly b">inheritQos</code>等。<code class="fe lv lw lx ly b">barrier</code>表示提交的工作项作为屏障。</p><blockquote class="nd ne nf"><p id="3761" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">在屏障之前提交的工作项目执行到完成，此时屏障工作项目执行。一旦障碍工作项目完成，队列返回到在障碍之后提交的计划工作项目。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="127b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="f6d6" class="oe mh it ly b gy of og l oh oi">async block #1 start</span><span id="7fd8" class="oe mh it ly b gy oj og l oh oi">async block #2 start</span><span id="2b8e" class="oe mh it ly b gy oj og l oh oi">async block #1 end</span><span id="158e" class="oe mh it ly b gy oj og l oh oi">async block #2 end</span><span id="b2e3" class="oe mh it ly b gy oj og l oh oi">async block #3 start</span><span id="6ad9" class="oe mh it ly b gy oj og l oh oi">async block #3 end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="85cf" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.使用带有屏障标志的DispatchWorkItem</h1><p id="d52d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">DispatchWorkItem</code>是在一个调度队列上执行的，或者与一个具有封装工作的调度组一起执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="4568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="454f" class="oe mh it ly b gy of og l oh oi">async block #1 start</span><span id="a4f9" class="oe mh it ly b gy oj og l oh oi">async block #2 start</span><span id="8af1" class="oe mh it ly b gy oj og l oh oi">async block #1 end</span><span id="21d5" class="oe mh it ly b gy oj og l oh oi">async block #2 end</span><span id="17ee" class="oe mh it ly b gy oj og l oh oi">async block #3 start</span><span id="6859" class="oe mh it ly b gy oj og l oh oi">async block #3 end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c8db" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.使用调度信号量</h1><p id="ec0b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">DispatchSemaphore</code>包含value参数，用于控制在给定时刻可以执行的线程数量。当调用<code class="fe lv lw lx ly b">DispatchSemaphore</code>的<code class="fe lv lw lx ly b">signal()</code>方法时，该值增加1，当调用<code class="fe lv lw lx ly b">wait()</code>方法时，该值减少1。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><ul class=""><li id="b12e" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated"><code class="fe lv lw lx ly b">DispatchSemaphore</code>的初始值为2。它允许两个线程同时执行。</li><li id="b91d" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">当调用第4行的第一个<code class="fe lv lw lx ly b">semaphor.wait()</code>时，值为1。</li><li id="1e2b" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">从值≥ 0开始执行<code class="fe lv lw lx ly b">aysncBlock(id: 1)</code>。</li><li id="9d18" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">调用第10行的第二个<code class="fe lv lw lx ly b">semaphor.wait()</code>时，值为0。</li><li id="b1b5" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">由于值≥ 0，所以执行<code class="fe lv lw lx ly b">aysncBlock(id: 2)</code>。</li><li id="f1a0" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">调用第16行的第二个<code class="fe lv lw lx ly b">semaphor.wait()</code>时，值为-1。</li><li id="7167" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">由于值&lt;为0，因此<code class="fe lv lw lx ly b">aysncBlock(id: 3)</code>正在等待。</li><li id="77be" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated"><code class="fe lv lw lx ly b">aysncBlock(id: 1)</code>在两秒后结束，由于第6行的<code class="fe lv lw lx ly b">semaphor.signal()</code>被执行，数值增加1。</li><li id="2fba" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">由于现在值为0，所以执行<code class="fe lv lw lx ly b">aysncBlock(id: 2)</code>。</li></ul><p id="4046" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="9c1a" class="oe mh it ly b gy of og l oh oi">async block #1 start</span><span id="6bb4" class="oe mh it ly b gy oj og l oh oi">async block #2 start</span><span id="11ae" class="oe mh it ly b gy oj og l oh oi">async block #1 end</span><span id="51e9" class="oe mh it ly b gy oj og l oh oi">async block #2 end</span><span id="725c" class="oe mh it ly b gy oj og l oh oi">async block #3 start</span><span id="28c7" class="oe mh it ly b gy oj og l oh oi">async block #3 end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="dffd" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.使用操作队列中的<code class="fe lv lw lx ly b">addDependency()</code></h1><p id="a983" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">根据苹果公司的文档:</p><blockquote class="nd ne nf"><p id="8da6" class="kz la ng lb b lc ld ju le lf lg jx lh nh lj lk ll ni ln lo lp nj lr ls lt lu im bi translated">直到它的所有相关操作都执行完毕，接收方才被认为准备好执行。如果接收者已经在执行它的任务，那么添加依赖项没有实际效果。此方法可能会更改接收器的<code class="fe lv lw lx ly b">isReady</code>和<code class="fe lv lw lx ly b">dependencies</code>属性。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="16e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果如下:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="5a7a" class="oe mh it ly b gy of og l oh oi">async block #2 start</span><span id="bc35" class="oe mh it ly b gy oj og l oh oi">async block #1 start</span><span id="b319" class="oe mh it ly b gy oj og l oh oi">async block #2 end</span><span id="7109" class="oe mh it ly b gy oj og l oh oi">async block #1 end</span><span id="685d" class="oe mh it ly b gy oj og l oh oi">async block #3 start</span><span id="9c98" class="oe mh it ly b gy oj og l oh oi">async block #3 end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9c6c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">7.请使用OperationQueue的addBarrierBlock()</h1><p id="1ec4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">addBarrierBlock(</code>添加任务时，操作队列如下:</p><ul class=""><li id="5160" class="nm nn it lb b lc ld lf lg li no lm np lq nq lu nr ns nt nu bi translated">在关卡之前提交的所有任务都将被执行。</li><li id="73fe" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">当所有提交的任务完成后，将执行关卡。</li><li id="95a7" class="nm nn it lb b lc nv lf nw li nx lm ny lq nz lu nr ns nt nu bi translated">然后回到关卡后提交的任务。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c384" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是:</p><pre class="kj kk kl km gt oa ly ob oc aw od bi"><span id="5a97" class="oe mh it ly b gy of og l oh oi">async block #1 start</span><span id="c52c" class="oe mh it ly b gy oj og l oh oi">async block #2 start</span><span id="365c" class="oe mh it ly b gy oj og l oh oi">async block #1 end</span><span id="3214" class="oe mh it ly b gy oj og l oh oi">async block #2 end</span><span id="809c" class="oe mh it ly b gy oj og l oh oi">async block #3 start</span><span id="b247" class="oe mh it ly b gy oj og l oh oi">async block #3 end</span><span id="6248" class="oe mh it ly b gy oj og l oh oi">async block #4 start</span><span id="d594" class="oe mh it ly b gy oj og l oh oi">async block #4 end</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1678" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="a05d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">OperationQueue</code>在iOS中起着基础的作用。重要的是不仅要了解什么是<code class="fe lv lw lx ly b">OperationQueue</code>，还要了解它是如何工作的，以及我们如何使用它。</p><p id="014e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您喜欢这篇文章，以及我们如何轻松管理异步任务的美妙之处。</p></div></div>    
</body>
</html>