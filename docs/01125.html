<html>
<head>
<title>Understanding JavaScript Closures With Ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轻松理解JavaScript闭包</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understand-javascript-closures-with-ease-aa1c808a929c?source=collection_archive---------8-----------------------#2019-08-16">https://betterprogramming.pub/understand-javascript-closures-with-ease-aa1c808a929c?source=collection_archive---------8-----------------------#2019-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cb49" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">闭包允许JavaScript程序员编写更好的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/090c106797b59211e68b22eb18d5b4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_zp-9aiPwFQIAkjk.jpeg"/></div></div></figure><p id="bd79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包允许JavaScript程序员编写更好的代码。有创意，有表现力，简洁。我们经常在JavaScript中使用闭包，不管您的JavaScript经验如何，您无疑会一次又一次地遇到它们。</p><p id="5b30" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，闭包可能看起来很复杂，超出了您的范围，但是在您阅读了本文之后，闭包会变得更容易理解，从而对您的日常JavaScript编程任务更有吸引力。</p><p id="0fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一篇关于JavaScript中闭包细节的相对简短(也很有趣)的文章。在进一步阅读之前，您应该熟悉JavaScript的变量范围，因为要理解闭包，您必须理解<a class="ae lq" href="https://www.geeksforgeeks.org/understanding-variable-scopes-in-javascript/" rel="noopener ugc nofollow" target="_blank"> JavaScript的变量范围。</a></p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="271c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">什么是终结？</h1><p id="348d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">闭包是一个内部函数，它可以访问外部(封闭)函数的变量——作用域链。</p><p id="2916" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包有三个作用域链:</p><ul class=""><li id="29f0" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">它可以访问自己的作用域(花括号中定义的变量)。</li><li id="c5c9" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">它可以访问外部函数的变量。</li><li id="e66a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">它可以访问全局变量。</li></ul><p id="45d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">内部函数不仅可以访问外部函数的变量，还可以访问外部函数的参数。注意，内部函数不能调用外部函数的<em class="nj">参数</em>给object，尽管它可以直接调用外部函数的参数。</p><p id="36cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在另一个函数中添加一个函数来创建闭包。闭包在<a class="ae lq" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>中被大量使用；它们是Node.js异步、非阻塞架构中的主力。</p><p id="8f45" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闭包也经常用在jQuery和你阅读的每一段JavaScript代码中。</p><p id="6c5e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript中闭包的一个基本例子:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="761c" class="np lz it nl b gy nq nr l ns nt"><strong class="nl iu">function showName (firstName, lastName) {</strong><br/><strong class="nl iu">var nameIntro = "Your name is ";</strong><br/><em class="nj">// this inner function has access to the outer function's     //variables, including the parameter</em><br/><strong class="nl iu">function makeFullName () {     <br/>return nameIntro + firstName + " " + lastName;   <br/>}<br/>return makeFullName ();<br/>}</strong></span><span id="8eff" class="np lz it nl b gy nu nr l ns nt"><strong class="nl iu">showName ("Michael", "Jackson");</strong> // Your name is Michael Jackson</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="b3e4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">关闭规则和副作用</h1><h2 id="a0af" class="np lz it bd ma nv nw dn me nx ny dp mi ld nz oa mk lh ob oc mm ll od oe mo of bi translated"><strong class="ak"> <em class="og">闭包可以访问外部函数的变量，即使在外部函数返回</em> </strong>之后</h2><p id="b66f" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">闭包最重要也是最棘手的特性之一是内部函数仍然可以访问外部函数的变量，即使外部函数已经返回。</p><p id="c435" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，你没看错。当JavaScript中的函数执行时，它们使用与创建时相同的作用域链。</p><p id="f2ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着即使外部函数已经返回，内部函数仍然可以访问外部函数的变量。因此，您可以稍后在程序中调用内部函数。</p><p id="72bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该示例演示了:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="9699" class="np lz it nl b gy nq nr l ns nt">function celebrityName (firstName) {<br/>    var nameIntro = "This celebrity is ";<br/>// this inner function has access to the outer function's               //variables, including the parameter<br/>   function lastName (theLastName) {<br/>        return nameIntro + firstName + " " + theLastName;<br/>    }<br/>    return lastName;<br/>}<br/><br/>var mjName = celebrityName ("Michael"); // At this juncture, the  //celebrityName outer function has returned.<br/><br/>// The closure (lastName) is called hereafter the outer function //has returned above<br/>// Yet, the closure still has access to the outer function's //variables and parameter<br/>mjName ("Jackson"); // This celebrity is Michael Jackson</span></pre><h2 id="fe26" class="np lz it bd ma nv nw dn me nx ny dp mi ld nz oa mk lh ob oc mm ll od oe mo of bi translated"><strong class="ak">闭包存储对外部函数变量的引用</strong></h2><p id="ecbe" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">它们不存储实际值。</p><p id="a210" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当外部函数的变量值在闭包被调用之前改变时，闭包变得更加有趣。这种强大的功能可以通过创造性的方式加以利用，比如这个私人变量的例子，首先由道格拉斯·克洛克福特证明:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="231e" class="np lz it nl b gy nq nr l ns nt"><strong class="nl iu">function celebrityID () {<br/>var celebrityID = 999;</strong><br/>//We are returning an object with some inner functions<br/>//All the inner functions have access to the outer function's //variables<br/>   <strong class="nl iu"> return {<br/>        getID: function ()  {</strong><br/>//This inner function will return the UPDATED celebrityID variable<br/>//It will return the current value of celebrityID, even after the //changeTheID function changes it<br/>          <strong class="nl iu">return celebrityID;<br/>        },<br/>        setID: function (theNewID)  {</strong><br/>//This inner function willchange outer function's variable anytime<br/>           <strong class="nl iu"> celebrityID = theNewID;<br/>        }<br/>    }<br/>}<br/></strong><br/><strong class="nl iu">var mjID = celebrityID ();</strong> // At this juncture, the celebrityID //outer function has returned.<br/><strong class="nl iu">mjID.getID();</strong> // 999<br/><strong class="nl iu">mjID.setID(567);</strong> // Changes the outer function's variable<br/><strong class="nl iu">mjID.getID();</strong> // 567: It returns the updated celebrityId variable</span></pre><h2 id="bafe" class="np lz it bd ma nv nw dn me nx ny dp mi ld nz oa mk lh ob oc mm ll od oe mo of bi translated"><strong class="ak">闭包出错</strong></h2><p id="6a5d" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">因为闭包可以访问外部函数变量的更新值，所以当外部函数的变量随着<code class="fe oh oi oj nl b">for-loop</code>改变时，它们也会导致错误。</p><p id="071a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6c06" class="np lz it nl b gy nq nr l ns nt">// This example is explained in detail below (just after this code box).<br/><strong class="nl iu">function celebrityIDCreator (theCelebrities) {<br/>    var i;<br/>    var uniqueID = 100;<br/>    for (i = 0; i &lt; theCelebrities.length; i++) {<br/>      theCelebrities[i]["id"] = function ()  {<br/>        return uniqueID + i;<br/>      }<br/>    }<br/>    return theCelebrities;<br/>}<br/><br/>var actionCelebs = [{name:"Stallone", id:0}, {name:"Cruise", id:0}, {name:"Willis", id:0}];<br/><br/>var createIdForActionCelebs = celebrityIDCreator (actionCelebs);<br/><br/>var stalloneID = createIdForActionCelebs[0]console.log(stalloneID.id());</strong> // 103</span></pre><p id="26b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在前面的例子中，当匿名函数被调用时，<code class="fe oh oi oj nl b">i</code>的值是3(数组的长度，然后它递增)。</p><p id="8737" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数字3被加到了<code class="fe oh oi oj nl b">uniqueID</code>上，为所有的<code class="fe oh oi oj nl b">celebritiesID</code>创造了<code class="fe oh oi oj nl b">103</code>。因此，返回数组中的每个位置都得到id = <code class="fe oh oi oj nl b">103</code>，而不是预期的100、101、102。</p><p id="b5e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">发生这种情况的原因是，正如我们在前面的例子中所讨论的，闭包(本例中的匿名函数)可以通过引用访问外部函数的变量，而不是通过值。</p><p id="d49f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，正如前面的例子显示我们可以用闭包访问更新的变量一样，这个例子同样在变量<code class="fe oh oi oj nl b">i</code>改变时访问它，因为外部函数运行整个for循环并返回最后一个值<code class="fe oh oi oj nl b">i</code>，即<code class="fe oh oi oj nl b">103</code>。</p><p id="eb03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要修复闭包中的这种副作用(bug ),可以使用立即调用的函数表达式(IIFE ),如下所示:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="5fec" class="np lz it nl b gy nq nr l ns nt"><strong class="nl iu">function celebrityIDCreator (theCelebrities) {<br/>    var i;<br/>    var uniqueID = 100;<br/>    for (i = 0; i &lt; theCelebrities.length; i++) {<br/>        theCelebrities[i]["id"] = function (j)  { </strong><br/>//the j parametric variable is the i passed in on invocation of this //IIFE<br/><strong class="nl iu">            return function () {<br/>                return uniqueID + j;</strong> // each iteration of the for //loop passes the current value of i into this IIFE and it saves the //correct value to the array<br/>           <strong class="nl iu"> } ()</strong> // BY adding () at the end of this function, we are //executing it immediately and returning just the value of //uniqueID+ j, instead of returning a function.<br/>       <strong class="nl iu"> } (i);</strong> // immediately invoke the function passing the i //variable as a parameter<br/><strong class="nl iu">    }<br/><br/>    return theCelebrities;<br/>}<br/></strong><br/><strong class="nl iu">var actionCelebs = [{name:"Stallone", id:0}, {name:"Cruise", id:0}, {name:"Willis", id:0}];<br/><br/>var createIdForActionCelebs = celebrityIDCreator (actionCelebs);</strong><br/><br/><strong class="nl iu">var stalloneID = createIdForActionCelebs [0];<br/>console.log(stalloneID.id);</strong> // 100<br/><br/><strong class="nl iu">var cruiseID = createIdForActionCelebs [1];<br/>console.log(cruiseID.id);</strong> // 101</span></pre></div></div>    
</body>
</html>