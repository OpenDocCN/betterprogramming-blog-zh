<html>
<head>
<title>How to Run a Python Script on Insertion of a USB Device</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在插入USB设备时运行Python脚本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-run-a-python-script-on-insertion-of-a-usb-device-2e86d38dcdb?source=collection_archive---------4-----------------------#2020-12-02">https://betterprogramming.pub/how-to-run-a-python-script-on-insertion-of-a-usb-device-2e86d38dcdb?source=collection_archive---------4-----------------------#2020-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="010d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Linux中插入USB时触发数据传输或其他过程的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f0a3f95eef5816886cda34ffd8a6672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2ycQlzIbLKbqi5Jx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Tobias Lystad 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="efc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们最新的Raspberry Pi传感器项目中，我们希望有一种无网络方法来自动获取数据。这个问题的解决方案是通过在插入“授权的”USB存储设备时运行Python脚本来实现的。</p><p id="59c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将解释如何实现这样的壮举。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be4d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">USB规则</h1><p id="bdb9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最简单的部分在于提供一组关于插入时做什么的规则。其中包括一个用于插入USB的脚本和一个用于移除USB的脚本:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="eff7" class="ne md it na b gy nf ng l nh ni">ACTION=="<strong class="na iu">add</strong>", SUBSYSTEM=="usb", PROGRAM="<strong class="na iu">&lt;full_path_here&gt;</strong>/on_usb_in.sh"<br/>ACTION=="<strong class="na iu">remove</strong>", SUBSYSTEM=="usb", PROGRAM="<strong class="na iu">&lt;full_path_here&gt;</strong>/on_usb_out.sh"</span></pre><p id="f9f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两行进入<code class="fe nj nk nl na b">etc/udev/rules.d</code>目录。例如:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="56e3" class="ne md it na b gy nf ng l nh ni">nano /etc/udev/rules.d/custom_usb.rules</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="60ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">USB断开时</h1><p id="74a3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">正如<a class="ae ky" href="https://raspberrypi.stackexchange.com/questions/51836/how-to-run-a-script-when-a-device-is-connected-to-usb" rel="noopener ugc nofollow" target="_blank">这篇文章</a>所建议的，我们可以使用一个锁文件，只在设备插入时显示，而不运行代码的多个实例。如果我们打算同时插入多个USB，这种方法有其缺点，但这很少会导致正常使用的问题。</p><p id="b513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们的“connect”文件将创建锁，所以disconnect脚本需要删除它。因此，我们的<code class="fe nj nk nl na b">.../on_usb_out.sh</code>脚本的内容是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2074" class="ne md it na b gy nf ng l nh ni">#!/bin/sh </span><span id="cc62" class="ne md it na b gy nm ng l nh ni">LOCK=/tmp/lockfile_for_plug_usb/bin/<br/>rm -f /tmp/lockfile_for_plug_usb</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7d27" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在USB连接上</h1><p id="f9b0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在识别新的通用串行总线时，我们已经知道我们想要创建一个锁文件。一旦这样做了，我们就可以在合理的范围内运行任何我们想要的脚本(也就是说，它们需要是有限的并且没有中断的可能性)。</p><p id="2cd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl na b">.../on_usb_in.sh</code>脚本将当前日期存储在一个日志文件中，然后运行一个Python脚本来确定是否有数据存储设备。如果是，它会将数据传输给它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0601" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Python脚本</h1><p id="8bd3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">理论上，Python脚本的内容可以做任何事情。在我的例子中，我首先调用一个允许USB完全安装的延迟期:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="75aa" class="ne md it na b gy nf ng l nh ni">import os, time, re<br/>time.sleep(10) # </span></pre><h2 id="815a" class="ne md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">提取驱动器信息</h2><p id="e320" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接下来，我通过使用<code class="fe nj nk nl na b">blkid</code>命令提取关于所有连接的USB驱动器的信息:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6c89" class="ne md it na b gy nf ng l nh ni">devices = os.popen('sudo blkid').readlines()</span></pre><p id="e1c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这里，我可以将每个条目提取到包含所有相关信息的dictionary对象列表中。由于我对Raspberry Pi SD卡不感兴趣，所以我只选择位于<code class="fe nj nk nl na b">/dev/sd**</code>内并且具有<code class="fe nj nk nl na b">sd[a-z][1-9]</code>格式的项目(例如<code class="fe nj nk nl na b">sda1</code>):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h2 id="bbd0" class="ne md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">查看选定的设备</h2><p id="d103" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在我们有了一个USBs列表，我们可以通过迭代以下内容来打印它们的位置、唯一标识符和标签名称:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fdb6" class="ne md it na b gy nf ng l nh ni">for u in usbs:<br/>    print ('Device %(LABEL)s is located at $(loc)s with UUID of $(UUID)s'%u )</span></pre><p id="3239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种功能有助于根据UUID筛选出特定设备，并且只为我们预先批准的设备执行任务。</p><h2 id="abe7" class="ne md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">增加</h2><p id="cd08" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，如果我们希望向USB设备传输数据，我们可能需要安装USB设备。这是通过使用系统调用来完成的，系统调用要求我们将驱动器安装在我们选择的位置(例如<code class="fe nj nk nl na b">/myusb</code>):</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="2099" class="ne md it na b gy nf ng l nh ni">os.system('sudo mount $(loc)s /myusb'%u)</span></pre><p id="5a99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使我们能够正常地向它传输文件和从它传输文件:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="fc19" class="ne md it na b gy nf ng l nh ni">cp ./file2backup /myusb</span></pre><h2 id="06f7" class="ne md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">卸载</h2><p id="c352" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">完成后，我们需要在拔下设备之前卸载它。同样，这是通过使用:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="4ba7" class="ne md it na b gy nf ng l nh ni">os.system('sudo umount /myusb')</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="818e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">使脚本可执行</h1><p id="9589" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可能需要做的最后一件事是使用<code class="fe nj nk nl na b">chmod a+x &lt;filename&gt;</code>使所有文件可执行，并可能重启系统以使更改生效。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="eb4f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="827c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们已经创建了一个在插入和移除u盘时执行的规则。其中，我们使用一个锁文件来停止多次执行，并运行一个Python脚本来识别插件设备。如果一个设备符合我们的标准，我们就可以安装它，并按照我们的意愿处理它，所有这些都是以自动化的方式进行的。</p><p id="7796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Raspberry Pi传感器，这使我们能够高效地卸载所有测量数据，而无需网络或移动信号。这种方法最大的优点(除了简单之外)是，对于恶劣的环境，只需使用一个防水连接端口就可以进行数据传输！</p></div></div>    
</body>
</html>