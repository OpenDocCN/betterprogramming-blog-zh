<html>
<head>
<title>Build a Modular Web Server Using Nginx, Docker Compose, and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx、Docker Compose和Go构建一个模块化的Web服务器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/power-to-the-proxy-80329995e8?source=collection_archive---------1-----------------------#2022-10-28">https://betterprogramming.pub/power-to-the-proxy-80329995e8?source=collection_archive---------1-----------------------#2022-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="db88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">代理人的权力</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/200b44fb7dd6ba13d3b0dc6c3c46ad38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03oap6oWq1brqKigR71Bug.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由creativeart在<a class="ae ky" href="https://www.freepik.com/free-photo/connected-elements_902782.htm#page=3&amp;query=web proxy&amp;position=42&amp;from_view=search&amp;track=ais" rel="noopener ugc nofollow" target="_blank"> Freepik </a>上提供</p></figure><p id="928f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时，你很可能听说过“反向代理”或“代理服务器”这样的术语，但它们到底是什么呢？在计算机网络的上下文中，万维网联盟(或W3C)将它们定义如下:</p><blockquote class="lv lw lx"><p id="8610" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在请求者代理和提供者代理之间中继消息的代理，对于Web服务来说，它就像是请求者。</p></blockquote><p id="a548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在查看典型实现时，代理通常分为两个不同的类别:</p><ul class=""><li id="6f60" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">正向代理</li><li id="7be7" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">反向代理</li></ul><p id="3956" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转发代理在各种规模的商业网络中非常普遍，在大规模的公司环境中尤其有用。你很有可能在工作中使用电脑试图访问网站或其他网络资源时遇到过这种情况。有没有尝试导航到一个被你的公司封锁的网站？这是一个转发代理过滤网络请求之前，被发送到网上！</p><p id="5257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然我相信我们中的许多人都不喜欢看到这种烦人的代理警报，但我们对这些配置不感兴趣！我们希望利用的是强大的反向代理:</p><blockquote class="mq"><p id="cc12" class="mr ms it bd mt mu mv mw mx my mz lu dk translated">反向代理是位于web服务器前面的服务器，并且将客户端(例如，web浏览器)请求转发到那些web服务器。反向代理通常用于帮助提高安全性、性能和可靠性。</p></blockquote><h1 id="ec6b" class="na nb it bd nc nd ne nf ng nh ni nj nk jz nl ka nm kc nn kd no kf np kg nq nr bi translated">我们的场景</h1><p id="80fb" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">您已经有了一个面向公众的网站，并希望创建几个不同的后端API来高效、安全地利用各种通知服务，而不暴露多个开放端口。我们如何着手做这件事？没错……一个反向代理！</p><p id="0e79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像编程世界中的许多事情一样，完成一项任务有几种方法。我们将组织这个项目的方式(这是我的偏好)如下:</p><ul class=""><li id="791e" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">利用Go的速度和丰富的社区框架为我们的通知服务创建API</li><li id="cd8f" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">利用集装箱化的灵活性和附加的安全性</li><li id="0bfa" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">利用Nginx的内置代理特性来处理我们所有的服务路由</li></ul><p id="e67c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们项目的总体结构如下:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="ff3e" class="oc nb it ny b gy od oe l of og">.</span><span id="563d" class="oc nb it ny b gy oh oe l of og">├── api</span><span id="757f" class="oc nb it ny b gy oh oe l of og">├── backend</span><span id="c240" class="oc nb it ny b gy oh oe l of og">│   └── main</span><span id="5118" class="oc nb it ny b gy oh oe l of og">│       └── assets</span><span id="4a71" class="oc nb it ny b gy oh oe l of og">│           ├── css</span><span id="a22f" class="oc nb it ny b gy oh oe l of og">│           ├── fonts</span><span id="6ef2" class="oc nb it ny b gy oh oe l of og">│           ├── img</span><span id="b094" class="oc nb it ny b gy oh oe l of og">│           └── js</span><span id="297e" class="oc nb it ny b gy oh oe l of og">├── devices</span><span id="e3e9" class="oc nb it ny b gy oh oe l of og">└── nginx</span><span id="65d2" class="oc nb it ny b gy oh oe l of og">└── sites-enabled</span></pre><blockquote class="lv lw lx"><p id="a26d" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">就资源目录而言，assets文件夹非常简单。它的父目录backend/main包含基本的网站模板，用于模拟真实部署中使用的面向公众的网站。</p></blockquote><p id="7340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能已经注意到在上面的结构中有两个有趣的目录。<code class="fe oi oj ok ny b">api</code>和<code class="fe oi oj ok ny b">devices</code>文件夹都保存了模拟后端API的示例代码，我们需要这些API来接收通知。一个用于新的联系表单提交，另一个用于设备传感器警报，以模拟现场物联网设备触发。</p><p id="e377" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为Go提供了出色的速度和并发性、简单的语法和众多的社区库，所以它很容易成为API编程的首选。让我们看看新提交的网站联系表单的示例代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="96aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个程序相对来说比较简单，但是让我们回顾一下代码的要点:</p><ul class=""><li id="8d55" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">我们首先运行一个<code class="fe oi oj ok ny b">init</code>函数来追加/创建一个日志文件，以跟踪容器生命周期中的所有请求(稍后将有更多内容)</li><li id="e2ce" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">我们导入了强大的Gorilla Mux库和Logrus，为创建自定义路由和日志条目提供了简单的接口</li><li id="6f0d" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">创建两个端点函数来匹配路径查询，每个端点函数都调用一个执行函数，该函数运行特定于路径的Python脚本…从而向您(或者客户端)发送电子邮件警报</li><li id="8d61" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">最后，我们创建主路由器，并在<code class="fe oi oj ok ny b">main</code>函数体中声明我们的定制路由，并在定义的端口上启动我们的API服务器</li></ul><p id="fec1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oi oj ok ny b">devices</code>目录也使用相同的代码结构来创建它的API。主要区别是用于通知服务的python脚本和为每个设备传感器创建的特殊<code class="fe oi oj ok ny b">Sensor</code>结构。</p></div><div class="ab cl on oo hx op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="im in io ip iq"><p id="ac11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">项目的下一个重要部分涉及到运行API服务器的容器的创建。为了给我们的web服务器增加模块性和安全性，我们将利用Docker在各自独立的环境中运行两个不同的API。如果你对集装箱化的整个概念不熟悉，一定要查看Docker网站<a class="ae ky" href="https://www.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">上提供的大量文档，让你快速上手，并在你的机器上设置使用集装箱。</a></p><p id="9bae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker有一个优秀的编排程序，叫做Docker Compose。它允许我们编写一个简单的YAML文件，声明我们计划使用哪些docker图像和资源，它完全符合我们对这个项目的需求！</p><p id="4f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们的web服务器将如何启动我们需要的容器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="da90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">深入研究Docker Compose经历的每一个步骤超出了本文的范围；然而，如果您同时查看<code class="fe oi oj ok ny b">devices</code>和<code class="fe oi oj ok ny b">api</code>目录，您会在每个目录中看到一个<code class="fe oi oj ok ny b">Dockerfile</code>。这些包含为每个服务构建映像的指令…这就是compose所使用的蓝图。我们马上就来看看这个高级流程！</p><h1 id="66b0" class="na nb it bd nc nd ne nf ng nh ni nj nk jz ou ka nm kc ov kd no kf ow kg nq nr bi translated">最终作品</h1><p id="001c" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">剩下我们要做的就是确保我们的服务器正确安装/配置了Nginx来托管我们的站点，并相应地路由传入的请求。</p><p id="a124" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有在你的服务器上安装和配置Nginx，我推荐你去看看数字海洋的几个演练之一。它们不仅会引导您完成安装和基本设置的步骤，还包括设置免费LetsEncrypt证书的步骤，以便您的页面可以利用SSL/TLS。</p><p id="f46f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦您的web服务器目录建立起来(如果还没有的话)，您只需要做一个大的改变。如果你跟随任何一个数字海洋漫游，很可能你会在<code class="fe oi oj ok ny b">/etc/nginx/sites-enabled</code>中为你的网站创建一个文件。这是声明重要配置的地方，允许我们利用Nginx的反向代理能力！下面是我们新网页和API路由的配置示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="223d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请记住，这只是配置文件的一部分，因为其他行是CertBot在获取Lets Encrypt证书时自动添加的(参见数字海洋文章)，还有其他一些与此无关的内容。</p><p id="8dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上述要点中提取的主要细节如下:</p><ul class=""><li id="8800" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">我们用路线的名称和我们希望它们被代理的地方来声明<code class="fe oi oj ok ny b">location</code>块。例如，如果一个请求带有URL<code class="fe oi oj ok ny b">awesomeinc.com/contact</code>，我们的服务器会将它转发到端口<code class="fe oi oj ok ny b">8081</code></li><li id="0dfa" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">URL对应于我们的API容器正在监听的端口</li><li id="7f2e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">Nginx文档推荐使用<code class="fe oi oj ok ny b">limit_req</code>和其他声明来限制并发请求，它们本身并不完全必要</li></ul><p id="d517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样一来，剩下的就是使用<code class="fe oi oj ok ny b">sudo systemctl restart nginx</code>重启(或最终启动)我们的Nginx服务。如果您使用AWS EC2之类的东西在云VM上托管该服务器，请确保进入您的网络仪表板，只允许传入网络流量到端口<code class="fe oi oj ok ny b">80</code>和<code class="fe oi oj ok ny b">443</code>(这应该已经完成以获得SSL证书)。只要您已经创建了正确的DNS记录，您现在应该能够导航到您的主页，并看到网站被正确地服务！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/bc7684d8e8ec8082048ce4aeb3965eef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lC3Tu4_ECA65MInhgcVbQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们新的Awesome公司网页！</p></figure><h1 id="fc4d" class="na nb it bd nc nd ne nf ng nh ni nj nk jz ou ka nm kc ov kd no kf ow kg nq nr bi translated">最后一档</h1><p id="d91a" class="pw-post-body-paragraph kz la it lb b lc ns ju le lf nt jx lh li nu lk ll lm nv lo lp lq nw ls lt lu im bi translated">所以现在我们的web服务器已经启动并运行了，但是我们的API还不可用。</p><p id="f0db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在确认您的主网页可用后，回到您的服务器终端，告诉docker-compose为您旋转这些容器！在执行任何操作之前，确保您的合成YAML文件位于项目目录的底部是非常重要的，各种服务容器API位于它们自己的特定文件夹中(以匹配合成文件声明):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/18819898f241df46d88f1e6c1c11d141.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*iwhrS2-glZTORYHBvUz4Ww.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们的项目</p></figure><p id="2c2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只要一切正常，我们就可以运行一个极其简单的命令来让事情运转起来:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="5d7f" class="oc nb it ny b gy od oe l of og">sudo docker-compose up -d</span></pre><h2 id="fb62" class="oc nb it bd nc oz pa dn ng pb pc dp nk li pd pe nm lm pf pg no lq ph pi nq pj bi translated">以下是该命令将执行的操作:</h2><ul class=""><li id="0eab" class="mc md it lb b lc ns lf nt li pk lm pl lq pm lu mh mi mj mk bi translated">告诉compose遍历配置文件中声明的每个文件夹，并在每个文件夹中使用<code class="fe oi oj ok ny b">Dockerfile</code>为它们构建“映像”</li><li id="c730" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">这些图像是compose将用来创建新容器的图像</li><li id="2f1a" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">构建过程结束后，docker-compose将在后台运行一切，以允许终端继续使用(T4代表“分离”)</li></ul><p id="4414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能需要也可能不需要继续并重启您的<code class="fe oi oj ok ny b">nginx</code>服务，但是一旦一切最终完成，您应该能够测试查询您的后端API服务了！我们在上面概述的示例代码中添加了一个特殊的“测试”路线。在本地机器上打开一个终端，使用<code class="fe oi oj ok ny b">curl</code>向测试端点请求您的域:</p><pre class="kj kk kl km gt nx ny nz oa aw ob bi"><span id="2837" class="oc nb it ny b gy od oe l of og">curl <a class="ae ky" href="http://www.awesomeinc.com/test" rel="noopener ugc nofollow" target="_blank">http://www.awesomeinc.com/test</a></span></pre><p id="ebba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果成功了，太棒了！如果没有…不要烦恼！设置这样的后端时，有许多移动部件。回到你的配置文件，检查你的端点声明…然后再试一次。</p><p id="a617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目和所有相关文件都可以在GitHub上找到:</p><div class="pn po gp gr pp pq"><a href="https://github.com/dedSyn4ps3/go-nginx-proxy" rel="noopener  ugc nofollow" target="_blank"><div class="pr ab fo"><div class="ps ab pt cl cj pu"><h2 class="bd iu gy z fp pv fr fs pw fu fw is bi translated">GitHub—ded syn 4 PS 3/go-nginx-proxy:Medium文章的代码文件</h2><div class="px l"><h3 class="bd b gy z fp pv fr fs pw fu fw dk translated">这个回购是为了持有代理的中等文章权力的代码文件。的整体结构…</h3></div><div class="py l"><p class="bd b dl z fp pv fr fs pw fu fw dk translated">github.com</p></div></div><div class="pz l"><div class="qa l qb qc qd pz qe ks pq"/></div></div></a></div><p id="4f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">什么是反向代理？|代理服务器说明| Cloudflare </em>。<a class="ae ky" href="https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/." rel="noopener ugc nofollow" target="_blank">https://www . cloud flare . com/learning/cdn/glossary/reverse-proxy/。</a></p></div></div>    
</body>
</html>