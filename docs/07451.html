<html>
<head>
<title>Building an API To List All Endpoints Exposed by Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个API来列出Spring Boot公开的所有端点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-an-api-to-list-all-endpoints-exposed-by-spring-boot-645f1f64ebf3?source=collection_archive---------7-----------------------#2021-01-15">https://betterprogramming.pub/building-an-api-to-list-all-endpoints-exposed-by-spring-boot-645f1f64ebf3?source=collection_archive---------7-----------------------#2021-01-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f60" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不再迷失在你的后端</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/790d70e734873b3515385ae5f5affa6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l5jXxxNDsZ4LeEC_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@goran_ivos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戈兰·艾沃斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="8283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过与后端打交道，我了解到您很容易忽略正在发生的事情或当前部署的内容。这可能会成为一个问题，尤其是在处理生产环境时。</p><p id="8907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有很多库可以解决这个问题，我个人推荐<a class="ae ky" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html" rel="noopener ugc nofollow" target="_blank"> Spring Boot执行器</a>。</p><blockquote class="lv lw lx"><p id="dbbb" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“Spring Boot包括许多附加功能，可帮助您在应用程序投入生产时对其进行监控和管理。您可以选择使用HTTP端点或JMX来管理和监视您的应用程序。审计、健康和指标收集也可以自动应用到您的应用程序中。”— <a class="ae ky" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html" rel="noopener ugc nofollow" target="_blank"> Spring文档</a></p></blockquote><p id="7d78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mc md me mf b"><a class="ae ky" href="https://github.com/spring-projects/spring-boot/tree/v2.4.1/spring-boot-project/spring-boot-actuator" rel="noopener ugc nofollow" target="_blank">spring-boot-actuator</a></code>模块提供了上述Spring Boot的所有生产就绪特性，帮助您监控和管理您的应用。</p><p id="63dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，本教程的目标不是向您展示如何利用Spring Boot致动器。事实上，对于简单的应用程序，单个监控API应该足够了。</p><p id="4c93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据我的经验，第一件也是最重要的事情是<strong class="lb iu">所有暴露端点的列表</strong>。可能有一些您不记得或不使用的API仍然在线，并且可能对任何人都可用。出于安全原因，应该避免这样做，尤其是在这些API被否决的情况下。</p><p id="6e80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何定义一个自定义API，返回使用Spring Boot应用程序公开的所有端点的列表。</p></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="59d2" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">构建API</h1><p id="8810" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在网上寻找检索Spring Boot应用程序中所有已部署端点的方法时，我发现了<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerMapping.html" rel="noopener ugc nofollow" target="_blank"><em class="ly">requestmappingchandlermapping</em></a>的存在。</p><p id="999a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个类被Spring Boot用来执行每一个用<code class="fe mc md me mf b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html" rel="noopener ugc nofollow" target="_blank"><em class="ly">@RequestMapping</em></a></code> <em class="ly"> </em>标注的方法，并包含一个所有方法的列表，具体来说，就是你的应用程序所暴露的所有端点的列表。</p><p id="e820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么实现这样一个API比你想象的要容易。这可以通过以下方式实现:</p><h2 id="7612" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">Java 语言(一种计算机语言，尤用于创建网站)</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="85ee" class="nk mo it bd mp nl nm dn mt nn no dp mx li np nq mz lm nr ns nb lq nt nu nd nv bi translated">科特林</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="a3f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这两种情况下，我都使用了<code class="fe mc md me mf b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/handler/AbstractHandlerMethodMapping.html#getHandlerMethods--" rel="noopener ugc nofollow" target="_blank">handlerMethods</a></code>属性，它存储了一个包含所有映射和<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/HandlerMethod.html" rel="noopener ugc nofollow" target="_blank"> HandlerMethod </a>的只读映射。他们的<code class="fe mc md me mf b"><a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/RequestMappingInfo.html#toString--" rel="noopener ugc nofollow" target="_blank">toString()</a></code>方法返回到达与<a class="ae ky" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/HandlerMethod.html" rel="noopener ugc nofollow" target="_blank"> HandlerMethod </a>对象关联的端点所需的所有内容，具体来说，就是用<code class="fe mc md me mf b"><em class="ly">@RequestMapping</em></code> <em class="ly">注释的方法。</em></p><p id="7243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个API的响应示例如下:</p><pre class="kj kk kl km gt ny mf nz oa aw ob bi"><span id="3670" class="nk mo it mf b gy oc od l oe of">[<br/>   "{GET /monitoring/endpoints}",      <br/>   "{GET /v1/genres}",    <br/>   "{GET /v1/genres/{id}}",<br/>   "{POST /dex/v1/genres}", <br/>   "{PUT /v1/genres/{id}}",<br/>   "{DELETE /v1/genres/{id}}",     <br/>   "{PATCH /v1/genres/{id}}", <br/>   "{GET /v1/books}",    <br/>   "{GET /v1/books/{id}}",<br/>   "{POST /dex/v1/books}", <br/>   "{PUT /v1/books/{id}}",<br/>   "{DELETE /v1/books/{id}}",     <br/>   "{PATCH /v1/books/{id}}", <br/>   "{GET /v1/authors}",    <br/>   "{GET /v1/authors/{id}}",<br/>   "{POST /dex/v1/authors}", <br/>   "{PUT /v1/authors/{id}}",<br/>   "{DELETE /v1/authors/{id}}",     <br/>   "{PATCH /v1/authors/{id}}", <br/>   "{GET /v1/authors/{id}/books}"    <br/>]</span></pre></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="f2fd" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">奖金</h1><p id="1988" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">只有少数选定的用户应该被允许访问<a class="ae ky" href="https://levelup.gitconnected.com/building-an-api-to-clear-all-the-caches-of-your-spring-boot-application-2d0dfdfe71b3" rel="noopener ugc nofollow" target="_blank">这种API </a>。</p><div class="og oh gp gr oi oj"><a href="https://levelup.gitconnected.com/building-an-api-to-clear-all-the-caches-of-your-spring-boot-application-2d0dfdfe71b3" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">构建一个API来清除Spring Boot应用程序的所有缓存</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">通过按需清除所有缓存数据来避免一致性问题</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox ks oj"/></div></div></a></div><p id="2673" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我建议实现一个定制的身份验证系统。如需进一步阅读，您可以查看我以前的文章，其中我展示了如何在Spring Boot实现这样的目标。</p><div class="og oh gp gr oi oj"><a href="https://medium.com/better-programming/how-to-implement-custom-token-based-authentication-in-spring-boot-and-kotlin-5b59b55c1de2" rel="noopener follow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何在Spring Boot和科特林实现自定义的基于令牌的身份验证</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">构建更安全的Spring Boot应用程序</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">medium.com</p></div></div><div class="os l"><div class="oy l ou ov ow os ox ks oj"/></div></div></a></div><div class="og oh gp gr oi oj"><a href="https://levelup.gitconnected.com/how-to-implement-basic-access-authentication-in-spring-boot-eaded2e33d19" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd iu gy z fp oo fr fs op fu fw is bi translated">如何在Spring Boot实现基本接入认证</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">让您的Spring Boot API更加安全</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="os l"><div class="oz l ou ov ow os ox ks oj"/></div></div></a></div></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><h1 id="cb36" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="f33c" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">迷失在后端的复杂性或广阔性中是很常见的。这也正是你要通过增加一些监控工具来保护自己的原因。正如我所展示的，实现一个列出所有端点的API并不复杂，对于简单的系统来说，这可能就足够了。</p><p id="d296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望这篇文章对你有所帮助。如有任何问题、意见或建议，请随时联系我。</p></div></div>    
</body>
</html>