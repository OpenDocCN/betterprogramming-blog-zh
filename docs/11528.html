<html>
<head>
<title>Drift Away From Android Handlers. Use Coroutines and Jobs Instead!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">远离Android处理器。请改用协程和作业！</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/drift-away-from-android-handlers-use-coroutines-and-jobs-instead-581815dd3e72?source=collection_archive---------10-----------------------#2022-03-28">https://betterprogramming.pub/drift-away-from-android-handlers-use-coroutines-and-jobs-instead-581815dd3e72?source=collection_archive---------10-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e7a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用协程和处理程序上的作业，可以简化定时任务。看如何！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aa3d71d7a64afba0130912342c09ce09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MJJHIwc7_U5B9qJ88lv6dA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">远离处理程序，改用协程和作业！</p></figure><h1 id="38fb" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">方案</h1><p id="14b0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在我们的Android应用程序中，我们都使用过带有<code class="fe mj mk ml mm b"><a class="ae mn" href="https://developer.android.com/reference/android/os/Handler#postDelayed(java.lang.Runnable,%20long)" rel="noopener ugc nofollow" target="_blank">postDelayed</a></code> <a class="ae mn" href="https://developer.android.com/reference/android/os/Handler#postDelayed(java.lang.Runnable,%20long)" rel="noopener ugc nofollow" target="_blank"> <em class="mo"> </em> </a>方法的处理程序来执行某个任务。这是我们在这种时间要求下执行任务的常用方法。</p><p id="a05c" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">使用<code class="fe mj mk ml mm b">Handler</code>，10秒后执行任务的典型代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><h1 id="b49c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">我觉得这太繁琐了！</h1><p id="f749" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">当有一个作用域要求我们取消当前正在运行的定时任务，并且我们同时有多个任务在运行时，处理程序实例的创建和维护就变得特别乏味。</p><p id="7211" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">在这种情况下，我们必须维护一个令牌或单独的runnable实例，以便在计时器超时之前取消所需的任务。</p><p id="9bfc" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">此外，为Handler的创建提供looper实例可能看起来有点乏味，我们大多数人倾向于只使用默认的主Looper(在上面的要点中使用),这又会导致一些UI问题/ Janks等。</p><h1 id="eafa" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">输入协程和作业</h1><p id="78f8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">多亏了Kotlin协程和作业机制，我们可以在这种情况下不使用处理程序，通过创建轻量级协程作业并在中间取消它们来阻止所需任务的执行。</p><p id="4b42" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">上面使用协程作业的代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2d06" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">我们可以只维护一个作业实例，而不是维护两个单独的<code class="fe mj mk ml mm b">Handler</code>实例和一个runnable实例。</p><p id="cac6" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">每当我们想要启动一个在X秒(本例中为10秒)后执行的任务时，我们可以取消以前运行的作业实例(这是可选的，只是为了避免不一致的状态)，并创建一个新的作业实例并获取它的引用。</p><p id="ff98" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">作业中使用的delay方法会将任务暂停X秒(在本例中为10秒)，然后继续执行。如果我们想取消中间的任务，我们可以直接取消作业！很干净简单，不是吗？</p><p id="2136" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">因为协程和作业被认为是轻量级的，所以每次创建新作业都不会对性能产生任何显著影响。我们还可以使用期望的调度程序(例如，<code class="fe mj mk ml mm b">Dispatchers.IO</code>)来执行任务，因此不需要像处理程序那样提供固定的<code class="fe mj mk ml mm b">Looper</code>实例，从而使代码更加线程友好，错误更少！</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="0a56" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">虽然Handler有自己的用例，但是我们肯定可以在它上面使用协程和作业，以简洁的方式执行定时任务。</p><p id="f4c0" class="pw-post-body-paragraph ln lo iq lp b lq mp jr ls lt mq ju lv lw mr ly lz ma ms mc md me mt mg mh mi ij bi translated">你认为这种方法怎么样？你想进一步改进它吗？有什么你担心的吗？</p></div></div>    
</body>
</html>