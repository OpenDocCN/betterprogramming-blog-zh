<html>
<head>
<title>Manacher Algorithm Visualized</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化管理器算法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/manacher-algorithm-visualized-17a7df7feded?source=collection_archive---------10-----------------------#2022-02-18">https://betterprogramming.pub/manacher-algorithm-visualized-17a7df7feded?source=collection_archive---------10-----------------------#2022-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe48" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">O(n)中最长的回文子串</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd63a93b18ff3f9d82c5488efac418d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3rfRIF-QpYI294cLw6iTA.png"/></div></div></figure><p id="d7f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">计算机科学中最漂亮的算法之一，它展示了如何从缓慢的O(n)到高速的<a class="ae lq" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank">O(n)获得巨大的加速，只要从不同的角度看问题。</a></p><p id="2b79" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任务是找到恰好是回文的最长子串。例如，“分数从不奇数或偶数”中最长的回文是“从不奇数或偶数”，(忽略字母大小写和空格)。在生物化学上有实际应用(<em class="lr"> GAATTC </em>和<em class="lr"> CTTAAG </em>称为<a class="ae lq" href="https://en.wikipedia.org/wiki/Palindromic_sequence" rel="noopener ugc nofollow" target="_blank">回文序列</a>)。是典型的<a class="ae lq" href="https://leetcode.com/problems/longest-palindromic-substring/" rel="noopener ugc nofollow" target="_blank">面试任务</a>。</p><p id="bf77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最直接的方法(同时也是最慢的方法)是迭代所有的开始和长度，检查相应的子串是否是回文:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ls"><img src="../Images/d2916aefb53bd92c0a71cb90b4d7797b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I2Lejw-YBgVXW56iq4h6mQ.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">到目前为止，让我们专注于奇数大小的回文，稍后我们将推广到偶数大小的回文。</p></figure><p id="bbf0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">伪代码</p><p id="7717" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lx ly lz ma b">loop over substring start:<br/> __loop over substring length:<br/> ____loop over letters in substring</code></p><p id="9350" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">明确表示它是一个O(n)方法(其中n是文本的长度)，这是一个快速增长的函数。</p><p id="d0bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们不是在开始循环，而是在中间循环，我们将能够重用前面步骤的结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/b5c3173be781ba04f28fcd72f90f3500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TdQHw4EskU5s5Is1EoGQOg.png"/></div></div></figure><p id="57a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们知道“eve”是一个回文，我们只需要再做一次比较就能知道“level”也是一个回文。在第一种方法中，我们必须从头开始重新运行整个检查。</p><p id="0042" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lx ly lz ma b">loop over substring middle<br/> __loop over substring length</code></p><p id="88b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个是O(n)。但是有⁴方法允许做得更快。</p><p id="afda" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其中最优雅的是Manacher algorithm⁵.它基于上述的O(n)方法，但是它引入的启发式算法将时间复杂度降低到O(n)。</p><p id="aa29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当文本中的回文相距较远时，这里就没有什么可优化的了。已经是O(n)了。当它们重叠时，问题就出现了，最坏的情况是一个文本由一个字母组成。</p><p id="e116" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑以下情况。算法找到了较短的绿色回文，较长的蓝色回文，并在字母‘I’处停止:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd63a93b18ff3f9d82c5488efac418d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N3rfRIF-QpYI294cLw6iTA.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">底部的数字是中间在这个位置的回文的最大半长。</p></figure><p id="2e31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仔细观察图像可以发现，确实没有必要处理蓝色回文右半部分的偏移量。根据定义，它是左半边的镜像，所以我们从左半边收集的所有信息都可以“免费”反射到右半边:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mc"><img src="../Images/6c57f177981076dcb17438aaadef2f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhDAS2LrlxGBapr9n3CSoA.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">案例A</p></figure><p id="4822" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这并不是唯一可能的重叠情况。在下图中，绿色回文跨越了蓝色回文的边界，因此其长度必须相应缩短:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi md"><img src="../Images/1bd738cba6574a981d8b96186ed75414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FjxwZ3A8Fmzc-_niCDR0oA.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">案例B</p></figure><p id="34a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，没有必要仔细检查反射回文的长度:字母b和x必须不同，否则蓝色回文会变长。</p><p id="04ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，一个回文可以从内部触及另一个。在这种情况下，不能保证反射的回文不会进一步增长，所以我们只能得到其长度的一个下限:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi me"><img src="../Images/23757e45ff46c2eec709ebc654a97e03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3J7XTxuVaVp53pu9KURkfQ.png"/></div></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">案例C</p></figure><p id="73da" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理想情况下，我们应该在进一步的处理中跳过零和严格的非零(=除了最后一种情况之外的所有情况)(下面的清单1)。但是在实践中(如果可以在这样一个抽象的问题中谈论实践的话)，这里≥和=之间的差别是如此之小(只是一个额外的比较)，为了代码简洁和可读性，将所有非零值都视为≥是有意义的(清单2)。</p><p id="9710" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该算法的一个可能的python实现是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">清单1。冗长的解决方案。</p></figure><p id="d541" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，它试图找到如上所述的相关反射。然后，如果必要的话，进行顺序搜索:就像在O(n)算法中一样，但是将反射值作为起点。最后，如果新的回文比前一个最右边的回文更靠右，它将被选为新的最右边的回文。</p><p id="ded8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个函数只查找奇数大小的回文。为了使它同样适用于偶数大小的回文，一种常见的方法是:<br/>–在原始文本的字母之间插入一个任意字符，例如<code class="fe lx ly lz ma b">‘noon’ -&gt; ‘|n|o|o|n|’</code>，<br/>–在那里找到奇数大小的回文，最后，<br/>–从结果中去掉这些字符。</p><p id="7793" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">字符“|”不需要从字符串中消失。任何角色都可以。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="fc0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">稍微模糊的版本(更难理解，稍微慢一点，但是更短)看起来像</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div><p class="lt lu gj gh gi lv lw bd b be z dk translated">清单2。较短的解决方案。</p></figure><p id="f85e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从代码中可以看出，有两个嵌套循环。这里有一个直觉，为什么这个方法不需要O(n)。在下图中，<code class="fe lx ly lz ma b">h</code>数组是可视化的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mh"><img src="../Images/a0f7c735408d7b5a086a107f69f96dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tcIFNoAG24LqN2y_PIQgEg.png"/></div></div></figure><p id="d016" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">外环对应于水平运动，内环对应于垂直运动。每一步都是一次比较。实线代表计算步骤，虚线代表跳过步骤。</p><p id="8175" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从图中可以明显看出，当回文不重叠时，向上的步数等于跳过的水平步数。对于重叠的回文，稍微做作一点，但是如果统计向上的总步数，又会和跳过的水平步总数重合。所以总的步骤数受到<code class="fe lx ly lz ma b">2n</code>比较的限制。它不是<code class="fe lx ly lz ma b">n</code>,因为与垂直步骤不同，要理解一个水平步骤被跳过，您仍然需要做一些工作(尽管可以进一步微调实现，以在恒定时间内跳过一批步骤)。因此，总时间为O(n)。</p><p id="67ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Manacher算法允许使用非常直观的方法在线性时间内找到字符串中最长的回文(事实上，不仅仅是最长的一个，而是每个可能中心的最长回文),最好用视觉描述。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h2 id="a5f8" class="mp mq it bd mr ms mt dn mu mv mw dp mx ld my mz na lh nb nc nd ll ne nf ng nh bi translated">参考</h2><ol class=""><li id="5b2e" class="ni nj it kw b kx nk la nl ld nm lh nn ll no lp np nq nr ns bi translated"><a class="ae lq" href="https://www.bigocheatsheet.com/" rel="noopener ugc nofollow" target="_blank"> Big-O小抄</a>，网站。</li><li id="ab5b" class="ni nj it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Palindromic_sequence" rel="noopener ugc nofollow" target="_blank">回文序列</a>，维基文章。</li><li id="18fb" class="ni nj it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><a class="ae lq" href="https://leetcode.com/problems/longest-palindromic-substring/" rel="noopener ugc nofollow" target="_blank">最长回文子串</a>，Leetcode问题。</li><li id="95e2" class="ni nj it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated"><a class="ae lq" href="https://en.wikipedia.org/wiki/Longest_palindromic_substring" rel="noopener ugc nofollow" target="_blank">最长回文子串</a>，维基百科文章。</li><li id="4ec5" class="ni nj it kw b kx nt la nu ld nv lh nw ll nx lp np nq nr ns bi translated">Manacher，Glenn (1975)，“一种新的线性时间”在线“寻找一个字符串的最小初始回文的算法”，<a class="ae lq" href="https://en.wikipedia.org/wiki/Journal_of_the_ACM" rel="noopener ugc nofollow" target="_blank"><em class="lr">ACM杂志</em> </a> <em class="lr">。</em></li></ol></div></div>    
</body>
</html>