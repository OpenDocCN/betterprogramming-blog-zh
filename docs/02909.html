<html>
<head>
<title>Functional Programming With Java: An Introduction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数式编程:简介</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-with-java-an-introduction-daa783355731?source=collection_archive---------5-----------------------#2020-01-08">https://betterprogramming.pub/functional-programming-with-java-an-introduction-daa783355731?source=collection_archive---------5-----------------------#2020-01-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="297f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Java从来就不是函数式语言，但这并不意味着我们不能尝试</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/321bc0be2d02cb6f5e19f46f6598a1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MG52px11rIccI8oKk1ZRAg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">威廉·戴尼奥在<a class="ae ky" href="https://unsplash.com/s/photos/try?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e723" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java被设计成一种通用编程语言<a class="ae ky" href="https://en.wikipedia.org/wiki/General-purpose_language" rel="noopener ugc nofollow" target="_blank"><em class="lv"/></a><em class="lv">，其核心是基于类的面向对象</em>。</p><p id="f471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着2014年版本8的发布，一种更加函数化的编程风格变得可行。这个故事试图揭示函数式编程的深度。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="b100" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">什么是函数式编程？</h1><p id="46b0" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">函数式编程(FP)范式是从1936年<a class="ae ky" href="https://en.wikipedia.org/wiki/Alonzo_Church" rel="noopener ugc nofollow" target="_blank">阿隆佐·邱奇</a>发明的<em class="lv">λ演算</em>演变而来的，“一种数学逻辑中的形式系统，用于基于函数抽象和应用使用变量绑定和替换来表达计算”(<a class="ae ky" href="https://en.wikipedia.org/wiki/Lambda_calculus" rel="noopener ugc nofollow" target="_blank">维基百科</a>)。</p><blockquote class="na nb nc"><p id="0a5a" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">一个科学流派或学科的哲学和理论框架，在此框架内，理论、定律、概括和为支持它们而进行的实验得以形成<br/>–<a class="ae ky" href="https://www.merriam-webster.com/dictionary/paradigm" rel="noopener ugc nofollow" target="_blank">韦氏词典</a></p></blockquote><p id="44d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助声明式编程风格，FP试图将我们的代码绑定在纯数学函数中，以构建可求值的表达式，而不是语句。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="85e4" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">函数式编程的核心概念</h1><p id="ee14" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">对函数式编程所基于的支柱做一个简短的概述，这样我们可以稍后检查Java是否适合。</p><h2 id="c7cd" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">纯函数</h2><p id="940b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">一个纯函数有两个基本属性:</p><ul class=""><li id="53d2" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">同样的输入产生同样的输出。</li><li id="f8c8" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">没有副作用，例如，影响全局状态或更改参数值。</li></ul><p id="649f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个属性保证了纯函数可以安全地在任何环境中使用，甚至是以并行/并发的方式。</p><h2 id="984c" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">对透明性有关的</h2><p id="15c7" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于不变输入参数的结果是可预测的，我们可以用返回值替换曾经运行过的函数。这叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Referential_transparency" rel="noopener ugc nofollow" target="_blank"> <em class="lv">参照透明</em> </a>。</p><p id="a771" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是纯粹的<em class="lv">T2表达式的结果，可以作为一种叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank"> <em class="lv">记忆化</em> </a>或“函数调用缓存”的优化技术来使用，以避免对已经求值的表达式进行不必要的重新计算。</em></p><h2 id="7ad4" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">不变</h2><p id="3514" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">改变数据结构会产生意想不到的副作用，我们必须对此进行检查。有了不变性，我们可以保持数据结构的可预测性和无副作用，并且更容易推理。</p><p id="24dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据结构在初始化后不应该被修改。要改变/改变一个数据结构，我们必须创建一个包含改变值的新变量。</p><p id="e8e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像纯函数一样，我们可以安全地使用任何数据结构而没有副作用，即使在并行/并发环境中，也不会因为不同步的访问或对超出范围的状态的更改而产生不确定的结果或问题。</p><h2 id="32e5" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">递归</h2><p id="3cd4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">类似循环的自调用函数，多次执行相同的表达式，直到达到结束条件，并返回“非自函数调用”。这很重要，否则我们很容易以无限递归结束，直到我们得到一个<code class="fe og oh oi oj b">java.lang.StackOverflowError</code>。</p><h2 id="53b6" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">一阶和高阶</h2><p id="5b4b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">像任何其他值一样，函数应该是一等公民，所以它们需要能够被赋给变量，被其他函数用作参数，并且能够被函数返回。</p><p id="e06c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">高阶函数是通过接受一个或多个函数作为参数，或返回一个函数作为其结果，或两者兼有来定义的。这是下一个支柱所必需的。</p><h2 id="9314" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">操作组合</h2><p id="a962" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">纯函数的组合创建了一个更复杂的表达式。通过这种方式，初始函数可以是小的、有主题的、可重用的，但是组合的函数将在数据结构中执行更完整的任务。</p><blockquote class="na nb nc"><p id="bd38" class="kz la lv lb b lc ld ju le lf lg jx lh nd lj lk ll ne ln lo lp nf lr ls lt lu im bi translated">“在数学中，函数合成是取两个函数<strong class="lb iu"> <em class="it"> f </em> </strong>和<strong class="lb iu"> g </strong>并产生一个函数<strong class="lb iu"> <em class="it"> h </em> </strong>使得<strong class="lb iu"><em class="it">h(x)= g(f(x))</em></strong><em class="it"/><br/>–<a class="ae ky" href="https://en.wikipedia.org/wiki/Function_composition" rel="noopener ugc nofollow" target="_blank">维基</a></p></blockquote></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="78bc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">用Java进行函数式编程</h1><p id="1691" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">添加了<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank"> lambdas </a>使得使用更像函数的编程风格成为可能。尤其是<a class="ae ky" href="https://jcp.org/en/jsr/detail?id=335" rel="noopener ugc nofollow" target="_blank">流</a> <em class="lv"> </em>和<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" rel="noopener ugc nofollow" target="_blank">选项</a>大量使用。</p><p id="567b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于选项的更多信息，您可以查看我的文章<a class="ae ky" href="https://medium.com/better-programming/better-null-handling-with-java-optionals-4793a8566710" rel="noopener"> <em class="lv">用Java选项更好地处理空值</em> </a> <em class="lv">。</em></p><p id="bae9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是新的特性能对抗FP的实际范例吗？或者仅仅是<a class="ae ky" href="https://en.wikipedia.org/wiki/Syntactic_sugar" rel="noopener ugc nofollow" target="_blank">匿名类</a><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html" rel="noopener ugc nofollow" target="_blank">等的</a>语法糖？</p><h2 id="7ffc" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">句法糖</h2><p id="c005" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">lambda函数的一般语法是:<code class="fe og oh oi oj b">(&lt;argument-list&gt;) -&gt; &lt;body&gt;</code>。从Java的角度来看，它由一个<a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank">函数接口</a>来表示，这个函数接口也可以由一个匿名类来表示。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="316b" class="ng me it oj b gy oo op l oq or">// LAMBDA EXPRESSION</span><span id="9807" class="ng me it oj b gy os op l oq or">Predicate&lt;String&gt; lambda = (input) -&gt; input != null;<br/></span><span id="8e44" class="ng me it oj b gy os op l oq or">// ANONYMOUS CLASS</span><span id="f1d1" class="ng me it oj b gy os op l oq or">Predicate&lt;String&gt; anonymous = new Predicate&lt;String&gt;() {</span><span id="5472" class="ng me it oj b gy os op l oq or">    @Override<br/>    public boolean test(String t) {<br/>        return t != null;<br/>    }<br/>};</span></pre><p id="c355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两个谓词做的是同样的事情，所以看起来真的很好的语法糖。但是有趣的问题是编译器和JVM在幕后做什么。用一个简单的<code class="fe og oh oi oj b">main</code>方法包装，结果是这样的:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="9770" class="ng me it oj b gy oo op l oq or">// ANONYMOUS CLASS<br/>0: new           #2 // class Anonymous$1<br/>3: dup<br/>4: invokespecial #3 // Method Anonymous$1."&lt;init&gt;":()V<br/>7: astore_1<br/>8: return<br/></span><span id="f681" class="ng me it oj b gy os op l oq or">// LAMBDA<br/>0: invokedynamic #2,  0 // InvokeDynamic #0:test:()Ljava/util/function/Predicate;<br/>5: astore_1<br/>6: return</span></pre><p id="b588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">匿名版本创建了一个匿名类<code class="fe og oh oi oj b">Anonymous$1</code>的新对象，产生了三个操作码。我们忽略了<code class="fe og oh oi oj b">7: astore_1</code>，因为lambda也需要<a class="ae ky" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.astore_n" rel="noopener ugc nofollow" target="_blank">保存对局部变量</a>的引用。</p><p id="8e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">lambda版本只需要一个操作码，新引入的操作码<code class="fe og oh oi oj b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/multiple-language-support.html#invokedynamic" rel="noopener ugc nofollow" target="_blank">invokedynamic</a></code>。</p><p id="bd03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，仅仅比较操作码计数是不公平的，因为在<code class="fe og oh oi oj b">invokedynamic</code>调用背后发生了很多事情。我们在字节码中看不到JVM实际上是如何处理lambda的。</p><p id="e9e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作码<code class="fe og oh oi oj b">invokedynamic</code>实际上是为Java 7创建的，以支持JVM更多的动态方法调用，改进动态语言，如<a class="ae ky" href="http://groovy-lang.org/" rel="noopener ugc nofollow" target="_blank"> Groovy </a>或<a class="ae ky" href="https://www.jruby.org/" rel="noopener ugc nofollow" target="_blank"> JRuby </a>。</p><p id="b136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JVM不是在编译时链接动态方法，如lambdas，而是在第一次执行之前将动态<a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/CallSite.html" rel="noopener ugc nofollow" target="_blank">调用点</a>与实际的目标方法链接起来。</p><p id="d319" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一次调用时使用一个<a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/lang/invoke/package-summary.html#jvm_mods" rel="noopener ugc nofollow" target="_blank">引导方法</a>来链接它并返回一个方法句柄。这有点像我们在代码中使用反射，但是更安全，并且直接由JVM执行。</p><p id="04c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建lambda有不同的策略(动态代理、匿名内部类、<code class="fe og oh oi oj b">MethodHandle</code>)，但是决策是由JVM在运行时做出的，而不是在编译时静态做出的。并且bootstrap方法只被调用一次。</p><p id="7f49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，这不仅仅是<em class="lv">的语法糖。Lambda表达式使JVM能够以新的方式优化我们的函数式代码，甚至允许JVM自行重用lambda。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3e2e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">功能核心概念和Java</h1><p id="a796" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">关于使用lambdas和匿名类的技术差异就说到这里，让我们看看FP范例是如何支持的。</p><h2 id="6586" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">纯函数</h2><p id="b7d8" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">检查。相同的输入导致相同的输出。没有副作用。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="7753" class="ng me it oj b gy oo op l oq or">double circumference(double radius) {<br/>    return 2.0 * Math.PI * radius;<br/>}</span></pre><h2 id="4a34" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">对透明性有关的</h2><p id="a75a" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">理论上，参照透明是可能的。我们有纯函数，我们可以缓存函数调用。</p><p id="d3e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是没有这样做的语言构造或助手。JVM可能会优化调用、内联结果等。，但不像其他语言中的<a class="ae ky" href="https://clojuredocs.org/clojure.core/memoize" rel="noopener ugc nofollow" target="_blank"> Clojure </a>那么容易。</p><h2 id="753e" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">不变</h2><p id="f475" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在JDK有很多不可变的和事实上不可变的类:</p><ul class=""><li id="eb6b" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated"><code class="fe og oh oi oj b">String</code>(仅事实上，hashCode是延迟计算的)。</li><li id="271e" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">值类型包装器，如<code class="fe og oh oi oj b">Integer</code>、<code class="fe og oh oi oj b">Boolean</code>、<code class="fe og oh oi oj b">Long</code>。</li><li id="5cbf" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><code class="fe og oh oi oj b">java.time</code>班级。</li><li id="87ed" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">使用<a class="ae ky" href="http://openjdk.java.net/jeps/269" rel="noopener ugc nofollow" target="_blank"> Java 9 </a>的不可变集合。</li><li id="b1bd" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi">…</li></ul><p id="3392" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以让自己的数据结构不可变，或者手动，或者通过使用像<a class="ae ky" href="https://immutables.github.io/" rel="noopener ugc nofollow" target="_blank"> Immutables </a>这样的库。但它仍然是一个实现细节，而不是像其他编程语言那样的语言特性。</p><h2 id="628e" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">递归</h2><p id="87fd" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">检查。虽然Java编译器不支持<a class="ae ky" href="https://en.wikipedia.org/wiki/Tail_call" rel="noopener ugc nofollow" target="_blank">尾调用优化</a>。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="0d44" class="ng me it oj b gy oo op l oq or">long factorial(long n) {<br/>    // Additional checks omitted...</span><span id="a79b" class="ng me it oj b gy os op l oq or">    // End condition<br/>    if (n == 1) {<br/>        return 1;<br/>    }</span><span id="b933" class="ng me it oj b gy os op l oq or">    // Recursive call<br/>    return n * factorial(n-1);<br/>}</span></pre><h2 id="645a" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">一阶和高阶</h2><p id="3d69" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">检查。但是Java一直是一种冗长的语言，所以它不像其他语言那样优雅。</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="2f37" class="ng me it oj b gy oo op l oq or">// FIRST-CLASS<br/>Supplier&lt;String&gt; lambda = myObject::toString;</span><span id="718d" class="ng me it oj b gy os op l oq or">// HIGHER-ORDER<br/>Supplier&lt;String&gt; higherOrder(Supplier&lt;String&gt; fn) {<br/>    String result = fn.get();<br/>    return () -&gt; result;<br/>}</span></pre><h2 id="c247" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">操作组合</h2><p id="779d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">检查。接口<code class="fe og oh oi oj b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" rel="noopener ugc nofollow" target="_blank">java.util.function.Function</a></code>提供了功能组合的方法:</p><pre class="kj kk kl km gt ok oj ol om aw on bi"><span id="c033" class="ng me it oj b gy oo op l oq or">Function&lt;Integer, Integer&gt; square = (input) -&gt; input * input;<br/>Function&lt;Integer, Integer&gt; multiplyByTen = (input) -&gt; input * 10;</span><span id="c6b1" class="ng me it oj b gy os op l oq or">// COMPOSE: argument will be run first</span><span id="3756" class="ng me it oj b gy os op l oq or">Function&lt;Integer, Integer&gt; multiplyByTenAndSquare = square.compose(multiplyByTen);</span><span id="f6aa" class="ng me it oj b gy os op l oq or">// ANDTHEN: argument will run last</span><span id="5de6" class="ng me it oj b gy os op l oq or">Function&lt;Integer, Integer&gt; squareAndMultiplyByTen = square.andThen(multiplyByTen);</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="e724" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">Java是函数式语言吗？</h1><p id="0b2b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">不完全是。但这从来不是它的意图。</p><p id="d837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管Java表面上符合许多函数式编程范例，但它本质上并不是一种函数式语言。</p><p id="ace3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它仍然是一种基于类的面向对象的通用编程语言，但是现在支持函数构造。然而，lambdas和更像函数的编程风格是我们工具带的一个有价值的补充。</p><p id="4408" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">面向对象与函数式。不是非此即彼。</p><p id="f799" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数函数概念必须遵守惯例和开发人员规范，而不是由编译器强制执行，而不是依赖语言特性。</p><p id="cb84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在适当的情况下，我们仍然应该采用功能范式为我们的代码库提供的核心概念和约束。</p><ul class=""><li id="041e" class="ns nt it lb b lc ld lf lg li nu lm nv lq nw lu nx ny nz oa bi translated">不变性:总是一个很好的想法，不仅仅是对于函数式编程。多亏了第三方库，我们可以使用不可变的数据结构，而不需要太多额外的代码。</li><li id="d88c" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">没有非法状态:设计你的状态总是合法的。避免空值、异常和锁定/同步。</li><li id="ac92" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">泛型:处理正确的类型，不依赖于<code class="fe og oh oi oj b">Object</code>或<code class="fe og oh oi oj b">instanceof</code>，有助于在编译时识别不正确的用法。</li><li id="b0ce" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated">没有魔力:任何不可预测的行为或副作用都与功能范式相反。如果可能的话，应该避免使用利用带有反射和/或代理的运行时愚蠢行为的库。</li></ul><p id="d6ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">底线是，我们应该知道所有的概念以及如何使用它们。而且知道什么时候将它们应用到我们的代码中是合适的。</p><p id="af65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望Java不断进化到一个更具功能性的领域，以更少的冗长和更简洁的代码提供更多的优势。</p><p id="bb7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一部分将强调不同类型的可用<a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html#package.description" rel="noopener ugc nofollow" target="_blank">功能接口</a>以及如何使用它们。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="c966" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">与其他JVM函数式语言的比较</h1><p id="c93c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了给你一个更好的概述，这里有一些运行在JVM上的其他语言，包括函数原理。</p><h2 id="0fa2" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">斯卡拉</h2><p id="ce07" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>和Java一样，是一种通用语言，而不是专门的函数式编程语言。</p><p id="2548" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是与Java不同，它从一开始就被设计成函数式编程，具有语言级的特性，比如不变性。并且在两个方向上都有很好的Java互操作。</p><h2 id="9f89" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">Clojure</h2><p id="57e2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">Clojure是JVM上的一种方言，一种真正的函数式编程语言。</p><p id="f7f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为Java开发人员，Scala很容易理解，而Clojure则是另一种野兽。代码是数据(<a class="ae ky" href="https://en.wikipedia.org/wiki/Homoiconicity" rel="noopener ugc nofollow" target="_blank">同象性</a>)，一切都是不可变的，数据结构是持久的，空处理是正确的，内置记忆，以及许多许多的括号。</p><p id="e2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个缺点，至少在我看来，是如果你想从Java中使用Clojure的话，Java互操作。反过来也很好。</p><h2 id="24aa" class="ng me it bd mf nh ni dn mj nj nk dp mn li nl nm mp lm nn no mr lq np nq mt nr bi translated">科特林</h2><p id="b64d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>是另一种通用语言，函数式编程根植于其中。好的Java interop，安卓一级语言。绝对值得一试。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="fbfc" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">资源</h1><ul class=""><li id="d54b" class="ns nt it lb b lc mv lf mw li ot lm ou lq ov lu nx ny nz oa bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" rel="noopener ugc nofollow" target="_blank">λ表达式</a></li><li id="fa54" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">功能编程</a></li><li id="1c5c" class="ns nt it lb b lc ob lf oc li od lm oe lq of lu nx ny nz oa bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/multiple-language-support.html#invokedynamic" rel="noopener ugc nofollow" target="_blank">调用的动态</a> — Oracle文档</li></ul><div class="ow ox gp gr oy oz"><a href="https://medium.com/better-programming/functional-programming-with-java-whats-in-the-box-4c0ee20035af" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">Java函数式编程:盒子里是什么</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">JDK中可用的不同种类的功能接口</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">medium.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">Java函数式编程:流</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">最佳实践概述</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">medium.com</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn ks oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://medium.com/better-programming/functional-programming-with-java-immutability-8dc748e85f9e" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">Java函数式编程:不变性</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">具有不可变状态的更好的数据结构</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">medium.com</p></div></div><div class="pi l"><div class="pp l pk pl pm pi pn ks oz"/></div></div></a></div></div></div>    
</body>
</html>