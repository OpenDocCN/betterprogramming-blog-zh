<html>
<head>
<title>Using the Decorator Pattern to Auto-Instrument .Net Classes With Otel Tracing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用装饰器模式进行自动检测。使用Otel跟踪的. Net类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-decorator-pattern-to-auto-instrument-net-classes-with-otel-tracing-781bf2be62ff?source=collection_archive---------9-----------------------#2022-06-01">https://betterprogramming.pub/using-the-decorator-pattern-to-auto-instrument-net-classes-with-otel-tracing-781bf2be62ff?source=collection_archive---------9-----------------------#2022-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3cda" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">装饰者如何帮助OpenTelemetry tracing仪器保持干燥</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/404025f455aafcceda27d3ca9cc5e9f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LxhBLz1PDiERRrkZO-tG6A.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="6c33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">。NET在最近的版本中明确地包含了OpenTelemetry。它支持使用内置系统定义轨迹和跨度。诊断类极大地简化了检测代码的任务。我唯一吹毛求疵的抱怨。NET实现是一种术语混乱，它试图通过背离标准的OTEL命名法来制造这种混乱。</p><p id="1530" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，开放式遥测跨度在中称为“活动”。NET，而“ActivitySource”通常被称为“追踪器”。“如果不在基本实体的特定语言命名之间来回转换，OpenTelemetry就已经够混乱的了。</p><p id="12c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最近，我有机会做一些样本项目，这时另一件事引起了我的注意:我注意到我是如何重复地复制/粘贴span/activities的样板设置代码的。实际上，确保将这些声明包含在代码的关键区域中需要一定的原则。</p><p id="fef6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让问题更复杂的是，我似乎总是错过最关键的部分——可能是因为我在处理它们时，脑子里都是实际的代码决策，所以忘记了复制粘贴的仪式。</p><p id="f17a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面您可以看到<code class="fe lr ls lt lu b">Span</code> / <code class="fe lr ls lt lu b">Activity</code>所需的样板文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ebc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">命名跨度也可能是一个恼人的打发时间。维护一致的span命名和粒度通常感觉像是分类学中的一项练习。为了简化起见，如果我设法使它足够清晰和有描述性，我通常会将span名称设置为与封闭方法名称相同。</p><p id="c2bb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lx" href="https://en.wikipedia.org/wiki/Decorator_pattern#:~:text=In%20object%2Doriented%20programming%2C%20the,objects%20from%20the%20same%20class." rel="noopener ugc nofollow" target="_blank">装饰模式</a>可以帮助解决这些问题，并提供一种简单优雅的方式将操作与OTEL活动包装在一起。此外，通过将与创建范围相关的逻辑从应用程序域类中分离出来，我们可以更容易地更改、管理和标准化跟踪的跨应用程序方面。</p><p id="5d9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，装饰者也有他们的开销和限制，我绝对不推荐使用低级类或者非常短的性能敏感操作的装饰者。</p><p id="e7f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这篇文章中，我们将介绍在一个<a class="ae lx" href="https://github.com/digma-ai/OpenTelemetry.Instrumentation.Digma" rel="noopener ugc nofollow" target="_blank">示例</a>ASP.NET核心MVC应用程序中创建一个<code class="fe lr ls lt lu b">Decorator</code>来处理不同服务方法的创建活动或OTEL跨度的步骤。如果你只是想在你的代码中使用这个<code class="fe lr ls lt lu b">Decorator</code>并且不太关心进程，它也已经被添加到Digma open telemetry helper<a class="ae lx" href="https://www.nuget.org/packages/OpenTel.Instrumentation.Digma/" rel="noopener ugc nofollow" target="_blank">Nuget包</a>中，并在<a class="ae lx" href="https://github.com/digma-ai/OpenTelemetry.Instrumentation.Digma#tracingdecorator" rel="noopener ugc nofollow" target="_blank"> this </a> repo中维护。</p><h1 id="18e3" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">使用DispatchProxy创建基本跟踪装饰器</h1><p id="ce46" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">的。NET DispatchProxy类，允许我们通过创建实现接口的代理对象来为任何接口创建通用包装器。它通常用于分离出与被调用的代码相关的特定问题，如日志记录、缓存等。</p><p id="131e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将创建一个<code class="fe lr ls lt lu b">DispatchProxy</code>的子类，命名为<code class="fe lr ls lt lu b">TracingDecorator</code>。与基类类似，我们将使用一个静态构造函数，它接受对象来修饰和实例化我们的代理对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="ce0f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意，作为初始对象配置的一部分，我们设置了一些基本的对象参数，包括对修饰对象的引用，以及我们将用来创建新的<code class="fe lr ls lt lu b">Activity</code>实例的<code class="fe lr ls lt lu b">ActivitySource</code>对象。</p><p id="3cc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们需要覆盖<code class="fe lr ls lt lu b">DispatchProxy</code> <code class="fe lr ls lt lu b">Invoke</code>方法，每当在代理对象上执行一个接口方法时，就会调用这个方法。我们的实现将调用委托给修饰对象，并用一个<code class="fe lr ls lt lu b">Activity</code>包装整个操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6d10" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以为我们创建的活动使用任何命名约定。在这种情况下，我们将使用修饰的对象类型和方法名创建一个完全限定名(我们将在后面进行改进)。最后，我们确保在重新抛出之前将任何异常记录为活动事件，以免干扰正常的处理流程。</p><h1 id="9032" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">使用装饰器</h1><p id="2425" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">现在我们差不多已经有了一个初始版本，我们可以通过包装一个应用程序类来测试它。对于这个例子，我使用了手头的一个用于OTEL的示例应用程序。我选择装饰一个域服务，因为对于装饰者来说，这似乎是一个足够安全的用例。作为一个高级构造，它对轻微的性能下降不敏感，这可能也被请求已经经历的许多不同的层和抽象所掩盖。</p><p id="876d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用我们上面定义的静态构造函数，初始化非常简单:</p><pre class="kg kh ki kj gt mv lu mw mx aw my bi"><span id="84a1" class="mz lz iq lu b gy na nb l nc nd">IMoneyTransferDomainService decoratedInstance = TraceDecorator&lt;IMoneyTransferDomainService&gt;.Create(domainServiceInstance)</span></pre><p id="0ae4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你用的是。NET DI框架，但是，用我们新的修饰代理简单地覆盖注册对象会容易得多。有多种方法可以实现这种改变。我发现的最简单的一个是使用优秀的<a class="ae lx" href="https://github.com/khellang/Scrutor" rel="noopener ugc nofollow" target="_blank"> Scrutor </a> Nuget包。Scrutor提供了一个叫做<code class="fe lr ls lt lu b">Decorate</code>的方便的扩展方法，这正是我们所需要的。代码如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="736e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本上，我们替换了<code class="fe lr ls lt lu b">ServiceCollection</code>中的当前映射，这样它将使用我们修饰的实例。我们传递一个工厂lambda，它接受原始的未修饰对象(在它已经被初始化并且它的依赖项已经被注入之后),并为同一个接口提供了<code class="fe lr ls lt lu b">TracingDecorator</code>代理。</p><p id="00d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们现在重新运行应用程序，并从其中一个方法中删除用于跟踪的样板代码，我们将能够看到它是如何被我们的<code class="fe lr ls lt lu b">TracingDecorator</code>类自动检测的:</p><div class="kg kh ki kj gt ab cb"><figure class="ne kk nf ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/3231e8f0ce3a0bf71fda7c171be8f341.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*XbXpcwsBYQL52w7Eu_llrw.png"/></div></figure><figure class="ne kk nk ng nh ni nj paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/7eaea71304b549e74aede562a11ce250.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*ChPyvcli9haNiGZYOmSBOA.png"/></div></figure></div><h1 id="671c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">改进我们的初始实现:记录异常、支持自定义Span名称等等</h1><p id="18e2" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">为了使我们的装饰器不那么死板，我们将添加一些属性，允许我们定制它行为的某些方面。例如，用户可能希望使用不同的<code class="fe lr ls lt lu b">Activity</code>名，或者明确定义异常记录行为。</p><p id="686b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们将定义一个包含所需信息的属性:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c919" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，我们可以更改装饰器实现来检索属性值并使用它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3423" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，通过在修饰类上设置正确的属性值，我们可以很容易地定义我们希望我们的跨度如何表现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/32e3fa84285796a9d312c05935eaf718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WnG5z68icpBHV_oKIsOKSg.png"/></div></div></figure><p id="7e74" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更干净的实现，以标准化的方式消除了不必要的重复和更好的跟踪处理。</p><h1 id="141e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">进一步的改进</h1><p id="439e" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在这个例子中，我发现自己很想给<code class="fe lr ls lt lu b">TracingDecorator</code>添加额外的有用功能，包括:</p><ul class=""><li id="9de2" class="nm nn iq kx b ky kz lb lc le no li np lm nq lq nr ns nt nu bi translated">定义是自动检测所有接口方法还是只检测那些标有<code class="fe lr ls lt lu b">TraceActivity</code>属性的接口方法的能力。</li><li id="1cd0" class="nm nn iq kx b ky nv lb nw le nx li ny lm nz lq nr ns nt nu bi translated">能够在接口上全局设置span属性，并将它们自动注入该接口的每个span。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/94373af54e2a872f5d0a9c3101367ab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XO9rNuiCiEUA4j7eaFH5gQ.png"/></div></div></figure><ul class=""><li id="bf9a" class="nm nn iq kx b ky kz lb lc le no li np lm nq lq nr ns nt nu bi translated">定义一个<code class="fe lr ls lt lu b">ISpanNamingSchema</code>接口，允许用一个标准的命名模式来设置装饰器，这个命名模式可能不同于我们上面实现的默认模式。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/78d2749426d1788edad9121eb3864e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yyHTzQImJ_Yzumqmbz9RhQ.png"/></div></div></figure><h1 id="244a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">你还有什么要补充的？</h1><p id="f653" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">你可以在<a class="ae lx" href="https://github.com/digma-ai/OpenTelemetry.Instrumentation.Digma" rel="noopener ugc nofollow" target="_blank">Digma open telemetry repository</a>中找到完整的源代码。让我看看这是否对你的项目有用！此外，如果有任何你觉得有用的功能，请随时联系或打开Github上的问题或PR。</p><p id="8d56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你对OTEL和可观察性感兴趣，我已经写了一些关于这个主题的其他帖子，特别是关于如何在开发中利用OTEL，你可以在这里找到<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/the-observant-developer-part-1-1939d53fd5a4">这里</a>和<a class="ae lx" rel="noopener ugc nofollow" target="_blank" href="/improving-code-design-with-opentelemetry-a-practical-guide-a08e6440c24d">这里</a>。</p><pre class="kg kh ki kj gt mv lu mw mx aw my bi"><span id="1beb" class="mz lz iq lu b gy na nb l nc nd"><strong class="lu ir">Want to Connect?</strong></span><span id="d69d" class="mz lz iq lu b gy oc nb l nc nd">You can reach me, Roni Dover, on Twitter at @doppleware.</span><span id="c3f2" class="mz lz iq lu b gy oc nb l nc nd">Follow my open source project for continuous feedback at <a class="ae lx" href="https://github.com/digma-ai/digma" rel="noopener ugc nofollow" target="_blank">https://github.com/digma-ai/digma</a>.</span></pre></div></div>    
</body>
</html>