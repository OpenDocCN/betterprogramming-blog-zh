<html>
<head>
<title>Anatomy of a PostgreSQL Query Plan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PostgreSQL查询计划的剖析</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/anatomy-of-a-postgresql-query-plan-875469119fb?source=collection_archive---------4-----------------------#2021-04-13">https://betterprogramming.pub/anatomy-of-a-postgresql-query-plan-875469119fb?source=collection_archive---------4-----------------------#2021-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="14a1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在优化查询之前，首先要看的是查询规划器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0886a95184c8c5e2f67e81c967254fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hePuaZnpN77XKtep.png"/></div></div></figure><p id="aa46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理解PostgreSQL查询计划对于开发人员和数据库管理员来说都是一项重要的技能。这可能是我们开始优化查询的第一件事，也是验证和确认我们优化的查询是否确实按照我们预期的方式进行了优化的第一件事。</p><h2 id="a659" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">PostgreSQL查询计划的剖析</h2><p id="849b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在我们尝试阅读查询计划之前，问一些非常基本的问题很重要:</p><ul class=""><li id="fb86" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">为什么我们甚至需要一个查询计划？</li><li id="93c0" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">这个计划到底代表了什么？</li><li id="14ab" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">PostgreSQL是否不够智能，无法自动优化我的查询？我为什么要担心策划者？</li><li id="2320" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">策划书是我唯一需要看的东西吗？</li></ul><p id="df82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个查询都经历不同的阶段，理解每个阶段对数据库的意义非常重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/d11b12118bb584280072a750ccf14e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*orpr1WrsdSgHQx01.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">Postgres查询生命周期图，由<a class="ae nh" href="https://app.diagrams.net/" rel="noopener ugc nofollow" target="_blank">https://app.diagrams.net/</a>制作</p></figure><p id="074b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一阶段是通过<a class="ae nh" href="https://www.microfocus.com/documentation/xdbc/win20/BKXDXDINTRXD1.5.html" rel="noopener ugc nofollow" target="_blank"> JDBC/ODBC </a>(分别由微软和甲骨文创建的用于与数据库交互的API)或通过其他方式如<a class="ae nh" href="https://www.postgresql.org/docs/13/app-psql.html" rel="noopener ugc nofollow" target="_blank">PSQL</a>(Postgres的终端前端)连接到数据库。</p><p id="862f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第二阶段是将查询翻译成一种称为解析树的中间格式。讨论<a class="ae nh" href="https://www.postgresql.org/docs/current/parser-stage.html" rel="noopener ugc nofollow" target="_blank">解析树</a>的内部结构超出了本文的范围，但是您可以想象它就像一个SQL查询的编译形式。</p><p id="a986" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第三个阶段是我们所说的重写系统/规则系统。它采用第二阶段生成的解析树，并以一种规划器/优化器可以开始工作的方式重写它。</p><p id="1133" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第四阶段是最重要的阶段，也是数据库的核心。如果没有规划器，执行者将会对如何执行查询、使用什么索引、是否扫描更小的表以删除更多不必要的行等一无所知。这个阶段是我们将在本文中讨论的。</p><p id="6019" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第五个也是最后一个阶段是执行程序，它实际执行并返回结果。几乎所有的数据库系统都遵循或多或少类似于上述的过程。</p><h2 id="9617" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">数据设置</h2><p id="3710" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们用假数据建立一些虚拟表来运行我们的实验。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="6f86" class="lq lr it nj b gy nn no l np nq">create table fake_data(id serial, name text, sentence text, company text);</span></pre><p id="431b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后用数据填充这个表。我使用下面的Python脚本来生成随机行。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="883e" class="lq lr it nj b gy nn no l np nq">from faker import Faker<br/><br/>fake = Faker()<br/># Change this range to whatever value you like<br/>MAX_RANGE = 1000<br/><br/>with open('data.csv', 'w') as f:<br/>    for i in range(0, MAX_RANGE):<br/>        name = fake.name().replace(",", "")<br/>        <br/>        sentence = fake.sentence(<br/>            nb_words=16, variable_nb_words=True<br/>        ).replace(",", "")<br/>        <br/>        company = fake.company().replace(",", "")<br/><br/>        content = "'" + name + "'" + "," + \<br/>                  "'" + sentence + "'" + "," \<br/>                  + "'" + company + "'" + "\n"<br/><br/>        f.write(content)</span></pre><p id="4a18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该脚本使用<a class="ae nh" href="https://faker.readthedocs.io/en/master/index.html" rel="noopener ugc nofollow" target="_blank"> Faker库</a>生成假数据。它将在根级别生成一个<code class="fe nr ns nt nj b">csv</code>文件，并可以通过下面的命令作为常规的<code class="fe nr ns nt nj b">csv</code>导入PostgreSQL。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="e867" class="lq lr it nj b gy nn no l np nq">COPY fake_data(name, sentence, company) <br/>FROM '/path/to/csv' DELIMITER ','</span></pre><p id="363a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe nr ns nt nj b">id</code>是串行的，它将由PostgreSQL自动填充。该表现在包含了<code class="fe nr ns nt nj b">1119284</code>条记录。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="18fa" class="lq lr it nj b gy nn no l np nq">SELECT COUNT(*) FROM fake_data;</span></pre><p id="dd8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的大多数例子都基于上表。有意保持简单，将重点放在流程而不是表/数据的复杂性上。</p><p id="592d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下示例使用了<a class="ae nh" href="https://www.arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype </a>编辑器。帖子的特色图片来自<a class="ae nh" href="https://explain.depesz.com/s/pIzU" rel="noopener ugc nofollow" target="_blank"> Depesz在线讲解工具</a>。</p><h2 id="3697" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">进入规划阶段</h2><p id="d07d" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">PostgreSQL和许多其他数据库系统让用户看到在计划阶段实际发生的事情。我们可以通过运行所谓的<code class="fe nr ns nt nj b">EXPLAIN</code>命令来做到这一点。</p><h2 id="3601" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">PostgreSQL解释查询</h2><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="9128" class="lq lr it nj b gy nn no l np nq">EXPLAIN SELECT * FROM fake_data LIMIT 10;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/82ef9548fc2538cf3c02771a092c9b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XkwYpS1L2DT8QX1z.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">解释查询输出显示为普通行。</p></figure><p id="26e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用<code class="fe nr ns nt nj b">EXPLAIN</code>，您可以在数据库实际执行查询计划之前查看它们。我们将在下一节中了解其中每一个的理解部分，但是让我们先来看看另一个叫做<code class="fe nr ns nt nj b">EXPLAIN ANALYSE</code>的<code class="fe nr ns nt nj b">EXPLAIN</code>的扩展版本。</p><h2 id="788c" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">一起解释分析</h2><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="431a" class="lq lr it nj b gy nn no l np nq">EXPLAIN ANALYSE SELECT * FROM fake_data LIMIT 10;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/113723e214d8f032c880c5bf6d30d1a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iu-ZTJNgDbvyAgnz.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">将ANALYZE参数添加到查询中会产生计时信息。</p></figure><p id="5941" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与<code class="fe nr ns nt nj b">EXPLAIN</code>不同，<code class="fe nr ns nt nj b">EXPLAIN ANALYSE</code>实际上在数据库中运行查询。该选项非常有助于理解计划者是否没有正确发挥其作用，即从<code class="fe nr ns nt nj b">EXPLAIN</code>和<code class="fe nr ns nt nj b">EXPLAIN ANALYSE</code>生成的计划是否存在巨大差异。</p><p id="cd75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">PostgreSQL对<code class="fe nr ns nt nj b">ANAYLYZE</code>和<code class="fe nr ns nt nj b">ANALYSE</code>都很熟悉</p><h2 id="2546" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">什么是数据库中的缓冲区和缓存？</h2><p id="9ab9" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们来看一个更有趣的指标<code class="fe nr ns nt nj b">BUFFERS</code>。这解释了有多少数据来自PostgreSQL缓存，有多少数据必须从磁盘获取。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c93d" class="lq lr it nj b gy nn no l np nq">EXPLAIN (ANALYSE,BUFFERS) SELECT * FROM fake_data LIMIT 10 OFFSET 200</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/9bdc381e030c4785a26e79cb8a84091f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*V_eKj_5sG2jekLI4.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">将BUFFERS作为参数显示了查询的页面命中率。</p></figure><p id="c74e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nr ns nt nj b">Buffers : shared hit=5</code>意味着五个<a class="ae nh" href="https://www.postgresql.org/docs/current/storage.html" rel="noopener ugc nofollow" target="_blank">页面</a>是从PostgreSQL缓存本身获取的。让我们将查询调整为从不同行偏移。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="c1b8" class="lq lr it nj b gy nn no l np nq">EXPLAIN (ANALYSE,BUFFERS) SELECT * FROM fake_data LIMIT 10 OFFSET 500</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/14a76802a36d3d655c591e57e2c4fa21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qg1Dbtcm2Kupd7WY.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">改变偏移量会导致不同的页面点击量。</p></figure><p id="65f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nr ns nt nj b">Buffers: shared hit=7 read=5</code>显示5页来自磁盘。<code class="fe nr ns nt nj b">read</code>部分是显示有多少页面来自磁盘的变量，而<code class="fe nr ns nt nj b">hit</code>如前所述来自缓存。如果我们再次执行相同的查询(记住<code class="fe nr ns nt nj b">ANALYSE</code>运行该查询)，那么所有的数据现在都来自缓存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/289d72d508e0c1365cd7d2549db3179b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2HFnAQBIkNNvfNN5.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">再次执行查询意味着缓存现在提供所有的结果。</p></figure><p id="9f82" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">PostgreSQL使用一种称为最近最少使用(LRU)缓存的机制将常用数据存储在内存中。理解缓存如何工作及其重要性是另一篇文章的主题，但现在我们必须理解的是PostgreSQL有一个坚如磐石的缓存机制，我们可以使用<code class="fe nr ns nt nj b">EXPLAIN (ANALYSE, BUFFERS)</code>命令来了解它是如何工作的。</p><h2 id="92a3" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">详细命令参数</h2><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="912e" class="lq lr it nj b gy nn no l np nq">EXPLAIN (ANALYSE,BUFFERS,VERBOSE) SELECT * FROM fake_data LIMIT 10 OFFSET 500</span></pre><p id="3b2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nr ns nt nj b">Verbose</code>是另一个提供额外信息的命令参数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ee1377e4cfd1f6b5e3a84a0c85d589a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qqHVAY6Y7FTKaeOI.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">VERBOSE命令参数将为复杂的查询提供更多的信息。</p></figure><p id="625e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意<code class="fe nr ns nt nj b">Output: id, name, sentence, company</code>是附加的。在一个复杂的查询计划中，将会打印出大量的其他信息。默认情况下，<code class="fe nr ns nt nj b">COSTS</code>和<code class="fe nr ns nt nj b">TIMING</code>选项为<code class="fe nr ns nt nj b">TRUE</code>设置，除非您想将其设置为<code class="fe nr ns nt nj b">FALSE</code>，否则无需明确指定。</p><h2 id="b643" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">Postgres格式解释</h2><p id="3e8a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">PostgreSQL能够以一种良好的格式给出查询计划，比如<code class="fe nr ns nt nj b">JSON</code>，这样这些计划就可以用一种与语言无关的方式来解释。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="02c4" class="lq lr it nj b gy nn no l np nq">EXPLAIN (ANALYSE,BUFFERS,VERBOSE,FORMAT JSON) SELECT * FROM fake_data LIMIT 10 OFFSET 500</span></pre><p id="4ff4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将以<code class="fe nr ns nt nj b">JSON</code>格式打印查询计划。您可以在Arctype中查看此格式，方法是复制其输出并将其插入另一个表中，如下图GIF所示。</p><p id="8c6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有各种其他格式，如下所示:</p><ul class=""><li id="40d8" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">文本(默认)</li><li id="b2d3" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">JSON(上例)</li><li id="ca1a" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">可扩展标记语言</li><li id="2026" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">YAML</li></ul><p id="1eb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还有另外两个选项叫做<code class="fe nr ns nt nj b">SETTINGS</code>和<code class="fe nr ns nt nj b">WAL</code>，它们可以包含在查询计划中，但是这超出了本文的范围。</p><p id="e957" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">总结一下:</p><ul class=""><li id="ebe1" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated"><code class="fe nr ns nt nj b">EXPLAIN</code>是您通常开始使用的计划类型，通常用于生产系统。</li><li id="ee8b" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe nr ns nt nj b">EXPLAIN ANALYSE</code>用于在获取查询计划的同时运行查询。这就是如何获得计划中的计划时间和执行时间细目，以及与执行查询的成本和实际时间的比较。</li><li id="1cb4" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe nr ns nt nj b">EXPLAIN (ANALYSE, BUFFERS)</code>用于分析之上，以获取来自缓存和磁盘的行数/页数以及缓存的行为方式。</li><li id="d1a0" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe nr ns nt nj b">EXPLAIN (ANALYSE, BUFFERS, VERBOSE)</code>获取关于查询的详细和附加信息。</li><li id="ee3e" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe nr ns nt nj b">EXPLAIN(ANALYSE,BUFFERS,VERBOSE,FORMAT JSON)</code>是如何以特定格式导出。在这种情况下，格式是JSON。</li></ul><p id="bd77" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一节中，我们将使用这些工具来研究PostgreSQL查询计划是如何工作的。为了便于阅读，我们将只查看PostgreSQL查询计划的文本格式。</p><h2 id="d280" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">查询计划的元素</h2><p id="6976" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">任何查询计划，不管有多复杂，都有一些基本的结构。在这一节中，我们将关注这些结构，这将帮助我们以抽象的方式理解查询计划。</p><h2 id="fbf9" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">查询的节点</h2><p id="295a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">查询计划由节点组成:</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="1341" class="lq lr it nj b gy nn no l np nq">EXPLAIN SELECT * FROM fake_data LIMIT 10 OFFSET 500;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/7a98f701876137ad03cbb9e16d67190a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iBUEpSz09jzIfZcp.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">节点是执行查询的关键部分。</p></figure><p id="4fff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以将节点视为数据库执行中的一个阶段。如上所示，节点大多是嵌套的。在它之前和之上完成了<code class="fe nr ns nt nj b">Seq Scan</code>，然后应用了<code class="fe nr ns nt nj b">Limit</code>子句。让我们添加一个<code class="fe nr ns nt nj b">Where</code>子句来理解进一步的嵌套。</p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="44ef" class="lq lr it nj b gy nn no l np nq">EXPLAIN SELECT * FROM fake_data where NAME = 'Sandra Smith' LIMIT 10</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/bbfa8c9d05e603e38a8de093a91fbe03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BClY3x2hi0KQx9Mv.png"/></div></div></figure><p id="e20b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">行刑是由内而外进行的。</p><ul class=""><li id="1337" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated">筛选name = Sandra Smith的行</li><li id="ba45" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">使用上述过滤器进行顺序扫描</li><li id="722e" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">在顶部应用限制条款</li></ul><p id="3d15" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，数据库识别出只需要十行，并且一旦达到所需的十行就不再扫描。请注意，我已经关闭了<code class="fe nr ns nt nj b">SET max_parallel_workers_per_gather =0;</code>，这样计划更简单。我们将在后面的文章中探讨并行化。</p><h2 id="695f" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">查询计划器中的成本</h2><p id="e520" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">成本是数据库查询计划的重要组成部分，由于其表示方式不同，成本很容易被误解。让我们再来看看这个简单的有成本的计划。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/ed4ed584ac7be175d36378e510573dd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/0*Po_4kU3-OUp1Ny19.png"/></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">成本在解释输出中表示。</p></figure><p id="dcd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下几点很重要:</p><ul class=""><li id="6e35" class="mo mp it kw b kx ky la lb ld mq lh mr ll ms lp mt mu mv mw bi translated"><code class="fe nr ns nt nj b">LIMIT</code>条款的启动成本不为零。这是因为启动成本加起来最高；你看到的是它下面的节点的开销。</li><li id="64a7" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">总成本是一个任意的衡量标准，与使用者相比，它与规划者更相关。在任何实际用例中，您都不会同时获取整个表数据。</li><li id="9180" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated">众所周知，顺序扫描在评估方面很糟糕，因为数据库不知道如何优化它们。索引可以极大地提高使用<code class="fe nr ns nt nj b">WHERE</code>子句的查询速度。</li><li id="cccd" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp mt mu mv mw bi translated"><code class="fe nr ns nt nj b">Width</code>很重要，因为行越宽，需要从磁盘中获取的数据就越多。这就是为什么遵循数据库表的规范化非常重要。</li></ul><p id="69a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们实际运行查询，那么成本会更有意义。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/913278f16deb679d7c9cd219c3f35e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a7yE1qOUTVVhtbql.png"/></div></div></figure><h2 id="e984" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">数据库规划和执行</h2><p id="c380" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">计划和执行时间是只能通过<code class="fe nr ns nt nj b">EXPLAIN ANALYSE</code>选项获得的指标。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/cb5ac609ecff8946af2450df8a8d934f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*APb5wGEEVvuJdH34.png"/></div></div><p class="nd ne gj gh gi nf ng bd b be z dk translated">规划和执行是查询执行的两个不同阶段。</p></figure><p id="be29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">计划者(计划时间)根据各种参数决定查询应该如何运行，而执行者(执行时间)运行查询。上面指出的这些参数是抽象的，适用于任何类型的查询。运行时间以毫秒表示。在许多情况下，计划时间和执行时间可能不接近。在上面的例子中，计划者可能会花更多的时间来计划查询，而执行者可能会花更少的时间，但通常情况并非如此。它们不一定需要彼此匹配，但是如果它们偏离很多，那么是时候调查发生了什么。</p><p id="4f06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在典型的OLTP系统(如PostgreSQL)中，任何计划和执行加起来都应该少于50毫秒，除非是分析查询/大量写入/已知异常。记住，OLTP代表在线事务处理。在一个典型的企业中，交易量通常从数千到数百万。应该始终非常仔细地观察这些执行时间，因为这些较小的、成本较高的查询可能会累积起来并增加巨大的开销。</p><h2 id="51b6" class="lq lr it bd ls lt lu dn lv lw lx dp ly ld lz ma mb lh mc md me ll mf mg mh mi bi translated">从这里去哪里</h2><p id="a4a5" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们已经讨论了从查询生命周期到规划器如何做出决策的主题。我特意省略了像节点类型(扫描、排序、连接)这样的主题，因为它们需要专门的文章。本文的目标是对查询规划器的工作原理、影响其决策的因素以及PostgreSQL提供的工具有一个大致的了解，以便更好地理解规划器。</p><p id="8f75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们重温一下上面问的问题。</p><p id="0eaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="od">问:为什么我们甚至需要一个查询计划？</em></p><p id="d586" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答:“有计划的傻瓜比没有计划的天才强！”—古老的Arctype谚语。一个计划对于决定走哪条路是绝对必要的，特别是当决定是基于统计数据做出的时候。</p><p id="801f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="od">问:这个计划具体代表了什么？</em></p><p id="ee1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答:计划由节点、成本、计划和执行时间组成。节点是查询的基本构造块。成本是节点的基本属性。计划和执行时间，以查看实际时间。</p><p id="af14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问:PostgreSQL不够智能，无法自动优化我的查询吗？我为什么要担心策划者？</p><p id="5a95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答:PostgreSQL实际上非常聪明。随着每个版本的发布，规划器变得越来越好，但是没有完全自动化/完美的规划器。这是不实际的，因为优化可能对一个查询有利，但对另一个查询不利。计划者必须在某处划定界限，并给出一致的行为和表现。开发人员/DBA有很大的责任来编写优化的查询并以更好的方式理解数据库行为。</p><p id="aa58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">问:策划者是我唯一需要看的东西吗？</p><p id="33ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">答:肯定不是。还有很多其他的东西——应用程序的领域专业知识、表设计和数据库架构等。这是非常重要的。但是作为一名开发人员/DBA，理解和提高这些抽象技能对我们的职业生涯极其重要。</p><p id="3604" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这些基础知识，我们现在可以自信地阅读任何计划，并对正在发生的事情形成高层次的想法。查询优化是一个非常广泛的话题，需要了解数据库内部发生的各种事情。在以后的文章中，我们将看到不同种类的查询及其节点是如何计划和执行的，哪些因素影响计划者的行为，以及我们如何优化它们。</p><h1 id="e1d2" class="oe lr it bd ls of og oh lv oi oj ok ly jz ol ka mb kc om kd me kf on kg mh oo bi translated">资源</h1><ol class=""><li id="13ac" class="mo mp it kw b kx mj la mk ld op lh oq ll or lp os mu mv mw bi translated"><a class="ae nh" href="https://www.arctype.com" rel="noopener ugc nofollow" target="_blank"> Arctype SQL客户端</a></li><li id="e644" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp os mu mv mw bi translated"><a class="ae nh" href="https://explain.depesz.com/s/pIzU" rel="noopener ugc nofollow" target="_blank"> depesz解释查询网站</a></li><li id="cc3d" class="mo mp it kw b kx mx la my ld mz lh na ll nb lp os mu mv mw bi translated"><a class="ae nh" href="https://faker.readthedocs.io/en/master/index.html" rel="noopener ugc nofollow" target="_blank"> Faker Python库</a></li></ol></div></div>    
</body>
</html>