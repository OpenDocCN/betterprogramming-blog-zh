<html>
<head>
<title>The All-New State in Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack组件中的全新状态</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-all-new-state-in-jetpack-compose-78b524cc346?source=collection_archive---------7-----------------------#2021-05-24">https://betterprogramming.pub/the-all-new-state-in-jetpack-compose-78b524cc346?source=collection_archive---------7-----------------------#2021-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4452" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何在Compose中使用LiveData、observeAsState和MutableState</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4d9b9f15ce8dbf82f832b056a674b64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0gjzVIijAUe2qLXU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Gert Boers 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="20bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习什么是状态以及它如何在<a class="ae ky" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose </a>中工作。在这样做的同时，我们将学习一些有趣的东西，比如<code class="fe lv lw lx ly b">remember</code>、<code class="fe lv lw lx ly b">LiveData</code>和<code class="fe lv lw lx ly b">observeAsState</code>，以及特定于Compose的<code class="fe lv lw lx ly b">MutableState</code>概念。</p><p id="9e36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">注意:Jetpack Compose最近已转移到测试版。这意味着API结构将不再有任何剧烈的变化。因此，这将是学习如何使用下一代UI套件进行Android开发的大好时机。Jetpack Compose中的小部件是对状态作出反应的，所以请享受这篇文章。</em></p><p id="1605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">需要安装Android Studio Canary，北极狐(2020 . 3 . 1)</em><strong class="lb iu"><em class="lz"/></strong><em class="lz">才能使用Jetpack缀Beta。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="4258" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">先决条件</h1><p id="8f75" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在进一步学习之前，您必须具备如何使用Jetpack Compose的基本知识。如果你是作曲新手，我强烈推荐阅读以下文章:</p><ul class=""><li id="64e3" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/jetpack-compose-components-part-1-a80717dbfb59">“Jetpack合成组件(第一部分)”</a></li><li id="26eb" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/build-android-layouts-in-jetpack-compose-bda2e0837f5e">“在JetPack Compose中构建Android布局”</a></li><li id="7544" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/theming-in-jetpack-compose-for-android-667d42b8279c">“Android版Jetpack Compose中的主题化”</a></li><li id="53bf" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/navigation-with-jetpack-compose-in-android-ab84d0984ade">“在Android中使用Jetpack撰写导航”</a></li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="b7e7" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">介绍</h1><p id="6de6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">在传统的Android开发方法中，我们通常编写代码来查找视图层次结构中的视图，并使用适当的函数来更新它们，例如<code class="fe lv lw lx ly b">setText</code>、<code class="fe lv lw lx ly b">setImageResource</code>、<code class="fe lv lw lx ly b">View.GONE</code>等等。</p><p id="edd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种方法中，我们需要根据用户交互、<code class="fe lv lw lx ly b">ViewModel</code>中发生的事件或者与系统相关的事件来手动更新UI的小部件。这种手动处理会增加出错的几率。</p><p id="a179" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Jetpack Compose中，我们以声明的方式使用一组可组合的函数来构建UI。如果您不熟悉Jetpack Compose，请在继续之前阅读以下文章(并确保使用更新版本的Jetpack Compose库):</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/jetpack-compose-a-new-and-simple-way-to-create-material-ui-in-android-f49c6fcb448b"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">jetpack Compose——一种在Android中创建材质界面的简单新方法</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">了解如何创建没有任何XML文件的用户界面</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">better编程. pub</p></div></div><div class="oe l"><div class="of l og oh oi oe oj ks nv"/></div></div></a></div><p id="287e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与传统方法不同，Jetpack Compose小部件相对来说是无状态的，不公开setter或getter函数。推荐的方法是维护高级可组合函数中的所有对象，并通过将它们作为参数传递给相同的可组合函数来更新UI。</p><p id="716f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，您可以像<code class="fe lv lw lx ly b">ViewModel</code>一样维护架构组件中的状态，并将它们作为参数传递给可组合的函数。有了这种方法，我们不再需要做任何手工工作。当状态改变时，组件负责更新UI。</p><p id="a5ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Jetpack Compose中，理想情况下，数据或状态应该从高级功能流向低级功能，而事件的触发则相反。看看这些图片:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/2f1bdb9266b1ac701cfbbe156af86aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hw5xByiZPqcvMiM4tm23iw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://developer.android.com/jetpack/compose/mental-model" rel="noopener ugc nofollow" target="_blank">安卓开发者</a></p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/2f655b4e9c5e9047832cc7298a8f9d09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tsV7vXBTfqwVLPMud7agg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://developer.android.com/jetpack/compose/mental-model" rel="noopener ugc nofollow" target="_blank">安卓开发者</a></p></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="904b" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">带有文本字段的简单状态示例</h1><p id="fa1e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">让我们在Jetpack Compose中声明一个简单的<code class="fe lv lw lx ly b">TextField</code> <em class="lz"> </em>。如果你是作曲新手，想知道什么是<code class="fe lv lw lx ly b">TextField</code>，那么答案很简单。<code class="fe lv lw lx ly b">TextField</code> <em class="lz"> </em>是构成框架中的一个<code class="fe lv lw lx ly b">EditText</code> <em class="lz"> </em>。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您运行应用程序，您将看到一个用户可以输入的<code class="fe lv lw lx ly b">TextField</code>。但是，如果您尝试键入文本，它将不会反映在用户界面中。这是因为<code class="fe lv lw lx ly b">TextField</code> <em class="lz"> </em>不会自己更新。它仅在其值参数改变时更新。</p><p id="8b78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个问题是什么时候改变value参数。无论何时给用户输入都很简单。我们可以从<code class="fe lv lw lx ly b">onValueChange</code> <em class="lz"> </em>参数监控输入。总而言之，我们需要维护一个代表<code class="fe lv lw lx ly b">TextField</code> <em class="lz"> </em>状态的值，然后在<code class="fe lv lw lx ly b">onValueChange</code> <em class="lz"> </em> lambda中更新那个状态。看一下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为对代码的高级解释，我们可以说我们正在维护一个状态(<code class="fe lv lw lx ly b">name</code>)并用它来表示<code class="fe lv lw lx ly b">TextField</code>中的文本。在<code class="fe lv lw lx ly b">onValueChange</code>函数中，我们正在更新状态，这样当用户键入任何文本时，它都会在<code class="fe lv lw lx ly b">TextField</code>中更新。</p><p id="4198" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你已经理解了基本的类比，让我们更深入地挖掘一下。代码中有一些新概念，比如<code class="fe lv lw lx ly b">remember</code>和<code class="fe lv lw lx ly b">mutableStateOf</code>。</p><h2 id="1544" class="on mi it bd mj oo op dn mn oq or dp mr li os ot mt lm ou ov mv lq ow ox mx oy bi translated">纪念</h2><p id="d479" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><code class="fe lv lw lx ly b">remember</code>让您即使在重新排版时也能记住状态。基本上，它在可组合函数的重组过程中维护一个状态。要了解更多信息，请阅读以下文章:</p><div class="ns nt gp gr nu nv"><a rel="noopener  ugc nofollow" target="_blank" href="/jetpack-compose-components-part-2-2b3eb135d294"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">Jetpack合成组件(第2部分)</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">查看图标、图像、记忆、间隔、单选按钮、加载器、开关和复选框以及滑块</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">better编程. pub</p></div></div><div class="oe l"><div class="oz l og oh oi oe oj ks nv"/></div></div></a></div><h2 id="62e0" class="on mi it bd mj oo op dn mn oq or dp mr li os ot mt lm ou ov mv lq ow ox mx oy bi translated">什么是重组？</h2><p id="b6e2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">每当一个状态被更新时，基于该状态的可组合函数会在必要时用新的参数自动调用。这叫做重组。</p><p id="e98f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们以上面的代码为例。当用户与<code class="fe lv lw lx ly b">TextField</code> <em class="lz"> </em>交互并改变文本时，我们正在更新状态。这导致<code class="fe lv lw lx ly b">simpleTextfield</code> <em class="lz"> </em>可组合函数的重组。</p><p id="9534" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在文章的后面讨论<code class="fe lv lw lx ly b">mutableStateOf</code> <em class="lz"> </em>。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="7236" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">状态提升</h1><p id="06fe" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">因此，使用状态使UI具有反应性比我们在每个场景中更新小部件的传统方法更加灵活。但是管理单个可组合对象内部的状态使得测试或重用可组合函数变得更加困难。</p><p id="afee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方法是状态提升。状态提升背后的基本类比是将所有状态变量移动到顶级可组合函数，并根据需求将它们作为参数传递给每个可组合函数。</p><p id="2a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉Android开发中的依赖注入，我们在构造函数中传递所需的依赖，状态托管与此类似。我们将状态作为高级组件来维护，并将它们作为参数注入到所需的组件中。</p><p id="3522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就拿上面的例子来说吧。<code class="fe lv lw lx ly b">simpleTextfield</code>是<code class="fe lv lw lx ly b">SimpleScreen</code>中的一个可组合函数，而<code class="fe lv lw lx ly b">SimpleScreen</code>是主要的可组合函数，代表整个屏幕的所有内容。因此，为了便于重用和测试<code class="fe lv lw lx ly b">simpleTextfield</code>可组合组件，我们可以将名称状态从<code class="fe lv lw lx ly b">simpleTextfield</code>移到<code class="fe lv lw lx ly b">SimpleScreen</code>，并将其作为参数传递。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="db87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们将状态值作为参数传递时，我们还需要传递lambda表达式来更新状态，因为默认情况下参数是值，这意味着它们不能被更新。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5d2f" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">具有视图模型的组件</h1><p id="7094" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我们还可以做得更好。我在五年的Android生涯中学到的一点就是隔离关注点，也就是俗称的关注点分离。</p><p id="e981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">架构和<code class="fe lv lw lx ly b">ViewModels</code>主要用于Android开发，以分离关注点并在模块间保持适当的层次结构。为了使我们的状态和数据在配置更改后仍然存在，我们可以将状态移到<code class="fe lv lw lx ly b">ViewModels</code>中，并从顶层的Compose函数中观察它们。让我们在已经使用过的<code class="fe lv lw lx ly b">Simplescreen</code> <em class="lz"> </em>例子中实现这个模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="a605" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是将状态转移到了<code class="fe lv lw lx ly b">ViewModel</code>，并在<code class="fe lv lw lx ly b">ViewModel</code>中加入了lambda表达式来更新状态，这样所有需要这些数据的可组合函数都可以通过<code class="fe lv lw lx ly b">ViewModel</code>使用它们。在这种情况下，数据可以在配置更改后继续存在，并且您可以在一个地方维护它们。</p><p id="9e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们使用了两个新东西:<code class="fe lv lw lx ly b">LiveData </code>和<code class="fe lv lw lx ly b">observeAsState</code>T24】。</p><h2 id="5342" class="on mi it bd mj oo op dn mn oq or dp mr li os ot mt lm ou ov mv lq ow ox mx oy bi translated">LiveData</h2><p id="3da0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">简单来说，<code class="fe lv lw lx ly b">LiveData</code>是一个可观察的数据容器类，这意味着<code class="fe lv lw lx ly b">LiveData</code>可以保存一组可以从其他Android组件(如<code class="fe lv lw lx ly b">Activities</code>、<code class="fe lv lw lx ly b">Fragments</code>和<code class="fe lv lw lx ly b">Services</code>)中观察到的数据。要了解更多关于<code class="fe lv lw lx ly b">LiveData</code>的信息，请阅读以下文章:</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/android-dev-hacks/exploring-livedata-and-kotlin-flow-7c8d8e706324" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd iu gy z fp oa fr fs ob fu fw is bi translated">探索LiveData和Kotlin流</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">何时何地使用LiveData和Kotlin Flow</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="pa l og oh oi oe oj ks nv"/></div></div></a></div><h2 id="93f6" class="on mi it bd mj oo op dn mn oq or dp mr li os ot mt lm ou ov mv lq ow ox mx oy bi translated">观察状态</h2><p id="fa82" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">这会将<code class="fe lv lw lx ly b">LiveData</code>观察为Compose中的一个状态，因此每次在<code class="fe lv lw lx ly b">LiveData</code>中发布一个新值时，它都会更新状态。这将导致重新组合以更新UI。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a31d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">可变状态</h1><p id="77af" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">现在是时候了解一下<code class="fe lv lw lx ly b">mutableState</code> <em class="lz">了。</em>在上一节中，我们使用<code class="fe lv lw lx ly b">LiveData</code>从<code class="fe lv lw lx ly b">ViewModel</code>发出数据。Compose提供了一个名为<code class="fe lv lw lx ly b">mutableState</code>的新概念，通过它我们可以实现与LiveData相同的功能。</p><h2 id="b548" class="on mi it bd mj oo op dn mn oq or dp mr li os ot mt lm ou ov mv lq ow ox mx oy bi translated">什么是可变状态？</h2><p id="34bc" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated"><em class="lz">"在执行</em> <code class="fe lv lw lx ly b"><em class="lz">Composable</em></code> <em class="lz">函数期间，读取到</em> <code class="fe lv lw lx ly b"><em class="lz">value</em></code> <em class="lz">属性的可变值持有者，当前的</em> <code class="fe lv lw lx ly b"><em class="lz">RecomposeScope</em></code> <em class="lz">将订阅该值的变化。当</em> <code class="fe lv lw lx ly b"><em class="lz">value</em></code> <em class="lz">属性被写入并更改时，将会安排对任何已订阅的</em> <code class="fe lv lw lx ly b"><em class="lz">RecomposeScopes</em></code> <em class="lz">进行重组。如果使用相同的值对</em> <code class="fe lv lw lx ly b"><em class="lz">value</em></code> <em class="lz">进行写入，则不会安排任何重新编译。”——</em><a class="ae ky" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState?hl=he" rel="noopener ugc nofollow" target="_blank"><em class="lz">安卓开发者</em> </a></p><p id="70b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过定义本身，我们可以了解它是如何工作的，以及在哪里使用它。基本上<code class="fe lv lw lx ly b">mutableState</code>和Compose函数的关系类似于<code class="fe lv lw lx ly b">LiveData</code>和Android组件的关系。</p><p id="dd45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的目标是用<code class="fe lv lw lx ly b">mutableState</code>替换<code class="fe lv lw lx ly b">ViewModel</code>中<code class="fe lv lw lx ly b">LiveData</code>的用法。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="5bfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<code class="fe lv lw lx ly b">mutableState</code>，我们可以减少样板代码，使代码更加简洁。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="4a53" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">奖金</h1><p id="84b2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">要了解有关Jetpack Compose的更多信息，请查看以下文章:</p><ul class=""><li id="ffa0" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/theming-in-jetpack-compose-for-android-667d42b8279c">“面向Android的Jetpack合成中的主题化”</a></li><li id="d87d" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/navigation-with-jetpack-compose-in-android-ab84d0984ade">“Jetpack撰写中的导航”</a></li><li id="383c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated"><a class="ae ky" href="https://medium.com/android-dev-hacks/jetpack-compose-with-server-driven-ui-396a19f0a661" rel="noopener">“使用服务器驱动的用户界面构建JetPack”</a></li></ul><p id="9195" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前就这些。希望你学到了有用的东西。感谢阅读。</p></div></div>    
</body>
</html>