<html>
<head>
<title>How to Write Good Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写好的单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-good-unit-tests-db5c46f9fd07?source=collection_archive---------12-----------------------#2020-07-24">https://betterprogramming.pub/how-to-write-good-unit-tests-db5c46f9fd07?source=collection_archive---------12-----------------------#2020-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="36ce" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在编写下一个测试时，需要考虑几件事情</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2d00d138455fdb431a87874b2e585560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RpSdWeWZSxQAWE68"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="ad7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写好的单元测试是软件开发的重要部分。通过正确地编写测试，您可以极大地减少bug的数量。然而，并不是所有的单元测试都是好的。写得不好的单元测试可能是一个大问题，会拖慢你的速度。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="aff2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">什么是单位？</h1><p id="39f3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你首先需要决定你所看到的整体。是一种方法吗？是模块吗？或者也许是某种流动？</p><p id="0831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不是每个单位都一样。例如，如果一个方法包含业务逻辑，那么为它创建几个单元测试可能是一个好主意。但是当您的方法只是将一些数据从一个类传递到另一个类时，这可能是不必要的。在这种情况下，测试整个模块会是一个更好的主意。</p><p id="9382" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看几个例子来演示不同的方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="084f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">具有业务逻辑的测试方法</h1><p id="6526" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">假设我们有一个带有<code class="fe mw mx my mz b">publish</code>方法的<code class="fe mw mx my mz b">Story</code>类。我们只允许发表一个拥有<code class="fe mw mx my mz b">DRAFT</code>身份的故事。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，为该方法编写一个单元测试是有意义的，因为它包含了一个重要的业务规则。为了完全覆盖这个规则，我们需要创建两个单元测试:</p><ul class=""><li id="152a" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">测试当状态不是<code class="fe mw mx my mz b">DRAFT</code>时是否抛出<code class="fe mw mx my mz b">Error</code>。</li><li id="b409" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">当状态为<code class="fe mw mx my mz b">DRAFT</code>时，测试状态是否变为<code class="fe mw mx my mz b">PUBLISHED</code>。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="87a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过只测试方法，我们可以保持我们的单元测试很小。这在测试复杂的业务逻辑时特别有用。试着总是涵盖你的业务逻辑的每一个分支。</p><p id="bae2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用代码覆盖率报告器来查看测试了代码的哪一部分是一个好主意。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0799" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">模仿依赖性</h1><p id="142e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在某些情况下，为了确保您只测试业务逻辑，您将需要模拟依赖关系。让我们用下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cb16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此服务依赖于事件调度程序。我们需要模拟这种依赖性，因为我们不想在单元测试期间调度<code class="fe mw mx my mz b">MoneyTransferredEvent</code>。我们只想知道服务是否像预期的那样处理所有的业务逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2ba2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过模仿依赖性，我们用一个“假”的实现替换了实际的实现。我们可以使用这个假的实现来检查是否调用了正确的方法。模拟也可以返回数据。这在模仿像存储库这样的东西时会很有用。</p><p id="a19a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽量让你的单元测试小而有描述性。如果您在一个单元测试中有不相关的断言，您可以考虑将它们分成多个单元测试。让我给你看一个断言不相关的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ce79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过分离这些断言，您将直接知道当单元测试失败时，应用程序的哪个部分没有工作。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="603d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">测试模块</h1><p id="df6e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">有时，测试整个模块比为每个方法编写单元测试更有用。假设我们的应用程序中有一些cronjob的代码。这个cronjob将获取所有等待的故事并发布它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="70da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个模块来说，唯一重要的事情是它获取故事并发布每一个故事。为这样的模块编写测试有一些好处:</p><ul class=""><li id="1aa7" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">您只能测试什么是重要的:是否用正确的数据调用了正确的端点？</li><li id="9c67" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">您可以轻松地重构您的代码库。只要用预期的数据调用端点，测试就会通过。</li><li id="5ec2" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">测试一个模块通常比为每个方法编写一个测试更快。</li></ul><p id="b565" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看模块测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="31f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过模仿API客户端，我们可以返回两个故事。如果这两个故事也出版了，我们的测试就通过了。为不同的API结果添加更多的测试可能是个好主意。</p><p id="3066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试模块的另一个好选择是编写集成测试。然而，单元测试的好处是您可以轻松地在本地或管道中运行它。这些模块测试对于<a class="ae kv" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a> (TDD)也非常有用。</p><p id="7ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果模块包含许多业务逻辑，您可能想要为那些特定的业务规则添加一些测试。通过在方法测试中包含业务逻辑，您可以保持模块测试的简单。模块测试对于确认所有的类是否如预期的那样一起工作仍然是有用的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fec3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="7cb9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我是模块测试的忠实粉丝，因为它们覆盖了大量的代码。它们对于测试依赖注入也很有用。然而，仅仅编写模块测试通常是不够的。将模块测试和方法测试结合起来会让你两全其美。</p><p id="fce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个需要注意的重要事情是，进行大量的方法测试会降低你的速度。例如，当将字符串更改为枚举时，大多数测试都会失败。然而，模块测试仍然会通过。所以考虑只为包含业务逻辑的方法编写这些测试。</p><p id="6480" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您以前从未编写过单元测试，我建议您从测试某些方法开始。模块测试可能有点让人不知所措——尤其是当它们有很多依赖项的时候。</p><p id="c71a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，最重要的部分是你的测试覆盖了最重要的逻辑，并帮助你提高代码的质量。</p><p id="6930" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了编写好的单元测试，你需要适当地分离你的代码。遵循<a class="ae kv" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的</a>原则会有很大帮助。通过使用类似于<a class="ae kv" href="https://en.wikipedia.org/wiki/Multitier_architecture" rel="noopener ugc nofollow" target="_blank">多层架构</a>的东西将你的项目分成不同的层，也可以使测试你的应用程序变得更容易。如果你有兴趣进一步了解这个话题，我给<a class="ae kv" href="https://levelup.gitconnected.com/building-maintainable-software-50c6bd09c611" rel="noopener ugc nofollow" target="_blank">写了一篇关于使用多层架构建立一个新项目的文章</a>。</p><p id="7261" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>