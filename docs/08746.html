<html>
<head>
<title>JavaScript ES2021: A Look at the New Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript ES2021:看看新特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-es2021-a-look-at-the-new-features-7d5770288648?source=collection_archive---------0-----------------------#2021-06-08">https://betterprogramming.pub/javascript-es2021-a-look-at-the-new-features-7d5770288648?source=collection_archive---------0-----------------------#2021-06-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8388" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">新ES12规格概述</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0af17df8f8520378a84e0e612052b2cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MN9xzVr2z8v8D8VaYmC9ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由作者提供。</p></figure><p id="cc6e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">新的ES12规格终于来了。规格？JavaScript确实不是开源语言。这是一种遵循ECMAScript标准规范编写的语言。TC39委员会负责讨论和批准新特性。他们是谁？</p><blockquote class="lu lv lw"><p id="d68f" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated">“ECMA International的TC39是一个由JavaScript开发人员、实现人员、学者等组成的团体，他们与社区合作维护和发展JavaScript的定义。”— <a class="ae mb" href="https://tc39.es/" rel="noopener ugc nofollow" target="_blank"> TC39.es </a></p></blockquote><p id="9f37" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们的释放过程由五个阶段组成。自2015年以来，他们一直在进行年度发布。它们通常发生在春天。下一个申请批准的日期是6月25日.</p><p id="c83d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两种方法可以引用任何ECMAScript版本:</p><ul class=""><li id="3b29" class="mc md it la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">按年份:这个新版本将是ES2021。</li><li id="b07e" class="mc md it la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">根据它的迭代编号:这个新版本将是第12次迭代，所以它可以被称为ES12。</li></ul><p id="0896" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么这个版本中有什么新内容呢？哪些功能可以让我们感到兴奋？</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="8c41" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">全部替换</h1><p id="2f31" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">一个新的功能被添加到<code class="fe nu nv nw nx b">String</code>原型中。在此之前，如果不使用正则表达式，就不可能替换子字符串的所有实例。</p><p id="944f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ES12之前:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="093b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a15a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果搜索参数是空字符串会发生什么？它将返回每个UCS-2/UTF-16代码单元之间的替换值。</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="570d" class="oe my it nx b gy of og l oh oi">'x'.replace('', '_');<br/>// '_x'</span><span id="2df9" class="oe my it nx b gy oj og l oh oi">'xxx'.replace(/(?:)/g, '_');<br/>// '_x_x_x_'</span><span id="922f" class="oe my it nx b gy oj og l oh oi">'xxx'.replaceAll('', '_');<br/>// '_x_x_x_'</span></pre><p id="5625" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">网上有很多关于这个话题的问题。因此，我们可以推断这将是一个有用的功能。不需要任何正则表达式知识使它更容易访问。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="8f03" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">承诺。任何</h1><p id="3cdf" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">新的<code class="fe nu nv nw nx b">Promise.any</code>方法是另一个有用的工具。它以一系列承诺作为论据。当满足其中任何一个条件时，它将触发<code class="fe nu nv nw nx b">Promise.any()</code>参数回调或返回响应。这要看你是不是在用<code class="fe nu nv nw nx b">async/await</code>了。</p><p id="4383" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果所有的承诺都失败了，这个方法将抛出一个<code class="fe nu nv nw nx b">AggregateError</code>,它组合了所有不同的承诺错误。为什么不返回一个普通数组呢？主要是为了兼容性。它将是<code class="fe nu nv nw nx b">Error</code>的一个实例，您将得到一个堆栈跟踪。有这些信息以备不时之需是件好事。</p><p id="4ab3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些例子。</p><ul class=""><li id="c700" class="mc md it la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">使用传统的<code class="fe nu nv nw nx b">callback</code>语法:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><ul class=""><li id="1ac1" class="mc md it la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">使用<code class="fe nu nv nw nx b">async/await</code>语法:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2c46" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们检查一个错误示例场景:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1348" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是<code class="fe nu nv nw nx b">Promise</code>原型的第四个附加物。简单回顾一下，目前我们有以下资源可供使用:</p><ul class=""><li id="7661" class="mc md it la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated"><code class="fe nu nv nw nx b">[ES2020] Promise.allSettled</code>:这个方法返回一个承诺，当所有给定的承诺都被实现或拒绝时，这个承诺就解决了。返回的对象描述了每个单独的承诺结果。</li><li id="48ad" class="mc md it la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">这个方法返回一个只有当所有的目标承诺都实现时才实现的承诺。</li><li id="df36" class="mc md it la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated"><code class="fe nu nv nw nx b">[ES2015] Promise.race</code>:该方法将返回一个承诺，一旦其中一个承诺被拒绝或履行，该承诺将立即履行。</li></ul></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="861b" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">WeakRefs</h1><p id="3b2d" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">JavaScript有一个自动垃圾收集过程。它只能收集不可及的对象。每次你给一个对象赋值的时候，你都在创建一个<code class="fe nu nv nw nx b">strong reference</code>。这可以保护它不被垃圾收集。</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="eaf5" class="oe my it nx b gy of og l oh oi">// x is a strong reference to the object<br/>const x = { foo: 'bar' };</span></pre><p id="53be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">WeakRef</code>服务于一个完全不同的用例:保存一个对象的引用，该对象不会保护它免于垃圾收集。因为垃圾收集是不确定的，所以没有真正的保证对象什么时候会被清除，甚至是否会被清除。<code class="fe nu nv nw nx b">WeakRef</code>利用了这一点，允许您访问该对象，直到它被收集。</p><p id="ad5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nu nv nw nx b">WeakRef</code>只能带一个宾语作为论元。</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="7116" class="oe my it nx b gy of og l oh oi">function Foo() {}</span><span id="c878" class="oe my it nx b gy oj og l oh oi">// strong reference to a Foo instance<br/>const x = new Foo();</span><span id="f127" class="oe my it nx b gy oj og l oh oi">// weak reference to the Foo's instance<br/>const xWeak = new WeakRef(x);</span></pre><p id="128d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们如何取回值？通过使用<code class="fe nu nv nw nx b">deref()</code>方法。请记住，该方法将返回对该对象的强引用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="16c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这为什么有用？它允许您根据用户的设备提高应用程序的性能。我们可以使用<code class="fe nu nv nw nx b">WeakRefs</code>来缓存大对象。这意味着拥有更多内存的机器可以看到应用程序性能的提高。那些内存有限的仍然会工作，不会吃掉用户的内存。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="2ad7" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">终结器</h1><p id="5c0a" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">终结器是ES12在内存区域的另一个特性。这个特性的作用是让你知道一个对象什么时候被垃圾收集了。它通过JavaScript回调来实现。</p><p id="eba5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，有几件事要记住:</p><ul class=""><li id="f78b" class="mc md it la b lb lc le lf lh me ll mf lp mg lt mh mi mj mk bi translated">不保证回调会执行。</li><li id="1d28" class="mc md it la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">目标对象已被清除，将无法访问。</li><li id="d6a7" class="mc md it la b lb ml le mm lh mn ll mo lp mp lt mh mi mj mk bi translated">回调将执行多长时间是不确定的。可以是一分钟，也可以是一个小时。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ba13" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个特性让您有机会做进一步的清理，以帮助优化您的应用程序。</p><p id="fde4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lx">注意:这不是你想要运行关键代码的地方。这是一个旨在帮助进一步减少我们的记忆网络应用程序的足迹的地方。</em></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="ecdc" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">逻辑赋值运算符</h1><p id="427d" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">最后，这些新的ES12规格配备了期待已久的运营商。新运算符将逻辑赋值运算符与逻辑运算<code class="fe nu nv nw nx b">&amp;&amp;</code>、<code class="fe nu nv nw nx b">||</code>和<code class="fe nu nv nw nx b">??</code>结合在一起。</p><h2 id="e408" class="oe my it bd mz ok ol dn nd om on dp nh lh oo op nj ll oq or nl lp os ot nn ou bi translated">运算符&amp;&amp;=</h2><p id="2792" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">让我们将它在ES11中的对等物与新规范进行比较。</p><p id="53fa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="8d32" class="oe my it nx b gy of og l oh oi">x &amp;&amp; (x = y)</span></pre><p id="1cae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="c1cf" class="oe my it nx b gy of og l oh oi">x &amp;&amp;= y;</span></pre><p id="f17a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="1cb3" class="oe my it bd mz ok ol dn nd om on dp nh lh oo op nj ll oq or nl lp os ot nn ou bi translated">运算符||=</h2><p id="e109" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">让我们将它在ES11中的对等物与新规范进行比较。</p><p id="2306" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="41ea" class="oe my it nx b gy of og l oh oi">x || (x = y)</span></pre><p id="b1e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="0a3e" class="oe my it nx b gy of og l oh oi">x ||= y;</span></pre><p id="7884" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="f74f" class="oe my it bd mz ok ol dn nd om on dp nh lh oo op nj ll oq or nl lp os ot nn ou bi translated">接线员？？=</h2><p id="cd62" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated"><code class="fe nu nv nw nx b">??</code>是JavaScript的nullish合并操作符。让我们回顾一下它是做什么的，因为它不太常见。</p><blockquote class="lu lv lw"><p id="b682" class="ky kz lx la b lb lc ju ld le lf jx lg ly li lj lk lz lm ln lo ma lq lr ls lt im bi translated"><strong class="la iu">无效合并运算符(</strong> <code class="fe nu nv nw nx b"><strong class="la iu">??</strong></code> <strong class="la iu"> ) </strong>是一个逻辑运算符，当其左侧操作数为<code class="fe nu nv nw nx b">null</code>或<code class="fe nu nv nw nx b">undefined</code>时，返回其右侧操作数，否则返回其左侧操作数— <a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="noopener ugc nofollow" target="_blank"> MDN网络文档</a></p></blockquote><p id="f75e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之前:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="8ddb" class="oe my it nx b gy of og l oh oi">x ?? (x = y);</span></pre><p id="9d5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="cc30" class="oe my it nx b gy of og l oh oi">x ??= y;</span></pre><p id="35c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="a8d5" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">数字分隔符</h1><p id="2332" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">这种添加可能不那么花哨，但它确实有助于提高代码的可读性。目前，当在<code class="fe nu nv nw nx b">var/let/const</code>变量中存储一个长数字时，它可能是不可读的。</p><p id="c7ee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子。让我们创建一个100万的常数。显而易见，长数字很难阅读。</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="aad0" class="oe my it nx b gy of og l oh oi">const oneMillion = 1000000;</span></pre><p id="256c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用新的ES12语法，您可以使用<code class="fe nu nv nw nx b">_</code>字符在数字之间创建分隔符。</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="dd68" class="oe my it nx b gy of og l oh oi">const oneMillion = 1_000_000;</span></pre><p id="e4fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它可以用于<code class="fe nu nv nw nx b">binary</code>和<code class="fe nu nv nw nx b">Hex</code>文字:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="cb2b" class="oe my it nx b gy of og l oh oi">const max8bits = 0b1111_1111;</span><span id="4a07" class="oe my it nx b gy oj og l oh oi">const message = 0xA0_B0_C0;</span></pre><p id="e29c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这肯定是我会经常使用的东西。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="b105" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">最后的想法</h1><p id="900a" class="pw-post-body-paragraph ky kz it la b lb np ju ld le nq jx lg lh nr lj lk ll ns ln lo lp nt lr ls lt im bi translated">这是一个有趣的版本，提供了许多小而有用的特性，如<code class="fe nu nv nw nx b">logical assigment operators</code>、<code class="fe nu nv nw nx b">replaceAll</code>和<code class="fe nu nv nw nx b">numerical separators</code>。你已经可以开始使用它们，并通过巴别塔传输它们。如果您使用TypeScript，那么这项工作已经为您完成了。</p><p id="192f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还增加了一些高级功能，如<code class="fe nu nv nw nx b">WeakRefs</code>和<code class="fe nu nv nw nx b">Finalizers</code>。尽管它们很复杂，但在使用之前需要很好地理解它们。否则，他们会带来比他们解决的更多的问题。它们涵盖了一些特定的场景，不应该被滥用。</p><p id="cee1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我希望这篇文章能让你像我一样对新的ES2021规格感到兴奋。</p><p id="3750" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不是中等会员？支持我<a class="ae mb" href="http://dioxmio.medium.com/membership" rel="noopener">成为其中一员。</a></p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="1b49" class="mx my it bd mz na nb nc nd ne nf ng nh jz ni ka nj kc nk kd nl kf nm kg nn no bi translated">相关文章</h1><div class="ov ow gp gr ox oy"><a rel="noopener  ugc nofollow" target="_blank" href="/5-common-javascript-memory-mistakes-c8553972e4c2"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">5个常见的JavaScript内存错误</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">避免应用程序内存泄漏的技巧</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">better编程. pub</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ks oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a rel="noopener  ugc nofollow" target="_blank" href="/7-tips-to-write-efficient-and-performant-javascript-code-bccbdb9662ae"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd iu gy z fp pd fr fs pe fu fw is bi translated">编写高效高性能JavaScript代码的7个技巧</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">提升您的JavaScript应用程序的性能</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">better编程. pub</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ks oy"/></div></div></a></div></div></div>    
</body>
</html>