<html>
<head>
<title>Build a GOAT-Inspired Animated Dismissing TabBar: Swift 5 With UIKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个受山羊启发的动画解散TabBar: Swift 5和UIKit</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-goat-inspired-animated-dismissing-tabbar-swift-5-with-uikit-bd6506f3af01?source=collection_archive---------2-----------------------#2020-07-19">https://betterprogramming.pub/build-a-goat-inspired-animated-dismissing-tabbar-swift-5-with-uikit-bd6506f3af01?source=collection_archive---------2-----------------------#2020-07-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e006" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给你的tabBar添加一些UI风格</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c58d6cba93f53dae53d9c20b8256484e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BCGgqFPQ75zXo-brESXvHw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="efe0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GOAT是一个广泛使用的街头服饰市场应用程序。我一直在使用这个应用，它对我的UI/UX设计产生了巨大的影响。它是最小的，干净的，反应灵敏的，易于使用的。它最突出的一点是滚动条上的取消标签栏。当您向下滚动时，tabBar会向下消失。向上滚动，tabBar再次出现。这里有一个我所说的演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="495b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它集成到应用程序中的方式非常干净，这增强了我对应用程序的体验。</p><p id="b9e9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用一个<code class="fe lw lx ly lz b">UICollectionView</code>，这是我基于滚动方向消除和显示tabBar的实现。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ee57" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">开始项目</h1><p id="9fdb" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">这是我最初的开始项目。它只是一个简单的带有tabBar的<code class="fe lw lx ly lz b">collectionView</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="64de" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">确定滚动方向</h1><p id="98f7" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">我们需要做的第一件事是确定滚动的方向。这将允许我们根据滚动方向决定是关闭还是显示tabBar。</p><p id="3b2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将首先声明一个变量，该变量将在<code class="fe lw lx ly lz b">collectionView</code>所在的类中跟踪先前的滚动方向。在我的项目中，它是<code class="fe lw lx ly lz b">HomeViewController</code>。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="fde4" class="ni mi it lz b gy nj nk l nl nm"><strong class="lz iu">private</strong> <strong class="lz iu">var</strong> prevScrollDirection: CGFloat = 0</span></pre><p id="d538" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，既然我们使用的是<code class="fe lw lx ly lz b">UICollectionView</code>，我们可以调用<code class="fe lw lx ly lz b">scrollViewDidScroll</code> <strong class="la iu"> <em class="nn"> </em> </strong>函数。该函数通过名为(<code class="fe lw lx ly lz b">scrollView</code> ) <strong class="la iu"> <em class="nn"> </em> </strong>的函数传递一个变量，该变量将给出y轴偏移量和<code class="fe lw lx ly lz b">scrollView</code>高度。我们将从y内容偏移量和滚动高度比较先前的滚动方向，以检查用户是否向上滚动。当他们向下滚动时，我们将比较前一次滚动和y内容偏移量，并检查y内容偏移量是否大于零。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lv l"/></div></figure><p id="1d68" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lw lx ly lz b">scrollView</code>功能，我们现在可以确定滚动方向。我们在控制台上打印滚动方向，以验证我们确实捕捉到了正确的方向。</p><p id="cf25" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">确定滚动方向后，我们将把y内容偏移量存储到我们创建的<code class="fe lw lx ly lz b">prevScrollDirection</code>变量中。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a8b6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">通知中心</h1><p id="3489" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">以下是苹果公司对通知中心的描述:</p><blockquote class="nq"><p id="4d66" class="nr ns it bd nt nu nv nw nx ny nz lt dk translated">"一种通知调度机制，能够向注册的观察者广播信息."</p></blockquote><p id="2f8a" class="pw-post-body-paragraph ky kz it la b lb oa ju ld le ob jx lg lh oc lj lk ll od ln lo lp oe lr ls lt im bi translated">我决定使用notification center<strong class="la iu"><em class="nn"/></strong>而不是委托协议方法，因为后者需要非常严格的语法。使用NotificationCenter允许更少的代码行，并且非常容易实现。我们只需要确保取消分配我们将创建的NotificationCenter观察器。</p><p id="e75b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将首先为通知名声明一个全局变量。对于这个例子，我们可以在<code class="fe lw lx ly lz b">HomeViewController</code> <strong class="la iu"> <em class="nn"> </em> </strong>类之外做。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="df23" class="ni mi it lz b gy nj nk l nl nm"><strong class="lz iu">public</strong> <strong class="lz iu">let</strong> tabBarNotificationKey = Notification.Name(rawValue: "tabBarNotificationKey")</span></pre><p id="9fc4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，让我们发布通知并根据滚动方向传递布尔值。经过对<code class="fe lw lx ly lz b">scrollViewDidScroll</code> <strong class="la iu"> <em class="nn"> </em> </strong>函数的返工，我们得到这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lv l"/></div></figure><p id="d006" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们创建一个名为<code class="fe lw lx ly lz b">isHidden</code>的变量。如果用户向上滚动，则为<code class="fe lw lx ly lz b">false</code>。如果他们向下滚动，将会是<code class="fe lw lx ly lz b">true</code>。我们发布一个通知，并使用字典通过<code class="fe lw lx ly lz b">userInfo</code> <strong class="la iu"> <em class="nn">传递布尔值。</em> </strong></p><p id="385d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">接下来，我们将进入<code class="fe lw lx ly lz b">tabBar</code>类，在那里我们将添加一个观察者。</p><p id="869b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以在<code class="fe lw lx ly lz b">viewDidLoad</code>中添加这个观察者:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="a90f" class="ni mi it lz b gy nj nk l nl nm">NotificationCenter.default.addObserver(<strong class="lz iu">self</strong>, selector: <strong class="lz iu">#selector</strong>(<strong class="lz iu">self</strong>.notificationReceived(<strong class="lz iu">_</strong>:)), name: tabBarNotificationKey, object: <strong class="lz iu">nil</strong>)</span></pre><p id="7585" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建它将需要我们创建一个函数，在这个函数中我们可以访问从发布的通知中传递的布尔值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lv l"/></div></figure><p id="dcca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行项目。如果你滚动，你会得到隐藏的tabBar，但它非常突兀:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="f309" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们继续之前，我们需要解除分配我们在同一个类中创建的NotificationCenter观察者<strong class="la iu"> <em class="nn"> </em> </strong>:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="6623" class="ni mi it lz b gy nj nk l nl nm"><strong class="lz iu">deinit</strong> {</span><span id="38c5" class="ni mi it lz b gy of nk l nl nm">NotificationCenter.default.removeObserver(<strong class="lz iu">self</strong>)</span><span id="b369" class="ni mi it lz b gy of nk l nl nm">}</span></pre></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1e66" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">动画Tabbar解散</h1><p id="b9c7" class="pw-post-body-paragraph ky kz it la b lb mz ju ld le na jx lg lh nb lj lk ll nc ln lo lp nd lr ls lt im bi translated">我们的最后一步是动画tabBar。</p><p id="9899" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在做了一些研究后，我发现了一篇由我是Simme写的关于如何动画演示tabBar消失的文章。我们可以添加这个扩展来扩展<code class="fe lw lx ly lz b">UITabBarController</code>类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lv l"/></div></figure><p id="af29" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一旦我们添加了这个扩展，我们就可以调用<code class="fe lw lx ly lz b">notificationReceived</code> <strong class="la iu"> <em class="nn"> </em> </strong>函数，并通过<code class="fe lw lx ly lz b">isHidden</code>将其传递给我们添加的<code class="fe lw lx ly lz b">setTabBar</code> <strong class="la iu"> <em class="nn"> </em> </strong>函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no lv l"/></div></figure><p id="dca2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行这个项目，我们应该得到这个结果:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="c2af" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请随意下载<a class="ae np" href="https://github.com/ModernProgrammer/DismissTabBarDemo" rel="noopener ugc nofollow" target="_blank"> GitHub项目</a>来亲自测试一下。干杯。</p></div></div>    
</body>
</html>