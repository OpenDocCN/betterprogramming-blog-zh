<html>
<head>
<title>A Beginner’s Guide to the File System Module in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中文件系统模块的初学者指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-beginners-guide-to-the-file-system-module-in-node-js-4743c0f3dab?source=collection_archive---------10-----------------------#2021-06-14">https://betterprogramming.pub/a-beginners-guide-to-the-file-system-module-in-node-js-4743c0f3dab?source=collection_archive---------10-----------------------#2021-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e234" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用Node.js中的“fs”模块</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c8ff471d43f1ef7ec86eae92bd9c401d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*avpsb4y-BTsLBL7U"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sigmund </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="cb39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文件系统模块，或简称为<code class="fe ls lt lu lv b">fs</code>，允许您访问机器上的文件系统并与之交互。</p><p id="0c70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">fs</code>模块，您可以执行如下操作:</p><ul class=""><li id="e772" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">创建文件和目录。</li><li id="6319" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">修改文件和目录。</li><li id="7247" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">删除文件和目录。</li><li id="5170" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">读取文件和目录的内容。</li></ul><p id="8d0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将教你最常用、最有用的<code class="fe ls lt lu lv b">fs</code>方法。事不宜迟，我们来看看那些方法是什么。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="4394" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">如何使用fs</h1><p id="dd64" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">文件系统模块是一个核心<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>模块。这意味着您不必安装它。您唯一要做的事情就是将<code class="fe ls lt lu lv b">fs</code>模块导入到您的文件中。</p><p id="62c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在文件的顶部添加以下行:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="9ff1" class="ns ms iq lv b gy nt nu l nv nw">const fs = require('fs');</span></pre><p id="182a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您可以通过使用前缀<code class="fe ls lt lu lv b">fs</code>从文件系统模块中调用任何方法。</p><p id="8c72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，您可以从<code class="fe ls lt lu lv b">fs</code> API中只导入您想要的方法，如下所示:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="4a2d" class="ns ms iq lv b gy nt nu l nv nw">const { writeFile, readFile } = require('fs');</span></pre><p id="ce5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，在本教程中，您将看到使用的第一个选项——导入整个<code class="fe ls lt lu lv b">fs</code>模块。</p><h2 id="c55d" class="ns ms iq bd mt nx ny dn mx nz oa dp nb lf ob oc nd lj od oe nf ln of og nh oh bi translated">警告</h2><p id="ae93" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">对于本教程，您还需要导入<code class="fe ls lt lu lv b">path</code>模块。它是另一个核心Node.js模块，允许您处理文件和目录路径。</p><p id="60c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在导入<code class="fe ls lt lu lv b">fs</code>模块后，在您的文件中添加以下行:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="ea11" class="ns ms iq lv b gy nt nu l nv nw">const path = require('path');</span></pre><p id="c9df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">path</code>模块是<em class="oi">而不是强制</em>与文件系统模块一起工作。但是，有帮助！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="af34" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">同步与异步</h1><p id="382e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">值得注意的是，默认情况下，所有的<code class="fe ls lt lu lv b">fs</code>方法都是异步的。但是，您可以通过在方法末尾添加<code class="fe ls lt lu lv b">Sync</code>来使用同步版本。</p><p id="775d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，像<code class="fe ls lt lu lv b">writeFile</code>这样的方法变成了<code class="fe ls lt lu lv b">writeFileSync</code>。同步方法同步完成代码，因此它们阻塞了主线程。阻塞Node.js中的主线程被认为是不好的做法。</p><p id="d916" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，本教程使用文件系统模块中的异步方法。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="57f4" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">写入文件</h1><p id="9314" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">你将学习的第一件事是如何写一个文件。要从Node.js应用程序写入文件，可以使用<code class="fe ls lt lu lv b">writeFile</code>方法。</p><p id="e677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">writeFile</code>方法至少接受以下参数:</p><ul class=""><li id="4f7f" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">文件的名称</li><li id="7ec7" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">内容</li><li id="0490" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">回调</li></ul><p id="fa0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果指定的文件已经存在，它将使用您作为参数提供的内容替换旧内容。如果指定的文件不存在，它将创建一个新文件。</p><p id="bb55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导入<code class="fe ls lt lu lv b">fs</code>和<code class="fe ls lt lu lv b">path</code>模块后，在应用程序中编写以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="db4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码创建了一个名为<code class="fe ls lt lu lv b">content.txt</code>的新文件，并添加了文本<code class="fe ls lt lu lv b">This is my first file!</code>作为内容。如果有错误，回调函数会抛出一个错误。否则，它向控制台输出文件创建成功。</p><p id="fba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您将文件命名为<code class="fe ls lt lu lv b">fsPractice.js</code>，进入终端并运行命令<code class="fe ls lt lu lv b">node fsPractice.js</code>。运行该命令后，您应该会看到包含指定内容的新文件。</p><p id="a5fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">writeFile</code>还有其他变体，例如:</p><ul class=""><li id="82f7" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">fs.writeFileSync</code> —同步写入文件。</li><li id="5135" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">fsPromises.writeFile</code> —使用基于承诺的API写入文件。</li></ul><p id="c56d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个要点，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="806e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">从文件中读取</h1><p id="319f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在读取文件之前，您需要创建并存储文件的路径。这就是<code class="fe ls lt lu lv b">path</code>模块派上用场的地方。</p><p id="0a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用来自<code class="fe ls lt lu lv b">path</code>模块的<code class="fe ls lt lu lv b">join</code>方法，您可以创建如下文件路径:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="1f7c" class="ns ms iq lv b gy nt nu l nv nw">const filePath = path.join(process.cwd(), 'content.txt');</span></pre><p id="fb39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个参数<code class="fe ls lt lu lv b">process.cwd()</code>返回当前工作目录。现在您已经有了文件路径，您可以读取文件的内容了。</p><p id="9639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件中编写以下代码:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="d18a" class="ns ms iq lv b gy nt nu l nv nw">fs.readFile(filePath, (error, content) =&gt; {<br/>  if (error) throw error;<br/><br/>  process.stdout.write(content);<br/>});</span></pre><p id="0bc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">readFile</code>方法至少有两个参数:</p><ul class=""><li id="4ef9" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">文件的路径</li><li id="2bc7" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">回调</li></ul><p id="2c97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有错误，它抛出一个错误。否则，它在终端中输出文件内容。</p><p id="83f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您进入终端并运行命令<code class="fe ls lt lu lv b">node fsPractice.js</code>，您应该在终端中看到文件内容。</p><p id="e996" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">readFile</code>还有其他变体，例如:</p><ul class=""><li id="b04a" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated"><code class="fe ls lt lu lv b">fs.readFileSync</code> —同步写入文件。</li><li id="04c0" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">fsPromises.readFile</code> —使用基于承诺的API写入文件。</li></ul><p id="aa65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看<a class="ae kv" href="https://gist.github.com/catalinpit/badc2a539a44412892a0e05a9575d54d" rel="noopener ugc nofollow" target="_blank">这个要点</a>，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="304a" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">读取目录的内容</h1><p id="a96f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">显示目录中的文件与读取文件内容非常相似。但是您传递的不是文件路径，而是当前工作目录(您可以传递任何其他目录)。</p><p id="e33f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，您传递一个回调函数来处理响应。在文件中编写以下代码:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="a953" class="ns ms iq lv b gy nt nu l nv nw">fs.readdir(process.cwd(), (error, files) =&gt; {<br/>  if (error) throw error;<br/><br/>  console.log(files);<br/>});</span></pre><p id="1fac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，您只使用了<code class="fe ls lt lu lv b">process.stdout.write</code>向终端输出内容。然而，您可以像上面的代码片段一样简单地使用<code class="fe ls lt lu lv b">console.log</code>。</p><p id="2297" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行这个应用程序，您应该得到一个包含您的目录中所有文件的数组。</p><p id="d68b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个要点，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="675d" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">删除文件</h1><p id="4027" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">文件系统模块有一个允许您删除文件的方法。然而，重要的是要注意它只对文件有效，对目录无效。</p><p id="c27e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你用文件路径作为参数调用<code class="fe ls lt lu lv b">unlink</code>方法时，它会删除文件。将以下代码片段添加到您的文件中:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="cf63" class="ns ms iq lv b gy nt nu l nv nw">fs.unlink(filePath, (error) =&gt; {<br/>  if (error) throw error;<br/><br/>  console.log('File deleted!')<br/>});</span></pre><p id="6f5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您重新运行代码，您的文件将被删除！</p><p id="7076" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个要点，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9af5" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">创建目录</h1><p id="7afb" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">mkdir</code>方法异步创建一个目录。在您的文件中编写以下代码:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="79f0" class="ns ms iq lv b gy nt nu l nv nw">fs.mkdir(`${process.cwd()}/myFolder/secondFolder`, { recursive: true }, (err) =&gt; {<br/>  if (err) throw err;<br/><br/>  console.log('Folder created successfully!');<br/>});</span></pre><p id="d200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一步一步来。首先，您想要在当前工作目录中创建一个新文件夹。如前所述，您可以使用<code class="fe ls lt lu lv b">process</code>对象中的<code class="fe ls lt lu lv b">cwd()</code>方法获取当前工作目录。</p><p id="703a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，传递想要创建的一个或多个文件夹。但是，这并不意味着您必须在当前工作目录中创建新文件夹。你可以在任何地方创建它们。</p><p id="dbda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，第二个参数是递归选项。如果不将其设置为<code class="fe ls lt lu lv b">true</code>，则无法创建多个文件夹。如果将<code class="fe ls lt lu lv b">recursive</code>选项设置为<code class="fe ls lt lu lv b">false</code>，上面的代码会给出一个错误。试试看！</p><p id="96fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您只想创建一个文件夹，则不需要将<code class="fe ls lt lu lv b">recursive</code>选项设置为<code class="fe ls lt lu lv b">true</code>。</p><p id="f123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码会工作得很好！</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="dcd5" class="ns ms iq lv b gy nt nu l nv nw">fs.mkdir(`${process.cwd()}/myFolder`, (err) =&gt; {<br/>  if (err) throw err;<br/><br/>  console.log('Folder created successfully!');<br/>});</span></pre><p id="3188" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我想强调一下<code class="fe ls lt lu lv b">recursive</code>的用法。当您想要在文件夹内创建文件夹时，需要将其设置为<code class="fe ls lt lu lv b">true</code>。它将创建所有文件夹，即使它们不存在。</p><p id="8088" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果您只想创建一个文件夹，您可以将其保留为<code class="fe ls lt lu lv b">false</code>。</p><p id="122c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个要点，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="aefc" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">删除目录</h1><p id="a963" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">删除目录的逻辑类似于创建目录的逻辑。如果您查看您编写的创建目录的代码和下面的代码，您会发现相似之处。</p><p id="a1d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，在您的文件中编写以下代码:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="b792" class="ns ms iq lv b gy nt nu l nv nw">fs.rmdir(`${process.cwd()}/myFolder/`, { recursive: true }, (err) =&gt; {<br/>  if (err) throw err;<br/><br/>  console.log('Folder/s deleted successfully!');<br/>});</span></pre><p id="2970" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您使用文件系统模块中的<code class="fe ls lt lu lv b">rmdir</code>方法，并传递以下参数:</p><ul class=""><li id="3a42" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">要删除的目录</li><li id="20cb" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated"><code class="fe ls lt lu lv b">recursive</code>房产</li><li id="4110" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">回调</li></ul><p id="983f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您将<code class="fe ls lt lu lv b">recursive</code>属性设置为<code class="fe ls lt lu lv b">true</code>，它将删除文件夹及其内容。需要注意的是，如果文件夹里面有内容，需要设置为<code class="fe ls lt lu lv b">true</code>。否则，您会得到一个错误。</p><p id="93e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下代码片段仅在文件夹为空时有效:</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="6f00" class="ns ms iq lv b gy nt nu l nv nw">fs.rmdir(`${process.cwd()}/myFolder/`, (err) =&gt; {<br/>  if (err) throw err;<br/><br/>  console.log('Folder/s deleted successfully!');<br/>});</span></pre><p id="d1c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在<code class="fe ls lt lu lv b">myFolder</code>中有其他文件和/或文件夹，如果您没有通过<code class="fe ls lt lu lv b">{ recursive: true }</code>，您会得到一个错误。</p><p id="4dc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">知道什么时候使用<code class="fe ls lt lu lv b">recursive</code>选项，什么时候不使用，以避免问题，这一点很重要。</p><p id="401c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个要点，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="41ee" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">重新命名</h1><p id="b1ea" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">fs</code>模块，您可以重命名目录和文件。下面的代码片段展示了如何使用<code class="fe ls lt lu lv b">rename</code>方法来实现这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="25f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到<code class="fe ls lt lu lv b">rename</code>方法有三个参数:</p><ol class=""><li id="b3ed" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr ol mc md me bi translated">第一个参数是现有的文件夹/文件。</li><li id="3aa4" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr ol mc md me bi translated">第二个参数是新名称。</li><li id="9838" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr ol mc md me bi translated">回调。</li></ol><p id="3e44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，要重命名文件或目录，需要传递当前文件/目录的名称和新名称。运行应用程序后，应该会更新目录/文件的名称。</p><p id="f6ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，如果新路径(例如文件/文件夹的新名称)已经存在，它将被覆盖。因此，请确保不要错误地覆盖现有的文件/文件夹。</p><p id="e7d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看这个要点，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9c1d" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">向文件添加内容</h1><p id="c105" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">使用文件系统模块，您还可以向现有文件添加新内容。<code class="fe ls lt lu lv b">appendFile</code>方法允许您这样做。</p><p id="ec2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你比较一下<code class="fe ls lt lu lv b">writeFile</code>和<code class="fe ls lt lu lv b">appendFile</code>的方法，你会发现它们是相似的。您传递文件路径、内容和一个回调。</p><pre class="kg kh ki kj gt no lv np nq aw nr bi"><span id="c4d5" class="ns ms iq lv b gy nt nu l nv nw">fs.appendFile(filePath, '\nNew data to be added!', (err) =&gt; {<br/>  if (err) throw err;<br/><br/>  console.log('New content added!');<br/>});</span></pre><p id="2c22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码片段演示了如何向现有文件添加新内容。如果您运行应用程序并打开您的文件，您应该会看到里面的新内容。</p><p id="4bfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看<a class="ae kv" href="https://gist.github.com/catalinpit/7c8d40db53dea9e6831f9ee89d92475c" rel="noopener ugc nofollow" target="_blank">这个要点</a>，看看你的应用程序在这一点上应该是什么样子。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="fd9e" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="5a80" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果你正在读这篇文章，这意味着你现在可以:</p><ul class=""><li id="7ebd" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">创建文件和目录。</li><li id="ea3e" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">修改文件和目录。</li><li id="1a4c" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">删除文件和目录。</li><li id="04f9" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">读取文件和目录的内容。</li></ul><p id="73f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干得好！然而，文件系统模块更复杂，我鼓励您查看<a class="ae kv" href="https://nodejs.org/docs/latest-v16.x/api/fs.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。在官方文档中，你可以看到所有的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om ok l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">YouTube版本</p></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="ad49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你想学习如何编码吗？查看这20个 <a class="ae kv" href="https://catalins.tech/20-best-places-to-learn-programming-for-free" rel="noopener ugc nofollow" target="_blank"> <em class="oi">学习如何编写</em> </a> <em class="oi">代码的最佳地点。</em></p><p id="9908" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oi">如果你想学习JavaScript，看看这5个</em> <a class="ae kv" href="https://catalins.tech/5-best-resources-to-learn-javascript-as-a-beginner" rel="noopener ugc nofollow" target="_blank"> <em class="oi">最好的JavaScript资源</em> </a> <em class="oi">。</em></p><p id="6a06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oi">下面列举一个带有</em> <a class="ae kv" href="https://catalins.tech/10-programming-project-ideas-for-beginners" rel="noopener ugc nofollow" target="_blank"> <em class="oi">编程项目思路</em> </a> <em class="oi">的清单，供初学者参考。</em></p><p id="0c8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="oi">检查这些</em><a class="ae kv" href="https://catalins.tech/javascript-es2020-the-features-you-should-know" rel="noopener ugc nofollow" target="_blank"><em class="oi">JavaScript es 2020</em></a><em class="oi">特性。</em></p></div></div>    
</body>
</html>