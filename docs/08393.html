<html>
<head>
<title>Create a 3D Heart for Valentine’s Day With Three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Three.js创建情人节的3D心形图案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/create-a-3d-heart-for-valentines-day-with-three-js-438aabf2d795?source=collection_archive---------6-----------------------#2021-04-26">https://betterprogramming.pub/create-a-3d-heart-for-valentines-day-with-three-js-438aabf2d795?source=collection_archive---------6-----------------------#2021-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="284f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你可以在一年中的任何时候做它！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/12f7947d88dbe9386b310f46cfb88f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_n9gwrrPoAIKCDNyO7CZVA.png"/></div></div></figure><p id="6de7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近(取决于你的时区，我猜)，是情人节季节。无论你是想向某个特别的人敞开心扉，还是想简单地将爱传播到全世界，可能没有比用JavaScript更好的方法了！</p><p id="e941" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本教程将展示我们如何使用three.js库来定义和修改自定义3D模型并在浏览器中渲染它。</p><p id="1213" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们将简要介绍什么是three.js，以及我们为什么在这里使用它。</p><p id="c0d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们将进入技术细节，看看如何创建一个场景，建立和渲染一个自定义模型，控制相机欣赏它的所有荣耀，最后，如何触发一个简单的动画。</p><p id="471d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">准备好升级你的基本表情符号了吗？❤</p><h1 id="df3f" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">为什么是Three.js</h1><p id="6344" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">three.js是一个依赖于WebGL的JavaScript 3D库，web GL是一个在浏览器中渲染2D和3D模型的API。</p><p id="d648" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当在常规HTML画布中绘制并使用GPU处理渲染过程时，three.js允许直接高效地操纵3D模型。甚至NASA也用它来模拟他们的火星车登陆火星。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="629b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然仅使用WebGL提供的工具来创建我们的心脏是完全可行的，但是您会看到three.js提供了丰富的API，使我们的工作变得更加简单。</p><p id="f1ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注意</strong> : three.js也提供画布2D、SVG和CSS3D渲染器，但是在这个例子中我们将坚持使用WebGL渲染器。</p><p id="c7e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安装three.js有不同的方法，但这次我们将通过CDN加载它。我们可以创建一个经典的<code class="fe mm mn mo mp b">index.html</code>文件，并在其中加载带有<code class="fe mm mn mo mp b">script</code>标签的库。</p><p id="ffb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们将在一个<code class="fe mm mn mo mp b">heart.js</code>文件中工作。此时，不需要其他任何东西。画布元素将由脚本自动添加到正文中。</p><pre class="kg kh ki kj gt mq mp mr bn ms mt bi"><span id="3362" class="mu lo iq mp b be mv mw l mx my">&lt;html&gt;<br/>  &lt;head&gt;<br/>  &lt;meta charset="utf-8"&gt;<br/>  &lt;title&gt;in my heart&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"&gt;&lt;/script&gt;<br/>    &lt;script src="./heart.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h1 id="2ecc" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">进入场景</h1><p id="4609" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">在制作实际模型之前，我们将为它创建一个友好的环境。</p><p id="a294" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">把你的艺术作品放在合适的场景中是你最起码应该做的。谢天谢地，我们可以使用我们得到的three.js工具。</p><p id="d0ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从第一个函数开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="459d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要定义一个实际的场景对象，它将包含我们将要渲染的几乎所有内容。很大的责任，但这是一句俏皮话。</p><p id="dbfe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们还需要创建一个相机对象。它代表你可以看到场景的点。Three.js提供了不同类型的相机，但这款很适合我们的情况。</p><p id="df57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如文档中所述:</p><blockquote class="na nb nc"><p id="71a6" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">“这种投影模式旨在模拟人眼的视觉方式。这是渲染3D场景最常用的投影模式。</p></blockquote><p id="02b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那好吧。您可以按照doc的指导来设置您的首选配置。注意，第二个参数用于摄像机的纵横比，这就是为什么它是从这里的窗口大小计算出来的。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="598e" class="nk lo iq mp b gy nl nm l nn my">camera.position.z = 30</span></pre><p id="f992" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要把摄像机放在离我们要放置形状的地方更远的地方。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="c120" class="nk lo iq mp b gy nl nm l nn my">const renderer = new THREE.WebGLRenderer({ antialias: true })</span></pre><p id="cfde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以实例化我们的<code class="fe mm mn mo mp b">WebGLRenderer</code>。你可以决定是否设置抗锯齿为真。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="2d9e" class="nk lo iq mp b gy nl nm l nn my">renderer.setSize(window.innerWidth, window.innerHeight)<br/>document.body.appendChild(renderer.domElement)</span></pre><p id="2194" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们设置大小以匹配窗口，并将画布附加到主体上。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="cd37" class="nk lo iq mp b gy nl nm l nn my">const color = 0xFFFFFF<br/>const intensity = 0.75<br/>const light = new THREE.PointLight(color, intensity)<br/>light.position.set(-15, -10, 30)</span><span id="39b9" class="nk lo iq mp b gy no nm l nn my">scene.add(light)</span></pre><p id="a386" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们将添加一个光源到我们的场景。Three.js还提供了不同种类的灯光。我在这里选择了点光源，因为它很容易可视化。它的行为就像一个灯泡——没有任何方向或任何东西。</p><p id="c885" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在一个<code class="fe mm mn mo mp b">init</code>方法中调用这个<code class="fe mm mn mo mp b">createScene</code>函数，这将是我们程序的入口点。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="3746" class="nk lo iq mp b gy nl nm l nn my">function init () {<br/> const {scene, camera, renderer} = createScene()<br/>}</span><span id="6864" class="nk lo iq mp b gy no nm l nn my">init()</span></pre><h1 id="efed" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">制造心脏</h1><p id="0b4c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在我们有了我们的场景，我们终于可以开始工作的明星…嗯，表演的核心！由于我们使用的是WebGL渲染器，我们知道可以用点(或顶点)坐标轻松绘制三角形。</p><p id="5e81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们将定义这些坐标；然后我们将看看如何在它们之间画三角形。</p><h1 id="29f6" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">协调</h1><p id="afb6" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们需要为我们的模型定义一组顶点。考虑这些点将连接你的形状的每一个边缘。在three.js中，可以使用<code class="fe mm mn mo mp b">Vector3</code>对象对它们进行配置。我们选择的位置可以是完全任意的。我通过在一张纸上画出我的模型算出了它们，但我会在这里作弊，给你看我用成品模型的图片选的坐标。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e2cf8b91aacdb9d412fba11a3ded28cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*llGsVoNBG9soyas6Wj0H_Q.png"/></div></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">心脏前侧各点的坐标</p></figure><p id="6901" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到每个点在一个(x，y，z)空间里有三个坐标，它中间比较厚，周围的边都在z=0平面上。让我从另一个角度展示给你看:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3f21fadcf11a5c4b64a19b6112a94f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*ibaGFX5nUAvWH2t5NJJMZg.png"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">心脏模型的侧视图</p></figure><p id="6d09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将需要另一组点的另一边，但他们是对称的，从第一个，所以我会饶你一个新的截图。</p><p id="c915" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们要渲染这些点之间的表面。你可能已经注意到，我们最终模型上的每个平面都是一个三角形。如果在一个空间中有三个点，三角形是你能画出的最简单的形状，它被广泛用于3D渲染中，作为任何模型的基础部分。</p><p id="3a09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们试图让它在这里容易可视化，所以我们只使用了几个三角形，但如果你想创建一个更平滑的形状，你可以使用更多。</p><h1 id="0bfb" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">三角形</h1><p id="ce57" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">好了，我们有了坐标，但是我们需要告诉three.js我们想要显示的三角形在哪里。我们将在这里使用的方法是存储这些坐标的索引，以便每三个索引的组代表一个三角形。</p><p id="bdfa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，是时候看看我们的第二个函数了。它看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="7c51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个数组(<code class="fe mm mn mo mp b">vertices</code>)表示将塑造我们的模型的所有点，从0到17。第二个(<code class="fe mm mn mo mp b">triangleIndexes</code>)代表我们要根据那些点画出的所有三角形。它只是一个整数数组，是第一个数组中顶点的索引。</p><p id="5e67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">重点是对于每三个索引，我们可以用第一个数组的三个对应点组成一个三角形。图中第一个三角形对应的是上面提到的点A、B、C。</p><h2 id="5e46" class="nk lo iq bd lp nv nw dn lt nx ny dp lx la nz oa lz le ob oc mb li od oe md of bi translated">创建网格</h2><p id="cc79" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">有了这些数据，我们现在就能画出东西来了！<br/>虽然我们完全可以让three.js绘制没有任何链接的三角形，但是如果有一个对象引用我们的模型会更好。</p><p id="d36f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在three.js中它被称为一个<code class="fe mm mn mo mp b">mesh</code>。</p><p id="857c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实例化一个新的<code class="fe mm mn mo mp b">mesh</code>，我们仍然需要创建两个对象:一个<code class="fe mm mn mo mp b">geometry</code>和一个<code class="fe mm mn mo mp b">material</code>。</p><p id="2cf9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe mm mn mo mp b">geometry</code>视为造型的参照物，将<code class="fe mm mn mo mp b">material</code>视为造型的质地或面料的参照物。</p><p id="d4c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成后，我们还需要一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="a9e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们分析一下这是怎么回事。首先，我们创建一个默认的<code class="fe mm mn mo mp b">geometry</code>。不需要进一步的配置，因为我们将分配它的所有面。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="634c" class="nk lo iq mp b gy nl nm l nn my">for (let i in trianglesIndexes) {<br/> if ((i+1)%3 === 0) {<br/>  geo.vertices.push(coordinatesList[trianglesIndexes[i-2]], coordinatesList[trianglesIndexes[i-1]], coordinatesList[trianglesIndexes[i]])<br/>  geo.faces.push(new THREE.Face3(i-2, i-1, i))<br/> }<br/>}</span></pre><p id="299d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这个循环，我们将遍历<code class="fe mm mn mo mp b">triangleIndexes</code>数组，对于每三个索引，我们可以用它存储相应的顶点和前两个顶点。</p><p id="2805" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们的几何图形已经有了这三个顶点，我们还可以给它添加一个<code class="fe mm mn mo mp b">face</code>。three.js中的<code class="fe mm mn mo mp b">Face3</code>对象由三个顶点索引定义。我们已经完成了匹配我们的点和三角形的工作(或者我们现在应该说面)，所以它是我们用来给几何体添加顶点的相同索引。</p><blockquote class="na nb nc"><p id="c377" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">另外，默认情况下，three.js一次只渲染一个面的正面。它是由索引的顺序定义的，所以如果它不适合你，也许你需要改变这个顺序。</p><p id="a1dc" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">如果需要的话，可以通过配置材质来渲染两面。</p></blockquote><p id="9f7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">既然我们已经确定了我们的几何图形，我们可以创建一个<code class="fe mm mn mo mp b">material</code>，如下所示:</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="9a80" class="nk lo iq mp b gy nl nm l nn my">geo.computeVertexNormals()<br/>const material = new THREE.MeshPhongMaterial( { color: 0xad0c00 } )</span></pre><p id="30cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用一种可以渲染光线反射的特定材质(因为为什么不可以)，所以在此之前我们将需要调用<code class="fe mm mn mo mp b">computeVertexNormals</code>。我们用漂亮的深红色来配置材料。</p><p id="dbdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，让我们将它添加到<code class="fe mm mn mo mp b">init</code>函数中，如下所示:</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="2731" class="nk lo iq mp b gy nl nm l nn my">function  init () {<br/> const {scene, camera, renderer} = createScene()<br/> const { vertices, trianglesIndexes} = useCoordinates()<br/> const { geo, material, heartMesh } = createHeartMesh(vertices, trianglesIndexes)</span></pre><p id="2b82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在还不足以考虑我们努力的结果，但是我们很快就会谈到场景的渲染。让我们在此之前添加最后一笔。</p><h2 id="a147" class="nk lo iq bd lp nv nw dn lt nx ny dp lx la nz oa lz le ob oc mb li od oe md of bi translated">三维线框模型</h2><p id="c715" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">现在我们可以看到它漂浮在空中，我们想添加一个效果，将每张脸分开。这不仅是为了让它超级时尚，也是为了更好地理解我们的三角形是如何在我们的模型上显示的。</p><p id="54e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">渲染网格面的边缘的对象被称为线框，一旦我们知道如何创建网格，这是非常容易的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="41f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以从之前创建的第一个几何图形自动创建一个<code class="fe mm mn mo mp b">WireframeGeometry</code>,并使用正确的材质和线对象创建线框。</p><p id="e37b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们可以将其添加到我们的心脏网格中。</p><p id="3e4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">嗯，一切似乎都在点上。我们来试着渲染一下吧！</p><h1 id="6e7b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">将模型放到场景中</h1><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="51a3" class="nk lo iq mp b gy nl nm l nn my">scene.add(heartMesh)</span></pre><p id="5c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">搞定了。下一步是什么？</p><p id="b56c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更严重的是，如果将我们的网格添加到场景中是如此容易，我们还需要看看如何渲染它并对它进行修改。</p><h2 id="edf8" class="nk lo iq bd lp nv nw dn lt nx ny dp lx la nz oa lz le ob oc mb li od oe md of bi translated">翻译</h2><p id="3f5c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">渲染非常简单，因为我们实例化了一个渲染器对象，并且拥有了我们需要的一切。</p><p id="cebd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，特别是如果我们想要动画我们的模型，我们将定期调用一个新的渲染。如今，平滑移动的通常频率是每秒六十帧。</p><p id="4b22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以简单地使用一个<code class="fe mm mn mo mp b">setInterval</code>并将其设置为六十分之一秒，但是浏览器提供了一个函数来获得相同的效果，而不需要太依赖主线程:<code class="fe mm mn mo mp b">requestAnimationFrame</code>。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="ff98" class="nk lo iq mp b gy nl nm l nn my">const animate = function () {<br/> requestAnimationFrame( animate )<br/> renderer.render( scene, camera )<br/> heartMesh.rotation.y -= 0.005<br/>}<br/>animate()</span></pre><p id="261b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mm mn mo mp b">requestAnimationFrame</code>接收一个回调作为它的参数，并将为每个可用的帧调用它。您可以在<a class="ae og" href="https://developer.mozilla.org/fr/docs/Web/API/Window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"> MDN文档上了解更多信息。</a></p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="69da" class="nk lo iq mp b gy nl nm l nn my">heartMesh.rotation.y -= 0.005</span></pre><p id="86d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这种行为，我们可以对模型进行简单的修改。通过减少(或增加)网格的旋转，我们可以使它围绕所需的轴旋转。</p><p id="2f1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">增量值越高，效果越快。</p><p id="7390" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们试着在<code class="fe mm mn mo mp b">init</code>函数中调用所有这些。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="bd39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你做到了这一步，你现在已经有了一个漂亮的心脏绕着自己旋转的3D模型，你已经准备好向你周围的每个人敞开心扉了。恭喜你！</p><p id="1e5e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果你认为你可以处理得更多一点，我们可以添加一个更复杂的动画，看看它是如何被用户输入触发的。</p><h2 id="2095" class="nk lo iq bd lp nv nw dn lt nx ny dp lx la nz oa lz le ob oc mb li od oe md of bi translated">跳动的动画</h2><p id="02fc" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">让我们用另一个动画来给我们的模型赋予生命。</p><p id="4016" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用我们在旋转动画中学到的东西，但是要让它看起来像我们的心脏在跳动。</p><p id="b530" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你知道该怎么做。让我们写另一个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="fba2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里要做的是放大网格，然后将其缩小到原始值。为了使变换一致，我们应该向网格的缩放属性的三个轴添加相同的增量值。</p><p id="0b85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以确定一个最大值，一旦达到这个值，我们就可以按比例缩小。我取了1.4，但是你可以随意放大或缩小它来制作一个更微妙的动画。</p><p id="e49e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后我们的算法非常简单:我们将把<code class="fe mm mn mo mp b">beatingIncrement</code>加到每个刻度属性上，一旦超过最大值，我们就切换一个布尔标志，然后从刻度属性中减去增量值。</p><p id="feda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数将被我们之前定义的<code class="fe mm mn mo mp b">animate</code>函数多次调用，因此尽管它看起来像是可以在while循环中编写的那种代码，但迭代是由渲染场景的递归方式触发的。</p><p id="a6a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们用下面的代码给<code class="fe mm mn mo mp b">animate</code>体添加跳动函数:</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="0e5b" class="nk lo iq mp b gy nl nm l nn my">const animate = function () {<br/>  requestAnimationFrame( animate )<br/>  renderer.render( scene, camera )<br/>  heartMesh.rotation.y -= 0.005<br/>  beatingAnimation(heartMesh)<br/>}</span></pre><p id="77cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">精彩！我们有脉搏了！</p><p id="811b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们继续下去，让用户决定心脏应该何时跳动。</p><h1 id="3da7" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">交互性</h1><p id="5b0c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我们的模型自豪地站在我们的场景中，甚至自己移动，但如果你再坚持一会儿，我们可以看到我们如何处理用户交互。</p><p id="0b39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们将使用光线投射来理解如何处理画布上的点击事件。之后，我们将设置相机控件，这不仅仅是3D建模世界中的有用工具。</p><h2 id="383c" class="nk lo iq bd lp nv nw dn lt nx ny dp lx la nz oa lz le ob oc mb li od oe md of bi translated">用Raycaster处理用户输入</h2><p id="657c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">通常，raycaster类通过利用鼠标指针和3D模型之间的交集来处理用户交互。</p><p id="48f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">开始了。下面是更多的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="6ef8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个函数需要一个对摄像机、场景的引用，以及一个将与指针交互的唯一网格ID。它返回一个函数，该函数将在单击/触摸事件时被调用。</p><p id="5843" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该处理程序方法设置鼠标对象的坐标，并允许光线投射者找出哪些网格截取了指针。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="8592" class="nk lo iq mp b gy nl nm l nn my">if (intersects.length &amp;&amp; intersects[0].object.uuid === meshUuid) {<br/>    startAnim = true<br/>}</span></pre><p id="df44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之后，我们只需测试第一个被相交对象的id是否与参数中传递的id相匹配。</p><p id="8aef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它必须是第一个，否则就意味着它隐藏在其他网格后面。在这种情况下，我们可以切换我们的标志变量。</p><p id="be39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个变量可以在<code class="fe mm mn mo mp b">animate</code>函数中触发我们的跳动动画。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="a9d0" class="nk lo iq mp b gy nl nm l nn my">const animate = function () {<br/> requestAnimationFrame( animate )<br/> renderer.render( scene, camera )<br/> heartMesh.rotation.y -= 0.005<br/> startAnim &amp;&amp; beatingAnimation(heartMesh)<br/>}</span></pre><p id="570c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">动画结束后切换回<code class="fe mm mn mo mp b">false</code>。</p><p id="e02f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要修改<code class="fe mm mn mo mp b">beatingAnimation</code>功能。下面是如何做到这一点:</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="6799" class="nk lo iq mp b gy nl nm l nn my">function beatingAnimation (mesh) {<br/>  // [...]<br/>   if (mesh.scale.x &lt;= 1) {<br/>    scaleThreshold = false<br/>    startAnim = false // we must stop it right here or it will start over again<br/>   }<br/> }<br/>}</span></pre><p id="7b3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以从<code class="fe mm mn mo mp b">init</code>函数中调用<code class="fe mm mn mo mp b">handleMouseIntersection</code>，然后将它返回的事件处理程序挂钩到窗口对象的click listener。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="391a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">精彩！你现在控制了殴打！事后看来，这听起来像是一项重大责任。</p><h1 id="1183" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">控制</h1><p id="3347" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">你可以骄傲。你的模型在你面前，你获得了对它的动画的控制，但是我们最后一次把它推得更远一点，并设置控制，以便你可以从各个角度欣赏它，怎么样？</p><p id="ef27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">听起来很有趣，对吧？让我们先尝试添加动态观察控件，然后为移动用户使用设备定向API。</p><h2 id="cc4f" class="nk lo iq bd lp nv nw dn lt nx ny dp lx la nz oa lz le ob oc mb li od oe md of bi translated">轨道控制</h2><p id="d9c2" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">动态观察控件允许您使相机围绕目标动态观察。这意味着我们可以将摄像机移动到离它所在的点越来越近的位置，并围绕这个点旋转摄像机，同时仍然朝向目标。</p><p id="c700" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这让我们可以改变角度和观点。</p><p id="bef8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管three.js本身不支持这一点，但我们可以使用一个API来设置这些控件。<a class="ae og" href="https://threejs.org/docs/#examples/en/controls/OrbitControls" rel="noopener ugc nofollow" target="_blank">看这里的doc</a>。</p><p id="69e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用脚本标签在<code class="fe mm mn mo mp b">index.html</code>中添加这个新的依赖项。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="f4bb" class="nk lo iq mp b gy nl nm l nn my">&lt;script src="<a class="ae og" href="https://threejs.org/examples/js/controls/OrbitControls.js" rel="noopener ugc nofollow" target="_blank">https://threejs.org/examples/js/controls/OrbitControls.js</a>"&gt;&lt;/script&gt;</span></pre><p id="ffcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以通过<code class="fe mm mn mo mp b">THREE</code>对象访问它的构造函数。让我们在一个专用函数中实例化它。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="3003" class="nk lo iq mp b gy nl nm l nn my">function setControls (camera, domElement) {<br/> const controls = new  THREE.OrbitControls( camera, domElement )<br/> controls.update()<br/>}</span></pre><p id="a4c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以在<code class="fe mm mn mo mp b">init</code>函数中调用它，就这样！现在，你可以通过按住左键环绕你的心脏，用滚轮放大和缩小，甚至用右键移动相机(或在触控板或触摸屏上的等效操作)。</p><p id="565f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，可以限制相机移动的范围；这可能是有用的。</p><p id="ef28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些动作已经足够欣赏你的创作了，但是当使用移动设备时，你还可以利用设备的方向将物理运动转换成相机运动。</p><h1 id="b3e0" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">设备方向控制</h1><p id="b4a9" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">像轨道控制一样，有一个我们可以使用的非本机API，你可以在这里阅读更多关于它的信息<a class="ae og" href="https://threejs.org/docs/#examples/en/controls/DeviceOrientationControls" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="ff14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与轨道一号相反，它只能改变相机的方向，所以你可以假装你的手机是你心脏居住和跳动的平行宇宙的一个窗口。</p><p id="a7b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mm mn mo mp b">DeviceOrientationControls</code>的代码可以在<a class="ae og" href="https://github.com/mrdoob/three.js/blob/master/examples/jsm/controls/DeviceOrientationControls.js" rel="noopener ugc nofollow" target="_blank">示例部分</a>的three.js GitHub存储库中找到，但是它引用了我们项目中没有的构建文件夹。你可以用我改编的这个做一个更独立的版本或者自己做。只要确保在你的<code class="fe mm mn mo mp b">index.html</code>文件中引用它。</p><p id="7b6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完成后，我们可以在之前的函数中使用它。最好不要删除我们刚刚做的，所以让我们使控件的初始化更有条件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz ml l"/></div></figure><p id="19f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这次我们需要返回<code class="fe mm mn mo mp b">controls</code>引用，因为当使用<code class="fe mm mn mo mp b">DeviceOrientationControls</code>时，我们还必须在渲染循环中调用c <code class="fe mm mn mo mp b">ontrols.update()</code>。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="001b" class="nk lo iq mp b gy nl nm l nn my">const  animate = function () {<br/> requestAnimationFrame( animate )<br/> renderer.render( scene, camera )<br/> heartMesh.rotation.y -= 0.005<br/> startAnim &amp;&amp; beatingAnimation(heartMesh)<br/> controls.update() // this line is new<br/>}<br/>animate()</span></pre><p id="53fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您可以通过改变<code class="fe mm mn mo mp b">setControls</code>调用中的参数，在两种控制模式之间轻松切换。不难将它与用户输入和其他想法联系起来。</p><pre class="kg kh ki kj gt mq mp nh ni aw nj bi"><span id="c098" class="nk lo iq mp b gy nl nm l nn my">const { controls } = setControls(camera,  renderer.domElement, true)</span></pre><p id="ae62" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可能有一种方法可以将两种控制结合成一个，并获得相机的全部动力，但在我写这篇文章的时候，我还没有找到它，我想它可能会变得有点乱。</p><h1 id="3d82" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">恭喜你！</h1><p id="5cd7" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">如果你做到了这一步，你现在已经建立了一个美妙的脉动指挥三维心脏！</p><p id="2e55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们通过初始化和使用three.js API来创建一个场景并渲染其中的网格，但我们也使用了一个坐标系来从头开始构建整个模型。</p><p id="765e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们处理用户与画布的交互，并让他们控制相机对象。</p><p id="9f86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在这里找到源代码<a class="ae og" href="https://github.com/Eddinos/eddinos.github.io/tree/master/in-my-heart" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到现场演示<a class="ae og" href="https://eddinos.github.io/in-my-heart/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6e79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也可以看看<a class="ae og" href="https://eddinos.github.io/in-my-heart/advanced/" rel="noopener ugc nofollow" target="_blank">高级版本</a>，它有更多的细节，例如，控件限制，心脏周围的墙壁模型，以及让你在加载页面时选择控件的用户输入。</p><p id="377e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你对3D渲染感兴趣，我强烈推荐Maxime Euzière 的这本指南。</p><p id="d64a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我做了这个实验之后写的。与其说我是专家，不如说我是初学者，所以如果你发现了一些可以改进的地方并与其他读者分享，请随时告诉我！</p><p id="f658" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你能从我的经历中学到一些东西。感谢您的阅读！</p></div></div>    
</body>
</html>