<html>
<head>
<title>Complexity Theory for Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法的复杂性理论</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/complexity-theory-for-algorithms-fabd5691260d?source=collection_archive---------8-----------------------#2020-04-14">https://betterprogramming.pub/complexity-theory-for-algorithms-fabd5691260d?source=collection_archive---------8-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d42e7a15a5d07f231039c32e233a33b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BgdLXKq1yoXD9139SHTWMA.jpeg"/></div></div><p class="jc jd gj gh gi je jf bd b be z dk translated">由<a class="ae jg" href="https://unsplash.com/photos/eH_ftJYhaTY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae jg" href="https://unsplash.com/@chuttersnap" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>拍摄的图像</p></figure><h2 id="121a" class="jh ji jj bd b dl jk jl jm jn jo jp dk jq translated" aria-label="kicker paragraph">软件工程</h2><div class=""/><div class=""><h2 id="9311" class="pw-subtitle-paragraph kp js jj bd b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dk translated">我们如何测量算法的速度</h2></div><p id="f3eb" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><em class="md">复杂性理论</em>研究算法运行所需的时间，作为输入大小的函数。这对软件开发人员理解非常有用，这样他们就可以高效地编写代码。有两种类型的复杂性:</p><p id="5087" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><strong class="lj jt">空间复杂度</strong>:一个算法需要运行多少内存。<br/> <strong class="lj jt">时间复杂度</strong>:一个算法需要运行多少时间。</p><p id="abf5" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们通常更担心时间复杂度而不是空间复杂度，因为我们可以重用算法运行所需的内存，但我们不能重用运行所需的时间。买记忆比买时间容易。如果你需要更多内存，你可以从亚马逊、谷歌或微软等提供商那里租用服务器空间。您也可以购买更多的计算机来增加更多的内存，而无需租用服务器空间。本文的剩余部分将介绍我们如何优化时间复杂度。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="687e" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">我们如何度量时间复杂度？</h1><p id="6097" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">新电脑通常会比旧电脑快，台式机通常会比智能手机快——那么我们如何真正知道一个算法花费的绝对时间呢？</p><p id="69e7" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了测量绝对时间，我们考虑算法执行的操作数量。任何算法的构建块都是if语句和循环。他们回答问题:<em class="md"> (1)什么时候应该做运营？(2)我们应该做多少次</em>？我们希望在任何机器上使用尽可能少的if语句和循环来编写代码，以获得最高的效率。</p><p id="9e3a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">为了分析算法，我们考虑输入大小<em class="md">n</em>——输入项目的数量。我们想好好猜测一下算法的运行时间与输入大小<em class="md"> n. </em>这是<em class="md">增长顺序:</em>给定输入大小<em class="md"> n. </em>算法将如何扩展和表现</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="ea24" class="nr mm jj nn b gy ns nt l nu nv"><strong class="nn jt">1. Input 10 items -&gt; 10 ms<br/>2. Input 100 items -&gt; 100 ms (Good, linear growth)<br/>3. Input 1,000 items -&gt; 10,000 ms (Bad, exponential growth)</strong></span></pre><p id="016e" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在上面的例子中，当我们输入10个条目时，运行需要10毫秒。当我们输入100个条目时，需要100毫秒——这很好，因为输入的增长与运行时间成比例。</p><p id="3d08" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然而，在下一步中，我们输入1，000个项目，需要10，000毫秒。相对于输入大小的增加，我们现在需要10倍的时间来运行<em class="md"> n. </em>现在，我们的运行时呈指数增长，而不是线性增长。为了更好地理解不同的增长顺序，我们将介绍一下<em class="md"> Big-O符号。</em></p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="c558" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">大O复杂度图</h1><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nw"><img src="../Images/cc20d119b8f1da35e1a1670207bc9b68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxCH4aYMa21HFVxSYL4p0Q.jpeg"/></div></div></figure><p id="93f1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">big-o符号描述了当运行时趋向于特定值或无穷大时算法的限制行为。我们用它来根据算法对输入大小变化的反应来对算法进行分类。我们将输入大小表示为<em class="md"> n </em>，对输入执行的操作数表示为<em class="md">n。</em>我的例子将用Python编码。</p><p id="ae5f" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">我们更喜欢在输入方面具有增长顺序<em class="md"> </em>即<em class="md">线性算法</em>或更快的算法，因为较慢的算法不能扩展到大的输入大小。以下是运行时复杂性从低到高的列表:</p><ul class=""><li id="b6d3" class="nx ny jj lj b lk ll ln lo lq nz lu oa ly ob mc oc od oe of bi translated">O(1) : <strong class="lj jt">恒定时间复杂度</strong></li><li id="a0d9" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">O(log(n)) : <strong class="lj jt">对数复杂度</strong></li><li id="1d66" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">O(n) : <strong class="lj jt">线性复杂度</strong></li><li id="017b" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">O(n * log(n)) : <strong class="lj jt">线性算法复杂度</strong></li><li id="8525" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">O(n^k) : <strong class="lj jt">多项式复杂度</strong>(其中<strong class="lj jt">k</strong>t42】1)</li><li id="662b" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">O(c^n) : <strong class="lj jt">指数复杂度</strong>(其中<strong class="lj jt"> c </strong>为常数)</li><li id="1561" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">O(n！):<strong class="lj jt">阶乘复杂度</strong></li></ul></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="d46c" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">恒定时间复杂度:O(1)</h1><p id="b200" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">如果运行时间被一个不依赖于输入大小的值所限制，则算法在<em class="md">常数时间</em>内运行。</p><p id="b9bd" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">常数时间算法的第一个例子是交换两个数的函数。如果我们改变函数定义，接受一百万个数字作为输入，而函数体保持不变，它仍然只执行同样的三个操作和一个返回语句。运行时不会根据输入大小而改变。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="521a" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">swapNums</strong>(num1, num2):<br/>   temp = num1<br/>   num1 = num2<br/>   num2 = temp<br/>   return (num1, num2)</span></pre><p id="b33a" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在第二个例子中，我们将首先检查输入消息是否为<code class="fe ol om on nn b">“Hello World!”</code>，如果是，则将消息更改为另一个值。之后，它将循环三次，执行另一个将打印消息100次的循环，这意味着消息将被打印300次。尽管进行了所有这些操作，但由于该函数不会根据输入大小执行更多的操作，因此该算法仍然以恒定的时间运行。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="8a85" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">printMessage300Times</strong>(message):<br/>   if(message == "Hello World!")<br/>      message = "Pick something more original!"<br/>   for x in range(0, 3):<br/>      for x in range(0, 100):<br/>         print(message)</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="0fb1" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">对数时间复杂度:O(log(n))</h1><p id="fe19" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">对数算法具有很强的可扩展性，因为当输入大小<em class="md"> n </em>增加时，运算数量<em class="md"> N </em>与输入大小<em class="md"> n </em>的比率会降低。这是因为对数算法不会访问其输入的所有元素——我们将在<em class="md">二进制搜索算法中看到。</em></p><p id="4747" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在二分搜索法，我们试图在一个排序列表<code class="fe ol om on nn b">num_list</code>中找到我们的输入号码<code class="fe ol om on nn b">num</code>。我们的输入尺寸<em class="md"> n </em>是<code class="fe ol om on nn b">num_list</code>的长度。</p><p id="ef13" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">由于我们的列表已经排序，我们可以将我们正在搜索的<code class="fe ol om on nn b">num</code>与列表中间的数字进行比较。如果<code class="fe ol om on nn b">num</code>大于中点值，我们知道我们的<code class="fe ol om on nn b">num</code> <em class="md"> </em>只能在列表的较大一侧——所以我们可以完全丢弃列表的较低端，因为不需要处理它而节省时间。</p><p id="46a2" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">然后，我们可以在列表的另一半上递归地重复这个过程(其行为很像一个循环),每次迭代时丢弃剩余的一半<code class="fe ol om on nn b">num_list</code>。这就是我们如何实现对数时间复杂度。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="0e88" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">binarySearch</strong>(num_list, left_i, right_i, num):<br/>   if right_i &gt;= left_i:<br/>      midpoint = left_i + (right_i - left_i)/2<br/>      if num_list[midpoint] == num:<br/>         return midpoint<br/>      elif num_list[midpoint] &gt; num:<br/>         return binarySearch(num_list, left_i, midpoint-1, num)<br/>      else:<br/>         return binarySearch(num_list, midpoint+1, right_i, num)<br/>   else:<br/>      return "Number not in collection"</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="b688" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">线性时间复杂度:O(n)</h1><p id="98bf" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">当运行时间与输入<em class="md"> n </em>的大小成比例增加时，算法在<em class="md">线性时间</em>内运行。如果我们将输入乘以10，运行时也应该乘以10或更少。这是因为在线性时间算法中，我们通常对输入的每个元素运行操作。</p><p id="8902" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在未排序的数字集合中寻找最大值是我们可以创建的在线性时间<em class="md"> </em>中运行的算法，因为我们必须检查一次输入中的每个元素才能解决问题:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="7952" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">findMaxNum</strong>(list_of_nums):<br/>   max = list_of_nums[0]</span><span id="e44e" class="nr mm jj nn b gy oo nt l nu nv">   for i in range(1, len(list_of_nums.length)):<br/>      if(list_of_nums[i] &gt; max):<br/>         max = list_of_nums[i]</span><span id="c2c5" class="nr mm jj nn b gy oo nt l nu nv">   return max</span></pre><p id="e96c" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在<code class="fe ol om on nn b">for</code>循环中，我们迭代输入中的每个元素<em class="md"> n </em>，<strong class="lj jt"> </strong>如果需要的话，在最后返回最大值之前更新我们的最大值。线性时间<em class="md"> </em>算法的更多例子包括检查无序列表中的重复项或查找列表的总和。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="2066" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">线性时间复杂度:O(n * log(n))</h1><p id="b7d6" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">Linearithmic-time <strong class="lj jt"> </strong>算法比线性时间的算法略慢，但仍可伸缩。</p><p id="198d" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这是一个中等的复杂度，在线性时间内浮动，直到输入达到足够大的规模。在<em class="md">线性时间</em>中运行的算法的最流行的例子是排序算法，如<code class="fe ol om on nn b">mergeSort</code>、<code class="fe ol om on nn b">quickSort</code>和<code class="fe ol om on nn b">heapSort</code>。我们再来看<code class="fe ol om on nn b">mergeSort</code>:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="6916" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">mergeSort</strong>(num_list): <br/>    if len(num_list) &gt; 1: <br/>        midpoint = len(arr)//2<br/>        L = num_list[:midpoint] # Dividing "n"  <br/>        R = num_list[midpoint:] # into 2 halves <br/>  <br/>        mergeSort(L) # Sort first half <br/>        mergeSort(R) # Sort second half <br/>  <br/>        i = j = k = 0<br/>          <br/>        # Copy data to temp arrays L[] and R[] <br/>        while i &lt; len(L) and j &lt; len(R): <br/>            if L[i] &lt; R[j]: <br/>                num_list[k] = L[i] <br/>                i+=1<br/>            else: <br/>                num_list[k] = R[j] <br/>                j+=1<br/>            k+=1<br/>          <br/>        # Checking if any element was left in L<br/>        while i &lt; len(L): <br/>            num_list[k] = L[i] <br/>            i+=1<br/>            k+=1</span><span id="eae3" class="nr mm jj nn b gy oo nt l nu nv">        # Checking if any element was left in R<br/>        while j &lt; len(R): <br/>            num_list[k] = R[j] <br/>            j+=1<br/>            k+=1</span></pre><h2 id="0dc9" class="nr mm jj bd mn op oq dn mr or os dp mv lq ot ou mx lu ov ow mz ly ox oy nb jp bi translated">“合并排序”的工作原理是:</h2><ul class=""><li id="38f4" class="nx ny jj lj b lk nd ln ne lq oz lu pa ly pb mc oc od oe of bi translated">递归地划分<code class="fe ol om on nn b">num_list</code>,直到元素为两个或更少</li><li id="1574" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">对每一对项目进行迭代排序</li><li id="3ade" class="nx ny jj lj b lk og ln oh lq oi lu oj ly ok mc oc od oe of bi translated">迭代合并我们得到的数组</li></ul><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/8910e6de457ca9dd4a39d16c3c440bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/0*__U0YOEGlJgb6ejJ.gif"/></div></figure><p id="3cde" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">使用这种方法，我们可以实现线性时间，因为整个输入<em class="md"> n </em>必须迭代，并且这必须发生<em class="md"> O(log(n)) </em>次(输入只能减半<em class="md"> O(log(n)) </em>次)。使<em class="md"> n </em>个项目迭代<em class="md"> log(n) </em>次会导致运行时间<em class="md"> O(n * log(n)) </em>，也称为线性时间。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="6db5" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">多项式时间复杂度:O(n^c)其中c &gt; 1</h1><p id="90b4" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">如果运行时间对于所有输入大小<em class="md"> n </em>以相同的指数<em class="md"> c </em>增加，则算法在<em class="md">多项式时间</em>内运行。</p><p id="bc26" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这一次的复杂性和随后的复杂性不成比例！这意味着随着输入大小的增长，运行时最终会变得太长，使算法不可行。有时我们会遇到无法快速解决的问题，我们需要创造性地限制输入的大小，这样我们就不会经历多项式算法将会产生的长处理时间。一个例子<em class="md">多项式</em>算法是<code class="fe ol om on nn b">bubbleSort</code>:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="025e" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">bubbleSort</strong>(num_list):<br/>    n = len(num_list)<br/>    for i in range(n):<br/>        # Last i elements are already in place<br/>        for j in range(0, n-i-1):<br/>            # Swap if the element found is greater<br/>            # than the next element<br/>            if num_list[j] &gt; num_list[j+1] :<br/>                temp = num_list[j]<br/>                num_list[j] = num_list[j+1]<br/>                num_list[j+1] = temp</span></pre><p id="1dbf" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated"><code class="fe ol om on nn b">bubbleSort</code>将一遍又一遍地遍历列表中的所有元素，当发现相邻的数字顺序不对时，就交换它们。只有当它发现所有的数字都按正确的顺序排列时，它才会停止。</p><p id="c093" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">在下图中，我们只有七个项目。该算法在整个集合中迭代三次来对数字进行排序——但是如果是100个数字，很容易看出运行时间会变得很长。<em class="md">这个不成比例。</em></p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pd"><img src="../Images/dab159588fceb522dc474f72789c4bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GWXUEsRclGWiMTYt.gif"/></div></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="862b" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">指数时间复杂度:O(c^n)其中c是常数</h1><p id="d175" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">当运行时间随着输入数据集的每次增加而加倍时，算法以指数时间<em class="md">运行。递归计算斐波那契数列是指数时间算法的一个例子:</em></p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="823b" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">fibonacci</strong>(n): <br/>    if n == 0:<br/>        return 0<br/>    elif n == 1:<br/>        return 1<br/>    else: <br/>        return fibonacci(n-1) + fibonacci(n-2) </span></pre><p id="96b1" class="pw-post-body-paragraph lh li jj lj b lk ll kt lm ln lo kw lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">这个算法在最后一行调用自己两次——一次用<em class="md"> n-1 </em>调用，一次用<em class="md"> n-2调用。</em>这意味着如果我们从<em class="md"> n=7开始，</em>我们将总共调用该函数25次！随着输入的增长，运行成本非常高。</p><figure class="ni nj nk nl gt iv gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/55b60c9d9f585788f81de5e3bb050b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*c4L35PXoqeeKWMA1.png"/></div></figure></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="503b" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">阶乘时间复杂度:O(n！)</h1><p id="e68e" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">最后，如果算法对输入<em class="md"> n </em>迭代的次数等于<em class="md"> n </em>乘以所有小于<em class="md"> n </em>的正整数，则该算法在<em class="md">阶乘时间</em> <strong class="lj jt"> </strong>内运行。这是我们将在本文中讨论的最慢的时间复杂度，它主要用于计算集合的排列:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="b24c" class="nr mm jj nn b gy ns nt l nu nv">def <strong class="nn jt">getListPermutation</strong>(items_list):<br/>   results = []<br/>   i = 0<br/>   l = len(items_list)<br/>   while i &lt; l:<br/>      j, k = i, i + 1<br/>      while k &lt;= l:<br/>         results.append(" ".join(items_list[j:k]))    <br/>         k = k + 1<br/>      i = i + 1<br/>   print results</span></pre></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="351b" class="ml mm jj bd mn mo mp mq mr ms mt mu mv ky mw kz mx lb my lc mz le na lf nb nc bi translated">结论</h1><p id="c3f2" class="pw-post-body-paragraph lh li jj lj b lk nd kt lm ln ne kw lp lq nf ls lt lu ng lw lx ly nh ma mb mc im bi translated">感谢阅读！我很乐意听到您的反馈或回答您的任何问题。</p></div></div>    
</body>
</html>