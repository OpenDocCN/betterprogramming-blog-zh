<html>
<head>
<title>Implementing an Actor Model in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中实现一个演员模型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-the-actor-model-in-golang-3579c2227b5e?source=collection_archive---------2-----------------------#2022-02-14">https://betterprogramming.pub/implementing-the-actor-model-in-golang-3579c2227b5e?source=collection_archive---------2-----------------------#2022-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6605" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用这种编程结构利用并发的力量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b83da03cd5aa09a7942a1661b3359516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*smZOmMQjuS_5l1Af"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">乔治·豪登在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5b5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着多核CPU的出现，我们需要能够通过以并发方式处理任务来利用这些额外内核的编程结构。<br/>actor模型就是这样一种编程结构，它对大量独立作业进行建模，这些作业以任意顺序进行处理，无需锁同步。</p><p id="55cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">actor模型的一个非常常见的用法可以在web服务器，Play！Java中的框架就是一个例子。一般来说，任何并发应用程序都可以构建在参与者模型之上。</p><p id="5fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将描述如何在golang中实现一个原始的actor模型。我们将利用golang提供的工具进行并发处理——go routines、通道和等待组。</p><p id="f096" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们来看一个演员:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/efb49e7e58fd76920bb02a1950e289bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*CIXfHy3wUQ6iF0Q20depzA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd lt">演员</strong></p></figure><p id="b7f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个actor有一个任务队列和一个监听任务队列并执行任务的goroutine。</p><p id="3489" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里A是一个阻塞任务队列并继续执行队列中的任务的goroutine。<br/>这里是一个actor的界面的样子:</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="bb26" class="lz ma iq lv b gy mb mc l md me">type Actor interface {<br/>   AddTask(task Task)<br/>   Start()<br/>   Stop()<br/>}</span></pre><p id="2060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们来看看<code class="fe mf mg mh lv b">task</code></p><p id="a16b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">任务在一个actor中执行。它是用<em class="mi">执行方法</em>给定接口的实现。任何可以通过执行调用来执行的东西。任务是我们需要做的工作的业务实现。</p><p id="cf79" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在web服务器框架中，它将调用定义API实现的接收者。</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="e69a" class="lz ma iq lv b gy mb mc l md me">type Task interface {<br/>   Execute()<br/>}</span></pre><p id="c0fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个系统看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mj"><img src="../Images/dccd2290cde127513b3e57acc388bbd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YGV-7SgbyBUKIUnruMI5Sg.png"/></div></div></figure><p id="ce41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看看actor系统界面。</p><pre class="kg kh ki kj gt lu lv lw lx aw ly bi"><span id="aab8" class="lz ma iq lv b gy mb mc l md me">type ActorSystem interface {<br/>   Run()<br/>   SubmitTask(task Task) <br/>   Shutdown(shutdownWG *sync.WaitGroup)<br/>}</span></pre><p id="8fed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mf mg mh lv b">SubmitTask</code>方法将<code class="fe mf mg mh lv b">Task</code>提交给<code class="fe mf mg mh lv b">ActorSystem</code>。一个<code class="fe mf mg mh lv b">taskAssigner</code>将每个任务分配给其中一个<code class="fe mf mg mh lv b">Actor</code>。每个<code class="fe mf mg mh lv b">Actor</code>也有一个小队列，在其中缓冲任务并逐个执行。</p><p id="cdc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们深入了解每个组件</p><h1 id="8c8e" class="mk ma iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">演员系统</h1><p id="30af" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">下面是<code class="fe mf mg mh lv b">ActorSystem</code>的一个要点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6c54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe mf mg mh lv b">ActorSystem</code>启动时，它启动一个<code class="fe mf mg mh lv b">taskAssigner</code>演员。通过调用actor上的AddTask方法，将每个传入系统的<code class="fe mf mg mh lv b">Task</code>添加到taskAssigner <code class="fe mf mg mh lv b">actor</code>中。</p><p id="9898" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mf mg mh lv b">SubmitTask</code>方法将<code class="fe mf mg mh lv b">Tasks</code>提交给<code class="fe mf mg mh lv b">ActorSystem</code>。我们通过调用<code class="fe mf mg mh lv b">AddTask</code>方法将每个传入的<code class="fe mf mg mh lv b">Tasks</code>放到<code class="fe mf mg mh lv b">taskAssigner</code>中。</p><p id="6a9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mf mg mh lv b">Shutdown</code>它关闭<code class="fe mf mg mh lv b">tasks</code>通道，阻塞任何新的输入任务，等待所有接收到的任务被分配给参与者。然后，它在每个<code class="fe mf mg mh lv b">Actor</code>上调用<code class="fe mf mg mh lv b">Stop</code>，并等待它们完成。</p><h1 id="8c03" class="mk ma iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">任务分配者</h1><p id="40e4" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">我们将每个传入的<code class="fe mf mg mh lv b">Tasks</code>放在通道<code class="fe mf mg mh lv b">tasks</code>中，将<code class="fe mf mg mh lv b">taskAssigner</code>和<code class="fe mf mg mh lv b">Task</code>放在一个<code class="fe mf mg mh lv b">Actor</code>的内部队列中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a86a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mf mg mh lv b">taskAssigner</code>内部流程任务通过调用池中的<code class="fe mf mg mh lv b">AddTask</code>将任务传递给池中的一个任务参与者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mf mg mh lv b">autoScalar</code>监视<code class="fe mf mg mh lv b">tasks</code>中的项目数，并增加或减少<code class="fe mf mg mh lv b">task actor pool</code>的大小。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="995a" class="mk ma iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">任务参与者</h1><p id="8aa1" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">它也是一个参与者，其工作是执行添加到通道任务中的任务，类似于分配者参与者。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="0311" class="mk ma iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">基准</h1><p id="fc9c" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">这里我们模拟了一个web服务器。</p><ol class=""><li id="196f" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">100k个请求以2毫秒的时间间隔线性发送</li><li id="0af0" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">当时钟在一分钟前30秒时，每个请求需要[0，50]~ 25毫秒，在一分钟的后30秒需要[50–100]~ 75毫秒。</li><li id="87ac" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">这模拟了下游服务延迟突然变化的情况。我们希望控制我们的吞吐量，以便不增加任何任务的等待时间</li></ol><p id="3392" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是io模拟基准的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="33eb" class="mk ma iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated"><strong class="ak">结果</strong></h1><p id="d553" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">这是模拟的结果。我们每隔100毫秒跟踪3个指标</p><ol class=""><li id="fe76" class="ni nj iq ky b kz la lc ld lf nk lj nl ln nm lr nn no np nq bi translated">提交的任务:这是一条恒定的线性橙色线，因为我们每2毫秒添加一个任务。</li><li id="be92" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">已完成的任务:这是黄线，它试图紧跟橙色线，因为我们希望尽快完成提交的任务。</li><li id="feac" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">活动参与者:这是蓝线，显示了系统需要为任务提供短等待时间的活动参与者的数量。当任务延迟增加时，参与者的数量也会增加，因为我们需要更多的参与者来实现类似的吞吐量。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/b2f772b33b258b6b11a0b42607b1de15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*18Cozxyrhjoup_xNbPk2XQ.png"/></div></div></figure><h2 id="5fdb" class="lz ma iq bd ml nx ny dn mp nz oa dp mt lf ob oc mv lj od oe mx ln of og mz oh bi translated"><strong class="ak">观察结果</strong></h2><ol class=""><li id="cb3b" class="ni nj iq ky b kz nb lc nc lf oi lj oj ln ok lr nn no np nq bi translated">在大约30秒时，标记等待时间从大约25毫秒增加到大约75毫秒</li><li id="a151" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">已完成的指标被删除，因为我们无法再处理类似数量的任务。</li><li id="1b8a" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">自动标量注意到队列大小增加，并开始增加actors，使其稳定在30个actors左右</li><li id="04f8" class="ni nj iq ky b kz nr lc ns lf nt lj nu ln nv lr nn no np nq bi translated">当延迟下降到大约25毫秒时，我们在60秒左右返回到原始状态。</li></ol><p id="0a24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该项目的完整代码可在以下网址找到:</p><div class="ol om gp gr on oo"><a href="https://github.com/gauravsa/go-actor-system" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">GitHub-gauravsa/go-actor-system</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">github.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc kp oo"/></div></div></a></div></div></div>    
</body>
</html>