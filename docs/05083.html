<html>
<head>
<title>The React Component Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件生命周期</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-react-component-lifecycle-c9302202a69f?source=collection_archive---------2-----------------------#2020-06-07">https://betterprogramming.pub/the-react-component-lifecycle-c9302202a69f?source=collection_archive---------2-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0146" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在创建、更新和销毁组件时，了解组件正在经历什么</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5952c5a88e7c4e9f9977719820863479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G9TPx-SO_-hnHBSP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">K. Mitch Hodge 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="ec68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我使用React的经验中，<code class="fe ls lt lu lv b">componentDidMount</code>一直是我使用的生命周期方法。我基本上忽略了其他人。然而，存在许多其他的生命周期方法。虽然很少使用，但了解它们的功能以及它们在组件生命周期中扮演的角色是很重要的。</p><p id="197a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面概述了组件生命周期的各个阶段，以及每种生命周期方法在此过程中的位置和方式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/75396d3980bdfecebf169b88963bbecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuhR3fqh5iieRs21MiQIAA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片来自<a class="ae kv" href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" rel="noopener ugc nofollow" target="_blank"> Wojciech Maj </a>。</p></figure></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="c5ab" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">组件生命周期</h1><p id="07dd" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">React的一个特点是能够创建由可重用组件组成的高响应性UI。由于用户交互和应用程序中的输入或更新，组件可以很容易地改变。为了适应这种不断变化的状态，React组件参与了创建(或安装)、更新和删除(或卸载)的生命周期。这个生命周期包括内置的方法，称为生命周期方法，可以在生命周期的不同时间调用这些方法来控制组件如何对应用程序中的更改做出反应。</p><p id="923d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">记住<code class="fe ls lt lu lv b">render()</code>是React组件中唯一需要的方法是很重要的。如果您想改变组件的默认行为，以下方法都是可选的。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="b31b" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">增加</h1><p id="6a45" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">React组件本质上是JavaScript类，因此它们包含一个<code class="fe ls lt lu lv b">constructor</code>函数来定义组件的初始状态，甚至在挂载发生之前:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:<code class="fe ls lt lu lv b">super</code>在上面被调用是为了确保我们可以将自己的功能添加到从<code class="fe ls lt lu lv b">React.Component</code>继承的<code class="fe ls lt lu lv b">constructor</code>函数中。</p><p id="b2f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦确定了初始状态，组件的JSX就会呈现在页面上，这样组件就被安装到DOM上了。此时，<code class="fe ls lt lu lv b">static getDerivedStateFromProps</code>和<code class="fe ls lt lu lv b">componentDidMount</code>生命周期方法是可用的。</p><p id="67e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次渲染一个组件时都会调用<code class="fe ls lt lu lv b">static getDerivedStateFromProps</code>函数，这是唯一一个在安装过程中在<code class="fe ls lt lu lv b">render</code>之前调用的生命周期方法。这个函数返回一个对象来更新状态，如果没有要更新的内容，则返回<code class="fe ls lt lu lv b">null</code>。<code class="fe ls lt lu lv b">static getDerivedStateFromProps</code>很少使用，除非组件的状态依赖于其属性随时间的变化。在每次渲染之前触发该方法(有时是不必要的)会导致应用程序出现性能问题。</p><p id="259f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">componentDidMount</code>只被调用一次，紧跟在组件的第一个<code class="fe ls lt lu lv b">render</code>之后。这是迄今为止最常用的生命周期方法。通常，任何DOM操作或从端点获取长期运行的数据都在这个方法中进行。这也是设置任何订阅或间隔的好地方。但是，它们必须在<code class="fe ls lt lu lv b">componentWillUnmount()</code>中终止(稍后将详细介绍)。</p><p id="ac80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举例来说，假设我们有一个每10秒获取实时股票数据的应用程序。在<code class="fe ls lt lu lv b">componentDidMount</code>中，我们将通过回调获取数据的函数来初始化时间间隔:</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="17c3" class="nh mf iq lv b gy ni nj l nk nl">componentDidMount() {<br/>    this.interval = setInterval(this.fetchStockData, 10000);<br/>} </span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="23e2" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">更新</h1><p id="f5a6" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在组件生命周期的更新阶段，有四种生命周期方法(除了<code class="fe ls lt lu lv b">render</code>)可用。这些是<code class="fe ls lt lu lv b">static getDerivedStateFromProps</code>(再次)、<code class="fe ls lt lu lv b">shouldComponentUpdate</code>、<code class="fe ls lt lu lv b">getSnapshotBeforeUpdate</code>和<code class="fe ls lt lu lv b">componentDidUpdate</code>。这些方法总是按照简介中的图表中列出的顺序调用:</p><ol class=""><li id="f7a6" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b">static getDerivedStateFromProps(props, state)</code></li><li id="e84a" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b">shouldComponentUpdate(nextProps, nextState)</code></li><li id="0bce" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b">render()</code> —渲染通过<code class="fe ls lt lu lv b">this.props</code>和<code class="fe ls lt lu lv b">this.state</code>访问道具和状态。</li><li id="d290" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b">getSnapshotBeforeUpdate(prevProps, prevState)</code></li><li id="2488" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><code class="fe ls lt lu lv b">componentDidUpdate(prevProps, prevState, snapshot)</code> —可以通过<code class="fe ls lt lu lv b">this.props</code>和<code class="fe ls lt lu lv b">this.state</code>访问道具和状态。这是最后一次以前的道具和以前的状态可用。</li></ol><p id="e5bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在安装部分介绍了<code class="fe ls lt lu lv b">static getDerivedStateFromProps</code>。但是，由于它在每次渲染之前被调用，所以它也存在于更新阶段。每当组件接收新的props或状态发生变化时，就会调用该方法。重要的是要注意，虽然这个方法已经被调用，但道具可能实际上并没有改变。也许一个父组件被更新，重新渲染，并把同样的道具传递给它的子组件。</p><p id="53a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，这种方法很少使用，因为它会导致性能问题，并且通常可以通过其他更好的解决方案实现相同的行为。</p><p id="dbdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">shouldComponentUpdate</code>的独特之处在于它返回一个布尔值。它查看道具和状态的当前变化，并确定组件是否应该更新。这不同于默认行为，默认行为在每次状态改变时重新呈现。<code class="fe ls lt lu lv b">shouldComponentUpdate</code>只作为性能优化而存在。不要使用这种方法来防止可能导致棘手错误的连续渲染，建议使用<code class="fe ls lt lu lv b">PureComponent</code>来执行属性和状态的浅层比较，以确定是否存在差异以及是否有必要重新渲染。</p><p id="1880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">getSnapshotBeforeUpdate</code>方法主要用于从DOM中捕获信息，这些信息在下一个生命周期方法被调用之前可能会改变。鼠标或滚动位置是可能需要捕捉的快速变化数据的一个很好的例子。这个方法在<code class="fe ls lt lu lv b">render</code>之后、React将内容从虚拟DOM粘贴到真实DOM之前被调用。该方法返回<code class="fe ls lt lu lv b">null</code>或信息的快照，这些信息将作为参数传递给<code class="fe ls lt lu lv b">componentDidUpdate</code>。</p><p id="2ace" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">componentDidUpdate</code>仅在更新后调用。该方法可以访问当前属性和状态，以及先前属性、先前状态和<code class="fe ls lt lu lv b">getSnapshotBeforeUpdate</code>中捕获的数据快照。<code class="fe ls lt lu lv b">componentDidUpdate</code>是进行网络请求(前提是道具有变化)或者更新第三方库的绝佳场所。<code class="fe ls lt lu lv b">setState()</code>可以在<code class="fe ls lt lu lv b">componentDidUpdate</code>内调用，但必须用条件括起来，以防无限循环。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="7de5" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">卸载</h1><p id="0826" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">在卸载或删除阶段，我们可以使用一种生命周期方法:<code class="fe ls lt lu lv b">componentWillUnmount</code>。这个方法在组件从DOM中移除之前被调用，并且它是任何时间间隔、网络请求或者在<code class="fe ls lt lu lv b">componentDidMount</code>中发起的订阅被清除的地方。将其映射回我们的stocks应用程序，我们将结束该时间间隔，以便我们的应用程序不会在组件被卸载后继续获取不必要的数据:</p><pre class="kg kh ki kj gt nd lv ne nf aw ng bi"><span id="4223" class="nh mf iq lv b gy ni nj l nk nl">componentWillUnmount() {<br/>    clearInterval(this.interval);<br/>}</span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="5202" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结束语</h1><p id="cb1e" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">虽然在大多数情况下没有必要用这些生命周期方法来覆盖组件的正常行为，但是当需要像订阅、数据获取和控制组件何时更新这样的操作时，选择几个是相当常用的。尽管如此，了解这些方法以及它们在组件生命周期中的位置对于更好地理解组件、DOM和我们在浏览器中看到的内容之间的关系是很重要的。</p><p id="5018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你好奇的话，还有一些其他很少使用的方法没有在这里介绍，在<a class="ae kv" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>中有详细介绍。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="73f4" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">参考</h1><div class="oa ob gp gr oc od"><a href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">状态和生命周期-反应</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">本页介绍了React组件中状态和生命周期的概念。你可以找到详细的组件API…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">reactjs.org</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://reactjs.org/docs/react-component.html" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">做出反应。成分-反应</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">该页面包含React组件类定义的详细API参考。它假设您熟悉…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">reactjs.org</p></div></div><div class="om l"><div class="os l oo op oq om or kp od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://www.tutorialspoint.com/reactjs/reactjs_component_life_cycle.htm" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">ReactJS -组件生命周期</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在这一章中，我们将讨论组件生命周期方法。componentWillMount在渲染之前执行，在两个…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">www.tutorialspoint.com</p></div></div><div class="om l"><div class="ot l oo op oq om or kp od"/></div></div></a></div></div></div>    
</body>
</html>