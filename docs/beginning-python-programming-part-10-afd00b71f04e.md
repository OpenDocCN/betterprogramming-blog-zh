# Python 编程入门—第 10 部分

> 原文：<https://betterprogramming.pub/beginning-python-programming-part-10-afd00b71f04e>

![](img/b2144ee2c4dadce95f45ee0e6f215fda.png)

照片由 [hue12 摄影](https://unsplash.com/@hue12_photography?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在上一篇文章中，我们讨论了与错误相关的所有内容，以帮助减少程序中的错误数量。

[](https://medium.com/better-programming/beginning-python-programming-part-8-45cad890e6b) [## Python 编程入门—第 9 部分

### 关于 Python 中的错误处理，您需要知道的一切

medium.com](https://medium.com/better-programming/beginning-python-programming-part-8-45cad890e6b) 

今天我们将更进一步，学习更多的技巧来帮助你减少代码中的错误数量。

如果你像我希望的那样一直在练习，你可能已经做了一个相当大的程序，吃了晚饭或者出去了，当你回来的时候，你感觉有点迷失在你的代码中。

编程入门的时候经常会迷路。如果你因为忘记了五分钟前写的东西而分心，你会感到沮丧。别担心。我们大多数人都经历过。我有好消息；随着时间的推移，它会变得更容易。需要多长时间取决于你练习了多少。

对我来说，我花了大约六个月的时间进行日常编码。从我醒来到睡觉，甚至周末，我都在写代码。不要误会我；这并不意味着我没有生活。我还是出去玩了。有时我会精疲力尽，不得不停止写代码一两天。即使在那时，我仍然在阅读文章，并试图在我所做的事情上做得更好。

所以继续练习。

# 代码结构

互联网上有大量的指南告诉你如何编写代码，也有关于如何格式化代码的文档，但是结构化代码总是留给开发人员去做。我不是说“让我们制定一个标准。”这将是太多的工作，但我们都同意，你的代码有一个通用的起点，这就是我将要讨论的。因为我们还没有介绍模块或文件导入，所以我可以先花点时间来做这件事。

## 进口

导入允许您导入位于其他文件或模块中的代码。例如，如果我有一个名为`models.py`的文件，里面有一个`Person`类，我需要在另一个名为`app.py`的文件中使用它，我不能只调用`Person`类，它就会工作；我得先导入它。那么我们如何做到这一点呢？

`import`是 Python 中一个独特的关键字，它告诉解释器去别处寻找稍后将在这个文件中被调用的代码。当解释器运行*这个*文件中的代码时，它是第一个被处理的东西。在这个例子中，我们导入整个`models`文件。我们只包括文件名；不是分机。

这允许我们使用出现在`models.py`中的每一个类或函数。这是可以的，但有时我们希望明确我们导入的内容。相反，我们可以使用`from ... import`。

这里我们有一个更好的 import 语句版本。我们只导入`Person`类。如果我们要有一个`Dog`类，我们需要一个单独的导入，或者我们可以在`Person`后面加上`Dog`，用逗号隔开。

您可以使用与您的代码无关的其他导入，您可能会对此感兴趣。例如，如果你打开一个 Python 控制台并输入`import this`，你会在控制台窗口中看到 *The Zen of Python，*作者 Tim Peters。

这个和这篇文章有关，所以我准备贴在下面。

> 蒂姆·彼得斯的《Python 之禅》
> 
> 漂亮总比难看好。
> 显性比隐性好。
> 简单胜于复杂。
> 复杂总比复杂好。
> 扁平比嵌套好。
> 稀不如密。
> 可读性很重要。特例不足以特殊到打破规则。
> 虽然实用性胜过纯粹性。错误永远不会无声无息地过去。
> 除非明确消音。
> 面对暧昧，拒绝猜测的诱惑。应该有一种——最好只有一种——显而易见的方法来做这件事。除非你是荷兰人，否则这种方式一开始可能并不明显。现在总比没有好。
> 虽然永远也不会比现在*好。如果实现很难解释，这是个坏主意。如果实现容易解释，这可能是个好主意。名称空间是一个非常棒的主意——让我们多做一些吧！

通读几遍，并在编写代码时尽量记住这一点。

另一个有趣的是`import antigravity`。

## 模块

模块只是包含相关代码的文件夹，比如助手、服务甚至模型。

当我打这封信时，我意识到我从未真正解释过什么是模型。模型主要是程序运行时用来存储数据的对象。一个人、一只狗、一只猫或一个地方可以被认为是一个模型。这些模型允许您将特定对象的数据作为一个值传递，而不是多个值。

回到模块。模块和文件夹在结构上的区别在于，模块内部包含一个名为`__init__.py`的文件。该文件可以是空白的，或者它可以为任何导入该模块的人提供初始配置信息。

```
my_project/
    models/
        __init__.py
        person.py
        dog.py
        cat.py
    app.py
```

使用上面的文件夹结构，我们可以使用以下语法导入 person 类:

我们可以调整`__init__.py`来包含导入语句，以便在其他地方更容易。

因为这些文件属于一个模块，我们可以使用`.`来表示当前的文件夹，而不用输入`models`。这对于小型项目来说没问题，但是在大型项目中，知道从哪里导入可能更有意义，特别是如果您有嵌套模块的话。

现在，当我们需要导入 *models* 文件夹中的任何类时，它变得更加易于管理。

看到多简单了吗？`models`因为`__init__.py`知道不同的类，我们可以直接导入这些类，而不必引用每个类所在的文件。

# 文件结构

好了，知道了导入之后，让我们从代码结构开始，更确切地说是文件结构。

当编写程序时，我们需要确保我们的代码是可读的。我不知道你，但我倾向于从上到下，从左到右阅读。为什么我们的代码不能这样做呢？

当我只能使用一个 Python 文件时，比如当我正在编写一个脚本时，我希望它遵循以下模式:

```
[import statements][global variables/constants][class declarations][helper/one shot functions]entry point
```

我用方括号是因为它们是可选的；你可能不总是需要进口或任何其他项目。您的代码应该从某个地方开始，默认情况下，这是在顶级范围。这就是我们的`print`语句奏效的原因。

当首先需要调用的是一个函数时，标准惯例是使用下面的语法来启动程序。

关于这方面的更多信息，请查看这篇关于堆栈溢出的[好文章](https://stackoverflow.com/a/419185)。

我以这种特殊的顺序安排版面，因为这样最有意义。

1.  导入应该总是在你需要它们的任何范围的顶端；通常，这是文件的顶部。
2.  接下来应该是全局变量和常量。打开代码，在顶部看到所有的固定变量总是好的；当他们中的一个需要改变的时候，它会减少以后的搜索。
3.  接下来是类声明，因为在添加更多代码时，它们可能需要新的字段或引用。
4.  一次性函数包含在上面的帮助函数中，但它们通常位于帮助函数之上，它们之所以得名是因为它们在程序运行时只被调用一次。这是用于环境变量的状态配置，或者可能设置程序来处理与另一个源的认证。
5.  助手函数是你会反复使用的代码，比如生成一个随机数或者对一系列数字求和。
6.  入口点是代码开始的地方。我们把它放在底部，因为在以前的 C/C++时代，你需要把所有的声明都放在顶部。这只是出于习惯，你会经常看到这种情况。

![](img/ee4ab8a20b6d1bb7ea9a8275f3345e77.png)

格伦·卡斯滕斯-彼得斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

# 原则

你的项目应该是有意义的，就像你把东西放在整个房子的房间里一样。在编程中，我们没有沙发、烤箱或床，但我们有模型、服务、视图、助手、API 和应用程序。

Django 在分离功能方面做得很好，迫使你使用合适的项目结构。

在我们进入项目结构之前，我想介绍一些原则。

首先，*“如果它没坏，就不要修理它。”这应该是一个非常简单的原则。如果你写的代码有效，即使你不知道它是如何工作的，也不要去管它。如果你试图修理它，你很可能会把它弄坏，而且不知道如何把它恢复原样。*

*信息隐藏*。这仅仅是确保可访问性(由访问控制定义)在您编写的每段代码上都尽可能地受到限制。如果没有其他人应该看到`my_super_secret_function()`，就不要公开。前面加个`_`，别人就知道不用了。如果您有构建 URL 的网络代码，让网络类创建 URL；在 networking 类中将该方法设置为 private。

*松耦合*。这听起来很抽象，其实不然。当一个类使用另一个类的一部分时，只从这个类中获取你需要的东西；不要在原始类中实例化那个类。否则，你会得到一个强引用。松散耦合只是保持类间低依赖性的结果。使用字典、列表或集合来帮助减少每个班级之间的相互了解。

# 项目结构

你的项目结构会根据你需要做什么而改变。有时您只需要一个文件，但是当您需要更多文件时，您如何跟踪所有文件呢？

这是我的典型文件结构，适用于大中型纯 Python 应用程序。

```
my_project/
  app/
    __init__.py
    main.py
    helper1.py
    helper2.pymodels/
    __init__.py
    class1.py
    class2.py
    class3.pyservices/
    __init__.py
    auth_service.py
    database_service.py
    network_service.pytests/
    __init__.py
    classes_test.py
    app_test.py
    services_test.pyvenv/
    ..app.py
  config.py
  requirements.txt
  test_requirements.txt
  .env
  .secrets
```

在这个项目中，我们有一个`app`模块，它包含了我们应用程序的所有业务逻辑；也就是将数据从一个地方移动和转换到另一个地方的代码。

可以被称为任何东西，但我只是让它容易理解。`main.py`不是我们应用程序的入口点，但它是我们程序开始工作的地方。这些`helper#.py`文件可能并不必要，但是我们在这里使用它们只是因为它是一个例子。

`models`包含我们将在整个应用程序中使用的所有模型(即类)。

`services`包括我们所有的后台代码。这种代码可能写起来并不有趣，但我们需要多次使用它，而且它太大了，无法在一个文件下工作。在这里，我们有用于与服务器进行身份验证、连接到数据库并对数据库执行 CRUD 操作(创建、读取、更新、删除)的代码，以及网络代码，因此我们不必继续编写代码来确保得到响应，如果没有得到响应就记录错误。

`tests`包含我们所有的测试。测试文件可以是基于模块的，也可以是基于文件的，这取决于需要，如果需要的话，我们可以将它们分解到它们的模块中。

`venv`是我们没有涉及到的，但这是针对*虚拟环境*的，我将在后面的教程中介绍。当您使用它时，它会自动为您创建，现在可以安全地忽略它。

`app.py`是我们用来启动程序的文件。这通常包含一个导入，导入让仓鼠在轮子上运行的主文件。

`config.py`是一个`Config`类，包含我们应用程序的默认运行配置。这不是必需的，但却是一个不错的选择。

`requirements.txt`和`test_requirements.txt`未涉及，但它们提供了运行该程序所需的外部模块及其版本号的列表。我喜欢把这些分开，所以我不在我的产品代码中包含任何测试模块。

`.env`是*nix 系统上的一个隐藏文件，我们会创建它来存储环境变量。它无论如何都不安全，但是我们可以稍后解析它，并根据需要提取值。

`.secrets`与`.env`相同，除了它可以用来存储用户名和密码。我强烈建议您只在部署到 docker/podman 容器时使用类似的东西，这样您就可以在文件被读入内存后删除它。你还需要确保你的程序有一个运行循环(像 web 服务器一样)，这样它就不会结束运行。一旦出现这种情况，所有这些变量都会从内存中释放出来。

![](img/f3293df0e2f6c2ba7d21f0b9e7de17d8.png)

照片由[马克·达弗尔](https://unsplash.com/@2mduffel?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 编码指南

Python 的开发者已经创建了一些标准，称为 PEPs。最著名的是 PEP 8 风格指南。这是一份很长的文件，但很有帮助。

一些亮点:

*   行长度不应超过 80 个字符。一些格式化程序(如 Black)认为这已经过时，建议使用更宽松的 88 个字符。
*   如果你不得不超过 80 个字符，总是硬包装在 120 个字符。
*   需要多行的冗长公式建议在运算符前断开(+-*/)。
*   在顶级函数和类之间使用两行空行，在类中的方法之间使用一行空行，在函数中尽量少用空行来表示逻辑部分。
*   从不同模块的导入应该总是在不同的行上。
*   应避免通配符输入(`from models import *`)。不清楚进口的是什么。

有很多东西要看，所以我强烈建议你读一读。

另一个要看的文档是 [PEP 257](https://www.python.org/dev/peps/pep-0257/) ，它涵盖了 docstrings。这也是强烈推荐的，因为 docstring 提供了每个函数的功能描述以及它在支持 docstring 的编辑器中返回的内容(PyCharm，VS Code)，从而使您的工作变得简单。

## 使用描述性变量名称

不要像人们在 C/C++中那样，试图用一个字母的变量来混淆代码。这些年来，`i`、`j`、`k`、`l`、`m`、`n`、`t`、`x`、`y`和`z`有太多的值，它们可以代表任何东西。告诉我你有一个程序可以计算一段时间内以给定速度行驶的距离，除了`j`、`k,`和`m`什么都没说；这很好，高级开发人员，但是什么是`k`？*高级 dev 看代码一分钟……*啊，`k`是速度变量。

真的吗？谁会知道`k`是速度变量，而不用考虑高级开发人员用来编写程序的公式呢？重点不就是我们应该能够立即看到一段代码并说“是的，这是速度设置的地方；我可以在这里添加一个五分钟的休息时间来模拟一次停顿，并在高级开发人员告诉我`k`是什么的相同时间内完成。”

关于单字母变量的一点历史:开发人员使用单字母变量的原因是自动完成功能不存在，而且开发人员不想尽可能多地输入。它还确保程序员不会拼错变量名。这相当于在 21 世纪初用手机发短信。我们用了 *lol，c u l8r，< 3 u，*和 *ttyl* 。为了缩短我们的单词，我们只需要按下按钮 20 次，而不是 100 次，如果我们真的拼出了完整的单词。时代变了；几乎每一种主流编程语言都有自动完成功能。

有时候还可以；例如，if 语句中的临时变量，您仍然可以在离您键入的地方五行之外看到声明。这就像在 iPhone 上使用`lol`。一切都好。但是当你在一个类或结构中使用`a`作为变量时，那就有问题了。当我看到有人在智能手机上输入`c u l8r`时，我会摇头。*但是你不是要换键盘类型才能打 8 键吗？似乎比它值得做的还要多。同样，对于全局单字母变量，您必须弄清楚它代表什么，然后才能在八个月后的更改中使用它；似乎比它的价值更多的工作。*

如果你忘记了我所说的一切，只要记住总是使用描述性变量和常数。我一直在没有自动完成的情况下从头开始编写这些教程，键入一些很长的变量名，很少使用复制粘贴。使用自动完成功能给变量起一个描述性的名字*应该不成问题。*

# 摘要

今天，我们讨论了一些需要记住的原则，从其他文件和模块引入代码的 import 语句，基本文件和项目结构，以及 PEP 标准，为您在代码中应该实现的目标提供了路线图。

我强烈建议你回顾一下之前的例子，尽量把它们做的漂亮一点。我将是第一个告诉你，使你的代码干净可能是困难的。我的代码远没有我所希望的整洁，但是它是有效的。这是你做得越多越擅长的技能之一。

## 建议扫描

我说扫描不是阅读；读书是理想的，但一开始你不会记住一半。挑出你认同的重要部分，并从那里开始。

[](https://www.python.org/dev/peps/pep-0008) [## PEP 8 风格的 Python 代码指南

### Python 编程语言的官方主页

www.python.org](https://www.python.org/dev/peps/pep-0008) 

和

[](https://www.python.org/dev/peps/pep-0257/) [## PEP 257 -文档字符串约定

### Python 编程语言的官方主页

www.python.org](https://www.python.org/dev/peps/pep-0257/) 

还有其他的 pep，但是如果你想看的话，我会让你自己决定。

# 下一步是什么？

根据我的 Swift 文章，我们涵盖了异步。我认为在开始异步编程之前，我们还有更重要的事情要做。虽然一次做多件事很有趣，但我认为如果我们先讨论虚拟环境和 PyPI 会更好。

虽然我提到我不会讨论外部模块，但我并没有说我不会讨论如何获取它们，所以虚拟环境和获取 Python 包将在下一篇文章中讨论。

[](https://medium.com/better-programming/beginning-python-programming-part-11-1dc915b4f0fd) [## Python 编程入门—第 11 部分

### 使用模块和虚拟环境

medium.com](https://medium.com/better-programming/beginning-python-programming-part-11-1dc915b4f0fd)