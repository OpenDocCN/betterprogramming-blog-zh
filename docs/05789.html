<html>
<head>
<title>Adding a Closure as a Target to a UIButton and Other Controls in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将闭包作为目标添加到Swift中的UIButton和其他控件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adding-a-closure-as-a-target-to-uibutton-and-other-controls-in-swift-2c5e66029817?source=collection_archive---------17-----------------------#2020-08-05">https://betterprogramming.pub/adding-a-closure-as-a-target-to-uibutton-and-other-controls-in-swift-2c5e66029817?source=collection_archive---------17-----------------------#2020-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f5f9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个经常被请求的API终于到来了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57b9a6ca3984eb212e687674c2e6fb6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pDXPiqSkFmaACTwJ"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@enginakyurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> engin akyurt </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="338e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目标动作模式与用户界面控件结合使用，作为对用户事件的回调。每当在目标上按下一个按钮，它的动作就会被调用。事实上，该方法的定义并不接近控件定义，这有时被视为一个缺点，也是许多美国开发人员在Stack Overflow等网站上搜索基于闭包的解决方案的原因。</p><p id="1abb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS 14 SDK引入了新的API，允许我们将UIControls与闭包结合使用。常见的<code class="fe lv lw lx ly b">UIControl</code>元素有<code class="fe lv lw lx ly b">UIButton</code>、<code class="fe lv lw lx ly b">UISegmentedControl</code>和<code class="fe lv lw lx ly b">UISwitch</code>，但是还有很多都是从<code class="fe lv lw lx ly b">UIControl</code>对象继承而来的。所有这些界面元素现在都可以与这个新的API一起使用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9f9c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用带有闭包回调的UIControl</h1><p id="03a4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您很可能熟悉下面这段代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="eea5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次点击按钮时都会调用<code class="fe lv lw lx ly b">buttonTapped(_:)</code>方法。</p><p id="066d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的代码现在可以写成如下形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使操作接近控件定义，从而提高代码的可发现性。</p><h2 id="648f" class="nf mh it bd mi ng nh dn mm ni nj dp mq li nk nl ms lm nm nn mu lq no np mw nq bi translated">获取对控件发送方的引用</h2><p id="0c58" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">上面这段代码的一个不同之处是我们的方法引用了发送者。在某些情况下，当您想知道哪个控件调用了链接方法时，这可能会很方便。</p><p id="0a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了新的基于闭包的API，您可以使用<code class="fe lv lw lx ly b">action</code>参数来访问发送者。例如，当您想要从文本字段中读出文本时:</p><pre class="kj kk kl km gt nr ly ns nt aw nu bi"><span id="ec9f" class="nf mh it ly b gy nv nw l nx ny">let textField = UITextField()<br/>textField.addAction(UIAction(title: "", handler: { action in<br/>    let textField = action.sender as! UITextField<br/>    print("Text is \(textField.text)")<br/>}), for: .editingChanged)</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="967f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我应该总是使用新的闭包API吗？</h1><p id="af5e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在到处使用闭包可能很有诱惑力。但是，控制动作很容易在代码中增长，从而降低代码的可读性。在这些情况下，您可能希望回到旧的目标-动作模式，这种模式允许您使用单独的方法。</p><p id="8335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您的控制操作需要多行代码时，Swift中的方法更容易阅读。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3b90" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="bbda" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">iOS 14 SDK中新的基于闭包的API是一个受欢迎的变化，但应该谨慎使用。使用许多闭包很容易使你的代码可读性更差，只有在控件回调逻辑可以用几行代码编写的情况下才应该使用。否则，最好使用老式的目标-行动模式。</p><p id="a30b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>