# 不要重复自己…等真的？

> 原文：<https://betterprogramming.pub/dont-repeat-yourself-really-9e5c9f0ba154>

## 代码复制可以说是最糟糕的实践。然而，有时候编写稳定的代码库是非常必要的

![](img/81450b64ecc5b3eadc555f28980f160f.png)

[自由股票](https://unsplash.com/@freestocks?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

人们应该尽可能多地分解代码，因为大多数时候，复制是人为错误的结果:复制和粘贴，对代码库一无所知…这是一种瘟疫，必须根除，没有什么可补充的。

但这不是它的唯一形式，确实有这样的情况，两个极其相似的模块比组合成一个模块更好。

这被称为意外复制:除了非常相似的实现之外，几个彼此无关的模块。

例如:假设你写了一个函数来计算你的智能手机的启动时间，另一个函数来计算你的微波炉的启动时间。

将两者放在一起很有诱惑力，但这是一个非常糟糕的想法，因为它们有彼此独立开发的风险。

如果你将它们排除在外，那么当你更换智能手机的一部分时，该算法将不再有效。如果你改变它，它将再次适用于智能手机，但不再适用于微波炉。

这被称为回归:当两个模块的耦合度超过它们应有的程度时，这是一个经典问题。

*这就是我们如何点燃我们的代码库。*

# 智能分解

> 所以，要么我们重复，要么我们创造了太强的依赖性，太棒了…

在所有可能的情况下，你都不应该这样做。好的架构和对设计模式的掌握应该足以让你摆脱困境。但是说起来容易做起来难。

最简单的解决方案仍然是智能分解，也就是说，在对两个模块进行分组之前，总是要询问它们是否意外重复。

> 我们该怎么做，夏洛克？

这并不容易，因为它需要对代码库和需求有很好的了解，但是有一个重复出现的现象。

重复的模块越靠近[业务领域](https://en.wikipedia.org/wiki/Business_rule)(低级)，越有可能是偶然重复。

这是因为业务规则本质上是独特的，并且独立于其他规则。如果一个业务规则发生变化，另一个不会受到影响。

# 中间

> 好，所以我们离领域越近，我们的因素就越少，我明白了。

呃，不，不是真的。

仅仅因为有偶然的重复，并不意味着你必须立即编写大块的代码。

恰恰相反，因为任何低级模块都依赖于高级模块，而高级模块本身也需要考虑在内。

下面是一个例子:这两个函数将一个重量和一个尺寸作为参数，验证它们，从数据库中获得一个系数，进行计算，然后返回结果。

唯一的区别在于所进行的计算和恢复系数(系数 b 和系数 f)的水平。

[https://gist . github . com/talhakhalid 101/7 Fe 485 b 591d 2 b 53697 b 9 e 89866004882](https://gist.github.com/TalhaKhalid101/7fe485b591d2b53697b9e89866004882)

你会注意到这两个函数在结构和算法上都极其相似。但这些都是商业规则，那么，偶然重复与否？

是也不是，因为即使将这两个功能合二为一是一个非常糟糕的想法(独立进化，诸如此类)，单个步骤也可以被排除。

[https://gist . github . com/talhakhalid 101/4fc 8754 c 23 a1 ba 6 f 97 a 0 f 6 EC 3 e 73 e 532](https://gist.github.com/TalhaKhalid101/4fc8754c23a1ba6f97a0f6ec3e73e532)

我将每个相同的步骤封装到它自己的顶级函数中，但并不是没有确保它确实是一个真正的副本。

为了验证，身高和体重永远不可能是负数，无论在什么情况下，这都是不可能的，所以因式分解是有效的。

这同样适用于转换。科学不会为了好玩而改变拇指的大小。

然而计算是不同的，那么为什么要把它们放在函数中呢？两件事:

*   给它们起个酷名字。
*   通过预防，如果其他地方需要的话，因为科学不会在一夜之间改变。

最后，让你冒冷汗的部分:请求。

同样的结构，同样的返回值，只是换表的名字。我们陷入了僵局，因为:

*   如果我们分解，如果基础图改变了，修复代码会更容易，但这打破了独立进化的思想。
*   如果进行复制，没有回归的风险，但是如果数据库图表发生变化，您将不得不在几个不同的地方修改代码。

就这一次，我选择了复制。但是这个例子给了我们两个非常重要的教训:

*   **解耦你的组件**，这样你的程序不需要知道数据库模式就能运行。不再上瘾=不再有问题。
*   **了解业务领域内部**了解业务领域外部**。正是它给出了程序的背景，自然地，它将引导你做出好的决定(关于验证和转换)。**