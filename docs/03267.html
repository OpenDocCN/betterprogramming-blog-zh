<html>
<head>
<title>Introduction to HTML Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTML画布介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introduction-to-html-canvas-1dd24037c13b?source=collection_archive---------12-----------------------#2020-01-30">https://betterprogramming.pub/introduction-to-html-canvas-1dd24037c13b?source=collection_archive---------12-----------------------#2020-01-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f66e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">开始使用画布</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/36334de771df0c447da18018553965c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vw0HE0znwPhsUpLU"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@kellitungay?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kelli Tungay </a>拍摄的照片</p></figure><p id="4b3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显示图形的一种方法是在HTML中使用<code class="fe lv lw lx ly b">img</code>元素。但是，它只显示带有固定URL的静态图像。为了绘制和显示动态图形，我们可以使用HTML <code class="fe lv lw lx ly b">canvas</code>元素。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="53b5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建新画布</h1><p id="f4ee" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">创建一个新的<code class="fe lv lw lx ly b">canvas</code>元素:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c9c6" class="nh mh it ly b gy ni nj l nk nl">&lt;canvas style='width: 200px; height: 200px'&gt;<br/>&lt;/canvas&gt;</span></pre><p id="1298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它看起来像是<code class="fe lv lw lx ly b">img</code>元素，但是它没有<code class="fe lv lw lx ly b">src</code>或<code class="fe lv lw lx ly b">alt</code>属性。这是因为它不是一个固定的图像元素。</p><p id="d00b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以像上面一样使用CSS样式，使用<code class="fe lv lw lx ly b">width</code>、<code class="fe lv lw lx ly b">height</code>、<code class="fe lv lw lx ly b">margin</code>、<code class="fe lv lw lx ly b">border</code>、<code class="fe lv lw lx ly b">padding</code>等等。</p><h2 id="54c1" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">后备内容</h2><p id="79b7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于不支持canvas的浏览器，我们可以通过在里面放一些东西来提供后备内容。例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d79e" class="nh mh it ly b gy ni nj l nk nl">&lt;canvas style='widthL 200px; height: 200px'&gt;<br/>  Your browser doesn't support canvas.<br/>&lt;/canvas&gt;</span></pre><p id="9464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">画布元素需要结束标记<code class="fe lv lw lx ly b">&lt;/canvas&gt;</code>。如果不存在，文档的其余部分将被视为后备内容。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="aa1b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">渲染上下文</h1><p id="0725" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">canvas元素创建一个固定大小的绘图表面，该表面公开一个或多个呈现上下文—创建和操作所绘制内容的实体。</p><p id="1a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最基本的是2D渲染上下文。还有一个用于WebGL和OpenGL ES的3D渲染环境。</p><p id="7de7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">画布最初是空白的。我们必须访问渲染上下文，并在其上绘制以显示某些内容。为此，我们可以使用<code class="fe lv lw lx ly b">canvas</code>元素的<code class="fe lv lw lx ly b">getContext()</code>方法。对于2D图形，我们将<code class="fe lv lw lx ly b">'2d'</code>指定到<code class="fe lv lw lx ly b">getContext()</code>方法中。</p><p id="a967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们按如下方式访问画布渲染上下文:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="802d" class="nh mh it ly b gy ni nj l nk nl">const canvas = document.querySelector('canvas');<br/>const ctx = canvas.getContext('2d');</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ba9c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">检查支持</h1><p id="400f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以通过检查<code class="fe lv lw lx ly b">getContext</code>方法是否存在来检查对<code class="fe lv lw lx ly b">canvas</code>元素的支持，如下所示:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d051" class="nh mh it ly b gy ni nj l nk nl">const canvas = document.querySelector('canvas');<br/>if (canvas.getContext) {<br/>  const ctx = canvas.getContext('2d');<br/>}</span></pre><p id="7104" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于几乎所有的现代浏览器都支持<code class="fe lv lw lx ly b">canvas</code>元素，这应该不是什么大问题。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7316" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">绝对码</h1><p id="b2a1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">把它们放在一起，我们就有了下面的代码。HTML:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4fc0" class="nh mh it ly b gy ni nj l nk nl">&lt;canvas&gt;<br/>  Your browser doesn't support canvas.<br/>&lt;/canvas&gt;</span></pre><p id="fd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以添加下面的CSS:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6c2e" class="nh mh it ly b gy ni nj l nk nl">canvas {<br/>  width: 200px;<br/>  height: 200px;<br/>  border: 1px solid black;<br/>}</span></pre><p id="3153" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有这个JavaScript代码:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9051" class="nh mh it ly b gy ni nj l nk nl">const canvas = document.querySelector('canvas');<br/>if (canvas.getContext) {<br/>  const ctx = canvas.getContext('2d');<br/>}</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9658" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一幅简单的画</h1><p id="2330" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这幅简单的画是由基本的2D形状组成的，比如长方形。我们用下面的代码创建了三个不同背景颜色的矩形:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7382" class="nh mh it ly b gy ni nj l nk nl">const canvas = document.querySelector('canvas');<br/>const ctx = canvas.getContext('2d');<br/>ctx.fillStyle = 'rgb(100, 0, 0)';<br/>ctx.fillRect(5, 5, 40, 40);</span><span id="3be3" class="nh mh it ly b gy nx nj l nk nl">ctx.fillStyle = 'rgba(0, 20, 100, 0.5)';<br/>ctx.fillRect(10, 10, 50, 50);</span><span id="381d" class="nh mh it ly b gy nx nj l nk nl">ctx.fillStyle = 'rgba(20, 0, 200)';<br/>ctx.fillRect(25, 25, 95, 90);</span></pre><p id="c34c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的工作原理如下。在我们获得渲染上下文之后，我们用属性<code class="fe lv lw lx ly b">fillStyle</code>设置形状的背景颜色，方法是用颜色值为它设置一个字符串。然后我们用左上角的坐标(5，5)和右下角的坐标(40，40)创建一个矩形。</p><p id="ed77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前两个参数是左上角的x和y坐标，后两个参数是宽度和高度。</p><p id="69c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个矩形是:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0589" class="nh mh it ly b gy ni nj l nk nl">ctx.fillStyle = 'rgb(100, 0, 0)';<br/>ctx.fillRect(5, 5, 40, 40);</span></pre><p id="a736" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">颜色值<code class="fe lv lw lx ly b">rgb(100, 0, 0)</code>代表褐色。</p><p id="ec26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们也有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c71d" class="nh mh it ly b gy ni nj l nk nl">ctx.fillStyle = 'rgba(0, 20, 100, 0.5)';<br/>ctx.fillRect(10, 10, 50, 50);</span></pre><p id="7916" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个矩形比第一个矩形靠右下方。它是灰色的。</p><p id="599d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f2ec" class="nh mh it ly b gy ni nj l nk nl">ctx.fillStyle = 'rgba(20, 0, 200)';<br/>ctx.fillRect(25, 25, 95, 90);</span></pre><p id="1e86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个也在右边，比第二个蓝色的矩形低。</p><p id="48db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/4466759425f158ff2dcb8ddff6269cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*h1_wftWz8m5KOZONR6iuUQ.png"/></div></figure><p id="609a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦加载了带有canvas元素的页面，绘图就完成了。坐标可以在矩形的维度之外或之内。如果它超过了维度，我们就看不到画出来的东西了。</p><p id="0b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">画布对于绘制静态或动态图形都很有用。我们可以在HTML中创建一个canvas元素，然后我们可以在JavaScript中获得canvas元素，并获得渲染上下文，以便我们可以在其上绘制项目。</p><p id="4e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在上面画出基本的形状。我们可以用上下文的<code class="fe lv lw lx ly b">fillStyle</code>属性改变背景的颜色，然后可以调用它上面的<code class="fe lv lw lx ly b">fillRect</code>来绘制一个矩形。</p><p id="545b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有四个参数:前两个参数左上角的x，y坐标，最后两个元素右下角的x，y坐标。</p></div></div>    
</body>
</html>