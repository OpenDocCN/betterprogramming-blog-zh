<html>
<head>
<title>How To Use LocalStorage to Store Data in the Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用LocalStorage在浏览器中存储数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/use-localstorage-to-store-data-on-the-browser-d10f8363dda5?source=collection_archive---------12-----------------------#2020-01-14">https://betterprogramming.pub/use-localstorage-to-store-data-on-the-browser-d10f8363dda5?source=collection_archive---------12-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c25" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在浏览器中存储数据变得更加容易</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/59f025b11a166192f44fa3918b158f3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*M0XShSGkdYo9QChE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丘特尔斯纳普</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="ea14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在浏览器中存储数据是我们经常为web应用程序做的事情。通常，我们需要在浏览器上存储一些特定于用户的临时数据。我们可以利用浏览器的本地存储功能做到这一点。</p><p id="a2e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本地存储，我们在浏览器上将数据存储为字符串。这是一个基于键值的存储介质，允许我们通过键获取数据，也可以用键作为标识符来设置值。所有数据都存储为字符串。如果一段数据不是字符串，那么在存储之前它会被转换成字符串。</p><p id="7b98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦它们被保存，只要我们不删除数据，它们就在那里。我们可以通过数据的键删除数据，也可以同时删除所有数据。在同一个域上托管的每个应用程序都可以访问数据，因此我们可以在同一个域下托管多个web应用程序，并且仍然可以在所有应用程序中获得相同的数据。</p><p id="507e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们可以轻松地将应用模块化为更小的应用，只要所有应用都托管在同一个域中，我们就不会有浏览器数据访问的问题。</p><p id="548b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与cookies不同，本地存储数据没有过期时间，所以如果我们不删除它，它仍然会在那里。</p><p id="4b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe lv lw lx ly b">localStorage</code>对象访问浏览器的本地存储。如果我们不使用<code class="fe lv lw lx ly b">http</code>协议访问<code class="fe lv lw lx ly b">localStorage</code>，它将抛出一个<code class="fe lv lw lx ly b">SecurityError</code>。这意味着任何以像<code class="fe lv lw lx ly b">file:</code>或<code class="fe lv lw lx ly b">data:</code>这样的协议开头的URL都会失败，并显示这个错误。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5d2c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">保存数据</h1><p id="f6e1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">setItem</code>方法将数据保存到浏览器的本地存储器中。这需要两个参数。第一个参数是带有数据键的字符串，第二个参数是带有我们传递给第一个参数的相应键的值的字符串。</p><p id="4458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果存储空间已满，它将引发异常。Safari在私人模式下将存储配额设置为零字节，但它允许在私人模式下使用单独的数据容器进行存储。这意味着我们应该从<code class="fe lv lw lx ly b">setItem</code>中捕捉异常。</p><p id="4f97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6b75" class="nh mh it ly b gy ni nj l nk nl">localStorage.setItem('foo', 'bar');</span></pre><p id="8ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后一旦我们运行它，我们会在Chrome的本地存储部分的应用程序标签中看到这个条目。</p><p id="4890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以写…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e280" class="nh mh it ly b gy ni nj l nk nl">localStorage.foo = 'bar';</span></pre><p id="f292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…保存数据。</p><p id="5c0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">括号符号也适用于为本地存储赋值。例如，我们可以写…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="602d" class="nh mh it ly b gy ni nj l nk nl">localStorage['foo'] = 'bar';</span></pre><p id="99b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…用键<code class="fe lv lw lx ly b">'foo'</code>和值<code class="fe lv lw lx ly b">'bar'</code>设置本地存储项目。</p><p id="df00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不应该使用点或括号符号来代替<code class="fe lv lw lx ly b">setItem</code>。我们不想无意中通过设置一个字符串来覆盖像<code class="fe lv lw lx ly b">setItem</code>方法这样的东西，比如试图通过使用<code class="fe lv lw lx ly b">setItem</code>作为键来保存数据。</p><h2 id="062c" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">保存对象数据</h2><p id="6b5e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们试图保存对象，我们将得到<code class="fe lv lw lx ly b">[object Object]</code>作为值。为了实际保存内容，我们必须使用<code class="fe lv lw lx ly b">JSON.stringify</code>方法。例如，不写…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="93f7" class="nh mh it ly b gy ni nj l nk nl">localStorage.setItem('foo', {foo: 'bar'});</span></pre><p id="ba25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们写道:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f9f0" class="nh mh it ly b gy ni nj l nk nl">localStorage.setItem('foo', JSON.stringify({foo: 'bar'}));</span></pre><p id="41aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们用<code class="fe lv lw lx ly b">foo</code>键得到<code class="fe lv lw lx ly b">{“foo”:”bar”}</code>作为条目的值。</p><h2 id="5c52" class="nh mh it bd mi nm nn dn mm no np dp mq li nq nr ms lm ns nt mu lq nu nv mw nw bi translated">重复呼叫</h2><p id="9790" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们用同一个键重复调用<code class="fe lv lw lx ly b">setItem</code>方法，那么这个键的现有值将被覆盖。例如，如果我们写…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="53d0" class="nh mh it ly b gy ni nj l nk nl">localStorage.setItem('foo', 1);<br/>localStorage.setItem('foo', 2);</span></pre><p id="b611" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后我们得到<code class="fe lv lw lx ly b">2</code>作为键为<code class="fe lv lw lx ly b">foo</code>的条目的值，因为它是保存的最后一个值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/c161f4aa54837026ab1f61e9323254d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-IUTvtVRFQ4YY1Yd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@erdaest?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Erda Estremera </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a752" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">获取数据</h1><p id="82dc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">getItem</code>方法获取数据，或者像其他对象一样使用点符号获取数据。<code class="fe lv lw lx ly b">getItem</code>接受一个参数——我们想要从中获取值的键的字符串。如果为给定的键设置了值，它将返回一个字符串，如果没有设置，则返回<code class="fe lv lw lx ly b">null</code>。</p><p id="2c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b3aa" class="nh mh it ly b gy ni nj l nk nl">localStorage.getItem('foo');</span></pre><p id="8626" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果我们运行上一节中的<code class="fe lv lw lx ly b">setItem</code>代码，就会得到值<code class="fe lv lw lx ly b">'bar'</code>。</p><p id="b6c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="81d4" class="nh mh it ly b gy ni nj l nk nl">localStorage.foo;</span></pre><p id="7a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="708c" class="nh mh it ly b gy ni nj l nk nl">localStorage['foo'];</span></pre><p id="8888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">括号符号对于访问带有相应键的值很方便，这些键不是有效的对象属性名称。</p><p id="c60d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个<code class="fe lv lw lx ly b">key</code>方法来获取本地存储中给定位置号的键的名称。它有一个参数，是一个零或更大的整数。第一个位置编号为<code class="fe lv lw lx ly b">0</code>。例如，如果我们有以下代码…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f565" class="nh mh it ly b gy ni nj l nk nl">localStorage.key(1)</span></pre><p id="0e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…然后我们获得本地存储中第二个条目的键名。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7bde" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">删除本地存储中的单个条目</h1><p id="7301" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">removeItem</code>方法从本地存储器中删除一个给定的键。它接受一个参数，这个参数是一个带有条目键名的字符串。</p><p id="518d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们想删除带有键<code class="fe lv lw lx ly b">'foo'</code>的条目，那么我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fa5c" class="nh mh it ly b gy ni nj l nk nl">loocalStorage.removeItem('foo');</span></pre><p id="2311" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码将删除键名为<code class="fe lv lw lx ly b">'foo'</code>的本地存储条目。</p><p id="db25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以使用<code class="fe lv lw lx ly b">delete</code>操作符删除给定键名的项目。例如，我们可以通过运行以下命令删除带有关键字<code class="fe lv lw lx ly b">'foo'</code>的本地存储条目:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a09f" class="nh mh it ly b gy ni nj l nk nl">delete localStorage.foo;</span></pre><p id="1414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用括号符号来做同样的事情，所以我们可以写…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8f3e" class="nh mh it ly b gy ni nj l nk nl">delete localStorage['foo'];</span></pre><p id="764b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…删除相同的条目。</p><p id="c828" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们不应该使用点或括号符号来代替<code class="fe lv lw lx ly b">setItem</code>。我们不想无意中通过设置一个字符串来覆盖像<code class="fe lv lw lx ly b">setItem</code>方法这样的东西，比如试图通过使用<code class="fe lv lw lx ly b">setItem</code>作为键来保存数据。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="735f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">清除本地存储</h1><p id="c44e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">clear()</code>方法清除本地存储器中的所有条目。</p><p id="a0b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="deb9" class="nh mh it ly b gy ni nj l nk nl">localStorage.clear()</span></pre><p id="fdba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…清除所有条目。一旦我们运行这个方法，我们不应该在浏览器的应用程序选项卡的本地存储部分看到任何东西。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9c39" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">浏览器兼容性</h1><p id="e517" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">几乎所有的现代浏览器都有本地存储，所以在任何地方使用都是安全的。甚至Internet Explorer从版本8开始就支持它，所以它不是一项新技术。对于持久数据来说，它比浏览器端的cookies好得多，因为它不会过期，并且有操作数据的方法。</p><p id="f760" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了浏览器上的本地存储，在客户端存储数据比以往任何时候都更容易。我们可以通过调用上面概述的方法做很多事情。保存的内容将被保存为字符串。如果传入<code class="fe lv lw lx ly b">setItem</code>的第二个参数的数据不是字符串，那么它会自动转换成字符串。</p></div></div>    
</body>
</html>