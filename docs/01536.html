<html>
<head>
<title>Building a Whack-A-Mole Game With rn-sprite-sheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用rn-sprite-sheet构建打地鼠游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-whack-a-mole-game-with-rn-sprite-sheet-e8871ca594ce?source=collection_archive---------3-----------------------#2019-09-22">https://betterprogramming.pub/building-a-whack-a-mole-game-with-rn-sprite-sheet-e8871ca594ce?source=collection_archive---------3-----------------------#2019-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="028d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过一个新的转折来构建这个经典游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ef6ae4639fb058ad1398e04249de72d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmuqfJ1uQxj2MoaqG3wk6Q.jpeg"/></div></div></figure><p id="3a96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天我要在React Native里再造另一个经典游戏:打地鼠。这款游戏的机械版在70年代末和80年代初是街机迷的最爱。从那以后，在各种设备上进行了大量的克隆。</p><p id="73bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TL；1号医生:看视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0dbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">TL；DR #2:从GitHub 获取源代码<a class="ae ls" href="https://github.com/lepunk/react-native-videos/tree/whack-a-mole/WhackAMole" rel="noopener ugc nofollow" target="_blank"/></p><p id="8196" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">游戏玩法超级简单。在屏幕上，我们显示了12个插槽。鼹鼠会从这些槽中冒出来，然后又快速消失——玩家的目标是尽可能多地击中它们的头部。作为对原文的曲解，我想介绍三种不同的鼹鼠:</p><ul class=""><li id="cfbf" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">“中立”:如果没有被“重击”，这个鼹鼠不会造成伤害，但是当被击中时，玩家仍然会得到点数。</li><li id="8a09" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">“好斗”:这种鼹鼠会攻击玩家，如果没有及时受到重击的话，会造成伤害。</li><li id="6056" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">“治疗者”:如果被重击，它会恢复玩家一点点生命值。</li></ul><p id="a487" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最初的游戏更多的是针对儿童的——我认为引入不同的鼹鼠将会使事情变得有趣，足以扩大它的吸引力！</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="0374" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">设置</h1><p id="ce17" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们需要一些动画。在我看来，在React Native中制作动画的最佳方式是使用<a class="ae ls" href="https://github.com/MiLeung/rn-sprite-sheet" rel="noopener ugc nofollow" target="_blank"> rn-sprite-sheet </a>库。您可以通过运行以下命令来安装它:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="42ed" class="nq mp it nm b gy nr ns l nt nu">npm install --save rn-sprite-sheet</span></pre><p id="78f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个库在从包含相同大小的帧的单个图像文件中定义和运行小动画方面是惊人的。</p><p id="1a1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果一个动画有六个图像帧，每个都是40x50像素，您可以创建一个240x50的图像，粘贴您的帧，然后就可以开始了。</p><p id="d1ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，在现实生活中，你的镜架大小并不一样。我花了好几个小时手工创建我的sprite工作表，并且感到很烦——以至于我不得不创建一个python脚本来为我做这件事。你可以从我的<a class="ae ls" href="https://github.com/lepunk/sprite-sheet-generator" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中获取脚本。</p><p id="5fc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论如何，我最终为我们的游戏准备了这些图像资产:<a class="ae ls" href="https://github.com/lepunk/react-native-videos/tree/whack-a-mole/WhackAMole/assets/img" rel="noopener ugc nofollow" target="_blank">https://github . com/lepunk/react-native-videos/tree/whak-a-mole/whack amole/assets/img</a></p><p id="94b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像往常一样，为了方便起见，让我们将它们放入Image.js文件中:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e3f7" class="nq mp it nm b gy nr ns l nt nu">export default Images = {<br/>    background: require('./img/background.png'),<br/>    sprites: require('./img/sprites.png'),<br/>    healthIcon: require('./img/icon_health.png'),<br/>    pauseIcon: require('./img/icon_pause.png'),<br/>    timeIcon: require('./img/icon_time.png'),<br/>    scoreIcon: require('./img/icon_score.png'),<br/>    restartIcon: require('./img/icon_restart.png'),<br/>    playIcon: require('./img/icon_play.png')<br/>}</span></pre><p id="aba5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置基础设计既漫长又无聊。所以不用写几百行解释，只要<a class="ae ls" href="https://github.com/lepunk/react-native-videos/tree/whackamole/WhackAMole" rel="noopener ugc nofollow" target="_blank">点这里</a> <strong class="kw iu"> </strong>就能看到我们的起始位置。没什么特别的。我唯一想强调的是Constants.js中的两行代码</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="6df4" class="nq mp it nm b gy nr ns l nt nu">XR: Dimensions.get("screen").width / 650,<br/>YR: Dimensions.get("screen").height / 1024,</span></pre><p id="1a65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe nv nw nx nm b">background.png</code>图像是静态的650x1024px png。我们正在拉伸这个图像，以覆盖用户设备的整个屏幕。这款设备的屏幕尺寸可能不会是650x1024，因此图像会略有失真，这不是什么大问题。然而，问题是，以后我们需要在这个背景上的准确位置放置元素。这就是为什么我们必须设置XR和YR常数。它们表示背景图像大小和用户屏幕大小之间的X和Y比率。例如，如果屏幕的宽度是1300，XR值将是2。如果我们想在原始背景的左边放置20像素的东西，我们可以说<code class="fe nv nw nx nm b">Constants.XR * 20</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/6eb9c15884bc324be12dd9f0fb3df426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s48rZP85FKnh-tVmhF7I7w.png"/></div></div><p class="nz oa gj gh gi ob oc bd b be z dk translated">这是我们的新记录</p></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="b8ed" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">鼹鼠. js</h1><p id="b4bd" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">是时候把我们的鼹鼠加到屏幕上了。我们的基本Mole.js看起来会像这样:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="35d0" class="nq mp it nm b gy nr ns l nt nu">import React, { Component } from 'react';<br/>import { View, StyleSheet, Button, Image, TouchableWithoutFeedback } from 'react-native';<br/>import Images from './assets/Images';<br/>import SpriteSheet from 'rn-sprite-sheet';<br/>import Constants from './Constants';<br/><br/>export default class Mole extends Component {<br/>    constructor(props){<br/>        super(props);<br/><br/>        this.mole = null;<br/>    }<br/><br/>    whack = () =&gt; {<br/><br/>    }<br/><br/>    render(){<br/>        return (<br/>            &lt;View style={{ flex: 1 }}&gt;<br/>                &lt;SpriteSheet<br/>                    ref={ref =&gt; (this.mole = ref)}<br/>                    source={Images.sprites}<br/>                    columns={6}<br/>                    rows={8}<br/>                    width={100}<br/>                    animations={{<br/>                        idle: [0],<br/>                        appear: [1, 2, 3, 4],<br/>                        hide: [4, 3, 2, 1, 0],<br/>                        dizzy: [36, 37, 38],<br/>                        faint: [42, 43, 44, 0],<br/>                        attack: [11, 12, 13, 14, 15, 16],<br/>                        heal: [24, 25, 26, 27, 28, 29, 30, 31, 32, 33]<br/>                    }}<br/>                /&gt;<br/>                &lt;TouchableWithoutFeedback onPress={this.whack} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0}}&gt;<br/>                    &lt;View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }} /&gt;<br/>                &lt;/TouchableWithoutFeedback&gt;<br/>            &lt;/View&gt;<br/>        )<br/>    }<br/>}</span></pre><p id="60ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的部分是<spritesheet>组件。因为我们的sprites.png一行有六个图像，而我们有八行，所以我们传入<code class="fe nv nw nx nm b">columns={6}</code>和<code class="fe nv nw nx nm b">rows={8}</code></spritesheet></p><p id="0a9d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们需要定义动画。每个动画都有一个名称(例如“出现”)和一个帧索引列表。我们的sprite中的每一帧都分配了一个索引，从左上角的零开始，从左到右、从上到下递增1。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="ced1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">将鼹鼠添加到屏幕上</h1><p id="3389" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在我们的App.js中，我们需要导入我们的Mole组件:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="e01d" class="nq mp it nm b gy nr ns l nt nu">import Mole from './Mole';</span></pre><p id="bf49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可能希望保留对每个摩尔的引用，所以让我们按如下方式修改我们的构造函数:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="fd37" class="nq mp it nm b gy nr ns l nt nu">constructor(props){<br/>    super(props);<br/>    this.state = DEFAULT_STATE;<br/>    this.moles = [];<br/>}</span></pre><p id="b56f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在我们的<code class="fe nv nw nx nm b">playArea</code>中创建一个3x4的鼹鼠网格:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="ad07" class="nq mp it nm b gy nr ns l nt nu">&lt;View style={styles.playArea}&gt;<br/>    {Array.apply(null, Array(4)).map((el, rowIdx) =&gt; {<br/>        return (<br/>            &lt;View style={styles.playRow} key={rowIdx}&gt;<br/>                {Array.apply(null, Array(3)).map((el, colIdx) =&gt; {<br/>                    let moleIdx = (rowIdx * 3) + colIdx;<br/><br/>                    return (<br/>                        &lt;View style={styles.playCell} key={colIdx}&gt;<br/>                            &lt;Mole<br/>                                index={moleIdx}<br/>                                ref={(ref) =&gt; { this.moles[moleIdx] = ref }}<br/>                            /&gt;<br/>                        &lt;/View&gt;<br/>                    )<br/>                })}<br/>            &lt;/View&gt;<br/>        )<br/>    })}<br/>&lt;/View&gt;</span></pre><p id="ce59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了，现在我们的屏幕上有12个洞什么都不用做。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="b901" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">打掉那些痣</h1><p id="2ad5" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们希望定期在随机位置弹出鼹鼠。为了实现这一点，我们需要在我们的Mole.js中公开一个<code class="fe nv nw nx nm b">pop()</code>方法</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="9e88" class="nq mp it nm b gy nr ns l nt nu">pop = () =&gt; {<br/>    this.isPopping = true;<br/>    this.mole.play({<br/>        type: "appear",<br/>        fps: 24,<br/>        onFinish: () =&gt; {<br/>            this.actionTimeout = setTimeout(() =&gt; {<br/>                this.mole.play({<br/>                    type: "hide",<br/>                    fps: 24,<br/>                    onFinish: () =&gt; {<br/>                        this.isPopping = false;<br/>                        this.props.onFinishPopping(this.props.index);<br/>                    }<br/>                })<br/>            }, 1000)<br/>        }<br/>    });<br/>}</span></pre><p id="21f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们调用这个方法播放“出现”动画时，等待一秒钟然后播放“隐藏”动画。注意到<code class="fe nv nw nx nm b">this.props.onFinishPopping</code>呼叫了吗？这将在整个序列完成时被调用。</p><p id="4874" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的App.js中，我们应该修改<code class="fe nv nw nx nm b">Mole</code>定义:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4ba5" class="nq mp it nm b gy nr ns l nt nu">&lt;Mole<br/>    index={moleIdx}<br/>    ref={(ref) =&gt; { this.moles[moleIdx] = ref }}<br/>    onFinishPopping={this.onFinishPopping}<br/>/&gt;</span></pre><p id="0c24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们添加设置两个循环的逻辑:一个用于弹出摩尔，另一个用于减少计时器:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="8913" class="nq mp it nm b gy nr ns l nt nu">constructor(props){<br/>    super(props);<br/>    this.state = DEFAULT_STATE;<br/>    this.moles = [];<br/>    this.molesPopping = 0;<br/>    this.interval = null;<br/>    this.timeInterval = null;<br/>}<br/><br/>componentDidMount = () =&gt; {<br/>    this.setState(DEFAULT_STATE, this.setupTicks);<br/>}<br/><br/>setupTicks = () =&gt; {<br/>    let speed = 750 - (this.state.level * 50);<br/>    if (speed &lt; 350){<br/>        speed = 350;<br/>    }<br/>    this.interval = setInterval(this.popRandomMole, speed);<br/>    this.timeInterval = setInterval(this.timerTick, 1000);<br/>}<br/><br/>randomBetween = (min, max) =&gt; {<br/>    return Math.floor(Math.random() * (max - min + 1) + min);<br/>}<br/><br/>onFinishPopping = (index) =&gt; {<br/>    this.molesPopping -= 1;<br/>}<br/><br/>popRandomMole = () =&gt; {<br/>    if (this.moles.length != 12){<br/>        return;<br/>    }<br/><br/>    let randomIndex = this.randomBetween(0, 11);<br/>    if (!this.moles[randomIndex].isPopping &amp;&amp; this.molesPopping &lt; 3){<br/>        this.molesPopping += 1;<br/>        this.moles[randomIndex].pop();<br/>    }<br/>}<br/><br/>timerTick = () =&gt; {<br/>    if (this.state.time === 0){<br/>        clearInterval(this.interval);<br/>        clearInterval(this.timeInterval);<br/>        this.setState({<br/>            cleared: true<br/>        })<br/>    } else {<br/>        this.setState({<br/>            time: this.state.time - 1<br/>        })<br/>    }<br/>}</span></pre><p id="c02b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好了，这里有很多东西要解开:</p><ul class=""><li id="17d4" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">在<code class="fe nv nw nx nm b">componentDidMount</code>上，我们调用<code class="fe nv nw nx nm b">setupTicks</code>(在设置一些基本状态之后)。</li><li id="e24d" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">setupTick</code>将设置如上所述的两个间隔。</li><li id="e312" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">我们在<code class="fe nv nw nx nm b">molesPopping</code>变量中记录在任何给定的时刻有多少摩尔在“爆炸”。</li><li id="2258" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">当一个鼹鼠完成弹出时，调用<code class="fe nv nw nx nm b">onFinishPopping</code>，我们减少这个变量。</li><li id="813f" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">popRandomMole</code>将选择一个当前没有弹出的随机槽，但前提是我们一次的活动鼹鼠少于三个(否则事情会变得太混乱)。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/36b1227c58157933014572114d8e4e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*CGKUHxsYtpNABPkLcVBcqQ.gif"/></div></figure><p id="6546" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来不错，但并不令人兴奋…</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="ff39" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">打那些鼹鼠</h1><p id="f4eb" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">正如这篇文章第一段提到的，我想在原来的游戏中加入一个转折，引入不同种类的鼹鼠。</p><p id="3c5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">默认情况下，每只鼹鼠都是“中立”的，但是他们有40%的几率变成“好斗的”，有5%的几率成为“治疗者”。</p><p id="5006" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于它们的类型，我们将播放不同的动画序列。我们还应该处理重击。一个<code class="fe nv nw nx nm b">TouchableWithoutFeedback</code>已经被定义并指向我们需要填充的鼹鼠的重击方法。我们的Mole.js看起来会像这样:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4b19" class="nq mp it nm b gy nr ns l nt nu">import React, { Component } from 'react';<br/>import { View, StyleSheet, Button, Image, TouchableWithoutFeedback } from 'react-native';<br/>import Images from './assets/Images';<br/>import SpriteSheet from 'rn-sprite-sheet';<br/>import Constants from './Constants';<br/><br/>export default class Mole extends Component {<br/>    constructor(props){<br/>        super(props);<br/><br/>        this.mole = null;<br/>        this.actionTimeout = null;<br/>        this.isPopping = false;<br/>        this.isFeisty = false;<br/>        this.isHealing = false;<br/>        this.isWhacked = false;<br/>        this.isAttacking = false;<br/>    }<br/><br/>    pop = () =&gt; {<br/>        this.isWhacked = false;<br/>        this.isAttacking = false;<br/>        this.isPopping = true;<br/><br/>        this.isFeisty = Math.random() &lt; 0.4;<br/>        if (!this.isFeisty){<br/>            this.isHealing = Math.random() &lt; 0.05;<br/>        }<br/><br/>        if (this.isHealing){<br/>            this.mole.play({<br/>                type: "heal",<br/>                fps: 24,<br/>                onFinish: () =&gt; {<br/>                    this.actionTimeout = setTimeout(() =&gt; {<br/>                        this.mole.play({<br/>                            type: "hide",<br/>                            fps: 24,<br/>                            onFinish: () =&gt; {<br/>                                this.isPopping = false;<br/>                                this.props.onFinishPopping(this.props.index);<br/>                            }<br/>                        })<br/>                    }, 1000);<br/>                }<br/>            })<br/>        } else {<br/>            this.mole.play({<br/>                type: "appear",<br/>                fps: 24,<br/>                onFinish: () =&gt; {<br/>                    if (this.isFeisty){<br/>                        this.actionTimeout = setTimeout(() =&gt; {<br/>                            this.isAttacking = true;<br/>                            this.props.onDamage();<br/>                            this.mole.play({<br/>                                type: "attack",<br/>                                fps: 12,<br/>                                onFinish: () =&gt; {<br/>                                    this.mole.play({<br/>                                        type: "hide",<br/>                                        fps: 24,<br/>                                        onFinish: () =&gt; {<br/>                                            this.isPopping = false;<br/>                                            this.props.onFinishPopping(this.props.index);<br/>                                        }<br/>                                    })<br/>                                }<br/>                            })<br/>                        }, 1000)<br/>                    } else {<br/>                        this.actionTimeout = setTimeout(() =&gt; {<br/>                            this.mole.play({<br/>                                type: "hide",<br/>                                fps: 24,<br/>                                onFinish: () =&gt; {<br/>                                    this.isPopping = false;<br/>                                    this.props.onFinishPopping(this.props.index);<br/>                                }<br/>                            })<br/>                        }, 1000)<br/>                    }<br/>                }<br/>            })<br/>        }<br/>    }<br/><br/>    whack = () =&gt; {<br/>        if (!this.isPopping || this.isWhacked || this.isAttacking){<br/>            return;<br/>        }<br/><br/>        if (this.actionTimeout){<br/>            clearTimeout(this.actionTimeout);<br/>        }<br/><br/>        this.isWhacked = true;<br/>        this.isFeisty = false;<br/><br/>        this.props.onScore();<br/>        if (this.isHealing){<br/>            this.props.onHeal();<br/>        }<br/><br/>        this.mole.play({<br/>            type: "dizzy",<br/>            fps: 24,<br/>            onFinish: () =&gt; {<br/>                this.mole.play({<br/>                    type: "faint",<br/>                    fps: 24,<br/>                    onFinish: () =&gt; {<br/>                        this.isPopping = false;<br/>                        this.props.onFinishPopping(this.props.index);<br/>                    }<br/>                })<br/>            }<br/>        })<br/>    }<br/><br/>    render(){<br/>        return (<br/>            &lt;View style={{ flex: 1 }}&gt;<br/>                &lt;SpriteSheet<br/>                    ref={ref =&gt; (this.mole = ref)}<br/>                    source={Images.sprites}<br/>                    columns={6}<br/>                    rows={8}<br/>                    width={100}<br/>                    animations={{<br/>                        idle: [0],<br/>                        appear: [1, 2, 3, 4],<br/>                        hide: [4, 3, 2, 1, 0],<br/>                        dizzy: [36, 37, 38],<br/>                        faint: [42, 43, 44, 0],<br/>                        attack: [11, 12, 13, 14, 15, 16],<br/>                        heal: [24, 25, 26, 27, 28, 29, 30, 31, 32, 33]<br/>                    }}<br/>                /&gt;<br/>                &lt;TouchableWithoutFeedback onPress={this.whack} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0}}&gt;<br/>                    &lt;View style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }} /&gt;<br/>                &lt;/TouchableWithoutFeedback&gt;<br/>            &lt;/View&gt;<br/>        )<br/>    }<br/>}</span></pre><p id="de49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能已经注意到，我们使用了三种新的回调方法:</p><ul class=""><li id="ae81" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">this.props.onDamage</code></li><li id="6417" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">this.props.onHeal</code></li><li id="986d" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">this.props.onScore</code></li></ul><p id="9874" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们应该在App.js中定义这些。首先，让我们更改鼹鼠的定义:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="2fdf" class="nq mp it nm b gy nr ns l nt nu">&lt;Mole<br/>    index={moleIdx}<br/>    ref={(ref) =&gt; { this.moles[moleIdx] = ref }}<br/>    onFinishPopping={this.onFinishPopping}<br/>    onDamage={this.onDamage}<br/>    onHeal={this.onHeal}<br/>    onScore={this.onScore}<br/>/&gt;</span></pre><p id="6472" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们定义这三种方法:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="44de" class="nq mp it nm b gy nr ns l nt nu">gameOver = () =&gt; {<br/>    clearInterval(this.interval);<br/>    clearInterval(this.timeInterval);<br/><br/>    this.setState({<br/>        gameover: true<br/>    });<br/>}<br/><br/>onScore = () =&gt; {<br/>    this.setState({<br/>        score: this.state.score + 1<br/>    })<br/>}<br/><br/>onDamage = () =&gt; {<br/>    if (this.state.cleared || this.state.gameOver || this.state.paused){<br/>        return;<br/>    }<br/><br/>    let targetHealth = this.state.health - 10 &lt; 0 ? 0 : this.state.health - 10;<br/><br/>    this.setState({<br/>        health: targetHealth<br/>    });<br/><br/>    if (targetHealth &lt;= 0){<br/>        this.gameOver();<br/>    }<br/>}<br/><br/>onHeal = () =&gt; {<br/>    let targetHealth = this.state.health + 10 &gt; 100 ? 100 : this.state.health + 10;<br/>    this.setState({<br/>        health: targetHealth<br/>    });<br/>}</span></pre><p id="955f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些方法都不是火箭科学:</p><ul class=""><li id="9dbf" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated">增加10点生命值(如果还没满的话)。</li><li id="8a02" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">onScore</code>状态加一分。</li><li id="ba64" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">onDamage</code>带走10点生命值。如果生命值低于0，它会清除间隔并在屏幕上显示游戏。</li></ul><p id="ce7d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们必须为我们的接口挂接一些方法。我们需要定义:</p><ul class=""><li id="90ff" class="lt lu it kw b kx ky la lb ld lv lh lw ll lx lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">reset()</code>，当用户点击任何弹出屏幕上的复位按钮时调用</li><li id="feeb" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">nextLevel()</code>，当用户点击清除屏幕上的“播放”按钮时调用</li><li id="d9e3" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">pause()</code>，当用户点击右上角的暂停按钮时</li><li id="59bd" class="lt lu it kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated"><code class="fe nv nw nx nm b">resume()</code>，当用户点击暂停屏幕上的播放按钮时。</li></ul><p id="60b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它们非常简单，应该是这样的:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c0e4" class="nq mp it nm b gy nr ns l nt nu">reset = () =&gt; {<br/>    this.molesPopping = 0;<br/><br/>    this.setState(DEFAULT_STATE, this.setupTicks);<br/>}<br/><br/>pause = () =&gt; {<br/>    if (this.interval) clearInterval(this.interval);<br/>    if (this.timeInterval) clearInterval(this.timeInterval);<br/>    this.setState({<br/>        paused: true<br/>    });<br/>}<br/><br/>resume = () =&gt; {<br/>    this.molesPopping = 0;<br/>    this.setState({<br/>        paused: false<br/>    }, this.setupTicks);<br/>}<br/><br/>nextLevel = () =&gt; {<br/>    this.molesPopping = 0;<br/><br/>    this.setState({<br/>        level: this.state.level + 1,<br/>        cleared: false,<br/>        gameover: false,<br/>        time: DEFAULT_TIME<br/>    }, this.setupTicks)<br/>}</span></pre><p id="c131" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你知道了！我们已经成功地在React Native中构建了一个正常工作的打地鼠游戏，这实际上是一个非常有趣的游戏！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/16067fb668b160fd9a367feadccdcb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*pkk3mHUZrpcUsuJJvm-UoA.gif"/></div></figure><p id="0507" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢这个教程。</p></div></div>    
</body>
</html>