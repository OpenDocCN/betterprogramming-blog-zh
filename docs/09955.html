<html>
<head>
<title>Play Around With StoreKit 2 in iOS 15</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS 15中试用StoreKit 2</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/play-around-with-storekit-2-in-ios-15-f10a8b822b97?source=collection_archive---------5-----------------------#2021-11-05">https://betterprogramming.pub/play-around-with-storekit-2-in-ios-15-f10a8b822b97?source=collection_archive---------5-----------------------#2021-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="02b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">酝酿了10年的更新</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b2b255c7596d84a388d2302eb524a451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CN3rzw5WamwEXqUNUV6xVg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/s/photos/retail-store?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@mercantile?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克拉克街商业</a>拍摄</p></figure><p id="cb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">StoreKit是很久很久以前为iOS 3.0发布的——当然，苹果继续进行调整，但没有重大更新。直到今年的WWDC2021上，苹果发布了StoreKit 2，这是十多年来的首次重大修订。</p><p id="91f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请和我一起简单浏览一下苹果新框架的客户端代码——尽管就在你开始之前——注意StoreKit 2.0需要iOS15，如果你需要支持iOS 14或更低版本，那么你也许应该<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/in-app-purchases-and-storekit-in-ios-14-aed2c3e58966">从这里开始</a>。</p><p id="2e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看了WWDC关于这个主题的演示并查看了代码，我可以理解他们为什么决定把这个叫做StoreKit 2。新的API本身分为五个部分，即产品、购买、交易信息、交易状态和订阅状态。</p><p id="cae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有一些重大变化的更新，最显著的是用新的并发异步await语法替换了委托模式，并将收据的格式更改为JSON，使用JSON web signatures签名，也称为<a class="ae ky" href="https://datatracker.ietf.org/doc/html/rfc7515" rel="noopener ugc nofollow" target="_blank"> x5c标准</a>。每笔交易都有一张收据。我注意到下载的演示，它是基于一个SwiftUI界面——注意UIKit的忠实用户。</p><p id="c1bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在演示中提到的另一个重大升级与用户体验有关，StoreKit 2会在重新安装应用程序时自动恢复购买。</p><p id="cd22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸好有了演示代码，它提供了一个相当全面的新特性示例。和我一起看看上面的代码，同时尝试对它进行一点逆向工程，以更好地理解新的StoreKit框架是如何结合在一起的。</p><h1 id="dc38" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">演示应用程序</h1><p id="f712" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，你应该从苹果下载完整的代码，你可以在这里找到<a class="ae ky" href="https://developer.apple.com/documentation/storekit/in-app_purchase/implementing_a_store_in_your_app_using_the_storekit_api" rel="noopener ugc nofollow" target="_blank"/>。一个演示应用程序，您只需在模拟器上签名并运行即可，尽管在运行之前，您需要通过Xcode上的Product-&gt;Scheme-&gt;Edit Scheme菜单来更改StoreKit配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/3769cbfc0170354e53d3790477772bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbIQbvInM5-p86udROJ2sg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截图取自Xcode版本13.1</p></figure><p id="e565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您只需要做一个小的调整，将StoreKit引用改为指向本地配置。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/4bdb899e3bbf25d93d1af92509d8c5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dn4HkaGJGUfKG4y7qlY76w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">截图取自Xcode版本13.1</p></figure><p id="ebb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行它，您会看到最左边的屏幕，这里有两个选项。首先看看你有什么车，其次再买一些。我没有抓拍“我的汽车”菜单，因为当你启动它时，它是空的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/18ab86e49ccf4d00c72f95b810059034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vWHpgwq0bxqPJRcOrjAB_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">苹果StoreKit 2演示应用截图</p></figure><p id="109e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦运行，你可以玩它，买一辆车，和/或导航订阅。一旦在“我的汽车”子菜单中购买，就有更多购买燃料和动力的选项。</p><h1 id="c67c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">编码</h1><p id="3af4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Bon —在StoreKit中，您有非消耗品、消耗品和订阅。在演示应用程序中，演示了如何做到这一点，它设置了一个导航视图，旨在以纵向方式在iPhone上运行。</p><p id="d466" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在顶部<code class="fe mv mw mx my b">ContentView</code>的导航视图中，还有另外九个视图。虽然我怀疑你真正感兴趣的部分是一个名为<code class="fe mv mw mx my b">Store.swift</code>的单独的Swift文件。在前面提到的视图中作为环境对象引用的文件。有人将环境对象比作SwiftUI版本的单例对象，没有缺点。</p><p id="340b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关注<code class="fe mv mw mx my b">Store.swift</code>代码，我注意到他们一直在使用<code class="fe mv mw mx my b">@MainActor</code>标签——swift ui替代了<code class="fe mv mw mx my b">DispatchQueue.main.async</code>。</p><p id="a57e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大约有六个方法，其中的主要类<code class="fe mv mw mx my b">@Publishing</code>这个演示应用程序中的主要变量，即汽车、燃料、订阅和所谓的<code class="fe mv mw mx my b">purchasedIdentifiers</code>？苹果选择使用一个<code class="fe mv mw mx my b">plist</code>来存储产品的本地细节，当商店类别代码初始化时，它被读取。</p><p id="6ac3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了读取<code class="fe mv mw mx my b">plist</code>之外，它还调用了两个方法，第一个是设置一个lister来捕获事务，第二个是对本地StoreKit配置的请求，以返回在<code class="fe mv mw mx my b">plist</code>中命名的产品的详细信息。这两个调用都利用了新的并发异步等待原语。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="1dd1" class="nd lw it my b gy ne nf l ng nh">updateListenerTask = listenForTransactions()</span><span id="033d" class="nd lw it my b gy ni nf l ng nh">Task {<br/>  //Initialize the store by starting a product request.<br/>  await requestProducts()<br/>}</span></pre><p id="27ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，前一个调用，监听器进入了一个循环，除非特别取消，否则不会退出——只有当类本身被销毁时才会调用。</p><p id="4d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现的下一个方法是购买，它是通过购买按钮调用的，该按钮本身在应用程序的几个不同的菜单中被引用。同样，这只是一项任务。一个任务，它的响应由我前面提到的监听器获取。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="608b" class="nd lw it my b gy ne nf l ng nh">Task {<br/>  await purchase()<br/>}</span></pre><p id="15d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，您还有一个方法isPurchased，它返回最近购买的JSON格式的包。JSON，它被提供给<code class="fe mv mw mx my b">isPurchased</code>中的第二个方法来验证它是否是它所声称的——这是苹果为您做的验证。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3b76" class="nd lw it my b gy ne nf l ng nh">guard let result = await Transaction.latest(for: productIdentifier) else {<br/>  //If there is no latest transaction, the product has not been purchased.<br/>  return false<br/>}</span></pre><p id="a86d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，验证方法使用泛型来返回结果。</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="cf3a" class="nd lw it my b gy ne nf l ng nh">func checkVerified&lt;T&gt;(_ result: VerificationResult&lt;T&gt;) throws -&gt; T {<br/>  switch result {<br/>    case .unverified:<br/>      throw StoreError.failedVerification</span><span id="18ee" class="nd lw it my b gy ni nf l ng nh">    case .verified(let safe):<br/>      return safe<br/>    }<br/>}</span></pre><h2 id="7d1b" class="nd lw it bd lx nj nk dn mb nl nm dp mf li nn no mh lm np nq mj lq nr ns ml nt bi translated">AppAccountTokens</h2><p id="7907" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后，StoreKit2中的新功能(在WWDC的演示中提到过)，尽管在演示代码中没有，是一个用户生成的UUID，苹果称之为<code class="fe mv mw mx my b">appAccountToken</code>。</p><p id="4aea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其目的是帮助您跟踪哪些应用程序用户帐户开始并完成了与应用程序中的帐户相关联的交易，而不是设备ID或Apple ID。将非/可消费/订阅链接到应用程序中的特定用户，而不是apple id/设备。</p><h1 id="cacd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">人工验证</h1><p id="1a25" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">WWDC2021 StoreKit 2演讲以加密主题结束，我猜他们决定将最难的部分留给那些足够专注的学生，让他们听完整个演讲。在这最后一部分，他们概述了JWS包是由什么组成的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/887d999eb637ae76ea49187e6615a1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0GM-U0uva0N-6ZOnAxoJ1A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10114/" rel="noopener ugc nofollow" target="_blank">WWDC视频截图</a></p></figure><p id="9b41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的是，这里提到的算法是CryptoKit固有的，尽管我很抱歉地说，演示者通过建议你去谷歌其他地方的细节来掩饰验证签名的任务。</p><p id="347b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，他还是提出了一些对他有利的建议。</p><ul class=""><li id="63cc" class="nu nv it lb b lc ld lf lg li nw lm nx lq ny lu nz oa ob oc bi translated">您应该确认您将在交易中找到的<code class="fe mv mw mx my b">appID</code>与应用程序匹配(因此您需要将<code class="fe mv mw mx my b">appID</code>嵌入到应用程序中)。</li><li id="efc0" class="nu nv it lb b lc od lf oe li of lm og lq oh lu nz oa ob oc bi translated">您应该执行设备验证检查，他将其定义为执行这段代码，以确认reciept中的签名信息是为该设备生成的。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/5208674a077c33642388e58636c2bbdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWoBBUz4AXVAiORy-eqCXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://developer.apple.com/videos/play/wwdc2021/10114/" rel="noopener ugc nofollow" target="_blank">WWDC视频截图</a></p></figure><p id="8e43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些让我结束了这次回顾，一次演讲之旅。我希望你觉得它很有用，也很有趣。</p></div></div>    
</body>
</html>