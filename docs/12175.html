<html>
<head>
<title>Rust: Singleton Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust:单一应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rust-singleton-application-db2df027afa1?source=collection_archive---------6-----------------------#2022-05-17">https://betterprogramming.pub/rust-singleton-application-db2df027afa1?source=collection_archive---------6-----------------------#2022-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="695c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">借用检查器与设计模式</h2></div><p id="383f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大家好。先来说说Rust的一个让Rust开发者抓狂的概念:借货检查器。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/40c5066b6e07cc39892c3095aca6a14b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pCBgZgFrh5NL6-5i"/></div></div><p class="ln lo gj gh gi lp lq bd b be z dk translated">迈克尔·泽兹奇在的照片</p></figure><p id="9c78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但首先，让我解释一下这是什么，以及如果你想开始在Rust中开发，为什么你应该对这个主题感兴趣。</p><p id="0107" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在其他编译语言中，比如C++，你必须控制内存，也就是分配和释放动态内存。在Java等其他语言中，您不会遇到这个问题，因为垃圾收集器正在运行，并在后台监听未使用的内存以释放它。</p><p id="ca6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust让它“更简单”或者看起来更简单，因为当一个作用域终止时，Rust会释放它。此外，当您将值传递给一个函数/方法(另一个作用域)时，这个作用域会获取变量属性，当它的作用域终止时，这个内存会被再次释放。让我们看一个例子:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e698" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们想在这些函数中重用<code class="fe lu lv lw lx b">some_string</code>，我们必须切换到获取引用，而不是打印函数中的变量值。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="d78f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者再次返回值以不释放它。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9d11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">借用检查器的其他规则可能会引发错误。例如，当传递对struct构造函数的引用时，借用检查器将引发错误，因为它不知道作为引用传递的struct或变量可以存在多长时间，因此编译器将强制您使用lifetime。但是，请注意，这是一个陷阱。</p><blockquote class="ly"><p id="cfb1" class="lz ma iq bd mb mc md me mf mg mh la dk translated">借用检查器是避免内存泄漏的防护措施</p></blockquote><p id="634d" class="pw-post-body-paragraph kf kg iq kh b ki mi jr kk kl mj ju kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们可以说借用检查器是避免内存泄漏的卫士，内存泄漏会使您调试几个小时来找出偶尔的bug。</p><h1 id="1a6c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">设计模式</h1><p id="fd67" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">有一些设计模式，比如Singleton，可能会被借用检查器所阻碍。这是因为，在单例策略中，您必须将结构的实例作为静态存储在结构中。</p><p id="4c33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nk"> Singleton负责存储自身的全局实例，并被整个应用程序重用来存储全局变量，如配置或服务连接。</em></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="dc62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理论上，单例是这样工作的。我们创建一个类/结构，它有一个自身的属性和一个创建自身实例并返回它的方法。</p><p id="622e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剧透:Rust不让你创建这个有两个原因:</p><ul class=""><li id="5fd5" class="nl nm iq kh b ki kj kl km ko nn ks no kw np la nq nr ns nt bi translated">不实例化就不能使用结构中的属性。</li><li id="f7ae" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated">借用检查器不允许您存储其自身的实例，因为它会将其检测为内存泄漏。</li></ul><p id="fcbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也是Rust core开发者为此设计一些工具的原因。</p><h1 id="ba08" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">引用计数(又名Rc)结构</strong></h1><p id="9b05" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">这种结构允许您通过弱引用在不同的域之间共享引用。它是如何工作的？</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="8b23" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得代码可以编译，因为Rc结构创建了一个弱引用作为属性，告诉编译器在编译时不需要检查。问题是我们在创建属性后没有使用它。所以，在下一次调用中，它会再次创建它。</p><p id="ba87" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以使用这个工具将数据结构化为动态列表，而不是单一列表。</p><p id="7d84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nk">这只在本地线程中有效。如果你需要更多的线程，我推荐你使用Arc。这个特征实现了克隆特征，用threadsafe克隆引用。</em></p><p id="aa39" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">互斥</strong></p><p id="b4f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将我们的值存储为可变的，但会阻塞资源，直到有人离开对该值的引用。例如，如果我们有一个类型为<code class="fe lu lv lw lx b">u8</code>的变量，即使它是一个原始类型，它也会使它可变。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="42b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，为什么还是得不到实际值呢？嗯，在<code class="fe lu lv lw lx b">get_instance</code>中，我们每次调用时都实例化单例结构，而不使用我们实际的<code class="fe lu lv lw lx b">instance</code>属性。所以，我们必须从全球任何一个国家。</p><p id="a271" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有什么问题？静态变量不能是可变的，因为Rust认为你可以创建竞争条件，所以它强迫你使用不安全的作用域。</p><p id="f9c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">线程_本地！</strong></p><p id="6f5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个宏允许创建静态变量，而不需要非常数值处理。这里有一个例子:</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><pre class="lc ld le lf gt nz lx oa ob aw oc bi"><span id="7681" class="od mo iq lx b gy oe of l og oh">#[derive(Default)]</span></pre><p id="2780" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个派生使我们的结构实现了默认的特征。trait实现Rust的主要和非主要默认值。所以，我们现在不用担心违约。</p><pre class="lc ld le lf gt nz lx oa ob aw oc bi"><span id="5dca" class="od mo iq lx b gy oe of l og oh">thread_local! {<br/> static SINGLETON_POOL: Arc&lt;Singleton&gt; = Arc::new(Default::default());<br/>}</span></pre><p id="8342" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建我们的Singleton的静态默认值。此外，我们将Rc更改为Arc(原子引用计数)，这允许我们克隆引用。</p><pre class="lc ld le lf gt nz lx oa ob aw oc bi"><span id="9b1c" class="od mo iq lx b gy oe of l og oh">pub fn get_instance() -&gt; Arc&lt;Singleton&gt; {<br/> SINGLETON_POOL.with(|singleton_pool| singleton_pool.clone())<br/> }</span></pre><p id="b2f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lu lv lw lx b">get_instance</code>方法现在返回单例的全局状态。瞧，<em class="nk">，</em>我们让我们的单例工作了。</p><h1 id="12ae" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><p id="795f" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">像其他语言一样创建单例并不是一个好主意。也许更简单的方法是将变量存储在父状态中，并在需要这种配置的组件之间共享它。例如，Actix web框架实现了一个将在每个请求中传递的状态。</p><h1 id="20aa" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="133f" class="nl nm iq kh b ki nf kl ng ko oi ks oj kw ok la nq nr ns nt bi translated"><a class="ae lr" href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html" rel="noopener ugc nofollow" target="_blank">借入审核人单据</a></li><li id="92da" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae lr" href="https://blog.logrocket.com/introducing-the-rust-borrow-checker/" rel="noopener ugc nofollow" target="_blank">借checker博客</a></li><li id="2184" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae lr" href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html" rel="noopener ugc nofollow" target="_blank"> Rc文档</a></li><li id="3a98" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae lr" href="https://doc.rust-lang.org/std/sync/struct.Arc.html" rel="noopener ugc nofollow" target="_blank"> Arc docs </a></li><li id="8469" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae lr" href="https://doc.rust-lang.org/std/sync/struct.Mutex.html" rel="noopener ugc nofollow" target="_blank">互斥文件</a></li><li id="d31d" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae lr" href="https://doc.rust-lang.org/std/macro.thread_local.html" rel="noopener ugc nofollow" target="_blank">线程_本地宏文件</a></li><li id="39d6" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae lr" href="https://docs.rs/actix-web/latest/actix_web/struct.HttpRequest.html#method.app_data" rel="noopener ugc nofollow" target="_blank"> Actix web app状态参考</a></li></ul><p id="6b0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读；希望你喜欢！我很想听听你对设计模式或Rust的想法和经验。</p><p id="3e96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae lr" href="https://www.linkedin.com/in/%C3%A1ngel-berh%C3%B3-grande/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上留言或联系我。</p></div></div>    
</body>
</html>