<html>
<head>
<title>Pagination in Kotlin Multiplatform Mobile</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kotlin多平台移动设备中的分页</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/pagination-in-kotlin-multiplatform-mobile-a96f21e71668?source=collection_archive---------4-----------------------#2022-08-18">https://betterprogramming.pub/pagination-in-kotlin-multiplatform-mobile-a96f21e71668?source=collection_archive---------4-----------------------#2022-08-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c6f8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用这些策略创建加载速度更快的页面</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/735b72edcff3ea86e35f75c2a40782d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zuHalKmxyRSaQH07"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@detpho?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗朗西斯科</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7aa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一个性能良好的应用程序中，分页总是不可避免的，这不仅是为了高效的数据加载，也是为了产生更好的用户体验。通过将数据分成独立的页面，应用程序将加载得更快，用户也将更快地获得数据。这将比需要加载所有数据的非分页应用程序有更好的转化率。</p><p id="378c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当谈到一个问题时，</p><blockquote class="ls lt lu"><p id="7e7a" class="kw kx lv ky b kz la jr lb lc ld ju le lw lg lh li lx lk ll lm ly lo lp lq lr ij bi translated">为Kotlin多平台移动(KMM)项目的声明式构造的UI进行分页的简单方法是什么？</p></blockquote><p id="aeea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能有各种各样的答案，但我们没有关于实用性和可靠性的确切答案。阅读这篇文章会让你探索你可能期待的答案。</p><h1 id="d72f" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">要求</h1><p id="eb26" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">建议您了解KMM项目结构。如果你还不熟悉，请先阅读这里的<a class="ae kv" href="http://Understand mobile project structure" rel="noopener ugc nofollow" target="_blank"/>。还希望熟悉Android (Jetpack Compose)和iOS (SwiftUI)平台的声明式UI。现在让我们从共享模块开始。</p><h1 id="b2dc" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">共享的</h1><p id="eca1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">由于KMM项目是模块化的，我们将从<a class="ae kv" href="https://kotlinlang.org/docs/multiplatform-mobile-understand-project-structure.html#root-project" rel="noopener ugc nofollow" target="_blank">共享</a>模块开始。首先，我们需要一个由API响应组成的数据类。分页API响应通常包含当前显示的页面、总页数和消息。下面是一个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">API响应</p></figure><p id="b78d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的数据类中，<code class="fe my mz na nb b">page</code>是当前显示的页面。同时，<code class="fe my mz na nb b">message</code>是仅在发生错误时才存在的服务器状态消息。此外，我们也有<code class="fe my mz na nb b">totalPages</code>显示我们应该加载的页数。</p><p id="0f98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地使用API获取结果，建议我们将结果包装在一个状态中。以下是该州的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">列表状态</p></figure><p id="f5d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的状态将API响应和错误封装在一个共享模块中，因此我们只需要在我们的共享视图模型中创建一个函数，它可以返回两种可能的结果(API响应或错误发生)。现在，让我们看看共享视图模型如何调用API。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">共享视图模型类</p></figure><p id="76f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的<code class="fe my mz na nb b">MovieListSharedViewModel</code>中，我们没有应用try-catch函数，因为它已经在存储库中进行了处理，所以上面的<code class="fe my mz na nb b">loadMovie</code>函数将只调用结果。这是为了让我们在iOS工作区中更高效地调用函数。参考<a class="ae kv" href="https://github.com/annasta13/The-Movies/blob/f45a651604d3104a42b8bbabaf7f18f59ecc99e1/shared/src/commonMain/kotlin/com/habileducation/themovie/util/FlowHelper.kt" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</p><p id="caea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在已经完成了共享模块的工作，而不考虑用例以及存储库。我们现在可以进入我们的Android模块，开始为Android平台实现分页。</p><h1 id="52b4" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">机器人</h1><p id="efe4" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">Android平台的声明式UI可以使用<a class="ae kv" href="https://developer.android.com/jetpack/compose?gclid=CjwKCAjwo_KXBhAaEiwA2RZ8hPj3kxONiuQB6FMLzKwiwXVzaO7JVpumr2TsraYs3hDvcVx4wKOLzxoCUdQQAvD_BwE&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank"> Jetpack Compose </a>来实现。在Jetpack Compose中建立分页非常简单。我们可以用它的<a class="ae kv" href="https://developer.android.com/jetpack/androidx/releases/paging\" rel="noopener ugc nofollow" target="_blank">分页库</a>，很容易实现。首先，向Android应用程序Gradle添加以下依赖项。</p><p id="172c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na nb b">implementation(“androidx.paging:paging-compose:1.0.0-alpha10”)</code></p><p id="2a32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们制作一个数据分页源，在我们的<code class="fe my mz na nb b">view</code>模型中调用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据分页源</p></figure><p id="a64f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe my mz na nb b">load</code>中，上面的函数调用了我们之前在共享<code class="fe my mz na nb b">view</code>模型中制作的函数。为了收集<code class="fe my mz na nb b">sharedViewModel.loadMovie</code>的返回结果，我们使用<code class="fe my mz na nb b">.last()</code>，因为<code class="fe my mz na nb b">loadMovie</code>函数被流包装。最后，为了创建可重用的结果条件，返回逻辑在下面的<code class="fe my mz na nb b">PagingHelper</code>类中处理:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">寻呼助手</p></figure><p id="b1cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，上面的<code class="fe my mz na nb b">PagingHelper</code>类被创建来拥有一个可重用的分页源加载结果的返回函数，这样一旦我们有了多个分页源，我们就不需要重新创建返回条件。</p><p id="aa2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是创建我们的列表视图模型，它将保存我们的分页数据列表，以便它知道应用程序的生命周期。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Android列表视图模型</p></figure><p id="6363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，列表是直接初始化的。但是，如果我们希望在视图模型初始化时让它为空，我们可以将其设置为<code class="fe my mz na nb b">var list: Flow&lt;PagingData&lt;Movie&gt;&gt; = flowOf(PagingData.empty())</code>。这种初始化也使我们能够根据需要修改列表。</p><p id="5b76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，在我们的可组合函数中，我们可以通过用<code class="fe my mz na nb b">viewModel.list.collectAsLazyPagingItems()</code>收集视图模型中的列表来调用列表。要了解它是如何实现的，请查看下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9c77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，列表中有<code class="fe my mz na nb b"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/paging/CombinedLoadStates" rel="noopener ugc nofollow" target="_blank">CombinedLoadStates</a></code> <a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/paging/CombinedLoadStates" rel="noopener ugc nofollow" target="_blank"> </a>可以被调用来处理错误。同样，为了拥有一个可重用的分页视图来保存它的错误状态，我创建了一个定制的分页视图容器，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="497e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们现在可以尝试我们的Android应用程序。下面是我们运行代码的截图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/6b41c1f671d7e47a1c1a9a2406e35aa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/1*iiLbfNt8-MMNfkuGKzOEWA.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Android分页预览</p></figure><h1 id="458a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">ios</h1><p id="3dea" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们已经在Android中实现了分页，现在是时候将它转换为Xcode以在iOS中实现它了。让我们从创建视图模型或可观察类开始，它将在视图配置中用作状态。与Android类似，视图模型至少应该有一个数据列表、一个当前显示页面和一个throwable对象，在本例中，我直接将其设置为错误消息。视图模型应该如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS列表视图模型</p></figure><p id="50a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们有一个名为<code class="fe my mz na nb b">loadingPage</code>的加载状态，一旦我们需要在UI配置中使用它，就可以使用它。此外，一旦我们从服务器收到IOException或status消息，也会有一个错误消息集。作为一条附加信息，<code class="fe my mz na nb b">sharedViewModel</code>在KMM项目的iOS main中配置的<code class="fe my mz na nb b">MovieModule</code>中初始化。参考<a class="ae kv" href="https://github.com/annasta13/The-Movies/blob/main/shared/src/iosMain/kotlin/com/habileducation/themovie/di/MovieModule.kt" rel="noopener ugc nofollow" target="_blank">此处</a>了解更多信息。</p><p id="5278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，这里最重要的事情是我们初始化列表的方式不同于Android视图模型，因为我们需要使用<code class="fe my mz na nb b">append</code>函数来添加列表。这就是我们需要的所有视图模型配置。我们现在可以开始创建我们的UI函数了。</p><p id="d49f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在SwiftUI中显示分页数据列表时，我们必须使用LazyVStack才能有更好的性能。此外，我们需要显示一个基于视图模型中的<code class="fe my mz na nb b">isLastPage</code>状态的加载视图。这用于指示滚动状态已经到达最后一项。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a586" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从上面的代码中，我们可以对视图模型在列表加载视图出现时如何调用<code class="fe my mz na nb b">loadPage</code>函数做一个简单的假设。但是，一旦我们到达了最后一页，加载视图就不会出现，视图模型也不会调用<code class="fe my mz na nb b">loadPage</code>函数。</p><p id="af1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来呢？是的，一切都完成了，我们现在可以运行应用程序。我们应该让我们的应用程序显示如下分页数据:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/809c7c9b3cdea216cec38235f2af8b83.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/1*9HAYQfeWOdUEFv-Q3655Aw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iOS分页预览</p></figure><h1 id="bada" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="defd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">当然，当在多平台项目上工作时，我们期望的是有一个二合一的代码来提高效率。在这个项目中，我们在共享电影列表视图模型中应用了加载页面功能，我们可以在Android视图模型和iOS视图模型中初始化的Android分页数据源中使用该功能。然而，我们只讨论分页实现所需的核心功能。</p><p id="f50e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要有更完整的实现，请参考下面的真实项目:</p><div class="ne nf gp gr ng nh"><a href="https://github.com/annasta13/The-Movies.git" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">GitHub - annasta13/The-Movies:干净的架构Kotlin多平台移动(KMM)与Android…</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">里面有什么？-Jetpack Compose-Hilt-Ktor-Android仪器测试-分页-单元测试- SQLDelight…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">github.com</p></div></div></div></a></div></div></div>    
</body>
</html>