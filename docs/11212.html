<html>
<head>
<title>How I Automated Minting My Tweets as NFTs on OpenSea — Listening to Twitter Events and Queuing Jobs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何在OpenSea上将我的推文自动生成为NFT的——听Twitter事件和排队工作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-i-automated-minting-my-tweets-as-nfts-on-opensea-part-2-662fcb52c45c?source=collection_archive---------7-----------------------#2022-02-27">https://betterprogramming.pub/how-i-automated-minting-my-tweets-as-nfts-on-opensea-part-2-662fcb52c45c?source=collection_archive---------7-----------------------#2022-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c86a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Webhooks定制我的OpenSea系统——第2部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e6382e54ca93dde29f7b6b27bb0a7115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iqwvF7BVqgsKVLIh"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图为<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">舒巴姆·达吉</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="fe1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是“我如何在OpenSea文章上自动将我的Tweets生成为NFT”系列的第二部分。在本文中，我将讨论如何使用NodeJS和ExpressJS创建OpenSear-API webhook监听器。</p><p id="f84e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要阅读本系列文章的第一部分，请查看以下链接:</p><div class="ls lt gp gr lu lv"><a rel="noopener  ugc nofollow" target="_blank" href="/how-i-automated-minting-my-tweets-as-nfts-on-opensea-854c50a44467"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">我如何在OpenSea上自动将我的推文制作成非功能性文件</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">下面是我如何创建自己的系统来上市和铸造非功能性交易</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">better编程. pub</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><p id="46c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的第一篇文章中，(我不希望这成为一个系列文章，但我的故事太大了，无法在一篇文章中讲述)我讨论了我如何创建Twitter帐户活动API webhooks。在本文中，我将讨论如何创建OpenSear-API，它本质上是一个webhook监听器。</p><p id="d9cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，对于这个API，我们需要创建两个端点。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="eb4e" class="mp mq iq ml b gy mr ms l mt mu">GET /callback</span></pre><p id="80a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个端点用于向Twitter帐户活动API注册和认证侦听器端点，并在需要时重新认证。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="d18d" class="mp mq iq ml b gy mr ms l mt mu">POST /callback</span></pre><p id="ffdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Twitter帐户活动API使用这个端点来发送webhook事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例JSON有效负载发送到POST/回调</p></figure><p id="8fd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的要点是一个发送到POST /callback端点的示例JSON有效负载。你可以从这里找到更多。</p><div class="ls lt gp gr lu lv"><a href="https://developer.twitter.com/en/docs/twitter-api/premium/account-activity-api/guides/account-activity-data-objects" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">帐户活动数据对象</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">订阅用户执行以下任何操作时的推文状态负载:推文、转发…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">developer.twitter.com</p></div></div><div class="me l"><div class="mx l mg mh mi me mj kp lv"/></div></div></a></div><p id="173d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们开始构建OpenSear-API吧。为此，让我们使用NodeJS和ExpressJS，因为在任何地方使用<a class="ae kv" href="https://medium.com/swlh/javascript-in-space-7855a7ecf81b" rel="noopener"> JavaScript都很酷。然而，如果我继续谈论如何使用Node和Express创建API，这将变得极其冗长，更不用说令人厌烦了。要学习如何轻松创建API，您可以遵循</a><a class="ae kv" href="https://medium.com/swlh/node-is-simple-part-1-b87a8dc390c7" rel="noopener">我的Node指南是简单文章系列</a>。</p><p id="184a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">长话短说，让我们创建这个文件夹结构。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="e5df" class="mp mq iq ml b gy mr ms l mt mu">.<br/>├── controllers<br/>│   └── index.js<br/>├── errors<br/>│   └── index.js<br/>├── keys<br/>│   └── index.js<br/>├── middleware<br/>│   └── index.js<br/>├── models<br/>│   └── index.js<br/>├── services<br/>│   └── index.js<br/>├── utilities<br/>│   ├── async-wrapper.d.ts<br/>│   └── async-wrapper.js<br/>└── index.js</span></pre><p id="a4f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe my mz na ml b">/index.js</code>文件是我们Express API的入口点。让我们如下创建它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/index.js" rel="noopener ugc nofollow" target="_blank"> /index.js </a></p></figure><p id="4caf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要创建<code class="fe my mz na ml b">controllers</code>和<code class="fe my mz na ml b">services</code>，它们将处理API请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/controllers/index.js" rel="noopener ugc nofollow" target="_blank">/控制器/index.js </a></p></figure><p id="4775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个控制器文件中，我们定义了API端点<code class="fe my mz na ml b">GET /callback</code>和<code class="fe my mz na ml b">POST /callback</code>，相关的服务将在一个服务文件中创建。<code class="fe my mz na ml b">asyncWrapper</code>用于创建一个包装器来捕捉错误，并使用我们自己的错误处理中间件来处理这些错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/utilities/async-wrapper.js" rel="noopener ugc nofollow" target="_blank">/utilities/异步包装器. js </a></p></figure><p id="ceb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了简化开发，我们可以使用数据类型声明。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/utilities/async-wrapper.d.ts" rel="noopener ugc nofollow" target="_blank">/实用程序/异步包装器. d.ts </a></p></figure><p id="8126" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们创建<code class="fe my mz na ml b">validator</code>中间件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/middleware/validator.js" rel="noopener ugc nofollow" target="_blank">/中间件/验证器. js </a></p></figure><p id="cd6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们创建<code class="fe my mz na ml b">models</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/models/index.js" rel="noopener ugc nofollow" target="_blank"> /models/index.js </a></p></figure><p id="4047" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于模型验证，我们使用最强大的模式描述语言和JavaScript数据验证器💪。我们从<a class="ae kv" href="https://developer.twitter.com/en/docs/twitter-api/premium/account-activity-api/guides/account-activity-data-objects" rel="noopener ugc nofollow" target="_blank">文档</a>中得知，Twitter账户活动API发送的每个有效载荷都有一个<code class="fe my mz na ml b">for_user_id</code>密钥。所以我们把它作为验证来检查。(这不是必需的，但我添加这个只是为了我可以使用<code class="fe my mz na ml b">joi</code>包。)此外，我将使用定制的中间件为这些端点增加一层安全性。现在让我们创建<code class="fe my mz na ml b">middleware</code>函数来处理安全性和其他重要的Express特性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/middleware/index.js" rel="noopener ugc nofollow" target="_blank">/中间件/index.js </a></p></figure><p id="b66a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">中间件；不能和他们一起生活，不能没有他们。</strong></p><p id="14aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们讨论一下这里使用的中间件。</p><ol class=""><li id="6f2c" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">Body-parser——Body parser中间件用于解析请求体，并将其附加为<code class="fe my mz na ml b">req.body</code>。</li></ol><p id="2075" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.mor gan—mor gan(Dexter mor gan)是一个用于NodeJS的HTTP请求记录器中间件。</p><p id="fc42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.cors——当您需要指定哪些资源可以访问该API时，可以使用CORS包。这也被称为跨来源资源共享。</p><div class="ls lt gp gr lu lv"><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">跨来源资源共享(CORS) - HTTP | MDN</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">跨源资源共享(CORS)是一种基于HTTP头的机制，允许服务器指示任何源…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">developer.mozilla.org</p></div></div><div class="me l"><div class="nl l mg mh mi me mj kp lv"/></div></div></a></div><p id="abef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.头盔-头盔用于通过设置各种HTTP头来保护Express应用程序。</p><p id="0aac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们转到最重要的中间件。<code class="fe my mz na ml b">TwitterValidator</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/middleware/twitter-validator.js" rel="noopener ugc nofollow" target="_blank">/中间件/twitter-validator.js </a></p></figure><p id="9f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个<code class="fe my mz na ml b">TwitterValidator</code>中，我们检查GET /callback端点是否被真正的Twitter API命中。为了帮助我们做到这一点，Twitter API为我们提供了<code class="fe my mz na ml b">x-twitter-webhooks-signature</code>头，我们可以在那里检查收到的数据。</p><p id="825f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安全性；那又怎么样？</p><ol class=""><li id="dbdf" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated">保护<code class="fe my mz na ml b">GET /callback</code>端点</li></ol><p id="f191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如官方指南中提到的那样，我们所要做的就是获得<code class="fe my mz na ml b">crc_token</code>查询参数和<code class="fe my mz na ml b">nonce</code>查询参数的值，然后创建下面的字符串。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="8e63" class="mp mq iq ml b gy mr ms l mt mu">`<!-- -->crc_token=${token}&amp;nonce=${nonce}`</span></pre><p id="bd53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们需要使用HMAC·SHA-256算法用上面的字符串和TWITTER_CONSUMER_SECRET创建散列。然后我们将这个散列与来自<code class="fe my mz na ml b">twitter-webhooks-signature</code>头的值进行比较。(这里我没有使散列比较时间攻击安全。从理论上讲，定时攻击可能会泄露两个散列的类型和长度信息，但不会泄露它们的真实值。)如果匹配，那么我们可以说GET请求已经被Twitter发送了。如果不是，就是有人在试图滥用你的API！</p><p id="5d00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.固定<code class="fe my mz na ml b">POST /callback</code>端点</p><p id="2b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最棘手的部分，我挣扎了很久。从来没有人告诉我(我指的是<a class="ae kv" href="https://developer.twitter.com/en/docs/twitter-api/enterprise/account-activity-api/guides/securing-webhooks" rel="noopener ugc nofollow" target="_blank">官方指南</a>)我应该使用原始缓冲体来获取hash以检查<code class="fe my mz na ml b">twitter-webhooks-signature</code>值。我试了一次又一次，试图对照<code class="fe my mz na ml b">JSON.stringify()</code>(纤维化)的身体来检查，但毫无效果。所以后来我发现，在应用<code class="fe my mz na ml b">bodyParser.json()</code>中间件之前，我必须使用原始体。所以我为<code class="fe my mz na ml b">bodyParser</code>中间件创建了<code class="fe my mz na ml b">verifyPostRequest</code>定制验证器。它所做的是使用HMAC SHA-256算法创建原始主体和TWITTER_CONSUMER_SECRET的散列，并对照<code class="fe my mz na ml b">twitter-webhooks-signature</code>值检查该散列。如果匹配，那么我们可以说POST请求是由Twitter发送的。如果不是，有人试图滥用您的API😂！</p><p id="e92e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然所有其他的中间件都被处理了，让我们继续讨论另一个非常重要的中间件。让我们来构建<code class="fe my mz na ml b">ErrorHandling</code>中间件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/middleware/error-handling.js" rel="noopener ugc nofollow" target="_blank">/中间件/错误处理. js </a></p></figure><p id="c6ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在错误处理中间件中，我们检查由我们的<code class="fe my mz na ml b">asyncWrapper</code>捕获的错误是否是我们在<code class="fe my mz na ml b">errors/index.js</code>中创建的错误，如果不是，我们使用默认的错误处理程序来处理它。下面是我们定义自定义错误类的<code class="fe my mz na ml b">errors/index.js</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/errors/index.js" rel="noopener ugc nofollow" target="_blank"> /errors/index.js </a></p></figure><p id="0073" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经完成了OpenSear-API Express应用程序的几乎所有基本部分，让我们继续创建在我们前面定义的控制器中使用的服务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://github.com/Niweera/opensear/blob/main/services/index.js" rel="noopener ugc nofollow" target="_blank"> /services/index.js </a></p></figure><p id="bd24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的服务文件中，我们处理两个端点。</p><ol class=""><li id="ab98" class="nb nc iq ky b kz la lc ld lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe my mz na ml b">GET /callback</code>端点——我们创建了<code class="fe my mz na ml b">services.getHandler()</code>函数，这样我们就可以创建CRC令牌并将其发送回Twitter API。为此，我们创建了一个对象，</li></ol><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="c4b2" class="mp mq iq ml b gy mr ms l mt mu">{<br/>  response_token: `sha256=${hmac}`<br/>}</span></pre><p id="1da2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<code class="fe my mz na ml b">hmac</code>是使用TWITTER_CONSUMER_SECRET和来自Twitter API的查询字符串提供的<code class="fe my mz na ml b">crc_token</code>创建的，并像我们之前所做的那样创建一个散列。Twitter账户活动API将像下面这样到达我们的<code class="fe my mz na ml b">GET /callback</code>端点。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="27bc" class="mp mq iq ml b gy mr ms l mt mu">/callback?crc_token=$token&amp;nonce=$nonce</span></pre><p id="47de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果Twitter API接受我们的<code class="fe my mz na ml b">response_token</code>有效，那么我们就成功了。我们可以通过webhook监听器监听Twitter事件。</p><p id="6e6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<code class="fe my mz na ml b">POST /callback</code>端点——我们创建<code class="fe my mz na ml b">services.postHandler()</code>函数来检查我们想要关注的Twitter事件是否真的发生了。在我的例子中，我检查Twitter事件是否是我创建的tweet，并且它在tweet正文中包含单词<code class="fe my mz na ml b">wordle</code>。如果Twitter事件是我要找的，我会在这里排队找工作。我在这里省略了作业排队功能，因为这取决于您对作业排队的想象。对于这项任务，我建议通读以下内容。</p><div class="ls lt gp gr lu lv"><a href="https://openbase.com/categories/js/best-nodejs-job-queues-libraries" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">2022年10大最佳Node.js作业队列库| Openbase</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">2022年10个最佳Node.js作业队列库对比:batch-cluster、generator-hapi-api-stack、kinetik……</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">openbase.com</p></div></div><div class="me l"><div class="nm l mg mh mi me mj kp lv"/></div></div></a></div><p id="3b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经完成了OpenSear-API的实现。我们可以通过运行我在上一篇文章中提到的以下命令来检查这一点。</p><pre class="kg kh ki kj gt mk ml mm mn aw mo bi"><span id="c92a" class="mp mq iq ml b gy mr ms l mt mu">$ node --experimental-specifier-resolution=node twitter-cli.js create-webhook</span><span id="2e74" class="mp mq iq ml b gy nn ms l mt mu">$ node --experimental-specifier-resolution=node twitter-cli.js create-susbscription</span></pre><p id="0ca1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们创建了webhook，然后我们为Twitter用户添加了订阅。然后我们可以创建一条包含单词<code class="fe my mz na ml b">wordle</code>的tweet。至于OpenSear系统，我们现在已经完成了前半部分。现在我们可以使用OpenSear-API基于tweet对作业进行排队。</p><p id="6b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们需要一个工人来承担这项工作，铸造和出版NFT。我将把它留到本系列的第3部分。所以让我们在下一篇文章中继续我们的讨论，我将讨论我如何创建用于处理作业的OpenSear-Worker。</p><div class="ls lt gp gr lu lv"><a href="https://github.com/Niweera/opensear" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">GitHub-Niweera/open sear:open sear是一个帮助我创建并列出我的NFT的系统…</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">OpenSear是一个帮助我在opensea.io marketplace上创建和列出我的NFT的系统。看看我的NFT收藏吧</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="no l mg mh mi me mj kp lv"/></div></div></a></div></div></div>    
</body>
</html>