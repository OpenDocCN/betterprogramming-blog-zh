<html>
<head>
<title>Design Distributed Transaction With Practical Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用实例设计分布式事务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-distributed-transaction-with-practical-examples-7b1d93fddb63?source=collection_archive---------10-----------------------#2022-03-14">https://betterprogramming.pub/design-distributed-transaction-with-practical-examples-7b1d93fddb63?source=collection_archive---------10-----------------------#2022-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac25" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">设计评审实际上是什么样子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a349a82b9a0949801981af0181ffaefb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AFKbOvu2LxfS5Dlq"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约翰·施诺布里奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="418a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上次，我们已经讨论过，<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/how-to-prepare-a-design-review-like-an-expert-85d2ab85d7f5">如何像专家</a>一样准备设计评审。应该准备三样东西:</p><ul class=""><li id="f5d5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">C4模型</li><li id="b851" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">用户故事和用例</li><li id="bfd6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">设计决策</li></ul><p id="4612" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将用一个实际的例子向你展示什么是设计评审。一些有太多细节的讨论将被跳过，只展示关键的设计。</p><h1 id="ca80" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">用户故事</h1><p id="721c" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">首先，我们要定义用户故事。就像前一篇文章提到的，用户故事与C4模型中的上下文观点一致。因此，我们清楚地写下用户故事。</p><p id="ef21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这次我们要做的是送礼物的功能。并且，整个故事如下。</p><ul class=""><li id="65e4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">用户可以决定一次给别人多少同样的礼物。</li><li id="3f0c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">只要用户有足够的钱，那么送礼的人数是没有限制的。</li><li id="a029" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在完成赠送礼物后，它必须通知发送者和接收者一切都已完成。</li></ul><h1 id="99e3" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">用例</h1><p id="c23d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">整个送礼场景在用户故事中描述的很清楚，但是，还有一些细节描述的不够充分。举个例子，</p><ul class=""><li id="fbb0" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果用户余额不够，那么所有的礼物都会失效，无法部分成功。</li><li id="b99d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">送礼物完毕表示所有的接收者都收到了礼物。</li><li id="1816" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">通知的内容必须包含发送者、礼品总额和所有接收者。</li><li id="7cc2" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">不管给多少人，整个过程都要在几分钟内完成。</li></ul><p id="420b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在上面看到的，在用例中，我们添加了故事中没有的细节，更详细地呈现了整个场景。</p><h1 id="21a4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">C4模型</h1><p id="88d9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在，我们可以画出整个设计的C4模型。</p><h1 id="99d4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">语境</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/23cb4cafe6a75776731224d8bba747e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*WFOdotUY2mTKPaBZiGhM6Q.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">内外关系图</p></figure><p id="185b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基于用户故事，我们绘制了一个上下文来描述用户和系统之间的交互。从上下文中，我们知道有几个关键点必须充分讨论。</p><ol class=""><li id="387c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ne ly lz ma bi translated">包含<code class="fe nf ng nh ni b">gift</code>的行</li><li id="1496" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated"><code class="fe nf ng nh ni b">Server</code>本身的行为</li><li id="3d5d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">包含<code class="fe nf ng nh ni b">notify</code>的行</li></ol><p id="b066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能会问<code class="fe nf ng nh ni b">notification service</code>和<code class="fe nf ng nh ni b">receivers</code>怎么样。答案很简单。那是第三方服务，我们无法控制它的行为。所以在一篇设计评论里，关于送礼的话题，没必要讨论。当然，如果对通知有任何担心，我们可以举行另一次设计审查来深入了解。</p><h1 id="3da1" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">容器</h1><p id="16de" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">一旦我们有了上下文，我们就开始深入上面列出的三点，并以容器的形式展开它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/15c7d689f826c30864d20f6192ce67d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QREa2DjREx-ZIYZL_vdLjA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">集装箱图</p></figure><p id="1b47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后我们得到了这个图表，这是它完成后的样子。这里有很多设计决策，但是在这一节，我只介绍这个图的意义。至于设计决策，我们将在后面的章节中深入分析。</p><ol class=""><li id="4576" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ne ly lz ma bi translated">用户发送礼物请求，包括送什么和送谁。</li><li id="1495" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">收到请求后，<code class="fe nf ng nh ni b">Server</code>首先从用户钱包中扣款，如果余额不够直接回复<code class="fe nf ng nh ni b">nak</code>，然后将请求分成固定大小的批次，并将批次信息写入数据库。之后，批处理任务被发送到worker，与事务的序列号异步执行。</li><li id="9025" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">虽然流程没有完成，但是准备工作已经做好了，回复用户<code class="fe nf ng nh ni b">ack</code>表示整个流程在进行中。</li><li id="1747" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">当worker接收到命令时，它关注分配给它的批处理任务，当它完成时，它从数据库中扣除<code class="fe nf ng nh ni b">counter</code>。如果工作人员遇到任何错误，只需重试任务本身。</li><li id="2781" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">当发现<code class="fe nf ng nh ni b">counter</code>扣除计数器后为0，表示所有人都完成了任务，那么最后一个工人会通知所有接收者。</li></ol><h1 id="22e7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">组件和代码</h1><p id="9288" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">从容器的角度来看，接下来的步骤是组件和代码，但这些已经涉及到一些实现细节，每个系统面临的问题也不一样，这里就不赘述了。</p><h1 id="e058" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">设计决策</h1><p id="1b77" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我们在集装箱图中发现了许多细节。正如我在上一篇文章中所做的，我们将使用<code class="fe nf ng nh ni b">why do A instead of B</code>公式来问很多问题。</p><ol class=""><li id="5ccc" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ne ly lz ma bi translated">为什么发送方和服务器以半异步的方式(介于同步和异步之间)相互通信？</li><li id="37bf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">为什么将服务器分为编排和工作器？</li><li id="4f9c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">为什么编排和工人是完全异步的？</li><li id="d303" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">为什么工人要通知接收者？</li><li id="8031" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">也许你可以考虑一些我从未列出的问题。</li></ol><p id="7d3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些问题都要从最初的架构说起。</p><p id="1c4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一开始，我们已经有了送礼物给一个人的特征。因此，最简单的方法是执行一个for循环，通过一对一的礼物发送所有接收者，而不管接收者的号码。</p><p id="18d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当只有几个接收器时，这没问题，但是一旦接收器的数量开始增加，性能将是一个严重的挑战。在我们的测算中，投递一个人大概需要<code class="fe nf ng nh ni b">100-200 ms</code>的时间，不包括通知，也就是说当人数达到<code class="fe nf ng nh ni b">10</code>的时候，就会达到秒量级。这显然是不能接受的。</p><p id="1c44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看来批处理是不可避免的，于是有人拟定了第一个架构图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/0012a54e4f2c4769d08ec28299ab0080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*lkjVYSjjwNEJgKtUhMU65g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第一次尝试</p></figure><p id="9734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从图表中，我们可以发现编排已经出现。但是，与工作人员的通信仍然是同步的，只有当所有任务都完成时，才会发送通知。在所有任务完成之前，它不会回复用户。这似乎大大减少了性能瓶颈，但它根本没有变得更好。</p><p id="6d94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们做一个简单的数学计算。假设我们要给1000个人发礼物，我们怎么设置批量和工人数量？</p><p id="d1d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了在几秒钟内完成它，最大批量是<code class="fe nf ng nh ni b">10</code>，所以需要同时生成<code class="fe nf ng nh ni b">100</code>工人来处理一个礼物请求。这对系统来说是一个非常严格的挑战，要在一瞬间产生<code class="fe nf ng nh ni b">100</code>工人并不是一件容易的事情。因此，很难让用户以完全同步的方式等待。那么，完全异步时会发生什么呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/bc2a68e6b59a04ae497d06db2f83e6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xvFJZLlgVPS_x_8rO5WicQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第二次尝试</p></figure><p id="0109" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二次尝试中，我们将编排改为编排，这样用户可以在很短的时间内得到响应，礼物也可以顺利发送。但是，真的是这样吗？</p><p id="7189" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果中工失败了会怎么样？整个链条断了，用户可能感觉不到，没有通知。是可以的，但是对于给予者来说，中间成功工作者已经扣了用户的钱，只是通知没有发出。此外，回到用例的第一点，不允许部分成功。</p><p id="b1ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编排相比编排确实会有更好的性能和更好的可伸缩性，但是会得到更复杂的工作流控制。因此，在这个用例中，编排会更合适。</p><p id="f7c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，让我们通过编排来实现完全异步。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/1b40657d7bb8ee69fd60051b934c5898.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*o3UlbgaffqqfhnWNL_5KoA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">第三次尝试</p></figure><p id="e211" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种架构立即遇到两个问题。</p><ol class=""><li id="5091" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ne ly lz ma bi translated">谁应该发送通知？</li><li id="aaac" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">中途钱不够了怎么办？</li></ol><p id="4b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">发送通知的问题得到了很好的解决，因为在C4模型中的前一个容器视图中，实际上已经解决了向谁发送通知的问题。然而，在完全异步架构的中途处理错误基本上是不可能的。</p><p id="abd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这个原因，我们最终采用了半异步的方法。一是编排决定余额是否够发，为了避免飙车状况，直接扣钱。因此，工作人员只需要处理发送礼物，而不需要从送礼者那里扣除钱，甚至不需要检查余额。</p><h1 id="dcc5" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">错误处理和灾难恢复</h1><p id="9b1d" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在这样的架构下，有一个巨大的麻烦。</p><blockquote class="nn no np"><p id="3291" class="kw kx nq ky b kz la jr lb lc ld ju le nr lg lh li ns lk ll lm nt lo lp lq lr ij bi translated"><em class="iq">工人失败了怎么办？</em></p></blockquote><p id="fe02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果这是由于数据库拥塞造成的，重试几次后应该就没事了。否则，如果实现中出现故障，即使重试多次也无法解决。</p><p id="59c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，需要一个额外的监控系统来定期检查哪些异步任务已经失败，并重试那些可以重试的任务，或者如果通过重试无法恢复，则通知人工干预。<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/implement-event-driven-architecture-with-minimal-effort-182c3bbe5524">适用的解决方案</a>在我之前的一篇文章里已经介绍过了，这里就不做过多解释了。</p><h1 id="669c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="d5a3" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">总而言之，这个系统把送礼分成几个步骤。</p><ol class=""><li id="404d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr ne ly lz ma bi translated">用户同步发送请求，余额提前扣除。</li><li id="7857" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">所有送礼物的过程都是异步进行的。</li><li id="6fad" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr ne ly lz ma bi translated">送礼的过程最终可以一致，扣的钱等于发的钱。</li></ol><p id="a018" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将通过一个实例来讨论设计分布式系统时所面临的挑战。</p><ul class=""><li id="77ef" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">同步与异步</li><li id="8cf0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">编排与编排</li><li id="cf27" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">原子一致性与最终一致性</li></ul><p id="b3c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，这些项目也是典型分布式事务中的权衡。这些方面会显著影响整个分布式事务模型。我在之前的文章的<a class="ae kv" href="https://medium.com/interviewnoodle/distributed-transaction-introduction-1cd105c830a2" rel="noopener">中介绍了分布式事务。下一次，我将仔细研究设计分布式系统时面临的挑战和问题。</a></p></div></div>    
</body>
</html>