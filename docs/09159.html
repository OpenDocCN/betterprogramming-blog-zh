<html>
<head>
<title>9 HTTP Methods You May Want To Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你可能想知道的9种HTTP方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-http-methods-you-want-to-know-88e45a28d106?source=collection_archive---------6-----------------------#2021-07-21">https://betterprogramming.pub/9-http-methods-you-want-to-know-88e45a28d106?source=collection_archive---------6-----------------------#2021-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4801" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">创建CRUD操作</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b47c0600c0b0c62e1af475eec0e2fe6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VStEGWJRRFZXIBXpe8ZmwQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com/s/photos/http?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="1469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的另一篇文章“命名REST API端点的10个最佳实践”中，我简要地提到了HTTP。超文本传输协议，通常称为HTTP，据说是一种标准。它用于客户端和服务器之间的通信。它是如何通过客户端和服务器之间的请求-响应协议来工作的。</p><p id="c776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是如何工作的一个简单例子:</p><p id="bb20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您的浏览器(客户端)向服务器发送一个HTTP请求(针对您试图访问的任何站点)。然后服务器向客户端返回一个响应。此响应包含有关您的请求的状态信息，可能包含也可能不包含所请求的内容，具体取决于目的。</p><p id="013d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的快速示例所述，这就是请求-响应协议。HTTP有方法或者动词，比如常用的POST，GET，PUT，DELETE。这四个分别对应于创建、读取、更新和删除(CRUD)操作。正如我所说的，这些只是一些常用的可用方法，所以这意味着还有许多其他方法不经常使用。继续读下去，你可能会看到更多这样的例子。</p><p id="0cfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是我将要谈到的方法:</p><ol class=""><li id="04df" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">得到</li><li id="bfab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">邮政</li><li id="f027" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">放</li><li id="9b68" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">删除</li><li id="3064" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">头</li><li id="2766" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">修补</li><li id="05f8" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">选择</li><li id="c9e3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">连接</li><li id="eeb1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">找到；查出</li></ol><p id="62ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们的名称也区分大小写，必须使用大写字母。(我个人认为这是一个被忽视的好玩的事实。)</p><p id="9d4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们深入了解每种方法的细节之前，有一点需要知道，有些方法，比如GET和HEAD，按照惯例只具有检索功能，没有其他功能。因此，它们也被认为是安全的。</p><p id="2d05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样因为约定，其他方法，比如POST、PUT和DELETE，可能是不安全的<em class="mj">动作。</em></p><p id="2f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了安全-不安全属性，方法还具有<em class="mj">幂等</em>属性。简单来说，当一个方法被应用时，当无论应用多少次，结果都没有超出其初始应用的变化时，该方法被视为幂等的。</p><p id="6098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像GET、HEAD、PUT和DELETE这样的方法总是预期地返回相同的结果，因此它们本质上是幂等的。当然，前提是没有并发操作在同一组资源上执行。否则，结果不应偏离其最初的应用。</p><p id="849a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在您已经了解了这两个属性，让我们更深入地了解每种方法。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9caa" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">1.得到</h1><p id="eb6e" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">GET是API和网站中最常见、最广泛使用的方法。每当您试图访问一个网站时，这基本上是一种从指定的资源或服务器请求数据或检索数据的行为，您正在调用此方法。</p><p id="466e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这只是检索数据，所以它不应该对数据或任何其他数据有任何其他影响。</p><p id="ebb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是GET的头的例子。</p><p id="4fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="76ab" class="nt ms it np b gy nu nv l nw nx">GET /hello.html HTTP/1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)<br/>Host: <a class="ae ky" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>Accept-Language: en-us<br/>Accept-Encoding: gzip, deflate<br/>Connection: Keep-Alive</span></pre><p id="aff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="6856" class="nt ms it np b gy nu nv l nw nx">HTTP/1.1 200 OK<br/>Server: Apache/2.2.14 (Win32)<br/>ETag: "34aa387-d-1568eb00"<br/>Vary: Authorization,Accept<br/>Accept-Ranges: bytes<br/>Content-Length: 88<br/>Content-Type: text/html<br/>Connection: Closed</span></pre><p id="76ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应数据示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="431b" class="nt ms it np b gy nu nv l nw nx">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Hello, World!&lt;/h1&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="9b50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的例子中，我们可以看到当您请求<code class="fe ny nz oa np b">hello.html</code>时的标题，然后是您得到的响应的标题，然后是将被加载到您的浏览器上的内容响应。</p><p id="c318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">视觉上是怎么做到的？它基本上是在你的浏览器URI栏上调用<a class="ae ky" href="http://www.example.com/hello.html" rel="noopener ugc nofollow" target="_blank">www.example.com/hello.html</a>。</p><p id="2321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有道理吗？请记住，使用GET请求只是为了检索资源表示/信息，而不是以任何方式修改它。因为GET方法不会改变资源的状态，所以它被认为是一种安全的方法。</p><p id="636e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，GET APIs必须在每次被调用时产生相同的结果，无论发出多少个相同的请求。因此，GET方法也是幂等的。如果资源的状态没有被服务器上的任何其他修改方法更改，则情况确实如此。</p><p id="1230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们多次调用GET<a class="ae ky" href="http://www.example.com/customers/12345/orders" rel="noopener ugc nofollow" target="_blank">http://www.example.com/customers/12345/orders</a>，它将总是为带有<code class="fe ny nz oa np b">ID: 12345</code>的特定客户返回相同的订单，除非客户最终以某种方式改变了订单，如果是这样，从那时起结果将会不同。</p><p id="d88d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一些关于GET的其他注意事项:</p><ul class=""><li id="e977" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ob mb mc md bi translated">GET请求可以被缓存。</li><li id="4fc6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">GET请求保留在浏览器历史记录中。</li><li id="3f23" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">GET请求可以加入书签。</li><li id="e2e6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">在处理敏感数据时，不应使用GET请求。</li><li id="0122" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">GET请求有长度限制。</li><li id="2ac6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">GET请求仅用于请求数据(而非修改)。</li></ul><p id="9ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么收益呢？返回或响应状态应该是<code class="fe ny nz oa np b">200 (OK)</code>，就像上面的响应标题示例中显示的那样。</p><p id="c038" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当出现错误时，它通常会返回一个<code class="fe ny nz oa np b">404 (NOT FOUND)</code>或<code class="fe ny nz oa np b">400 (BAD REQUEST)</code>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="976f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">2.邮政</h1><p id="6cbc" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">该方法也相当常见，广泛应用于API和网站中。它用于向服务器发送数据，并创建或更新资源。</p><p id="e04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在线提交表单时，您最常遇到这种情况。在幕后，它将您的数据输入发送到服务器。文件上传也属于这一类。</p><p id="e32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，它最常用于创建新资源。这是因为还有另一种非常常用的方法来更新资源。</p><p id="4042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">POST既不安全也不幂等。它不安全，因为它会修改数据。它也不是幂等的，因为它不安全。发出两个相同的POST请求很可能会导致两个资源包含相同的信息。即使不完全相同，也会产生两种资源。</p><p id="30c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例子如下。</p><p id="8312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="abda" class="nt ms it np b gy nu nv l nw nx">POST /feedback.html HTTP/1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)<br/>Host: <a class="ae ky" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>Content-Type: text/xml; charset=utf-8<br/>Content-Length: 88<br/>Accept-Language: en-us<br/>Accept-Encoding: gzip, deflate<br/>Connection: Keep-Alive</span></pre><p id="0a42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求数据示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="cfe7" class="nt ms it np b gy nu nv l nw nx">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;string &gt;string&lt;/string&gt;</span></pre><p id="48de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f12a" class="nt ms it np b gy nu nv l nw nx">HTTP/1.1 200 OK<br/>Server: Apache/2.2.14 (Win32)<br/>ETag: "34aa387-d-1568eb00"<br/>Vary: Authorization,Accept<br/>Accept-Ranges: bytes<br/>Content-Length: 88<br/>Content-Type: text/html<br/>Connection: Closed</span></pre><p id="8b3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应数据示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5efd" class="nt ms it np b gy nu nv l nw nx">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Request Processed Successfully!&lt;/h1&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="9c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们的角度来看，我们可能会这样称呼它:POST<a class="ae ky" href="http://www.example.com/feedback.html" rel="noopener ugc nofollow" target="_blank">www.example.com/feedback.html</a>。</p><p id="7ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于回复内容，您可能会收到也可能不会收到，这取决于创建者。但是，您仍然会收到响应标头，以指示它是否是一个成功的请求。</p><p id="655b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于POST方法的其他一些注意事项:</p><ul class=""><li id="4cb9" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ob mb mc md bi translated">从不缓存POST请求。</li><li id="e503" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">发布请求不会保留在浏览器历史记录中。</li><li id="4b1a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">发布请求不能加入书签。</li><li id="215e" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">POST请求对数据长度没有限制。</li></ul><p id="29eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对POST的响应也是不可缓存的，除非该响应包括适当的缓存控制或<code class="fe ny nz oa np b">Expires</code>头字段。</p><p id="9378" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于返回，它可以返回以下三种HTTP状态:</p><ul class=""><li id="2da3" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ob mb mc md bi translated"><code class="fe ny nz oa np b">201 (Created)</code>带有一个<code class="fe ny nz oa np b">Location</code>标题，链接到新创建的资源</li><li id="0920" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated"><code class="fe ny nz oa np b">200 (OK)</code>，这可能不会产生可被URI识别的资源</li><li id="d626" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated"><code class="fe ny nz oa np b">204(No Content)</code>，这也是另一个明确表示没有资源返回的</li></ul><p id="d8eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于错误情况，如果资源已经存在，它可以返回<code class="fe ny nz oa np b">404 (Not Found)</code>或<code class="fe ny nz oa np b">409 (Conflict)</code>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="d0eb" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">3.放</h1><p id="b8bd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">PUT是另一种在API和网站中也非常常见和广泛使用的方法。它用于向服务器发送数据，并创建或更新资源。</p><p id="e44a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，还记得我说过POST更适合用于创建资源吗？PUT方法主要用于更新现有资源。如果要更新的资源不存在，那么API可以决定是否创建新的资源。</p><p id="7b20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为它修改了服务器上的状态，所以它是不安全的。但是，它是幂等的。这就是POST和PUT的区别。这是因为多次调用PUT请求总是会产生相同的结果。相比之下，重复调用POST请求会产生多次创建相同资源的副作用。</p><p id="6150" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果对资源调用PUT使资源内的计数器递增，则该调用不再是等幂的。有时会发生这种情况，它可能被视为不是等幂的。但是，建议让PUT请求保持幂等，并强烈建议对非幂等请求使用POST。</p><p id="8adc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是PUT的例子。</p><p id="c552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1d5e" class="nt ms it np b gy nu nv l nw nx">PUT /hello.html HTTP/1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)<br/>Host: <a class="ae ky" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>Accept-Language: en-us<br/>Connection: Keep-Alive<br/>Content-type: text/html<br/>Content-Length: 182</span></pre><p id="6c2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求数据示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="1c2e" class="nt ms it np b gy nu nv l nw nx">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Hello, World!&lt;/h1&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f1f5" class="nt ms it np b gy nu nv l nw nx">HTTP/1.1 201 Created<br/>Server: Apache/2.2.14 (Win32)<br/>Content-type: text/html<br/>Content-length: 30<br/>Connection: Closed</span></pre><p id="9535" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应数据示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="678f" class="nt ms it np b gy nu nv l nw nx">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;The file was created.&lt;/h1&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="ed4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我们的角度来看，调用大概是这样的:把<a class="ae ky" href="http://www.example.com/hello.html" rel="noopener ugc nofollow" target="_blank">www.example.com/hello.html</a>。</p><p id="c969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像POST一样，响应中的主体也是可选的。PUT方法也是不可缓存的。</p><p id="b348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于HTTP状态，成功案例将相应地通知用户:</p><ul class=""><li id="cf3a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ob mb mc md bi translated"><code class="fe ny nz oa np b">201 (Created)</code>如果创建了资源</li><li id="b698" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated"><code class="fe ny nz oa np b">200 (OK)</code>如果现有资源被更新并且可能带有内容响应</li><li id="bc6a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated"><code class="fe ny nz oa np b">204 (No Content)</code>如果现有资源被更新而没有内容</li></ul><p id="8064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于错误情况，如果没有找到输入id或者输入ID无效，可以返回<code class="fe ny nz oa np b">404 (Not Found)</code>。否则，您可以返回<code class="fe ny nz oa np b">405 (Method Not Allowed)</code>，除非您想要更新/替换整个集合中的所有资源。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="9713" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">4.删除</h1><p id="660f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">删除是另一种在API和网站中非常普遍和广泛使用的方法。它用于删除指定的资源。</p><p id="9561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">DELETE方法用于请求服务器删除位于给定URL指定位置的文件。这个很简单。</p><p id="0cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">删除操作是幂等的。如果删除资源，它将被删除。对该资源反复调用DELETE以同样的方式结束:资源消失了。</p><p id="736c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，如果调用DELETE减少了一个计数器(在资源内)，那么DELETE调用不再是等幂的。这是因为数据已被更改。但是，您通常不会遇到DELETE的这种用法。</p><p id="3897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是它的例子。</p><p id="3a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="56ec" class="nt ms it np b gy nu nv l nw nx">DELETE /hello.html HTTP/1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)<br/>Host: <a class="ae ky" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>Accept-Language: en-us<br/>Connection: Keep-Alive</span></pre><p id="1606" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c983" class="nt ms it np b gy nu nv l nw nx">Response header example:<br/>HTTP/1.1 200 OK<br/>Server: Apache/2.2.14 (Win32)<br/>Content-type: text/html<br/>Content-length: 30<br/>Connection: Closed</span></pre><p id="4bc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">响应数据示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="873d" class="nt ms it np b gy nu nv l nw nx">&lt;html&gt;<br/>&lt;body&gt;<br/>&lt;h1&gt;Resource deleted.&lt;/h1&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="538e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此的调用大致如下:删除<a class="ae ky" href="http://www.example.com/hello.html" rel="noopener ugc nofollow" target="_blank">www.example.com/hello.html</a>。</p><p id="2391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法也不可缓存。</p><p id="2050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成功案例的三种可能回报是:</p><ul class=""><li id="5ae2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ob mb mc md bi translated"><code class="fe ny nz oa np b">200 (OK)</code>带应答体</li><li id="654d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated"><code class="fe ny nz oa np b">204 (No Content)</code>无应答体</li><li id="9e53" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated"><code class="fe ny nz oa np b">202 (Accepted)</code>如果动作已经排队</li></ul><p id="e704" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当第二次调用资源上的DELETE时，它通常会返回一个<code class="fe ny nz oa np b">404 (NOT FOUND)</code>,因为它已经被删除了，因此无法再找到。</p><p id="dbc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于某些人来说，这使得删除操作不再是幂等的。但是，资源的最终状态是相同的。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="cf60" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">5.头</h1><p id="5395" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">就我个人而言，我很少看到这种方法被使用。但是，它的行为类似于GET方法，只是它没有响应体。</p><p id="742a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HEAD方法在功能上类似于GET，只是服务器回复时没有实体主体(基本上只有头信息)。服务器不发送报头后的任何数据。换句话说，如果GET <code class="fe ny nz oa np b">/orders</code>返回订单列表，那么HEAD <code class="fe ny nz oa np b">/orders</code>将发出相同的请求，但不会返回任何列表。</p><p id="2d66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">HEAD请求对于在实际发出GET请求之前检查GET请求将返回什么非常有用，比如在下载大文件或响应正文之前。</p><p id="5e3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它也是一个安全的幂等方法，就像GET方法一样。</p><p id="7de8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是HEAD的例子。</p><p id="5207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="0708" class="nt ms it np b gy nu nv l nw nx">HEAD /hello.html HTTP/1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)<br/>Host: <a class="ae ky" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>Accept-Language: en-us<br/>Accept-Encoding: gzip, deflate<br/>Connection: Keep-Alive</span></pre><p id="e1a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b9c1" class="nt ms it np b gy nu nv l nw nx">HTTP/1.1 200 OK<br/>Server: Apache/2.2.14 (Win32)<br/>ETag: "34aa387-d-1568eb00"<br/>Vary: Authorization,Accept<br/>Accept-Ranges: bytes<br/>Content-Length: 88<br/>Content-Type: text/html<br/>Connection: Closed</span></pre><p id="e8e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无响应数据示例。</p><p id="959b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于HTTP状态，它们与GET方法中的状态非常相似。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="590c" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">6.修补</h1><p id="e3f4" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这也是另一个我不常看到的，但知道它还是很好的。它也用于更新，就像游戏中的“补丁”一样。然而，这和PUT是有区别的，PATCH更像是更新-修改，而PUT更像是更新-替换类型的更新。</p><p id="b61d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，补丁请求只需要包含对资源的更改，而不是整个资源。它应用差异(部分更新)而不是替换整个资源。同时，如果您要替换整个资源，则使用PUT。</p><p id="b632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">补丁既不安全也不幂等。然而，补丁请求可以以幂等的方式发出，这也有助于防止在相似的时间范围内同一资源上的两个补丁请求之间的冲突产生不良结果。</p><p id="34e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于示例，让我们看一下数据内容，以便更好地理解。假设我们有这样的数据:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="b3f5" class="nt ms it np b gy nu nv l nw nx">{<br/>“name” : “Mark”,<br/>“isUser” : false,<br/>“numberOfDogs” : 8<br/>}</span></pre><p id="ade6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们想用这个来更新它:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="9db9" class="nt ms it np b gy nu nv l nw nx">{<br/>“numberOfDogs” : 10,<br/>“numberOfCats” : 0<br/>}</span></pre><p id="aedd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果大概是这样的:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="53fc" class="nt ms it np b gy nu nv l nw nx">{<br/>“name” : “Mark”,<br/>“isUser” : false,<br/>“numberOfDogs” : 10,<br/>“numberOfCats” : 0<br/>}</span></pre><p id="7994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意它是如何修补、更新旧值和添加新字段的。</p><p id="c536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于PUT，使用相同的现有数据和输入数据，输出请求将只包含:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5b34" class="nt ms it np b gy nu nv l nw nx">{<br/>“numberOfDogs” : 10,<br/>“numberOfCats” : 0<br/>}</span></pre><p id="a68a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为PUT更像是更新-替换，而PATCH更像是更新-修改。</p><p id="db3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在不存在的资源上发送修补请求将会失败，并且不会创建任何资源。</p><p id="ed48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，如果您决定在应用程序中使用补丁API，会遇到一些列出的挑战:</p><ul class=""><li id="cf87" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ob mb mc md bi translated">浏览器、服务器和web应用程序框架对补丁的支持并不普遍。IE8、PHP、Tomcat、Django和许多其他软件都缺少或中断了对它的支持。</li><li id="4c75" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ob mb mc md bi translated">补丁请求的有效负载不像上传请求那样简单。</li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="ee16" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">7.选择</h1><p id="b7b2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">这个我个人只用了一次。它用于请求有关可用通信选项的信息。它描述了目标资源的通信选项。</p><p id="52cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，您可以在指定的URL上找到web服务器支持的HTTP方法和其他选项的列表(星号是指整个服务器，还是只与URL相关的特定服务器)。</p><p id="5d5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例请求主机<code class="fe ny nz oa np b">&lt;host&gt;</code>上运行的web服务器支持的方法列表:</p><p id="5473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="f052" class="nt ms it np b gy nu nv l nw nx">OPTIONS * HTTP/1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span></pre><p id="7abf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="4a6f" class="nt ms it np b gy nu nv l nw nx">HTTP/1.1 204 No Content<br/>Server: Apache/2.2.14 (Win32)<br/>Allow: GET,HEAD,POST,OPTIONS<br/>Content-Type: httpd/unix-directory</span></pre><p id="454f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个方法是安全的、等幂的，并且不可缓存。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="5390" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">8.连接</h1><p id="b644" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">如果您使用该工具，则无法在Postman中找到此方法。它的用途是建立到由给定URI标识的服务器的隧道。</p><p id="f5c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它基本上被客户端用来通过HTTP建立到web服务器的网络连接。就是这样。</p><p id="6c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下示例请求与主机<code class="fe ny nz oa np b">&lt;host&gt;</code>上运行的web服务器建立连接:</p><p id="377b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="5b27" class="nt ms it np b gy nu nv l nw nx">CONNECT www.example.com HTTP/1.1<br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span></pre><p id="9e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="e298" class="nt ms it np b gy nu nv l nw nx">HTTP/1.1 200 Connection established<br/>Server: Apache/2.2.14 (Win32)</span></pre><p id="7529" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">标题状态返回仅仅是<code class="fe ny nz oa np b">200 “Connection Established”</code>。我想说它非常像选项，标题看起来非常简单明了。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="215f" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">9.找到；查出</h1><p id="2dee" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">此方法沿着到目标资源的路径执行消息环回测试。</p><p id="2b26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，它用于将HTTP请求的内容回显给请求者，以便在开发时进行测试/调试。</p><p id="71ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可能看起来像下面这样。</p><p id="282f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请求标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="2c51" class="nt ms it np b gy nu nv l nw nx">TRACE / HTTP/1.1<br/>Host: <a class="ae ky" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span></pre><p id="215d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回复标题示例:</p><pre class="kj kk kl km gt no np nq nr aw ns bi"><span id="c751" class="nt ms it np b gy nu nv l nw nx">HTTP/1.1 200 OK<br/>Server: Apache/2.2.14 (Win32)<br/>Connection: close<br/>Content-Type: message/http<br/>Content-Length: 39</span><span id="b442" class="nt ms it np b gy oc nv l nw nx">TRACE / HTTP/1.1<br/>Host: <a class="ae ky" href="http://www.example.com" rel="noopener ugc nofollow" target="_blank">www.example.com</a><br/>User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="333e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">结论</h1><p id="003d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在创建API时，有时了解每种HTTP方法的差异是有好处的。这是为了创建具有更准确目的的更准确的API。通常初学者容易混淆所有这些，因此他们只是对所有东西都使用GET，这当然会在处理敏感数据或任何数据时带来安全问题。有时候，随着你的进步，你仍然会对某些方法感到困惑，比如什么时候使用哪种方法。</p><p id="2fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你已经从这篇文章中学到了一些东西，受到了启发。如果你觉得这有帮助，请随意评论或与其他人分享。</p><p id="217a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>