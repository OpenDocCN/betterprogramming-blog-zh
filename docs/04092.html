<html>
<head>
<title>How to Write a Timestamp-Based Task Scheduler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写一个基于时间戳的任务调度程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-write-a-timestamp-based-task-scheduler-1312abe9e6d?source=collection_archive---------13-----------------------#2020-03-23">https://betterprogramming.pub/how-to-write-a-timestamp-based-task-scheduler-1312abe9e6d?source=collection_archive---------13-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8ad1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写一个分布式、可水平扩展的任务调度程序，以接收任务并在预定义的时间运行</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/16a3e4950066c65b57c8affc8dfe9040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbVCnCII6FAjhiVQMHKnwQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@curtismacnewton?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">柯蒂斯·麦克牛顿</a>在<a class="ae ky" href="https://unsplash.com/s/photos/schedule?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="b0df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有时会觉得在我们的设计架构中需要一个<a class="ae ky" href="https://microservices.io/" rel="noopener ugc nofollow" target="_blank">服务</a>，它可以为我们接收任务，并确保它们在首选的时间戳得到保证的执行。任务可以是任何事情，从向客户发送电子邮件通知和文本消息，到点击第三方API，到安排另一个任务，或者可以简单到在终端上打印消息。</p><p id="8219" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任务调度程序应该做什么:</p><ul class=""><li id="91c1" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">接收带有预定义时间戳的任务</li><li id="126a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">确保每个任务在给定的时间戳被触发</li><li id="f323" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">扩展大量摄取任务</li><li id="d446" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">避免<a class="ae ky" href="https://en.wikipedia.org/wiki/Single_point_of_failure" rel="noopener ugc nofollow" target="_blank">spof</a>，如果有的话</li><li id="2575" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">避免瓶颈</li></ul><p id="01f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">等等！我们真的需要它吗？</p><p id="a0bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看<a class="ae ky" href="https://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files/" rel="noopener ugc nofollow" target="_blank"> Linux crons </a>能否解决这个问题。您所需要做的就是准备好您的<code class="fe mj mk ml mm b">script.sh</code>，然后将这些代码粘贴到我们的crontab ( <code class="fe mj mk ml mm b">crontab -e</code>)上:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="71c5" class="mr ms it mm b gy mt mu l mv mw">* * * * * ~/path/script.sh &gt;&gt; ~/path/script.log</span></pre><p id="91b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mj mk ml mm b"><a class="ae ky" href="https://crontab.guru/" rel="noopener ugc nofollow" target="_blank">* * * * *</a></code> <strong class="lb iu"> </strong>帮助你决定脚本运行的时间戳(以及重复次数)。该脚本将在准确的时间戳重复执行。直到这里，一切都很好。</p><p id="7e9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有一个问题。如果这台机器停机了，或者有太多的任务需要单个硬件来扩展，该怎么办？</p><p id="93ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Crontabs与可执行脚本配合得非常好。但仅此而已。在分布式环境中，或者当您需要重试策略时，它们可能不起作用。它们可以充当整个系统的SPOFs。假设我们需要在一个上午的时间段向客户发送数千条消息，不幸的是，硬件出现故障或者出现连接阻塞？任何一天只有一台机器都不是一个好主意。这个问题需要检查一下。</p><p id="2ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何解决这个问题呢？</p><p id="f340" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将设计自己的内部调度程序。它将是一个水平可扩展的独立微服务，能够大规模接收任务，暂时保存它们，并在给定的时间戳执行这些任务。让我们开始第一步。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="9d31" class="ne ms it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">1.将任务纳入系统</h1><p id="40cc" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">一项任务可以有多种类型，每一种都被指定根据类型做不同的事情。为了简单起见，假设任务结构只是一条消息以及使用该消息的时间戳。用户提交请求后:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="a4dc" class="mr ms it mm b gy mt mu l mv mw">curl --location --request POST '{url}/tasks/submit' \<br/>--data-raw '{<br/> "message":"This is a demo task",<br/> "timestamp":"2020-03-10T00:42:30"<br/>}'</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/aa4990681fb66b5e74ab1ea425905e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u8lDlDKhP1Sx1Al-XS9VbA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将任务纳入系统</p></figure><p id="cd65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们必须将唯一的<code class="fe mj mk ml mm b">TaskId</code>返回给用户。其思想是<a class="ae ky" href="https://blog.pythian.com/case-auto-increment-mysql/" rel="noopener ugc nofollow" target="_blank">使用UUIDs，而不是自动增量id</a>。一旦请求被正确验证，我们必须通过发回UUID作为响应的一部分来满足它:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="0a37" class="mr ms it mm b gy mt mu l mv mw">{<br/>    "status": {<br/>        "status": "SUCCEDED",<br/>        "count": 1<br/>    },<br/>    "data": [<br/>        {<br/>            "id": "21021f23-8df7-4bbf-a169-1227d3e49c63",<br/>            "message": "drredecff",<br/>            "timestamp": "2020-03-10T00:42:30.000+0000",<br/>            "version": 0,<br/>            "status": "SUBMITTED"<br/>        }<br/>    ]<br/>}</span></pre><p id="5c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有持久的数据存储，在那里我们已经在<code class="fe mj mk ml mm b">SUBMITTED</code>状态下完成了请求的任务。现在，一旦时机成熟，我们如何对任务进行投票？</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="790e" class="ne ms it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">2.在给定的时间戳轮询任务</h1><p id="d1b5" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">这是练习中最棘手的部分。在一段时间间隔(可配置)后，我们将继续重复运行这个轮询器(一组线程)，以获取时间戳与当前时间戳相比已经过去的所有线程。这个轮询器将从一个负责获取预定义任务批的节点(所有节点都将这样做)产生多个线程。然后，它将在预定时间后重新运行。我们需要保持批量、线程数和间隔可配置。让我们看看我们的<code class="fe mj mk ml mm b">application.properties</code>文件的一部分:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="28f1" class="mr ms it mm b gy mt mu l mv mw">thread.count = 4<br/>thread.interval = 20000<br/>batch.size = 10000<br/></span></pre><p id="c10a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这仅仅意味着我们需要启动四个线程，每个线程将在20，000毫秒后运行，并获取一批10，000个任务。下面是我们在服务启动时如何生成这些线程的一个快速实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="14f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一<code class="fe mj mk ml mm b">TaskProcessor</code>会是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6e54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="od"> </em> <code class="fe mj mk ml mm b">process()</code> <em class="od"> </em>方法应标记为<code class="fe mj mk ml mm b">Transactional</code>，因为多个线程(可从<code class="fe mj mk ml mm b"><em class="od">.</em>properties</code>文件配置)将从单个节点一次轮询数据库。</p><p id="e904" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了以防万一，我们将保留上升时间<code class="fe mj mk ml mm b">ATOMIC</code>以避免脏读。一旦任务被线程获取，在同一事务中会被标记为<code class="fe mj mk ml mm b">IN_PROGRESS</code>。</p><p id="4b3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们希望几个线程从数据库中提取任务，所以我们需要找到批处理。一个<code class="fe mj mk ml mm b">Cursor</code> <em class="od"> </em>类可以为单个节点服务，将任务分成多个批次:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="06a8" class="mr ms it mm b gy mt mu l mv mw">Cursor =&gt; Query [Start Pointer, Batch Size]</span></pre><p id="93d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个<code class="fe mj mk ml mm b">Cursor</code><em class="od"/>(struct with<a class="ae ky" href="https://stackoverflow.com/questions/32634280/how-does-compare-and-set-in-atomicinteger-works" rel="noopener ugc nofollow" target="_blank">CAS</a>implementation<em class="od">)</em>类来更新单个线程的查询限制，因为我们确实希望其他线程并行访问其他批处理。</p><p id="c83d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们进行这种轮询时，日志看起来有点像这样:</p><pre class="kj kk kl km gt mn mm mo mp aw mq bi"><span id="d388" class="mr ms it mm b gy mt mu l mv mw">2020-03-22 21:35:10.401  INFO 1378 --- [pool-3-thread-4] c.taskschedular.processor.TaskProcessor  : Thread pool-3-thread-4started/resumed ...<br/>2020-03-22 21:35:10.401  INFO 1378 --- [pool-3-thread-1] c.taskschedular.processor.TaskProcessor  : Thread pool-3-thread-1started/resumed ...<br/>2020-03-22 21:35:10.401  INFO 1378 --- [pool-3-thread-3] c.taskschedular.processor.TaskProcessor  : Thread pool-3-thread-3started/resumed ...<br/>2020-03-22 21:35:10.402  INFO 1378 --- [pool-3-thread-1] com.taskschedular.dao.impl.TaskDaoImpl   : Querying Tasks from Limit : (0,20) Before Sun Mar 22 21:35:10 IST 2020<br/>2020-03-22 21:35:10.402  INFO 1378 --- [pool-3-thread-4] com.taskschedular.dao.impl.TaskDaoImpl   : Querying Tasks from Limit : (40,20) Before Sun Mar 22 21:35:10 IST 2020</span></pre><p id="b059" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们扩展了线程的数量(对于单个节点)，我们也将能够扩展任务的轮询。但是，当CPU内核/虚拟机配置出现时，可能会有一些警告。</p><p id="357d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将任务委托给作为分布式系统一部分的其他节点，我们可以保留一个普通的(如Redis键)来不时地更新<code class="fe mj mk ml mm b">Start Pointer</code><em class="od"/>(<code class="fe mj mk ml mm b">REDIS_INTERVAL</code>)<em class="od">。</em>此外，我们可以配置光标是否从Redis中获取初始值。<code class="fe mj mk ml mm b">CursorConfig</code> <em class="od"> </em>类的快照可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="347d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了记忆中的任务，我们如何大规模地处理它们？在给定的时间框架内可能有太多的任务，而在一天的其他时间内可能有太少的任务。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="a02c" class="ne ms it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">3.执行任务</h1><p id="4345" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">解决这个问题以及实现并行扩展的最简单方法是归结到发布-订阅模型。一旦我们获取了确保没有重复的消息，我们可以简单地放入一个消息队列(让我们使用<a class="ae ky" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>)来确保:</p><ul class=""><li id="f6d7" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">一旦发布者线程将消息放入交换中，绑定队列将接收该消息。</li><li id="fbde" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">一旦队列收到消息，它会尽快将消息传递给其中一个并发消费者。(消息不能发送两次，一旦发送，就应该有一个正确的ACK。)</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/f3ee76d577a0b2fb97d10495b2b0f8ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ua_uKKgJoX6zmniAuAKkPw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">轮询/处理任务</p></figure><p id="a102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在使用这种模式来根据我们的偏好调整我们的消费者。此外，提取-执行duo可以分离出来。在消费者方面，当我们收到消息时，我们可以自由地执行它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><p id="583e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法可以适应任务的重新运行(可重复的任务)。我们只需要调用刚刚执行的任务的<code class="fe mj mk ml mm b">SubmitAPI</code>调用。任务的摄取是相当可伸缩的，因为一个任务独立于另一个任务。(这给我们留下了使用非关系数据库的选择，但那是以后的事了。)此外，poller不是在一台机器上运行，因此不存在SPOF的可能性。</p><p id="8968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ORM ( <code class="fe mj mk ml mm b">Hibernate</code>)维护了适当的原子性，以避免任何脏读(重复的消息被推到队列中)。我们还可以微调时间间隔(轮询器重新运行)和要获取的任务批次，因为唯一需要做的事情是配置<code class="fe mj mk ml mm b">application.properties</code> <em class="od"> </em>文件。此外，我们可以通过配置我们的消费者来扩展作业的消耗(在执行时)。</p></div><div class="ab cl mx my hx mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="im in io ip iq"><h1 id="153e" class="ne ms it bd nf ng nh ni nj nk nl nm nn jz no ka np kc nq kd nr kf ns kg nt nu bi translated">资源</h1><p id="eae5" class="pw-post-body-paragraph kz la it lb b lc nv ju le lf nw jx lh li nx lk ll lm ny lo lp lq nz ls lt lu im bi translated">你可以在GitHub 上找到<a class="ae ky" href="https://github.com/xero812/TaskSchedulerService" rel="noopener ugc nofollow" target="_blank">的完整实现。</a></p><p id="6c4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他参考:</p><p id="77ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Single_point_of_failure" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Single_point_of_failure</a></p><p id="261a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.howtogeek.com/101288/how-to-schedule-tasks-on-linux-an-introduction-to-crontab-files/" rel="noopener ugc nofollow" target="_blank">https://www . how togeek . com/101288/how-to-schedule-tasks-on-Linux-an-introduction-to-crontab-files/</a></p><p id="d3ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://blog.pythian.com/case-auto-increment-mysql/" rel="noopener ugc nofollow" target="_blank">https://blog.pythian.com/case-auto-increment-mysql/</a></p><p id="d565" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://stackoverflow.com/questions/32634280/how-does-compare-and-set-in-atomicinteger-works" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/32634280/how-does-compare-and-set-in-atomic integer-works</a></p><p id="c4fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://www.rabbitmq.com/amqp-0-9-1-quickref.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/amqp-0-9-1-quickref.html</a></p></div></div>    
</body>
</html>