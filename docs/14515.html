<html>
<head>
<title>Build a Custom React Component Library With Storybook 7 Beta and Vite 4 in 2023</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2023年用Storybook 7 Beta和Vite 4构建自定义React组件库</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-custom-react-component-library-with-storybook-7-beta-and-vite-4-in-2023-c52db4d733c0?source=collection_archive---------1-----------------------#2022-12-31">https://betterprogramming.pub/build-a-custom-react-component-library-with-storybook-7-beta-and-vite-4-in-2023-c52db4d733c0?source=collection_archive---------1-----------------------#2022-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2c4a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用React中的Storybook 7和Vite 4创建可重用组件库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/23629d871298b2b43f18c9a8716b6418.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pljMZgpye8Cj7AEeAFqj-g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">React组件库盒—中途</p></figure><h1 id="48f4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">什么是组件库？</h1><p id="96b1" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">React组件库是可重用组件的集合，可用于快速构建用户界面。它们通常作为NPM包分发，可以包含各种不同类型的组件，如按钮、表单元素和布局组件。使用React组件库有助于加快开发速度，并确保用户界面是一致的，并遵循既定的设计模式。</p><h1 id="cc1c" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">使用组件库的优势</h1><ol class=""><li id="4415" class="mj mk iq lp b lq lr lt lu lw ml ma mm me mn mi mo mp mq mr bi translated">可重用组件:组件库提供了一组预构建的、可重用的组件，这些组件可以轻松地集成到许多应用程序中，从而节省时间和精力。</li><li id="8a8b" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">一致性:通过使用组件库，更容易确保用户界面在应用程序的不同部分保持一致。这可以改善整体用户体验，使用户更容易浏览应用程序。</li><li id="2d76" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">提高性能:设计良好的组件库可以通过提供针对性能进行优化的组件来提高应用程序的性能。</li><li id="fe3b" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">社区支持:许多组件库有一个庞大的用户和贡献者社区，这意味着通常有大量的资源和支持可用于使用该库。</li><li id="21cd" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mo mp mq mr bi translated">改进的可维护性:使用组件库有助于提高应用程序的可维护性，因为它提供了一组稳定的、经过良好测试的组件，可以随着时间的推移轻松地进行更新和维护。</li></ol><h1 id="c705" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">为什么您可能不需要创建自己的组件库</h1><p id="47c0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">无论你是公司还是个人，创建一个组件库都需要时间，所以考虑时间投资以及对你的项目或组织来说是否值得是很重要的。从头开始构建需要大量的工作，但是利用现有的库或框架可以减少工作量。考虑开发组件库的好处是否超过时间投入。对于有多个开发人员的大型长期项目，组件库可以节省时间并提高一致性。对于生命周期较短的小型项目，这可能不值得努力。</p><h1 id="7c31" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">项目设置概述</h1><ul class=""><li id="d381" class="mj mk iq lp b lq lr lt lu lw ml ma mm me mn mi mx mp mq mr bi translated">用TypeScript设置Vite React项目</li><li id="6b09" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated">用React和TypeScript设置故事书</li><li id="5bac" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated">使用Tailwind设置样式并导入生成的文件</li><li id="ea28" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated">设置库构建脚本和故事书构建</li><li id="0dca" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated">安装程序包发布</li></ul><p id="45d4" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">设置Vite React project with TypeScript确保将<code class="fe nd ne nf ng b">react-component-library</code>重命名为您想要的库名称</p><p id="a11c" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">npm create vite@latest react-component-library -- --template react-ts</code></p><p id="efff" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><strong class="lp ir">注意:</strong>如果你使用的是NPM 6或更低版本，那么你可能不需要额外的破折号(<code class="fe nd ne nf ng b">--</code>)</p><p id="c6af" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">一旦将Vite app cd生成到目录中，</p><p id="edaf" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">初始化故事书测试版:</p><p id="1f1b" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">npx sb@next init</code></p><h1 id="8716" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">设置顺风</h1><p id="1a0e" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">如果你从未用过顺风，以下是我的电梯营销:</p><p id="e56b" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">Tailwind是一个实用优先的CSS框架，与传统的CSS解决方案相比，它提供了许多优势。</p><p id="9200" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">与提供一组预定义组件和样式的传统CSS框架不同，Tailwind使用“实用程序优先”的方法，提供底层实用程序类，如<code class="fe nd ne nf ng b">text-red-600</code>或<code class="fe nd ne nf ng b">p-4</code>，它们可以组合起来构建复杂的组件。</p><p id="d8a7" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">这种方法允许更大的灵活性和定制，允许开发人员快速创建定制组件，而无需编写定制CSS。这也使得跟踪样式变得更加容易，因为所有的样式规则都在一个文件中定义。Tailwind的捆绑系统被设计成只包含项目中使用的类。</p><p id="3dc5" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">当生成Tailwind配置文件时，它会创建一个所有可用类的列表，当生成Tailwind CSS包时，只有项目中引用的类才会包含在包中，从而减小包的大小并使其更有效。</p><p id="be4d" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">这使得开发人员可以使用Tailwind，而不必担心包含未使用的类或增加包的大小。此外，Tailwind是完全可定制的，并支持主题化，因此开发人员可以轻松地为他们的应用程序创建自己的定制主题。</p><p id="6441" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">为顺风安装必要的软件包:</p><p id="19b5" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">npm install -D tailwindcss postcss autoprefixer concurrently</code></p><p id="8c9d" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">一旦安装了包，我们需要初始化Tailwind:</p><p id="f598" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">npx tailwindcss init</code></p><p id="1ad2" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">它将生成一个<code class="fe nd ne nf ng b">tailwind.config.js</code>，并需要更新为以下内容:</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="3135" class="nl kw iq ng b be nm nn l no np">module.exports = {<br/>  content: [<br/>    "./app/**/*.{js,ts,jsx,tsx}",<br/>  ],<br/>  theme: {<br/>    extend: {},<br/>  },<br/>  plugins: [],<br/>}</span></pre><p id="1fb3" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">创建一个文件<code class="fe nd ne nf ng b">src/tailwind-entry.css</code>并添加以下内容:</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="4fb3" class="nl kw iq ng b be nm nn l no np">@tailwind base;<br/>@tailwind components;<br/>@tailwind utilities;</span></pre><p id="2e9e" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">接下来，我们需要更新<code class="fe nd ne nf ng b">package.json</code>脚本，它们应该如下所示:</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="12b1" class="nl kw iq ng b be nm nn l no np">"scripts": {<br/>    "build": "concurrently \\"npm run build:css\\" \\"tsc --emitDeclarationOnly &amp;&amp; vite build\\"",<br/>    "build:css": "tailwindcss -m -i ./src/tailwind-entry.css -o ./dist/index.css",<br/>    "storybook": "concurrently \\"npm run storybook:css\\" \\"storybook dev -p 6006\\"",<br/>    "storybook:css": "tailwindcss -w -i ./src/tailwind-entry.css -o ./src/index.css",<br/>    "build-storybook": "concurrently \\"npm run build-storybook:css\\" \\"storybook build\\"",<br/>    "build-storybook:css": "tailwindcss -m -i ./src/tailwind-entry.css -o ./src/index.css"<br/>  },</span></pre><p id="2fc5" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">让我们回顾一下这里发生了什么:</p><p id="8fb5" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">由于我们正在构建一个组件库，你会注意到我们删除了<code class="fe nd ne nf ng b">dev</code>和<code class="fe nd ne nf ng b">preview</code>脚本，这将是运行Vite应用程序，这被Storybook所取代Storybook 7运行Vite。</p><p id="1b8b" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">你会注意到<code class="fe nd ne nf ng b">:css</code>脚本，在运行Storybook的情况下，它将启动一个观察器，当添加新的Tailwind类时，该观察器将生成一个新的CSS文件。构建脚本将为构建创建CSS包。在开发过程中，Tailwind接收<code class="fe nd ne nf ng b">./src/tailwind-entry.css</code>文件并正常输出<code class="fe nd ne nf ng b">./src/index.css</code>。在<code class="fe nd ne nf ng b">./src/tailwind-entry.css</code>文件中，你会看到<code class="fe nd ne nf ng b">@tailwind base;</code>,它是Tailwind的规格化器。</p><p id="7b89" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">CSS规范器是一组规则，用来确保所有的HTML元素在不同的浏览器中保持一致。它的工作原理是将应用于HTML元素的所有默认样式(如边距、填充和字体大小)重置为一致的基线。</p><p id="28c2" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">这有助于确保无论在哪个浏览器中查看，用户界面看起来都是一样的。我正在将它添加到项目中，但你可能不一定想要它，我只是想确保你知道它正在被添加。</p><p id="3e66" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">现在我们正在生成顺风CSS文件，我们需要将该文件导入到Storybook stories中，为了做到这一点，我们需要更新<code class="fe nd ne nf ng b">.storybook/preview.js</code>文件并导入生成的CSS文件，<code class="fe nd ne nf ng b">preview.js</code>现在应该如下所示:</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="fae0" class="nl kw iq ng b be nm nn l no np">import '../src/index.css';<br/><br/>export const parameters = {<br/>  actions: { argTypesRegex: "^on[A-Z].*" },<br/>  controls: {<br/>    matchers: {<br/>      color: /(background|color)$/i,<br/>      date: /Date$/,<br/>    },<br/>  },<br/>}</span></pre><p id="4a49" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">.storybook/main.js</code>文件用于配置Storybook的各个方面，比如源文件的位置、构建过程和应该使用的附加组件。我们的<code class="fe nd ne nf ng b">.storybook/main.js</code>文件应该是这样的:</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="f64a" class="nl kw iq ng b be nm nn l no np">module.exports = {<br/>  "stories": [<br/>    "../src/**/*.mdx",<br/>    "../src/**/*.stories.@(js|jsx|ts|tsx)"<br/>  ],<br/>  "addons": [<br/>    "@storybook/addon-links",<br/>    "@storybook/addon-essentials",<br/>    "@storybook/addon-interactions"<br/>  ],<br/>  "framework": {<br/>    "name": "@storybook/react-vite",<br/>    "options": {}<br/>  },<br/>  "docs": {<br/>    "docsPage": true<br/>  }<br/>}</span></pre><p id="39ee" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><strong class="lp ir">注意:</strong>设置<code class="fe nd ne nf ng b">framework &gt; name</code>被设置为<code class="fe nd ne nf ng b">"@storybook/react-vite"</code>这是启动Storybook时使Vite运行的原因。</p><h1 id="10a6" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Package.json设置</h1><p id="21dd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在<code class="fe nd ne nf ng b">package.json</code>中，我们想要添加一个名为<code class="fe nd ne nf ng b">peerDependencies</code>的新字段，并将<code class="fe nd ne nf ng b">react</code>和<code class="fe nd ne nf ng b">react-dom</code>从<code class="fe nd ne nf ng b">dependencies</code>移至<code class="fe nd ne nf ng b">peerDependencies</code>。NPM对等依赖项是程序包所需的程序包，但在安装程序包时不会自动安装。相反，它们必须由用户手动安装。</p><p id="ae77" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">这允许包依赖于其他包，而不需要将它们包含在包的实际代码中。例如，如果一个包使用React，它可以将React列为对等依赖项，因此该包的用户必须单独安装React，以便该包能够正常工作。从依赖关系中移除<code class="fe nd ne nf ng b">react</code>和<code class="fe nd ne nf ng b">react-dom</code>。</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="28ca" class="nl kw iq ng b be nm nn l no np">"peerDependencies": {<br/>  "react": "^18.2.0",<br/>  "react-dom": "^18.2.0"<br/>}</span></pre><p id="16c8" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">package.json</code>文件中的<code class="fe nd ne nf ng b">type</code>、<code class="fe nd ne nf ng b">main</code>、<code class="fe nd ne nf ng b">module</code>、<code class="fe nd ne nf ng b">types</code>、<code class="fe nd ne nf ng b">files</code>和<code class="fe nd ne nf ng b">name</code>字段用于指定发布到NPM时包中应该包含哪些文件。<code class="fe nd ne nf ng b">type</code>字段指定包的类型，如库或应用程序。<code class="fe nd ne nf ng b">main</code>字段指定包的入口点或主文件。<code class="fe nd ne nf ng b">module</code>字段指定用于包的es模块版本的文件。<code class="fe nd ne nf ng b">types</code>字段指定包的TypeScript声明文件。</p><p id="4b32" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">最后，<code class="fe nd ne nf ng b">files</code>字段指定在发布包时应该包含哪些文件和目录。<code class="fe nd ne nf ng b">package.json</code>文件中的<code class="fe nd ne nf ng b">name</code>字段用于指定包的名称。该名称将在软件包发布到NPM以及使用<code class="fe nd ne nf ng b">npm install</code>命令安装时使用。它应该是唯一的、小写的、用破折号分隔的字符串，并且不应包含任何空格或特殊字符。</p><p id="5585" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">我们需要将这些字段添加到我们的<code class="fe nd ne nf ng b">package.json</code>:</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="0414" class="nl kw iq ng b be nm nn l no np">"type": "module",<br/>"main": "dist/react-component-library.cjs.js",<br/>"module": "dist/react-component-library.es.js",<br/>"types": "dist/index.d.ts",<br/>"name": "react-component-library",<br/>"files": [<br/>  "/dist",<br/>  "/dist/style.css"<br/>],</span></pre><h1 id="9d26" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">最终Package.json:</h1><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="aef2" class="nl kw iq ng b be nm nn l no np">{<br/>  "name": "react-component-library",<br/>  "private": true,<br/>  "version": "0.0.0",<br/>  "type": "module",<br/>  "main": "dist/react-component-library.cjs.js",<br/>  "module": "dist/react-component-library.es.js",<br/>  "types": "dist/index.d.ts",<br/>  "files": [<br/>    "/dist",<br/>    "/dist/style.css"<br/>  ],<br/>  "scripts": {<br/>    "build": "concurrently \\"npm run build:css\\" \\"tsc --emitDeclarationOnly &amp;&amp; vite build\\"",<br/>    "build:css": "tailwindcss -m -i ./src/tailwind-entry.css -o ./dist/index.css",<br/>    "preview": "vite preview",<br/>    "storybook": "concurrently \\"npm run storybook:css\\" \\"storybook dev -p 6006\\"",<br/>    "storybook:css": "tailwindcss -w -i ./src/tailwind-entry.css -o ./src/index.css",<br/>    "build-storybook": "concurrently \\"npm run build-storybook:css\\" \\"storybook build\\"",<br/>    "build-storybook:css": "tailwindcss -m -i ./src/tailwind-entry.css -o ./src/index.css"<br/>  },<br/>  "devDependencies": {<br/>    "@babel/core": "^7.20.5",<br/>    "@storybook/addon-essentials": "^7.0.0-beta.12",<br/>    "@storybook/addon-interactions": "^7.0.0-beta.12",<br/>    "@storybook/addon-links": "^7.0.0-beta.12",<br/>    "@storybook/blocks": "^7.0.0-beta.12",<br/>    "@storybook/react": "^7.0.0-beta.12",<br/>    "@storybook/react-vite": "^7.0.0-beta.12",<br/>    "@storybook/testing-library": "^0.0.13",<br/>    "@types/react": "^18.0.26",<br/>    "@types/react-dom": "^18.0.9",<br/>    "@vitejs/plugin-react": "^3.0.0",<br/>    "autoprefixer": "^10.4.13",<br/>    "babel-loader": "^8.3.0",<br/>    "concurrently": "^7.6.0",<br/>    "postcss": "^8.4.20",<br/>    "storybook": "^7.0.0-beta.12",<br/>    "tailwindcss": "^3.2.4",<br/>    "typescript": "^4.9.3",<br/>    "vite": "^4.0.0"<br/>  },<br/>  "peerDependencies": {<br/>    "react": "^18.2.0",<br/>    "react-dom": "^18.2.0"<br/>  }<br/>}</span></pre><p id="f1fe" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">现在一切都准备好了，让我们开始吧！要运行该应用程序，只需执行以下命令:<code class="fe nd ne nf ng b">npm run storybook</code>。Storybook应该会在项目中生成一些默认的故事。</p><p id="3674" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">我已经删除了默认的故事，但是你可以设置你想要的文件夹结构，但是我设置了项目有<code class="fe nd ne nf ng b">components</code>文件夹和<code class="fe nd ne nf ng b">src</code>文件夹下的<code class="fe nd ne nf ng b">stories</code>文件夹。首先让我们创建一个卡组件。创建一个文件<code class="fe nd ne nf ng b">src/components/card.tsx</code>，让我们创建下面的组件:</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="491c" class="nl kw iq ng b be nm nn l no np">type CardProps = {<br/>  title: string;<br/>  description: string;<br/>};<br/><br/>export const Card = ({ title, description }: CardProps) =&gt; {<br/>  return (<br/>    &lt;div className="bg-white rounded-lg shadow-lg overflow-hidden"&gt;<br/>      &lt;div className="px-6 py-4"&gt;<br/>        &lt;h2 className="font-bold text-xl mb-2"&gt;{title}&lt;/h2&gt;<br/>        &lt;p className="text-gray-700 text-base"&gt;{description}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="f4ca" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">因为我们正在构建一个组件库，所以我有一个<code class="fe nd ne nf ng b">src/index.ts</code>文件，它可以导出我计划用组件库导出的任何组件。您可以将该文件视为组件库的入口点。在该文件中，我们需要导入/导出<code class="fe nd ne nf ng b">Card</code>组件</p><p id="4d5a" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">之后，就是创造故事的时候了。故事就像你的应用程序的缩小版，它被用来创建你的组件的孤立的例子。故事书可以用来创建、查看和组织这些故事。要创建一个故事，只需在<code class="fe nd ne nf ng b">stories</code>目录中创建一个新文件。让我们为<code class="fe nd ne nf ng b">Card</code>组件创建一个故事，并创建一个名为<code class="fe nd ne nf ng b">card.stories.js</code>的文件。</p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="e8ed" class="nl kw iq ng b be nm nn l no np">import type { Meta, StoryObj } from "@storybook/react";<br/>import { Card } from "../";<br/><br/>const meta = {<br/>  title: "Example/Card",<br/>  component: Card,<br/>  tags: ["docsPage"],<br/>  argTypes: {<br/>    title: {<br/>      control: { type: "text" },<br/>    },<br/>    description: {<br/>      control: { type: "text" },<br/>    },<br/>  },<br/>} satisfies Meta&lt;typeof Card&gt;;<br/>export default meta;<br/>type Story = StoryObj&lt;typeof meta&gt;;<br/>export const Primary: Story = {<br/>  args: {<br/>    title: "Card Title",<br/>    description: "This is a card",<br/>  },<br/>};</span></pre><p id="f66d" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">argTypes</code>字段允许我们指定故事书控件允许哪些道具。这意味着在观看故事时，我们可以看到对道具的控制，并且可以在观看故事时根据需要调整它们。你可以用这个功能做很多事情，如果你还没有，我强烈建议你阅读故事书文档。</p><p id="a0f1" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">Primary</code>导出允许我们建立一个故事的例子，包括传入默认的属性值。这使我们可以看到实际情况，并可以用来调试和检查组件是否按预期工作。如果你一直在关注，希望你能去<code class="fe nd ne nf ng b">localhost:6006</code>看看我们新的<code class="fe nd ne nf ng b">Card</code>故事，你可以更新标题和描述道具来测试一下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/db222435c68d64d39ed08c9de3685bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VbCtl6BPwmVt9Myg0n4KOQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">卡组件示例。</p></figure><p id="3f6a" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">太好了，我们可以构建和查看组件，但是现在您可能想知道“我如何构建和分发我的组件？”</p><h1 id="26b2" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">设置构建过程</h1><p id="e5bd" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">以下所有文件都在项目的根目录下。</p><h1 id="5fd8" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Vite配置设置</h1><p id="7e53" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><code class="fe nd ne nf ng b">vite.config.ts</code></p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="c9f9" class="nl kw iq ng b be nm nn l no np">import react from "@vitejs/plugin-react";<br/>import { resolve } from "path";<br/>import { defineConfig } from "vite";<br/>import dts from "vite-plugin-dts";<br/>import tsConfigPaths from "vite-tsconfig-paths";<br/>import * as packageJson from "./package.json";<br/><br/>export default defineConfig((configEnv) =&gt; ({<br/>  plugins: [<br/>    react(),<br/>    tsConfigPaths(),<br/>    dts({<br/>      include: ["src"],<br/>    }),<br/>  ],<br/>  build: {<br/>    lib: {<br/>      entry: resolve("src", "index.ts"),<br/>      name: "react-component-library",<br/>      formats: ["es", "umd"],<br/>      fileName: (format) =&gt; `react-component-library.${format}.js`,<br/>    },<br/>    rollupOptions: {<br/>      external: [...Object.keys(packageJson.peerDependencies)],<br/>    },<br/>  },<br/>}));</span></pre><p id="f906" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">该文件从导入配置中使用的许多模块开始。<code class="fe nd ne nf ng b">react</code>模块是一个用于构建React应用程序的Vite插件。来自<code class="fe nd ne nf ng b">path</code>模块的<code class="fe nd ne nf ng b">resolve</code>函数用于解析文件路径。<code class="fe nd ne nf ng b">defineConfig</code>函数是Vite API的一部分，用于定义构建的配置。<code class="fe nd ne nf ng b">dts</code>模块是用于生成类型脚本声明文件的Vite插件，<code class="fe nd ne nf ng b">tsConfigPaths</code>模块是用于在配置中使用类型脚本路径的Vite插件。</p><p id="d9d6" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">然后，该文件导出一个默认配置对象，该对象是通过调用<code class="fe nd ne nf ng b">defineConfig</code>函数并传入一个接收<code class="fe nd ne nf ng b">configEnv</code>对象的函数而生成的。配置对象有两个属性:<code class="fe nd ne nf ng b">plugins</code>和<code class="fe nd ne nf ng b">build</code>。</p><p id="6468" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">属性是一个应该被加载的Vite插件的数组。在这种情况下，配置包括<code class="fe nd ne nf ng b">react</code>插件、<code class="fe nd ne nf ng b">tsConfigPaths</code>插件和<code class="fe nd ne nf ng b">dts</code>插件。</p><p id="d17a" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">build</code>属性有一个<code class="fe nd ne nf ng b">lib</code>子属性，它指定了构建库的配置选项。属性是库的入口点，属性是库的名称。<code class="fe nd ne nf ng b">formats</code>属性指定应该生成的输出格式，而<code class="fe nd ne nf ng b">fileName</code>属性是一个为输出文件生成文件名的函数。</p><p id="a36a" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">build</code>属性还有一个<code class="fe nd ne nf ng b">rollupOptions</code>子属性，它为Vite使用的汇总捆绑器指定选项。<code class="fe nd ne nf ng b">external</code>属性是一个依赖关系数组，应该被视为包的外部。</p><p id="6ff5" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">tsconfig.json</code></p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="766c" class="nl kw iq ng b be nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "ESNext",<br/>    "useDefineForClassFields": true,<br/>    "lib": ["DOM", "DOM.Iterable", "ESNext"],<br/>    "allowJs": false,<br/>    "allowSyntheticDefaultImports": true,<br/>    "strict": true,<br/>    "forceConsistentCasingInFileNames": true,<br/>    "module": "ESNext",<br/>    "moduleResolution": "Node",<br/>    "resolveJsonModule": true,<br/>    "isolatedModules": true,<br/>    "noEmit": true,<br/>    "jsx": "react-jsx",<br/>    "declaration": true,<br/>    "skipLibCheck": true,<br/>    "esModuleInterop": true,<br/>    "declarationMap": true,<br/>    "baseUrl": ".",<br/>    "paths": {<br/>      "react-component-library": ["src/index.ts"],<br/>    },<br/>    "typeRoots": ["node_modules/@types", "src/index.d.ts"]<br/>  },<br/>  "include": ["src"],<br/>  "references": [{ "path": "./tsconfig.node.json" }]<br/>}</span></pre><p id="4f68" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">如果你想知道每个属性是什么，我把它分解如下:</p><ul class=""><li id="c070" class="mj mk iq lp b lq my lt mz lw nr ma ns me nt mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"compilerOptions"</code>:为TypeScript编译器指定各种选项的对象。</li><li id="6fb6" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"target"</code>:指定编译代码的ECMAScript目标版本。在这种情况下，值是<code class="fe nd ne nf ng b">"ESNext"</code>，这意味着代码将被编译成TypeScript编译器支持的最新版本的ECMAScript。</li><li id="7f38" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"useDefineForClassFields"</code>:控制类字段的<code class="fe nd ne nf ng b">defineProperty</code>调用的发出。</li><li id="7bd2" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"lib"</code>:编译器应该包含在编译输出中的库文件数组。在这种情况下，包括库<code class="fe nd ne nf ng b">"DOM"</code>、<code class="fe nd ne nf ng b">"DOM.Iterable"</code>和<code class="fe nd ne nf ng b">"ESNext"</code>。</li><li id="5501" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"allowJs"</code>:控制编译器是否允许编译JavaScript文件。在这种情况下，值为<code class="fe nd ne nf ng b">false</code>，意味着编译器将不允许编译JavaScript文件。</li><li id="2052" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"allowSyntheticDefaultImports"</code>:控制输入文件中是否允许合成默认导入。</li><li id="7dda" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"strict"</code>:启用所有严格的类型检查选项。</li><li id="da46" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"forceConsistentCasingInFileNames"</code>:不允许对同一文件的大小写不一致的引用。</li><li id="2bb1" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"module"</code>:指定编译代码的模块类型。在这种情况下，值是<code class="fe nd ne nf ng b">"ESNext"</code>，这意味着代码将被编译为ECMAScript模块。</li><li id="7841" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"moduleResolution"</code>:指定编译器的模块解析策略。在这种情况下，值为<code class="fe nd ne nf ng b">"Node"</code>，这意味着编译器将使用Node.js模块解析策略。</li><li id="b24b" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"resolveJsonModule"</code>:控制TypeScript编译器是否应该将<code class="fe nd ne nf ng b">.json</code>文件解析为模块。在这种情况下，值是<code class="fe nd ne nf ng b">true</code>，意味着编译器将把<code class="fe nd ne nf ng b">.json</code>文件解析为模块。</li><li id="704e" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"isolatedModules"</code>:控制输入文件是否被视为独立的模块。</li><li id="1705" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"noEmit"</code>:告诉编译器不要发出输出。</li><li id="be2d" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"jsx"</code>:指定编译JSX代码时使用的JSX工厂函数。在这种情况下，值是<code class="fe nd ne nf ng b">"react-jsx"</code>，这意味着编译器将使用<code class="fe nd ne nf ng b">React.createElement</code>函数作为JSX工厂函数。</li><li id="901f" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"declaration"</code>:告诉编译器为每个输入文件生成相应的<code class="fe nd ne nf ng b">.d.ts</code>文件。</li><li id="7a61" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"skipLibCheck"</code>:告诉编译器跳过声明文件的类型检查。</li><li id="1383" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"esModuleInterop"</code>:控制编译器是否应该在生成的代码中的顶级导入/导出语句中添加名称空间。</li><li id="5cb8" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"declarationMap"</code>:控制编译器是否为每个对应的声明文件生成一个源映射。</li><li id="5bdb" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"baseUrl"</code>:指定编译器在解析非相对模块名时使用的基本URL。在这种情况下，值是<code class="fe nd ne nf ng b">"."</code>，这意味着编译器将使用当前目录作为基本URL。</li><li id="4ecd" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"paths"</code>:用于指定应由TypeScript编译器解析的导入的别名。这些别名可用于简化代码中的导入，也可用于简化代码的移动，而无需更改导入。例如，在这个配置中，<code class="fe nd ne nf ng b">react-component-library</code>别名用于指向<code class="fe nd ne nf ng b">src/index.ts</code>文件，因此使用这个别名的任何导入都将被解析到<code class="fe nd ne nf ng b">src/index.ts</code>文件。</li><li id="46a5" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">“typeroots”</code>:解析模块导入时，TypeScript编译器将用来搜索类型声明的路径数组。这些路径可用于指定编译器应该在何处查找第三方模块的类型声明，以及自定义模块的类型声明。通过将<code class="fe nd ne nf ng b">src/index.d.ts</code>路径添加到<code class="fe nd ne nf ng b">typeRoots</code>数组，我们可以确保TypeScript编译器能够为我们的定制模块找到类型声明。</li><li id="e975" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">"include"</code>:用于指定编译过程中应该包含哪些文件和文件夹。默认情况下，TypeScript编译器将只编译扩展名为<code class="fe nd ne nf ng b">.ts</code>或<code class="fe nd ne nf ng b">.tsx</code>的文件。属性可以用来指定编译过程中应该包含的附加文件和文件夹。在这种情况下，<code class="fe nd ne nf ng b">"include"</code>属性被设置为<code class="fe nd ne nf ng b">"src"</code>，这意味着编译器将在编译过程中包含<code class="fe nd ne nf ng b">src</code>文件夹中的所有文件和文件夹。</li><li id="b64c" class="mj mk iq lp b lq ms lt mt lw mu ma mv me mw mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">“references”</code>:用于指定编译项目时需要引用的其他<code class="fe nd ne nf ng b">tsconfig</code>文件。这可以用于包含来自多个文件的配置，这使得跨多个项目维护和共享配置变得更加容易。例如，在这个配置中，<code class="fe nd ne nf ng b">references</code>属性被设置为<code class="fe nd ne nf ng b">"./tsconfig.node.json"</code>，这意味着来自<code class="fe nd ne nf ng b">tsconfig.node.json</code>文件的任何配置都将包含在编译过程中。</li></ul><p id="c405" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">tsconfig.node.json</code></p><pre class="kg kh ki kj gt nh ng ni bn nj nk bi"><span id="1e59" class="nl kw iq ng b be nm nn l no np">{<br/>  "compilerOptions": {<br/>    "composite": true,<br/>    "module": "ESNext",<br/>    "moduleResolution": "Node",<br/>    "allowSyntheticDefaultImports": true,<br/>    "resolveJsonModule": true,<br/>  },<br/>  "include": ["vite.config.ts","package.json"],<br/>}</span></pre><p id="bdce" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">tsconfig.json</code>和<code class="fe nd ne nf ng b">tsconfig.node.json</code>文件用于配置项目的TypeScript编译器。<code class="fe nd ne nf ng b">tsconfig.json</code>文件用于指定项目的一般配置，而<code class="fe nd ne nf ng b">tsconfig.node.json</code>文件用于指定特定于Node.js的配置。为一般配置和Node.js特定配置提供单独的文件有助于保持配置的有序性，并使在多个项目间维护和共享配置变得更加容易。</p><ul class=""><li id="1d25" class="mj mk iq lp b lq my lt mz lw nr ma ns me nt mi mx mp mq mr bi translated"><code class="fe nd ne nf ng b">composite</code>:一个布尔值，告诉编译器启用复合模式。在复合模式下，TypeScript编译器会将<code class="fe nd ne nf ng b">tsconfig.json</code>文件中指定的所有项目合并成一个复合项目。如果您想要一起构建多个项目，或者如果您想要避免多次构建项目，这可能会很有用。</li></ul><h1 id="cde4" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">测试版本</h1><p id="97e0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">一旦你设置了<code class="fe nd ne nf ng b">tsconfig.json</code>、<code class="fe nd ne nf ng b">tsconfig.node.json</code>、<code class="fe nd ne nf ng b">package.json</code>和<code class="fe nd ne nf ng b">vite.config.ts</code>。让我们通过运行来测试以确保构建实际工作</p><p id="6265" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated"><code class="fe nd ne nf ng b">npm run build</code></p><p id="ccc3" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">库应该会成功构建，现在您应该会在项目中看到一个<code class="fe nd ne nf ng b">dist</code>文件夹。这是您的库的最终版本。但是在你把这个包放到NPM之前，明智的做法是在一个本地项目上进行测试。</p><h1 id="b774" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">将库链接到本地应用程序</h1><p id="eac0" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">NPM链接是一个命令行实用程序，是节点程序包管理器(NPM)的一部分。它允许开发人员在本地包和项目之间创建一个符号链接，这样就可以在项目中测试对本地包的更改，而不必发布包。</p><p id="0cb6" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">要使用NPM链接，请在项目中运行<code class="fe nd ne nf ng b">npm link</code>。这将在软件包和全局NPM安装目录之间创建一个符号链接。现在转到您想要测试这个库的一个单独的项目。然后，在项目目录中，运行<code class="fe nd ne nf ng b">npm link react-component-library</code>在包和项目之间创建一个符号链接。最后，在项目目录下运行<code class="fe nd ne nf ng b">npm install</code>来安装链接包。现在，您应该能够对组件库代码进行更新了，这些更改将反映在它所链接的项目中。</p><h1 id="fb3d" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">发布图书馆</h1><p id="5f02" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">向NPM发布NPM套餐时，您首先需要在NPM上创建一个帐户。一旦您有了一个帐户，您就可以使用<code class="fe nd ne nf ng b">npm publish</code>命令将您的包发布到NPM注册中心。在运行该命令之前，确保您已经更新了<code class="fe nd ne nf ng b">package.json</code>文件中的版本号，并且您的代码已经过适当的测试和记录。一旦软件包发布，您就可以使用<code class="fe nd ne nf ng b">npm install</code>命令来安装它。</p><p id="dd74" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">我想专注于用提到的技术创建一个组件库，所以我没有包括像ESLint或Prettier这样的东西，如果需要的话，我可以随时修改帖子。但我绝对可以把它们包含在GitHub项目中。</p><p id="b4c2" class="pw-post-body-paragraph ln lo iq lp b lq my jr ls lt mz ju lv lw na ly lz ma nb mc md me nc mg mh mi ij bi translated">感谢阅读这篇博文！我希望这对您有所帮助，并且您对使用Storybook 7和Vite 4构建自定义React组件库充满信心。使用这些工具可能会令人生畏，但是我希望这篇文章对你有用。如果你有问题或需要帮助，不要犹豫，伸出援手。如果有什么困惑，请在评论中告诉我，这样我就可以更新帖子了。我一直在努力使这篇文章有帮助和全面，所以任何反馈都是非常感谢的。</p><h2 id="234e" class="nu kw iq bd kx nv nw dn lb nx ny dp lf lw nz oa lh ma ob oc lj me od oe ll of bi translated"><strong class="ak"> GitHub回购链接</strong></h2><div class="og oh gp gr oi oj"><a href="https://github.com/brandon-schabel/react-component-lib-template" rel="noopener  ugc nofollow" target="_blank"><div class="ok ab fo"><div class="ol ab om cl cj on"><h2 class="bd ir gy z fp oo fr fs op fu fw ip bi translated">GitHub-Brandon-schabel/react-component-lib-template</h2><div class="oq l"><h3 class="bd b gy z fp oo fr fs op fu fw dk translated">Storybook、React、Tailwind和TypeScript都是强大的工具，可以结合起来创建一个强大的web…</h3></div><div class="or l"><p class="bd b dl z fp oo fr fs op fu fw dk translated">github.com</p></div></div><div class="os l"><div class="ot l ou ov ow os ox kp oj"/></div></div></a></div><h2 id="50c0" class="nu kw iq bd kx nv nw dn lb nx ny dp lf lw nz oa lh ma ob oc lj me od oe ll of bi translated"><strong class="ak">演职员表</strong></h2><p id="108b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">感谢<a class="oy oz ep" href="https://medium.com/u/7f11188da0fc?source=post_page-----c52db4d733c0--------------------------------" rel="noopener" target="_blank"> Bigyan Poudel </a>关于设置构建步骤的内容丰富的<a class="ae pa" href="https://articles.wesionary.team/react-component-library-with-vite-and-deploy-in-npm-579c2880d6ff" rel="noopener ugc nofollow" target="_blank">文章</a>。</p></div></div>    
</body>
</html>