<html>
<head>
<title>The Mediator Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的中介模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-mediator-pattern-in-javascript-2bd2ff244447?source=collection_archive---------2-----------------------#2019-10-28">https://betterprogramming.pub/the-mediator-pattern-in-javascript-2bd2ff244447?source=collection_archive---------2-----------------------#2019-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8828" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用中介模式解耦耦合的模块</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/361543d9ca1bb5cc43b14393a82ce136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GvKwpca90xYxLiRdoO8NFg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="ky">Florian Olivo在Unsplash上拍摄的照片</em></p></figure><p id="2538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论<em class="lv">中介模式</em>并使用JavaScript实现它。JavaScript中的中介允许我们公开一个中央接口，该接口封装了一组对象之间的所有交互。</p><p id="3450" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这种模式改变了程序的运行行为，并负责协调交互，所以它被认为是一种行为模式。随着应用程序规模的增长，如果有多个对象直接相互交互，引入中介的需求会越来越大。</p><p id="09bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设你正在开发一款RPG游戏，并且设计了一堆<em class="lv">没有</em>利用中介模式的类或函数。让我们来看看会是什么样子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/715fdb5c65fab166340c4c21075d1bdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QWhZ2DjSXSvuQ-AI.JPG"/></div></div></figure><p id="99ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在试着想象你自己试图阅读和维护隐藏在下面的代码。</p><p id="19da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你必须自己追踪一切，并且知道<code class="fe lx ly lz ma b">function1</code>与什么通信，<code class="fe lx ly lz ma b">function3</code>与<code class="fe lx ly lz ma b">function9</code>通信，<code class="fe lx ly lz ma b">function5</code>与<code class="fe lx ly lz ma b">function10</code>通信，<code class="fe lx ly lz ma b">function8</code>从<code class="fe lx ly lz ma b">function10</code>接收数据并将其转发给<code class="fe lx ly lz ma b">function2</code>，等等。</p><p id="2d68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毫无疑问，这将很快成为开发人员最糟糕的噩梦！</p><p id="c314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当在代码中引入中介模式时，<code class="fe lx ly lz ma b">mediator</code> <em class="lv"> </em>对象将被放置在两者之间，它的主要职责是封装它们之间的所有交互和行为，指定它自己负责处理所有这些。</p><p id="7df5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来会像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/aa338006aa6f0784be3f7d5affff3c01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9CkXWjMLm-0dGemo.JPG"/></div></div></figure><p id="49ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你现在所看到的，<code class="fe lx ly lz ma b">mediator</code> <em class="lv"> </em>对象位于两者之间，现在负责一组对象之间的交互。</p><p id="58b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，想象调试这个应用程序。如果这里的一个模块抛出错误，我们知道只有两个地方可以查看中介或模块本身。这使得维护更大的代码库变得更容易，因为我们能够更明显地分离逻辑。</p><p id="9589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，当我们需要更改代码中的某些内容时，我们可以确保它会变得比以前少得多，因为我们现在对对象之间的方向有了更清晰的了解。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="c1eb" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">如何知道何时引入中介模式</h1><p id="343e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当代码中的某些部分与其他部分有太多的直接关系时，可能需要引入这一点。</p><p id="1498" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，您的代码可能会不稳定。</p><p id="82b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它有助于促进它们之间的松散耦合，确保它们的所有交互都通过一个中心点(即中介)来协调，而不是显式地引用其他对象。这有助于我们提高组件的可用性。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="396e" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">现实世界的类比</h1><p id="ca64" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这里有一个真实世界的类比，可能有助于您理解<em class="lv">调解人</em>如何帮助带来效率及其概念:</p><p id="ecf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你和其他学生在一个教室里，老师拿着一叠试卷。他们想把这些分发出去，这样每个学生都能收到一份。</p><p id="6976" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的老师不是把一叠试卷发给一个学生，让他们拿一份，然后把这叠试卷传给后面的学生，直到最后一个学生拿到这叠试卷，而是决定把试卷传给每个学生。</p><p id="6509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由此，他们负责确保每个孩子都拿到一张纸，并从本质上承担起调解人的角色。最后，当叫到最后一个学生时，教室对面的另一个学生举手说:“我没有拿到一张纸”。</p><p id="ab40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你试着“调试”一下这种情况。你可以立即得出结论，调解员应对丢失的纸负责，因为他们的角色是给每个学生提供一张纸。</p><p id="cf7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，您还可以清楚地预测此时纸叠的位置。</p><p id="7881" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果老师决定把这叠试卷传给学生，学生负责确保他们都拿到一张纸，如果一个学生举手说他们没有拿到纸，“调试”这种情况会相当困难。</p><p id="7da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一，你不知道<em class="lv">此时</em>那堆纸在哪里。第二，你几乎不知道是谁搞砸了这个过程。你必须问每一个学生，问他们把他们的试卷交给了谁，才能弄清楚为什么有人没有拿到试卷。</p><p id="11c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您一直在用JavaScript为web开发，那么您已经在围绕中介进行开发了。</p><p id="241b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在DOM中，中介的一个例子是<code class="fe lx ly lz ma b">document</code>对象本身，因为它可以协调DOM元素之间的逻辑和行为。带有<code class="fe lx ly lz ma b">type="radio"</code>的<code class="fe lx ly lz ma b">input</code>元素也可以作为中介，因为它可以决定检查哪个单选按钮，因为它可以保存当前值。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="7af4" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">优势</h1><p id="fb19" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当你有多个相互直接通信的对象时，你实际上是在围绕一个<em class="lv">多对多关系</em>工作，这在调试时会变成一场噩梦。</p><p id="650b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在对象之间引入一个<em class="lv">一对多</em>流，引入中介将有助于减少这个问题。</p><p id="6bea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他值得注意的好处包括减少对象之间的依赖性(松散耦合)，更少的错误，更易于代码维护和可读性。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="c820" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">不足之处</h1><p id="7680" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">就像生活中所有美好的事物一样，并非一切都是完美的。中介模式也是如此。</p><p id="c068" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，用一个单一的对象点来协调对象之间的所有交互本质上意味着，如果有任何错误，它将影响被它封装的所有东西。</p><p id="e8cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其中一个例子是，因为中介是多个对象之间交互的中心点，所以当应用程序变大时，它可能会成为一个性能问题，因为它们总是间接通信。</p><p id="0657" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，在让一个中介管理交互和让对象直接管理交互之间进行选择，几乎总是更好的选择。</p><p id="88d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们改变了一个对象中的某个东西，而某个东西最终抛出了一个异常，这很容易在应用程序的其余部分产生多米诺骨牌效应，你甚至会很难知道从哪里开始。</p><p id="0178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像我们在前面的例子中的真实世界类比一样，调试这种情况将成为一个真正的噩梦，因为您必须检查代码中的每个通信点。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="68ef" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">代码示例</h1><p id="884f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们假设我们正在创建一个RPG游戏，我们想要实现的第一个特性是一个<code class="fe lx ly lz ma b">Novice</code>类，并实现一个party API。</p><p id="299d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你从未听说过聚会这个概念，那就是当你将一组或多组用户联系在一起，创建一个联合团队，共同完成一个特定的目标。</p><p id="33d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将定义一个<code class="fe lx ly lz ma b">Novice</code>构造函数，以及<code class="fe lx ly lz ma b">Game</code>和<code class="fe lx ly lz ma b">Party</code>。</p><p id="1075" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lx ly lz ma b">Novice</code>用于创建新玩家，<code class="fe lx ly lz ma b">Party</code>为<em class="lv">方</em>功能提供API，<code class="fe lx ly lz ma b">Game</code>将成为使用<code class="fe lx ly lz ma b">Party</code>创建<code class="fe lx ly lz ma b">Novice</code>实例(用户)之间关联的中介。</p><p id="d092" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个实际应用的代码示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="3a77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们从示例中看到的，指定<code class="fe lx ly lz ma b">Game</code>实例来协调多个用户之间的当事人关联使得代码更容易阅读和维护，并且它解耦了<code class="fe lx ly lz ma b">Party</code>和<code class="fe lx ly lz ma b">Novice</code>实例之间的逻辑。</p><p id="521d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，我们将不得不直接将逻辑实现为<code class="fe lx ly lz ma b">Novice</code>或<code class="fe lx ly lz ma b">Party</code>接口的一部分，如果是这样的话，将它们合并是没有意义的。</p><p id="bd01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，当事情没有意义时，如果出现问题，调试会变得更加困难！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="99f5" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="dbb4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这一点到此为止！我希望你发现这是有价值的，并期待在未来更多。</p><p id="8d6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">想保持联系吗？订阅我的<a class="ae ni" href="https://app.getresponse.com/site2/javascript-newsletter?u=zpBtw&amp;webforms_id=SM2hz" rel="noopener ugc nofollow" target="_blank">简讯</a>。</p></div></div>    
</body>
</html>