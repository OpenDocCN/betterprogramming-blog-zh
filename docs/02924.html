<html>
<head>
<title>How To Create a WebSocket in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python创建WebSocket</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-websocket-in-python-b68d65dbd549?source=collection_archive---------0-----------------------#2020-01-09">https://betterprogramming.pub/how-to-create-a-websocket-in-python-b68d65dbd549?source=collection_archive---------0-----------------------#2020-01-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5b0c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">WebSockets简介</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/582a5f1c54a4ce6c503042438ac6400d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jVktlOqn6JW6fI76"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马里乌斯·马萨拉尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><blockquote class="kz la lb"><p id="35bc" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">WebSocket是一种计算机通信协议，通过单一TCP连接提供全双工通信通道— <a class="ae ky" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="ae37" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在本文中，您将学习如何使用<a class="ae ky" href="https://websockets.readthedocs.io/en/stable/api.html" rel="noopener ugc nofollow" target="_blank"> WebSockets </a> API在<a class="ae ky" href="https://docs.python.org/3/" rel="noopener ugc nofollow" target="_blank"> Python </a>中设置WebSocket。</p><p id="bef0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">Websocket API使得客户端和服务器之间的双向交互通信会话成为可能。使用API，您可以以事件驱动的方式发送和接收消息，而不必一直轮询服务器的数据。这导致了更少的开销，并允许来自和去往服务器的实时数据传输。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d7a8" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">入门指南</h1><p id="1812" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">WebSocket要求Python ≥ 3.6.1。</p><p id="5262" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">您可以使用以下命令在Python中简单地安装WebSockets API:</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="2980" class="nl mk it nh b gy nm nn l no np">pip install websockets</span></pre><p id="3f60" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">读完这篇文章，你就会明白WebSocket到底是什么了。我将给你一个中间的例子，其中服务器与它连接的客户机同步它得到的所有消息。</p><p id="3a85" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我不会涉及安全性之类的主题——我将展示的所有内容都是用Python编写的。对于至少对这门语言或一般编程有一点熟悉的人来说，这很容易理解。这样，您就可以更容易地用另一种语言或为前端应用程序编写消费者、生产者甚至服务器。</p><p id="cc88" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我希望你会发现提供的例子很有用，我鼓励每个开发人员在职业生涯中至少尝试一次WebSocket它太棒了。还有不止<a class="ae ky" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank">休息</a>，你懂的！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="528a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">一个简单的消息消费者</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/c2aa13d194ee2abacc7cbefb59403dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OhEmdahi4VrxNmbzYWLDBA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个简单的消息消费者</p></figure><p id="ae98" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">首先，让我们从我上面提供的消费协程开始。我将解释上面的每一行代码，这样你就能很好地理解发生了什么。简单总结一下上面发生的事情:我们连接到由特定WebSocket URL指定的WebSocket。WebSocket服务器生成的每条消息都会被记录下来。</p><p id="8aa2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我现在将详细解释最重要的三行。如果你对语法不感兴趣，可以跳过这一步。</p><p id="be14" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果你以前从未见过关键词<code class="fe nr ns nt nh b">async</code>或<code class="fe nr ns nt nh b">await</code>，你可能会有点吃惊。<code class="fe nr ns nt nh b">async/await</code>只是一种以舒适的方式处理承诺的特殊语法。承诺只不过是一个表示异步操作最终完成或失败的对象。</p><p id="6652" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">您可以将回调附加到此返回的对象，而不是作为将回调传递到函数中的替代方法。你会惊讶它是多么容易理解和使用。</p><p id="13c4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在Python中，<code class="fe nr ns nt nh b">async</code>确保函数返回一个承诺，并在其中包装非承诺。在<code class="fe nr ns nt nh b">await</code>调用期间，其他不相关的代码可以执行。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="c554" class="nl mk it nh b gy nm nn l no np">websocket_resource_url = f"ws://{host}:{port}"</span></pre><p id="faa2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">WebSocket资源URL使用以<code class="fe nr ns nt nh b">ws</code>(或<code class="fe nr ns nt nh b">wss</code>为安全连接)开始的方案。其后是主机名和端口号(例如，ws://web socket . example . com:8400)。我在这里使用一个f字符串来构建资源URL。语法与您习惯使用的<code class="fe nr ns nt nh b">str.format()</code>类似，但是f-string是Python 3.6中添加的，它使得格式化字符串文字不那么冗长。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="edca" class="nl mk it nh b gy nm nn l no np">async with websockets.connect(websocket_resource_url) as ws:</span></pre><p id="6d6f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我正在解释的下一行使用<code class="fe nr ns nt nh b">websockets.connect</code>打开与WebSocket的连接。等待连接产生一个<code class="fe nr ns nt nh b">WebSocketClientProtocol</code>，然后可以用它来发送和接收消息。这一行使用了<code class="fe nr ns nt nh b">async with</code>，它与异步上下文管理器一起工作。退出上下文时，连接被关闭。</p><p id="2828" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">注意:</strong>我有时会使用WebSocket (ws)的缩写，以使代码示例在介质上更易读，但在生产代码中总是要写全名。这增加了可读性。例如，你可以把它理解为<em class="le">网站</em>或<em class="le">网络服务器</em>，作为一个优秀的开发者，这是你应该避免的。毕竟，代码读起来应该像一本好书。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="4d7c" class="nl mk it nh b gy nm nn l no np">async for message in websocket:</span></pre><p id="b524" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">你可能会想，“等等，<code class="fe nr ns nt nh b">async for</code>是做什么的？”这就像一个同步for循环，但是它支持异步理解。</p><p id="8c10" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">异步IO使我们能够迭代异步迭代器。这允许您在迭代的每个阶段调用异步代码，而常规的for循环不允许您这样做。您可以在这行代码中将WebSocket视为消息的生成器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/eba1118c43cfecf83e497c1f6601cfdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*niMoKwuIWn70sdf6JC-TKw.png"/></div></div></figure><p id="8bdb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">要运行这个简单的消费者，只需指定主机名和端口，并让它永远运行。就这么简单。如果没有事件循环也不用担心，<code class="fe nr ns nt nh b">asyncio</code>会创建一个新的事件循环，并将其设置为当前事件循环。</p><p id="5bbf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">很简单，对吧？此代码示例将开始使用来自ws://localhost:4000的消息。如果没有服务器运行，它将失败并抛出404未找到。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="c196" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">简单的生产者</h1><p id="20d4" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">我举一个只生产一种价值的生产者的例子。我将向您展示这甚至比编写消费者更容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/6589bb081ac37f6f3639bac0d3213c32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fdEgTYHyqYT_FC8s_XxQLQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单的生产者</p></figure><p id="834e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">上面的代码不言自明。我们连接到WebSocket，就像我们之前在消费者中所做的那样。我们向服务器发送一条消息，然后等待响应。当我们收到来自服务器的消息时，我们知道我们的消息已经被传递了。</p><p id="99fa" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">现在，我们只需要一种方法来执行这个产品协程一次。</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="9199" class="nl mk it nh b gy nm nn l no np">loop = asyncio.get_event_loop()<br/>loop.run_until_complete(produce(message='hi', host='localhost', port=4000))</span></pre><p id="1f8c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当然，我们给它命名，Python也有答案。我们可以像对消费者那样简单地使用事件循环。唯一的区别是我们运行它，直到它完成。一旦我们收到服务器的响应，任务就完成了。</p><p id="108e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在Python 3.7中，它变得更好——我们现在可以使用run函数来执行协程。很漂亮，对吧？</p><pre class="kj kk kl km gt ng nh ni nj aw nk bi"><span id="bd75" class="nl mk it nh b gy nm nn l no np">asyncio.run(produce(message='hi', host='localhost', port=4000))</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="a800" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">服务器:拼图的最后一块</h1><p id="9450" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">在这种情况下，我编写了一个服务器类，将服务器的所有功能组合在一起。该服务器将生产者发送的消息分发给所有侦听的消费者。</p><p id="6a01" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">服务器被实例化并定义了一个WebSocket处理程序协程。WebSocket的<code class="fe nr ns nt nh b">serve</code>函数是事件循环的<code class="fe nr ns nt nh b">create_server()</code>方法的包装器。它用<code class="fe nr ns nt nh b">create_server()</code>创建并启动一个服务器。它接受一个WebSocket处理程序作为参数。</p><p id="b014" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">每当客户端连接时，服务器接受连接，创建一个<code class="fe nr ns nt nh b">WebSocketServerProtocol</code>，执行开始握手，并委托给由<a class="ae ky" href="https://websockets.readthedocs.io/en/stable/api.html" rel="noopener ugc nofollow" target="_blank"> ws_handler </a>定义的连接处理程序。一旦该处理程序完成，无论是正常完成还是出现异常，服务器都会执行关闭握手并关闭连接。</p><p id="a17c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这都是为你做的。因为我们指定服务器必须永远运行，所以每当我们的生产者生产一些东西时，它将只执行在服务器类中定义的协程<code class="fe nr ns nt nh b">ws_handler</code>(下面解释)。然后它会向所有连接的客户端分发一条消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/c7eff043796b611046628e76b22a98d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3V6iNchooPYuiPZBwhPQgg.png"/></div></div></figure><p id="26d2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">最后一段代码是最长的一段，但它是最后一部分，所以坚持住。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/19e82ad7088a3585641c46e2e08cd803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LTs97YIpNRkbzV4GS6E0ww.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将消息同步到连接的客户端的服务器类</p></figure><p id="27a3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe nr ns nt nh b">ws_handler</code>注册一个客户端，将消息分发给连接的客户端，最后关闭连接。消费者将保持连接，而生产者，另一方面，注销自己。<code class="fe nr ns nt nh b">distribute</code>协程将把WebSocket中的每条消息发送给我们连接的客户端集合中的所有客户端。</p><p id="e2cf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果有任何连接的客户端，将执行下面这段代码。<code class="fe nr ns nt nh b">asyncio.wait</code>确保我们只有在每个客户端都收到消息后才继续。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/bd3a8237b1e92f766958ed1763834493.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBlISDBn8imtLEKhgcbN0w.png"/></div></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="feba" class="nl mk it bd ml ny nz dn mp oa ob dp mt lz oc od mv ma oe of mx mb og oh mz oi bi translated">结论</h2><p id="42d2" class="pw-post-body-paragraph lc ld it lf b lg nb ju li lj nc jx ll lz nd lo lp ma ne ls lt mb nf lw lx ly im bi translated">总而言之，以下是WebSockets相对于HTTP长轮询的一些主要优势:</p><ul class=""><li id="68ac" class="oj ok it lf b lg lh lj lk lz ol ma om mb on ly oo op oq or bi translated">在WebSocket连接的生命周期中，可以随时以任何一种方式发送通信</li><li id="1f1d" class="oj ok it lf b lg os lj ot lz ou ma ov mb ow ly oo op oq or bi translated">客户端和服务器是持续连接的—数据可以随时发送到客户端，而无需请求它</li><li id="4365" class="oj ok it lf b lg os lj ot lz ou ma ov mb ow ly oo op oq or bi translated">在Python中使用WebSockets相当容易。这个消息同步示例无需编写大量代码就能实现。高效地对HTTP长轮询做同样的事情是一件相当复杂的事情。</li></ul></div></div>    
</body>
</html>