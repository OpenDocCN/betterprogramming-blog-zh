<html>
<head>
<title>Don’t Repeat Yourself… Wait Really?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要重复自己…等真的？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-repeat-yourself-really-9e5c9f0ba154?source=collection_archive---------0-----------------------#2021-08-18">https://betterprogramming.pub/dont-repeat-yourself-really-9e5c9f0ba154?source=collection_archive---------0-----------------------#2021-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b1b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">代码复制可以说是最糟糕的实践。然而，有时候编写稳定的代码库是非常必要的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/81450b64ecc5b3eadc555f28980f160f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aCl5KF4UoB6XU789"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">自由股票</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="9ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">人们应该尽可能多地分解代码，因为大多数时候，复制是人为错误的结果:复制和粘贴，对代码库一无所知…这是一种瘟疫，必须根除，没有什么可补充的。</p><p id="bfbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这不是它的唯一形式，确实有这样的情况，两个极其相似的模块比组合成一个模块更好。</p><p id="15db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为意外复制:除了非常相似的实现之外，几个彼此无关的模块。</p><p id="89f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如:假设你写了一个函数来计算你的智能手机的启动时间，另一个函数来计算你的微波炉的启动时间。</p><p id="6106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将两者放在一起很有诱惑力，但这是一个非常糟糕的想法，因为它们有彼此独立开发的风险。</p><p id="da0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你将它们排除在外，那么当你更换智能手机的一部分时，该算法将不再有效。如果你改变它，它将再次适用于智能手机，但不再适用于微波炉。</p><p id="2bff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这被称为回归:当两个模块的耦合度超过它们应有的程度时，这是一个经典问题。</p><p id="b896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">这就是我们如何点燃我们的代码库。</em></p><h1 id="d9df" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">智能分解</h1><blockquote class="mo mp mq"><p id="1ea6" class="kz la lv lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">所以，要么我们重复，要么我们创造了太强的依赖性，太棒了…</p></blockquote><p id="d29a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有可能的情况下，你都不应该这样做。好的架构和对设计模式的掌握应该足以让你摆脱困境。但是说起来容易做起来难。</p><p id="0b08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最简单的解决方案仍然是智能分解，也就是说，在对两个模块进行分组之前，总是要询问它们是否意外重复。</p><blockquote class="mo mp mq"><p id="2c48" class="kz la lv lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">我们该怎么做，夏洛克？</p></blockquote><p id="0d0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这并不容易，因为它需要对代码库和需求有很好的了解，但是有一个重复出现的现象。</p><p id="439b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重复的模块越靠近<a class="ae ky" href="https://en.wikipedia.org/wiki/Business_rule" rel="noopener ugc nofollow" target="_blank">业务领域</a>(低级)，越有可能是偶然重复。</p><p id="6d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为业务规则本质上是独特的，并且独立于其他规则。如果一个业务规则发生变化，另一个不会受到影响。</p><h1 id="6261" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">中间</h1><blockquote class="mo mp mq"><p id="696d" class="kz la lv lb b lc ld ju le lf lg jx lh mr lj lk ll ms ln lo lp mt lr ls lt lu im bi translated">好，所以我们离领域越近，我们的因素就越少，我明白了。</p></blockquote><p id="a41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呃，不，不是真的。</p><p id="e4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仅仅因为有偶然的重复，并不意味着你必须立即编写大块的代码。</p><p id="3f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">恰恰相反，因为任何低级模块都依赖于高级模块，而高级模块本身也需要考虑在内。</p><p id="6714" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子:这两个函数将一个重量和一个尺寸作为参数，验证它们，从数据库中获得一个系数，进行计算，然后返回结果。</p><p id="6cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的区别在于所进行的计算和恢复系数(系数b和系数f)的水平。</p><p id="a05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/TalhaKhalid101/7fe485b591d2b53697b9e89866004882" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/talhakhalid 101/7 Fe 485 b 591d 2 b 53697 b 9 e 89866004882</a></p><p id="4099" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会注意到这两个函数在结构和算法上都极其相似。但这些都是商业规则，那么，偶然重复与否？</p><p id="54d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是也不是，因为即使将这两个功能合二为一是一个非常糟糕的想法(独立进化，诸如此类)，单个步骤也可以被排除。</p><p id="9251" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://gist.github.com/TalhaKhalid101/4fc8754c23a1ba6f97a0f6ec3e73e532" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/talhakhalid 101/4fc 8754 c 23 a1 ba 6 f 97 a 0 f 6 EC 3 e 73 e 532</a></p><p id="f3d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将每个相同的步骤封装到它自己的顶级函数中，但并不是没有确保它确实是一个真正的副本。</p><p id="3522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了验证，身高和体重永远不可能是负数，无论在什么情况下，这都是不可能的，所以因式分解是有效的。</p><p id="834a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这同样适用于转换。科学不会为了好玩而改变拇指的大小。</p><p id="4b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而计算是不同的，那么为什么要把它们放在函数中呢？两件事:</p><ul class=""><li id="946a" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">给它们起个酷名字。</li><li id="aaa9" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">通过预防，如果其他地方需要的话，因为科学不会在一夜之间改变。</li></ul><p id="03f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让你冒冷汗的部分:请求。</p><p id="f84d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样的结构，同样的返回值，只是换表的名字。我们陷入了僵局，因为:</p><ul class=""><li id="c06e" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated">如果我们分解，如果基础图改变了，修复代码会更容易，但这打破了独立进化的思想。</li><li id="92b0" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated">如果进行复制，没有回归的风险，但是如果数据库图表发生变化，您将不得不在几个不同的地方修改代码。</li></ul><p id="46d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这一次，我选择了复制。但是这个例子给了我们两个非常重要的教训:</p><ul class=""><li id="2dc8" class="mu mv it lb b lc ld lf lg li mw lm mx lq my lu mz na nb nc bi translated"><strong class="lb iu">解耦你的组件</strong>，这样你的程序不需要知道数据库模式就能运行。不再上瘾=不再有问题。</li><li id="bf3f" class="mu mv it lb b lc nd lf ne li nf lm ng lq nh lu mz na nb nc bi translated"><strong class="lb iu">了解业务领域内部</strong>了解业务领域外部<strong class="lb iu">。正是它给出了程序的背景，自然地，它将引导你做出好的决定(关于验证和转换)。</strong></li></ul></div></div>    
</body>
</html>