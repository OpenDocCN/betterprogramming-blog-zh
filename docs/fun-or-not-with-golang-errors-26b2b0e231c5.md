# Golang 错误有趣(或不有趣)

> 原文：<https://betterprogramming.pub/fun-or-not-with-golang-errors-26b2b0e231c5>

## 我试图解决的 6 个与错误相关的问题

![](img/345d4f2f463067dc133866ff067d8c66.png)

由 [Geran de Klerk](https://unsplash.com/@gerandeklerk?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片。

我喜欢 Go，并且已经用它写了近十年的代码，但是处理错误一直是一场斗争。我之前的公司是世界上第一批在生产中使用 Golang 的公司之一，从第一天起，我就一直在思考如何最好地处理错误。不知何故，事情总是感觉不对，所以最近我开始真正地用它们做实验，让使用它们感觉良好。

这些是我想解决的问题:

*   如何在错误发生的地方获得堆栈跟踪？
*   我应该在何时何地为错误写日志输出？
*   如何区分我想向用户显示的错误和我想在日志中显示的内容？
*   当我想记录错误时，如何添加上下文以便使用结构化日志记录？
*   如何减少错误处理和日志记录的代码量？
*   我如何遵循常见的围棋最佳实践，比如戴夫·切尼[建议的那些实践，并完成上述任务？](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully)

什么都试过至少一次，就是想看看感觉如何。

例如，在最深处进行日志记录，这样我就可以在日志和适当的上下文中获得堆栈跟踪，然后返回错误。像[优步的 Zap](https://github.com/uber-go/zap) 这样的日志库将打印堆栈跟踪和结构化内容:

这对我来说总是有点难看，因为每当你得到一个错误时，它需要额外的一行来记录。这也意味着通过显式地将`logger`作为参数添加到每个函数或者[使用上下文](https://blog.gopheracademy.com/advent-2016/context-logging/)来传递`logger`(更简洁的方式)。有些人会说把它加到上下文中也不是一个好主意。

如果您不小心，并且没有更深入地检查，您不可避免地会不止一次地记录同一个错误。所以你会得到这样的结果:

你可以看到这是怎么回事，这不是一个快乐的地方！

当你在开发一个 API 时(可能是我们大多数人)，事情会变得更糟，比如这样的代码:

现在变得非常非常丑陋。所有这些多余的无用代码在每次错误检查中都随处可见(在 Go 中，到处都有错误检查)。

那么一个可怜的围棋开发者该怎么办呢？

# 我最近的围棋错误实验

我想我终于找到了一种相当优雅的方式来处理上面的一切，同时将错误处理代码保持在最少。我自己心中的一个启示。

我有一些用于实验的 GitHub repos，在这一节中我将特别提到一个叫做 [gotils](https://github.com/treeder/gotils) 的。

## 步骤 1:向上下文添加上下文

与其将上下文添加到您的`logger`(结构化字段)，不如将它们添加到 Go 上下文:

```
ctx = gotils.With(ctx, "foo", "bar")
```

这样做的好处是，您可以在任何地方使用这些上下文字段，而不仅仅是日志库。这只是一个基本的条目图。在上下文中添加上下文看起来很合适。

## 步骤 2:向错误添加上下文和堆栈跟踪

让我们将堆栈和上下文添加到我们返回的错误中，而不是尝试深入记录以便获得正确的堆栈跟踪和上下文:

```
if err != nil {
    return gotils.C(ctx).Errorf("error on x: %v", err)
}
```

`gotils.Errorf`函数包装您的错误，添加当前堆栈以及上下文字段映射，并返回一个包含该信息的新错误。

## 步骤 3:在入口点记录并向用户返回错误响应

如果这是一个 API，并且我们得到了一个错误，那么我们只在入口点(即 HTTP 处理程序)处理错误:

所以现在我们已经从应用程序的内部删除了所有难看的错误处理和日志代码，我们只在边缘**做一次*。***

## 进一步减少日志记录和错误处理

为了更好地进行这种处理，可以尝试使用一个`ErrorHandler`，让您的 HTTP 处理程序返回一个错误。这意味着我们不需要在每个处理程序中处理错误——只需要在一个地方包装所有其他的处理程序。这看起来像下面这样:

然后在整个应用程序中有一个地方处理日志记录和返回错误。

你可以看到一个[处理`UserErrors`之类的](https://github.com/treeder/gotils/blob/master/http.go#L53)T3 的完整例子。

## 特定于用户的错误，向用户隐藏内部错误并返回信息性消息

通常，您不希望您的用户看到程序内部发生的错误(例如，数据库错误)。您可能不想将`sql.ErrTxDone`发送回您的用户，但是您可能希望记录它或者以某种方式处理它。

处理它的一种方法是只返回一般性的错误，比如一个 500 内部服务器错误，如果一个错误发生了，但是这是非常严格的，你不能向用户返回一个关于到底哪里出错了的详细响应。例如，如果只是无效的输入，您可能希望返回类似“字段 X 无效”的消息

所以我们需要一种方法来区分内部使用的错误消息和用户使用的错误消息。为此，我做了一个`UserError`界面:

```
type UserError interface {
   error
   UserError() string
}
```

它是这样使用的:

```
return gotils.UserErrorf(err, "field %v is invalid", fieldname)
```

然后到了该回复的时候:

如果您想返回特定的 HTTP 状态代码，还有一个`gotils.HTTPError`。

## 如何在日志库中使用它们

您的日志库不知道如何自动提取堆栈或字段，但幸运的是，这相当容易。更好的是，在你的整个应用程序中可能只有一行真正使用了你的日志库！

如果您在自己的代码中尝试上述方法，请确保有几个方法可以从错误中获取上下文字段和堆栈。`gotils`有`Stacked`和`Fielded`接口提供这些方法，如果你愿意，你可以复制或者直接使用:

调用它们来获得正确的信息，并将其传递给日志库。

在 [gcputils repo](https://github.com/treeder/gcputils) 中有一个这样的例子，它会以 Google Cloud logging 的适当格式记录所有这些内容，只需简单地调用:

```
gcputils.Printf("%v", err)
```

# 结论

这些事情让我清理了许多总是困扰我的混乱代码，但我太忙了(或者说太懒了)以至于想不出更好的方法。直到最近，也就是说，当我有足够的时间和精力去尝试日志和错误处理的时候。

尝试这里讨论的一些概念，看看你有什么想法。我很想听到你的反馈，或者了解你是如何处理这些事情的。

> “犯错是人之常情；宽恕，神圣的。”——[亚历山大·波普](https://www.brainyquote.com/quotes/alexander_pope_101451)