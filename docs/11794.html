<html>
<head>
<title>6 Things to Know About Subclassing in Python — Why and How</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python中的子类化要知道的6件事——为什么和如何</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-things-to-know-about-subclassing-in-python-why-and-how-296003b62a75?source=collection_archive---------4-----------------------#2022-04-18">https://betterprogramming.pub/6-things-to-know-about-subclassing-in-python-why-and-how-296003b62a75?source=collection_archive---------4-----------------------#2022-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0034" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">触及Python作为面向对象语言的一些核心特性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cbb989f6d9829fae46de293351f74b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pse0hcB34JSojeL2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗伯特·科林斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="191a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从本质上讲，Python是一种面向对象的设计语言。它将所有东西都实现为对象、包、模块、类、函数，当然还有类的实例对象。当我们构建我们的应用程序时，我们通常必须创建定制的类来将相关的数据和功能捆绑在一起——这是解决编程问题的典型OOP方法。</p><p id="192d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着项目范围的扩大，几乎不可避免地需要创建子类。在本文中，我想强调一些您在定义子类时应该注意的特性/注意事项。请注意，我没有对你的知识水平做任何假设，所以我可能会涉及非常基础的东西，但是这些要点应该足以让你开始子类化。</p><p id="d882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，让我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f596" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.我们为什么要子类化？</h1><p id="cb1c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">首先，我们为什么要创建子类呢？当我们决定创建一个子类时，我们应该意识到我们要创建的不仅仅是一个子类——如果是这样的话，我们就不应该创建子类，因为我们可以简单地在初始类上工作。换句话说，当我们需要创建子类时，我们应该有创建至少两个共享同一个超类的子类的需求。如果你没有发现，我认为你不应该子类化。</p><p id="420e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的段落似乎在谈论“后果”——在你已经创建了一个子类之后你要检查的事情。如果我们退后一步，我们应该想知道什么时候创建子类。</p><p id="42ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们正在做一个项目，为人们创建一个在学校使用的应用程序。我们知道学校里有两类人:学生和老师。因此，我们创建了两个类来管理每个类别的数据。这两个类的一些基本结构如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">学生和教师(分开上课)</p></figure><p id="83b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nb nc nd ne b">Student</code>类中，我们定义了三个属性:<code class="fe nb nc nd ne b">name</code>、<code class="fe nb nc nd ne b">student_id</code>和<code class="fe nb nc nd ne b">grade</code>以及三个实例方法:<code class="fe nb nc nd ne b">register_course</code>、<code class="fe nb nc nd ne b">load_account</code>和<code class="fe nb nc nd ne b">check_in</code>。在教师类中，我们还定义了三个属性:<code class="fe nb nc nd ne b">name</code>、<code class="fe nb nc nd ne b">staff_id</code>和<code class="fe nb nc nd ne b">course_covered</code>，以及三个实例方法:<code class="fe nb nc nd ne b">request_vacation</code>、<code class="fe nb nc nd ne b">load_account</code>和<code class="fe nb nc nd ne b">check_in</code>。可以看出，这两个类共享相似的属性和方法，下图提供了直观的总结。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a2d3baf2ae4d8b76a7330f54a2c9f77c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*mEj5RkSjX4Xgp0brBm3oQA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">师生关系</p></figure><p id="c160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我们注意到这两个类在很大程度上是相似的，这种多个类之间的相似性是创建超类的基础。</p><p id="3844" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，实际上，您的类可能比图中所示的更复杂。但是要观察的最重要的事情是，当两个或更多的类共享重叠的功能时，您应该考虑创建一个超类，它反过来处理这些共享的功能。</p><blockquote class="ng nh ni"><p id="6747" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">创建子类最重要的好处是我们使我们的代码更加结构化——更加清晰和易于维护。也就是说，不是在单独的类中实现每个功能，而是将共享的实现放到超类中，这样更容易维护。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6e86" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.超类的基本框架</h1><p id="7f1d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们现在知道了创建超类的基本原理。显而易见的第一个问题是我们应该给我们的超类取什么名字。在大多数情况下，我们可以简单地从名词或语义的角度。由于学生和老师都属于更大的“人”的概念，我们可以将超类命名为<code class="fe nb nc nd ne b">Person</code>。</p><p id="6e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nb nc nd ne b">Person</code>类中，我们期望超类应该捕获子类的共享功能:<code class="fe nb nc nd ne b">Student</code>和<code class="fe nb nc nd ne b">Teacher</code>。因此，为了帮助我们定义超类的结构，如果您可以创建一个图表，向您展示超类的基本框架，以及子类的框架，而现在不指定任何实现细节，将会很有帮助。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/91b27a42d825c7589f35bc7b0163ff78.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*Cq6P-VTDvLqNIM_sw_eL_w.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">超类——子类的结构</p></figure><p id="0fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们将共享属性:<code class="fe nb nc nd ne b">name</code>和<code class="fe nb nc nd ne b">person_id</code>(结合了<code class="fe nb nc nd ne b">student_id</code>和<code class="fe nb nc nd ne b">staff_id</code>)和共享方法:<code class="fe nb nc nd ne b">load_account</code>和<code class="fe nb nc nd ne b">check_in</code>放在超类中。显然，不同的属性和方法应该在子类中实现:<code class="fe nb nc nd ne b">Student</code>和<code class="fe nb nc nd ne b">Teacher</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a2ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.创建超类</h1><p id="c62b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在上一节中，我们有一个关于超类和子类之间共享和不同功能的相对安排的计划。现在，是时候开始为超类编写代码了。在我开始解释之前，让我们看看下面的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">超类——人</p></figure><p id="6127" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在超类的初始化方法中，我们只包含了<code class="fe nb nc nd ne b">Student</code>和<code class="fe nb nc nd ne b">Teacher</code>共有的两个属性:<code class="fe nb nc nd ne b">name</code>和<code class="fe nb nc nd ne b">person_id</code>。同时，我们只定义子类共享的方法:<code class="fe nb nc nd ne b">load_account</code>和<code class="fe nb nc nd ne b">check_in</code>。</p><blockquote class="ng nh ni"><p id="7189" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">因此，定义超类的关键是定义子类应该继承的属性和方法。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="741b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.重构子类</h1><p id="7e9a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们布局了超类<code class="fe nb nc nd ne b">Person</code>的基本实现之后，现在是后退一步重构我们最初的<code class="fe nb nc nd ne b">Student</code>和<code class="fe nb nc nd ne b">Teacher</code>类，因为它们现在应该按照计划从<code class="fe nb nc nd ne b">Person</code>类继承。</p><h2 id="944a" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">定义子类</h2><p id="c777" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对于一个现有的超类，定义一个超类涉及到以下语法:<code class="fe nb nc nd ne b">class Subclass(Superclass)</code>。应用此表，我们可以为<code class="fe nb nc nd ne b">Student</code>和<code class="fe nb nc nd ne b">Teacher</code>类创建以下标题。</p><pre class="kj kk kl km gt oa ne ob oc aw od bi"><span id="2a72" class="no md it ne b gy oe of l og oh">class Student(Person):<br/>    pass</span><span id="0c57" class="no md it ne b gy oi of l og oh">class Teacher(Person):<br/>    pass</span></pre><h2 id="1d5f" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">继承属性和方法</h2><p id="2d89" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">到目前为止，我们在学生和教师的主体中没有任何代码。但是子类化允许子类继承我们在超类中定义的所有属性和方法。这正是子类化的主要优势——超类的子类可以立即获得共享功能，而子类化不需要做任何事情。让我们来观察这个效果:</p><pre class="kj kk kl km gt oa ne ob oc aw od bi"><span id="6159" class="no md it ne b gy oe of l og oh">student = Student("David", 20020)<br/>student.load_account(50)</span><span id="e74e" class="no md it ne b gy oi of l og oh">teacher = Teacher("Ashley", 1000033)<br/>teacher.load_account(100)</span></pre><p id="ec5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我们可以使用超类中定义的构造函数创建一个<code class="fe nb nc nd ne b">Student</code>类的实例，并在这个实例上调用<code class="fe nb nc nd ne b">load_account</code>方法。我们可以用<code class="fe nb nc nd ne b">Teacher</code>类做同样的事情。</p><h2 id="237b" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">重写初始化方法</h2><p id="1c88" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在许多情况下，我们需要覆盖子类中的初始化方法，因为我们可能拥有比超类中定义的更多的属性。让我们先看看代码，仅以<code class="fe nb nc nd ne b">Student</code>类为例，您可以将相同的技术应用于<code class="fe nb nc nd ne b">Teacher</code>类。</p><pre class="kj kk kl km gt oa ne ob oc aw od bi"><span id="b3ce" class="no md it ne b gy oe of l og oh">class Student(Person):<br/>    def __init__(self, name, student_id, grade):<br/>        super().__init__(name, student_id)<br/>        self.grade = grade</span><span id="252e" class="no md it ne b gy oi of l og oh">student = Student("David", 20020, 3)<br/>print(student.__dict__)</span><span id="b2a7" class="no md it ne b gy oi of l og oh"># output: {'name': 'David', 'person_id': 20020, 'grade': 3}</span></pre><p id="a451" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nb nc nd ne b">__init__</code>方法中，我们可以像在自定义类中一样初始化grade属性。除此之外，最值得注意的是我们通过调用<code class="fe nb nc nd ne b">super().__init__(name, student_id)</code>来使用超类的初始化方法。调用<code class="fe nb nc nd ne b">super()</code>会创建一个引用超类(<code class="fe nb nc nd ne b">Person</code>)的代理对象，这样我们就可以通过发送<code class="fe nb nc nd ne b">name</code>和<code class="fe nb nc nd ne b">person_id</code>来使用超类的初始化方法。您可能知道这一点，但这只是一个友好的提醒，调用<code class="fe nb nc nd ne b">__init__</code>不会获得任何返回值，它只是简单地设置初始化属性。</p><h2 id="13e8" class="no md it bd me np nq dn mi nr ns dp mm li nt nu mo lm nv nw mq lq nx ny ms nz bi translated">覆盖其他方法</h2><p id="a09e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你需要覆盖其他方法的时候，和覆盖<code class="fe nb nc nd ne b">__init__</code>没有太大的区别。如果您需要完全覆盖一个方法，您可以通过使用<code class="fe nb nc nd ne b">super()</code>只编写方法的主体，而不调用超类的方法。因为<strong class="lb iu">方法解析顺序(MRO) </strong>，您可以定义该方法，就像在超类中没有相同方法的实现一样，这将在下面讨论。</p><p id="6410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您部分覆盖该方法，您可以使用<code class="fe nb nc nd ne b">super()</code>来重用与超类相同的实现，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">更新的学生班级</p></figure><p id="72ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在更新的<code class="fe nb nc nd ne b">Student</code>类中，我们现在实现了<code class="fe nb nc nd ne b">check_in</code>方法。值得注意的是，我们使用<code class="fe nb nc nd ne b">super()</code>来创建一个代理对象，它是超类的实例对象，这样我们就可以在这个代理实例对象上调用超类的实例方法。因此，<code class="fe nb nc nd ne b">super()</code>的独特之处在于<strong class="lb iu">不仅可以创建超类的代理对象，还可以是超类实例的代理对象，让您可以访问实例方法。</strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="607a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.了解MRO</h1><p id="120e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你有一个类层次结构(超类-子类)时，当你在子类的一个实例上调用一个方法时，你可能想知道这个方法是如何被调用的。例如，你的子类可能实现超类没有的方法，或者实现超类也实现的方法。</p><p id="a767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何知道使用了哪个实现？这就是MRO的概念发挥作用的地方——它决定了如何按照特定的顺序解决方法。下图显示了MRO的工作原理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/06eec475095f6966908115e35b3dced4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*0plLNT5e2p7MjUpSBEdKBQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">MRO流</p></figure><p id="2858" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，当您调用一个方法时，比如说<code class="fe nb nc nd ne b">some_method</code>，Python首先试图通过在<code class="fe nb nc nd ne b">Student</code>类中定位它来解析它。如果实现，则使用此实现。如果没有，它尝试去<code class="fe nb nc nd ne b">Student</code>的超类<code class="fe nb nc nd ne b">Person</code>，如果实现了，它就解决了。否则，它将上升到object类，默认情况下，所有自定义类都从object类继承。如果仍未解决，升起<code class="fe nb nc nd ne b">AttributeError</code>。</p><p id="6372" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您实际上可以通过调用类上的<code class="fe nb nc nd ne b">mro</code>方法来检查类的MRO，这将按照方法被解析的顺序给出类的列表。</p><pre class="kj kk kl km gt oa ne ob oc aw od bi"><span id="8436" class="no md it ne b gy oe of l og oh">&gt;&gt;&gt; Student.mro()<br/>[&lt;class '__main__.Student'&gt;, &lt;class '__main__.Person'&gt;, &lt;class 'object'&gt;]</span></pre><blockquote class="ng nh ni"><p id="6dff" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">如你所料，顺序与上图所示的一致，对于<code class="fe nb nc nd ne b">Student</code>类，它是<code class="fe nb nc nd ne b">Student</code>-&gt;-<code class="fe nb nc nd ne b">Person</code>-&gt;-<code class="fe nb nc nd ne b">object</code>。</p></blockquote><p id="f722" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您有多个继承时，您也可以通过调用<code class="fe nb nc nd ne b">mro</code>方法来找出MRO。请注意，拥有多个继承通常不是一个好主意，这会使您的代码库变得复杂。换句话说，最好使用单一继承。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="09a6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.使用受保护的私有方法</h1><p id="edc2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在OOP中封装数据的一种方法是创建受保护的私有方法。虽然Python并不真正使用公共和非公共方法的概念/关键字，但是我们可以通过在方法名前面加上一两个下划线来创建受保护的和私有的方法，如下所示。</p><pre class="kj kk kl km gt oa ne ob oc aw od bi"><span id="d757" class="no md it ne b gy oe of l og oh">class Person:<br/>    def __init__(self, name, person_id):<br/>        self.name = name<br/>        self.person_id = person_id</span><span id="d91f" class="no md it ne b gy oi of l og oh">    def _login(self):<br/>        pass</span><span id="c196" class="no md it ne b gy oi of l og oh">    def __logout(self):<br/>        pass</span></pre><p id="f55b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，<code class="fe nb nc nd ne b">_login </code>是一个受保护的方法，而<code class="fe nb nc nd ne b">__logout</code>是一个私有方法。这两个方法都是非公共的，这意味着它们不打算由类外的用户调用，并且当您使用ide(使用PyCharm的图)时，可以注意到这一点，其中通过自动完成提示来提示可用的方法，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/588f52aede7dbf857f32f3a3c97ba9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tn3UD38aKePlXMHzdkPktQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">没有非公共方法的提示</p></figure><p id="ea51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">受保护方法和私有方法之间的区别不仅仅是使用一两个下划线，另一个重要的区别是它们在类的子类中的可访问性。<strong class="lb iu">您可以调用超类的受保护方法，但不能调用私有方法。</strong>下面可以观察到这个效果。</p><pre class="kj kk kl km gt oa ne ob oc aw od bi"><span id="5fbc" class="no md it ne b gy oe of l og oh">class Student(Person):<br/>    def test_login_logout(self):<br/>        self._login()<br/>        self.__logout()<br/></span><span id="42fe" class="no md it ne b gy oi of l og oh">student = Student("David", 20020)<br/>student.test_login_logout()</span><span id="65cb" class="no md it ne b gy oi of l og oh"># ERROR:<br/><strong class="ne iu">AttributeError: 'Student' object has no attribute '_Student__logout'</strong></span></pre><p id="34f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从打印输出中，我们可以看到<code class="fe nb nc nd ne b">_login</code>被调用，没有任何问题。但是，<code class="fe nb nc nd ne b">__logout</code>不能被调用，提高了<code class="fe nb nc nd ne b">AttributeError</code>。如果我们仔细观察，我们注意到它不是试图调用<code class="fe nb nc nd ne b">__logout</code>，而是试图调用<code class="fe nb nc nd ne b">_Student__logout </code>。这看起来很奇怪，但它被称为<strong class="lb iu">名称篡改</strong>功能。也就是说，当你定义一个私有方法时，假设它在一个名为<code class="fe nb nc nd ne b">Data</code>的类中被命名为<code class="fe nb nc nd ne b">__private_method</code>，这个方法被命名为<code class="fe nb nc nd ne b">_Data__private_method</code>。</p><blockquote class="ng nh ni"><p id="fd6d" class="kz la nj lb b lc ld ju le lf lg jx lh nk lj lk ll nl ln lo lp nm lr ls lt lu im bi translated">由于它们在子类中的不同可访问性，如果您希望它们在子类中使用，您应该定义受保护的方法，如果您不希望子类使用它们，您应该改为定义私有方法。</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="762f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="f2c6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我们回顾了在Python中定义子类的要点。本质上，在类层次结构中，有一个超类，在其中定义共享的属性和方法。</p><p id="aebc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该有多个继承自这个超类的子类——如果你注意到你只使用了一个子类，这是不对的——没有必要一开始就创建一个超类。</p></div></div>    
</body>
</html>