<html>
<head>
<title>Data Structures: An Introduction to Stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:堆栈介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/data-structures-an-introduction-to-stacks-a902cd830018?source=collection_archive---------12-----------------------#2019-11-13">https://betterprogramming.pub/data-structures-an-introduction-to-stacks-a902cd830018?source=collection_archive---------12-----------------------#2019-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8f07" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数组很棒，但是你试过堆栈吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c24a9125bd7cca40db25dea92a50a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ysX9AqKvPthZ5fFT2rOhpA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@eaterscollective?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">食客集体</a>在<a class="ae kv" href="https://unsplash.com/s/photos/stack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="e5da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇博文中，我们将使用C编程语言学习、实现和全面介绍堆栈数据结构。</p><p id="d0ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在理解栈数据结构之前，你应该对<em class="ls">数组</em>和<em class="ls">链表</em>有很好的理解，因为只有借助这两种数据结构，我们才能实现栈。</p><p id="8705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，对于实现任何数据结构，无论是堆栈、队列、树等。，我们必须使用数组或者链表。</p><p id="42c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你可以预测数据结构的大小(需要多少内存)，那么你可以使用数组，否则，你可以使用链表动态分配内存。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="9cc7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">推荐给初学者的资源</h1><ul class=""><li id="6d3f" class="ms mt iq ky b kz mu lc mv lf mw lj mx ln my lr mz na nb nc bi translated"><a class="ae kv" href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850" rel="noopener ugc nofollow" target="_blank"> <em class="ls">破解编码访谈:189个编程问题及解答</em> </a>盖尔·拉克曼·麦克道尔著。</li><li id="9f99" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://www.amazon.com/Introduction-Algorithms-3rd-MIT-Press/dp/0262033844" rel="noopener ugc nofollow" target="_blank"> <em class="ls">算法简介</em> </a>托马斯·h·科尔曼著。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2e75" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">栈的概念</h1><p id="078a" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">将堆叠视为从底部到顶部垂直放置的一系列<em class="ls">板</em>。</p><p id="f7d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设有五个板块，P1、P2、P3、P4和P5，你想把它们组织成一堆(也就是把它们一个放在另一个上面)，那么你会怎么做呢？</p><p id="2104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，你会拿起第一个盘子，P1，在它上面，你会把盘子P2，然后下一个盘子，等等，直到你把最后一个盘子，即P5。</p><p id="3d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一切形成了一堆板块，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/8df28097f74252ac560ecb7b85befae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TEOVo6feDvmU4QOa.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">堆栈的图示视图</p></figure><p id="9a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且，无论何时你想要接近或取出一个特定的板，你必须首先看到你想要接近的板是否在顶部。</p><p id="df6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们想要访问P3，那么在到达P3板块之前，首先必须从堆栈中移除P5和P4板块。</p><p id="de34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">堆栈也称为后进先出(LIFO ),意思是最后插入堆栈的元素将首先从堆栈中移除。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1fa3" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">堆栈上的操作</h1><ol class=""><li id="b30e" class="ms mt iq ky b kz mu lc mv lf mw lj mx ln my lr nm na nb nc bi translated">推入:将元素插入堆栈。</li><li id="ea27" class="ms mt iq ky b kz nd lc ne lf nf lj ng ln nh lr nm na nb nc bi translated">从堆栈中删除一个元素。</li></ol></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="384d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">堆栈的实现</h1><p id="f73d" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">有两种方法可以实现堆栈数据结构。</p><h2 id="b188" class="nn mb iq bd mc no np dn mg nq nr dp mk lf ns nt mm lj nu nv mo ln nw nx mq ny bi translated">1.使用数组</h2><p id="e405" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在这个表示中，我们将使用索引以<code class="fe nz oa ob oc b">0</code>开始的数组来实现堆栈。</p><p id="27be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在插入或删除一个元素之前，我们必须检查两个条件，第一个是溢出条件，第二个是下溢条件。</p><p id="831e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">溢出条件</em>只是检查堆栈是否已满。如果它已经满了，那么你就不能在栈中插入一个新元素。</p><p id="1cdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">下溢条件</em>检查堆栈是否为空，因为如果堆栈已经为空，并且如果我们试图删除一个甚至不存在的元素，因为堆栈已经为空，我们肯定会得到一个错误。</p><p id="789e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些是我们必须检查的一些极限情况，以确保我们的程序在任何情况下都能完美运行，没有任何错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/10f8f98f78fb4602155b5da54b53124c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PJufa765v_FCXa9i.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用数组的堆栈实现</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用数组的堆栈实现</p></figure><p id="64b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe nz oa ob oc b">top</code> <strong class="ky ir"> </strong>指针跟踪堆栈的最顶端位置。如果顶部指针的值是<code class="fe nz oa ob oc b">-1</code>，那么它代表堆栈是空的。这一点也适用于栈的链表表示。</p><p id="bac2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在堆栈中，当我们弹出一个元素时，我们实际上并没有像在链表中那样从堆栈中删除该元素。这里，我们只是减少了顶部指针，而那个特定堆栈块中的值仍然存在。</p><p id="d142" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在数组中插入和删除元素的时间复杂度为O(1)，即常数时间。</p><h2 id="9c12" class="nn mb iq bd mc no np dn mg nq nr dp mk lf ns nt mm lj nu nv mo ln nw nx mq ny bi translated">2.使用链接列表</h2><p id="2f65" class="pw-post-body-paragraph kw kx iq ky b kz mu jr lb lc mv ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">在这个表示中，我们将使用一个链表来实现堆栈数据结构。</p><p id="7a84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道，链表由不同的节点组成，每个节点有两个东西。一个是<em class="ls">数据</em>，另一个是指向下一个节点的<em class="ls">指针</em>。</p><p id="1b26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，在插入元素之前，我们首先必须创建一个新节点，然后将该节点添加到一个链表中。这里，我们也必须检查上溢和下溢条件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/b29559468b575732abdb87b8fb93b1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uXP5B-KdmcosIkYu.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/8d5d47c967b1e4950e1901523ed42861.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OXI7h9GV3cr26Jgb.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/db62c67cddce9a58a8b319440bae88a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XXoVsVhhoFfvm39-.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/c6709f53afd0cc33784da865bd24b221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g839jHYakFUqsLxz.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/9e1ca8fc2fdd979b10890b611c5bda4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XcF7NiLcHbNZtaK_.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用链表的堆栈实现</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="od oe l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用链表的堆栈实现</p></figure><p id="283a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">链表中元素的插入和删除的<em class="ls">时间复杂度</em>也取O(1)，即常数时间。</p><p id="1b68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多这样的博客请访问<a class="ae kv" href="https://liongueststudios.com/" rel="noopener ugc nofollow" target="_blank"> LionGuest工作室</a>。</p><p id="d66f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>