<html>
<head>
<title>Algorithms: Quicksort with Haskell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法:用Haskell快速排序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/quicksort-with-haskell-75cb07ec57f3?source=collection_archive---------6-----------------------#2019-05-13">https://betterprogramming.pub/quicksort-with-haskell-75cb07ec57f3?source=collection_archive---------6-----------------------#2019-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="69c1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及ST monad如何启用可变数组</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1030649c2d4a6e1c1924a0c43f6a80cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GcPCHyH_HHS1zuLQ4UYKcw.png"/></div></div></figure><p id="9e47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><a class="ae lq" href="https://www.mmhaskell.com/blog/2019/5/6/making-arrays-mutable" rel="noopener ugc nofollow" target="_blank">在这篇文章</a>中，我们引用了<code class="fe lr ls lt lu b">ST</code>单子，并研究了它如何启用可变数组。<code class="fe lr ls lt lu b">ST</code> mondad是<code class="fe lr ls lt lu b">IO</code> monad的替代物，它给我们可变的数据而没有副作用。现在，我们暂时停止向我们的<a class="ae lq" href="https://www.github.com/jhb563/MazeGame" rel="noopener ugc nofollow" target="_blank">迷宫游戏</a>添加功能，而是看一个具体的例子，其中可变数据可以允许不同的算法。</p><p id="4862" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑一下<a class="ae lq" href="https://www.geeksforgeeks.org/quick-sort/" rel="noopener ugc nofollow" target="_blank">快速排序算法</a>。我们可以“就地”做这件事，改变一个输入数组，但是Haskell中不可变的数据使这种方法很难实现。让我们研究另一种使用普通的不可变列表的方法，然后看看我们如何使用一个更常见的使用<code class="fe lr ls lt lu b">ST</code>的快速排序算法。最终，按照我们希望的方式进行这项工作仍然有困难，但这仍然是一个有用的尝试。</p><p id="7e53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对Haskell中的monads还陌生吗？你会发现这个关于<a class="ae lq" href="https://www.mmhaskell.com/monads" rel="noopener ugc nofollow" target="_blank">单子和功能结构</a>的系列很有用。它将帮助你从头开始学习单子，从像函子这样简单的概念开始。</p><h1 id="4ddd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">圣莫纳德</h1><p id="ae9d" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">在我们深入使用数组之前，让我们花点时间来理解一下<code class="fe lr ls lt lu b">ST</code>单子的用途。我第一次尝试在迷宫游戏中使用可变数组时使用了一个<code class="fe lr ls lt lu b">IOArray</code>。这是可行的，但是它导致了<code class="fe lr ls lt lu b">generateRandomMaze</code>使用<code class="fe lr ls lt lu b">IO</code>单子。您应该警惕任何将您的代码从纯代码更改为使用<code class="fe lr ls lt lu b">IO</code>的行为。这个函数的新版本可能会有许多旧版本中没有的奇怪的错误和副作用，比如文件系统访问。此外，这使得使用和测试这些代码变得更加困难。</p><p id="0ae4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我的具体案例中，有一个更紧迫的问题。从<code class="fe lr ls lt lu b">eventHandler</code>内部运行随机生成变得不可能。这意味着我不能以我想要的方式重启游戏。处理程序是一个纯函数，不能使用<code class="fe lr ls lt lu b">IO</code>。</p><p id="3f9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">单子正是我们所需要的。它允许我们运行可以在适当的位置<strong class="kw iu">改变值的代码，而不像<code class="fe lr ls lt lu b">IO</code>那样允许任意的副作用</strong>。我们可以使用通用的<code class="fe lr ls lt lu b">runST</code>函数将<code class="fe lr ls lt lu b">ST</code>单子中的计算转换成它的纯结果。这类似于我们如何使用<code class="fe lr ls lt lu b">runState</code>来运行一个纯粹的<code class="fe lr ls lt lu b">State</code>计算。</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="4f85" class="mw lw it lu b gy mx my l mz na">runST :: (forall. s ST a) -&gt; a</span></pre><p id="b293" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lr ls lt lu b">s</code>参数有点神奇。我们通常不必指定它是什么，但是该参数可以防止外界对数据产生额外的副作用。不要太担心。</p><p id="55f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一个函数<code class="fe lr ls lt lu b">runSTArray, </code>做同样的事情——除了它处理可变数组:</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="ff9a" class="mw lw it lu b gy mx my l mz na">runSTArray :: (forall. s ST s (STArray s i e)) -&gt; Array i e</span></pre><p id="f9f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这允许我们使用<code class="fe lr ls lt lu b">STArray</code>而不是<code class="fe lr ls lt lu b">IOArray</code>作为可变数据类型。在本文的后面，我们将使用这种类型来实现我们的“就地”快速排序算法。首先，让我们看看这个算法的一个更简单的版本。</p><h1 id="3cf2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">慢速快速排序</h1><p id="66ee" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated"><a class="ae lq" href="http://learnyouahaskell.com/recursion" rel="noopener ugc nofollow" target="_blank">学习Haskell以获得更好的效果</a>简要介绍了快速排序算法。它展示了我们表达递归解的优雅。</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="7284" class="mw lw it lu b gy mx my l mz na">quicksort1 :: (Ord a) =&gt; [a] -&gt; [a]<br/>quicksort1 [] = []<br/>quicksort1 (x:xs) =<br/>  let smallerSorted = quicksort1 [a | a &lt;- xs, a &lt;= x]<br/>      biggerSorted = quicksort1 [a | a &lt;- xs, a &gt; x]<br/>  in  smallerSorted ++ [x] ++ biggerSorted</span></pre><p id="bc2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个看起来不错！它抓住了快速排序的一般思想。我们将第一个元素作为枢纽，然后将剩余的列表分成大于枢纽和小于枢纽的元素。然后我们递归地排序这些子列表中的每一个，并把它们和中间的枢纽结合起来。</p><p id="dae5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们制作的每个新列表都需要额外的内存。我们在每一个递归步骤中都复制了列表的一部分。因此，对于这个算法，我们将至少使用<code class="fe lr ls lt lu b">O(n)</code>内存。</p><p id="ad81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还可以注意到这个算法选择其枢纽的方式:它总是选择第一个元素。这对于某些输入(排序或反向排序的数组)来说效率很低。为了让性能满足我们的期望，我们希望随机选择枢纽指数。然而，我们需要一个额外的类型为<code class="fe lr ls lt lu b">StdGen</code>的参数，所以在本文中我们将忽略它。</p><p id="8c11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，可以“就地”进行快速排序，而不用复制数组的任何部分，但是这需要可变内存。为了了解这个算法，我们首先用Java实现它。可变数据在Java中更自然，所以代码更容易理解。</p><h1 id="a179" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">就地快速排序(Java)</h1><p id="1807" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">快速排序算法是递归的，但是我们将在一个助手中处理递归。助手将接受两个额外的参数:quicksort部分的“start”和“end”的int值。<code class="fe lr ls lt lu b">quicksortHelper</code>的目标是确保我们只对这部分进行了排序<strong class="kw iu">。出于风格上的原因，我使用“end”来表示我们排序的点之后的一个索引。所以我们的主<code class="fe lr ls lt lu b">quicksort</code>函数会用<code class="fe lr ls lt lu b">0</code>和<code class="fe lr ls lt lu b">arr.length</code>调用助手。</strong></p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="da64" class="mw lw it lu b gy mx my l mz na">public static void quicksort(int[] arr) {<br/>  quicksortHelper(arr, 0, arr.length);<br/>}</span><span id="2ffc" class="mw lw it lu b gy nb my l mz na">public static void quicksortHelper(int[] arr, int start, int end) {<br/>  ...<br/>}</span></pre><p id="189e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们看这个函数的其余部分之前，让我们设计两个更小的助手。第一个很简单，它将交换数组中的两个元素:</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="4e00" class="mw lw it lu b gy mx my l mz na">public static void swap(int[] arr, int i, int j) {<br/>  int temp = arr[i];<br/>  arr[i] = arr[j];<br/>  arr[j] = temp;<br/>}</span></pre><p id="4adb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一个助手将包含算法的核心——这是我们的<code class="fe lr ls lt lu b">partition</code>函数。它负责选择一个支点(同样，为了简单起见，我们将使用第一个元素)，然后它划分数组，使得比支点小的所有元素都在数组的第一部分。接下来，我们插入枢轴，并获得更大的元素。它返回分区的索引:</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="71db" class="mw lw it lu b gy mx my l mz na">public static int partition(int[] arr, int start, int end) {<br/>  int pivotElement = arr[start];<br/>  int pivotIndex = start + 1;<br/>  for (int i = start + 1; i &lt; end; ++i) {<br/>    if (arr[i] &lt;= pivotElement) {<br/>      swap(arr, i, pivotIndex);<br/>      ++pivotIndex;<br/>    }<br/>  }<br/>  swap(arr, start, pivotIndex - 1);<br/>  return pivotIndex - 1;<br/>}</span></pre><p id="a314" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们的快速排序助手很简单！它将对数组进行分区，然后对子部分进行递归调用。还要注意基本情况:</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="4d45" class="mw lw it lu b gy mx my l mz na">public static void quicksortHelper(int[] arr, int start, int end) {<br/>  if (start + 1 &gt;= end) {<br/>    return;<br/>  }<br/>  int pivotIndex = partition(arr, start, end);<br/>  quicksortHelper(arr, start, pivotIndex);<br/>  quicksortHelper(arr, pivotIndex + 1, end);<br/>}</span></pre><p id="13c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们已经做好了一切准备，所以我们没有分配任何新的阵列！所以我们的函数定义只为临时值增加了额外的内存。因为堆栈深度平均为<code class="fe lr ls lt lu b">O(log n)</code>，所以这是该算法的渐进内存使用量。</p><h1 id="1bca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">就地快速排序(Haskell)</h1><p id="d92b" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">现在我们已经熟悉了就地算法，让我们看看它在Haskell中是什么样子的。我们想用<code class="fe lr ls lt lu b">STArray</code>做到这一点，但我们还是会写一个纯输入输出的函数。不幸的是，这意味着我们无论如何都要使用<code class="fe lr ls lt lu b">O(n)</code>内存。<code class="fe lr ls lt lu b">thaw</code>函数必须复制数组来创建它的可变版本。然而，我们的其余操作将在可变数组上就地工作。我们将遵循与Java代码相同的模式。让我们从简单开始，编写我们的<code class="fe lr ls lt lu b">swap</code>函数:</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="1c5a" class="mw lw it lu b gy mx my l mz na">swap :: ST s Int a -&gt; Int -&gt; Int -&gt; ST s ()<br/>swap arr i j = do<br/>  elem1 &lt;- readArray arr i<br/>  elem2 &lt;- readArray arr j<br/>  writeArray arr i elem2<br/>  writeArray arr j elem1</span></pre><p id="8b61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们写出我们的<code class="fe lr ls lt lu b">partition</code>函数。我们将尽可能使它看起来像我们的Java版本，但是这有点棘手，因为我们没有for循环。我们将正面处理这个问题，设计一个函数来处理这个循环。</p><p id="205e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该循环为最终的枢纽索引生成我们的值，但是我们必须跟踪它的当前值。这听起来像是单子上的工作。我们的状态函数将把<code class="fe lr ls lt lu b">pivotElement</code>和数组本身作为参数，然后它将把最后一个参数作为我们在Java版本的分区循环中的<code class="fe lr ls lt lu b">i</code>值。</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="8d2f" class="mw lw it lu b gy mx my l mz na">partitionLoop :: (Ord a)<br/>  =&gt; STArray s Int a<br/>  -&gt; a<br/>  -&gt; Int<br/>  -&gt; StateT Int (ST s) ()<br/>partitionLoop arr pivotElement i = do<br/>  ...</span></pre><p id="bff9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用与Java版本相当的代码填充它。我们读取当前的pivot和当前<code class="fe lr ls lt lu b">i</code>索引的元素，然后，如果它更小，我们在数组中交换它们并增加pivot:</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="ce8e" class="mw lw it lu b gy mx my l mz na">partitionLoop :: (Ord a)<br/>  =&gt; STArray s Int a<br/>  -&gt; a<br/>  -&gt; Int<br/>  -&gt; StateT Int (ST s) ()<br/>partitionLoop arr pivotElement i = do<br/>  pivotIndex &lt;- get<br/>  thisElement &lt;- lift $ readArray arr i<br/>  when (thisElement &lt;= pivotElement) $ do<br/>    lift $ swap arr i pivotIndex<br/>    put (pivotIndex + 1)</span></pre><p id="8539" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，在得到pivot元素后，我们将这个循环合并到我们的主要<code class="fe lr ls lt lu b">partition</code>函数中。我们将使用<code class="fe lr ls lt lu b">mapM</code>对状态动作进行排序，并将其传递给<code class="fe lr ls lt lu b">execStateT</code>。然后我们将返回最后一个支点(减1)。不要忘记把轴心换到数组的中间！</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="f103" class="mw lw it lu b gy mx my l mz na">partition :: (Ord a)<br/> =&gt; STArray s Int a<br/> -&gt; Int<br/> -&gt; Int<br/> -&gt; ST s Int<br/>partition arr start end = do<br/>  pivotElement &lt;- readArray arr start<br/>  let pivotIndex_0 = start + 1<br/>  finalPivotIndex &lt;- execStateT<br/>    (mapM (partitionLoop arr pivotElement) [(start+1)..(end-1)])<br/>    pivotIndex_0<br/>  swap arr start (finalPivotIndex - 1)<br/>  return $ finalPivotIndex - 1</span></pre><p id="40df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在很容易将这些合并到我们的最终函数中:</p><pre class="kj kk kl km gt ms lu mt mu aw mv bi"><span id="e560" class="mw lw it lu b gy mx my l mz na">quicksort2 :: (Ord a) =&gt; Array Int a -&gt; Array Int a<br/>quicksort2 inputArr = runSTArray $ do<br/>  stArr &lt;- thaw inputArr<br/>  let (minIndex, maxIndex) = bounds inputArr<br/>  quicksort2Helper minIndex (maxIndex + 1) stArr<br/>  return stArr</span><span id="d09a" class="mw lw it lu b gy nb my l mz na">quicksort2Helper :: (Ord a)<br/>  =&gt; Int <br/>  -&gt; Int<br/>  -&gt; STArray s Int a<br/>  -&gt; ST s ()<br/>quicksort2Helper start end stArr = when (start + 1 &lt; end) $ do<br/>  pivotIndex &lt;- partition stArr start end<br/>  quicksort2Helper start pivotIndex stArr<br/>  quicksort2Helper (pivotIndex + 1) end stArr</span></pre><p id="b181" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就完成了我们的算法！请再次注意，我们使用了<code class="fe lr ls lt lu b">thaw</code>和<code class="fe lr ls lt lu b">freeze</code>。这意味着我们的主<code class="fe lr ls lt lu b">quicksort2</code>函数可以有纯粹的输入和输出，但这是以额外的内存为代价的。不过，我们可以在纯函数中使用可变数据，这很酷！</p><h1 id="4120" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="e5a5" class="pw-post-body-paragraph ku kv it kw b kx mn ju kz la mo jx lc ld mp lf lg lh mq lj lk ll mr ln lo lp im bi translated">由于我们必须复制列表，这个例子并没有带来太多的改进。事实上，当我们对这些函数进行基准测试时，我们发现第一个函数的执行速度要快得多。然而，理解我们如何在Haskell中“就地”操作数据仍然是有用的。单子允许我们以一种“纯”的方式来做这件事。如果我们愿意接受不纯的代码，那么<code class="fe lr ls lt lu b">IO</code>单子也是可能的。</p></div></div>    
</body>
</html>