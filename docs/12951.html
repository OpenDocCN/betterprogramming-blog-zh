<html>
<head>
<title>External Debugging Tools 1: DTrace and strace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外部调试工具1: DTrace和strace</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/external-debugging-tools-1-dtrace-and-strace-7e4cf58280f4?source=collection_archive---------7-----------------------#2022-07-13">https://betterprogramming.pub/external-debugging-tools-1-dtrace-and-strace-7e4cf58280f4?source=collection_archive---------7-----------------------#2022-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e7f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更轻松地解决项目问题的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ee3eb4c5b71fc0fab65f4ebbb5b0f849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhHFAEHPI7Hczd-d2jd78w.jpeg"/></div></div></figure><p id="4114" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常在调试时，我们需要跳出ide舒适的怀抱来重现或跟踪问题。在这个系列中，我将介绍一些对这些案例有用的工具。我会尽量限制自己使用100%调试工具，而不是那些对开发测试有用的工具。</p><p id="e92e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，像<a class="ae ln" href="https://curl.se/" rel="noopener ugc nofollow" target="_blank"> curl </a>或<a class="ae ln" href="https://stedolan.github.io/jq/" rel="noopener ugc nofollow" target="_blank"> jq </a>这样的工具非常有用。您可以并且应该在调试时使用它们。但是您可能在构建和测试特性时使用过它们，所以您应该已经熟悉它们，并且应该对它们的功能有所了解。我想把重点放在您在调试时最常使用的工具上。从这个意义上说，像<a class="ae ln" href="https://sdkman.io/" rel="noopener ugc nofollow" target="_blank"> SDKMan </a>等工具。在这里也没有意义。</p><p id="cbba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我还想避免使用像数据库工具这样的工具。它们在调试时非常有用，但是同样，您也可能在开发过程中使用它们。它们也是非常特定于供应商的，所以这是一个非常广泛的主题，在这里无法涵盖。</p><p id="3341" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在本系列中介绍的工具包括以下几类:</p><ul class=""><li id="1a36" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">系统监控工具——如我们今天将要讨论的strace和DTrace</li><li id="1985" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">网络显示器——也属于上述类别，但有其自身的类别</li><li id="df96" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">VM/运行时监控——例如，让我们检查JVM的工具等。</li><li id="01a5" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">分析器和内存监视器</li></ul><p id="8bff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这第一篇文章中，我想讨论两个重量级冠军:DTrace和strace。如果您是Java开发人员或Windows用户，您很可能从未听说过这些工具。您可能无意中使用了其中的一个，因为许多工具都是基于它们构建的，但事实可能并非如此。</p><p id="5707" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两个工具都可以让你在没有源代码的情况下调试任何东西。你可以发现问题，并获得你从未想象过的理解。</p><h1 id="38ba" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">DTrace</h1><p id="8638" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">早在2004年，我在Sun Microsystems工作时第一次听说了DTrace。它在走廊里风靡一时，因为这是太阳微系统公司正在推广的一项创新。DTrace后来被移植到MacOS X中(它起源于Solaris)。今天，Windows和Linux上也有端口。</p><p id="b3da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">DTrace是一个强大的低级动态跟踪框架。但这只是另一个最高级，如果您从未使用过这样的工具，也没有系统编程背景，您可能会感到有点困惑:它到底是干什么的？</p><p id="1fc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它让你“看到”一切。想知道一个进程打开了哪些文件？</p><p id="ec44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的。</p><p id="3e77" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想知道是谁调用了一个内核API并获得了对调用者的堆栈跟踪吗？</p><p id="2ac5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的。</p><p id="9c88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想知道一个进程为什么会死？</p><p id="36c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的。</p><p id="c114" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想知道一个操作要花多少CPU时间？</p><p id="48f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的。</p><p id="93ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能认为DTrace是那些会完全摧毁您的CPU的工具之一…但是它有一个致命的特性:它足够快，可以在生产中运行，对性能的影响很小甚至没有影响！</p><p id="6476" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它在近二十年前推出时是革命性的，直到今天仍然如此！</p><h1 id="1baa" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">运行DTrace</h1><p id="9250" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">在我们开始之前，有一个警告。保存您的数据！</p><p id="8be7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个工具很容易让你的机器崩溃，启用它需要禁用MacOS上的重要安全设施。这是一种有风险的“低级”系统服务，应该如此对待。</p><p id="735a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Mac上，DTrace与“系统完整性保护”相冲突，系统完整性保护是一种阻止进程间某些交互的安全功能。正常情况下，这就太好了。但是，如果您想运行DTrace，这将是一个问题。</p><p id="7288" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">解决方案是在英特尔MAC上引导至恢复模式；这意味着开机时按住<code class="fe mz na nb nc b">Command-R</code>键。在ARM mac上，只需长按电源按钮。</p><p id="89f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，在恢复模式终端中，发出命令:<code class="fe mz na nb nc b">csrutil disable</code>。</p><p id="75f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在重新启动时，DTrace应该按预期工作。</p><h1 id="f1c9" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">基本用法</h1><p id="7684" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">如前所述，DTrace是一个非常强大的工具。有很多关于它的书。它有自己的基于C语法的编程语言，可以用来构建复杂的逻辑。例如，以下命令将记录来自给定回调的一些信息:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="237f" class="nh md iq nc b gy ni nj l nk nl">sudo dtrace -qn 'syscall::write:entry, syscall::sendto:entry /pid == $target/ { printf("(%d) %s %s", pid, probefunc, copyinstr(arg1)); }' -p [PID]</span></pre><p id="9cd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">传递给DTrace命令的代码段侦听目标进程ID上的sendto回调。然后将信息打印到控制台，例如:<code class="fe mz na nb nc b">(pid) text</code></p><p id="0c8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果这看起来有点太多太难开始…你是100%正确的。当你需要它的时候，它是一个强大的工具。但是对于我们大多数的日常使用来说，它实在是太强大了。我们想要的是知道一点基本的东西，这太多了！</p><h1 id="64b7" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">简单用法</h1><p id="b736" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">幸运的是，我们有一个简单的解决方案:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="4415" class="nh md iq nc b gy ni nj l nk nl">man -k dtrace</span></pre><p id="aefc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这打印出了一个值得一读的工具列表，只是为了了解这个东西有多广泛。下面是该命令的几行有趣的输出:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="7e44" class="nh md iq nc b gy ni nj l nk nl">bitesize.d(1m)           - analyse disk I/O size by process. Uses DTrace<br/>dapptrace(1m)            - trace user and library function usage. Uses DTrace<br/>errinfo(1m)              - print errno for syscall fails. Uses DTrace<br/>iotop(1m)                - display top disk I/O events by process. Uses DTrace<br/>plockstat(1)             - front-end to DTrace to print statistics about POSIX mutexes and read/write locks</span></pre><p id="628b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这份清单值得你花时间去了解你在这里真正能做什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/2820a852fab7b135d33fa2d915aa35c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xDNmy0ej1S7EI18T"/></div></div></figure><h1 id="cd78" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">例子</h1><p id="b6b9" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">您正面临着导致应用程序性能下降的磁盘写入问题，但这是您的应用程序还是其他应用程序的问题呢？</p><p id="3c59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只需运行:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="c3bb" class="nh md iq nc b gy ni nj l nk nl">sudo rwbypid.d</span></pre><p id="6ea6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它将打印出对磁盘的读/写操作:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="82c4" class="nh md iq nc b gy ni nj l nk nl">PID CMD                       DIR    COUNT<br/>  2957 wordexp-helper              W        1<br/>  2959 wc                          W        1<br/>  2961 grep                        W        1</span><span id="e25a" class="nh md iq nc b gy nn nj l nk nl">... snipped for clarity ...</span><span id="b7b2" class="nh md iq nc b gy nn nj l nk nl">   637 firefox                     R     6937<br/>   637 firefox                     W    15325<br/>   343 sentineld                   W   100287</span></pre><p id="46ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">安全软件确实降低了性能…</p><p id="b467" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还可以使用<code class="fe mz na nb nc b">bitesize.d</code>来获得关于写入/分布的字节数的更具体的结果。</p><p id="7004" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不过，这已经是很高的水平了。如果您想知道细节:文件名、进程名等，该怎么办？</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="7316" class="nh md iq nc b gy ni nj l nk nl">sudo iosnoop -a</span></pre><p id="1997" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打印出几乎包含您需要的所有内容的输出:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="9c54" class="nh md iq nc b gy ni nj l nk nl">STRTIME              DEVICE  MAJ MIN   UID   PID D      BLOCK     SIZE                     PATHNAME ARGS<br/>2022 Jun 30 12:16:56 ??        1  17   501  1111 W  150777072     4096 ??/idb/3166453069wcaw.sqlite-wal firefox\0<br/>2022 Jun 30 12:16:56 ??        1  17   501   661 W  150777175   487424  ??/index-dir/the-real-index Slack Helper\0<br/>2022 Jun 30 12:16:57 ??        1  17   499   342 W  150777294     4096 ??/persistent/.dat.nosync0156.ztvXap sentineld\0</span></pre><p id="9d13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我可以看到进程id以及它向特定文件写入了多少字节！</p><p id="59b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设你的程序跨越了多个进程，你想看看发生了什么。例如，我在自己构建的服务器上运行源代码构建:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="6f8d" class="nh md iq nc b gy ni nj l nk nl">sudo errinfo</span></pre><p id="424b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我检测从系统调用返回的错误以及最初触发该错误的命令:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="3c71" class="nh md iq nc b gy ni nj l nk nl">EXEC          SYSCALL  ERR  DESC<br/>    WindowServer workq_kernreturn   -2 <br/>    WindowServer workq_kernreturn   -2 <br/>   SentinelAgent workq_kernreturn   -2 <br/>   SentinelAgent workq_kernreturn   -2 <br/>          Signal           Helper    0 <br/>          Google           Chrome    0 <br/>           Brave          Browser    0 <br/>          Google           Chrome    0</span></pre><p id="dfb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些只是冰山一角。我建议看看甲骨文的这个旧的<a class="ae ln" href="https://www.oracle.com/solaris/technologies/dtrace-tutorial.html" rel="noopener ugc nofollow" target="_blank"> DTrace教程</a>或者<a class="ae ln" href="https://www.bookdepository.com/DTrace-Brendan-Gregg/9780132091510?ref=grid-view&amp;qid=1656581174175&amp;sr=1-1" rel="noopener ugc nofollow" target="_blank">书</a>。声明:我没有读过这本书。</p><h1 id="9edf" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">斯特拉斯</h1><p id="588c" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">有趣的是，strace工具也起源于90年代的Sun Microsystems。这并不奇怪，因为来自Sun Microsystems的技术清单绝对令人麻木。</p><p id="41ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Strace在用法和功能上都比DTrace简单得多。不管是好是坏。由于DTrace需要深入的操作系统支持，它从未成为普通Linux发行版的正式特性，因此在Linux上人们使用strace而不是DTrace。不过，它们并不完全可以互换。</p><p id="79da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Strace的启用要感谢名为ptrace的内核特性。由于ptrace已经在Linux中，我们不需要添加额外的内核代码或模块。通常，DTrace需要更深层次的内核支持，为了解决Linux上的许可问题，它在一个单独的可加载模块中，但这仍然存在一些挑战。</p><p id="5e3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用strace类似于每次我们进行内核调用时打印一个日志条目。这将为您执行的每个命令创建非常详细的日志记录。因此，您可以了解正在运行的进程的真实情况。</p><h1 id="21fd" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">跑步跑道</h1><p id="b3bf" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">现在，strace在Linux中被广泛使用，它是我在这个平台上最喜欢的系统诊断工具。使用它非常方便，因为我们可以在没有特权的情况下运行它。注意，与DTrace不同，您应该让strace远离生产环境(除非代码被隔离)。它会带来巨大的性能开销，并会导致生产系统停机。</p><p id="2aa8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">strace最基本的用法是将命令行传递给它:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="a3ba" class="nh md iq nc b gy ni nj l nk nl">strace java -classpath. PrimeMain</span></pre><p id="bfa2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，strace的输出相当长。让我们来看几行:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="4dc0" class="nh md iq nc b gy ni nj l nk nl">execve("/home/ec2-user/jdk1.8.0_45/bin/java", ["java", "-classpath.", "PrimeMain"], 0x7fffd689ec20 /* 23 vars */) = 0<br/>brk(NULL)                               = 0xb85000<br/>mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0294272000<br/>readlink("/proc/self/exe", "/home/ec2-user/jdk1.8.0_45/bin/j"..., 4096) = 35<br/>access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/tls/x86_64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>stat("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/tls/x86_64", 0x7fff37af09a0) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/tls/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>stat("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/tls", 0x7fff37af09a0) = -1 ENOENT (No such file or directory)</span></pre><p id="6fd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每一行都是一个Linux系统调用。我们可以在谷歌上搜索他们每一个人，了解一下发生了什么。这里有一个简单的例子:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="734f" class="nh md iq nc b gy ni nj l nk nl">open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/tls/x86_64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)</span></pre><p id="394a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Java试图使用系统open调用从<code class="fe mz na nb nc b">tls</code>目录加载<code class="fe mz na nb nc b">pthread</code>库来加载文件。系统调用的退出代码是<code class="fe mz na nb nc b">-1</code>，这意味着文件不在那里。在正常情况下，我们应该从这个API获得一个文件描述符值。</p><p id="1deb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看目录，好像是<code class="fe mz na nb nc b">tls</code>目录不见了。我猜这是因为一个失踪的JCE装置。这可能没问题，但在某些情况下可能会很有趣。</p><p id="8bf4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很明显，有时候输出的数量是压倒性的。我们通常只想看到诸如“哪个文件被打开了”和“我们的网络调用发生了什么”之类的东西。我们可以通过使用<code class="fe mz na nb nc b">-e</code>参数只查看特定的系统调用来轻松实现这一点。</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="dcd0" class="nh md iq nc b gy ni nj l nk nl">strace -e open java -classpath . PrimeMain</span></pre><p id="0e8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将只显示开放系统调用:</p><pre class="kg kh ki kj gt nd nc ne nf aw ng bi"><span id="1eb7" class="nh md iq nc b gy ni nj l nk nl">open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/tls/x86_64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/tls/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/x86_64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/tls/x86_64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/tls/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/x86_64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)<br/>open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3<br/>open("/lib64/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 3<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/libjli.so", O_RDONLY|O_CLOEXEC) = 3<br/>open("/home/ec2-user/jdk1.8.0_45/bin/../lib/amd64/jli/libdl.so.2", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)</span></pre><p id="fde8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以学习许多系统调用，并使用它们来跟踪许多行为，如连接、写入等。这只是使用strace可以做的事情的冰山一角。Julia Evans在strace 上写了一些最详尽和有趣的帖子。如果你想了解更多，可能没有更好的地方了(也可以看看她的其他东西。惊人的资源！).</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/ea728e6694e653b68874b4498dae78b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*auSX_mTP4Z6j9BSV"/></div></div></figure><h1 id="85da" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">Strace和Java</h1><p id="ddfd" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">正如您之前看到的，strace与JVM配合得很好。因为strace先于Java，并且是一个非常低级的工具，所以它不知道JVM。JVM像大多数其他平台一样工作，并调用系统调用来调试它的行为。然而，由于它对某些问题的独特处理方式，有些方面可能无法用strace来体现。</p><p id="7cbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">分配就是一个很好的例子。系统工具使用malloc，它映射到内核分配逻辑，但是Java走的是不同的路线。它管理自己的内存以提高效率并简化垃圾收集逻辑。因此，内存分配的某些方面将从strace输出中隐藏。这可能是塞翁失马焉知非福，因为输出有时会令人难以承受。</p><p id="ba59" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在撰写本文时，线程技术在strace上运行良好。但是随着<a class="ae ln" href="https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html" rel="noopener ugc nofollow" target="_blank">项目的出现</a>可能会改变Java线程和系统线程之间的一对一映射，情况可能会有所不同。这可能会使重线程应用程序中的strace输出更难精确定位。</p><h1 id="f12c" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">最后</h1><p id="2edc" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">有各种形式的“*trace”实用程序的字母汤，它们不断地互相借鉴。跟上所有这些噪音是一个巨大的挑战。有太多很棒的工具需要介绍，不过我想在以后的文章中讨论btrace。它非常类似于DTrace，但也非常特定于JVM，因此可能值得另发一篇文章。</p><p id="822a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我今天讨论的工具采用不同的方法来解决类似的问题:我们如何理解二进制应用程序“真正”做什么？安全研究人员和黑客使用这些工具来理解你的程序。他们不需要代码，也不需要反汇编来查看你实际在做什么。</p><p id="ac5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也可以使用这些工具来了解你的行为的影响。我们经常调用一个API，让事情就此结束。但是魔鬼在细节中，这些细节会带来沉重的代价。作为一名Java开发人员，我很少考虑信号传递、流程管理或这类低级的东西。但是我确实花时间研究这些东西，因为它们最终会影响我的应用程序的稳定性和性能。</p></div></div>    
</body>
</html>