<html>
<head>
<title>Running Redis at Scale — Redis Roadmap</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大规模运行Redis—Redis路线图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/running-redis-at-scale-redis-roadmap-607521db2a0f?source=collection_archive---------11-----------------------#2022-01-28">https://betterprogramming.pub/running-redis-at-scale-redis-roadmap-607521db2a0f?source=collection_archive---------11-----------------------#2022-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fd7a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对Redis的深入研究</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/186fbb2dd95013e6e559fb222acc968e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jKmXaS7tIcLh9DjX"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@nbischop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Niklas bishop</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2ebf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">名为<code class="fe ls lt lu lv b">redis.conf</code>的自文档化Redis配置文件作为编写良好的文档的例子被多次提及。</p><p id="0527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个文件中，您可以找到所有可能的Redis配置指令，以及它们的功能和默认值的详细描述。</p><p id="da9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在生产环境中运行Redis时，您应该始终根据您的需要调整<code class="fe ls lt lu lv b">redis.conf</code>文件，并指示Redis基于其参数运行。</p><p id="dc0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法是在启动服务器时提供文件的路径:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="90f2" class="ma mb iq lv b gy mc md l me mf">$ redis-server./path/to/redis.conf</span></pre><p id="18bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您只是为了测试而启动Redis服务器实例时，您可以直接在命令行上传递配置指令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6426" class="ma mb iq lv b gy mc md l me mf">$ redis-server --port 7000 --replicaof 127.0.0.1:6379</span></pre><p id="8120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过命令行传递的参数的格式与在<code class="fe ls lt lu lv b">redis.conf</code>文件中使用的格式完全相同，唯一不同的是关键字是前缀。</p><p id="7bb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，这在内部生成了一个内存中的临时配置文件，其中的参数被转换成<code class="fe ls lt lu lv b">redis.conf</code>的格式。</p><p id="5dad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用特殊命令<code class="fe ls lt lu lv b">CONFIG SET</code>和<code class="fe ls lt lu lv b">CONFIG GET</code>，可以在不停止或重启Redis服务器的情况下对其进行重新配置。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7058" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; CONFIG GET *</span><span id="80e7" class="ma mb iq lv b gy mg md l me mf">127.0.0.1:6379&gt; CONFIG SET something</span><span id="83d8" class="ma mb iq lv b gy mg md l me mf">127.0.0.1:6379&gt; CONFIG REWRITE</span></pre><p id="a949" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并不是所有的配置指令都支持这种方式，但是您可以首先检查命令<code class="fe ls lt lu lv b">CONFIG GET *</code>的输出，以获得所有支持的指令的列表。</p><p id="4b64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，动态修改配置对<code class="fe ls lt lu lv b">redis.conf</code>文件没有影响，所以在Redis下一次重启时，将使用旧的配置。</p><p id="c969" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想用您当前的配置设置强制更新<code class="fe ls lt lu lv b">redis.conf</code>文件，您可以运行<code class="fe ls lt lu lv b">CONFIG REWRITE</code>命令，它将自动扫描您的<code class="fe ls lt lu lv b">redis.conf</code>文件并更新与当前配置值不匹配的字段。</p><h1 id="0d58" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">客户端性能提升</strong></h1><h2 id="cf8d" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">连接管理—池化</strong></h2><p id="8513" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis客户端负责管理与Redis服务器的连接。一遍又一遍地创建和重新创建新连接会给服务器带来大量不必要的负载。一个好的客户机库会提供一些优化连接管理的方法，例如，通过建立一个连接池。</p><p id="36ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用连接池，<a class="ae kv" href="https://redis.io/topics/clients" rel="noopener ugc nofollow" target="_blank">客户端</a>库将实例化一系列到Redis服务器的(持久)连接，并保持它们打开。当应用程序需要发送请求时，当前线程将从池中获得这些连接中的一个，使用它，并在完成后返回它。</p><p id="1cc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果可能的话，总是尝试选择一个支持连接池的客户端库，因为这个决定会对系统的性能产生巨大的影响。</p><h2 id="98a8" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">流水线作业</strong></h2><p id="bad6" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">与任何客户机-服务器应用程序一样，Redis可以同时处理许多客户机。</p><p id="afa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个客户端在一个套接字上进行读取(通常是阻塞的),并等待服务器响应。服务器从套接字读取请求，解析它，处理它，并将响应写入套接字。数据包从客户端传输到服务器，然后再传输回来的时间称为网络往返时间，或RTT。</p><p id="d3d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果您需要执行50个命令，您将不得不发送请求并等待响应50次，每次都要支付RTT成本。为了解决这个问题，Redis可以处理新的请求，即使客户端还没有读取旧的响应。这样，您可以向服务器发送多个命令，而根本不需要等待回复；最后，只需一步就可以阅读回复。</p><p id="fb64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种技术叫做<a class="ae kv" href="https://redis.io/topics/pipelining" rel="noopener ugc nofollow" target="_blank">流水线</a>，是另一种提高系统性能的好方法。大多数Redis库都支持这种现成的技术。</p><h2 id="bdbb" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">初始调谐</strong></h2><p id="9269" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们喜欢Redis，因为它很快(而且有趣！)，所以当我们开始考虑扩展Redis时，我们首先要确保我们已经尽了一切努力来最大化它的性能。</p><p id="ca71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从一些重要的调优参数开始。</p><h2 id="d07d" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">最大客户端数</strong></h2><p id="969a" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis的默认最大客户端数为10，000；达到最大值后，Redis将对所有新连接做出错误响应。如果您有许多连接(或许多应用程序实例)，那么您可能需要更高。您可以在Redis配置文件中设置并发客户端的最大数量:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6cc1" class="ma mb iq lv b gy mc md l me mf">maxclients 20000</span></pre><h2 id="6d65" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">最大内存</strong></h2><p id="7c7f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">默认情况下，Redis没有最大内存限制，因此它将使用所有可用的系统内存。如果您正在使用复制，您将希望限制内存使用，以减少副本输出缓冲区的开销。给系统留个记忆也是个好主意。大约25%的开销。您可以在Redis配置文件中更新此设置:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8039" class="ma mb iq lv b gy mc md l me mf"># memory size in bytes  <br/>maxmemory 1288490188</span></pre><h2 id="8d16" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">设置tcp-backlog </strong></h2><p id="3012" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis服务器使用<code class="fe ls lt lu lv b">tcp-backlog</code>的值来指定完整连接队列的大小。</p><p id="102c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis将这个配置作为<code class="fe ls lt lu lv b">listen(int s, int backlog)</code>调用的第二个参数传递。</p><p id="ee32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您有许多连接，您将需要设置高于默认值511。您可以在Redis配置文件中对此进行更新:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ea5b" class="ma mb iq lv b gy mc md l me mf"># TCP listen() backlog. <br/># <br/># In high requests-per-second environments you need an high backlog in order <br/># to avoid slow clients connections issues. Note that the Linux kernel <br/># will silently truncate it to the value of /proc/sys/net/core/somaxconn so <br/># make sure to raise both the value of somaxconn and tcp_max_syn_backlog <br/># in order to get the desired effect.<br/>tcp-backlog 65536</span></pre><p id="f766" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如<code class="fe ls lt lu lv b">redis.conf</code>中的注释所示，somaxconn和<code class="fe ls lt lu lv b">tcp_max_syn_backlog</code>的值可能也需要在操作系统级别增加。</p><h2 id="33b0" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">设置读取副本配置</strong></h2><p id="21d2" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">扩展Redis的一个简单方法是添加读取副本并减轻主副本的负载。当您有大量读取(相对于大量写入)工作负载时，这是最有效的。您可能希望副本可用，并且即使复制没有完成，也仍然提供陈旧数据。您可以在Redis配置中对此进行更新:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2bb1" class="ma mb iq lv b gy mc md l me mf">slave-serve-stale-data yes</span></pre><p id="c821" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还需要防止复制副本上发生任何写入。您可以在Redis配置中对此进行更新:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="dd9b" class="ma mb iq lv b gy mc md l me mf">slave-read-only yes</span></pre><h2 id="aa1c" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">内核内存</strong></h2><p id="5d52" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在高负载下，由于内存分配，偶尔会出现性能下降。这是Redis的创始人Salvatore过去在博客上写的。性能问题与透明的<code class="fe ls lt lu lv b">hugepages</code>有关，如果需要，您可以在操作系统级别禁用它。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b444" class="ma mb iq lv b gy mc md l me mf">$ echo 'never' &gt; /sys/kernel/mm/transparent_hugepage/enabled</span></pre><h2 id="4874" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">内核网络栈</strong></h2><p id="5e94" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果您计划在高性能环境中处理大量连接，我们建议调整以下内核参数:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e306" class="ma mb iq lv b gy mc md l me mf">vm.swappiness=0                       # turn off swapping<br/>net.ipv4.tcp_sack=1                   # enable selective acknowledgements<br/>net.ipv4.tcp_timestamps=1             # needed for selective acknowledgements<br/>net.ipv4.tcp_window_scaling=1         # scale the network window<br/>net.ipv4.tcp_congestion_control=cubic # better congestion algorithm<br/>net.ipv4.tcp_syncookies=1             # enable syn cookies<br/>net.ipv4.tcp_tw_recycle=1             # recycle sockets quickly<br/>net.ipv4.tcp_max_syn_backlog=NUMBER   # backlog setting<br/>net.core.somaxconn=NUMBER             # up the number of connections per port<br/>net.core.rmem_max=NUMBER              # up the receive buffer size<br/>net.core.wmem_max=NUMBER              # up the buffer size for all connections</span></pre><h2 id="3f34" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">文件描述符限制</strong></h2><p id="01e3" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果没有为Redis用户设置正确的文件描述符数量，您将会看到错误消息，指出“Redis无法设置最大打开文件数”您可以在操作系统级别增加文件描述符限制。</p><p id="c3d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个在Ubuntu上使用<code class="fe ls lt lu lv b">systemd</code>的例子:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c57f" class="ma mb iq lv b gy mc md l me mf">/etc/systemd/system/redis.service<br/>[Service] <br/>... <br/>User=redis <br/>Group=redis <br/>...<br/>LimitNOFILE=65536 <br/>...</span></pre><p id="6c1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您需要重新加载守护程序并重新启动redis服务。</p><h2 id="cd5b" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">启用RPS(接收数据包控制)和CPU首选项</strong></h2><p id="d869" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">我们可以提高性能的一个方法是防止Redis运行在与处理任何网络流量的CPU相同的CPU上。这可以通过为我们的网络接口启用RPS并为我们的Redis进程创建一些CPU关联来实现。</p><p id="2983" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子。首先，我们可以在CPU 0–1上启用RPS:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1d3c" class="ma mb iq lv b gy mc md l me mf">$ echo '3' &gt; /sys/class/net/eth1/queues/rx-0/rps_cpus</span></pre><p id="d493" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以将redis的CPU关联设置为CPU 2–8:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="93ba" class="ma mb iq lv b gy mc md l me mf"># config is set to write pid to /var/run/redis.pid<br/>$ taskset -pc 2-8 `cat /var/run/redis.pid`<br/>pid 8946's current affinity list: 0-8<br/>pid 8946's new affinity list: 2-8</span></pre><h2 id="f813" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">保存快照</strong></h2><p id="497b" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">正如我们在前一单元中了解到的，如果至少有一个键发生了变化，Redis将每小时保存一次数据库快照，如果至少有100个键发生了变化，则每5分钟保存一次，如果至少有10000个键发生了变化，则每60秒保存一次。</p><p id="a7d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将其更新为一个简化的假设场景，如果在20秒内修改了三个键，我们希望保存一个快照。</p><p id="7e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤1 —创建一个名为2.2的目录，并在其中准备一个redis.conf文件。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2072" class="ma mb iq lv b gy mc md l me mf">$ mkdir 2.2<br/>$ cd 2.2<br/>$ vim redis.conf</span></pre><p id="7dd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">redis.conf</code>文件应该指定一个将用于rdb文件的文件名和一个指令，如果20秒内修改了3个键，该指令将触发快照的创建，如上所述。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d849" class="ma mb iq lv b gy mc md l me mf">dbfilename my_backup_file.rdb<br/>save 20 3</span></pre><p id="4286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤2——在2.2目录中启动一个Redis服务器，将您刚刚创建的<code class="fe ls lt lu lv b">redis.conf </code>配置文件传递给它。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0772" class="ma mb iq lv b gy mc md l me mf">$ redis-server ./redis.conf</span></pre><p id="8d2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在单独的终端中，tab使用<code class="fe ls lt lu lv b">redis-cli</code>创建三个随机密钥，一个接一个。例如:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4b48" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; SET a 1<br/>127.0.0.1:6379&gt; SET b 2<br/>127.0.0.1:6379&gt; SET c 3</span></pre><p id="0892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在2.2目录中运行ls命令以列出其所有内容。什么变了？</p><p id="ea24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤3——现在我们准备将我们的持久性提升一个层次，并建立一个AOF文件。修改您的<code class="fe ls lt lu lv b">redis.conf</code>文件，这样服务器将记录每一个新的写命令并强制写入磁盘。</p><p id="5cfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">小心点！我们有一个正在运行的服务器，我们希望在不重新启动它的情况下应用此配置。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8674" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; CONFIG SET appendonly yes<br/>127.0.0.1:6379&gt; CONFIG SET appendfsync always</span></pre><p id="edfd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了将这些设置保存到redis.conf文件中，我们需要保存它们:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8242" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; CONFIG REWRITE</span></pre><p id="1ef4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤4 —通过redis-cli创建几个随机密钥。再次检查目录2.2的内容。什么变了？</p><p id="298e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第5步—作为最后一步，重新启动Redis服务器进程(您可以在终端中按Ctrl+C停止该进程并再次重新运行它)。如果您运行SCAN 0命令，您将看到您创建的所有密钥仍在数据库中，即使我们重新启动了该进程。</p><h2 id="d210" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">启用基本复制</strong></h2><p id="34c2" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">步骤1 —首先，让我们创建并配置主实例。我们将从它的primary.conf配置文件中的一些配置更改开始。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7a25" class="ma mb iq lv b gy mc md l me mf">$ touch primary.conf  # Create the configuration file</span></pre><p id="6d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在用你最喜欢的文本编辑器打开<code class="fe ls lt lu lv b">primary.conf</code>文件，并设置以下配置指令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5875" class="ma mb iq lv b gy mc md l me mf"># Create a strong password here<br/>requirepass a_strong_password</span><span id="5956" class="ma mb iq lv b gy mg md l me mf"># AUTH password of the primary instance in case this instance becomes a replica<br/>masterauth a_strong_password</span><span id="ceca" class="ma mb iq lv b gy mg md l me mf"># Enable AOF file persistence<br/>appendonly yes</span><span id="2fdf" class="ma mb iq lv b gy mg md l me mf"># Choose a name for the AOF file<br/>appendfilename "primary.aof"</span></pre><p id="4e17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，让我们启动主实例:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="17fa" class="ma mb iq lv b gy mc md l me mf">$ redis-server ./primary.conf</span></pre><p id="27ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤2 —接下来，让我们为复制副本准备配置文件:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="018d" class="ma mb iq lv b gy mc md l me mf">$ touch replica.conf</span></pre><p id="ab0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为刚刚创建的文件添加一些设置:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b577" class="ma mb iq lv b gy mc md l me mf"># Port on which the replica should run<br/>port 6380</span><span id="9224" class="ma mb iq lv b gy mg md l me mf"># Address of the primary instance<br/>replicaof 127.0.0.1 6379</span><span id="fce0" class="ma mb iq lv b gy mg md l me mf"># AUTH password of the primary instance<br/>masterauth a_strong_password</span><span id="c30a" class="ma mb iq lv b gy mg md l me mf"># AUTH password for the replica instance<br/>requirepass a_strong_password</span></pre><p id="a76c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们开始复制:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8477" class="ma mb iq lv b gy mc md l me mf">$ redis-server ./replica.conf</span></pre><p id="e6d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤3 —打开两个终端选项卡，并使用它们启动与主实例和复制副本实例的连接:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="13b1" class="ma mb iq lv b gy mc md l me mf"># Tab 1 (primary)<br/>$ redis-cli </span><span id="1478" class="ma mb iq lv b gy mg md l me mf"># Tab 2 (replica)<br/>$ redis-cli -p 6380</span></pre><p id="c38e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过运行命令<code class="fe ls lt lu lv b">AUTH</code>后跟您的密码，在两个选项卡上进行身份验证:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a752" class="ma mb iq lv b gy mc md l me mf">AUTH a_strong_password</span></pre><p id="0cb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个(副本)选项卡上运行<code class="fe ls lt lu lv b">MONITOR</code>命令，这将允许您查看针对该实例执行的每个命令。</p><p id="f716" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">返回第一个(主要)选项卡，执行任何写命令，例如</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7180" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; SET foo bar</span></pre><p id="3e55" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第二个选项卡中，您应该会看到命令已经发送到副本服务器:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c3e5" class="ma mb iq lv b gy mc md l me mf">1617230062.389077 [0 127.0.0.1:6379] "SELECT" "0"<br/>1617230062.389092 [0 127.0.0.1:6379] "set" "foo" "bar"</span></pre><p id="d061" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤4 —保持实例运行，或者至少保持它们的配置文件。下一次练习我们会用到它们。</p><h2 id="0996" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">了解哨兵</strong></h2><p id="1f21" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis Sentinel是一个分布式系统，由多个以Sentinel模式启动的Redis实例组成。我们称这些情况为哨兵。</p><p id="b395" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://redis.io/topics/sentinel" rel="noopener ugc nofollow" target="_blank">哨兵小组</a>监控主Redis实例及其副本。如果哨兵检测到主实例出现故障，哨兵进程将查找具有最新数据的复制副本，并将该复制副本升级为新的主实例。这样，与数据库对话的客户端将能够重新连接到新的主服务器，并继续正常运行，对用户的干扰最小。</p><h2 id="f65c" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">决定主实例停机</strong></h2><p id="a46c" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">为了让哨兵能够决定主实例已经关闭，我们需要足够多的哨兵同意，从他们的角度来看，服务器是不可访问的。</p><p id="4f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有许多哨兵成员同意他们需要采取行动，这叫做达到法定人数。如果哨兵同盟无法达到法定人数，他们就不能判定初选失败。法定人数所需的哨兵确切人数是可配置的。</p><h2 id="44d9" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">触发故障转移</strong></h2><p id="3c7d" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">一旦哨兵确定主实例停机，他们需要选举并授权一名负责故障转移的领导者(哨兵实例)。只有在哨兵同盟的大多数成员都同意的情况下，才能选出领导人。</p><p id="d843" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最后一步中，领导者将通过发送命令<code class="fe ls lt lu lv b">REPLICAOF NO ONE</code>将所选的副本重新配置为主副本，并且它将重新配置其他副本以跟随新升级的主副本。</p><h2 id="a418" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">前哨和客户端库</strong></h2><p id="24b5" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果您的系统使用Sentinel实现高可用性，那么您需要一个支持Sentinel的客户端。并不是所有的库都有这个功能，但是大多数流行的库都有，所以在选择库时要确保将其添加到需求列表中。</p><p id="73f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第1步——我们将重复使用它们来创建我们的哨兵设置。如果没有，请重新参考说明并再次阅读。</p><p id="0e3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，您将拥有一个包含一个复制副本的主Redis实例。</p><p id="2243" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第2步——要初始化Redis Sentinel，您需要提供一个配置文件，所以让我们继续创建一个:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a7f6" class="ma mb iq lv b gy mc md l me mf">$ touch sentinel1.conf</span></pre><p id="04bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开文件并在以下设置中粘贴:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7b2e" class="ma mb iq lv b gy mc md l me mf">port 5000<br/>sentinel monitor myprimary 127.0.0.1 6379 2<br/>sentinel down-after-milliseconds myprimary 5000<br/>sentinel failover-timeout myprimary 60000<br/>sentinel auth-pass myprimary a_strong_password</span></pre><h2 id="4f05" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">条款明细</strong></h2><p id="35cb" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><code class="fe ls lt lu lv b">port</code>-哨兵应运行的端口</p><p id="e07b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">sentinel monitor</code> —在特定的IP地址和端口上监视主服务器。有了主哨兵的地址，他们将能够自己发现所有的复制品。这一行的最后一个论点是法定人数需要多少哨兵。</p><p id="8396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">sentinel down-after-milliseconds</code> —一个实例不可达到被认为停机的时间需要多少毫秒</p><p id="11f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">sentinel failover-timeout</code> —如果一个Sentinel投票给另一个Sentinel进行给定主节点的故障转移，它将等待这个毫秒数，再次尝试对同一主节点进行故障转移。</p><p id="7cdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">sentinel auth-pass</code> —为了让sentinel在配置了requirepass时连接到Redis服务器实例，Sentinel配置必须包括sentinel auth-pass指令。</p><p id="6b9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤3 —制作该文件的另外两个副本— sentinel2.conf和sentinel3.conf，并编辑它们，以便端口配置分别设置为5001和5002。</p><p id="73d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤4 —让我们在三个不同的终端选项卡中初始化三个Sentinels:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="537f" class="ma mb iq lv b gy mc md l me mf"># Tab 1<br/>$ redis-server ./sentinel1.conf --sentinel</span><span id="cc71" class="ma mb iq lv b gy mg md l me mf"># Tab 2<br/>$ redis-server ./sentinel2.conf --sentinel</span><span id="1677" class="ma mb iq lv b gy mg md l me mf"># Tab3<br/>$ redis-server ./sentinel3.conf --sentinel</span></pre><p id="e0a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤5——如果您现在连接到Sentinels中的一个，您将能够运行许多新命令，如果在Redis实例上运行，这些命令将会出错。例如:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a64f" class="ma mb iq lv b gy mc md l me mf"># Provides information about the Primary<br/>SENTINEL master myprimary</span><span id="7277" class="ma mb iq lv b gy mg md l me mf"># Gives you information about the replicas connected to the Primary<br/>SENTINEL replicas myprimary</span><span id="6017" class="ma mb iq lv b gy mg md l me mf"># Provides information on the other Sentinels<br/>SENTINEL sentinels myprimary</span><span id="8edd" class="ma mb iq lv b gy mg md l me mf"># Provides the IP address of the current Primary<br/>SENTINEL get-master-addr-by-name myprimary</span></pre><p id="84b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤6 —如果我们现在通过按Ctrl+C或运行<code class="fe ls lt lu lv b">redis-cli -p 6379 DEBUG sleep 30</code>命令来终止主Redis实例，我们将能够在Sentinels的日志中观察到故障转移过程将在大约5秒钟后开始。如果您再次运行返回主服务器IP地址的命令，您将看到复制副本服务器已提升为主服务器:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6f1a" class="ma mb iq lv b gy mc md l me mf">redis&gt; SENTINEL get-master-addr-by-name myprimary<br/>1) "127.0.0.1"<br/>2) "6380"</span></pre><h2 id="d7fb" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">创建Redis集群</strong></h2><p id="0670" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">步骤1 —要创建一个集群，我们需要启动几个空的Redis实例，并将它们配置为以集群模式运行。</p><p id="6bf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是Redis集群的最小配置文件:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="fb30" class="ma mb iq lv b gy mc md l me mf"># redis.conf file<br/>port 7000<br/>cluster-enabled yes<br/>cluster-config-file nodes.conf<br/>cluster-node-timeout 5000<br/>appendonly yes</span></pre><p id="3b0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一行中，我们指定了服务器应该运行的端口，然后我们声明我们希望服务器以集群模式运行，并带有启用集群的yes指令。cluster-config-file定义存储该节点配置的文件的名称，以防服务器重新启动。最后，cluster-node-timeout是一个节点必须不可访问才能被认为处于故障状态的毫秒数。</p><p id="6120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤2 —让我们在您的本地主机上创建一个具有三个主碎片和三个副本的集群(请记住，在生产中始终使用两个副本来防止出现裂脑情况)。我们需要启动六个Redis进程，并为每个进程创建一个<code class="fe ls lt lu lv b">redis.conf</code>文件，指定它们的端口和上面的其余配置指令。</p><p id="64e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，创建六个目录:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="09f8" class="ma mb iq lv b gy mc md l me mf">mkdir 7000 7001 7002 7003 7004 7005</span></pre><p id="e839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第3步——然后在每个目录中创建最小配置<code class="fe ls lt lu lv b">redis.conf</code>文件，确保您更改了端口指令以匹配目录名。您最终应该得到以下目录结构:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2418" class="ma mb iq lv b gy mc md l me mf">- 7000<br/>  - redis.conf<br/>- 7001<br/>  - redis.conf<br/>- 7002<br/>  - redis.conf<br/>- 7003<br/>  - redis.conf<br/>- 7004<br/>  - redis.conf<br/>- 7005<br/>  - redis.conf</span></pre><p id="728b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤4 —打开六个终端选项卡，进入每个目录并启动一个Redis实例来启动服务器:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0aa5" class="ma mb iq lv b gy mc md l me mf"># Terminal tab 1<br/>cd 7000<br/>/path/to/redis-server ./redis.conf</span><span id="3f7e" class="ma mb iq lv b gy mg md l me mf"># Terminal tab 2<br/>cd 7001<br/>/path/to/redis-server ./redis.conf</span></pre><p id="4eaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">…等等。</p><p id="e067" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤5 —现在您已经有六个空的Redis服务器在运行，您可以将它们加入一个集群:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="585d" class="ma mb iq lv b gy mc md l me mf">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \<br/>127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \<br/>--cluster-replicas 1</span></pre><p id="0042" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们列出了所有六个服务器的端口和IP地址，并使用CREATE命令指示Redis将它们加入集群，为每个主服务器创建一个副本。</p><p id="e311" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis-cli将提出配置建议；键入yes接受它。集群将被配置和加入，这意味着实例将被引导以相互通信。</p><p id="be1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您应该会看到一条消息，内容如下:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d04f" class="ma mb iq lv b gy mc md l me mf">[OK] All 16384 slots covered</span></pre><p id="48ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着至少有一个主实例为16384个可用插槽中的每一个提供服务。</p><p id="2892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤6 —让我们向集群添加一个新的碎片，这是您需要扩展时可能会做的事情。</p><p id="3613" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，和以前一样，我们需要在集群模式下启动两个新的空Redis实例(主实例及其副本实例)。我们创建新的目录7006和7007，并在其中复制我们之前使用的相同的<code class="fe ls lt lu lv b">redis.conf</code>文件，确保我们将它们中的端口指令更改为适当的端口(7006和7007)。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2c24" class="ma mb iq lv b gy mc md l me mf">$ mkdir 7006 7007<br/>$ cp 7000/redis.conf 7006/redis.conf<br/>$ cp 7000/redis.conf 7007/redis.conf</span></pre><p id="5bf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将文件<code class="fe ls lt lu lv b">./7006/redis.conf</code>和<code class="fe ls lt lu lv b">./7007/redis.conf</code>中的端口号分别更新为7006和7007。</p><p id="8c5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤7 —让我们启动Redis实例:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a503" class="ma mb iq lv b gy mc md l me mf"># Terminal tab 7<br/>$ cd 7006<br/>$ redis-server ./redis.conf</span><span id="1d49" class="ma mb iq lv b gy mg md l me mf"># Terminal tab 8<br/>$ cd 7007<br/>$ redis-server ./redis.conf</span></pre><p id="88b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤8 —在下一步中，我们使用add-node命令将新的主碎片加入集群。第一个参数是新碎片的地址，第二个参数是集群中任何当前碎片的地址。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5817" class="ma mb iq lv b gy mc md l me mf">redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7000</span></pre><p id="2466" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第9步——最后，我们需要加入新的副本碎片，使用相同的add-node命令，以及一些额外的参数，表明碎片作为副本加入，什么将是它的主碎片。如果我们不指定一个主碎片，Redis会自己分配一个。</p><p id="0fe2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过在任何碎片上运行cluster nodes命令来找到我们的碎片的id:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="aae0" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -p 7000 cluster nodes<br/>46a768cfeadb9d2aee91ddd882433a1798f53271 127.0.0.1:7006@17006 master - 0 1616754504000 0 connected<br/>1f2bc068c7ccc9e408161bd51b695a9a47b890b2 127.0.0.1:7003@17003 slave a138f48fe038b93ea2e186e7a5962fb1fa6e34fa 0 1616754504551 3 connected<br/>5b4e4be56158cf6103ffa3035024a8d820337973 127.0.0.1:7001@17001 master - 0 1616754505584 2 connected 5461-10922<br/>a138f48fe038b93ea2e186e7a5962fb1fa6e34fa 127.0.0.1:7002@17002 master - 0 1616754505000 3 connected 10923-16383<br/>71e078dab649166dcbbcec51520742bc7a5c1992 127.0.0.1:7005@17005 slave 5b4e4be56158cf6103ffa3035024a8d820337973 0 1616754505584 2 connected<br/>f224ecabedf39d1fffb34fb6c1683f8252f3b7dc 127.0.0.1:7000@17000 myself,master - 0 1616754502000 1 connected 0-5460<br/>04d71d5eb200353713da475c5c4f0a4253295aa4 127.0.0.1:7004@17004 slave f224ecabedf39d1fffb34fb6c1683f8252f3b7dc 0 1616754505896 1 connected</span></pre><p id="6bb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在上一步中添加的主碎片的端口是7006，我们可以在第一行看到它。它的id是<code class="fe ls lt lu lv b">46a768cfeadb9d2aee91ddd882433a1798f53271</code>。</p><p id="338f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成的命令是:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d705" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -p 7000 --cluster add-node 127.0.0.1:7007 127.0.0.1:7000 --cluster-slave --cluster-master-id 46a768cfeadb9d2aee91ddd882433a1798f53271</span></pre><p id="dba7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">标志cluster-slave表示碎片应该作为副本加入，并且— <code class="fe ls lt lu lv b">cluster-master-id 46a768cfeadb9d2aee91ddd882433a1798f53271</code>指定它应该复制哪个主碎片。</p><p id="ed27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">步骤10 —现在我们的群集有八个碎片(四个主碎片和四个副本碎片)，但是如果我们运行cluster slots命令，我们将会看到新添加的碎片没有托管任何哈希片段，因此也没有托管数据。让我们给它们分配一些哈希槽:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="280d" class="ma mb iq lv b gy mc md l me mf">$ redis-cli  -p 7000  --cluster reshard 127.0.0.1:7000</span></pre><p id="f8d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在这里使用命令reshard和集群中任何碎片的地址作为参数。在下一步中，我们将能够选择我们要从中移动插槽的碎片。</p><p id="8838" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您将得到的第一个问题是关于您想要移动的插槽数量。如果我们总共有16384个插槽和四个主碎片，让我们得到所有碎片的四分之一，这样数据就平均分布了。16384 ÷ 4是4096，我们就用这个数吧。</p><p id="9a8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来的问题是关于接收shard id我们想要将数据移动到的主碎片的ID，我们在上一步中学习了如何使用cluster nodes命令来获取它。</p><p id="0444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们需要输入我们想要从中复制数据的碎片的id。或者，我们可以输入“all ”,碎片将从所有可用的主碎片中移走一些散列槽。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9b1b" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -p 7000 --cluster reshard 127.0.0.1:7000<br/>....<br/>....<br/>....</span><span id="dbe8" class="ma mb iq lv b gy mg md l me mf">How many slots do you want to move (from 1 to 16384)? 4096<br/>What is the receiving node ID? 46a768cfeadb9d2aee91ddd882433a1798f53271<br/>Please enter all the source node IDs.<br/>  Type 'all' to use all the nodes as source nodes for the hash slots.<br/>  Type 'done' once you entered all the source nodes IDs.<br/>Source node #1: all</span><span id="63d9" class="ma mb iq lv b gy mg md l me mf">Ready to move 4096 slots.<br/>  Source nodes:<br/>	M: f224ecabedf39d1fffb34fb6c1683f8252f3b7dc 127.0.0.1:7000<br/>   	slots:[0-5460] (5461 slots) master<br/>   	1 additional replica(s)<br/>	M: 5b4e4be56158cf6103ffa3035024a8d820337973 127.0.0.1:7001<br/>   	slots:[5461-10922] (5462 slots) master<br/>   	1 additional replica(s)<br/>	M: a138f48fe038b93ea2e186e7a5962fb1fa6e34fa 127.0.0.1:7002<br/>   	slots:[10923-16383] (5461 slots) master<br/>   	1 additional replica(s)<br/>  Destination node:<br/>	M: 46a768cfeadb9d2aee91ddd882433a1798f53271 127.0.0.1:7006<br/>   	slots: (0 slots) master<br/>   	1 additional replica(s)<br/>  Resharding plan:<br/>	Moving slot 5461 from 5b4e4be56158cf6103ffa3035024a8d820337973<br/>	Moving slot 5462 from 5b4e4be56158cf6103ffa3035024a8d820337973</span><span id="c9ef" class="ma mb iq lv b gy mg md l me mf">Do you want to proceed with the proposed reshard plan (yes/no)? <br/>Moving slot 5461 from 127.0.0.1:7001 to 127.0.0.1:7006:<br/>Moving slot 5462 from 127.0.0.1:7001 to 127.0.0.1:7006:<br/>Moving slot 5463 from 127.0.0.1:7001 to 127.0.0.1:7006:<br/>....<br/>....<br/>....</span></pre><p id="7e81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令完成后，我们可以再次运行cluster slots命令，我们将看到新的主碎片和副本碎片已被分配了一些哈希槽:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="182f" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -p 7000 cluster slots</span></pre><h2 id="4aff" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">对redis集群使用Redis-CLI</strong></h2><p id="16c0" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">当您使用<code class="fe ls lt lu lv b">redis-cli</code>连接到Redis集群的一个分片时，您只能连接到那个分片，不能访问其他分片的数据。如果您试图从错误的碎片访问密钥，您将得到一个移动错误。</p><p id="cc36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个技巧你可以用在<code class="fe ls lt lu lv b">redis-cli</code>上，这样你就不必打开所有碎片的连接，而是让它为你做连接和重新连接的工作。这是由-c开关触发的<code class="fe ls lt lu lv b">redis-cli</code>集群支持模式:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="3288" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -p 7000 -c</span></pre><p id="b5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当处于集群模式时，如果客户端从它连接的碎片获得(错误)移动15495 <code class="fe ls lt lu lv b">127.0.0.1:7002</code>错误响应，它将简单地重新连接到错误响应中返回的地址，在这种情况下是<code class="fe ls lt lu lv b">127.0.0.1:7002</code>。</p><p id="50b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在轮到你了:使用<code class="fe ls lt lu lv b">redis-cli</code>集群模式连接到你的集群，并尝试访问不同碎片中的密钥。观察响应消息。</p><p id="684d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您使用<code class="fe ls lt lu lv b">redis-cli</code>连接到Redis集群的一个分片时，您只能连接到那个分片，不能访问其他分片的数据。如果您试图从错误的碎片访问密钥，您将得到一个移动错误。</p><p id="aab6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个技巧你可以用在<code class="fe ls lt lu lv b">redis-cli</code>上，这样你就不必打开所有碎片的连接，而是让它为你做连接和重新连接的工作。这是由-c开关触发的<code class="fe ls lt lu lv b">redis-cli</code>集群支持模式:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="b482" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -p 7000 -c</span></pre><p id="710f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在集群模式下，如果客户端从它所连接的shard获得(error) MOVED 15495 127.0.0.1:7002错误响应，它将简单地重新连接到错误响应中返回的地址，在本例中为127.0.0.1:7002。</p><p id="30d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在轮到你了:使用<code class="fe ls lt lu lv b">redis-cli</code>集群模式连接到你的集群，并尝试访问不同碎片中的密钥。观察响应消息。</p><p id="1b5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您使用<code class="fe ls lt lu lv b">redis-cli</code>连接到Redis集群的一个分片时，您只能连接到那个分片，不能访问来自其他分片的数据。如果您试图从错误的碎片访问密钥，您将得到一个移动错误。</p><p id="7e6a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个技巧你可以用在<code class="fe ls lt lu lv b">redis-cli</code>上，这样你就不必打开所有碎片的连接，而是让它为你做连接和重新连接的工作。这是由-c开关触发的<code class="fe ls lt lu lv b">redis-cli</code>集群支持模式:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="d984" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -p 7000 -c</span></pre><p id="3525" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当处于集群模式时，如果客户端从它连接的碎片获得(错误)移动15495 <code class="fe ls lt lu lv b">127.0.0.1:7002</code>错误响应，它将简单地重新连接到错误响应中返回的地址，在这种情况下是<code class="fe ls lt lu lv b">127.0.0.1:7002</code>。</p><p id="7837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在轮到您了:使用redis-cli集群模式连接到您的集群，并尝试访问不同碎片中的密钥。观察响应消息。</p><h2 id="d3bb" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak"> Redis集群和客户端库</strong></h2><p id="a188" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">要将客户端库与<a class="ae kv" href="https://redis.io/topics/cluster-tutorial" rel="noopener ugc nofollow" target="_blank"> Redis集群</a>一起使用，客户端库需要支持集群。支持Redis集群的客户端通常具有一个特殊的连接模块，用于管理到集群的连接。一些较好的客户机库通常遵循这样的过程:</p><p id="92f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">客户端连接到集群中的任何碎片，并获取其余碎片的地址。客户端还获取散列槽到碎片的映射，这样它就可以知道在特定散列槽的什么地方寻找一个键。这个哈希槽映射在本地缓存。</p><div class="no np gp gr nq nr"><a href="https://redis.io/topics/cluster-tutorial" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">Redis集群教程- Redis</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">这份文件是一个温和的介绍Redis集群，这并没有使用难以理解的概念…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">redis.io</p></div></div><div class="oa l"><div class="ob l oc od oe oa of kp nr"/></div></div></a></div><p id="29e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当客户端需要读/写一个密钥时，它首先对密钥名运行哈希函数(crc16 ),然后模块除以16384，得到密钥的哈希槽号。</p><p id="f9ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的例子中，键“foo”的散列槽号是12182。然后，客户机对照散列槽映射检查散列槽号，以确定它应该连接到哪个碎片。在我们的例子中，哈希槽号12182位于碎片127.0.0.1:7002上。</p><p id="0652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，客户端连接到碎片并找到它需要使用的密钥。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/207005ec1996ad9f8160c32a37b10a30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qqBCSv9va49gffcq.png"/></div></div></figure><p id="b132" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果集群的拓扑由于某种原因发生了变化，并且密钥已经被移动，那么碎片将会响应一个(error) MOVED 15495 127.0.0.1:7006错误，返回负责那个密钥的新碎片的地址。这向客户端表明，它需要重新查询集群的拓扑结构和哈希槽分配，因此它会这样做，并为将来的查询更新其本地哈希槽映射。</p><p id="db17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">并不是每个客户机库都内置了这种额外的逻辑，所以在选择客户机库时，一定要寻找支持集群的。</p><p id="d090" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个要检查的细节是客户机是否在本地存储散列槽映射。如果没有，并且它依赖于(错误的)移动响应来获得正确碎片的地址，您可以预期会有比通常高得多的延迟，因为您的客户端可能必须发出两个网络请求，而不是一个请求。</p><p id="d7eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">支持Redis集群的<a class="ae kv" href="https://redis.io/clients" rel="noopener ugc nofollow" target="_blank">客户端</a>示例:</p><ul class=""><li id="1212" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated">爪哇:Jedis，莴苣</li><li id="b0b0" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">。NET: StackExchange。雷迪斯</li><li id="0070" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">Go: Radix，go-redis/redis</li><li id="aec3" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">Node.js: ioredis</li><li id="9802" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">Python: redis-py</li></ul><h2 id="54d1" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">Redis中的数据点</strong></h2><p id="504e" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">通过redis-cli可以查看多个Redis指标。</p><p id="7624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行INFO命令可以在单个视图中提供许多可用的指标。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e54f" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; INFO<br/># Server<br/>redis_version:6.0.1<br/>redis_git_sha1:00000000<br/>redis_git_dirty:0<br/>redis_build_id:e02d1d807e41d65<br/>redis_mode:standalone<br/>os:Linux 4.19.121-linuxkit x86_64<br/>…</span></pre><p id="2be9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几个部分可以单独拉动。例如，如果您只想获得“clients”部分，您可以将该部分作为参数传递给info命令。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e7e7" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; INFO CLIENTS<br/># Clients<br/>connected_clients:1<br/>client_recent_max_input_buffer:2<br/>client_recent_max_output_buffer:0<br/>blocked_clients:0<br/>tracking_clients:0<br/>clients_in_timeout_table:0</span></pre><p id="3b14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">服务器</strong>:当前Redis服务器信息。</p><p id="defa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="a49e" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">redis_version</code></li><li id="af3d" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">process_id</code></li><li id="d92e" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">config_file</code></li><li id="63ce" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">uptime_in_seconds</code></li><li id="3f3d" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">uptime_in_days</code></li></ul><p id="1967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">客户端</strong>:已连接或连接失败的客户端的可用数据。</p><p id="49e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="268a" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">connected_clients</code></li><li id="f8a8" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">blocked_clients</code></li></ul><p id="d6f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">内存</strong>:内存使用和统计</p><p id="f4e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="9d81" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">used_memory</code></li><li id="7982" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">mem_fragmentation_ratio</code></li></ul><p id="ec89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">持久性</strong> : RDB或AOF指标</p><p id="0534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="5299" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">rdb_last_save_time</code></li><li id="d1f2" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">rdb_changes_since_last_save</code></li><li id="5e4e" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">aof_rewrite_in_progress</code></li></ul><p id="c725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">统计数据:一些一般的统计数据</p><p id="cb7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="8b40" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">keyspace_hits</code></li><li id="d419" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">keyspace_misses</code></li><li id="1ae8" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">expired_keys</code></li><li id="cfb7" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">evicted_keys</code></li><li id="040e" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">instantaneous_ops_per_sec</code></li></ul><p id="1440" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">复制</strong>:包括主/副本标识符和偏移量的复制数据</p><p id="5470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="06de" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">master_link_down_since</code></li><li id="740a" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">connected_slaves</code></li><li id="447e" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">master_last_io_seconds_ago</code></li></ul><p id="b000" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> CPU </strong>:计算消耗统计</p><p id="2bcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="b66a" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">used_cpu_sys</code></li><li id="3dc9" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">used_cpu_user</code></li></ul><p id="b80b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">模块</strong>:来自任何加载模块的数据</p><p id="f5fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标(每个模块):</p><ul class=""><li id="330e" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated">版本</li><li id="c3b2" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">选择</li></ul><p id="3992" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">集群</strong>:集群是否启用</p><p id="f859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标:</p><ul class=""><li id="9db4" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated"><code class="fe ls lt lu lv b">cluster_enabled</code></li></ul><p id="b80c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">密钥空间</strong>:密钥和到期数据</p><p id="5e1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得注意的指标(每数据库):</p><ul class=""><li id="51b7" class="oh oi iq ky b kz la lc ld lf oj lj ok ln ol lr om on oo op bi translated">键</li><li id="7d7c" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">期满</li><li id="b969" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated"><code class="fe ls lt lu lv b">avg_ttl</code></li></ul><p id="7e9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出可以从结果中读取，也可以通过管道传输到文件中。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="18d9" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; redis-cli INFO STATS &gt; redis-info-stats</span></pre><p id="980b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这可以间隔进行，并由本地或第三方监控服务使用。</p><p id="f773" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">INFO返回的一些数据将是静态的。例如，Redis版本在更新之前不会改变。其他数据是动态的，例如<code class="fe ls lt lu lv b">keyspace_hits</code><code class="fe ls lt lu lv b">keyspace_misses</code>。后者可用于计算命中率，并作为长期指标进行观察。复制部分字段<code class="fe ls lt lu lv b">master_link_down_since</code>可以是连接警报的度量。</p><p id="27ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以为给定指标设置的一些可能的预警示例:</p><p id="8a4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">MetricExample Alertuptime_in_seconds </code> &lt; 300秒:确保服务器停留<code class="fe ls lt lu lv b">upconnected_clients</code> &lt;预期应用程序的最小数量<code class="fe ls lt lu lv b">connectionsmaster_link_down_since</code> &gt; 30秒:复制应该是<code class="fe ls lt lu lv b">operationalrdb_last_save_time</code> &gt;不拍摄快照的最大可接受间隔。</p><p id="0556" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是一个详尽的列表，只是为了让您了解如何使用<code class="fe ls lt lu lv b">INFO</code>中的指标。</p><h1 id="d103" class="mh mb iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">通过redis-cli选项获得延迟和统计数据</strong></h1><p id="f94a" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><code class="fe ls lt lu lv b">redis-cli</code>客户端有一些内置选项，允许您提取一些实时延迟和统计数据。</p><h2 id="5243" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">延迟选项</strong></h2><p id="0e68" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">连续采样延迟</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="16f1" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --latency<br/>min: 1, max: 17, avg: 4.03 (927 samples)</span></pre><p id="d1cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以添加raw或CSV输出标志</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7742" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --latency --csv<br/>1,4,1.94,78</span></pre><p id="0686" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了进行超过一秒钟的采样，可以使用latency-history，它的默认时间间隔为15秒，但可以使用-i参数指定。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="bc79" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --latency-history -i 60 <br/>min: 1, max: 30, avg: 4.84 (328 samples)</span></pre><p id="684f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也可以与CSV或raw输出格式标志结合使用。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="1a1d" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --latency-history -i 60 --csv<br/>13,13,13.00,1<br/>5,13,9.00,2<br/>3,13,7.00,3<br/>3,13,6.00,4<br/>3,13,5.60,5<br/>2,13,5.00,6<br/>2,13,5.43,7<br/>2,13,5.62,8<br/>2,13,5.22,9<br/>2,13,5.00,10<br/>1,13,4.64,11<br/>…</span></pre><p id="50b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两者都可以通过管道传输到一个文件。</p><p id="bd90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">latency-dist选项将延迟显示为一个频谱。默认间隔为一秒，但可以使用<code class="fe ls lt lu lv b">-i</code>参数进行更改。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/6604290924cc077891f26a5b7e071a70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wRhF9lTJTuoRcQjW.png"/></div></div></figure><h2 id="38dd" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">统计选项</strong></h2><p id="f3bf" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">使用stat标志从服务器获取滚动统计数据。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="439f" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --stat <br/>------- data ------ --------------------- load -------------------- - child -<br/>keys       mem      clients blocked requests            connections<br/>4          9.98M    51      0       8168035 (+0)        4132<br/>4          9.98M    51      0       8181542 (+13507)    4132<br/>4          9.98M    51      0       8196100 (+14558)    4132<br/>4          9.98M    51      0       8209794 (+13694)    4132<br/>4          9.98M    51      0       8223420 (+13626)    4132<br/>4          9.98M    51      0       8236624 (+13204)    4132<br/>4          9.98M    51      0       8251376 (+14752)    4132<br/>4          9.98M    51      0       8263417 (+12041)    4182<br/>4          9.98M    51      0       8276781 (+13364)    4182<br/>4          9.90M    51      0       8289693 (+12912)    4182</span></pre><h2 id="de4b" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">内存统计</strong></h2><p id="44ba" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis包含一个<code class="fe ls lt lu lv b">MEMORY</code>命令，该命令包含一个获取统计数据的子命令。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8782" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; memory stats<br/> 1) "peak.allocated"<br/> 2) (integer) 11912984<br/> 3) "total.allocated"<br/> 4) (integer) 8379168<br/> 5) "startup.allocated"<br/> 6) (integer) 5292168<br/> 7) "replication.backlog"<br/> 8) (integer) 0<br/> 9) "clients.slaves"<br/>10) (integer) 0<br/>11) "clients.normal"<br/>12) (integer) 16986<br/>13) "aof.buffer"<br/>14) (integer) 0</span></pre><p id="4c78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些值在<code class="fe ls lt lu lv b">INFO MEMORY</code>命令中也是可用的，但是这里它们是在一个典型的Redis RESP数组回复中返回的。</p><p id="796c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有一个<code class="fe ls lt lu lv b">LATENCY DOCTOR</code>子命令，包含当前内存指标的分析报告。</p><h2 id="0917" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">延迟监控</strong></h2><p id="b7d6" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">众所周知，Redis速度很快，因此经常被用在非常极端的场景中，在这些场景中，低延迟是必须的。Redis有一个称为延迟监控的特性，它允许您深入研究可能的延迟问题。延迟监控由以下概念性部分组成:</p><p id="b44a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">延迟挂钩对不同的延迟敏感代码路径进行采样。</p><p id="3302" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不同事件导致的潜伏期峰值的时序记录。</p><p id="4ba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从时间序列中获取原始数据的报告引擎。</p><p id="d6f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分析引擎根据测量结果提供人类可读的报告和提示。</p><p id="9e90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，此功能是禁用的，因为大多数时候不需要它。为了启用它，您可以在Redis配置中更新想要监控的阈值时间(以毫秒为单位)。</p><p id="8374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">时间超过阈值的事件将被记录为延迟峰值。如果要求识别阻塞服务器10毫秒或更长时间的所有事件，则应该相应地设置阈值配置。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="922f" class="ma mb iq lv b gy mc md l me mf">latency-monitor-threshold 10</span></pre><p id="622c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果调试会话是临时的，可以通过<code class="fe ls lt lu lv b">redis-cli</code>设置阈值。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2d57" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; CONFIG SET latency-monitor-threshold 10</span></pre><p id="77f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要禁用延迟框架，阈值应设回0。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="937b" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; CONFIG SET latency-monitor-threshold 0</span></pre><p id="52ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用<code class="fe ls lt lu lv b">LATENCY</code>命令及其子命令查看延迟数据:</p><p id="f922" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">LATENCY LATEST</code> —所有事件的最新样本</p><p id="9120" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">LATENCY HISTORY</code> —给定事件的最新时间序列</p><p id="24e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">LATENCY RESET</code> —重置时间序列数据</p><p id="66c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">LATENCY GRAPH</code> —渲染ASCII艺术图形</p><p id="3e1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">LATENCY DOCTOR</code> —分析报告</p><p id="f632" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使用这些命令，您需要熟悉<a class="ae kv" href="https://redis.io/topics/latency-monitor" rel="noopener ugc nofollow" target="_blank">延迟监控框架</a>正在跟踪的不同事件。</p><p id="3cb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您可以使用<code class="fe ls lt lu lv b">LATENCY LATEST</code>子命令，您可能会看到如下数据:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2cdd" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; latency latest<br/>1) 1) "command"<br/>   2) (integer) 1616372606<br/>   3) (integer) 600<br/>   4) (integer) 600<br/>2) 1) "fast-command"<br/>   2) (integer) 1616372434<br/>   3) (integer) 12<br/>   4) (integer) 12</span></pre><p id="2b56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令的结果提供了该事件的时间戳、延迟和最大延迟。利用上面的事件表，我可以看到常规命令的延迟峰值为600毫秒，而O(1)或O(log N)命令的延迟峰值为12毫秒。</p><p id="baae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些延迟命令需要传递特定的事件。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f653" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379&gt; latency graph command<br/>command - high 600 ms, low 100 ms (all time high 600 ms)<br/>--------------------------------------------------------------------------------<br/>    _##<br/>   o|||<br/>  o||||<br/>_#|||||</span><span id="9e7f" class="ma mb iq lv b gy mg md l me mf">3222184<br/>05308ss<br/>sssss</span></pre><p id="f70c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然启用延迟监控的成本接近于零，并且内存需求非常小，但它会提高您的基准内存使用量，因此如果您想从Redis获得所需的性能，就没有必要让它保持启用状态。</p><h2 id="4f92" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">监控工具</strong></h2><p id="2334" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">有许多开源监控工具和服务可以可视化您的Redis指标，其中一些还提供了警报功能。</p><p id="f6d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Grafana的Redis数据源就是一个例子。它是一个Grafana插件，允许用户连接到Redis数据库并构建仪表板以轻松观察Redis数据。它提供了一个现成的预定义控制面板，而且还允许您根据自己的特定需求构建定制的控制面板。</p><div class="no np gp gr nq nr"><a href="https://github.com/redislabs-training/ru301" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd ir gy z fp nw fr fs nx fu fw ip bi translated">GitHub-Redis labs-training/ru 301:ru 301的练习文件-大规模运行Redis。</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ow l oc od oe oa of kp nr"/></div></div></a></div><p id="2ae7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进入可观察性统计目录。</p><h2 id="9951" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">要求</strong></h2><ul class=""><li id="6ca4" class="oh oi iq ky b kz nj lc nk lf ox lj oy ln oz lr om on oo op bi translated">码头工人</li><li id="9faa" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">docker-撰写</li><li id="fb75" class="oh oi iq ky b kz oq lc or lf os lj ot ln ou lr om on oo op bi translated">互联网连接</li></ul><h2 id="fcd7" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">启动环境</strong></h2><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e2fb" class="ma mb iq lv b gy mc md l me mf">$ docker-compose up -d</span></pre><h2 id="4bff" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">连接到环境</strong></h2><p id="5551" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在终端中运行以下命令，在正在运行的docker容器中获得shell提示符:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="af97" class="ma mb iq lv b gy mc md l me mf">$ docker-compose exec redis_stats bash</span></pre><h2 id="e04c" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">生成负载</strong></h2><p id="28c2" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">生成一些负载的简单方法是打开另一个终端并运行:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a117" class="ma mb iq lv b gy mc md l me mf">$ docker-compose exec redis_stats redis-benchmark</span></pre><h2 id="565a" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">信息</strong></h2><p id="ef8c" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">由于大多数统计数据来自于<code class="fe ls lt lu lv b">INFO</code>命令，您应该首先运行这个命令来查看那里。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7cff" class="ma mb iq lv b gy mc md l me mf">$ redis-cli INFO</span></pre><p id="62d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尝试将此输出通过管道传输到一个文件。</p><h2 id="2a8d" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">内存使用情况</strong></h2><p id="dc79" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">因为我们通常建议设置<code class="fe ls lt lu lv b">maxmemory</code>大小，所以可以根据<code class="fe ls lt lu lv b">maxmemory</code>配置值和<code class="fe ls lt lu lv b">used_memory</code> stat的结果来计算正在使用的内存和警报的百分比。</p><p id="26e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一集<code class="fe ls lt lu lv b">maxmemory</code>。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4c15" class="ma mb iq lv b gy mc md l me mf">$ redis-cli config set maxmemory 100000</span></pre><p id="afae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您可以提取这两个数据点，看看如何使用它们来计算内存使用量。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ad6b" class="ma mb iq lv b gy mc md l me mf">$ redis-cli INFO | grep used_memory:<br/>$ redis-cli CONFIG GET maxmemory</span></pre><h2 id="c711" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">客户数据</strong></h2><p id="20b8" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">您可以拉动<code class="fe ls lt lu lv b">INFO</code>命令的客户端部分:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6fe4" class="ma mb iq lv b gy mc md l me mf">$ redis-cli info clients</span></pre><p id="f70d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者是您想要跟踪的特定指标:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8613" class="ma mb iq lv b gy mc md l me mf">$ redis-cli info clients | grep connected_clients</span></pre><h2 id="eb84" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">统计部分</strong></h2><p id="bb7f" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">使用<code class="fe ls lt lu lv b">redis-cli</code>列出完整的“统计”部分。</p><h2 id="a7fd" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">命中率</strong></h2><p id="a5a3" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">可以使用stats部分中的两个数据点来生成缓存命中/未命中比率。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7b62" class="ma mb iq lv b gy mc md l me mf">$ redis-cli INFO stats | grep keyspace</span></pre><h2 id="96c0" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">被驱逐的钥匙</strong></h2><p id="8819" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">当Redis达到其最大内存并且<code class="fe ls lt lu lv b">redis.conf</code>中的<code class="fe ls lt lu lv b">maxmemory-policy</code>被设置为除<code class="fe ls lt lu lv b">volatile-lru</code>之外的值时，就会发生驱逐。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e496" class="ma mb iq lv b gy mc md l me mf">$ redis-cli INFO stats | grep evicted_keys</span></pre><h2 id="a629" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">过期密钥</strong></h2><p id="70ee" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">关注到期时间是一个好主意，以确保redis按预期运行。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="7721" class="ma mb iq lv b gy mc md l me mf">$ redis-cli INFO stats | grep expired_keys</span></pre><h2 id="ed91" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">键槽</strong></h2><p id="7da5" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">以下数据可用于绘制键空间的大小，因为键数量的快速下降或上升是问题的良好指示器。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e0ec" class="ma mb iq lv b gy mc md l me mf">$ redis-cli INFO keyspace</span></pre><h2 id="9453" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">工作量(接收的连接，处理的命令)</strong></h2><p id="58b3" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">以下统计数据是Redis服务器上工作负载的良好指标。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="a1d3" class="ma mb iq lv b gy mc md l me mf">$ redis-cli INFO stats | egrep "^total_"</span></pre><h2 id="5a6a" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">识别问题</strong></h2><p id="04bc" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">除了上述信息、内存和延迟框架中数据点的指标之外，在进行故障诊断时，您可能需要从其他来源获取数据。</p><h2 id="b3c0" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">可用性</strong></h2><p id="d0cc" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis服务器在正常运行时会响应<code class="fe ls lt lu lv b">PING</code>命令:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9546" class="ma mb iq lv b gy mc md l me mf">$ redis-cli -h redis.example.com -p 6379 PING<br/>PONG</span></pre><h2 id="075a" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">慢速日志</strong></h2><p id="d0d5" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis Slowlog是一个记录超过特定执行时间的查询的系统，其中不包括I/O操作，如客户端通信。默认情况下，它通过两个配置参数启用。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="96ab" class="ma mb iq lv b gy mc md l me mf">slowlog-log-slower-than 1000000</span></pre><p id="8178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这表明如果有一个执行时间长于微秒，在本例中是一秒，它将被记录。可以使用值-1禁用慢速日志。它还可以设置为记录每个值为0的命令。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4b0c" class="ma mb iq lv b gy mc md l me mf">slowlog-max-len 128</span></pre><p id="d860" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将设置慢速日志的长度。当新命令被记录时，最旧的命令被从队列中删除。</p><p id="a4b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些值也可以在运行时使用<code class="fe ls lt lu lv b">CONFIG SET</code>命令进行更改。</p><p id="bda3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe ls lt lu lv b">LEN</code>子命令查看慢速日志的当前长度:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="3f79" class="ma mb iq lv b gy mc md l me mf">redis.cloud:6379&gt; slowlog len<br/>(integer) 11</span></pre><p id="fdff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用GET子命令从慢速日志中提取条目。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4ed7" class="ma mb iq lv b gy mc md l me mf">redis.cloud:6379&gt; slowlog get 2<br/>1) 1) (integer) 10<br/>   2) (integer) 1616372606<br/>   3) (integer) 600406<br/>   4) 1) "debug"<br/>      2) "sleep"<br/>      3) ".6"<br/>   5) "172.17.0.1:60546"<br/>   6) ""<br/>2) 1) (integer) 9<br/>   2) (integer) 1616372602<br/>   3) (integer) 600565<br/>   4) 1) "debug"<br/>      2) "sleep"<br/>      3) ".6"<br/>   5) "172.17.0.1:60546"<br/>   6) ""</span></pre><p id="0eaa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用reset子命令重置慢速日志。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="0fa6" class="ma mb iq lv b gy mc md l me mf">redis.cloud:6379&gt; slowlog reset<br/>OK<br/>redis.cloud:6379&gt; slowlog len<br/>(integer) 0</span></pre><h2 id="992c" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">扫描键</strong></h2><p id="9c63" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">有几个选项可以传递给redis-cli，这将触发密钥空间分析。它们使用SCAN命令，因此应该可以安全运行，不会影响操作。您可以在它们的输出中看到，如果需要，有一个节流选项。</p><p id="465c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">大关键字:</strong>该选项将扫描数据集寻找大关键字，并提供关于它们的信息。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="2c4d" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --bigkeys </span><span id="ed38" class="ma mb iq lv b gy mg md l me mf"># Scanning the entire keyspace to find biggest keys as well as<br/># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec<br/># per 100 SCAN commands (not usually needed).</span><span id="ca33" class="ma mb iq lv b gy mg md l me mf">[00.00%] Biggest string found so far '"counter:__rand_int__"' with 6 bytes<br/>[00.00%] Biggest hash   found so far '"myhash"' with 1 fields<br/>[00.00%] Biggest list   found so far '"mylist"' with 200000 items</span><span id="ba31" class="ma mb iq lv b gy mg md l me mf">-------- summary -------</span><span id="d970" class="ma mb iq lv b gy mg md l me mf">Sampled 4 keys in the keyspace!<br/>Total key length in bytes is 48 (avg len 12.00)</span><span id="b098" class="ma mb iq lv b gy mg md l me mf">Biggest   list found '"mylist"' has 200000 items<br/>Biggest   hash found '"myhash"' has 1 fields<br/>Biggest string found '"counter:__rand_int__"' has 6 bytes</span><span id="5908" class="ma mb iq lv b gy mg md l me mf">1 lists with 200000 items (25.00% of keys, avg size 200000.00)<br/>1 hashs with 1 fields (25.00% of keys, avg size 1.00)<br/>2 strings with 9 bytes (50.00% of keys, avg size 4.50)<br/>0 streams with 0 entries (00.00% of keys, avg size 0.00)<br/>0 sets with 0 members (00.00% of keys, avg size 0.00)<br/>0 zsets with 0 members (00.00% of keys, avg size 0.00)</span></pre><p id="9fa5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">记忆键:</strong>与大键类似，记忆键会寻找最大的键，但也会报告平均大小。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6d17" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --memkeys</span><span id="cfd5" class="ma mb iq lv b gy mg md l me mf"># Scanning the entire keyspace to find biggest keys as well as<br/># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec<br/># per 100 SCAN commands (not usually needed).</span><span id="39e3" class="ma mb iq lv b gy mg md l me mf">[00.00%] Biggest string found so far '"counter:__rand_int__"' with 62 bytes<br/>[00.00%] Biggest string found so far '"key:__rand_int__"' with 63 bytes<br/>[00.00%] Biggest hash   found so far '"myhash"' with 86 bytes<br/>[00.00%] Biggest list   found so far '"mylist"' with 860473 bytes</span><span id="73c1" class="ma mb iq lv b gy mg md l me mf">-------- summary -------</span><span id="50bd" class="ma mb iq lv b gy mg md l me mf">Sampled 4 keys in the keyspace!<br/>Total key length in bytes is 48 (avg len 12.00)</span><span id="db7c" class="ma mb iq lv b gy mg md l me mf">Biggest   list found '"mylist"' has 860473 bytes<br/>Biggest   hash found '"myhash"' has 86 bytes<br/>Biggest string found '"key:__rand_int__"' has 63 bytes</span><span id="62cb" class="ma mb iq lv b gy mg md l me mf">1 lists with 860473 bytes (25.00% of keys, avg size 860473.00)<br/>1 hashs with 86 bytes (25.00% of keys, avg size 86.00)<br/>2 strings with 125 bytes (50.00% of keys, avg size 62.50)<br/>0 streams with 0 bytes (00.00% of keys, avg size 0.00)<br/>0 sets with 0 bytes (00.00% of keys, avg size 0.00)<br/>0 zsets with 0 bytes (00.00% of keys, avg size 0.00)</span></pre><p id="130d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">热键:</strong>热键扫描仅在<code class="fe ls lt lu lv b">maxmemory-policy</code>设置为<code class="fe ls lt lu lv b">volatile-lfu</code>或<code class="fe ls lt lu lv b">allkeys-lfu</code>时可用。如果您需要识别热键，您可以将此参数添加到<code class="fe ls lt lu lv b">redis-cli</code>。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f195" class="ma mb iq lv b gy mc md l me mf">$ redis-cli --hotkeys</span><span id="dd72" class="ma mb iq lv b gy mg md l me mf"># Scanning the entire keyspace to find hot keys as well as<br/># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec<br/># per 100 SCAN commands (not usually needed).</span><span id="8b3d" class="ma mb iq lv b gy mg md l me mf">[00.00%] Hot key '"key:__rand_int__"' found so far with counter 37</span><span id="6360" class="ma mb iq lv b gy mg md l me mf">-------- summary -------</span><span id="7813" class="ma mb iq lv b gy mg md l me mf">Sampled 5 keys in the keyspace!<br/>hot key found with counter: 37  keyname: "key:__rand_int__"</span></pre><p id="e86d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">Monitor:</strong><code class="fe ls lt lu lv b">MONITOR</code>命令允许您查看针对Redis实例运行的每个命令的流。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="f71a" class="ma mb iq lv b gy mc md l me mf">127.0.0.1:6379 &gt; monitor<br/>OK<br/>1616541192.039933 [0 127.0.0.1:57070] "PING"<br/>1616541276.052331 [0 127.0.0.1:57098] "set" "user:2398423hu" "KutMo"</span></pre><h2 id="e8f9" class="ma mb iq bd mi my mz dn mm na nb dp mq lf nc nd ms lj ne nf mu ln ng nh mw ni bi translated"><strong class="ak">设置和使用Redis日志文件</strong></h2><p id="5002" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">Redis日志文件是您需要了解的另一个重要日志。它包含对配置和部署错误进行故障排除的有用信息。如果不配置Redis日志记录，故障排除将会非常困难。</p><p id="1125" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis有四个日志级别，您可以直接在<code class="fe ls lt lu lv b">redis.conf </code>文件中配置— <code class="fe ls lt lu lv b">WARNING</code>、<code class="fe ls lt lu lv b">NOTICE</code>、<code class="fe ls lt lu lv b">VERBOSE</code>、<code class="fe ls lt lu lv b">DEBUG</code></p><p id="b275" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Redis还支持通过使用<code class="fe ls lt lu lv b">syslog</code>将日志文件发送到远程日志服务器。</p><p id="966e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">远程日志记录对于许多安全专业人员来说非常重要。这些远程日志服务器经常用于监控安全事件和管理事故。</p><p id="cc31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些集中式日志服务器执行三种常见功能:确保日志文件的完整性，确保日志保留一段特定的时间，以及将日志与其他系统日志相关联，以发现对基础结构的潜在攻击。</p><p id="de1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在Redis部署上设置日志记录。首先，我们将打开我们的<code class="fe ls lt lu lv b">redis.conf </code>文件:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e7e9" class="ma mb iq lv b gy mc md l me mf">$ sudo vi /etc/redis/redis.conf</span></pre><p id="6fa9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">redis.conf</code>文件有一整节专门用来记录日志。</p><p id="20d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，在<code class="fe ls lt lu lv b">redis.conf</code>文件中找到logfile指令。这将允许您定义日志目录。对于这个例子，让我们使用<code class="fe ls lt lu lv b">/var/log/redis/redis.log</code>。</p><p id="e034" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想使用远程日志服务器，那么您需要取消注释行<code class="fe ls lt lu lv b">syslog-enabled</code>、<code class="fe ls lt lu lv b">syslog-ident</code>和<code class="fe ls lt lu lv b">syslog-facility</code>，并确保<code class="fe ls lt lu lv b">syslog-enabled</code>设置为yes。</p><p id="5514" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将重启Redis服务器。您应该看到指示Redis正在启动的日志事件。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="ec5b" class="ma mb iq lv b gy mc md l me mf">$ sudo tail -f /var/log/redis/redis.log</span></pre><p id="c7de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，让我们检查我们是否正确地写入了<code class="fe ls lt lu lv b">syslog</code>。您应该看到这些相同的日志。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="288a" class="ma mb iq lv b gy mc md l me mf">$ less /var/log/syslog | grep redis</span></pre><p id="f06b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您需要将您的日志发送到您的远程日志服务器，以确保您的日志将备份到该服务器。为此，您还必须修改<code class="fe ls lt lu lv b">rsyslog</code>配置。此配置因远程日志服务器提供商而异。</p><p id="86d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一篇文章再见…</p></div></div>    
</body>
</html>