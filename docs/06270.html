<html>
<head>
<title>10 Pods to Use in a New iOS Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在新的iOS项目中使用10个pod</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-pods-to-use-in-a-new-ios-project-5ab7180e794a?source=collection_archive---------2-----------------------#2020-09-16">https://betterprogramming.pub/10-pods-to-use-in-a-new-ios-project-5ab7180e794a?source=collection_archive---------2-----------------------#2020-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c01b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有用的豆荚开始你的项目</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb5db7e89f7d858cbb2ffceb0d86103a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gIjLovBOuPYAItpc"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@slothxbear?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">熊燕</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4c46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你开始开发一个新的iOS应用，你可能需要使用几个外部库。即使这将是一个非常简单的任务，您也可能希望收集一些统计数据，发出请求或者显示一个负载指示器。所有这些都可以在没有外部库的情况下完成。毕竟外部库也是代码，代码可以自己写。但是，如果别人已经花了几个月或几年的时间做了一些事情，而且他们准备免费提供给你，你为什么要从头开始做呢？</p><p id="dbac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">iOS最流行的依赖管理器是<code class="fe lv lw lx ly b">Cocoapods</code>。它下载您需要的库及其依赖项。它非常容易集成，并且拥有最大的iOS库集合。事实上，<code class="fe lv lw lx ly b">Cocoapods</code>是一个标准的依赖管理器。所有流行的开源库都使用它。</p><p id="ae6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将展示当我开始几乎每一个新项目时我使用哪些库，以及为什么。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="297f" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用椰子恐龙</h1><p id="9351" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是对<code class="fe lv lw lx ly b">Cocoapods</code>系统的简要概述。如果你熟悉它，跳过这一节。</p><p id="f13c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的系统中仍然没有<code class="fe lv lw lx ly b">Cocoapods</code>，请打开终端应用程序并键入:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="23cd" class="nh mh it ly b gy ni nj l nk nl">sudo gem install cocoapods</span></pre><p id="e257" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新项目，在“终端”中打开包含项目的文件夹，然后键入:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f751" class="nh mh it ly b gy ni nj l nk nl">pod init<br/>pod install</span></pre><p id="8f1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您将获得一个工作空间文件。从这一刻起，<em class="nm"> y </em>你应该只打开工作空间，而不是一个项目，否则，Xcode不会看到你的依赖项，你会得到一个不存在的代码的引用。要添加依赖项，请使用<code class="fe lv lw lx ly b">Podfile</code>。这是一个Ruby脚本，但是你不需要知道Ruby来编辑它。有几个简单的规则。</p><p id="3d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让<code class="fe lv lw lx ly b">Cocoapods</code>了解你的目标系统。比如iOS。不要忘记指定您的最低iOS版本:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3827" class="nh mh it ly b gy ni nj l nk nl">platform :ios, '10.0'</span></pre><p id="7473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于外部库中的所有警告都与我无关，所以我通常会添加这一行:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1c6a" class="nh mh it ly b gy ni nj l nk nl">inhibit_all_warnings!</span></pre><p id="3920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将关闭外部库中的所有警告。</p><p id="3c58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你使用Swift，你可能想使用框架。一些pod需要这样:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2cf4" class="nh mh it ly b gy ni nj l nk nl">use_frameworks!</span></pre><p id="ea8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个目标可以有单独的依赖关系。例如:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b3b6" class="nh mh it ly b gy ni nj l nk nl">target 'MyApp' do<br/>  pod 'Alamofire'<br/>  pod 'Kingfisher'<br/>  # ...<br/>end</span></pre><p id="d95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，您可以使用符号<code class="fe lv lw lx ly b">#</code>添加注释。</p><p id="5a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何目标都可以有无限数量的库。有时您需要指定一个版本或版本范围。在这种情况下，库的网页会给你一些说明，但是一般的语法是这样的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a036" class="nh mh it ly b gy ni nj l nk nl">pod 'Kingfisher', '~&gt; 5.4'</span></pre><p id="213d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！让我们来看看我最常用的十个图书馆。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d8d5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">翠鸟或SDWebImage</h1><p id="f4fd" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这两个库，用于Swift的Kingfisher和用于Objective-C的SDWebImage，允许您将图像从URL直接加载到您的<code class="fe lv lw lx ly b">UIImageView</code>中。它们支持缓存、转换等等。它们在可回收列表中非常有效，比如<code class="fe lv lw lx ly b">UITableView</code>和<code class="fe lv lw lx ly b">UICollectionView</code>。换句话说，如果你想从网上下载图片，这些库中肯定有一个适合你。</p><p id="61a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将其添加到您的<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="db87" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'Kingfisher'<br/># or<br/><strong class="ly iu">pod</strong> 'SDWebImage'</span></pre><p id="11d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与UIKit一起使用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b149" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">let</strong> url = URL(string: "https://example.com/image.png")<br/>imageView.kf.setImage(with: url)</span></pre><p id="bf00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI的用法:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6292" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">import</strong> KingfisherSwiftUI<br/><br/><strong class="ly iu">var</strong> body: some View {<br/>    KFImage(URL(string: "https://example.com/image.png")!)<br/>}</span></pre><p id="b58a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带Objective-C的SDWebImage:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="43c5" class="nh mh it ly b gy ni nj l nk nl">#import &lt;SDWebImage/SDWebImage.h&gt;</span><span id="dc1e" class="nh mh it ly b gy nn nj l nk nl">// ...</span><span id="4511" class="nh mh it ly b gy nn nj l nk nl">[imageView sd_setImageWithURL:[NSURL URLWithString:@"http://www.domain.com/path/to/image.jpg"]<br/>             placeholderImage:[UIImage imageNamed:@"placeholder.png"]];</span></pre><p id="6b0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">翠鸟和SDWebImage都可以和Swift和Objective-C一起使用，但是翠鸟是用Swift写的，SDWebImage是用Objective-C写的，我更喜欢用同样的方式使用它们。</p><div class="no np gp gr nq nr"><a href="https://github.com/onevcat/Kingfisher" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">onevcat/翠鸟</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">翠鸟是一个强大的，纯粹快速的库，用于从网上下载和缓存图像。它给你提供了一个机会…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://github.com/SDWebImage/SDWebImage" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">SDWebImage/SDWebImage</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">这个库提供了一个带缓存支持的异步图像下载器。为了方便起见，我们为UI添加了类别…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="78b5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">PKHUD</h1><p id="fc2f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个图书馆是我最喜欢的图书馆之一。没有它我真的不做项目，<em class="nm"> </em>哪怕是最简单的。</p><p id="50eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何异步过程都需要视觉反馈。可以是数据加载，文件上传，在后台线程处理，没关系。你需要显示一个指示器，它会挡住屏幕，向用户显示正在发生的事情。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/38c5a19a41e51edbaa3b493bdb33eea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*_V7pWKI8mHjINHLFjWvIWw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">PKHUD进度</p></figure><p id="9c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这正是PKHUD能为你做的。但这不是这个库的唯一用途:它还可以显示一条短消息，或者指示一个过程的成功或失败。视觉上它看起来像是iOS的一部分，它有扁平的设计，圆角，小动画，就像原生的iOS元素一样。</p><p id="c1af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">把它添加到你的<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4c02" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'PKHUD'</span></pre><p id="2d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">导入它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ec69" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">import</strong> PKHUD</span></pre><p id="09be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b137" class="nh mh it ly b gy ni nj l nk nl">HUD.show(.progress)</span><span id="c6d5" class="nh mh it ly b gy nn nj l nk nl">// Some async process</span><span id="f3ff" class="nh mh it ly b gy nn nj l nk nl">if success {<br/>    HUD.flash(.success)<br/>} else {<br/>    HUD.flash(.error)<br/>}</span></pre><div class="no np gp gr nq nr"><a href="https://github.com/pkluz/PKHUD" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">pkluz/PKHUD</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">基于Swift的Apple HUD的重新实现(音量、铃声、旋转、...)适用于iOS 8及以上版本。iOS 8官方模糊…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="oi l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="87f4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">SwipeView</h1><p id="fb73" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个旧的但相当有用的UI库，修改UIScrollView以响应滑动手势和改变可见页面。在Android中，有一个类似的UI组件ViewPager。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/e8593cd825e357d1f9df95085ade00ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*bRl5sF2mfMFuL7w3NqNqYQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">SwipeView。来源:<a class="ae ky" href="https://github.com/nicklockwood/SwipeView" rel="noopener ugc nofollow" target="_blank">https://github.com/nicklockwood/SwipeView</a></p></figure><p id="6244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">库中的最后一次修改是在五年前，但它是用Objective-C编写的，所以它可以在任何现代Swift或Objective-C项目中工作。</p><p id="8703" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将它添加到您的<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ba5c" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'SwipeView'</span></pre><p id="9dd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将它添加到您的故事板或用代码创建它。你需要实现两个协议:<code class="fe lv lw lx ly b">SwipeViewDataSource</code>和<code class="fe lv lw lx ly b">SwipeViewDelegate</code>。</p><p id="5ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数返回一个元素的大小。如果你想给一个元素和屏幕一样的大小，用<code class="fe lv lw lx ly b">UIScreen.main.bounds.width</code>代替<code class="fe lv lw lx ly b">width</code>。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6318" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">func</strong> swipeViewItemSize(<strong class="ly iu">_</strong> swipeView: SwipeView!) -&gt; CGSize {<br/>    <strong class="ly iu">return</strong> CGSize(width: 250, height: 250)<br/>}</span></pre><p id="a9ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一个函数返回代表一个项目的<code class="fe lv lw lx ly b">UIView</code>。它们可以重用，为了良好的内存管理，使用旧的<code class="fe lv lw lx ly b">UIView</code>而不是创建一个新的很重要。请注意，如果这个函数被调用，并不意味着这个<code class="fe lv lw lx ly b">UIView</code>将是可见的，它创建了可见的<code class="fe lv lw lx ly b">UIView</code>的“邻居”来执行页面之间的平滑过渡。例如，如果您需要启动动画，请记住这一点。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="23d6" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">func</strong> swipeView(<strong class="ly iu">_</strong> swipeView: SwipeView!, viewForItemAt index: Int, reusing view: UIView!) -&gt; UIView! {<br/>    <strong class="ly iu">let</strong> myView = (view as? MyView) ?? MyView(frame: CGRect(x: 0, y: 0, width: 250, height: 250))<br/>    // ... Set up myView<br/>    <strong class="ly iu">return</strong> myView<br/>}</span></pre><p id="7506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当用户滑动并且当前页面改变时，调用这个函数。此外，如果您以编程方式更改页面，也会调用它。如果您有一个页面指示器，这个回调是有用的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6771" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">func</strong> swipeViewCurrentItemIndexDidChange(<strong class="ly iu">_</strong> swipeView: SwipeView!) {<br/>    <strong class="ly iu">let</strong> index = swipeView.currentItemIndex<br/>    // ...<br/>}</span></pre><p id="f3cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个更重要的函数返回总页数:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2b7c" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">func</strong> numberOfItems(in swipeView: SwipeView!) -&gt; Int {<br/>    items.count<br/>}</span></pre><div class="no np gp gr nq nr"><a href="https://github.com/nicklockwood/SwipeView" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">nicklockwood/SwipeView</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">SwipeView是一个类，旨在简化iOS上水平分页滚动视图的实现。它是基于…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ok l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6b73" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">能达到性</h1><p id="aebc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个库有两个修改，一个是针对Swift的，另一个是针对Objective-C的。它们几乎是相同的，所以我只以Swift版本为例。两个库都会报告您当前的互联网连接状态。您可以只请求一个状态，也可以使用回调来监控更改。</p><p id="83e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过先加到<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b8fc" class="nh mh it ly b gy ni nj l nk nl">pod 'ReachabilitySwift'</span></pre><p id="bac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此示例显示了如何检查用户是否连接到互联网:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="614b" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">import</strong> Reachability</span><span id="6262" class="nh mh it ly b gy nn nj l nk nl"><strong class="ly iu">lazy</strong> <strong class="ly iu">var</strong> reachability: Reachability = <strong class="ly iu">try</strong>! Reachability()</span><span id="abfd" class="nh mh it ly b gy nn nj l nk nl"><strong class="ly iu">public</strong> <strong class="ly iu">func</strong> isNetworkAvailable() -&gt; Bool {<br/>    reachability.connection != .unavailable<br/>}</span></pre><p id="95b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在他们的官方网站上，他们还提供了一个监控网络状态的例子。</p><div class="no np gp gr nq nr"><a href="https://github.com/ashleymills/Reachability.swift" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">ashleymills/Reachability.swift</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">Reachability.swift是苹果可达性示例的替代品，用闭包重新编写在swift中。这是…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="ol l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a href="https://github.com/tonymillion/Reachability" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">到百万/可达性</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">这是苹果可达性类的直接替代。它是ARC兼容的，并使用新的GCD方法…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="om l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="afbc" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">单一信号</h1><p id="46d6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果你需要向iOS、Android或web发送远程推送通知，你可能会喜欢OneSignal服务。免费帐户允许您向移动设备发送无限量的推送通知。</p><p id="6933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，<a class="ae ky" href="https://app.onesignal.com/signup" rel="noopener ugc nofollow" target="_blank">创建一个账户</a>或<a class="ae ky" href="https://app.onesignal.com/login" rel="noopener ugc nofollow" target="_blank">登录一个已有的账户</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/3c181d99f5059d1deaa91c7d62e05fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*Oa2z9H3CC6TyQu3_SBnISQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">创建OneSignal应用程序</p></figure><p id="e2b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于iOS，您需要上传来自Apple的证书。对于Android，来自Firebase的一个键。<a class="ae ky" href="https://documentation.onesignal.com/docs/generate-an-ios-push-certificate" rel="noopener ugc nofollow" target="_blank">本文档</a>描述了如何生成iOS推送证书。</p><p id="0cdc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配置过程比较长，这里就不全抄了。相反，如果需要，您可以从官方文档中阅读:</p><div class="no np gp gr nq nr"><a href="https://documentation.onesignal.com/docs/ios-sdk-setup" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">iOS SDK安装程序</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">OneSignalNotificationServiceExtension允许您的iOS应用程序接收带有图像的丰富通知…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">documentation.onesignal.com</p></div></div><div class="oa l"><div class="oo l oc od oe oa of ks nr"/></div></div></a></div><p id="54bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可能看起来很复杂，但只是第一次。当整合结束时，使用OneSignal将变得快速而简单。</p><p id="48d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以向您的iOS设备发送推送通知。别忘了模拟器不接收推送通知。此外，您需要运行应用程序并接受推送通知。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/4f94131179c0130e8306f734d0443960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvI4m9rUWGl4wVTAf2aYdQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个信号。发送通知</p></figure><p id="e78d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击“新推”，享受众多选项。您也可以使用<a class="ae ky" href="https://documentation.onesignal.com/docs/onesignal-api" rel="noopener ugc nofollow" target="_blank"> OneSignal REST API </a>发送推送通知。</p><div class="no np gp gr nq nr"><a href="https://onesignal.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">排名第一的推送服务|发送手机和网络推送通知</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">全球领先的移动推送通知、网络推送和应用内消息服务。受800，000家企业的信任，发送5…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">onesignal.com</p></div></div><div class="oa l"><div class="oq l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="25b1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">SwiftEventBus</h1><p id="4b8e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这是一个小但非常有用的库。它将消息从代码的一部分发送到另一部分。它可以在后台线程中发送命令，或者跳转到UI线程中。</p><p id="8815" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先更新你的<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2a52" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'SwiftEventBus'</span></pre><p id="d3ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它使用了发布者和订阅者的概念。您可以使用以下命令从代码的任何部分发布事件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d999" class="nh mh it ly b gy ni nj l nk nl">SwiftEventBus.post("eventName")</span></pre><p id="3a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事件名称必须是字符串，为所有事件类型创建常量以避免拼写错误是一个好习惯。您还可以传递带有参数的字典和/或指定发送者:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8fec" class="nh mh it ly b gy ni nj l nk nl">SwiftEventBus.post("eventName", sender: anyObject, userInfo: someDictionary)</span></pre><p id="5420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Sender</code>可以是任何对象，包括您自己类型的对象。<code class="fe lv lw lx ly b">UserInfo</code>是一本字典。如果您收到一个事件，您需要一个订阅者。这不是强制性的，但如果你没有它，信息就无处可去。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4b6f" class="nh mh it ly b gy ni nj l nk nl">SwiftEventBus.onMainThread(target, name: "eventName") { result in<br/>    // This code will be executed in main thread<br/>}</span></pre><p id="9942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么可能有用？假设您有一个Firebase身份验证，并且希望在每次身份验证状态改变时更新UI。</p><p id="dd49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以在AppDelegate中完成(在Firebase初始化之后):</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d927" class="nh mh it ly b gy ni nj l nk nl">Auth.auth().addStateDidChangeListener { (auth, user) in<br/>  <!-- -->SwiftEventBus.post("authenticationStatusChanged") // Make it a constant ;)<br/>}</span></pre><p id="ecee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Firebase Auth使用singleton，所以不需要传递任何参数，我们可以从<code class="fe lv lw lx ly b">Auth.auth().currentUser</code>中获取它们。</p><p id="8981" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新UI是<code class="fe lv lw lx ly b">UIViewController</code>的责任，所以你可以把订阅功能放在<code class="fe lv lw lx ly b">viewDidAppear</code>上，把取消订阅功能放在<code class="fe lv lw lx ly b">viewWillDisappear</code>上。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9c77" class="nh mh it ly b gy ni nj l nk nl">SwiftEventBus.onMainThread(self, name: "authenticationStatusChanged") { result in<br/>    // Update UI<br/>}</span><span id="cae9" class="nh mh it ly b gy nn nj l nk nl">// ...</span><span id="b8c3" class="nh mh it ly b gy nn nj l nk nl">SwiftEventBus.unregister(self)</span></pre><p id="7144" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我一直假设，能出问题就出问题，所以卸载活动前别忘了退订。要么在<code class="fe lv lw lx ly b">viewWillDisappear</code>要么在<code class="fe lv lw lx ly b">deinit</code>。</p><div class="no np gp gr nq nr"><a href="https://github.com/cesarferreira/SwiftEventBus" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">cesarferreira/SwiftEventBus</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">允许组件之间进行发布-订阅式的通信，而不需要组件明确知道…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="or l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d030" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">`网络浏览器</h1><p id="b82d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">这个库的名字很容易描述。它是一个单独的视图控制器，带有<code class="fe lv lw lx ly b">WKWebView</code>。它支持共享、JavaScript和其他特性。它既可以作为模态打开，也可以用<code class="fe lv lw lx ly b">UINavigationController</code>推动。</p><p id="5112" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将此添加到您的<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0068" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'WebBrowser'</span></pre><p id="1ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您需要打开它时，创建一个<code class="fe lv lw lx ly b">WebBrowserViewController</code>的实例并配置它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b837" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">let</strong> webVC = WebBrowserViewController()<br/>webVC.delegate = self</span><span id="c2fd" class="nh mh it ly b gy nn nj l nk nl">// ... other adjustments</span><span id="d82d" class="nh mh it ly b gy nn nj l nk nl">webVC.loadURLString("https://medium.com/")</span></pre><p id="eb50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推动它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fda6" class="nh mh it ly b gy ni nj l nk nl">navigationController?.pushViewController(webVC, animated: true)</span></pre><p id="725a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…或者用情态表达:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="50e8" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">let</strong> nav = WebBrowserViewController.rootNavigationWebBrowser(webBrowser: webVC)<br/>present(navigationWebBrowser, animated: true, completion: nil)</span></pre><p id="4fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！现在，您可以在自己的网站上显示隐私政策、说明或支持聊天，而无需制作原生版本。</p><div class="no np gp gr nq nr"><a href="https://github.com/teambition/WebBrowser" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">团队定位/网络浏览器</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">使用WebKit并用Swift为iOS应用程序编写的网络浏览器。在你的Cartfile: github中指定“WebBrowser”…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="os l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="a4c0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">SWRevealViewController</h1><p id="1276" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">另一个古老但非常有用的图书馆。iOS应用程序中的标准导航方式有:</p><ul class=""><li id="49cb" class="ot ou it lb b lc ld lf lg li ov lm ow lq ox lu oy oz pa pb bi translated">底部的标签栏最多有五个项目</li><li id="6847" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">带有操作按钮的导航栏</li></ul><p id="9578" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些动作按钮或者执行某些动作，或者打开警报、动作表或弹出菜单。</p><p id="a56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，Android应用程序经常提供边栏。它们在那里土生土长，你可以更经常地看到它们。使用用Objective-C编写的SWRevealViewController(这意味着它与所有版本的Swift兼容)，你可以毫不费力地将这样的边栏添加到你的iOS应用程序中。</p><p id="2107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来添加一个pod:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5697" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'SWRevealViewController'</span></pre><p id="1719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将展示如何使用故事板来做这件事，但是你可以用纯代码来做。这个库提供了相当好的<a class="ae ky" href="https://github.com/John-Lluch/SWRevealViewController" rel="noopener ugc nofollow" target="_blank">文档</a>和几个<a class="ae ky" href="https://github.com/John-Lluch/SWRevealViewController/tree/master/RevealControllerExample" rel="noopener ugc nofollow" target="_blank">例子</a>。</p><p id="d6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建四个<code class="fe lv lw lx ly b">UIViewController</code>(见截图):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/6101588ef17bb82a061ef5cf6cfa1641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08etS9oa78nII629gOPlUg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">屏幕布局</p></figure><ul class=""><li id="6f70" class="ot ou it lb b lc ld lf lg li ov lm ow lq ox lu oy oz pa pb bi translated">根<code class="fe lv lw lx ly b">UIViewController</code>(白色)应该是<code class="fe lv lw lx ly b">SWRevealViewController</code>的一个实例。</li><li id="6e23" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">侧边栏(红色)可以是任何一个<code class="fe lv lw lx ly b">UIViewController</code>，但是在设计它的时候你应该记住它不会完全显示。侧边栏应该用类型为<code class="fe lv lw lx ly b">SWRevealViewControllerSegueSetController</code>的segue连接到根屏幕。这个序列应该有<code class="fe lv lw lx ly b">sw_read</code>标识符。这很重要。</li><li id="b095" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">绿屏是两个前屏之一，也是默认的一个。默认屏幕应该用类型为<code class="fe lv lw lx ly b">SWRevealViewControllerSegueSetController</code>和名称为<code class="fe lv lw lx ly b">sw_front</code>的segue连接到根屏幕。由于它可以从侧边栏打开，我们还添加了一个与<code class="fe lv lw lx ly b">UIButton</code>的连接。这就好像你想在用户按下UIButton时打开屏幕，但是segue应该是<code class="fe lv lw lx ly b">SWRevealViewControllerSeguePushController</code>类型。标识符并不重要，可以为空。</li><li id="6851" class="ot ou it lb b lc pc lf pd li pe lm pf lq pg lu oy oz pa pb bi translated">蓝屏和绿屏一样，但是没有和根屏连接。出于显而易见的原因，应该只有一个默认的前端控制器。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/bf4a1a7b5bd42ef9f75b003b0a009612.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MkXkzqWStLP1WejT5IFWRw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加片段</p></figure><p id="0f1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有一个细节:我们需要添加一个打开侧边栏的方法。有两种标准方式，从左边滑动和使用按钮。将此代码添加到所有前端控制器中:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0a87" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">import</strong> SWRevealViewController</span><span id="6a91" class="nh mh it ly b gy nn nj l nk nl">//...</span><span id="1c6c" class="nh mh it ly b gy nn nj l nk nl"><strong class="ly iu">override</strong> <strong class="ly iu">func</strong> viewDidLoad() {<br/>    <strong class="ly iu">super</strong>.viewDidLoad()<br/>    <strong class="ly iu">if</strong> <strong class="ly iu">let</strong> gr = revealViewController()?.panGestureRecognizer() {<br/>        <strong class="ly iu">self</strong>.view.addGestureRecognizer(gr)<br/>    }<br/>}</span></pre><p id="89cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将激活滑动手势。如果你想添加一个按钮打开侧边栏，把这个代码添加到<code class="fe lv lw lx ly b">@IBAction</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1878" class="nh mh it ly b gy ni nj l nk nl">revealViewController()?.revealToggle(sender)</span></pre><p id="c73f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果我们得到了什么？启动应用程序后，你会看到一个绿色的屏幕。用手指(模拟器上的鼠标)从屏幕左侧拉动侧边栏，会出现一个侧边栏。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/a7b48b5e199ac28df82794b24b3ea26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3-fsGH6XnDM-DFfTuoZEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">iOS应用程序中的边栏</p></figure><p id="07ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">边栏上的两个按钮将打开一个绿色和一个蓝色的屏幕。一开始看起来可能很复杂，但是当你掌握它的时候，它不会比，例如，一个标签栏难太多。</p><p id="16d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前屏幕可以有任何类型。它们可以是简单的<code class="fe lv lw lx ly b">UIViewController</code>或更复杂的，如<code class="fe lv lw lx ly b">UINavigationController</code>或<code class="fe lv lw lx ly b">UITabBarController</code>取决于你的需要。</p><div class="no np gp gr nq nr"><a href="https://github.com/John-Lluch/SWRevealViewController" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">John-Lluch/SWRevealViewController</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">一个UIViewController子类，用于显示前控制器后面的后(左和/或右)视图控制器…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="pk l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0722" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">SwiftyGif</h1><p id="a18d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在应用程序中使用gif可能是个好主意。它们小巧高效。显示gif比显示MPEG或QuickTime视频要容易得多。库<a class="ae ky" href="https://github.com/kirualex/SwiftyGif" rel="noopener ugc nofollow" target="_blank"> SwiftyGif </a>将帮助你添加Gif支持，只需几行代码。</p><p id="d0be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将此添加到您的<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9a2a" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'SwiftyGif'</span></pre><p id="1f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftyGif直接在<code class="fe lv lw lx ly b">UIImageView</code>组件中添加Gif动画，甚至没有子类化它们。</p><p id="a8a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过编写以下代码以编程方式创建它:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="03c7" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">import</strong> SwiftyGif<br/><br/><strong class="ly iu">do</strong> {<br/>    <strong class="ly iu">let</strong> gif = <strong class="ly iu">try</strong> UIImage(gifName: "MyImage.gif")<br/>    <strong class="ly iu">let</strong> imageview = UIImageView(gifImage: gif, loopCount: 3) // Will loop 3 times<br/>    imageview.frame = view.bounds<br/>    view.addSubview(imageview)<br/>} <strong class="ly iu">catch</strong> {<br/>    <strong class="ly iu">print</strong>(error)<br/>}</span></pre><p id="3727" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将其添加到现有的<code class="fe lv lw lx ly b">UIImageView</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="ea04" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">let</strong> gif = <strong class="ly iu">try</strong> UIImage(gifName: "MyImage.gif")<br/><strong class="ly iu">self</strong>.myImageView.setGifImage(gif, loopCount: -1) // Will loop forever</span></pre><p id="ccb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以从网上下载:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9625" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">let</strong> url = URL(string: "...")<br/><strong class="ly iu">let</strong> loader = UIActivityIndicatorView(style: .white)<br/>cell.gifImageView.setGifFromURL(url, customLoader: loader)</span></pre><p id="0cd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借用<a class="ae ky" href="https://github.com/kirualex/SwiftyGif" rel="noopener ugc nofollow" target="_blank">官网</a>的例子。</p><div class="no np gp gr nq nr"><a href="https://github.com/kirualex/SwiftyGif" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">kirualex/SwiftyGif</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">高性能和易于使用的Gif引擎源代码' https://github . com/cocoa pods/specs . git ' use _ frameworks！豆荚…</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="pl l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e1aa" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">RSSelectionMenu</h1><p id="d63c" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后要说的pod是<a class="ae ky" href="https://github.com/rushisangani/RSSelectionMenu" rel="noopener ugc nofollow" target="_blank"> RSSelectionMenu </a>。当你需要给用户一个从列表中选择的方法时，这是一个很好的时间节省。非常典型的情况。你可以使用这个库，而不是用<code class="fe lv lw lx ly b">UITableView</code>(或<code class="fe lv lw lx ly b">UITableViewController</code>)创建你自己的<code class="fe lv lw lx ly b">UIViewController</code>。</p><p id="a3d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来补充一下<code class="fe lv lw lx ly b">Podfile</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e219" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">pod</strong> 'RSSelectionMenu'</span></pre><p id="86e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在源代码中，让我们定义一个选项列表:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="693d" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">let</strong> options = ["New York", "London", "Istanbul", "Moscow", "Berlin", "Paris", "Beijing", "Tokyo"]</span></pre><p id="db55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的取决于你打算如何使用它。您只能选择一个或多个选项。您可以预先选择一些选项。你可以推动它，也可以用情态表达它。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="18b1" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">let</strong> selectionMenu = RSSelectionMenu(dataSource: options) { (cell, item, indexPath) in<br/>    // ...<br/>}</span></pre><p id="48a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来推动它(我们需要有一个活跃的<code class="fe lv lw lx ly b">UINavigationController</code>):</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b314" class="nh mh it ly b gy ni nj l nk nl">selectionMenu.show(style: .push, from: <strong class="ly iu">self</strong>)</span></pre><div class="no np gp gr nq nr"><a href="https://github.com/rushisangani/RSSelectionMenu" rel="noopener  ugc nofollow" target="_blank"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">rushisangani/RSSelectionMenu</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">一个优雅的选择列表或下拉菜单，用于iOS的单项或多项选择。单项和多项选择。</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">github.com</p></div></div><div class="oa l"><div class="pm l oc od oe oa of ks nr"/></div></div></a></div></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7a38" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="23d1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">外部库非常有用。并且<code class="fe lv lw lx ly b">Cocoapods</code>让你使用它们没有任何头痛。嗯，差不多了。在使用这些框架之前，不要忘记检查您的Swift版本(如果库是用Swift、iOS目标范围和许可证编写的)。不要害怕寻找新的库。您可以在您的项目中使用数百个精彩的pod。</p><p id="f696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐，下次见！</p></div></div>    
</body>
</html>