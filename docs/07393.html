<html>
<head>
<title>An Optimization Exercise in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的优化练习</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-optimization-exercise-in-golang-43fea807441d?source=collection_archive---------7-----------------------#2021-01-11">https://betterprogramming.pub/an-optimization-exercise-in-golang-43fea807441d?source=collection_archive---------7-----------------------#2021-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22cc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这个简单的时间转换还能更快吗？提示:它快了420倍</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/20428be71738289fcf2863b51eb69ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WiMDxyQuhwyQeUUY4rmevQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@harleydavidson?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈雷戴维森</a>在<a class="ae ky" href="https://unsplash.com/s/photos/fast?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="1cf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个安静的日子里，我的一个朋友向我寻求一个想法:他说:“如果我给你一个12小时格式的一小时字符串，比如<code class="fe lv lw lx ly b">7PM</code>，你会如何得到24小时格式的整数版本，比如<code class="fe lv lw lx ly b">19</code>？”在回答了这个问题后，一些关于这个问题能有多快开始流动的想法，我决定去那个兔子洞，希望能学到一两件事。</p><p id="ce17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">剧透警告:我学到了很多东西，以及我的一些期望是多么的错误。</em></p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="e8b5" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">问题陈述</h1><p id="e76c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">问题很简单:</p><ul class=""><li id="7ba1" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">输入到函数的字符串保证有一个数字，后跟<code class="fe lv lw lx ly b">AM</code>或<code class="fe lv lw lx ly b">PM</code>。一个有效的例子是<code class="fe lv lw lx ly b">7PM</code>。</li><li id="5f77" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">代码会用Golang写。</li><li id="15e0" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">我们的目标不是编写最准确的代码或可读性最强的代码，而是尽可能快地处理给定的情况。</li><li id="f082" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">我们将明确忽略错误处理，因为我们的目标不是编写生产代码，我们是在测试单个案例的性能。</li></ul><p id="8fcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用Golang，所以我们有可用的Golang基准工具，我们将针对不同的方法运行基准测试，以查看哪种方法运行得更快。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="771e" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">1.天真的方法</h1><p id="1f99" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Golang的标准库令人惊叹，已经有相当多的函数处理日期和时间转换。这里最简单的方法是依靠标准库来解析字符串，并将结果数字转换为整数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="b5d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个版本中，我们将<code class="fe lv lw lx ly b">inputString</code>值直接传递给<code class="fe lv lw lx ly b">time.Parse</code>函数，后者返回一个<code class="fe lv lw lx ly b">time.Time</code>值。一旦我们有了值，我们就把它格式化成一个字符串。</p><p id="9642" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了衡量性能，我们将运行一个简单的基准测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="7b06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了测试，我们可以用下面的命令运行它:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="e1bc" class="ny mi it ly b gy nz oa l ob oc">go test -bench=.</span></pre><p id="bda0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="06d1" class="ny mi it ly b gy nz oa l ob oc">❯ go test -bench=.<br/>goos: darwin<br/>goarch: amd64<br/>BenchmarkParseWithDateTime-8    10220811               115 ns/op<br/>PASS</span></pre><p id="a334" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最右边的列是这里的键值。它说一次操作平均需要115ns <strong class="lb iu"> </strong>。在这一点上，对于许多用例来说，代码已经足够快了，但是为了这个原因，我们将继续下去。</p><p id="d3c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能比这更快吗？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="bf99" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">2.用ReplaceAll进行整数计算</h1><p id="6da4" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">假设我们的用例很简单，除了转换小时之外，不需要任何特殊的日期-时间操作，我相信我们可以在AM-PM时间的基础上完成简单的整数加法。</p><p id="3f91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的简单尝试是检查时间是AM还是PM，从字符串中删除AM-PM部分，并将结果转换为整数。代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="bf69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将像之前一样测试它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d1c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果很有趣:我们将速度提高了三倍(简单方法的速度为115ns/op，而新实现的速度为44.3ns/op):</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="969e" class="ny mi it ly b gy nz oa l ob oc">❯ go test -bench=.<br/>goos: darwin<br/>goarch: amd64<br/>BenchmarkParseWithDateTime-8            10030531               115 ns/op<br/>BenchmarkParseWithReplaceAll-8          25858335                44.3 ns/op<br/>PASS</span></pre><p id="c734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很酷，但问题仍然存在:我们能比这更快吗？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="cd90" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">3.使用TrimSuffix而不是ReplaceAll</h1><p id="ce16" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">前面的方法很好，但是它使用了<code class="fe lv lw lx ly b">strings.ReplaceAll</code>，这可能会慢一些，因为它需要搜索整个字符串。尽管字符串很小，但这可能会对性能产生影响。因此，我决定尝试使用<code class="fe lv lw lx ly b">strings.TrimSuffix</code>函数。</p><p id="22a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码在这里:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fc4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">测试几乎是一样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后嘭，成功了！这样，时间减少到以前的26 %: 45 ns/op比12ns/op。</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="0115" class="ny mi it ly b gy nz oa l ob oc">❯ go test -bench=.<br/>goos: darwin<br/>goarch: amd64<br/>BenchmarkParseWithDateTime-8                     9056252               122 ns/op<br/>BenchmarkParseWithReplaceAll-8                  24098204                45.2 ns/op<br/>BenchmarkParseWithReplaceAllTrimSuffix-8        96514599                12.0 ns/op<br/>PASS</span></pre><p id="eed9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们从122ns/op开始，并设法将其速度提高了10倍。在这一点上，停止担心速度可能是有意义的。对于那些想继续下去的人来说，这个问题仍然存在。</p><p id="7085" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能比这更快吗？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="2d54" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">4.摆脱TrimSuffix</h1><p id="abac" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">解决这个问题的更简单的方法可能是直接操作字符串，而不是使用<code class="fe lv lw lx ly b">strings.TrimSuffix</code>，因为我们知道最后两个字母总是会被删除。为此，我编写了以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="de2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此运行基准测试也非常简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="4866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，我们又变快了！</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="e5ab" class="ny mi it ly b gy nz oa l ob oc">❯ go test -bench=.<br/>goos: darwin<br/>goarch: amd64<br/>BenchmarkParseWithDateTime-8                     9958882               117 ns/op<br/>BenchmarkParseWithReplaceAll-8                  25727338                44.6 ns/op<br/>BenchmarkParseWithReplaceAllTrimSuffix-8        99211851                11.9 ns/op<br/>BenchmarkParseWithStringManipulation-8          152646218                7.85 ns/op<br/>PASS</span></pre><p id="0f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前的方法大约是12ns/op，而新方法让我们达到了7.85ns/op。此时，我不确定是否有更快的方法，但我想我们需要继续尝试。</p><p id="470e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能比这更快吗？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ed15" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">5.拆卸HasSuffix</h1><p id="e9df" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">因为我们知道字符串的最后两个字符总是相同的，所以用于确定给定字符串是AM还是PM的区别值将是最后一个字符之前的字符。按照这个逻辑，也许我们可以通过直接角色访问比<code class="fe lv lw lx ly b">strings.HasSuffix</code>走得更快。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="496e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的，这也奏效了:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="9139" class="ny mi it ly b gy nz oa l ob oc">goos: darwin<br/>goarch: amd64<br/>BenchmarkParseWithDateTime-8                                     9716124               115 ns/op<br/>BenchmarkParseWithReplaceAll-8                                  26728262                45.0 ns/op<br/>BenchmarkParseWithReplaceAllTrimSuffix-8                        97785483                11.7 ns/op<br/>BenchmarkParseWithStringManipulation-8                          157282510                7.23 ns/op<br/>BenchmarkParseWithStringManipulationWithoutHasSuffix-8          262210579                4.46 ns/op<br/>PASS</span></pre><p id="6b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以前的方法约为7ns/op，我们设法将其降至4.46ns/op。虽然这是显而易见的风险，但问题仍然存在:我们能比这更快吗？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="52c6" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">6.四处打听</h1><p id="bec0" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对于最后一次尝试，我不知道如何提高这个函数的性能。因此，我开始询问一些朋友和同事的想法。</p><p id="d4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一番挖掘，我的同事<a class="ae ky" href="https://www.linkedin.com/in/cfoesch/" rel="noopener ugc nofollow" target="_blank"> Cassondra Foesch </a>想出了以下的黑魔法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3669" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">她警告我，这将被认为是一种竞争伎俩，它假设输入总是有效的，这符合我们的期望和我们一开始设定的目标。现在我们需要将它与其他算法进行比较:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="07ae" class="ny mi it ly b gy nz oa l ob oc">❯ go test -bench=.<br/>goos: darwin<br/>goarch: amd64<br/>BenchmarkParseWithDateTime-8                                    10635800               113 ns/op<br/>BenchmarkParseWithReplaceAll-8                                  25383086                44.5 ns/op<br/>BenchmarkParseWithReplaceAllTrimSuffix-8                        99624820                11.7 ns/op<br/>BenchmarkParseWithStringManipulation-8                          170418279                7.02 ns/op<br/>BenchmarkParseWithStringManipulationWithoutHasSuffix-8          273248098                4.35 ns/op<br/>BenchmarkParseWithBlackMagic-8                                  1000000000               0.268 ns/op<br/>PASS</span></pre><p id="2717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哇！<strong class="lb iu"> </strong>使用这一最新功能，时间为0.268ns/op。这比以前的方法大约快16倍。在这一点上，它比我们最初的方法快了420倍。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="61de" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="d39f" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">总的来说，这是一个有趣的实验，以了解更多我们用于简单操作的日常功能的特征。如果您只执行一次这个操作，纳秒并没有多大关系，但是如果这个操作在每个操作单元中执行了数百万次，纳秒就会累积起来。一般来说，了解我们使用的工具的行为是有好处的，这样我们就可以选择最适合这项工作的工具。</p><p id="7bfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个实验中，我学到了:</p><ul class=""><li id="94f5" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">日期库做很多事情，不适合这种简单的操作，看似日期时间的事情，实际上是字符串操作的挑战。然而，日期-时间方法仍然会产生最干净的代码。</li><li id="d7ed" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">如果在字符串的开头或结尾移除，字符串函数<code class="fe lv lw lx ly b">strings.TrimPrefix</code>和<code class="fe lv lw lx ly b">strings.TrimSuffix</code>比<code class="fe lv lw lx ly b">strings.ReplaceAll</code>快。</li><li id="a84c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">直接访问字符而不是使用标准库函数来进行简单的比较要快得多。显然，这取决于用例。</li><li id="263c" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">对于最后一个算法，我尝试记忆<code class="fe lv lw lx ly b">len</code>调用，因为它们是乘法，但这没有任何影响。根据<a class="ae ky" href="https://stackoverflow.com/a/26634977" rel="noopener ugc nofollow" target="_blank">这个StackOverflow的回答</a>，那些重复的调用已经返回了缓存的结果。</li><li id="9f1e" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">通过利用简单的技术并考虑如何最好地做一件事，我们可以在不牺牲代码质量的情况下引入巨大的性能改进。如果我们在最后一个神奇的步骤之前停下来，我们将会有一个比简单方法快30倍的易读函数。</li></ul><p id="47b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，我知道这段代码不适合生产，原因有很多:</p><ul class=""><li id="8a31" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">没有错误处理。</li><li id="04de" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">没有执行任何输入验证。</li><li id="1c90" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">边缘情况还没有被正确测试，所以我不确定<code class="fe lv lw lx ly b">12AM</code>和<code class="fe lv lw lx ly b">12PM</code>是否总是被正确计算。</li></ul><p id="7cb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管如此，实现算法并直接测量结果而不是猜测在这里被证明是一个更好的决定。我设法进行了一次有趣的锻炼，学到了不少东西。</p><p id="aa88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您认为上面的代码有任何错误，请随时纠正我。此外，对于那些准备接受挑战的人来说，这个问题仍然存在:我们能比这更快吗？</p><p id="c5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读本文。如果你有进一步的建议，请在评论中告诉我！</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f762" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">资源</h1><ul class=""><li id="2346" class="ne nf it lb b lc mz lf na li od lm oe lq of lu nj nk nl nm bi translated">Golang标准库中的<code class="fe lv lw lx ly b">strings</code>模块文档，其中包含方法<code class="fe lv lw lx ly b">HasSuffix</code>、<code class="fe lv lw lx ly b">ReplaceAll</code>和<code class="fe lv lw lx ly b">TrimSuffix</code>:<a class="ae ky" href="https://golang.org/pkg/strings/" rel="noopener ugc nofollow" target="_blank">https://golang.org/pkg/strings/</a>的详细信息</li><li id="5f42" class="ne nf it lb b lc nn lf no li np lm nq lq nr lu nj nk nl nm bi translated">详细描述了<code class="fe lv lw lx ly b">len</code>行为的StackOverflow答案:<a class="ae ky" href="https://stackoverflow.com/questions/26634554/go-multiple-len-calls-vs-performance/26634977#26634977" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/26634554/go-multiple-len-calls-vs-performance/26634977 # 26634977</a></li></ul></div></div>    
</body>
</html>