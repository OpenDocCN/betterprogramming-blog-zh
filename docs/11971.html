<html>
<head>
<title>Lerna is Officially Dead. Long Live Monorepos</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">琳娜已经正式死亡。Monorepos万岁</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lerna-is-officially-dead-long-live-monorepos-9853c80a7b0e?source=collection_archive---------0-----------------------#2022-05-02">https://betterprogramming.pub/lerna-is-officially-dead-long-live-monorepos-9853c80a7b0e?source=collection_archive---------0-----------------------#2022-05-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf0b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">4个有效管理JavaScript monorepo的工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/96ed5fe76ebf7b0b89e341e8f42d7c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOIXYzC17oKEWc5p4gMIwg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者标题</p></figure><p id="d498" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">monorepo方法是管理所有依赖关系的一个好方法。几年来，这一直是一个热门话题。这是保持不同项目之间良好关系的一个好方法。一个直接的好处是，它使我们能够通过不同的项目共享像<code class="fe lu lv lw lx b">ESLint</code>、<code class="fe lu lv lw lx b">Prettier</code>、<code class="fe lu lv lw lx b">TypeScript</code>、…这样的配置，从而确保一致性。</p><p id="9945" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">像<code class="fe lu lv lw lx b">npm</code>、<code class="fe lu lv lw lx b">yarn</code>和<code class="fe lu lv lw lx b">pnpm</code>这样的工具为monorepo提供了一些本地支持。然而，它们缺少一些从未打算构建的功能。这就是<code class="fe lu lv lw lx b">Lerna</code>发挥作用的地方。它的目标是增强它并使其可伸缩，帮助构建、编排和发布您的包。</p><p id="0632" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Lerna</code>近日已正式杀青。虽然它的创造者<code class="fe lu lv lw lx b">@evocateur</code>表达了他的疲惫和放弃这个项目的意图，但直到2020年4月它才被正式宣布。</p><blockquote class="ly"><p id="da48" class="lz ma it bd mb mc md me mf mg mh lt dk translated"><strong class="ak">重要提示:</strong>本项目<a class="ae mi" href="https://github.com/lerna/lerna/issues/2703" rel="noopener ugc nofollow" target="_blank">未主动维护</a>。考虑采用替代工具集进行monorepo管理。— Lerna的Readme.md</p></blockquote><p id="820c" class="pw-post-body-paragraph ky kz it la b lb mj ju ld le mk jx lg lh ml lj lk ll mm ln lo lp mn lr ls lt im bi translated">这个项目不会被移交，尽管它的点击量持续超过每日下载量。为什么？作者会迫不及待地重写它，而不是做出补偿。它无法与最新工具的性能竞争。即使许多人仍然热爱和享受<code class="fe lu lv lw lx b">lerna</code>是时候继续前进了。</p><p id="05d6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么在构建JavaScript/TypeScript monorepo生态系统时，我们的选择是什么呢？在本文中，我们将检查最流行的工具。</p><pre class="kj kk kl km gt mo lx mp mq aw mr bi"><span id="20d8" class="ms mt it lx b gy mu mv l mw mx"><strong class="lx iu"><em class="my">Update: </em></strong><em class="my">there are has been a plot twist after this article was published. The creator of Lerna has decided to hand over the project to </em><strong class="lx iu"><em class="my">Nrwl </em></strong><em class="my">🚀🚀. Their roadmap is still to be unveiled. The inactivy of Lerna during this past year has made it lag behind.</em></span></pre></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="0d0d" class="ng mt it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">1.纱线、Npm和Pnpm</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/f958fa19ffdb9e5ba5c130c8d2be1d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgmML7r4OsnNdDikiVfiBg.png"/></div></div></figure><p id="2260" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如前所述，<code class="fe lu lv lw lx b">npm</code>、<code class="fe lu lv lw lx b">yarn</code>和<code class="fe lu lv lw lx b">pnpm</code>已经提供了本机monorepo支持。所以你需要问自己:你真的需要<code class="fe lu lv lw lx b">Lerna</code>或者其他工具吗？你的monorepo有那么复杂吗？</p><p id="e5b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">第一辆是先锋。它只是在2020年10月发布的版本7中到达npm。这三者之间有很多相似之处。</p><p id="18e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<code class="fe lu lv lw lx b">pnpm</code>中，工作空间配置位于<code class="fe lu lv lw lx b">pnpm-workspace.yaml</code>中，而在<code class="fe lu lv lw lx b">yarn</code>和<code class="fe lu lv lw lx b">npm</code>中，它位于根<code class="fe lu lv lw lx b">package.json</code>中。</p><p id="9db4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用<code class="fe lu lv lw lx b">npm</code>工作空间的例子</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="dc26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要运行像<code class="fe lu lv lw lx b">test</code>这样的命令，我们可以使用<code class="fe lu lv lw lx b">npm</code>上的<code class="fe lu lv lw lx b">--workspaces</code>和<code class="fe lu lv lw lx b">pnpm</code>上的<code class="fe lu lv lw lx b">-r</code>或<code class="fe lu lv lw lx b">recursive</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="22b7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">yarn</code>的一个特性是，它允许您通过动态替换任何<code class="fe lu lv lw lx b">workspace:</code>引用来简化依赖过程。超级方便。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="36f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那三个中哪一个最好？可能我会选择<code class="fe lu lv lw lx b">yarn</code>，因为它有更成熟的特性，尽管<code class="fe lu lv lw lx b">npm</code>正在快速追赶。<code class="fe lu lv lw lx b">pnpm</code>还有其他好处，比如磁盘使用，但这可以通过<code class="fe lu lv lw lx b">yarn berry</code>来实现。</p><p id="eec0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">什么时候使用这三个中的任何一个？只在相对较小的项目中使用，因为它缺少编排方面的功能。如果您需要复杂的依赖关系图或版本，最好选择其他工具。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="08c7" class="ng mt it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">2.Rush堆栈</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/2b576ba5e8cb7f137a5ed686a25c751f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_agf6wVxCgNv4O_Sp6MWQ.png"/></div></div></figure><p id="13ef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rush是微软开发的一个工具，旨在解决JavaScript/TypeScript项目的Monorepo管理。它作为一种内部管理工具而诞生，并不断发展。</p><p id="1f80" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它最好的特点是什么？</p><ul class=""><li id="7121" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">自动本地链接</li><li id="7c90" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">快速构建</li><li id="37a9" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">子集或增量构建</li><li id="6197" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">循环依赖</li><li id="d4db" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">批量出版</li></ul><p id="f788" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它非常容易安装和使用，以下是安装方法:</p><pre class="kj kk kl km gt mo lx mp mq aw mr bi"><span id="34b0" class="ms mt it lx b gy mu mv l mw mx">npm install -g <strong class="lx iu">@microsoft/rush</strong><strong class="lx iu"> </strong></span></pre><p id="c0cc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个工具提供了对如何最好地构建应用程序的很大程度的控制。它是非自以为是的。它是一个构建和发布协调器。它建立在三个顶级打包程序管理器之上:<code class="fe lu lv lw lx b">yarn</code>、<code class="fe lu lv lw lx b">pnpm</code>或<code class="fe lu lv lw lx b">npm</code>。这三个里面<code class="fe lu lv lw lx b">npm</code>是最兼容的一个。唯一的警告是，他们建议将它与相当旧的版本<code class="fe lu lv lw lx b">4.5.0</code>一起使用。</p><p id="6fbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它是如何工作的？都是通过<code class="fe lu lv lw lx b">rush.json</code>文件配置的。让我们看一个使用<code class="fe lu lv lw lx b">pnpm</code>工具的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d6fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看项目依赖项目是如何在该文件上配置的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2a26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它仍然与其他工具相当一致。Rush工具非常适合希望对项目依赖关系进行粒度控制的大型组织。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="61f4" class="ng mt it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">3.Turborepo</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/99111c2589b8c100247747fa5d829c68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZZWr6mmjPV7r57JzFtw_w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae mi" href="https://github.com/vercel/turborepo" rel="noopener ugc nofollow" target="_blank">https://github.com/vercel/turborepo</a></p></figure><p id="63db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Vercel最近收购了<code class="fe lu lv lw lx b">Turborepo</code>公司，控制了其智能monorepo工具。它是由<code class="fe lu lv lw lx b">Formik</code>的作者创建的，并使用<code class="fe lu lv lw lx b">go</code>语言构建。这使得它擅长并行执行。</p><p id="5cfe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它最好的特点是什么？</p><ul class=""><li id="a1b6" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">计算和远程缓存</li><li id="3042" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">并行任务执行</li><li id="548c" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">易于使用和配置</li><li id="2f1d" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">依赖性可视化</li><li id="5519" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">变化是不断整合的</li></ul><p id="fef1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">开始时，我们可以通过运行以下命令来触发终端设置向导</p><pre class="kj kk kl km gt mo lx mp mq aw mr bi"><span id="4149" class="ms mt it lx b gy mu mv l mw mx"><em class="my">// execute</em><br/><strong class="lx iu">npx create-turbo@latest my-turbo-repo</strong></span></pre><p id="4bd8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就像Rush一样，Turborepo需要选择一个包管理器。选项有:<code class="fe lu lv lw lx b">npm</code>、<code class="fe lu lv lw lx b">pnpm</code>和<code class="fe lu lv lw lx b">yarn</code>。由于它与那些工具集成得很好，如果我们已经在使用他们的本地工作区功能，我们可以很容易地过渡到这个工具。</p><p id="3ae2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意我们如何通过使用<code class="fe lu lv lw lx b">"*"</code>符号来管理包的依赖关系。这将使应用程序保持最新版本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="f152" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以通过<code class="fe lu lv lw lx b">turbo.json</code>创建构建管道。这是我们定义项目构建方式的地方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="167b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想拥有一个非unopinionated monorepo，并希望在其中深入配置您的构建过程，那么这个工具非常有用。</p><p id="c6c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然很有前途，但要赶上<code class="fe lu lv lw lx b">Nx</code>这样的成熟工装还有很长的路要走。后面有<code class="fe lu lv lw lx b">vercel</code>在，很可能会有很大的进步。这是对未来的一个肯定的赌注。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="e18f" class="ng mt it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">4.（同nonexpendable）非消耗品</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/7f11be1775904e65152dcab20ba8880b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZjdRqOwAUAQEcsNe.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae mi" href="https://github.com/nrwl/nx" rel="noopener ugc nofollow" target="_blank">https://github.com/nrwl/nx</a></p></figure><p id="0d57" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Nx</code>工具是由<code class="fe lu lv lw lx b">Nrwl</code>团队创建的。它已经问世多年，但直到最近才变得非常流行。它是使用TypeScript构建的。但是不要被这个骗了。它极具表演性。繁重的计算由内核<code class="fe lu lv lw lx b">Node.js</code>和<code class="fe lu lv lw lx b">C++</code>中编写的模块完成。</p><p id="8ea2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它的哲学是拥有一个固执己见的项目结构。他们创建了一个bit插件生态系统来保持整个结构的干燥、通用和可插拔。它是一个可扩展、快速、智能的构建系统。</p><p id="c54d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它最好的特点是什么？</p><ul class=""><li id="7451" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">智能重建。它只是重建和重新测试受我们的变化影响的东西</li><li id="6a8f" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">项目图表</li><li id="c7b4" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">分布式任务执行</li><li id="f0f2" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">计算和远程缓存</li><li id="4048" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">开发者体验</li><li id="7a6b" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">所有权管理</li><li id="5d89" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">发电机</li><li id="6e4f" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">插件生态系统</li><li id="31c6" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">CL / VSCode扩展</li></ul><p id="042c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">迁移很简单，首先，通过执行命令添加<code class="fe lu lv lw lx b">Nx</code></p><pre class="kj kk kl km gt mo lx mp mq aw mr bi"><span id="2a78" class="ms mt it lx b gy mu mv l mw mx"><em class="my">// execute</em><br/><strong class="lx iu">npx add-nx-to-monorepo</strong></span></pre><p id="c875" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是做什么的？</p><ul class=""><li id="f3ed" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">将Nx添加到您的package.json。</li><li id="4019" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">创建包含所有必要配置的<code class="fe lu lv lw lx b">nx.json</code></li><li id="cfa4" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">设置Nx云(如果您选择“是”)，这是免费的，不需要验证。</li></ul><p id="0837" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下一步是什么？</p><ul class=""><li id="27fc" class="oa ob it la b lb lc le lf lh oc ll od lp oe lt of og oh oi bi translated">使用插件</li><li id="291f" class="oa ob it la b lb oj le ok lh ol ll om lp on lt of og oh oi bi translated">删除插件利用的冗余配置</li></ul><p id="4dea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">Nx</code>工具坚固且性能良好。它比<code class="fe lu lv lw lx b">turborepo</code>和<code class="fe lu lv lw lx b">rush</code>更成熟。有更大的社区支持和更多的可用资源。它的VSCode插件使得使用CLI非常直观。选择它永远不会出错，这是一个安全的赌注。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><h1 id="1743" class="ng mt it bd nh ni nj nk nl nm nn no np jz nq ka nr kc ns kd nt kf nu kg nv nw bi translated">包裹</h1><p id="f82b" class="pw-post-body-paragraph ky kz it la b lb op ju ld le oq jx lg lh or lj lk ll os ln lo lp ot lr ls lt im bi translated">目前，<code class="fe lu lv lw lx b">Lerna</code>项目的下载量几乎与<code class="fe lu lv lw lx b">Nx</code>持平，超过了<code class="fe lu lv lw lx b">turborepo</code>和<code class="fe lu lv lw lx b">rush</code>的总和。随着越来越多的人意识到缺乏保养，这一趋势将会改变。</p><p id="81d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然还很新，但是<code class="fe lu lv lw lx b">turborepo</code>已经成为我最喜欢的一个了。它似乎检查了所有的盒子。不言而喻，你<code class="fe lu lv lw lx b">Nx</code>。它成熟、快速、可靠。</p><p id="f4d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">干杯。</p><div class="ou ov gp gr ow ox"><a rel="noopener  ugc nofollow" target="_blank" href="/is-bun-the-next-big-thing-after-webpack-d683441f77b9"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">Bun是继Webpack之后的下一个大事件吗？</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">bun vs. swc vs. esbuild</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">better编程. pub</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>