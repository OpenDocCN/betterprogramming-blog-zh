<html>
<head>
<title>Understanding WorkManager in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Android中的工作管理器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/workmanager-a-onestop-solution-for-background-tasks-e597068617b0?source=collection_archive---------0-----------------------#2021-07-25">https://betterprogramming.pub/workmanager-a-onestop-solution-for-background-tasks-e597068617b0?source=collection_archive---------0-----------------------#2021-07-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f7c5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">看看Jetpack为所有延期任务提供的一站式解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/69a0fcb7ee4754fe948f91c875afc584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ujFf97zBDRrec05i"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·托马索在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="855a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="0d96" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为应用程序开发的一部分，我们做后台任务，比如将本地数据库与服务器同步，从API预取一些数据，等等。</p><p id="3567" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">当我们说后台工作时，这意味着应用程序不是实时的，我们试图通过消耗RAM、电池、电源等系统资源来做一些事情。在棉花糖发布之前，我们习惯于使用服务或意向服务来做这些事情。在牛轧糖之后，瞌睡诞生了。</p><p id="4195" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">Doze模式基本上是一种在设备长时间处于空闲状态时，通过推迟app后台CPU和网络活动来延长电池寿命的状态。这里我们有一个维护窗口，在此期间应用程序可以完成未完成的工作。</p><p id="70ff" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">随后，在奥利奥，后台服务运行被删除。为了限制后台服务，前台服务的概念应运而生。许多应用程序都在关注它。</p><p id="32a5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">多年来，我们一直使用服务、意向服务、作业调度器等来运行我们的后台任务。所以在经历了所有的困难时期之后，Android团队想出了一个做后台工作的一站式解决方案。它只不过是工作管理器。</p><p id="0de6" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在这篇文章中，让我们看看工作管理器的基本知识，比如它是什么，我们如何使用它，它是如何工作的，我们如何跟踪我们工作的状态。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f9e0" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">什么是工作管理器？</h1><p id="d3f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">WorkManager是Android Jetpack库的一部分，是一个架构组件，主要用于执行长期运行的后台任务。主要根据执行时间，后台任务可以分为三个阶段</p><ul class=""><li id="d493" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">马上</li><li id="30aa" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">在准确的时间点</li><li id="3463" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">在未来的任何时间点(延迟任务)</li></ul><p id="cb4b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以使用前台服务或线程来执行即时请求，使用AlarmManager来执行特定的时间点任务。</p><p id="257b" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">WorkManager可以在大多数情况下使用，如即时和延迟任务，因为它可以处理任务，并确保即使应用程序突然进入后台执行操作或设备重新启动，执行也能完成。</p><blockquote class="ns nt nu"><p id="465d" class="lr ls nv lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">对于长时间运行的延迟<strong class="lt iu"> </strong>任务，WorkManger是推荐的解决方案，可以确保执行。</p></blockquote><p id="a791" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们可以将WorkManager定义为管理可推迟后台任务的库。延迟任务是指不需要用户交互就可以在未来任何时间点运行的任务。</p><p id="bb0f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在引擎盖下，它使用了我们以前可能使用过的组件，但它以一种有效的方式实现了这些组件，如电池和功耗等。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/e7e980237ef0ecf22c24377716668fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ExahNy8HYsdp1NCiXyeERQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/workmanager?gclid=Cj0KCQjw9O6HBhCrARIsADx5qCQzJRPJaYl0XzFTSrVQPGfzblD0nhvYnS2Y9qxBIfiyZ9ar68QToecaAsiSEALw_wcB&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank">安卓开发</a></p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="7fbf" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">为什么我们需要工作管理器？</h1><p id="f0f3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">WorkManager提供了处理后台任务的更好方法。</p><ul class=""><li id="641f" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated">支持API 14之前提供向后兼容性的大多数版本</li><li id="4fec" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">在有/没有Google play服务的设备上运行。</li><li id="d0dc" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">无需担心线程问题，因为WorkManager将确保在后台线程上执行。</li><li id="685c" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">容易安排，取消，重试和查询工作。它给了我们完全的控制权。</li><li id="471b" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">支持顺序和并行执行。在执行时，后面任务的输入可以是前面任务的输出。</li><li id="c26b" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated">保证任务执行。</li></ul><p id="e897" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">下面就让我们来看看其中大部分的深入分析。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="43b8" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">工作管理器基础</h1><p id="a242" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">与工作经理打交道，我们需要了解一些事情。在大多数情况下，它类似于作业调度程序。</p><h2 id="af85" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated"><strong class="ak">约束条件</strong></h2><p id="76f0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可能有一些预定义的条件，系统在开始工作之前应该满足这些条件，这些被称为约束。例如，如果与网络相关，任务可能需要网络连接，或者通过检查它是否在低电池电量的情况下运行繁重的任务，可以提高电池效率，等等。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="078e" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">基于需求，它可以是单个或多个约束。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="42e3" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated"><strong class="ak">工人</strong></h2><p id="3e37" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe oo op oq or b">Worker</code>类定义需要执行的任务或工作。这是一个抽象类，所以我们需要对它进行子类化，并覆盖方法<code class="fe oo op oq or b">doWork()</code> <strong class="lt iu"> </strong>来实现我们的实际工作。<code class="fe oo op oq or b">Worker</code>类负责在<code class="fe oo op oq or b">WorkManager</code>提供的后台线程上同步执行工作。让我们创建一个简单的工人类</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8ebb" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">来自工作线程的结果指定任务执行成功还是失败，需要重试。</p><ul class=""><li id="265f" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated"><code class="fe oo op oq or b">Result.success()</code>:返回一个Result实例，可以用来表示工作成功完成</li><li id="dfef" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><code class="fe oo op oq or b">Result.failure()</code>:返回一个Result实例，可用于指示工作已完成，但出现永久性故障</li><li id="ea64" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><code class="fe oo op oq or b">Result.retry()</code>:返回一个Result实例，该实例可用于指示工作遇到暂时失败，应该使用退避策略重试</li></ul><h2 id="8438" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated"><strong class="ak">工作请求</strong></h2><p id="2447" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">它定义了工作应该如何以及何时执行。每个工作必须有一个工作请求来安排。我们有两种请求</p><ul class=""><li id="d98e" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated"><code class="fe oo op oq or b">OneTimeWorkRequest</code> <strong class="lt iu"> : </strong>基本用于任务的一次性执行。对于非重复任务</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><ul class=""><li id="cfcd" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated"><code class="fe oo op oq or b">PeriodicWorkRequest</code> <strong class="lt iu"> : </strong>需要重复执行的任务。对于重复任务</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="2a1f" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated"><strong class="ak">工作经理</strong></h2><p id="6031" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦定义了工作请求，我们就可以使用工作管理器对其进行调度。我们调用<code class="fe oo op oq or b">enqueue()</code> <strong class="lt iu"> </strong>来调度一个请求</p><pre class="kj kk kl km gt os or ot ou aw ov bi"><span id="c3b9" class="oa la it or b gy ow ox l oy oz">WorkManager.getInstance(this).enqueue(uploadWorker)</span></pre><h2 id="8fa9" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated"><strong class="ak">工作状态</strong></h2><p id="bd1a" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一旦工作进入队列，我们唯一需要知道的就是工作的状态和输出。对于所有调度的工作请求，WorkManager维护一个LiveData，我们可以通过使用标签或request-id来获取它。标签是我们在用WorkManger将请求入队时提供的字符串</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="6c6d" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated"><strong class="ak">取消</strong></h2><p id="e813" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们想要取消任何预定的工作，WorkManger为我们提供了灵活性，可以通过使用工作请求的id或标记来实现。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="9046" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">延误的工作</h2><p id="7cdb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以使用<code class="fe oo op oq or b">setInitialDelay()</code>延迟最初的工作执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="1036" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">重试和回退策略</h2><p id="23b4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当工人返回<code class="fe oo op oq or b">Result.retry()</code>时，<code class="fe oo op oq or b">WorkManger</code>将根据补偿标准重新安排工作。退避标准由两个属性定义</p><ul class=""><li id="15ee" class="ne nf it lt b lu mn lx mo ma ng me nh mi ni mm nj nk nl nm bi translated"><code class="fe oo op oq or b">BackoffDelay</code> <strong class="lt iu"> </strong>指定重试工作前等待的最小量。默认为10秒</li><li id="1c8e" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><code class="fe oo op oq or b">BackoffPolicy</code>定义随后重试尝试的补偿延迟应如何增加。工作管理器支持两种回退策略，<code class="fe oo op oq or b"><a class="ae ky" href="https://developer.android.com/reference/androidx/work/BackoffPolicy#LINEAR" rel="noopener ugc nofollow" target="_blank">LINEAR</a></code>和<code class="fe oo op oq or b"><a class="ae ky" href="https://developer.android.com/reference/androidx/work/BackoffPolicy#EXPONENTIAL" rel="noopener ugc nofollow" target="_blank">EXPONENTIAL</a></code>。默认情况下，退避策略是指数型的，但可以设置为线性。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="ea5c" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated"><strong class="ak">链接</strong></h2><p id="9181" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以通过WorkManager轻松地链接多个请求。假设我们有三个请求要在开始时并行执行，一旦前三个请求成功完成，就应该执行下一个请求，然后我们可以使用<code class="fe oo op oq or b">begin</code>和<code class="fe oo op oq or b">then</code>如下指定它们</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><blockquote class="ns nt nu"><p id="6f81" class="lr ls nv lt b lu mn ju lw lx mo jx lz nw mp mc md nx mq mg mh ny mr mk ml mm im bi translated">注意:begin和then方法采用<code class="fe oo op oq or b">OneTimeWorkRequests</code> <strong class="lt iu"> </strong>和<strong class="lt iu"> </strong>如果链中的任何工作失败或被取消，它的所有依赖工作都会继承该状态，并且永远不会运行。</p></blockquote><p id="f5f7" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">现在让我们看看工作管理器是如何执行任务的</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="d993" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">用WorkManager怎么保证工作？</h1><p id="b9ff" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当我们用WorkManager将一个工作排队时，一个内部TaskExecutor将我们的<code class="fe oo op oq or b">WorkRequest</code>信息保存到work manager数据库中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/374c816201a29eaff74a980263d471e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*-r6dTUdIN3FG_h2RpN8YLw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.youtube.com/watch?v=83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">安卓开发峰会</a></p></figure><p id="7e8d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">保存请求后，只要满足约束，内部TaskExecutor就使用<code class="fe oo op oq or b">WorkerFactory</code>创建一个<code class="fe oo op oq or b">Worker</code>。我们可以定制工人工厂。一旦创建了工作线程，它就会在一个执行器中执行</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/4caebc19d3ef7401785803a9e6ef857b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4yL7HDWB8xQtjdrOaTPLnQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.youtube.com/watch?v=83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">安卓开发者峰会</a></p></figure><p id="fab3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我们甚至可以定制这个工作执行过程，我们将在接下来的帖子中看到。这样，我们的请求就能保证被执行。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="0409" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">一次性请求的生命周期</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/90d34be1a6053a0c3f14518d7a181ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzZ-7H_q2v8w1vI1DQJ47Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.youtube.com/watch?v=83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">安卓开发者峰会</a></p></figure><p id="4456" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">正如我们所看到的，初始状态要么被阻塞，要么大部分被排队，这取决于工作管理器的状态。一旦开始执行工作线程，它就进入运行状态。从运行状态来看，它通常要么成功，要么失败。但是在某些情况下，我们可能希望根据需求重试或取消正在进行的请求。</p><h2 id="a37b" class="oa la it bd lb ob oc dn lf od oe dp lj ma of og ll me oh oi ln mi oj ok lp ol bi translated">周期性请求的生命周期</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/09a49d4559f16fce866d4688d5b87a9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP5H7PX4q1XtKqF_4Wh09Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://www.youtube.com/watch?v=83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">安卓开发者峰会</a></p></figure><p id="8fe5" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在大多数情况下，它类似于一次性请求，但唯一的变化是，即使请求成功执行，它也会根据我们提供的间隔再次排队。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="6a1b" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">摘要</h1><p id="d751" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">由于增加了后台限制，WorkManger把我们从延迟的任务处理中解脱出来，保证了任务的执行。这可能看起来很复杂，但一旦开始，我们可以很容易地投入重复的工作。它为处理这些任务提供了一个简单的回调。</p><p id="c375" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">在接下来的文章中，我们将通过一个例子来看看WorkManger的实际应用。感谢阅读。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="8a21" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">资源</h1><ul class=""><li id="1b0f" class="ne nf it lt b lu lv lx ly ma pe me pf mi pg mm nj nk nl nm bi translated"><a class="ae ky" href="https://www.youtube.com/watch?v=83a4rYXsDs0" rel="noopener ugc nofollow" target="_blank">使用工作管理器</a></li><li id="9291" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/workmanager?gclid=Cj0KCQjw9O6HBhCrARIsADx5qCQzJRPJaYl0XzFTSrVQPGfzblD0nhvYnS2Y9qxBIfiyZ9ar68QToecaAsiSEALw_wcB&amp;gclsrc=aw.ds" rel="noopener ugc nofollow" target="_blank">使用工作管理器安排任务</a></li></ul></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="5d76" class="kz la it bd lb lc mz le lf lg na li lj jz nb ka ll kc nc kd ln kf nd kg lp lq bi translated">更多Android文章</h1><ul class=""><li id="1fec" class="ne nf it lt b lu lv lx ly ma pe me pf mi pg mm nj nk nl nm bi translated"><a class="ae ky" href="https://proandroiddev.com/the-life-cycle-of-a-view-in-android-6a2c4665b95e" rel="noopener ugc nofollow" target="_blank">Android中一个视图的生命周期</a></li><li id="c030" class="ne nf it lt b lu nn lx no ma np me nq mi nr mm nj nk nl nm bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-implement-in-app-purchases-in-your-android-app-7cc1f80148a4">如何在您的Android应用中实现应用内购买</a></li></ul></div></div>    
</body>
</html>