<html>
<head>
<title>Explaining Docker in Front-End Terms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用前端术语解释Docker</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/https-medium-com-ozantunca-explaining-docker-in-frontend-terms-9d8d2b282ed8?source=collection_archive---------7-----------------------#2019-09-08">https://betterprogramming.pub/https-medium-com-ozantunca-explaining-docker-in-frontend-terms-9d8d2b282ed8?source=collection_archive---------7-----------------------#2019-09-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7a6c975a7c98f9991e133b75daf0a081.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_HrXxNiLPIGb4hnsElbJZA.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">帕特里克·布林克斯玛在<a class="ae kf" href="https://unsplash.com/photos/PnOhIxlmdRA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="2b7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们前端开发人员已经习惯了处理流行词汇和不断增加的要学习的技术。多年来，我们已经被一个又一个库轰炸了——而且每一个库都结合了许多具有矛盾方法的框架。</p><p id="809e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你已经在这个行业呆了几年以上，很可能你的脸皮已经开始因为这个行业对我们的花言巧语而变厚了。我们听说了码头工人、库伯内特斯、集装箱化和所有其他的东西。它们听起来都是非常复杂的概念，但是不要觉得有什么特别。在这篇文章中，我将解释你听到最多的一个。</p><p id="ef15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这篇文章是写给前端开发人员的，他们想了解Docker到底是怎么回事，并想看看如何利用Docker来改进他们的日常工作。</p><p id="5002" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我并不期望你比一般的前端开发人员拥有更多的知识。请注意，本文更多的是对Docker主要特性和用例的理论解释，而不是关于如何实现它们的实践教程。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="2069" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">术语</h1><p id="355e" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在我开始详细解释之前，让我们先快速浏览一下术语。</p><ul class=""><li id="ffe2" class="mo mp it ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated"><strong class="ki iu">容器:</strong>容器是一个标准的软件单元，它封装了代码及其所有依赖关系，因此应用程序可以快速可靠地从一个计算环境运行到另一个计算环境。</li><li id="f5fb" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated"><strong class="ki iu">映像:</strong>映像是一个不可更改的静态文件，包括可执行代码及其所有依赖关系，操作系统除外。当执行一个映像时，它会创建容器，使用该映像中的文件运行该映像中的代码。</li><li id="9b5c" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated"><strong class="ki iu">容器化:</strong>将可执行代码封装在容器内，并在虚拟环境(如云)中运行这些容器的过程。</li></ul><p id="6bf1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker是一个容器化解决方案，所以我们需要从解释什么是容器以及它们如何工作开始。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="5026" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">那么容器到底是什么呢？</h1><p id="1cb8" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">你可以把容器想象成一种虚拟机或者一个<code class="fe nc nd ne nf b">iframe</code>。与<code class="fe nc nd ne nf b">iframe</code>非常相似，容器的目的是将内部的进程和代码执行与外部干扰隔离开来。</p><p id="a8fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前端世界中，当我们出于许多原因想要将外部资源与我们的网站隔离时，我们使用<code class="fe nc nd ne nf b">iframes</code> <strong class="ki iu"> </strong>。有时这是为了确保CSS或JavaScript执行不会有任何不必要的冲突；其他时候是为了在宿主和导入的代码之间加强一个安全层。</p><p id="22e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们将广告单元放在iframes中，因为它们通常由不同的团队甚至不同的公司构建，并且独立于管理主机网站的团队部署。在这种情况下，几乎不可能管理双方之间的CSS和JS冲突。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/b7e97c284dc9f77a72d3e7b5ee718f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVf3LMUun9K8tx2cF3y7JQ.png"/></div></div></figure><p id="690f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个用例是加强安全性。你在下面看到的PayPal按钮被放置在一个iframe中，以确保主机网站无法访问你在PayPal帐户上的任何信息。它甚至不能为你点击那个按钮。因此，即使你支付的网站被黑了，只要贝宝本身安全，你的贝宝也是安全的。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/9f79df9b7186c1ff5d1a0844ca494722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C03waK1vLwbX2EDyMrawJg.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">来自<a class="ae kf" href="http://guardian.co.uk" rel="noopener ugc nofollow" target="_blank">guardian.co.uk</a>的支付屏幕</p></figure><p id="2163" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker最初的用例是一样的。您可以将两个应用程序从彼此的进程、文件、内存等中分离出来，即使它们运行在同一台物理机器上。例如，如果一个数据库在Docker容器中运行，另一个应用程序就不能访问该数据库的文件，除非数据库容器希望它这样做。</p><h2 id="2fd4" class="nm lm it bd ln nn no dn lr np nq dp lv kr nr ns lz kv nt nu md kz nv nw mh nx bi translated">所以Docker容器是虚拟机？</h2><p id="d01a" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">有点——但不完全是。</p><p id="7e55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虚拟机运行自己的操作系统。这允许您在同一台计算机上运行macOS、Linux和Windows，这很神奇，但不是很高效，因为这些操作系统的边界必须非常精确地定义，以防止可能的冲突。</p><p id="a2d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是对于大多数意图和目的，容器不需要完全独立的操作系统。他们只是需要隔离。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/8785b13a92ed5c64cab3e21a6360efaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7dPpSH-pSZaZkamS_g1Kw.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">https://docs.docker.com/get-started/<a class="ae kf" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"/></p></figure><p id="5efe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，Docker所做的是在Linux上使用内核级隔离来隔离应用程序的资源，同时赋予它底层操作系统的功能。容器共享操作系统，但是保持它们的独立资源。</p><p id="3865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着更好的资源管理和更小的图像尺寸。因为一旦你把资源管理交给Docker，它就能确保容器不会使用比它们需要的更多的RAM和CPU，而如果你使用一个虚拟机，你就需要把一定数量的资源分配给虚拟机，不管它们是否总是使用它们。</p><p id="b228" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们开始了:我们现在知道了什么是Docker和什么是Docker容器的基本知识。但是隔离仅仅是开始。一旦我们获得了这些高性能的隔离容器和一个强大的资源管理器(Docker)来管理它们，我们就能够进行下一步了。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="2300" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">可再生容器</h1><p id="6345" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">Docker做得很好的另一件事是为我们提供了一种以声明方式重新构建容器的方法。</p><p id="9994" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所需要的是一个<code class="fe nc nd ne nf b">Dockerfile</code>来定义Docker应该如何构建我们的容器，我们知道我们每次都会得到相同的容器，不管底层硬件或操作系统如何。想想在所有桌面和移动设备上实现响应式设计有多复杂。如果有可能确定你需要什么，并且在任何地方都可以毫不费力地得到它，你难道不喜欢吗？这就是Docker试图完成的任务。</p><p id="de6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们进入一个真实的用例之前，让我们快速回顾一下Docker的生命周期，了解当。</p><h2 id="2652" class="nm lm it bd ln nn no dn lr np nq dp lv kr nr ns lz kv nt nu md kz nv nw mh nx bi translated">Docker容器的生命周期</h2><p id="6c13" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这一切都从一个<code class="fe nc nd ne nf b">Dockerfile</code>开始，它定义了我们希望Docker如何构建容器将基于的图像。请注意下面的流程:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9ddfffd1b9abda37e8029ac59624db04.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*f724uJHfz5UZensBxLF9mw.png"/></div></figure><p id="d076" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Docker使用<code class="fe nc nd ne nf b">Dockerfile</code>构建图像。它获取文件，执行命令，做任何在<code class="fe nc nd ne nf b">Dockerfile</code>中定义的事情，并将结果保存在一个静态文件中，我们称之为<code class="fe nc nd ne nf b">image</code>。Docker然后使用这个映像并创建一个容器来执行预定义的代码，使用该映像中的文件。因此，通常的生命周期如下所示:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/13ba37a3fe48965616991df3fd69afe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HmeXnfWL56p2qagAMs3I8g.png"/></div></div></figure><p id="3539" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用一个真实的用例来解开这个谜团。</p><h2 id="2c01" class="nm lm it bd ln nn no dn lr np nq dp lv kr nr ns lz kv nt nu md kz nv nw mh nx bi translated">对持续集成(CI)运行测试</h2><p id="fa71" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">Docker在前端开发中的一个常见用例是在将新代码部署到产品之前，在持续集成上运行单元或端到端测试。当编写代码时，在本地运行它们是很好的，但是在隔离的环境中运行它们总是更好，以确保无论计算机设置如何，您的代码在任何地方都可以工作。</p><p id="f4ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们都有这样一个队友，他总是跳过测试，只推代码。因此，CI设置也有助于控制每个人。下面是一个非常基本的容器设置，它将在您运行容器时运行您的测试:</p><figure class="nh ni nj nk gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="1a7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们检查一下那里的命令，以了解发生了什么。</p><p id="5af9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">FROM</code>用于定义要构建的基础图像。公共Docker注册表中已经有很多图片。<code class="fe nc nd ne nf b">FROM node:12</code>去公共注册中心，抓取一个安装了Node.js的图像，并把它带给我们。</p><p id="4032" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">COPY</code>用于将文件从主机复制到容器中。记住，容器有一个独立的文件系统。默认情况下，它无权访问我们计算机上的任何文件。我们运行<code class="fe nc nd ne nf b">COPY . /app</code>将文件从当前目录复制到容器内的<code class="fe nc nd ne nf b">/app</code>目录。您可以选择任何目标目录。这里的这个<code class="fe nc nd ne nf b">/app</code>只是一个例子。</p><p id="ce0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">WORKDIR</code>基本上就是我们从基于UNIX的系统中知道的<code class="fe nc nd ne nf b">cd</code>命令。它设置当前的工作目录。</p><p id="66a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">RUN</code>相当直截了当。它在我们构建的容器中运行下面的命令。</p><p id="2b33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">CMD</code>有点类似于<code class="fe nc nd ne nf b">RUN</code>。它还在容器内部运行以下命令。但是它不是在<em class="od">构建</em>时运行，而是在<em class="od">运行</em>时运行命令。您提供给<code class="fe nc nd ne nf b">CMD</code>的任何命令都将是容器启动后运行的命令。</p><p id="ac30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们的<code class="fe nc nd ne nf b">Dockerfile</code>构建一个容器的模板所要做的一切，该容器将设置Node.js环境并运行<code class="fe nc nd ne nf b">npm test</code>。</p><p id="3624" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，这个用例只是容器拥有的众多用例之一。在现代软件架构设置中，大多数服务器端服务要么已经在容器中运行，要么工程师们已经计划迁移到该架构。现在我们将要谈论这些<code class="fe nc nd ne nf b">images</code>帮助我们解决的也许是最重要的问题。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f3c8" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">可量测性</h1><p id="ed56" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是我们前端开发者经常忽略的。这是因为尽管后端代码只在少数几台服务器上为所有用户运行，但我们编写的代码在一台单独的机器上为我们的每个用户运行。他们甚至购买那些机器(个人电脑、智能手机等。)来运行我们的代码。这是我们前端开发人员所拥有的，而后端开发人员却没有的惊人的奢侈。</p><p id="cce5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在服务器端，可伸缩性是一个真正的问题，需要对基础架构和预算进行大量规划。云技术使得创建新的机器实例变得更加容易，但是让他们的代码在一台全新的机器上工作仍然是开发人员的工作。</p><p id="e824" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们一贯可再生的容器派上用场的地方。感谢Docker为我们构建的<code class="fe nc nd ne nf b">image</code>,我们可以部署任意多的容器(或者我们可以支付得起)。不再需要创建新的虚拟机、安装所有依赖项、传输代码、设置网络权限，以及我们过去为让服务器运行而采取的许多步骤。我们已经在<code class="fe nc nd ne nf b">image</code>中完成了所有这些工作。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="f58d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="35a3" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在过去的几年里，Docker无疑革新了我们开发和部署软件的方式。我希望我已经阐明了它受欢迎的原因。</p><p id="f6c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">毫无疑问，容器化及其带来的思维方式将继续影响我们在未来几年构建软件的方式。</p><h2 id="5e37" class="nm lm it bd ln nn no dn lr np nq dp lv kr nr ns lz kv nt nu md kz nv nw mh nx bi translated">进一步阅读</h2><ul class=""><li id="a693" class="mo mp it ki b kj mj kn mk kr oe kv of kz og ld mt mu mv mw bi translated"><a class="ae kf" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank"> Docker Docs (T1)</a></li><li id="ef53" class="mo mp it ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">Docker 容器的生命周期(T3)</li></ul></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="2c77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae kf" href="https://ozantunca.org" rel="noopener ugc nofollow" target="_blank">奥赞·通卡(Ozan Tunca)</a></p></div></div>    
</body>
</html>