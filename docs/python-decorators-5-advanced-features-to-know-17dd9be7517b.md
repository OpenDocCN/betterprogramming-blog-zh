# python Decorators——需要了解的 5 个高级特性

> 原文：<https://betterprogramming.pub/python-decorators-5-advanced-features-to-know-17dd9be7517b>

## 在您的项目中利用 Python decorators

![](img/ec018d482493f1cfdb226a04be896d0d.png)

图为 [Mantas Hesthaven](https://unsplash.com/@mantashesthaven?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上。

装饰器是修改其他函数的行为而不改变其核心操作的函数。顾名思义，装饰者只装饰其他功能。你可以把其他功能想象成普通的甜甜圈，而装饰者所做的就是给甜甜圈涂上不同的涂层。不管你有什么口味(装饰者)，甜甜圈(装饰功能)仍然是甜甜圈。

下面的代码向您展示了一个基本的装饰器，它记录了一个函数调用的运行时间。本质上，装饰函数接受另一个函数(即要装饰的函数)作为它的输入参数。它定义了一个实际提供装饰活动的内部函数，并返回该内部函数作为输出。要使用装饰器，只需将带有`@`符号前缀的装饰器函数名放在要用装饰器函数装饰的函数的上方。

装饰者的基本形式

既然您已经对装饰者的最基本形式有了很好的理解，那么是时候获得一些关于它们的更深入的知识了。

# 1.支持不同的函数签名

上面的代码片段有一个问题:它假设修饰的函数不需要任何输入参数(第 7 行)。如果我们将当前形式的装饰器与一个带参数的函数一起使用，它将不会像您预期的那样工作:

签名不兼容

为了解决这个问题，我们应该考虑在装饰定义中使用`*args`和`**kwargs`。这两个术语用于表示函数中不确定数量(零到更多)的位置和关键字参数。换句话说，它们可以捕获各种函数签名。让我们看看修改后的版本及其改进的兼容性:

支持不同的签名

正如您所看到的，最大的变化是不再假设函数不带参数，修改后的版本为函数调用提供了`*args` 和`**kwargs`，这样装饰器现在更加通用了。

# 2.包装修饰的函数

有些人可能不知道，默认情况下，修饰会弄乱被修饰函数的元数据，比如 docstrings。让我们看看当前装饰者的行为:

文档字符串有问题

如您所见，文档字符串显示了我们在装饰函数中定义的内部函数，而不是装饰函数`say_hello`。在引擎盖下，这都是因为装饰过程是从装饰器函数创建一个闭包。本质上，装修的过程相当于调用`say_hello = logging_time(say_hello)`。因此，用修饰函数获得内部函数的文档字符串就不足为奇了。

为了解决这个问题，我们可以使用标准 Python 库中附带的另一个装饰函数(`wraps`)，如下所示:

包装装饰函数

*   第 2 行:我们从`functools`模块导入`wraps`装饰函数。
*   第 6 行:我们使用`wraps`装饰器通过包装要装饰的函数来装饰内部函数(`func`参数)。
*   第 21-23 行:修饰函数现在有了正确的文档字符串。

除了为被修饰的函数传递期望的文档字符串之外，`wraps` decorator 对于被修饰的函数显示正确的函数注释(例如参数类型)和支持数据保存的 pickling 是必要的。

# 3.用参数定义装饰器

到目前为止，我们的装饰人员已经修复了他们的装饰功能。如果我们想让我们的装饰者根据用户的偏好表现出不同的行为呢？在这种情况下，我们可以考虑定义接受参数的装饰器。让我们继续记录函数运行时间的装饰示例。假设有一个微不足道的业务需求:我们的装饰者以用户指定的单位(毫秒或秒)显示时间。以下代码向您展示了一种可能的解决方案:

接受参数的装饰者

如您所见，为了允许装饰器接受`unit`参数，我们需要在我们之前定义的装饰器之外创建另一个层。让我们看看它是否如我们预期的那样工作:

带参数的装饰器

*   我们为装饰器使用了两种不同的设置，并且都按预期工作。
*   添加另一层来让装饰器接受参数的原因是装饰过程链接了函数调用。调用`logging_time(“ms”)`将允许我们获得`logger`函数，它与我们之前定义的装饰函数具有完全相同的函数签名。

请注意，装饰者的当前定义要求我们指定装饰的单元。如果你想让你的论点可选，那就需要额外的工作。你可以在我之前的文章中找到相关的讨论。

# 4.多个装饰者

上面的例子只使用了一个装饰器来装饰其他函数。然而，可以同时使用多个装饰器来装饰函数。要做到这一点，我们可以简单地将装饰器堆叠在要装饰的函数之上。以下代码片段向您展示了一个简单的示例:

多个装饰者

上面的代码向您展示了我们创建的另一个装饰器，它简单地调用了被装饰的函数两次。值得注意的是，我们定义了两个由两个装饰者装饰的函数。然而，我们以不同的顺序应用了装饰器，这将产生不同的效果:

装饰顺序的不同影响

*   我们注意到`say_hi`函数被调用了两次，而时间只被记录了一次。同时，`say_hello`函数被调用两次，时间也被记录两次。
*   当我们有多个装饰者时，应用装饰者的顺序是基于邻近性的。换句话说，在装饰功能正上方的是先发挥装饰作用，以此类推。这就是为什么`say_hi`函数的时间只被记录一次——因为`logging_time`装饰器是最后应用的。相比之下，重复装饰器应用于已经被`logging_time`装饰过的函数，因此`say_hello`函数的时间被记录了两次。

# 5.基于类的装饰者

我们一直在说装饰者是函数。准确地说，这些是高阶函数，这意味着这些函数使用其他函数作为输入和/或输出参数。但是，你知道 decorators 可以作为一个类来实现吗？有了 decorator 作为类的可能性，我们应该说 decorator 是可调用的。在之前的一篇文章中，我介绍了 callables。如果您不了解 callables，请随意查看。

以下代码向您展示了如何使用类定义装饰器:

作为类实现的装饰器

*   这个例子向您展示的不是最基本的 decorator 形式，而是可以接受参数的 decorator。
*   我将把创建一个充当装饰器的类的挑战留给您。使用类实现装饰器的基本原理与常规装饰器函数相同。您可以将类视为函数，因为上面的类通过实现`__call__`方法变得可调用。
*   正如您所看到的，通过指定重复次数，修饰函数可以按预期工作。

尽管使用类来实现装饰器是可能的，但是如果你希望你的装饰器是完全通用的，那么它会比这里介绍的更复杂。给出的例子只是为您提供一个概念证明。如果你想在一个类中定义的方法中使用这些装饰器，你必须考虑与类相关的位置参数(比如`cls`)或者与实例相关的位置参数(比如`self`)。更深入的知识可以参考一些关于[栈溢出](https://stackoverflow.com/questions/30104047/how-can-i-decorate-an-instance-method-with-a-decorator-class)的好的讨论。

# 结论

在本文中，我们首先回顾了 decorator 的基本形式，然后学习了 decorator 的五个更高级的特性。当你对 decoratorss 有了很好的理解，你可以定义一些自定义的 decorator(例如，登录时间，类型检查)，这将有助于你的日常工作。