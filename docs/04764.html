<html>
<head>
<title>Map, WeakMap, Set, and WeakSet in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Map、WeakMap、Set和WeakSet</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/map-weakmap-set-weakset-in-javascript-77ecb5161e3?source=collection_archive---------3-----------------------#2020-05-07">https://betterprogramming.pub/map-weakmap-set-weakset-in-javascript-77ecb5161e3?source=collection_archive---------3-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a24" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">每个集合对象的说明</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/29fb15d014aeb292bfa28a09e573f152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fHXEfqB3bA5tWPe2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">杰夫·谢尔登在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="62e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我猜想超过70%的JavaScript开发人员只在他们的项目中使用对象来收集和维护数据。事实上，更新的集合对象，如<code class="fe lv lw lx ly b">Map</code>和<code class="fe lv lw lx ly b">Set</code>，并没有得到充分利用，尽管它们是在2015年推出的。</p><p id="1f76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以今天，我要谈谈2015年的奇妙新功能——<code class="fe lv lw lx ly b">Map</code>、<code class="fe lv lw lx ly b">Set</code>、<code class="fe lv lw lx ly b">WeakMap</code>和<code class="fe lv lw lx ly b">WeakSet</code>。</p><h2 id="ed3d" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">阅读前</h2><ul class=""><li id="8f36" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated">这篇文章不会告诉你如何使用它们。但是我见过一些申请者在编码测试中使用了其中的一个，我喜欢在某些情况下使用它们。由您决定何时在您的项目中使用它们。</li><li id="c623" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated">为了更好地理解我将要谈论的内容，你应该知道什么是。查看我以前的文章，了解更多关于t 下摆的信息。</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="402b" class="nq ma it bd mb nr ns nt me nu nv nw mh jz nx ka mk kc ny kd mn kf nz kg mq oa bi translated">目标</h1><p id="c5fd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">应该先说说如何使用对象。</p><p id="1b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，我相信超过90%的人已经知道了这一部分，因为你点击了这篇文章，以了解新的集合对象，但对于JavaScript的初学者，让我们简单地谈谈它们。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="b5e0" class="lz ma it ly b gy oi oj l ok ol">const algorithm = { site: "leetcode" };<br/>console.log(algorithm.site); // leetcode</span><span id="9bde" class="lz ma it ly b gy om oj l ok ol">for (const key in algorithm) {<br/>  console.log(key, algorithm[key]);<br/>}<br/>// site leetcode</span><span id="6edf" class="lz ma it ly b gy om oj l ok ol">delete algorithm.site;<br/>console.log(algorithm.site); // undefined</span></pre><p id="ed93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我做了一个<code class="fe lv lw lx ly b">algorithm</code>对象，它的键和值是一个字符串类型的值。我已经通过使用关键字<code class="fe lv lw lx ly b">.</code>成功地检查了这个值。</p><p id="2f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，一个<code class="fe lv lw lx ly b">for-in</code>循环对于遍历对象是很好的。您可以使用<code class="fe lv lw lx ly b">[]</code>关键字访问与其键对应的值。但是不能使用<code class="fe lv lw lx ly b">for-of</code>循环，因为对象是不可迭代的。</p><p id="2484" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对象的属性可以用<code class="fe lv lw lx ly b">delete</code>关键字删除。这完全从对象中去除了属性，您应该小心不要与这种方法混淆。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="4b32" class="lz ma it ly b gy oi oj l ok ol">const algorithm = { site: "leetcode" };</span><span id="8fd1" class="lz ma it ly b gy om oj l ok ol">// Property is not removed!!<br/>algorithm.site = undefined;</span><span id="402a" class="lz ma it ly b gy om oj l ok ol">// Property is removed!!<br/>delete algorithm.site;</span></pre><p id="a2ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">algorithm.site = undefined</code>只是将新值分配给<code class="fe lv lw lx ly b">site</code>。</p><p id="f12e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好了，我们已经快速讨论了一些关于对象的事情:</p><ul class=""><li id="1542" class="ms mt it lb b lc ld lf lg li on lm oo lq op lu mz na nb nc bi translated">如何添加属性</li><li id="5b6f" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated">如何在对象上循环</li><li id="9a4b" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated">如何删除属性</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="8f2d" class="nq ma it bd mb nr ns nt me nu nv nw mh jz nx ka mk kc ny kd mn kf nz kg mq oa bi translated">地图</h1><p id="c69b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">Map</code>是JavaScript中一个新的集合对象，其功能类似于一个对象。但是与常规对象相比，还是有一些主要的区别。</p><p id="6f86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们看一个创建<code class="fe lv lw lx ly b">Map</code>对象的简单例子。</p><h2 id="d9e3" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">如何添加属性</h2><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="9694" class="lz ma it ly b gy oi oj l ok ol">const map = new Map();<br/>// Map(0) {}</span></pre><p id="1508" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。<code class="fe lv lw lx ly b">Map</code>不需要创造任何东西。但是添加数据的方式略有不同。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="9516" class="lz ma it ly b gy oi oj l ok ol">map.set('name', 'john');<br/>// Map(1) {"name" =&gt; "john"}</span></pre><p id="5700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Map</code>有一个特殊的添加属性的方法叫做<code class="fe lv lw lx ly b">set</code>。它有两个参数:键作为第一个参数，值作为第二个参数。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="4fd4" class="lz ma it ly b gy oi oj l ok ol">map.set('phone', 'iPhone');<br/>// Map(2) {"name" =&gt; "john", "phone" =&gt; "iPhone"}</span><span id="263c" class="lz ma it ly b gy om oj l ok ol">map.set('phone', 'iPhone');<br/>// Map(2) {"name" =&gt; "john", "phone" =&gt; "iPhone"}</span></pre><p id="12c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，它不允许您在其中添加现有数据。如果新数据的关键字对应的值已经存在于<code class="fe lv lw lx ly b">Map</code>对象中，则不会添加新数据。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="565b" class="lz ma it ly b gy oi oj l ok ol">map.set('phone', 'Galaxy');<br/>// Map(2) {"name" =&gt; "john", "phone" =&gt; "Galaxy"}</span></pre><p id="c1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是您可以用不同的值覆盖现有数据。</p><h2 id="16c7" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">如何在对象上循环</h2><p id="f411" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated"><code class="fe lv lw lx ly b">Map</code>是一个iterable对象，这意味着它可以用<code class="fe lv lw lx ly b">for-of</code>语句映射。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="9f7f" class="lz ma it ly b gy oi oj l ok ol">for (const item of map) {<br/>  console.dir(item);<br/>}</span><span id="db6e" class="lz ma it ly b gy om oj l ok ol">// Array(2) ["name", "john"]<br/>// Array(2) ["phone", "Galaxy"]</span></pre><p id="c0c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要记住的一点是<code class="fe lv lw lx ly b">Map</code>以数组的形式给出数据。您应该析构数组或访问每个索引来获取键或值。</p><p id="2eb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要仅获取键或值，您也可以遵循一些方法。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="abcf" class="lz ma it ly b gy oi oj l ok ol">map.keys();<br/>// MapIterator {"name", "phone"}</span><span id="6835" class="lz ma it ly b gy om oj l ok ol">map.values();<br/>// MapIterator {"john", "Galaxy"}</span><span id="0854" class="lz ma it ly b gy om oj l ok ol">map.entries();<br/>// MapIterator {"name" =&gt; "john", "phone" =&gt; "Galaxy"}</span></pre><p id="671b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您甚至可以使用spread操作符来获得<code class="fe lv lw lx ly b">Map</code>的完整数据，因为spread操作符也可以处理场景背后的iterable对象。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="0d65" class="lz ma it ly b gy oi oj l ok ol">const simpleSpreadedMap = [...map];<br/>// [Array(2), Array(2)]</span></pre><h2 id="d7b8" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">如何删除属性</h2><p id="878d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">从<code class="fe lv lw lx ly b">Map</code>对象中移除数据也非常容易。你需要做的就是调用<code class="fe lv lw lx ly b">delete</code>。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="1e08" class="lz ma it ly b gy oi oj l ok ol">map.delete('phone');<br/>// true</span><span id="045e" class="lz ma it ly b gy om oj l ok ol">map.delete('fake');<br/>// false</span></pre><p id="c93b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">delete</code>返回布尔值，表示删除功能是否成功删除数据。如果是，则返回<code class="fe lv lw lx ly b">true</code>，否则返回<code class="fe lv lw lx ly b">false</code>。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="d445" class="nq ma it bd mb nr ns nt me nu nv nw mh jz nx ka mk kc ny kd mn kf nz kg mq oa bi translated">WeakMap</h1><p id="e814" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated"><code class="fe lv lw lx ly b">WeakMap</code>源于<code class="fe lv lw lx ly b">Map</code>，所以彼此很像。然而，<code class="fe lv lw lx ly b">WeakMap</code>有一个很大的不同。</p><p id="c5fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">WeakMap</code>是如何得名的？嗯，这是因为它与它的引用链接所引用的数据对象的连接或关系不如<code class="fe lv lw lx ly b">Map</code>的连接或关系强，使得<em class="nd">弱。</em></p><p id="f47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么这到底意味着什么呢？</p><h2 id="c96c" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">区别1:键必须是一个对象</h2><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="26eb" class="lz ma it ly b gy oi oj l ok ol">const John = { name: 'John' };<br/>const weakMap = new WeakMap();</span><span id="c08e" class="lz ma it ly b gy om oj l ok ol">weakMap.set(John, 'student');<br/>// WeakMap {{...} =&gt; "student"}</span><span id="0853" class="lz ma it ly b gy om oj l ok ol">weakMap.set('john', 'student');<br/>// Uncaught TypeError: Invalid value used as weak map key</span></pre><p id="a3fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将任何值作为键传递给<code class="fe lv lw lx ly b">Map</code>对象，但是<code class="fe lv lw lx ly b">WeakMap</code>不同。它只接受一个对象作为键；否则，它将返回一个错误。</p><h2 id="071e" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">区别2:并非所有来自Map的方法都受支持</h2><p id="1b7b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">您可以使用<code class="fe lv lw lx ly b">WeakMap</code>的方法如下。</p><ul class=""><li id="e41c" class="ms mt it lb b lc ld lf lg li on lm oo lq op lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">delete</code></li><li id="cae8" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">get</code></li><li id="fbfc" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">has</code></li><li id="1f1e" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">set</code></li></ul><p id="fc2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个主题中最大的不同是<code class="fe lv lw lx ly b">WeakMap</code>不支持迭代对象的方法。但是为什么呢？下面有描述。</p><h2 id="bb4d" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">区别3:当GC清理引用时，数据被删除</h2><p id="33ec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">这是相比<code class="fe lv lw lx ly b">Map</code>最大的不同。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="ffea" class="lz ma it ly b gy oi oj l ok ol">let John = { major: "math" };</span><span id="e765" class="lz ma it ly b gy om oj l ok ol">const map = new Map();<br/>const weakMap = new WeakMap();</span><span id="7028" class="lz ma it ly b gy om oj l ok ol">map.set(John, 'John');<br/>weakMap.set(John, 'John');</span><span id="b08f" class="lz ma it ly b gy om oj l ok ol">John = null;<br/>/* John is garbage-collected */</span></pre><p id="35c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">John</code>对象被垃圾回收时，<code class="fe lv lw lx ly b">Map</code>对象保持引用链接，而<code class="fe lv lw lx ly b">WeakMap</code>对象失去链接。所以你在使用<code class="fe lv lw lx ly b">WeakMap</code>的时候，要考虑这个特性。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="ee56" class="nq ma it bd mb nr ns nt me nu nv nw mh jz nx ka mk kc ny kd mn kf nz kg mq oa bi translated">一组</h1><p id="4a31" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated"><code class="fe lv lw lx ly b">Set</code>也和<code class="fe lv lw lx ly b">Map</code>很像，但是<code class="fe lv lw lx ly b">Set</code>对于单个值更有用。</p><h2 id="a155" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">如何添加属性</h2><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="e7d2" class="lz ma it ly b gy oi oj l ok ol">const set = new Set();</span><span id="dfe4" class="lz ma it ly b gy om oj l ok ol">set.add(1);<br/>set.add('john');<br/>set.add(BigInt(10));<br/>// Set(4) {1, "john", 10n}</span></pre><p id="a38e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe lv lw lx ly b">Map</code>一样，<code class="fe lv lw lx ly b">Set</code>也阻止我们添加相同的值。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="53ac" class="lz ma it ly b gy oi oj l ok ol">set.add(5);<br/>// Set(1) {5}</span><span id="6a36" class="lz ma it ly b gy om oj l ok ol">set.add(5);<br/>// Set(1) {5}</span></pre><h2 id="a137" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">如何在对象上循环</h2><p id="9c0e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">因为<code class="fe lv lw lx ly b">Set</code>是一个可迭代的对象，你可以使用一个<code class="fe lv lw lx ly b">for-of</code>或者<code class="fe lv lw lx ly b">forEach</code>语句。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="7558" class="lz ma it ly b gy oi oj l ok ol">for (const val of set) {<br/>  console.dir(val);<br/>}<br/>// 1<br/>// 'John'<br/>// 10n<br/>// 5</span><span id="eb0d" class="lz ma it ly b gy om oj l ok ol">set.forEach(val =&gt; console.dir(val));<br/>// 1<br/>// 'John'<br/>// 10n<br/>// 5</span></pre><h2 id="be49" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">如何删除属性</h2><p id="6434" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">这部分和<code class="fe lv lw lx ly b">Map</code>的删除完全一样。如果数据删除成功，返回<code class="fe lv lw lx ly b">true</code>；否则，它返回<code class="fe lv lw lx ly b">false</code>。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="6a3f" class="lz ma it ly b gy oi oj l ok ol">set.delete(5); <br/>// true</span><span id="ffbf" class="lz ma it ly b gy om oj l ok ol">set.delete(function(){});<br/>// false;</span></pre><p id="5e1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Set</code>当你不想把相同的值添加到数组形式中时，可能会很有用。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="7b85" class="lz ma it ly b gy oi oj l ok ol">/* With Set */<br/>const set = new Set();</span><span id="97c8" class="lz ma it ly b gy om oj l ok ol">set.add(1);<br/>set.add(2);<br/>set.add(2);<br/>set.add(3);<br/>set.add(3);<br/>// Set {1, 2, 3}</span><span id="57b0" class="lz ma it ly b gy om oj l ok ol">// Converting to Array<br/>const arr = [ ...set ];<br/>// [1, 2, 3]</span><span id="0c30" class="lz ma it ly b gy om oj l ok ol">Object.prototype.toString.call(arr);<br/>// [object Array]</span><span id="9f9c" class="lz ma it ly b gy om oj l ok ol">/* Without Set */<br/>const hasSameVal = val =&gt; ar.some(v === val);<br/>const ar = [];</span><span id="4d12" class="lz ma it ly b gy om oj l ok ol">if (!hasSameVal(1)) ar.push(1);<br/>if (!hasSameVal(2)) ar.push(2);<br/>if (!hasSameVal(3)) ar.push(3);</span></pre></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="2ed9" class="nq ma it bd mb nr ns nt me nu nv nw mh jz nx ka mk kc ny kd mn kf nz kg mq oa bi translated">WeakSet</h1><p id="1d2a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">和<code class="fe lv lw lx ly b">WeakMap</code>一样，<code class="fe lv lw lx ly b">WeakSet</code>如果被垃圾收集，也会失去对内部数据的访问链接。</p><pre class="kj kk kl km gt oe ly of og aw oh bi"><span id="1c99" class="lz ma it ly b gy oi oj l ok ol">let John = { major: "math" };</span><span id="7baf" class="lz ma it ly b gy om oj l ok ol">const set = new Set();<br/>const weakSet = new WeakSet();</span><span id="8e34" class="lz ma it ly b gy om oj l ok ol">set.add(John);<br/>// Set {{...}}<br/>weakSet.add(John);<br/>// WeakSet {{...}}</span><span id="7773" class="lz ma it ly b gy om oj l ok ol">John = null;<br/>/* John is garbage-collected */</span></pre><p id="b651" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦对象<code class="fe lv lw lx ly b">John</code>被垃圾收集，<code class="fe lv lw lx ly b">WeakSet</code>就无法访问引用<code class="fe lv lw lx ly b">John</code>的数据。并且<code class="fe lv lw lx ly b">WeakSet</code>不支持<code class="fe lv lw lx ly b">for-of</code>或<code class="fe lv lw lx ly b">forEach</code>，因为它不是可迭代的。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="216c" class="nq ma it bd mb nr ns nt me nu nv nw mh jz nx ka mk kc ny kd mn kf nz kg mq oa bi translated">比较摘要</h1><h2 id="5eb2" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">全部</h2><ul class=""><li id="db74" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated">不支持添加相同的值</li></ul><h2 id="1e02" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">地图与WeakMap</h2><ul class=""><li id="0fca" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated"><code class="fe lv lw lx ly b">WeakMap</code>只接受对象作为键，而<code class="fe lv lw lx ly b">Map</code>不接受</li></ul><h2 id="48a4" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">地图和布景</h2><ul class=""><li id="b5dc" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated">支持可迭代对象— <code class="fe lv lw lx ly b">for-of</code>、<code class="fe lv lw lx ly b">forEach</code>或<code class="fe lv lw lx ly b">spread</code>运算符</li><li id="4209" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated">不受GC关系约束</li></ul><h2 id="2844" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">WeakMap和WeakSet</h2><ul class=""><li id="938e" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated">不是可迭代对象—不能循环</li><li id="c533" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated">如果引用数据被垃圾收集，则无法访问数据</li><li id="ffba" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated">支持性较差的方法</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><h1 id="7476" class="nq ma it bd mb nr ns nt me nu nv nw mh jz nx ka mk kc ny kd mn kf nz kg mq oa bi translated">结论</h1><p id="5bdb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li ob lk ll lm oc lo lp lq od ls lt lu im bi translated">尽管如此，我认为许多团队或公司并不使用<code class="fe lv lw lx ly b">Map</code> s或<code class="fe lv lw lx ly b">Set</code> s。也许是因为他们觉得没有必要，或者是因为数组仍然可以做几乎所有他们想做的事情。</p><p id="bc4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，根据不同的情况，<code class="fe lv lw lx ly b">Map</code> s或<code class="fe lv lw lx ly b">Set</code> s可能是JavaScript中非常独特和强大的东西。所以我希望有一天，你能有机会使用它们。</p><h2 id="3c72" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">资源</h2><ul class=""><li id="b405" class="ms mt it lb b lc mu lf mv li mw lm mx lq my lu mz na nb nc bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">地图— MDN </a></li><li id="9b06" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"> WeakMap — MDN </a></li><li id="dec6" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">设置— MDN </a></li><li id="96bc" class="ms mt it lb b lc ne lf nf li ng lm nh lq ni lu mz na nb nc bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet" rel="noopener ugc nofollow" target="_blank"> WeakSet — MDN </a></li></ul></div></div>    
</body>
</html>