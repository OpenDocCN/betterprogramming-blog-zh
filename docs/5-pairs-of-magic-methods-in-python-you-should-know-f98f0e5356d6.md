# 你应该知道的 Python 中的 5 对神奇方法

> 原文：<https://betterprogramming.pub/5-pairs-of-magic-methods-in-python-you-should-know-f98f0e5356d6>

## 理解与这些神奇方法相关的五个关键 Python 概念

![](img/1a55b246c628f695277f8e093e732f59.png)

照片由 [Liz Hixon](https://unsplash.com/@liz_hixon?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 介绍

当谈到 Python 中的命名函数时，我们可以使用下划线以及字母和数字。当单词之间使用下划线时，它们没有太大的意义——它们只是通过在单词之间创建空格来提高可读性。这就是众所周知的蛇命名风格。例如，`calculate_mean_score`比`calculatemeanscore`更容易阅读。如你所知，除了这种使用下划线的常见方式，我们还在函数名前加上一两个下划线(例如，`_func`，`__func`)来表示这些函数是在类或模块中私有使用的。不带下划线前缀的名称被视为公共 API。

下划线在函数命名中的另一种用法是魔法方法，也称为特殊方法。具体来说，我们在函数名之前和之后放置两个下划线——类似于`__func__`。由于使用了双下划线，有些人将特殊方法称为“邓德方法”或简称为“邓德”在本文中，我想回顾五对密切相关的常见魔术方法，每一对代表一个 Python 概念。

# 1.实例化:__new__ 和 __init__

在学习了 Python 数据结构的基础知识(例如，字典、列表)之后，您应该已经看到了一些定义定制类的例子，在这些例子中，您第一次接触到了一种神奇的方法— `__init__`。此方法用于定义实例对象的初始化行为。具体来说，在 `__init__`方法中，您希望为创建的实例对象设置初始属性。这里有一个简单的例子:

__init__ 方法

当我们使用`__init__`方法时，我们不直接调用它。相反，`__init__`方法成为类的构造函数方法的构建基础，它与`__init__`方法具有相同的函数签名。例如，要创建一个新的`Product`实例，使用下面的代码:

```
product = Product(**"Vacuum"**, 150.0)
```

与`__init__`方法密切相关的是`__new__`方法，我们通常不会在自定义类中实现它。本质上，`__new__`方法实际上创建了实例对象，该对象被传递给`__init__`方法以完成初始化过程。

*换句话说，构造一个新的实例对象(称为实例化的过程)需要依次调用* `*__new__*` *和* `*__init__*` *方法。*

下面的代码向您展示了这样一个反应链:

实例构建过程

# 2.字符串表示形式:__repr__ 和 __str__

这两种方法对于为自定义类设置正确的字符串表示都很重要。在解释它们之前，让我们快速看一下下面的实现:

字符串表示

*`*__repr__*`*方法应该返回一个字符串，显示如何创建实例对象。*具体来说，可以将字符串传递给`eval()`来重新构造实例对象。以下代码片段向您展示了这样的操作:*

*__repr__ 字符串的求值*

**`*__str__*`*方法可以返回更多关于实例对象的描述。*需要注意的是`print()`函数使用了`__str__`方法来显示实例相关的信息，如下所示。**

```
**>>> print(product)
Product: Vacuum, $150.00**
```

**虽然这两个方法都应该返回字符串，但是`__repr__`方法通常是为开发人员设计的，所以我们希望显示实例化信息，而`__str__`方法是为普通用户设计的，所以我们希望显示更多的信息。**

# **3.迭代:__iter__ 和 __next__**

**我们可以用代码自动化的一个关键操作是为我们重复某项工作，它的实现涉及到作为逻辑流的 for 循环。就相关对象而言，可以在 for 循环中使用的是 iterable。for 循环的基本形式如下所示:**

```
**for item in iterable:
    # Operations go here**
```

**在底层，iterable 被转换为迭代器，它为每个循环提供 iterable 中的项。*一般来说，迭代器是 Python 对象，可以用来渲染要迭代的项目。* 通过实现`__iter__`特殊方法完成转换。此外，检索迭代器的下一项涉及到`__next__`特殊方法的实现。让我们继续前面的例子，让我们的`Product`类在 for 循环中作为迭代器工作:**

**自定义迭代器**

**如上所示，我们在`__iter__`方法中创建了一个包含免费样本的对象列表，为定制类实例创建了一个迭代器。为了实现迭代行为，我们通过呈现免费样本列表中的对象来实现`__next__`方法。当我们用完免费样本时，迭代结束。**

# **4.上下文管理器:__enter__ 和 __exit__**

**当我们在 Python 中处理文件对象时，您可能遇到的最常见的语法可能是这样的:**

```
**with open('filename.txt') as file:
    # Your file operations go here**
```

**`with`语句的使用被称为上下文管理器技术。具体来说，在上面的文件操作示例中，`with`语句将为文件对象创建上下文管理器，并且在文件操作之后，上下文管理器将帮助我们关闭文件对象，使得共享资源(即，文件)可用于其他进程。**

**所以，*一般来说，上下文管理器是管理共享资源*的 Python 对象，比如为我们打开和关闭。没有它们，我们必须手动管理它们，这很容易出错。**

**为了用自定义类实现这样的行为，我们的类需要实现`__enter__`和`__exit__`方法。`__enter__`方法设置上下文管理器，为我们操作准备所需的资源，而`__exit__`方法是清理任何应该释放的已用资源，使它们可用。让我们考虑一下前面的`Product`类的简单例子:**

**上下文管理器**

**正如您所看到的，当实例对象嵌入到一个`with`语句中时，就会调用`__enter__`方法。当操作在`with`语句中完成时，调用`__exit__`方法。**

**然而，应该注意的是，我们可以实现`__enter__`和`__exit__`方法来创建上下文管理器。使用上下文管理器装饰函数可以更容易地做到这一点——您可以在我之前的文章中找到关于这个主题的更多信息。**

# **5.更精细的属性访问控制:__getattr__ 和 __setattr__**

**如果您有其他语言的编程经验，您可能已经习惯于为实例属性设置显式的 getters 和 setters。在 Python 中，我们不需要对每个单独的属性使用这些访问控制技术。然而，我们可以通过实现`__getattr__`和`__setattr__`方法来进行一些控制。具体来说，当访问实例对象的属性时会调用`__getattr__`方法，而当我们设置实例对象的属性时会调用`__setattr__`方法。**

**属性的访问控制**

**每次我们试图设置对象的属性时，都会调用`__setattr__`方法。要正确使用它，您必须通过使用 super()来使用超类方法。否则，它将陷入无限递归。**

**设置完`formatted_name`属性后，该属性将成为`__dict__`对象的一部分，所以`__getattr__`不会被调用。**

**顺便提一下，还有另一个与访问控制密切相关的特殊方法叫做`__getattribute__`，它类似于`__getattr__`，但是每次访问一个属性时都会被调用。在这方面，它类似于`__setattr__` ——同样，您应该使用`super()`来实现`__getattribute__`方法，以避免无限递归错误。**

# **结论**

**在本文中，我们回顾了五对重要的特殊方法，通过这些方法，我们学习了与每一对相关的五个 Python 概念。我希望您对这些概念以及如何在自己的 Python 项目中使用特殊方法有更好的理解。**