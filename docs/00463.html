<html>
<head>
<title>Decorators in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的装饰者</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decorators-in-python-72a1d578eac4?source=collection_archive---------0-----------------------#2019-05-26">https://betterprogramming.pub/decorators-in-python-72a1d578eac4?source=collection_archive---------0-----------------------#2019-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ec6d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用一个简单的例子简要描述Python中的decorators</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a04172da422312dd311e6ae88b03996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-z53EJJxiBYFmm7qaYD-Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hishahadat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">沙哈达特·拉赫曼</a>在<a class="ae ky" href="https://unsplash.com/s/photos/python-coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="9553" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">功能</h1><p id="1de8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Python中，函数是一级对象，这意味着:</p><ul class=""><li id="aff3" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated">函数是对象——它们可以被引用，传递给变量，也可以从其他函数返回。</li><li id="512e" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated">函数可以在另一个函数中定义，也可以作为参数传递给另一个函数。</li></ul><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="b5dc" class="nl la it ng b gy nm nn l no np">def say_name():<br/>    print("Guido van Rossum")<br/><br/><br/>def say_nationality():<br/>    print("Netherlands")<br/><br/><br/>def say(func):<br/>    return func<br/><br/><br/>say(say_name)()<br/>say(say_nationality)()</span></pre><p id="7fe0" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="e2c6" class="nl la it ng b gy nm nn l no np">Guido van Rossum<br/>Netherlands</span></pre><p id="74e8" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">这里我们向<code class="fe nd ne nf ng b">say</code>函数发送两个不同的函数引用(不是括号),作为再次返回引用的参数。</p><p id="b07a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">这就是<strong class="lt iu">内部函数</strong>的工作方式:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="5be4" class="nl la it ng b gy nm nn l no np">def say():<br/><br/>    def say_name():<br/>        print("Guido van Rossum")<br/><br/>    def say_nationality():<br/>        print("Netherlands")<br/><br/>    say_name()<br/>    say_nationality()<br/><br/>say()</span></pre><p id="5a54" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="a56c" class="nl la it ng b gy nm nn l no np">Guido van Rossum<br/>Netherlands</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="e78e" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">装修工</h1><p id="9484" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">您已经看到了函数就像Python中的任何其他对象一样，现在让我们举一个例子来看看Python装饰器的魔力。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f0ec" class="nl la it ng b gy nm nn l no np">def say(func):<br/><br/>    def employer():<br/>        print("Say something about you.")<br/><br/>    def say_name():<br/>        print("My name is Guido van Rossum.")<br/><br/>    def say_nationality():<br/>        print("I am from Netherlands.")<br/><br/>    def wrapper():<br/>        employer()<br/>        say_name()<br/>        say_nationality()<br/>        func()<br/><br/>    return wrapper<br/><br/>@say<br/>def start_interview():<br/>    print("Real interview Started...")<br/><br/>start_interview()</span></pre><p id="010e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="b868" class="nl la it ng b gy nm nn l no np">Say something about you.<br/>My name is Guido van Rossum.<br/>I am from Netherlands.<br/>Real interview Started...</span></pre><p id="9d2a" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">这里我们称之为<code class="fe nd ne nf ng b">start_interview</code>方法。它转到装饰器函数<code class="fe nd ne nf ng b">say</code>并定义<code class="fe nd ne nf ng b">employer</code>、<code class="fe nd ne nf ng b">say_name</code>、<code class="fe nd ne nf ng b">say_nationality</code>和<code class="fe nd ne nf ng b">wrapper</code>函数，最后它返回<code class="fe nd ne nf ng b">wrapper</code>函数引用，并在调用调用者函数<code class="fe nd ne nf ng b">start_interview</code>的地方调用它。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="4128" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">用参数修饰函数</h1><p id="7cc9" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们还可以修饰一个接受参数的函数。我们可以在包装函数中使用<code class="fe nd ne nf ng b">*args</code>和<code class="fe nd ne nf ng b">**kwargs</code>来接受这些参数。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="050a" class="nl la it ng b gy nm nn l no np">def say(func):<br/><br/>    def wrapper(*args, **kwargs):<br/>        func(*args, **kwargs)<br/>    return wrapper<br/><br/>@say<br/>def greet(name):<br/>    print("Hello {}".format(name))<br/><br/>greet("Goutom")</span></pre><p id="4481" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f0cd" class="nl la it ng b gy nm nn l no np">Hello Goutom</span></pre><h1 id="37e3" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">从修饰函数返回</h1><p id="33fb" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">当你的修饰函数返回一些东西时会发生什么？只需从包装器返回调用函数。让我们看一个例子来理解这一点。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="010f" class="nl la it ng b gy nm nn l no np">def my_decorator(func):<br/><br/>    def wrapper(*args, **kwargs):<br/>        return func(*args, **kwargs)<br/>    return wrapper<br/><br/>@my_decorator<br/>def doubled(number):<br/>    return number*2<br/><br/>print(doubled(10))</span></pre><p id="36ca" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="6887" class="nl la it ng b gy nm nn l no np">20</span></pre><h1 id="3b68" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">反省</h1><p id="e425" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在Python <a class="ae ky" href="https://docs.python.org/3/library/inspect.html" rel="noopener ugc nofollow" target="_blank">中，自省</a>是一个对象在运行时知道自己属性的能力。例如，一个函数知道自己的名字和文档。让我们打印出<code class="fe nd ne nf ng b">doubled</code>函数名。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f85b" class="nl la it ng b gy nm nn l no np">print(doubled.__name__)</span></pre><p id="9932" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="41d0" class="nl la it ng b gy nm nn l no np">wrapper</span></pre><p id="dcfd" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">但是它应该是<code class="fe nd ne nf ng b">doubled.</code>在被修饰之后，我们的<code class="fe nd ne nf ng b">doubled</code>函数已经对它的身份感到困惑，因为它是从<code class="fe nd ne nf ng b">wrapper</code>函数中被调用的。为了解决这个问题，decorator应该在<code class="fe nd ne nf ng b">wrapper</code>函数中使用<code class="fe nd ne nf ng b"><a class="ae ky" href="https://docs.python.org/library/functools.html#functools.wraps" rel="noopener ugc nofollow" target="_blank">@functools.wraps</a></code> decorator，它将保存关于原始函数的信息。添加这个装饰器后，它将返回它原来的名字<code class="fe nd ne nf ng b">doubled</code>。</p><h1 id="33ba" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">现实世界的例子</h1><p id="f4e5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">让我们编写一个装饰器，它将以秒为单位计算函数执行时间，并在控制台中打印出来。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="d7dc" class="nl la it ng b gy nm nn l no np">import functools<br/>import time<br/><br/><br/>def timer(func):<br/><br/>    @functools.wraps(func)<br/>    def wrapper(*args, **kwargs):<br/>        start_time = time.perf_counter()<br/>        value = func(*args, **kwargs)<br/>        end_time = time.perf_counter()<br/>        run_time = end_time - start_time<br/>        print("Finished {} in {} secs".format(repr(func.__name__), round(run_time, 3)))<br/>        return value<br/><br/>    return wrapper</span></pre><p id="e2eb" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">现在让我们使用这个装饰器:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="58ee" class="nl la it ng b gy nm nn l no np">@timer<br/>def doubled_and_add(num):<br/>    res = sum([i*2 for i in range(num)])<br/>    print("Result : {}".format(res))<br/><br/>doubled_and_add(100000)<br/>doubled_and_add(1000000)</span></pre><p id="2df7" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f7df" class="nl la it ng b gy nm nn l no np">Result : 9999900000<br/>Finished ‘doubled_and_add’ in 0.0119 secs<br/>Result : 999999000000<br/>Finished ‘doubled_and_add’ in 0.0897 secs</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="7ea9" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">注册插件</h1><p id="11fd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">装饰者不必包装他们正在装饰的功能。他们也可以简单地注册一个函数的存在，并将其解包返回。例如，这可以用来创建一个轻量级插件架构:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="7074" class="nl la it ng b gy nm nn l no np">PLUGINS = dict()<br/><br/>def register(func):<br/>    PLUGINS[func.__name__] = func<br/>    return func<br/><br/>@register<br/>def add(a, b):<br/>    return a+b<br/><br/>@register<br/>def multiply(a, b):<br/>    return a*b<br/><br/>def operation(func_name, a, b):<br/>    func = PLUGINS[func_name]<br/>    return func(a, b)<br/><br/>print(PLUGINS)<br/>print(operation('add', 2, 3))<br/>print(operation('multiply', 2, 3))</span></pre><p id="da8d" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="ae52" class="nl la it ng b gy nm nn l no np">{‘add’: &lt;function add at 0x7fb27f7a8620&gt;, ‘multiply’: &lt;function multiply at 0x7fb27f7a88c8&gt;}<br/>5<br/>6</span></pre><p id="f3f1" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated"><code class="fe nd ne nf ng b">@register</code>装饰器只是在全局<code class="fe nd ne nf ng b">PLUGINS</code>字典中存储一个对被装饰函数的引用。注意，在本例中，您不必编写内部函数或使用<code class="fe nd ne nf ng b">@functools.wraps</code>，因为您返回的是未修改的原始函数。这种简单的插件架构的主要好处是，您不需要维护存在哪些插件的列表。该列表是在插件注册时创建的。这使得添加新插件变得很简单:只需定义函数并用<code class="fe nd ne nf ng b">@register</code>修饰它。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="f45b" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">装饰课</h1><p id="9369" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">有两种不同的方式在类中使用装饰器。第一种是装饰一个类的方法或者装饰整个类。</p><h2 id="88e7" class="nl la it bd lb of og dn lf oh oi dp lj ma oj ok ll me ol om ln mi on oo lp op bi translated">一些内置的类装饰器</h2><p id="c8d5" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">Python内置的一些常用装饰器有<code class="fe nd ne nf ng b">@classmethod</code>、<code class="fe nd ne nf ng b">@staticmethod</code>和<code class="fe nd ne nf ng b">@property</code>。<code class="fe nd ne nf ng b">@classmethod</code>和<code class="fe nd ne nf ng b">@staticmethod</code>装饰器用于定义一个类名称空间内的方法，该方法不与该类的特定实例相关联。<code class="fe nd ne nf ng b">@property</code>装饰器用于为类属性定制getters和setters。展开下面的方框，看一个使用这些装饰器的例子。你可以在这里了解更多关于内置装饰器<a class="ae ky" href="https://docs.python.org/3/library/functions.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="6dab" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">让我们看一个例子。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="8d60" class="nl la it ng b gy nm nn l no np">class Circle:<br/>    def __init__(self, radius):<br/>        self._radius = radius<br/><br/>    @property<br/>    def radius(self):<br/>        """Get value of radius"""<br/>        return self._radius<br/><br/>    @radius.setter<br/>    def radius(self, value):<br/>        """Set radius, raise error if negative"""<br/>        if value &gt;= 0:<br/>            self._radius = value<br/>        else:<br/>            raise ValueError("Radius must be positive")<br/><br/>    @property<br/>    def area(self):<br/>        """Calculate area inside circle"""<br/>        return self.pi() * self.radius**2<br/><br/>    def cylinder_volume(self, height):<br/>        """Calculate volume of cylinder with circle as base"""<br/>        return self.area * height<br/><br/>    @classmethod<br/>    def unit_circle(cls):<br/>        """Factory method creating a circle with radius 1"""<br/>        return cls(1)<br/><br/>    @staticmethod<br/>    def pi():<br/>        """Value of π, could use math.pi instead though"""<br/>        return 3.1415926535</span></pre><p id="78bf" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">在本课程中:</p><ul class=""><li id="5ef2" class="mn mo it lt b lu mp lx mq ma mr me ms mi mt mm mu mv mw mx bi translated"><code class="fe nd ne nf ng b">.cylinder_volume()</code>是常规方法。</li><li id="07e9" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><code class="fe nd ne nf ng b">.radius</code>是一个可变属性:它可以被设置为不同的值。然而，通过定义setter方法，我们可以进行一些错误测试，以确保它没有被设置为无意义的负数。属性作为不带括号的属性来访问。</li><li id="9a68" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><code class="fe nd ne nf ng b">.area</code>是一个不可变的属性:没有<code class="fe nd ne nf ng b">.setter()</code>方法的属性不能被改变。即使它被定义为一个方法，它也可以作为一个没有括号的属性被检索。</li><li id="2f89" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><code class="fe nd ne nf ng b">.unit_circle()</code>是类方法。它并不局限于<code class="fe nd ne nf ng b">Circle</code>的一个特定实例。类方法通常用作工厂方法，可以创建类的特定实例。</li><li id="1827" class="mn mo it lt b lu my lx mz ma na me nb mi nc mm mu mv mw mx bi translated"><code class="fe nd ne nf ng b">.pi()</code>是静态方法。它并不真正依赖于<code class="fe nd ne nf ng b">Circle</code>类，除了它是其名称空间的一部分。静态方法可以在实例或类上调用。</li></ul><p id="127e" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">在控制台中测试:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="84c3" class="nl la it ng b gy nm nn l no np">&gt;&gt;&gt; c = Circle(5)<br/>&gt;&gt;&gt; c.radius<br/>5<br/><br/>&gt;&gt;&gt; c.area<br/>78.5398163375<br/><br/>&gt;&gt;&gt; c.radius = 2<br/>&gt;&gt;&gt; c.area<br/>12.566370614<br/><br/>&gt;&gt;&gt; c.area = 100<br/>AttributeError: can't set attribute<br/><br/>&gt;&gt;&gt; c.cylinder_volume(height=4)<br/>50.265482456<br/><br/>&gt;&gt;&gt; c.radius = -1<br/>ValueError: Radius must be positive<br/><br/>&gt;&gt;&gt; c = Circle.unit_circle()<br/>&gt;&gt;&gt; c.radius<br/>1<br/><br/>&gt;&gt;&gt; c.pi()<br/>3.1415926535<br/><br/>&gt;&gt;&gt; Circle.pi()<br/>3.1415926535</span></pre><h2 id="4799" class="nl la it bd lb of og dn lf oh oi dp lj ma oj ok ll me ol om ln mi on oo lp op bi translated">装饰类方法</h2><p id="f244" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里我们使用一个先前创建的<code class="fe nd ne nf ng b">timer</code>装饰器。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="2a0b" class="nl la it ng b gy nm nn l no np">class Calculator:<br/><br/>    def __init__(self, num):<br/>        self.num = num<br/><br/>    @timer<br/>    def doubled_and_add(self):<br/>        res = sum([i * 2 for i in range(self.num)])<br/>        print("Result : {}".format(res))<br/><br/>c = Calculator(10000)<br/>c.doubled_and_add()</span></pre><p id="b9a8" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="3fc6" class="nl la it ng b gy nm nn l no np">Result : 99990000<br/>Finished 'doubled_and_add' in 0.001 secs</span></pre><h2 id="5fc3" class="nl la it bd lb of og dn lf oh oi dp lj ma oj ok ll me ol om ln mi on oo lp op bi translated">装饰一个班级</h2><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="58b6" class="nl la it ng b gy nm nn l no np">@timer<br/>class Calculator:<br/><br/>    def __init__(self, num):<br/>        self.num = num<br/>        import time<br/>        time.sleep(2)<br/><br/>    def doubled_and_add(self):<br/>        res = sum([i * 2 for i in range(self.num)])<br/>        print("Result : {}".format(res))<br/><br/>c = Calculator(100)</span></pre><p id="1332" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="8f41" class="nl la it ng b gy nm nn l no np">Finished 'Calculator' in 2.001 secs</span></pre><p id="d8b8" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">装饰一个类并不装饰它的方法。这里，<code class="fe nd ne nf ng b">@timer</code>只度量实例化类所花费的时间。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="9e9c" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">嵌套装饰器</h1><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="60e6" class="nl la it ng b gy nm nn l no np">def hello(func):<br/>    def wrapper():<br/>        print("Hello")<br/>        func()<br/>    return wrapper<br/><br/>def welcome(func):<br/><br/>    def wrapper():<br/>        print("Welcome")<br/>        func()<br/>    return wrapper<br/><br/>@hello<br/>@welcome<br/>def say():<br/>    print("Greeting Dome")<br/><br/>say()</span></pre><p id="5720" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="c836" class="nl la it ng b gy nm nn l no np">Hello<br/>Welcome<br/>Greeting Dome</span></pre><p id="ac30" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">可以把这想象成装饰者按照它们被列出的顺序被执行。换句话说，<code class="fe nd ne nf ng b">@hello</code>调用<code class="fe nd ne nf ng b">@welcome</code>，后者调用<code class="fe nd ne nf ng b">say()</code>。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="f502" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">有争论的装饰者</h1><p id="947f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这里<code class="fe nd ne nf ng b">repeat</code>处理装饰器的参数。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="1353" class="nl la it ng b gy nm nn l no np">def repeat(*args_, **kwargs_):<br/><br/>    def inner_function(func):<br/><br/>        @functools.wraps(func)<br/>        def wrapper(*args, **kwargs):<br/>            for _ in range(args_[0]):<br/>                func(*args, **kwargs)</span><span id="37f9" class="nl la it ng b gy oq nn l no np">        return wrapper<br/><br/>    return inner_function<br/><br/><br/>@repeat(4)<br/>def say(name):<br/>    print(f"Hello {name}")<br/><br/>say("World")</span></pre><p id="ef6f" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="63b9" class="nl la it ng b gy nm nn l no np">Hello World<br/>Hello World<br/>Hello World<br/>Hello World</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="5cd9" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">有状态装饰器</h1><p id="6bb1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们可以使用装饰器来跟踪状态。作为一个简单的例子，我们将创建一个装饰器来计算一个函数被调用的次数。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="f467" class="nl la it ng b gy nm nn l no np">def count_calls(func):<br/><br/>    @functools.wraps(func)<br/>    def wrapper(*args, **kwargs):<br/>        wrapper.num_calls += 1<br/>        print(f"Call {wrapper.num_calls} of {func.__name__!r}")<br/>        return func(*args, **kwargs)<br/><br/>    wrapper.num_calls = 0<br/>    return wrapper<br/><br/><br/>@count_calls<br/>def say():<br/>    print("Hello!")<br/><br/>say()<br/>say()<br/>say()<br/>say()<br/>print(say.num_calls)</span></pre><p id="00ca" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="e225" class="nl la it ng b gy nm nn l no np">Call 1 of 'say'<br/>Hello!<br/>Call 2 of 'say'<br/>Hello!<br/>Call 3 of 'say'<br/>Hello!<br/>Call 4 of 'say'<br/>Hello!<br/>4</span></pre><p id="d777" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">对函数的调用次数存储在<code class="fe nd ne nf ng b">wrapper</code>函数的函数属性<code class="fe nd ne nf ng b">num_calls</code>中。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="7fd7" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">作为装饰者的类</h1><p id="0ef3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">维护状态的最好方法是使用类。如果我们想使用class作为装饰器，它需要将<code class="fe nd ne nf ng b">func</code>作为其<code class="fe nd ne nf ng b">.__init__()</code>方法中的一个参数。此外，这个类需要是<a class="ae ky" href="https://docs.python.org/reference/datamodel.html#emulating-callable-objects" rel="noopener ugc nofollow" target="_blank">可调用的</a>，这样它就可以代替修饰函数。对于一个可调用的类，你实现特殊的<code class="fe nd ne nf ng b">.__call__()</code>方法。</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="0003" class="nl la it ng b gy nm nn l no np">class CountCalls:<br/>    def __init__(self, func):<br/>        functools.update_wrapper(self, func)<br/>        self.func = func<br/>        self.num_calls = 0<br/><br/>    def __call__(self, *args, **kwargs):<br/>        self.num_calls += 1<br/>        print(f"Call {self.num_calls} of {self.func.__name__!r}")<br/>        return self.func(*args, **kwargs)<br/><br/><br/>@CountCalls<br/>def say():<br/>    print("Hello!")<br/><br/>say()<br/>say()<br/>say()<br/>say()<br/>print(say.num_calls)</span></pre><p id="a46c" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="7377" class="nl la it ng b gy nm nn l no np">Call 1 of 'say'<br/>Hello!<br/>Call 2 of 'say'<br/>Hello!<br/>Call 3 of 'say'<br/>Hello!<br/>Call 4 of 'say'<br/>Hello!<br/>4</span></pre></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="9c4a" class="kz la it bd lb lc oa le lf lg ob li lj jz oc ka ll kc od kd ln kf oe kg lp lq bi translated">带有参数的基于类的装饰器</h1><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="20cb" class="nl la it ng b gy nm nn l no np">class ClassDecorator(object):<br/><br/>    def __init__(self, arg1, arg2):<br/>        print("Arguements of decorator %s, %s" % (arg1, arg2))<br/>        self.arg1 = arg1<br/>        self.arg2 = arg2<br/><br/>    def __call__(self, func):<br/>        functools.update_wrapper(self, func)<br/><br/>        def wrapper(*args, **kwargs):<br/>            return func(*args, **kwargs)<br/>        return wrapper<br/><br/>@ClassDecorator("arg1", "arg2")<br/>def print_args(*args):<br/>    for arg in args:<br/>        print(arg)<br/><br/>print_args(1, 2, 3)</span></pre><p id="2028" class="pw-post-body-paragraph lr ls it lt b lu mp ju lw lx mq jx lz ma nq mc md me nr mg mh mi ns mk ml mm im bi translated">输出:</p><pre class="kj kk kl km gt nh ng ni nj aw nk bi"><span id="df39" class="nl la it ng b gy nm nn l no np">Arguements of decorator arg1, arg2<br/>1<br/>2<br/>3</span></pre></div></div>    
</body>
</html>