<html>
<head>
<title>Securing Kubernetes With GVisor and GKE Sandbox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用GVisor和GKE沙盒保护Kubernetes</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/securing-kubernetes-with-gvisor-and-gke-sandbox-78c6b152b3a0?source=collection_archive---------9-----------------------#2021-09-28">https://betterprogramming.pub/securing-kubernetes-with-gvisor-and-gke-sandbox-78c6b152b3a0?source=collection_archive---------9-----------------------#2021-09-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d93" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">针对容器运行时和工作负载的深度防御</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7688e15fc5bf9443913fc90ed29761ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NP8TqFQgj0Rsh4Zs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@ihor_dvoretskyi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伊霍尔·德沃雷茨基</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="e0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes和容器运行时安全性是您应该为您的Kubernetes集群考虑的最重要的安全性方面之一。容器确保了您的应用程序封装在它们自己的虚拟环境中，并且独立于其他应用程序。然而，使用Kubernetes集群的默认设置，您仍然可以从容器中访问大量内核资源，包括进行系统API调用。</p><p id="3449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是网络犯罪分子利用来进入您的系统并实施恶意行为的一个方面，会危及您的许多应用程序和关键数据。</p><p id="475e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">gVisor 是一个容器运行时安全工具，允许你在自己的沙盒应用内核中运行你的容器。这意味着您的容器在集群中作为单独的虚拟机运行，尽管仍然与其他容器共享计算资源，如CPU、内存和磁盘。大家双赢！</p><p id="7230" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Google Kubernetes引擎在节点池上提供了GKE <a class="ae ky" href="https://cloud.google.com/kubernetes-engine/docs/concepts/sandbox-pods" rel="noopener ugc nofollow" target="_blank">沙盒</a>模式，您可以使用该模式在您的托管Kubernetes集群中实现gVisor，无需任何自定义设置，而您可能必须在自管理集群中进行设置。</p><p id="72a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将看看如何在GKE沙盒中运行容器，并做一些测试来演示安全性。因此，让我们从创建GKE集群开始。</p><h1 id="3c2d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">先决条件</h1><p id="2f10" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">由于练习使用谷歌Kubernetes引擎(GKE)集群，您将需要一个GCP帐户。GCP提供三个月的免费试用，所以如果你还没有注册，你可以注册。</p><h1 id="fc30" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建GKE集群</h1><p id="5bf5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">首先，我们将使用以下命令创建一个GKE集群:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5265" class="mx lw it mt b gy my mz l na nb">$ gcloud container clusters create cluster-1 --zone us-central1-a</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/2820fa53d003733bb1b5f05cb3026919.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8PodmY8ETn3PdqRQ.gif"/></div></div></figure><p id="870b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这需要几分钟的时间，您应该已经启动并运行了GKE集群。现在，我们需要创建另一个启用了gVisor的节点池，因为GKE的默认节点池不提供该选项。</p><h1 id="40f0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">创建gVisor节点池</h1><p id="ce1d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要创建gVisor节点池，我们将使用以下命令:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="c4bf" class="mx lw it mt b gy my mz l na nb">gcloud container node-pools create gvisor-np \<br/>  --cluster=cluster-1 \<br/>  --node-version=latest \<br/>  --machine-type=n1-standard-2 \<br/>  --image-type=cos_containerd \<br/>  --sandbox type=gvisor<!-- --> \<br/>  --zone us-central1-a</span></pre><p id="33a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，e2微、e2小和e2中节点池不支持gVisor。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/a172d879a9c9b587eb723c773222e907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*guNJcF-Z7JEjFfswQHLhfQ.gif"/></div></div></figure><p id="22cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦创建了新的节点池，我们只需要检查节点池是否启用了gVisor。为此，请运行以下命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/988d390b6dbf14ae2a051768355baec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*RfhAeytWya3l4ahAVI7K4A.gif"/></div></div></figure><p id="b87f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，正如<code class="fe ne nf ng mt b">runtimeclass</code>显示的<code class="fe ne nf ng mt b">gvisor</code>，这意味着新节点池启用了gVisor。</p><p id="dde0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经准备好测试配置了</p><h1 id="430c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">测试配置</h1><p id="142a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了测试配置，我们将使用<code class="fe ne nf ng mt b">gvisor</code>节点池中的<code class="fe ne nf ng mt b">Deployment</code>资源部署一个<code class="fe ne nf ng mt b">fedora</code>容器，并使用<code class="fe ne nf ng mt b">curl</code>命令获取集群元数据。由于沙盒环境不应该访问父内核，它应该不知道集群，因此这个调用应该会失败。</p><p id="fc04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保将<code class="fe ne nf ng mt b">Pod</code>部署到启用了gVisor的节点，我们必须将<code class="fe ne nf ng mt b">spec.template.spec.runtimeClassName</code>设置为<code class="fe ne nf ng mt b">gvisor</code>，如下面的部署清单所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="92c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们使用下面的命令来应用这个yaml:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e73a" class="mx lw it mt b gy my mz l na nb">$ kubectl apply -f fedora.yaml</span></pre><p id="a2a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Pod运行后，我们将使用<code class="fe ne nf ng mt b">kubectl exec -it &lt;pod_name&gt; -- bash</code>打开一个shell并运行以下命令:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="239b" class="mx lw it mt b gy my mz l na nb">$ curl -s "http://metadata.google.internal/computeMetadata/v1/instance/attributes/kube-env" -H "Metadata-Flavor: Google"</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/bbd76879ebb613ea9e0d9d28844af5a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4GZ3vTzLgDexfS413LxsXA.gif"/></div></div></figure><p id="2f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，当我们到达终点时，我们没有得到任何输出。这是因为gVisor正在无声地丢弃数据包，而<code class="fe ne nf ng mt b">Pod</code>无法访问<code class="fe ne nf ng mt b">metadata.google.internal</code>端点。</p><p id="b830" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，为了证明这是因为gVisor，让我们看看当我们使用没有将<code class="fe ne nf ng mt b">RuntimeClassName</code>设置为<code class="fe ne nf ng mt b">gvisor</code>的<code class="fe ne nf ng mt b">Deployment</code>时会发生什么，如下面的清单所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="b888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们使用下面的命令来应用这个清单，并运行相同的<code class="fe ne nf ng mt b">curl</code>命令来看看我们得到了什么:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="199a" class="mx lw it mt b gy my mz l na nb">$ kubectl apply -f fedora-norc.yaml</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/36caf4bb3807d638d967968ed65602fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*9E9D3bmPYtGMgqGjza832g.gif"/></div></div></figure><p id="cf02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们看到的，这一次，我们获得集群元数据以响应<code class="fe ne nf ng mt b">curl</code>命令。这意味着gVisor在保护集群免受恶意外来者攻击方面做了自己的工作。就<code class="fe ne nf ng mt b">Pod</code>而言，它没有对Kubernetes环境的访问权，因此，只需很少的修改，您的集群和容器运行时就是安全的。</p><h1 id="5c01" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="aae2" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">gVisor帮助我们为容器工作负载实施深度防御，并保护容器运行时免受恶意攻击。如果我们仍然碰巧看到对特定<code class="fe ne nf ng mt b">Pod</code>的攻击，它将仅限于该特定的<code class="fe ne nf ng mt b">Pod</code>，并且攻击者将无法访问任何集群级资源。</p><p id="ed1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>