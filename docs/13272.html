<html>
<head>
<title>Exploring SwiftUI Layout Protocol — Creating Custom Layout</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索SwiftUI布局协议—创建自定义布局</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-swiftui-layout-protocol-creating-custom-layout-7562be989a60?source=collection_archive---------6-----------------------#2022-08-12">https://betterprogramming.pub/exploring-swiftui-layout-protocol-creating-custom-layout-7562be989a60?source=collection_archive---------6-----------------------#2022-08-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9e13" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">苹果随着iOS 16的发布引入了新SwiftUI的布局协议。在这篇文章中，我将讨论该协议并实现一个自定义视图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2476f24758524558dd06e980d56c26b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hyKoJSvZDJFWHCTgluwRHQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/composing_custom_layouts_with_swiftui" rel="noopener ugc nofollow" target="_blank">用SwiftUI编写自定义布局</a></p></figure><p id="6b5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">苹果随着iOS 16的发布引入了新的SwiftUI <code class="fe ls lt lu lv b">Layout</code>协议。它是一个强大的工具，用于构造SwiftUI优雅的定制视图。在这篇文章中，我将介绍什么是<code class="fe ls lt lu lv b">Layout</code>以及如何使用它。</p><p id="a655" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将构建一个定制的表格视图，自动排列其子视图。提供了完整的代码！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/5403d3792ac7d12011d2b38e723109b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEInwS1iGwZnAETv2wtANA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们的自定义布局</p></figure><h1 id="046b" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">符合布局</h1><p id="95d1" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">讨论的<code class="fe ls lt lu lv b">Layout</code>是一个新的协议，允许你选择一种方式来排列你的视图。</p><p id="e289" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过它，你真的可以说出你想在哪个坐标上放置子视图。比如现在的<code class="fe ls lt lu lv b">HStack</code>、<code class="fe ls lt lu lv b">VStack</code>、<code class="fe ls lt lu lv b">ZStack</code>都可以在iOS 16中通过它轻松实现。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="ec2a" class="my ly iq lv b gy mz na l nb nc">protocol Layout : Animatable</span></pre><p id="fd91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了符合协议，您需要定义两个方法</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="450f" class="my ly iq lv b gy mz na l nb nc">func sizeThatFits(<br/>    proposal: ProposedViewSize,<br/>    subviews: Self.Subviews,<br/>    cache: inout Self.Cache<br/>) -&gt; CGSize<br/><br/><br/>func placeSubviews(<br/>    in bounds: CGRect,<br/>    proposal: ProposedViewSize,<br/>    subviews: Self.Subviews,<br/>    cache: inout Self.Cache<br/>)</span></pre><p id="0064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你的布局有一些计算不依赖于建议而只依赖于子视图，你也可以定义<code class="fe ls lt lu lv b">makeCache(subviews:)</code>。然后，您可以在<code class="fe ls lt lu lv b">makeCache(subviews:)</code>中进行计算，然后使用这些值。</p><h1 id="70af" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">方法<code class="fe ls lt lu lv b">sizeThatFits</code></h1><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="7acb" class="my ly iq lv b gy mz na l nb nc">func sizeThatFits(<br/>    proposal: ProposedViewSize,<br/>    subviews: Self.Subviews,<br/>    cache: inout Self.Cache<br/>) -&gt; CGSize</span></pre><p id="76de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">返回一个大小，指示容器需要多少空间来排列其子视图。SwiftUI可以多次调用这个方法，探测您的视图并最终决定最佳选项</p><blockquote class="nd ne nf"><p id="2b6b" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">💥只能返回有限的大小。使用无限坐标<strong class="ky ir">返回大小会导致没有合理的调用堆栈</strong>的崩溃，所以请注意您返回的大小</p></blockquote><p id="c4bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要计算它，您可以使用传递的参数:</p><h2 id="229e" class="my ly iq bd lz nk nl dn md nm nn dp mh lf no np mj lj nq nr ml ln ns nt mn nu bi translated">建议</h2><p id="ea56" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">基本上，这是SwiftUI对您的视图大小的建议。我喜欢把它想成谈判。</p><blockquote class="nd ne nf"><p id="5aca" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">我可以给你这么大的空间。你的尺码是多少？你穿得下吗？<br/><br/>——swift ui谈判代表</p></blockquote><p id="51c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ProposedViewSize</code>就像<code class="fe ls lt lu lv b">CGSize</code>一样，也可以有一些特定的值。</p><ul class=""><li id="2d14" class="nv nw iq ky b kz la lc ld lf nx lj ny ln nz lr oa ob oc od bi translated"><code class="fe ls lt lu lv b">zero</code>提案；视图以其最小尺寸响应。</li><li id="5c3a" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated"><code class="fe ls lt lu lv b">infinity</code>提案；视图以其最大尺寸响应。</li><li id="81fc" class="nv nw iq ky b kz oe lc of lf og lj oh ln oi lr oa ob oc od bi translated"><code class="fe ls lt lu lv b">unspecified</code>提案；视图以理想的大小响应。</li></ul><p id="af9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不是上述值，您也可以访问建议书的<code class="fe ls lt lu lv b">width</code>和<code class="fe ls lt lu lv b">height</code>。</p><p id="0037" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">建议可以有一个固定的维度，第二个维度为<code class="fe ls lt lu lv b">nil</code>。例如，<code class="fe ls lt lu lv b">HStack</code>可能测量它的子视图宽度的灵活性，同时使用一个固定的高度值。</p><h2 id="d025" class="my ly iq bd lz nk nl dn md nm nn dp mh lf no np mj lj nq nr ml ln ns nt mn nu bi translated">子视图</h2><p id="2cc7" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">它只是一个子视图代理<code class="fe ls lt lu lv b">LayoutSubview</code>的容器。通过它，你可以询问子视图的大小，并给他们你的建议</p><blockquote class="nd ne nf"><p id="aaaa" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">亲爱的子视图，我给你这么多空间。你的尺码是多少？<br/> <br/> —自定义布局协商器</p></blockquote><p id="9baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过以下方式询问子视图尺寸</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="9603" class="my ly iq lv b gy mz na l nb nc">func sizeThatFits(ProposedViewSize) -&gt; CGSize</span></pre><p id="702d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="27a8" class="my ly iq lv b gy mz na l nb nc">func dimensions(in: ProposedViewSize) -&gt; ViewDimensions</span></pre><h2 id="3d1b" class="my ly iq bd lz nk nl dn md nm nn dp mh lf no np mj lj nq nr ml ln ns nt mn nu bi translated">隐藏物</h2><p id="a6a7" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">是你的<code class="fe ls lt lu lv b">makeCache(subviews:)</code>函数提供的缓存。也可以是<code class="fe ls lt lu lv b">Void</code>(无缓存)。</p><h1 id="d84e" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">方法<code class="fe ls lt lu lv b">placeSubviews</code></h1><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="3b02" class="my ly iq lv b gy mz na l nb nc">func placeSubviews(<br/>    in bounds: CGRect,<br/>    proposal: ProposedViewSize,<br/>    subviews: Self.Subviews,<br/>    cache: inout Self.Cache<br/>)</span></pre><p id="1433" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是奇迹发生的地方。在这种方法中(也只有这种方法),给你视图和子视图的界限，供你使用。</p><p id="9785" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要放置子视图，您需要在<code class="fe ls lt lu lv b">subviews</code>元素上调用<code class="fe ls lt lu lv b">place</code>方法。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="3620" class="my ly iq lv b gy mz na l nb nc">func place(<br/>    at position: CGPoint,<br/>    anchor: UnitPoint = .topLeading,<br/>    proposal: ProposedViewSize<br/>)</span></pre><p id="1d7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个定义非常简单明了。对于每个子视图，你需要指定一个点来放置它，这个点的锚点，以及<strong class="ky ir">你对所选子视图的</strong>建议。</p><h2 id="8b8d" class="my ly iq bd lz nk nl dn md nm nn dp mh lf no np mj lj nq nr ml ln ns nt mn nu bi translated">界限</h2><p id="1d5a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">这是您的视图使用的界限。它是你的<code class="fe ls lt lu lv b">sizeThatFits</code>输出之一。</p><blockquote class="nd ne nf"><p id="a53c" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">💡虽然名为<code class="fe ls lt lu lv b">bounds</code>，但实际上是<code class="fe ls lt lu lv b">frame</code>。因此，原点也被指定<strong class="ky ir">并且你需要相对于那个</strong>排列子视图</p></blockquote><h2 id="8928" class="my ly iq bd lz nk nl dn md nm nn dp mh lf no np mj lj nq nr ml ln ns nt mn nu bi translated">建议</h2><p id="20f8" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">容器根据其生成父容器用来创建<code class="fe ls lt lu lv b">bounds</code>参数的大小的大小建议。</p><h1 id="12c6" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">关于缓存</h1><p id="651b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">您可能不使用它，但是通常，一些与子视图相关的计算可以被缓存，这是一个很好的实践，对性能有很大帮助。</p><p id="c140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当子视图改变时，调用<code class="fe ls lt lu lv b">func updateCache(inout Self.Cache, subviews: Self.Subviews)</code>。它的默认实现只是调用<code class="fe ls lt lu lv b">makeCache(subviews:)</code>。</p><h1 id="08e0" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">创建自动填充的表格</h1><p id="aab2" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">SwiftUI有一个<code class="fe ls lt lu lv b">Grid</code>来构造类似表格的结构，但是如果有未知数量的子视图呢？然后，您需要以某种方式正确地构造<code class="fe ls lt lu lv b">GridRow</code>。</p><p id="bb81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们更好地使用新的<code class="fe ls lt lu lv b">Layout</code>协议特性！</p><h2 id="e505" class="my ly iq bd lz nk nl dn md nm nn dp mh lf no np mj lj nq nr ml ln ns nt mn nu bi translated">计算大小</h2><p id="8210" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">决定结果视图的大小相对简单。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="da13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它使用了几个辅助函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h2 id="a115" class="my ly iq bd lz nk nl dn md nm nn dp mh lf no np mj lj nq nr ml ln ns nt mn nu bi translated">放置子视图</h2><p id="0a02" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">最后，我们只需要小心翼翼地将视图放置在它们的位置上。只是迭代子视图并计算它们的<code class="fe ls lt lu lv b">x</code>和<code class="fe ls lt lu lv b">y</code>位置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><h1 id="65f6" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">例子</h1><p id="ef1f" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">现在，我们可以像普通视图一样简单地构造一个包含所需列数的表。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/6aaa54a22c45ab848f922e0133b40bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*T3n18zVv7q8C4s66.png"/></div></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="730b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在将列数改为三列后，它会神奇地重新组装。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/34fd5b5ff9accc1692d3565deb44f81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3JRae4By3_nQb6kL.png"/></div></div></figure><h1 id="921a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">最终注释</h1><p id="aa42" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我相信你看到了这个工具有多强大。例如，<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/composing_custom_layouts_with_swiftui" rel="noopener ugc nofollow" target="_blank"> Apple使用<code class="fe ls lt lu lv b">Layout</code>协议在他们的示例</a>中创建了一个径向视图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/a7e54d1c646ef30a3ba5e96eaf965b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nQ0Ys8pN_AKwMTrJ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来自<a class="ae kv" href="https://developer.apple.com/documentation/swiftui/composing_custom_layouts_with_swiftui" rel="noopener ugc nofollow" target="_blank">用SwiftUI编写自定义布局</a></p></figure><p id="5b3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如何在容器中放置视图取决于你，这最终是iOS 16中SwiftUI所需要的灵活性空间。</p><p id="20b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以从<a class="ae kv" href="https://alexdremov.me/content/files/2022/08/ColumnsLayout.swift" rel="noopener ugc nofollow" target="_blank">这里</a>下载完整的代码。</p><pre class="kg kh ki kj gt mu lv mv mw aw mx bi"><span id="5e75" class="my ly iq lv b gy mz na l nb nc"><strong class="lv ir">Want to Connect?</strong></span><span id="4f24" class="my ly iq lv b gy oo na l nb nc">This post was originally published on <a class="ae kv" href="https://alexdremov.me/exploring-swiftui-layout-protocol-creating-custom-layout/" rel="noopener ugc nofollow" target="_blank">www.alexdremov.me</a>.</span></pre></div></div>    
</body>
</html>