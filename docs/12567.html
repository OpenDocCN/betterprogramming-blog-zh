<html>
<head>
<title>Go and SQL: Pitfalls With Existing Libraries (and a Better Solution)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go和SQL:现有库的缺陷(以及更好的解决方案)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/golang-sql-problems-with-existing-libraries-145a037261b8?source=collection_archive---------6-----------------------#2022-06-14">https://betterprogramming.pub/golang-sql-problems-with-existing-libraries-145a037261b8?source=collection_archive---------6-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d1be" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">见见KSQL——我为解决Golang和SQL问题而编写的库</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3e1a5029ccad97bf79e1bc82f0931f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kLCBa1lCP9AH2q6X"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@geekgunda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Chinmay Bhattar </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="238c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我使用Golang的这些年中，我得出的结论是，使用SQL还不是一个很好解决的问题。我们可用的库只是不容易使用，并且有太多的方式搬起石头砸自己的脚。</p><p id="368a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了说明这一点，我将在本文中详细描述所有这些问题，然后简要介绍我提出的解决这些问题的解决方案:我编写的名为<code class="fe ls lt lu lv b"><a class="ae kv" href="https://github.com/VinGarcia/ksql" rel="noopener ugc nofollow" target="_blank">KSQL</a></code>的库。</p><p id="e6cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的章节中，我们将讨论Golang生态系统中三个被广泛采用的库:</p><ul class=""><li id="71dc" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">标准库:<code class="fe ls lt lu lv b">database/sql</code></li><li id="8c50" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">一个标准库的包装器，增加了一些很酷的特性，比如结构扫描:<code class="fe ls lt lu lv b">sqlx</code></li><li id="5045" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">Postgres的专用驱动程序，比其他驱动程序更快，可以与<code class="fe ls lt lu lv b">database/sql</code>或<code class="fe ls lt lu lv b">sqlx</code> : <code class="fe ls lt lu lv b">pgx</code>一起使用</li></ul><h1 id="1c76" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题1:为单个查询检查错误4次</h1><p id="3fa9" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">当编写从数据库中读取多行的查询时，这个问题最明显。</p><p id="51d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做时，我们实际上必须使用<code class="fe ls lt lu lv b">database/sql</code>或<code class="fe ls lt lu lv b">sqlx</code>测试4次错误，使用<code class="fe ls lt lu lv b">pgx</code>测试3次错误。</p><p id="ff15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可怕的是，大多数人甚至不知道这一点，通常只测试对<code class="fe ls lt lu lv b">Query()</code>的调用是否成功，以及对<code class="fe ls lt lu lv b">.Scan()</code>的每个调用是否成功。</p><p id="6454" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们真的检查所有这些错误，我们的代码最终会是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><blockquote class="nj nk nl"><p id="3b22" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">注意，当使用pgx时，<code class="fe ls lt lu lv b">.Close()</code>函数实际上并不返回错误，所以您必须测试它3次，而不是4次。</p></blockquote><p id="83ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你曾经使用过这些库中的任何一个，我敢打赌你不会测试所有这4个错误，而且通常都没问题。</p><p id="46eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我仍然希望库不要强迫我们在非常冗长的错误检查和忽略很少发生的错误之间做出决定。</p><h1 id="4c96" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题2:忘记打电话<code class="fe ls lt lu lv b">defer rows.Close()</code></h1><p id="f952" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">所以如上面的例子所示，我们必须调用<code class="fe ls lt lu lv b">defer rows.Close()</code>。如果我们不调用它，我们会以一个非常严重的错误结束，我们的连接将永远不会被释放，使得我们的代码在执行一段时间后最终停止，没有错误消息。</p><p id="2066" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更糟糕的是，如果您在整个系统中的单个查询上这样做，它仍然可能通过您所有的集成测试，甚至您的代码审查，因为不太容易发现丢失的行，这可能会导致生产中的问题。</p><h1 id="0c0a" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题3:调用延迟行。在错误的时间关闭()</h1><p id="8a47" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">即使你永远不会忘记调用<code class="fe ls lt lu lv b">rows.Close()</code>,仍然有另一个问题很容易在代码审查和集成测试中被忽视。下面的代码示例说明了这个问题:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e69e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最后一个例子中，许多读者可能没有发现这个问题，如果你发现了，我敢打赌你团队中的某个人可能没有发现。</p><p id="9678" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行此代码，它将在大多数情况下在生产中工作，但有时会死机。换句话说，这是最难调试的问题之一:它只是偶尔发生。那边发生了什么事？</p><p id="25b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题出在我们调用<code class="fe ls lt lu lv b">rows.Close()</code>的地方，即在检查错误之前，而不是之后，所以如果对<code class="fe ls lt lu lv b">db.Query(...)</code>的调用返回一个错误，那么<code class="fe ls lt lu lv b">rows</code>变量将是<code class="fe ls lt lu lv b">nil</code>，这意味着对<code class="fe ls lt lu lv b">defer rows.Close()</code>的调用将试图调用一个关于<code class="fe ls lt lu lv b">nil</code>值的方法，当延迟被执行时，它将在函数结束时死机。</p><p id="e39c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，使这个问题特别令人担忧的是，它可以轻易地通过代码审查和许多类型的集成测试。</p><h1 id="f5b1" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">问题4:大结构的代码重复</h1><p id="688a" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">这可能是一个非常熟悉的情况:我们有一个struct，比如说一个<code class="fe ls lt lu lv b">User</code> struct，我们需要在查询中列出这个struct的所有属性，并且在每次我们做任何读取用户的查询时都要在传递给<code class="fe ls lt lu lv b">.Scan()</code>的参数中列出。</p><p id="a0cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了说明这一点，假设这些查询之一如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="c065" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个小例子中，情况看起来还不算太糟，但是如果你的结构有超过50个属性，情况就会变得非常糟糕。更糟糕的是，如果我们让5到7个查询扫描每个结构。</p><p id="4187" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望我能够描绘出这个问题在大型代码库中会变得多么糟糕。</p><blockquote class="nj nk nl"><p id="ea3d" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">但是在继续之前:重要的是要提到，当使用<code class="fe ls lt lu lv b">sqlx</code>时，你并不被迫使用<code class="fe ls lt lu lv b">.Scan()</code>函数，你可以使用<code class="fe ls lt lu lv b">.StructScan()</code>函数来代替，所以这个例子将会改进50%。</p><p id="8d80" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">还有一个很棒的库也有一个叫做<a class="ae kv" href="https://github.com/georgysavva/scany" rel="noopener ugc nofollow" target="_blank"> Scany </a>的<code class="fe ls lt lu lv b">StructScan()</code>特性。它可以用在<code class="fe ls lt lu lv b">database/sql</code>和<code class="fe ls lt lu lv b">pgx</code>之上，用<code class="fe ls lt lu lv b">StructScan()</code>特性扩展这两个库。</p><p id="6902" class="kw kx nm ky b kz la jr lb lc ld ju le nn lg lh li no lk ll lm np lo lp lq lr ij bi translated">但还是。这两种解决方案仍然需要您在每个查询中列出结构的所有属性名称，因此您并没有真正消除所有的代码重复。</p></blockquote><p id="e589" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果上面提到的解决方案都不使用，那么这个问题的主要后果是:</p><ol class=""><li id="405a" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated">查询的<code class="fe ls lt lu lv b">SELECT</code>部分的属性顺序和传递给<code class="fe ls lt lu lv b">.Scan()</code>的属性顺序之间存在非常紧密的耦合。因为如果这两个列表的顺序不匹配，您可能会得到意外的扫描错误或更糟的情况:一个无声的错误，您加载了不正确的值的变量，但程序继续运行。这是一个特别糟糕的问题，因为它很容易逃过代码审查过程，所以建议总是进行集成测试。</li><li id="d66b" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">从结构中添加或删除属性可能会迫使您在所有查询中更新所有这些值，由于上面提到的排序问题，这是一个微妙的操作。</li><li id="5f3c" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">还有一个可读性的小问题:当您试图在代码中找到特定的逻辑片段时，包含琐碎信息的大块代码没有帮助。</li></ol><h1 id="823f" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">那么有没有可能有一个更好的SQL库呢？</h1><p id="0456" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">是的，它是。我写了这个非常酷的库，叫做<a class="ae kv" href="http://github.com/VinGarcia/ksql" rel="noopener ugc nofollow" target="_blank"> KSQL </a>。我相信它对上述问题有很好的解决方案。</p><p id="4fc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为解释原因和KSQL的所有特性不是这篇文章的目的，所以我会尽量简短，只举一个例子来说明KSQL是如何使处理这些问题变得更容易，并且不会增加太多的复杂性。</p><p id="620f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的简单示例将查询一个结构片中的几个值，它将使用struct标记来:</p><ol class=""><li id="71fe" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated">为您创建查询的<code class="fe ls lt lu lv b">SELECT</code>部分(不要担心，这是一个可选特性，它被缓存起来，因此非常高效，<a class="ae kv" href="https://github.com/VinGarcia/ksql#benchmark-comparison" rel="noopener ugc nofollow" target="_blank">参见我们的比较基准</a>)。</li><li id="b505" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">映射哪一列应该被扫描到结构的哪一个属性中(同样，反射部分只做一次并被缓存，所以效率很高，<a class="ae kv" href="https://github.com/VinGarcia/ksql#benchmark-comparison" rel="noopener ugc nofollow" target="_blank">参见我们的比较基准</a>)。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="3952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，现在你可能会看到，这已经比我们以前使用的任何其他库都要简单得多，但是让我们更详细地了解一下之前提到的每个问题:</p><h2 id="7f17" class="nr ml iq bd mm ns nt dn mq nu nv dp mu lf nw nx mw lj ny nz my ln oa ob na oc bi translated"><strong class="ak">问题1的解决方案:过多的错误处理</strong></h2><p id="0384" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">KSQL API的设计理念是在所有操作完成后才返回，这意味着它只返回一个错误，确保在内部检查所有可能的错误来源，包括对<code class="fe ls lt lu lv b">rows.Err()</code>、<code class="fe ls lt lu lv b">.Scan()</code>和<code class="fe ls lt lu lv b">.Close()</code>的调用。</p><h2 id="4c39" class="nr ml iq bd mm ns nt dn mq nu nv dp mu lf nw nx mw lj ny nz my ln oa ob na oc bi translated"><strong class="ak">问题2和问题3的解决方法:调用</strong>T3】</h2><p id="9735" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">没有必要给<code class="fe ls lt lu lv b">rows.Close()</code>打电话。</p><p id="3318" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正是因为函数只有在完成整个过程后才返回，所以我们可以在内部调用它，让用户不必处理这种额外的复杂性。</p><h2 id="1c84" class="nr ml iq bd mm ns nt dn mq nu nv dp mu lf nw nx mw lj ny nz my ln oa ob na oc bi translated"><strong class="ak">问题4的解决方案:属性名不必要的重复</strong></h2><p id="4cd7" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">为了消除名称重复的问题，KSQL有两个特性:</p><ol class=""><li id="c57d" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr nq mc md me bi translated">它将有选择地为您创建查询的<code class="fe ls lt lu lv b">SELECT</code>部分，只有当您的查询以<code class="fe ls lt lu lv b">FROM</code>开始时，才会触发此行为，因此，如果您想要在查询的<code class="fe ls lt lu lv b">SELECT</code>部分中使用更复杂的表达式，只需编写它，它就会像预期的那样工作。</li><li id="1bd4" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr nq mc md me bi translated">它会根据标记中的名称将查询中返回的任何列自动映射到您的结构中。</li></ol><p id="61fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你知道处理SQL有多复杂，你可能仍然会有所怀疑。</p><p id="cd56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们加载的用户超过了内存容量，会发生什么情况？</p><p id="b9c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，如果我们为了获得这些抽象而损失了大量的效率呢？</p><p id="3e8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">KSQL确实解决了这些问题，在我有一篇更详细地解释KSQL设计决策的文章之前，我邀请您阅读<a class="ae kv" href="https://github.com/VinGarcia/ksql#readme" rel="noopener ugc nofollow" target="_blank"> KSQL自述文件</a>。</p><h1 id="9e9b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结论</h1><p id="8d26" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">KSQL是一个新概念，所以对它的特性、效率、测试覆盖率和稳定性持怀疑态度是一件好事(并不是说我没有解决这些问题)，但它确实解决了一些我们在一些最常用的SQL Go库上看到的严重问题。</p><p id="4bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样值得注意的是，KSQL不是ORM，这些抽象保持简单和有限，正是为了避免常见的ORM陷阱，这只是对库如<code class="fe ls lt lu lv b">sqlx</code>和<code class="fe ls lt lu lv b">pgx</code>的明智替代，尽可能减少查询构建和效率损失。</p><p id="2d58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/VinGarcia/ksql#benchmark-comparison" rel="noopener ugc nofollow" target="_blank">我们的基准</a>中，很容易看到我们在实践中的表现与这些其他库相同，我的意思是基准值在每次运行时变化很大，所以很难精确，但我推测KSQL比Postgres上的<code class="fe ls lt lu lv b">pgx</code>和所有其他数据库上的<code class="fe ls lt lu lv b">sqlx</code>慢1%。</p></div></div>    
</body>
</html>