<html>
<head>
<title>Refactoring From Redux Thunk to Redux-Saga</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从Redux Thunk到Redux-Saga的重构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/refactoring-from-redux-thunk-to-redux-saga-f9379a172a99?source=collection_archive---------11-----------------------#2021-01-06">https://betterprogramming.pub/refactoring-from-redux-thunk-to-redux-saga-f9379a172a99?source=collection_archive---------11-----------------------#2021-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0d89" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高JavaScript应用程序的可伸缩性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/892dc11bbdf1d4f943c4d8f456fc62c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ppiHMoVTzehgjyVD68wfVA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>。</p></figure><p id="de45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">许多正在阅读这篇文章的人可能都有过使用<a class="ae ky" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank"> Redux Thunk </a>的经历，知道它能做什么，也许正在考虑换成<a class="ae ky" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>。</p><p id="693e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了快速复习，让我们查阅一下Redux Thunk的文档:</p><blockquote class="lv lw lx"><p id="298a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“对于普通的基本Redux存储，您只能通过分派动作来进行简单的同步更新。中间件扩展了商店的功能，并允许您编写与商店交互的异步逻辑。</p><p id="4726" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">Redux Thunk中间件允许您编写返回函数而不是动作的动作创建器。thunk可用于延迟动作的调度，或者仅在满足特定条件时才进行调度。"</p></blockquote><p id="cdc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，所以Redux Thunk工作良好。那我们为什么要选择佐贺呢？和任何决定一样，每个决定都有利弊。我认为你选择Thunk而不是Saga的主要原因是为了快速和简单的项目，因为设置Thunk要容易得多。除此之外，佐贺几乎总是要走的路。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="5b61" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">为什么是Redux-Saga？</h1><blockquote class="lv lw lx"><p id="bf27" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">“Redux-Saga是一个库，旨在使应用程序副作用(即数据获取等异步操作和访问浏览器缓存等不纯操作)更易于管理、更高效地执行、更易于测试以及更好地处理故障。”— <a class="ae ky" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga的文档</a></p></blockquote><p id="9365" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于可扩展性的原因，上面提到的所有特性都是Saga优于Thunk的原因——尤其是在测试方面。虽然测试thunks并非不可能，但它需要模仿在thunks中使用的API调用和其他函数，导致代码可读性更差、更混乱。</p><p id="999a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，虽然Redux Thunk使用回调函数来允许我们管理异步逻辑，但Redux-Saga就像是应用程序中的一个独立线程来管理它。由于线程可以从主应用程序启动、暂停和取消，这实质上意味着我们可以完全控制Redux应用程序的状态。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="5b78" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">从Thunk到Saga的重构</h1><p id="058f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">要从Thunk重构到Saga，我们首先需要更好地理解Saga是如何工作的。</p><p id="de87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想要一个按钮，当它被点击时从API请求一些数据。</p><h2 id="d737" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">1.派遣行动</h2><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="85d7" class="ng mk it nt b gy nx ny l nz oa">fetchData() {<br/>    const { data } = this.props<br/>    dispatch({type: 'FETCH_REQUESTED', payload: data})<br/>  }</span></pre><h2 id="dc2f" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">2.创建一个saga来监视所有FETCH_REQUESTED操作，这些操作将触发API调用来获取数据</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="900e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了更好地理解上面的代码，请注意以下几点:</p><ul class=""><li id="67f1" class="od oe it lb b lc ld lf lg li of lm og lq oh lu oi oj ok ol bi translated">正如<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="noopener ugc nofollow" target="_blank"> MDN Web Docs </a>所指出的，“关键字<code class="fe om on oo nt b">yield</code>暂停生成器函数的执行，关键字<code class="fe om on oo nt b">yield</code>后面的表达式的值返回给生成器的调用者。”</li><li id="9063" class="od oe it lb b lc op lf oq li or lm os lq ot lu oi oj ok ol bi translated"><code class="fe om on oo nt b">call(api.fetchData, action.payload.data)</code>调用接受<code class="fe om on oo nt b">action.payload.data</code>作为参数的<code class="fe om on oo nt b">fetchData</code>(异步)函数。</li><li id="ebc2" class="od oe it lb b lc op lf oq li or lm os lq ot lu oi oj ok ol bi translated">结果变得类似于<code class="fe om on oo nt b">await [promise]</code>。</li><li id="e14f" class="od oe it lb b lc op lf oq li or lm os lq ot lu oi oj ok ol bi translated"><code class="fe om on oo nt b">put</code>指示中间件相应地分派动作。</li><li id="1ae1" class="od oe it lb b lc op lf oq li or lm os lq ot lu oi oj ok ol bi translated">注意<code class="fe om on oo nt b">takeEvery</code>和<code class="fe om on oo nt b">takeLatest</code>的区别。这就是Redux-Saga如此强大的原因！</li></ul><p id="5bc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了Saga的一般工作原理，让我们看看如何从Thunk重构到Saga。</p><p id="4d94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Thunk，我们的<code class="fe om on oo nt b">actions</code>文件将包含如下所示的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="97d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我使用一个单一的函数作为一个例子，从以前的项目。只关注结构。</p><p id="a048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，要将我们的代码重构为Saga，我们可以遵循以下步骤:</p><ol class=""><li id="8ee8" class="od oe it lb b lc ld lf lg li of lm og lq oh lu ou oj ok ol bi translated">像承诺的那样重构对一个单独文件的API调用。</li><li id="c4da" class="od oe it lb b lc op lf oq li or lm os lq ot lu ou oj ok ol bi translated">重构函数以返回一个普通的action对象，而不是thunks(即回调函数)，其action类型声明请求了一个API调用(这里，我称之为<code class="fe om on oo nt b">CREATE_USER_DATA</code>)。然后导出所有不同的动作类型。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="74c1" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">创造传奇</h1><p id="a6fc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为我们的传奇故事创建一个新文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="676e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是，每当我们想要创建新的用户数据时，我们只需简单地写下:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="1816" class="ng mk it nt b gy nx ny l nz oa">dispatch(createUser());</span></pre><p id="ce27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Redux-Saga会完成它的使命！最后但同样重要的是，我们需要应用Saga中间件。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="8916" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">应用Saga中间件</h1><p id="e34a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">目前，这是我使用Thunk的代码的样子:</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="9ef6" class="ng mk it nt b gy nx ny l nz oa">import thunk from "redux-thunk";<br/>import reducers from "./reducers";<br/>const store = createStore(reducers, applyMiddleware(thunk));</span></pre><p id="6e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了应用Saga，我们首先创建中间件并用Thunk替换它。请注意，同时使用Saga和Thunk是可能的。它们并不相互排斥，但是需要另一种配置。</p><pre class="kj kk kl km gt ns nt nu nv aw nw bi"><span id="ec04" class="ng mk it nt b gy nx ny l nz oa">const sagaMiddleware = createSagaMiddleware();<br/>const store = createStore(reducers,applyMiddleware(sagaMiddleware));</span></pre><p id="36fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们完事了。这并不太难，是吗？希望这篇文章对那些从Thunk过渡到Saga的人有所帮助。感谢阅读！</p></div></div>    
</body>
</html>