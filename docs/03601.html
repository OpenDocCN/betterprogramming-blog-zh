<html>
<head>
<title>Cache and Serve Static Assets in Rails With Nginx Reverse Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Nginx反向代理缓存和服务Rails中的静态资产</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/cache-and-serve-rails-static-assets-with-nginx-reverse-proxy-dfcd49319547?source=collection_archive---------9-----------------------#2020-02-20">https://betterprogramming.pub/cache-and-serve-rails-static-assets-with-nginx-reverse-proxy-dfcd49319547?source=collection_archive---------9-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="374f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过提供和缓存静态内容来提高Rails web应用程序的性能和速度</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1bab23f42b6bed8b8fdb286644702bc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LuuiQd-ouXYzhr2D"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Marc-Olivier Jodoin 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1ef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的<a class="ae ky" href="https://levelup.gitconnected.com/three-methods-to-share-rails-assets-with-nginx-f39c90bb7d68?gi=d5b966651883" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>中，我介绍了三种不同的方法，用于与反向代理Nginx共享Rails应用程序的静态内容(这也适用于任何应该提供静态内容的web应用程序)。</p><p id="cbf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">共享内容的主要原因是为了提高向客户端交付静态内容的性能和速度。然而，使用Nginx共享资产并不是影响静态内容交付性能的唯一方法。</p><p id="31fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将介绍另一种技术，缓存，<strong class="lb iu"> </strong>，它可以帮助提高处理web请求的性能，而不需要在Rails应用程序和Nginx反向代理之间共享资产。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="aa66" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">什么是缓存？</strong></h1><p id="2174" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">缓存是在本地存储响应副本的过程，以加速通信和向最终用户交付内容。响应的副本可以存储在客户端(浏览器)或服务器端。缓存是为静态内容(如图像或样式表)的重复请求提供服务的强大技术。举例来说，在这个案例中，一个客户请求下载一个图像。如果图像不在缓存中，请求将被转发到后端应用程序。但是，如果它在缓存中，请求将从缓存中得到服务，并且请求不会命中后端应用程序。</p><h2 id="2d9f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">Nginx缓存如何帮助</strong></h2><p id="dcb7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在生产环境中，Rails应用程序和其他web应用程序通常位于反向代理之后，比如Nginx或Apache。反向代理是设计用于服务大量并发请求和保护后端应用程序的应用程序。反向代理将请求转发给后端应用程序，一旦收到响应，它将被转发给客户端。</p><p id="2e13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将每个请求发送到后端应用程序可能会影响后端应用程序的速度和性能。因此，配置反向代理来保存静态文件的本地副本(缓存)并在不涉及后端应用程序的情况下为它们提供服务可以提高应用程序的性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f2ae" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">如何实现Nginx缓存</strong></h1><p id="f82b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在开始Nginx配置之前，我们必须确保部署的Rails应用程序拥有预编译资产的副本，并且被配置为服务静态资产。第一项任务可以通过在应用程序文档中包含以下行来完成。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="0f21" class="mz md it nm b gy nq nr l ns nt">bundle exec rake assets:precompile</span></pre><p id="613e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">配置Rails应用程序来服务静态资产也是一项简单的任务；我们只需要确保在运行的容器上设置了下面的环境变量。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="c3ff" class="mz md it nm b gy nq nr l ns nt">RAILS_SERVE_STATIC_FILES: 'true'</span></pre><p id="1649" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">"<a class="ae ky" href="https://nginx.org/en/docs/http/ngx_http_proxy_module.html" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"><em class="nu">ngx _ http _ proxy _ module</em></strong></a><strong class="lb iu"><em class="nu">"</em></strong>是一个Nginx内置模块，允许将请求从Nginx传递到另一个服务器。在我们的例子中，另一个服务器是Rails应用程序。这个模块提供了复杂的配置项目来配置Nginx上游服务器的缓存。下面的代码片段显示了一个完整的Nginx配置文件，该文件用于缓存Rails应用程序的静态内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0f4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上述配置中首先可以注意到的是指令<code class="fe nx ny nz nm b">proxy_cache_path</code>。该指令用于设置以下高速缓存配置:</p><ul class=""><li id="c076" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">缓存文件的位置。缓存数据存储在文件中，<code class="fe nx ny nz nm b">MD5</code>函数用于命名缓存文件。</li><li id="f5cc" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">参数<code class="fe nx ny nz nm b">levels</code>定义了缓存的层次级别，从1到3；每个级别都接受值1或2。</li><li id="12e8" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nx ny nz nm b">keys_zone=blog:10m</code>定义了缓存的名称以及保存关键字和元数据信息的内存空间的大小。</li><li id="3e43" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nx ny nz nm b">max_size=1g</code>指定NGINX可以用于缓存的最大存储大小。</li><li id="364c" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nx ny nz nm b">inactive=60m</code>指定缓存对象的最大缓存生存期。</li></ul><p id="8cf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nx ny nz nm b">proxy_cache_key</code>是第二个使用的指令。对于每个缓存的请求，该项需要是唯一的，它将用于生成缓存文件名。</p><p id="ad22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，Nginx配置定义了两个位置。第一个位置在启用缓存的情况下用于服务静态资产，另一个位置在禁用缓存的情况下用于服务动态内容。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5851" class="mz md it nm b gy nq nr l ns nt">location ~ ^/(assets|images|javascripts|stylesheets|swfs|system)/ {<br/>  set $skip_cache 0;<br/>  try_files $uri <a class="ae ky" href="http://twitter.com/rails" rel="noopener ugc nofollow" target="_blank">@rails</a>;<br/>  break;<br/>}</span><span id="7052" class="mz md it nm b gy oo nr l ns nt">location / {<br/>  set $skip_cache 1;<br/>  try_files $uri <a class="ae ky" href="http://twitter.com/rails" rel="noopener ugc nofollow" target="_blank">@rails</a>;<br/>}</span></pre><p id="57ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步是为转发给Rails应用程序的请求启用缓存。下面简要描述了归档此任务所需的最重要的配置:</p><ul class=""><li id="e750" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated"><code class="fe nx ny nz nm b">proxy_cache</code>:定义使用的缓存区。</li><li id="f7a0" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nx ny nz nm b">proxy_cache_valid</code>:定义web响应的缓存时间。</li><li id="5065" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nx ny nz nm b">proxy_cache_bypass</code>:定义不从缓存中提取请求的条件。</li><li id="99d9" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nx ny nz nm b">proxy_no_cache</code>:定义响应不保存到缓存的条件。</li><li id="9bc3" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe nx ny nz nm b">add_header X-Cache-Stats</code>:向响应添加一个报头，指定请求是高速缓存命中还是高速缓存未命中。</li></ul><h2 id="4bfd" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated"><strong class="ak">测试和验证缓存配置</strong></h2><p id="d6b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我想测试的第一件事是缓存配置是否按预期工作。为了测试这一点，我多次请求同一个静态文件，并检查响应头<code class="fe nx ny nz nm b">X-Cache-Stats</code>以检查请求是<strong class="lb iu">命中</strong>还是<strong class="lb iu">未命中。</strong>下图显示了我的请求的结果，它还显示只有第一个请求没有命中<strong class="lb iu"/>；其他请求是<strong class="lb iu">命中</strong>请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/abfad34e3ed9e11846af20fd5dbf5f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkNCh5j7kOQsmd5q5wUDIw.png"/></div></div></figure><p id="6f0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想测试和衡量的下一件事是有和没有缓存特性的web应用程序。为了完成这个任务，我实现了两个Nginx服务器，一个有缓存特性，另一个没有。然后，我使用“boom”工具在每台服务器上创建许多并发请求。以下是两种情况的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/aa11d46e11d6c0f4017e79775c0bc335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_jlm81ep-lMA2pj1YKSGQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无缓存的Nginx</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/5d9dd4feac0d08563ddd84a5042efd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f_qI5psHjAsU37NxuIA5CA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带缓存的Nginx</p></figure><p id="824e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于以上测试，我们可以说缓存特性帮助<strong class="lb iu"> <em class="nu">将</em> </strong>执行所有请求所需的时间减少了五秒。此外，我们看到每秒请求数(RPS)从83个增加到98个。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="abda" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated"><strong class="ak">结论</strong></h1><p id="57c6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用Nginx为后端服务实现缓存有助于提高web应用程序的性能，并减少后端服务的负载。Nginx缓存特性可以用来缓存Nginx直接管理的内容，也可以用来缓存任何上游服务器提供的静态内容。</p></div></div>    
</body>
</html>