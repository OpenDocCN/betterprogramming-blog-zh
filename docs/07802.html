<html>
<head>
<title>Implementing Interfaces With Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang实现接口</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implementing-interfaces-with-golang-51a3b7f527b4?source=collection_archive---------0-----------------------#2021-02-22">https://betterprogramming.pub/implementing-interfaces-with-golang-51a3b7f527b4?source=collection_archive---------0-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ff02" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何利用接口的力量</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0637ae596f6c9864f29a030f777e9c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5KNabwstG5jM4DuB3N7rQ.png"/></div></div></figure><p id="2cbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接口是定义一系列动作和行为的工具。它们帮助对象依赖抽象，而不是其他对象的具体实现。我们可以通过组合多个接口来组合不同的行为。</p><p id="1e3f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将讨论Golang中的接口以及如何使用它们。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4c83" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">什么是接口？</h1><blockquote class="mp"><p id="5332" class="mq mr it bd ms mt mu mv mw mx my lp dk translated">接口是一组表示不同数据类型的通用行为的方法。</p></blockquote><p id="e40a" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">有了接口，我们可以组织不同的方法组，应用于不同类型的对象。通过这样做，我们的程序可以依赖于更高的抽象(接口),而不是具体的实现，允许其他方法与实现相同接口的各种不同的对象一起工作。</p><p id="add1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在OOP的世界里，这个概念被称为依赖倒置原则。如果你想了解更多关于坚实原则的内容，我推荐你看一看<a class="ae ne" href="https://medium.com/swlh/what-are-solid-principles-in-software-development-world-a5ec98637c01" rel="noopener">这篇文章。</a></p><p id="c247" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中，构建小型接口，然后将它们组合在一起，为对象添加更多功能，被认为是最佳实践。这样，您可以保持代码整洁，并提高可重用性。</p><p id="4b58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以考虑多种类型之间常见的不同动作来定义接口。</p><p id="7a37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中，我们可以自动推断一个struct (object)实现了它的所有方法就实现了一个接口。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="3573" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">在Go中定义简单接口</h1><p id="09a1" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">让我们在Go中定义一个接口，开始玩转，发现它的强大之处。</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="cc0d" class="np ly it nl b gy nq nr l ns nt">type Printer interface {<br/>  Print()  <br/>}</span></pre><p id="e197" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常简单的接口，定义了一个叫做<code class="fe nu nv nw nl b">Print()</code>的方法。此方法表示其他对象可以实现的操作或行为。</p><p id="1b74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要明确的是，接口仅仅定义了行为，并没有定义具体的实现。这是实现这个接口的对象的工作。</p><p id="3889" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们创建两个将实现这个<code class="fe nu nv nw nl b">Printer</code>接口的对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="5299" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的例子中，我们声明了两个<code class="fe nu nv nw nl b">struct</code>类型——一个用户和一个文档。</p><p id="6989" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们使用接收函数在每个struct类型上声明<code class="fe nu nv nw nl b">Print</code>函数及其自定义实现。</p><p id="4ebb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这之后，我们可以说这两个结构都实现了<code class="fe nu nv nw nl b">Printer</code>接口。</p><p id="0dec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过这样做，我们可以编写更多依赖于抽象而不是具体对象的代码，从而允许我们的代码被重用。假设我们想写一个新的方法来打印这两个结构的细节。我们可以使用这个接口来实现:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="cc5f" class="np ly it nl b gy nq nr l ns nt">func Process(obj Printer) {<br/>    obj.Print()<br/>}</span></pre><p id="9f09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该函数将实现该接口的任何对象作为参数。所以只要对象响应接口内部定义的方法，我们就可以用这个函数来处理对象。</p><p id="ddbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在main函数中，我们可以编写以下内容来打印每个对象的详细信息:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="12a3" class="np ly it nl b gy nq nr l ns nt">func main() {<br/>  u := User{name: "John", age: 24, lastName: "Smith"}<br/>  doc := Document{name: "doc.csv", documentType: "csv", date: time.Now()}<br/>  Process(u)<br/>  Process(doc)<br/>}</span></pre><p id="2507" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码的输出如下所示:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="f236" class="np ly it nl b gy nq nr l ns nt">Hi I am John Smith and I am 24years old <br/>Document name: doc.csv, type: csv, date: 2009-11-10 23:00:00 +0000 UTC m=+0.000000001</span></pre><p id="11fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看一个使用接口的更复杂的例子，让我们更好地理解接口在Go中是如何工作的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="acd7" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">项目描述</h1><p id="3f48" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">在这个项目中，我们将处理客户订单。我们的程序将支持<code class="fe nu nv nw nl b">National</code>和<code class="fe nu nv nw nl b">International</code>订单，两者都依赖于接口的抽象来定义预期的行为。</p><p id="83fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在这个项目中使用Go模块，我希望你对模块如何在Go中工作有一个基本的了解，但如果你没有，这也没什么大不了的。</p><p id="6d01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们开始创建一个名为<code class="fe nu nv nw nl b">interfaces</code>的新文件夹。</p><p id="c198" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在该文件夹中，运行以下命令创建一个模块:</p><pre class="kj kk kl km gt nk nl nm nn aw no bi"><span id="6b26" class="np ly it nl b gy nq nr l ns nt">go mod init interfaces</span></pre><p id="1939" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该命令将生成一个新文件<code class="fe nu nv nw nl b">go.mod</code>，其中包含模块名称和Go版本。对我来说，围棋版本是<code class="fe nu nv nw nl b">go 1.15</code>。</p><p id="ab53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一个名为<code class="fe nu nv nw nl b">order</code>的新文件夹。在该文件夹中创建以下文件:</p><ul class=""><li id="f9d6" class="nz oa it kw b kx ky la lb ld ob lh oc ll od lp oe of og oh bi translated"><code class="fe nu nv nw nl b">intenationalOrder.go</code></li><li id="bc61" class="nz oa it kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated"><code class="fe nu nv nw nl b">nationalOrder.go</code></li><li id="ce56" class="nz oa it kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated"><code class="fe nu nv nw nl b">order.go</code></li><li id="1352" class="nz oa it kw b kx oi la oj ld ok lh ol ll om lp oe of og oh bi translated"><code class="fe nu nv nw nl b">helpers.go</code></li></ul><p id="6c86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在根文件夹中创建一个新的<code class="fe nu nv nw nl b">main.go</code>文件。文件夹结构将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi on"><img src="../Images/f3bd2e467907ccfd15c4eeea75587db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*ws61oUgWmfc9i_MrCr-ruA.png"/></div></figure><p id="5ff8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们看看<code class="fe nu nv nw nl b">main.go</code>文件的实现。main函数的定义将非常简单，因为我们导入了orders包，并且只从中调用了<code class="fe nu nv nw nl b">New</code>函数。反过来，这个包将具有这个例子所有逻辑:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2415" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，这个文件非常简单，我们只是导入订单包并在其上调用<code class="fe nu nv nw nl b">New</code>函数。我们还没有创建订单包，但我们将很快创建。</p><p id="a5db" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于订单包，我们将创建不同的结构类型和接口。让我们看看这个文件是什么样子的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="6070" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们浏览一下这个文件，解释每个定义的函数、接口和结构对象。</p><p id="5e26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们有一个<code class="fe nu nv nw nl b">New</code>函数。正如你已经知道的，我们使用大写字母作为函数名，因为我们想导出并使它对其他包可用。第一个功能的目的是创建一个国家秩序的新实例和一个国际秩序的新实例。然后，我们将这两个实例传递给类型为<code class="fe nu nv nw nl b">Operations</code>的片内的<code class="fe nu nv nw nl b">ProcessOrder</code>函数。我们稍后将更详细地讨论这个<code class="fe nu nv nw nl b">Operation</code>类型。</p><p id="e720" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下结构类型代表了我们创建订单所需的各种对象:<code class="fe nu nv nw nl b">Product</code>、<code class="fe nu nv nw nl b">ProductDetail</code>、<code class="fe nu nv nw nl b">Summary</code>、<code class="fe nu nv nw nl b">ShippingAddress</code>、<code class="fe nu nv nw nl b">Client</code>和<code class="fe nu nv nw nl b">Order</code>。</p><p id="a310" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nu nv nw nl b">Order</code>结构类型将有一个摘要、送货地址和客户属性。它还有一个类型为<code class="fe nu nv nw nl b">ProductDetail</code>的产品数组。</p><p id="5573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还声明了三个小接口:<code class="fe nu nv nw nl b">Processer</code>、<code class="fe nu nv nw nl b">Printer</code>和<code class="fe nu nv nw nl b">Notifier</code>。这些接口中的每一个都有一个函数，它定义了其他对象实现它们时必须采用的行为。</p><p id="0576" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还有另外一个接口叫做<code class="fe nu nv nw nl b">Operations</code>。我们正在组合不同的接口来创建这个接口，这非常方便，因为它允许我们的程序组合对象，并使代码更加可重用。</p><p id="9c6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，对于这个文件，我们有一个接收订单数组的<code class="fe nu nv nw nl b">ProcessOrder</code>函数。有趣的部分来了。与接收特定对象的数组相反，该函数接收这些对象的抽象。所以，只要我们在数组内部传递的对象实现了<code class="fe nu nv nw nl b">Operations</code>接口，这个函数就能正常工作。这就是接口真正有用的地方，因为它们允许我们的程序依赖抽象而不是具体的实现。</p><p id="a719" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们实现<code class="fe nu nv nw nl b">internationalOrder.go</code>文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b7ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该文件是<code class="fe nu nv nw nl b">Operations</code>接口的第一个具体实现。首先，我们创建了一个名为<code class="fe nu nv nw nl b">InternationalOrder</code>的新结构类型，使用<code class="fe nu nv nw nl b">Order</code>结构来定义它的属性和对象。然后我们有一个名为<code class="fe nu nv nw nl b">NewInternationalOrder</code>的初始化函数，它将为这个订单设置一些产品、客户信息和发货地址。</p><p id="ff8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用一个助手函数来初始化一个新的<code class="fe nu nv nw nl b">ProductDetail</code>、<code class="fe nu nv nw nl b">Client</code>和<code class="fe nu nv nw nl b">ShippingAddress </code>——别担心，我们很快就会实现。</p><p id="b3ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在文件的其余部分，我们声明了<code class="fe nu nv nw nl b">FillOrderSummary</code>、<code class="fe nu nv nw nl b">Notify</code>和<code class="fe nu nv nw nl b">PrintOrderDetails</code>函数的具体实现。这样，我们可以说国际订单结构类型实现了<code class="fe nu nv nw nl b">Operations</code>接口，因为它有所有方法的定义。相当酷！</p><p id="3769" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来看看<code class="fe nu nv nw nl b">nationalOrder.go</code>文件的执行情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="0e76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个文件代表了<code class="fe nu nv nw nl b">Operations</code>接口的第二个具体实现。这里，我们有一个<code class="fe nu nv nw nl b">NationalOrder</code>结构类型，它也使用了<code class="fe nu nv nw nl b">Order</code>结构类型。</p><p id="4786" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还声明了一个初始化函数，该函数将设置一些产品、客户信息以及这个特定国家订单的发货地址。</p><p id="83d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，正如我们在前面的文件中所做的那样，我们有了实现接口所需的所有方法的定义。这样，国家订单结构也实现了<code class="fe nu nv nw nl b">Operations</code>接口，因为它响应它的所有方法。</p><p id="b165" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了这两个具体的实现，我们可以将这些实例传递给依赖于<code class="fe nu nv nw nl b">Operations</code>接口的任何方法。</p><p id="0c52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了完成这个例子，我们只需要在<code class="fe nu nv nw nl b">helpers.go</code>文件中实现助手函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="15bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如前所述，该文件包含一些帮助器函数，用于创建产品、设置客户端、送货地址以及计算订单的小计。</p><p id="c076" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们准备好运行这个程序了！</p><p id="684c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们转到项目的根文件夹，用<code class="fe nu nv nw nl b">go run main.go</code>运行程序。我们应该看到这样的预期输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/45c44a1e6d08d6d71a9098203f2207ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JCWlhFBhBTw9SSkOQTV_WA.png"/></div></div></figure><p id="1410" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经学会了如何在Go中使用接口，我们可以创建更多依赖于其他接口的函数。</p><p id="d0a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，我们可以创建新的函数来接收任何实现了<code class="fe nu nv nw nl b">OrderProcesser</code>或<code class="fe nu nv nw nl b">OrderNotifier</code>接口的对象。这时，定义小接口的想法就派上了用场。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="35ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们的对象实现了较小的接口，但同时又是较大接口的一部分时，这将非常有用。通过创建小接口，我们遵循接口分离原则，确保我们的程序与实现不同接口的不同对象一起工作。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="a753" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">结论</h1><p id="ea0c" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">接口是创建定义行为的抽象的好方法。现在，我们可以开始构建使用接口来抽象行为和跨不同对象共享公共动作的程序。接口也给了程序更多的灵活性，允许更多的代码重用。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="4446" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">资源</h1><p id="bd18" class="pw-post-body-paragraph ku kv it kw b kx nf ju kz la ng jx lc ld nh lf lg lh ni lj lk ll nj ln lo lp im bi translated">如果您有兴趣了解更多关于Go的知识，下面的文章可能会有所帮助。</p><div class="op oq gp gr or os"><a href="https://levelup.gitconnected.com/grpc-how-to-make-effective-unary-calls-4c9fa68cd9d5" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">gRPC:如何进行有效的一元调用</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在本文中，我将解释如何进行一元gRPC调用——实现客户机和服务器Go应用程序。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://levelup.gitconnected.com/grpc-how-to-make-client-streaming-calls-5c731197585" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">gRPC:如何进行客户端流调用</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在本文中，我将介绍客户机流gRPC调用——实现客户机和服务器Go应用程序。</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div></div></div>    
</body>
</html>