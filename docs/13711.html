<html>
<head>
<title>AWS SQS Batch Consumer Using AWS Lambda and Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用AWS Lambda和Go的AWS SQS批次消费者</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/aws-sqs-batch-consumer-using-aws-lambda-and-go-b747795afccd?source=collection_archive---------5-----------------------#2022-09-19">https://betterprogramming.pub/aws-sqs-batch-consumer-using-aws-lambda-and-go-b747795afccd?source=collection_archive---------5-----------------------#2022-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa5c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何一次消费几条消息</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f6a8fa8004b5048ae6f830c41574393f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1S88kSztbnt4H3zH"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Emile Perron 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="af03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，当与一些HTTP API集成时，在执行业务流的同时发送请求并不重要(同步流)。有些请求甚至可以成批分组并最终发送出去(异步流)。下面是<em class="ls">事件驱动设计</em>，可以帮你解决这个问题。但是怎么做呢？如何将几个请求一批分组？在这篇文章中，我将描述我的经历，以及我如何用现实生活中的例子来处理它。</p><h1 id="cdcd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">概观</h1><p id="e9a8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">前段时间我集成了拥有某个领域模型的API(我就叫它<em class="ls">实体API </em>)。它很宽，允许您执行几乎所有的CRUD操作，并将它们分组为批处理。在单个HTTP请求的范围内，可以更新、添加和删除三个不同的实体。但是当然，我不是这样用它的。</p><p id="fc48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我做过一个监听HTTP webhook的服务，当它被触发时，我必须做很多事情。我必须做的一件事是使用实体API更新模型。接下来是对更新的要求:它应该在webhook被触发后的前1个小时内发生。但是为了简单起见，我在处理webhook的范围内更新了实体。</p><p id="5228" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不得不处理的问题来了。我已经开始收到429个HTTP响应，负载巨大。我已经超过了实体API HTTP速率限制。此时此刻，别无选择。有必要重新实现整合。</p><h1 id="8965" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">切换到事件驱动架构</h1><p id="6ecb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当涉及到实体更新时，我的第一个决定是切换到异步流。更新SLA使之成为可能(它是1小时)。在这里，我开始寻找一个我可以使用的信息传递服务。</p><p id="2afb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在此之前，我也研究过外部API。正如我之前所说的，它允许在一个批处理中分组几个更新。如果我可以将至少两个更新组合在一个批处理中——这将减少两倍的负载。批量越大，外部API的负载就越低！它可以显著降低负载。</p><p id="19ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我不仅需要一个消息代理。我需要一次接收几条消息的能力。首先想到了<strong class="ky ir"> RabbitMQ </strong>。它允许在没有确认的情况下使用多个消息。因此，您可以将它们收集到内存集合中，对它们进行处理和确认。这意味着应该在应用程序端进行多次消息消费。这是一个选项，但不是我想要的。</p><p id="0007" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我已经开始研究我能用亚马逊SQS做些什么。SQS正是我所需要的。</p><h2 id="447a" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">亚马逊SQS</h2><p id="c4fc" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果你打开<a class="ae kv" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank">亚马逊文档</a>，它接下来说:</p><blockquote class="nc nd ne"><p id="6192" class="kw kx ls ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">亚马逊简单队列服务(SQS)是一种完全托管的消息队列服务，使您能够分离和扩展微服务、分布式系统和无服务器应用程序。SQS消除了与管理和操作面向消息的中间件相关的复杂性和开销，并使开发人员能够专注于不同的工作。使用SQS，您可以在任意数量的软件组件之间发送、存储和接收消息，而不会丢失消息或要求其他服务可用。</p></blockquote><p id="cf1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">亚马逊SQS可以成为亚马逊Lambda的触发器。简单地说，这是另一种AWS服务，它允许您在云中运行应用程序代码，而没有基础设施开销。你可以在亚马逊文档和我以前发表的另一篇文章中找到更多的细节:</p><div class="ni nj gp gr nk nl"><a href="https://aws.amazon.com/lambda/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">无服务器计算- AWS Lambda -亚马逊网络服务</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">AWS Lambda无需配置或管理基础设施即可运行代码。只需编写并上传代码作为一个. zip文件或…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">aws.amazon.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://awstip.com/building-serverless-c-telegram-bot-3df51b2f4661" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">构建无服务器C#电报机器人</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">为什么应该选择AWS Lambda来构建bot</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">awstip.com</p></div></div><div class="nu l"><div class="oa l nw nx ny nu nz kp nl"/></div></div></a></div><p id="fdc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我读到如何用来自SQS的事件触发Lambda(<a class="ae kv" href="https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html" rel="noopener ugc nofollow" target="_blank">链接</a>)时，我发现了下面的语句:</p><blockquote class="nc nd ne"><p id="0586" class="kw kx ls ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">Lambda成批读取消息，并为每批调用一次您的函数</p></blockquote><p id="35cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这正是我所需要的！所以我必须创建一个SQS队列，创建AWS Lambda并正确配置它。在几条消息发布到队列之后——Lambda应该以这些消息作为输入参数来执行。</p><p id="bbfb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来是架构图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/304c5b841f6a9b74e74dcbf88f96aee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vm4ISZ7QuEpe1PZzJHNu_Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">综合</p></figure><p id="74b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不是从服务直接更新调用实体API，而是将消息发布到SQS队列，最终触发Lambda。Lambda将几个事件组合成一个批处理，并执行一个HTTP调用来更新所有条目。让我们试着实现它吧！</p><h1 id="32de" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">履行</h1><p id="4201" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我不能展示真正的代码，但我将使用Go实现Lambda代码，它将向SQS发布消息。了解流程以及如何根据自己的需求进行扩展就足够了。</p><p id="4d52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从您将需要的依赖项开始:</p><ul class=""><li id="6eab" class="oc od iq ky b kz la lc ld lf oe lj of ln og lr oh oi oj ok bi translated"><code class="fe ol om on oo b">github.com/aws/aws-lambda-go/events</code>—包为AWS Lambda提供输入类型；</li><li id="9894" class="oc od iq ky b kz op lc oq lf or lj os ln ot lr oh oi oj ok bi translated"><code class="fe ol om on oo b">github.com/aws/aws-lambda-go/lambda </code> —包提供了实现AWS Lambda的方法。</li></ul><p id="7fe9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们实现代码。这将是初级的。你可以在下面看到:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">希腊字母的第11个</p></figure><p id="0d62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ol om on oo b">sqsEvent.Records</code>的单条记录是有字段<code class="fe ol om on oo b">Body</code> <em class="ls">的SQS报文。</em>这是你发布消息时发的内容。它可以是JSON或者任何你想要的格式。因此您可以解组它，并以您需要的方式处理它。</p><h2 id="b0f6" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak">基础设施</strong></h2><p id="0214" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，您需要创建一个SQS队列。你需要打开<strong class="ky ir"> AWS管理控制台</strong>，进入<strong class="ky ir">简单队列服务</strong>，点击<strong class="ky ir">创建队列</strong>。您将需要配置队列。这里就不描述细节了，因为配置取决于你的需求。</p><p id="21f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，你就可以创建Lambda了。转到<strong class="ky ir"> Lambda </strong>，点击<strong class="ky ir"> Create Function </strong>并创建一个空函数，具有Go运行时和消费AWS SQS所需的权限(亚马逊SQS轮询器权限)。</p><p id="69a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在您可以部署代码了。您需要执行以下命令来创建部署代码所需的工件:</p><pre class="kg kh ki kj gt ow oo ox oy aw oz bi"><span id="1046" class="mq lu iq oo b gy pa pb l pc pd">GOOS=linux go build main.go<br/>zip function.zip main</span></pre><p id="8d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后打开创建的Lambda并选择上传自。zip文件。最后但同样重要的是，您需要配置触发器。单击添加触发器，选择SQS作为源，选择SQS队列并提供附加配置:批处理大小和批处理窗口。批处理大小是一次从流中读取的最大记录数。Batch window是调用函数之前收集记录的最长时间，以秒为单位。</p><p id="a8ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。现在，您需要让您的应用程序向SQS队列发布消息。下面是我用来测试Lambda的示例控制台应用程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">出版</p></figure><p id="cda3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS SDK(至少在Go中)允许你一次发布十条消息。所以在实现代码时要小心。</p><h2 id="193f" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">测试</h2><p id="922b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我已经将lambda配置为一次处理20条消息。在您发布大量消息并检查日志后，您将看到类似于我所看到的内容:</p><pre class="kg kh ki kj gt ow oo ox oy aw oz bi"><span id="140a" class="mq lu iq oo b gy pa pb l pc pd">Messages count: 16<br/>Messages count: 14<br/>Messages count: 2<br/>Messages count: 20<br/>...</span></pre><p id="c4c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">AWS不保证lambda总是在消息计数等于批处理大小的情况下执行。在我的场景中，这并不重要。您还应该知道，标准的SQS队列不能保证顺序，并且一条消息可以被传递多次。这对您的系统设计至关重要。</p><h1 id="ef6f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="af05" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Amazon Web Services提供了许多可以用来开发应用程序的服务。您可以结合AWS Lambda和AWS SQS的优势来构建健壮、有弹性、可伸缩的系统，以应对大负载。</p><h1 id="ae51" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">资源</h1><div class="ni nj gp gr nk nl"><a href="https://aws.amazon.com/sqs/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">亚马逊SQS |消息队列服务| AWS</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">微服务、分布式系统和无服务器应用程序的完全托管消息队列Amazon Simple Queue…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">aws.amazon.com</p></div></div><div class="nu l"><div class="pe l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://aws.amazon.com/lambda/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">无服务器计算- AWS Lambda -亚马逊网络服务</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">AWS Lambda无需配置或管理基础设施即可运行代码。只需编写并上传代码作为一个. zip文件或…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">aws.amazon.com</p></div></div><div class="nu l"><div class="pf l nw nx ny nu nz kp nl"/></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://pkg.go.dev/github.com/aws/aws-lambda-go/events" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">事件</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">const(CodeBuildEventSource = " AWS . CodeBuild " CodeBuildStateChangeDetailType = " CodeBuild生成状态更改"…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">pkg.go.dev</p></div></div></div></a></div><div class="ni nj gp gr nk nl"><a href="https://pkg.go.dev/github.com/aws/aws-lambda-go/lambda" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">希腊字母的第11个</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">此部分是空的。此部分是空的。func Start(处理程序接口{}) Start接受一个处理程序并与一个…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">pkg.go.dev</p></div></div></div></a></div></div></div>    
</body>
</html>