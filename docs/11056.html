<html>
<head>
<title>Using Coroutines in Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Unity中使用协程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-coroutines-in-unity-e293d2f17b57?source=collection_archive---------14-----------------------#2022-02-14">https://betterprogramming.pub/using-coroutines-in-unity-e293d2f17b57?source=collection_archive---------14-----------------------#2022-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="332c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习在Unity代码库中设置和使用协程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d47b229f8fa358799e9cec1637aeedb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*yTIT9uZ4R2nQ5o3RWzc41Q.gif"/></div></div></figure><p id="5cbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Unity中的协程允许用户在继续之前等待一段时间。</p><p id="6baf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们这样来看。如果我想每隔几秒钟产生一个敌人，我会使用一个协程来完成。</p><p id="1a72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看看如何设置一个。</p><p id="e6e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要定义一个类型为<code class="fe ln lo lp lq b">IEnumerator</code>的方法。这是一个集合类型，它将代码放入事件序列类型结构中。</p><p id="46b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这意味着用我们产卵的敌人为例，我们可以等待几秒钟，然后产卵另一个，然后再次等待，重复。</p><p id="0e33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一下代码。首先，我为敌人预设设置了一个新的私有序列化字段<code class="fe ln lo lp lq b">GameObject</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7ce5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我将设置<code class="fe ln lo lp lq b">IEnumerator</code>方法，并将其命名为<code class="fe ln lo lp lq b">SpawnRoutine</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="1552" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的红色曲线告诉我有东西不见了。错误消息指出并非所有代码路径都返回值。我们将在添加yield return命令时解决这个问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/fdcb6fbbf62b4e5d866677fe87835395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4VA9ABdUh6lQM34r2sDcdA.png"/></div></div></figure><p id="f5ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">yield return命令的作用是为我们设置事件的顺序。例如，如果我使用yield返回null，1号错误将被解决，2号<code class="fe ln lo lp lq b">IEnumerator</code>将等待一帧，然后运行它下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="9682" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，我们想要的行为是让协程每隔几秒钟运行一次。我们使用yield return new <code class="fe ln lo lp lq b">WaitForSeconds()</code>方法来完成这个任务。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="0227" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太棒了，我们现在可以在跑步前等待一段时间了。但是这只会运行代码一次。现在我们必须实现一个叫做while循环的东西。</p><p id="8550" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">While loops，顾名思义，在满足某些条件时循环一段代码。举例来说，如果我们只想让这个敌人产卵5次，我们会说，当它少于5次时，每5秒产卵一次。</p><p id="95b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在代码中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="96c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里更新计数器是极其重要的。如果我们不这样做，那么我们就进入了所谓的无限循环。</p><p id="f039" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无限循环可能有用，但也可能非常危险。如果做得不正确，他们可以崩溃你的电脑，并公然使你的游戏无法播放。</p><p id="cf98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些有用的无限循环的例子是Unity。程序本身不会自动关闭，说一切运行正常，直到你自己关闭它。这是因为一个无限循环正在运行，以确保程序保持打开。</p><p id="c03c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们回到繁殖我们的敌人，我们实际上将遵循同样的逻辑，当我们的游戏运行时，我们希望无限繁殖新的敌人。</p><p id="37b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为此，我们将这样设置我们的循环:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="32db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这一行代码说，虽然我们想等待5秒钟，然后运行我们的代码。</p><p id="d6ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是无限的，因为真永远不会自己变成假。因此，这个循环永远不会中断。</p><p id="0a07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在添加我们的敌人，我们将用一个随机的产卵位置来实例化我们的敌人预置游戏对象:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="3194" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基础工作已经就绪。剩下唯一要做的事情就是弄清楚如何实际调用这个方法。</p><p id="e35f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Unity有一个名为<code class="fe ln lo lp lq b">StartCoroutine()</code>的内置方法，它接受协程名称或协程调用的参数。因为我们希望这在游戏的整个生命周期中持续，所以我们将把它放在Spawn Manager脚本的start方法中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="496c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<a class="ae lu" href="https://www.linkedin.com/in/brantlee-mercer-433012112/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上与我联系，关注更多！</p></div></div>    
</body>
</html>