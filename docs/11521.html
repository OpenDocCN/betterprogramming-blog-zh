<html>
<head>
<title>Learn SOLID Design Principles in Java by Coding It</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过编写Java来学习坚实的设计原则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-solid-design-principles-in-java-by-coding-it-dcbf64a17b53?source=collection_archive---------3-----------------------#2022-03-28">https://betterprogramming.pub/learn-solid-design-principles-in-java-by-coding-it-dcbf64a17b53?source=collection_archive---------3-----------------------#2022-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8dbd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对所有可靠设计原则的深入解释，包括真实世界的用例及代码示例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/794d64de904a5737b1f2cce23dacce31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4UMe0F6rXeH-emJtQLkaSQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@max_duz?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>拍照</p></figure><h1 id="4cde" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">目录</h1><ol class=""><li id="982c" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是固体，为什么你要费心使用它</li><li id="f024" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">单一责任原则</li><li id="4a6d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">开闭原理</li><li id="6f8e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">利斯科夫替代原理</li><li id="b644" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">界面分离原理</li><li id="b6d9" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">从属倒置原则</li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="ea0b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在本文中，我们将讨论固体设计原则。首先我们会明白它们为什么会出来，然后我们会明白如何用代码例子实现每一个原理。</p><h1 id="2d70" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.什么是固体，为什么你要费心使用它</h1><p id="f29e" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">在他的论文<a class="ae kv" href="http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf" rel="noopener ugc nofollow" target="_blank">设计原则和设计模式</a>中，Robert C. Martin介绍了这些原则，后来，Michael Feathers介绍了这个缩写。</p><p id="61b3" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">一般来说，设计原则鼓励我们写出更好的软件，更易维护，更易理解，更灵活。它也改善了那些将来会成为你团队一部分的人的开发体验。</p><p id="319b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk"> S.O.L.I.D </em>代表:</p><ol class=""><li id="ff42" class="lo lp iq lq b lr mu lt mw lv nl lx nm lz nn mb mc md me mf bi translated">单一责任原则</li><li id="ef0d" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir"> O </strong>笔关闭原理</li><li id="2ca2" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir"> L </strong>伊斯科夫替代原理</li><li id="cd60" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir"> I </strong>界面偏析原理</li><li id="c2c9" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir"> D </strong>依赖反转原理</li></ol><h1 id="bea9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.单一责任原则</h1><p id="4e5e" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">这个原则规定一个类应该只有一个责任，换句话说，<em class="nk">一个类应该只有一个改变的理由</em>。</p><p id="3477" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这意味着只有当我们的类的功能发生变化时，它才应该发生变化。</p><p id="a9a2" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">你可以从中受益，比如，加入新成员会更容易，测试会更容易，等等。</p><p id="e15e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">许多框架和库都遵循这个原则。例如，<a class="ae kv" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html" rel="noopener ugc nofollow" target="_blank">crud repository</a>from Spring Data，<a class="ae kv" href="https://www.baeldung.com/javax-validation" rel="noopener ugc nofollow" target="_blank">验证</a> API，<a class="ae kv" href="https://www.baeldung.com/java-8-date-time-intro" rel="noopener ugc nofollow" target="_blank">日期/时间</a> API。</p><p id="efb3" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">用例</em></p><p id="4e11" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">假设我们有一个类产品服务，它有两个关注点和责任:</p><ol class=""><li id="a78f" class="lo lp iq lq b lr mu lt mw lv nl lx nm lz nn mb mc md me mf bi translated">操纵产品上的crud操作。</li><li id="812b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">基于crud操作发送短信和电子邮件通知。</li></ol><p id="c4fa" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">SingleResponsibility.java</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="782e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">如果这个类的需求改变了，现在我们要发送一封文本邮件和一封HTML邮件，它们需要不同的<code class="fe nq nr ns nt b">sendEmail()</code>方法的实现，会发生什么呢？</p><p id="748d" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">之后，我们可能会有一个不同的产品操作要求，也需要改变。</p><p id="653c" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">随后，<code class="fe nq nr ns nt b">ProductService</code>类基于通知相关原因和产品相关原因发生变化。</p><p id="bf1b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">最好将这些问题分开:</p><p id="4ff9" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">SingleResponsibility.java</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7ad6" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">即使我们在每个需求变更上创建不同的方法，这里的想法是分离关注点，解决这种问题的解决方案是一个完全不同的主题。</p><h2 id="af37" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated"><em class="og">常见讨论</em></h2><p id="cfeb" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">每个工程师/团队都有自己的改变理由。当决定一门课程的目的时，没有严格的概念可以遵循。这完全取决于你自己的商业规则、你的项目、你的团队等等。</p><p id="7284" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">关键是不要想太多。试着想象一个单一的责任，即使方法执行不同的操作，它们的目的是一样的吗？</p><h1 id="63ce" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.开闭原理</h1><p id="30f6" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">这个原则规定软件实体(类、模块、函数等)。)应该对扩展开放，但对修改关闭。</p><p id="b372" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这意味着，当组件不断增长时，您应该避免修改系统中某些东西的逻辑。在真实的例子中更容易形象化。</p><h2 id="5a28" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated"><em class="og">用例</em></h2><p id="d2fa" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">想象一下，我们有一个著名的计算几何图形面积的问题。</p><p id="d14e" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">AreaCalculator.java</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a29f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">即使是一个基本的例子，每次需要计算一个新的形状面积时，都必须改变<code class="fe nq nr ns nt b">AreaCalculator</code>，用一个新的方法，这可能是很无聊的，因为逻辑每次都会改变。</p><p id="6839" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们可以利用简单的抽象和多态来处理这个问题。</p><p id="7a68" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe nq nr ns nt b">AreaCalculator.java</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f351" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这样，<code class="fe nq nr ns nt b">AreaCalculator</code>就不知道要处理哪个和多少个形状，也不知道它自己的实现。</p><p id="2f8b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">现在那个班开放延期(<code class="fe nq nr ns nt b">Triangle</code>、<code class="fe nq nr ns nt b">Circle</code>、<code class="fe nq nr ns nt b">Rectangle</code>等)。)并关闭以进行修改(不会有每次出现新形状时都添加不同逻辑的方法)。</p><h1 id="17d2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.利斯科夫替代原理</h1><p id="1cfd" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">这个原则规定了一个类通过它的子类的可替换性，所以在所有实际的使用场景中，一个类可以被它的子类替换，这意味着你应该只为可替换性使用继承。</p><blockquote class="oh oi oj"><p id="1394" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated"><em class="iq">“子类型必须可以替换其基本类型。”</em></p><p id="c038" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated">罗伯特·马丁</p><p id="a68b" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated"><em class="iq">“如果对于S类型的每个对象o1，存在T类型的对象o2，使得对于根据T定义的所有程序P，当o1替换o2时，P的行为不变，则S是T的子类型。”</em></p><p id="9381" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated"><em class="iq">——芭芭拉·利斯科夫</em></p></blockquote><p id="a679" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">简而言之:</p><p id="621b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">如果我们可以在不改变程序行为的情况下用一个<code class="fe nq nr ns nt b">ChildClass</code>对象替换一个<code class="fe nq nr ns nt b">ParentClass</code>对象，那么<code class="fe nq nr ns nt b">ChildClass</code>应该只扩展一个<code class="fe nq nr ns nt b">ParentClass</code>，否则我们应该使用组合或委托。</p><h2 id="73f0" class="nu kx iq bd ky nv nw dn lc nx ny dp lg lv nz oa li lx ob oc lk lz od oe lm of bi translated"><em class="og">用例</em></h2><p id="f94a" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">想象我们有一个父类<code class="fe nq nr ns nt b">Bird</code>。我们可以有很多子类，比如麻雀，鸵鸟，老鹰，猎鹰等。</p><p id="f0ae" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">有一个<code class="fe nq nr ns nt b">Sparrow</code>和一个<code class="fe nq nr ns nt b">Ostrich</code>类，扩展一个<code class="fe nq nr ns nt b">Bird</code>类对吗？根据利斯科夫替代原理，它不是。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="25b9" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">即使鸵鸟也是一种鸟，让它的对象能够飞也没有意义，因为它不能。</p><p id="0333" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们可以将继承分解成一个更小的层次来遵循这个原则。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f367" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这样，在任何情况下，Bird类都不会被Sparrow类错误地替换。</p><h1 id="c15b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.界面分离原理</h1><p id="a4d4" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">这个原则表明，客户不应该被迫实现一个它不使用的接口。</p><p id="73bf" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这有点像单一责任原则，但是在接口层次上。</p><p id="e3f4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">用例</em></p><p id="9169" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">想象一下，如果我们有一个接口工作器，它有两个方法，work()和sleep()。这样，每个混凝土工人阶层都可以工作和睡觉。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3004" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">让机器人工人实现sleep()方法有意义吗，即使我们知道它不能？</p><p id="eec6" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们可以通过将接口分解成更小、更具体的接口来解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5e7f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这样，我们可以减少使用更大的通用接口的副作用，让每个接口服务于一个目的。</p><h1 id="f4b9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">6.从属倒置原则</h1><blockquote class="oh oi oj"><p id="8dfc" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated"><em class="iq">“高层模块不要依赖低层模块。两者都应该依赖于抽象。</em></p><p id="6bb0" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated">罗伯特·马丁</p><p id="7103" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</p><p id="3a6f" class="ms mt nk lq b lr mu jr mv lt mw ju mx ok my mz na ol nb nc nd om ne nf ng mb ij bi translated">罗伯特·马丁</p></blockquote><p id="6dd7" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这个原则表明，我们应该通过抽象高层模块和低层模块之间的交互，来颠倒它们之间的传统依赖关系。</p><p id="5f48" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">它通过在高级模块和低级模块之间引入接口或抽象类来分离它们之间的依赖关系。</p><p id="26af" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">最终，你会得到一个依赖于抽象的高级模块和一个依赖于抽象的低级模块。</p><p id="df2f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">用例</em></p><p id="73c1" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk"> UML图</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8ff43da41de3888e305c2fa0ddf80ffb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*xN0tlKBcb7dViIXHmcZPtg.png"/></div></figure><p id="c98d" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">我们的高层是CustomerService，低层是MySqlImpl和PostgreSqlImpl，我们的抽象是CustomerRepository。</p><p id="52c3" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">客户服务(高级别)</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="19ff" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk">客户仓库(抽象)</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1e37" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk"> MySqlImpl(低级)</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="221f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><em class="nk"> PostgreSqlImpl(低级)</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="01e7" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这样，您与CustomerService一起使用的CustomerRepository的任何实现都将独立于唯一的数据库例如，如果您最终需要更改为SqlServer，您将依赖于另一个实现，而您的高级CustomerService不知道正在发生什么。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="c3a4" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">与本文相关的所有代码都可以在<a class="ae kv" href="https://github.com/pedroluiznogueira/java/tree/master/src/designprinciples/solid" rel="noopener ugc nofollow" target="_blank"> Project GitHub Repo </a>中找到。也可以以任何方式在GitHub上投稿，我们非常欢迎投稿。</p><h1 id="280d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">参考</h1><ol class=""><li id="8acb" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="https://www.amazon.com/dp/0596007124/?tag=javamysqlanta-20" rel="noopener ugc nofollow" target="_blank"> <em class="nk">头像第一个图案</em> </a>，卡西塞拉和伊丽莎白罗布森</li><li id="d2e7" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://www.amazon.com/Design-Patterns-Java-paperback-Software/dp/0134277880/?tag=javamysqlanta-20" rel="noopener ugc nofollow" target="_blank"><em class="nk">Java中的设计模式</em> </a>，威廉·c·威克</li><li id="ced6" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="http://staff.cs.utu.fi/~jounsmed/doos_06/material/DesignPrinciplesAndPatterns.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="nk">设计原则和设计模式</em> </a>，罗伯特·c·马丁</li><li id="24a3" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=cPH5AiqLQTo" rel="noopener ugc nofollow" target="_blank"> <em class="nk">干净的建筑</em> </a>，汤姆·洪伯格</li></ol></div></div>    
</body>
</html>