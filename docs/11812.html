<html>
<head>
<title>Corrupted Hard Drive? Python to the Rescue!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">损坏的硬盘？巨蟒来救援了！</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/corrupted-hard-drive-python-to-the-rescue-6feb2a9e0422?source=collection_archive---------8-----------------------#2022-04-19">https://betterprogramming.pub/corrupted-hard-drive-python-to-the-rescue-6feb2a9e0422?source=collection_archive---------8-----------------------#2022-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="546b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">当其他方法都失败时，我如何用一个简单的Python脚本保存了一年的工作成果的故事</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/f2b869fbe363e31611d6ee516503ba8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8mFoS4QHc9t8BUIAVQeetg.jpeg"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">https://www.pexels.com/@george-milton/<a class="ae kw" href="https://www.pexels.com/@george-milton/" rel="noopener ugc nofollow" target="_blank">乔治·米尔顿摄</a></p></figure><p id="fda0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在当今的云世界和无尽的高级备份解决方案中，将您最珍贵的项目存储在简单的外置硬盘上听起来可能有点过时，但正如我最近了解到的那样(违背我的意愿)，这似乎仍然是音乐家的首选。</p><h2 id="acac" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">我的(非常具体的)问题</h2><p id="f2b0" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">因此，当我丈夫的一个外置硬盘决定发出嘎嘎声时，我正在过一个<em class="mr">有趣的</em>周末。这也是他存储所有最新音乐项目的地方，他的音乐流的声音效果和我所知道的能让他获得音乐版权的叫做“茎”的东西。<em class="mr">不好玩。</em></p><p id="3227" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">所以为了省下几天时间去安慰他失去了整整一年的工作，我决定先潜水，试着尽可能多地保存他的数据——使用我在互联网上搜索的传统方法，就像我是一个聪明的技术人员一样。</p><p id="6e8d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这很快被证明是徒劳的:磁盘似乎布满了随机不可读的扇区，不仅毫无理由地减慢了任何扫描可怜的磁盘钻或等效应用程序试图做的事情，而且任何自动或手动备份的尝试最终都被随机卸载的磁盘中断，每当程序遇到障碍时就重新安装。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ms"><img src="../Images/d7dbd0abdc5591032b887b50696c0908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FGYlT2GxbzmITNWnQYtLtg.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">使用磁盘钻取对剩余备份时间的实际估计。就上下文而言，8489小时是354天，或者说不到一年。</p></figure><p id="b772" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">唯一可取的是，磁盘仍然是可检测的，并且(无论多慢)可读的。我很有耐心地发现，复制单个文件实际上是可行的，如果它们没有被破坏，它会以相对正常的速度发生。</p><p id="be67" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，为了保存尽可能多的数据，必须检查每个文件并尝试复制它，然后等待看它是否工作，或者文件是否引发I/O错误。哈！但是我们在这里讨论的是500GB的数据，这些数据分布在不同的目录、子目录和子目录中……是时候放弃了，对吗？<strong class="kz ir">不会，因为我们可以自动完成这项工作！</strong></p><h1 id="8a60" class="mt lu iq bd lv mu mv mw ly mx my mz mb jw na jx me jz nb ka mh kc nc kd mk nd bi translated">Python解决方案</h1><p id="cbe5" class="pw-post-body-paragraph kx ky iq kz b la mm jr lc ld mn ju lf lg mo li lj lk mp lm ln lo mq lq lr ls ij bi translated">由于问题的特殊性，我不得不为文件备份编写一个非常特殊的脚本，但是当所有其他方法都失败时，这个解决方案的一部分可能对同病相怜的人有用。</p><p id="ec06" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">以下是我的脚本的路线图:</p><h2 id="0f8f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated"><strong class="ak"> 1。在备份iCloud目录中复制目录树</strong></h2><ul class=""><li id="9176" class="ne nf iq kz b la mm ld mn lg ng lk nh lo ni ls nj nk nl nm bi translated">选择要备份的文件夹子集</li><li id="1590" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">对于每个找到的文件夹，在备份位置创建一个同级文件夹</li><li id="1085" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">保留每个找到的文件夹中包含完整路径的单个文件的列表(将在步骤2中复制)</li><li id="1a79" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">保存文件列表以备将来检索</li></ul><p id="17ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这一步的代码是:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="75f4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">根据目录和子目录的数量，这本身可能需要一段时间，但在它的末尾，我们有一个所有单个文件的列表，以及它们在硬盘驱动器中的完整路径。</p><p id="c47c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我之所以选择这个选项，而不是在遍历目录时复制每个文件，只是因为备份需要很长时间，而且经常会被不可预见的错误中断。这样我只整理一次清单，以后可以参考。</p><p id="514a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果您怀疑脚本会在某个时候崩溃，不要忘记将列表保存到文件中！我对<code class="fe nu nv nw nx b">numpy</code>很着迷，所以我是这样做的:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="73cd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一个更聪明的选择可能是将每个路径写到循环本身的一个文件中，所以这是任何不幸的人必须重现这一点的家庭作业。</p><h2 id="bf39" class="lt lu iq bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated"><strong class="ak"> 2。将每个文件拷贝到iCloud上它的兄弟位置</strong></h2><ul class=""><li id="f512" class="ne nf iq kz b la mm ld mn lg ng lk nh lo ni ls nj nk nl nm bi translated">加载文件列表</li><li id="e4f2" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">初始化一个标志数组来跟踪进程——如果您仍然不知道您试图捕获哪些错误以及未捕获的错误会中断循环，这很有帮助。对于将来分析节省了多少磁盘空间和丢失了多少磁盘空间也非常有用。</li><li id="1ab9" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">尝试/except复制每个文件，并根据成功或捕获的异常更新标志数组</li></ul></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="61fe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我很快注意到并不是所有的子目录都是在<code class="fe nu nv nw nx b">os.walk()</code>循环中创建的，所以我首先必须根据文件列表对其进行处理:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="af15" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我还决定编写一些逻辑来处理复制时间过长的文件——有时它们不会抛出错误，但会减慢整个过程，这是我想要避免的:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="7566" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后，实际的备份循环:</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e009" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你会注意到我记录了几个不同的错误，原因如下:</p><ul class=""><li id="1b28" class="ne nf iq kz b la lb ld le lg of lk og lo oh ls nj nk nl nm bi translated"><code class="fe nu nv nw nx b"><strong class="kz ir">FileNotFoundError</strong></code> <strong class="kz ir"> </strong> —当磁盘随机卸载并重新装载或者根本找不到文件时引发。为了跟踪这两种情况，我添加了<code class="fe nu nv nw nx b">time.sleep(120)</code>来允许磁盘重新挂载，以及一个计数器(<em class="mr"> j </em>)来记录文件被尝试的次数。如果它连续失败两次，我会跳过它，并将其标记为未找到(flag -1)</li><li id="5637" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated"><code class="fe nu nv nw nx b"><strong class="kz ir">IOError</strong></code></li><li id="053a" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">我给每个文件最多5分钟的复制时间。如果超过了这个时间限制，就会引发超时异常并进行标记(-3)。如果这些文件太大或太重要而不能跳过，那么可以重新访问其中的一些文件。</li><li id="5bc4" class="ne nf iq kz b la nn ld no lg np lk nq lo nr ls nj nk nl nm bi translated">所有其他异常都标有-999，表示它们不属于上述情况(如果我们想更详细地检查它们，还可以再次查看)。</li></ul><p id="c718" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就是这样！</p><p id="5816" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当高级应用程序甚至无法恢复一个字节时，这种简单的基于Python的方法设法在这个损坏的外部驱动器上保存了78%的重要数据。就时间而言，编写脚本用了不到半个小时，排除故障用了一个小时左右，而备份本身用了大约两天时间(如果这听起来太长，请记住估计需要8000多个小时的磁盘演练！).根据备份的大小和您的耐心，这甚至可以通过多处理进一步优化。</p><p id="c797" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最棒的是，它是免费的！</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oi"><img src="../Images/28017beb101287306acf3172f116ba4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQMbwRo67U4oY_YflZXFug.png"/></div></div><p class="ks kt gj gh gi ku kv bd b be z dk translated">所选“重要”目录中恢复的部件与丢失的部件的可视化对比。</p></figure><p id="7d6f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我现在要去给蟒蛇神献祭。</p></div></div>    
</body>
</html>