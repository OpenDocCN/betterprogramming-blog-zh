<html>
<head>
<title>Diving Into React Suspense Render-as-You-Fetch for REST APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为REST APIs投入React悬疑式即取即用渲染</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/diving-into-react-suspense-render-as-you-fetch-for-rest-apis-bf2d20ea7c59?source=collection_archive---------8-----------------------#2019-12-16">https://betterprogramming.pub/diving-into-react-suspense-render-as-you-fetch-for-rest-apis-bf2d20ea7c59?source=collection_archive---------8-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9769" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">取代基于useEffect的数据提取</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b99365b305bb64751a19ac7a8a19205a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ytHO7Lwl4aL0MV6bJECQGw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Lukasz Szmigiel 在<a class="ae ky" href="https://unsplash.com/s/photos/render?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5bbe" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="7c1d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">React释放实验通道上的并发模式和<a class="ae ky" href="https://reactjs.org/docs/concurrent-mode-suspense.html" rel="noopener ugc nofollow" target="_blank">暂停数据获取</a>。<em class="mu">此版本面向库作者，尚未面向生产应用。</em>提出的新数据提取模式被称为<em class="mu">即取即用</em>。</p><p id="30fe" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这篇文章主要讨论了基本Fetch调用的即取即用，比如调用REST APIs。但是，有些讨论并不局限于休息。</p><p id="5897" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">人们可以通过简单的获取调用来调用<a class="ae ky" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>端点。对于GraphQL更复杂的用例，也值得查看一下<a class="ae ky" href="https://relay.dev/docs/en/experimental/a-guided-tour-of-relay#advanced-data-fetching" rel="noopener ugc nofollow" target="_blank">中继文档</a>。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="9f4f" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">基于useEffect的数据提取的问题</h1><p id="66e9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">让我们首先讨论典型解决方案的问题，即在<code class="fe na nb nc nd b">useEffect</code>中开始取数据。</p><h2 id="c393" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">装载指示器太多</h2><p id="e4e1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">典型的基于useEffect的数据提取如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="b2f4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果我们在各种组件中使用这种模式，用户最终会在他们的屏幕上看到许多加载指示器。</p><p id="38f5" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们可以通过在父组件中拥有一个加载计数器并在子组件之间共享它来解决这个问题。</p><p id="4e86" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated"><code class="fe na nb nc nd b">Suspense</code>组件是这个问题的本地解决方案。</p><h2 id="1af0" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">获取调用运行太晚</h2><p id="b13b" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在上面的例子中，<code class="fe na nb nc nd b">fetchData</code>在<code class="fe na nb nc nd b">useEffect</code>中运行。只有在浏览器中绘制了所有组件后，它才会运行。这可能会很晚，也可能不会很晚，取决于应用程序。</p><p id="c682" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这在使用<code class="fe na nb nc nd b">React.lazy</code>时至关重要。Fetch调用只能在组件加载后调用。</p><p id="f590" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们希望启动一个fetch调用，同时加载一个组件。</p><h2 id="f5d2" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">获取呼叫瀑布</h2><p id="0275" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">由于上面描述的时序，有一个特定的行为称为“瀑布”</p><p id="3e29" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果父组件处于加载状态，子组件将不会呈现，因此不会在<code class="fe na nb nc nd b">useEffect</code>中启动获取调用。只有当父组件中的获取调用完成时，子组件中的获取调用才能开始。</p><p id="75bd" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">请参考<a class="ae ky" href="https://reactjs.org/docs/concurrent-mode-suspense.html#approach-1-fetch-on-render-not-using-suspense" rel="noopener ugc nofollow" target="_blank">React文档</a>中的瀑布示例。</p><h2 id="d00d" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">麻烦的useEffect deps/useCallback</h2><p id="3f5a" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">建议将<code class="fe na nb nc nd b">useEffect</code>中使用的道具放在<code class="fe na nb nc nd b">useEffect</code>第二个参数的deps中。出于某种原因，如果你需要提前创建一个函数，它应该由<code class="fe na nb nc nd b">useCallback</code>来包装。</p><p id="974c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">典型的自定义挂钩如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="ef84" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这种模式对于初学者来说不是很容易。可以说<code class="fe na nb nc nd b">useEffect</code>被过度用于数据抓取，或者更准确的说，在<code class="fe na nb nc nd b">Suspense</code>落地之前，一直没有其他手段。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="bfe5" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">用“反应悬念”进行不同的思考</h1><p id="9192" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">“随取随渲染”需要你以不同的方式思考。否则，很难理解新模式的库。以下是理解新格局的一些随机点。</p><h2 id="3ec4" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">不要使用效果</h2><p id="603e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">不要把远程数据当成道具的效果。在创建元素的同时创建它。</p><p id="2238" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">伪代码是这样的:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="07b7" class="ne lh it nd b gy nw nx l ny nz">const fetchRemoteData = ...;<br/>const Component = ...;</span><span id="04eb" class="ne lh it nd b gy oa nx l ny nz">const remoteData = fetchRemoteData();<br/>&lt;Component remoteData={remoteData} /&gt;</span></pre><h2 id="9c49" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">将远程数据作为道具传递或存储在状态中</h2><p id="0967" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">将提取数据作为道具与其依赖的道具一起传递。</p><p id="c589" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">伪代码是这样的:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="1a44" class="ne lh it nd b gy nw nx l ny nz">const Component = ({ useId, userData }) =&gt; {<br/>  // userData is remote data fetched with `userId`<br/>  // ...<br/>};</span></pre><p id="32ad" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">或者，直接保持在状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="0f06" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">像对待本地数据一样对待远程数据</h2><p id="9b16" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">由于悬念，渲染代码不需要关心数据是本地可用还是远程获取。你可以直接用它。</p><p id="07ab" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">伪代码是这样的:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="9931" class="ne lh it nd b gy nw nx l ny nz">const Component = ({ localData, remoteData }) =&gt; (<br/>  &lt;div&gt;<br/>    &lt;div&gt;Local Name: {localData.name}&lt;/div&gt;<br/>    &lt;div&gt;Remote Name: {remoteData.name}&lt;/div&gt;<br/>  &lt;/div&gt;<br/>);</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="dfc9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">提取即渲染的用例</h1><p id="aad3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在，让我们考虑一下，如果我们有一个好的库，我们如何使用“取即渲染”模式。</p><p id="8747" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">我们假设我们有一个允许创建可挂起结果的库，它可以像本地数据一样使用。这意味着，如果结果没有准备好，它将抛出一个承诺。</p><h2 id="d5ed" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">单次提取</h2><p id="a743" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">最简单的例子是一个取一次的调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="6943" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">多重提取</h2><p id="2c14" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果我们需要并行运行两个fetch调用，我们可以同时创建它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="d57e" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">至于结果是一次显示还是一个接一个显示，这完全取决于你如何在树中放置<code class="fe na nb nc nd b">&lt;Suspense&gt;</code>。</p><p id="5ecf" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">查看API文档以了解更多关于如何使用<code class="fe na nb nc nd b">Suspense</code>和<code class="fe na nb nc nd b">SuspenseList</code>的信息。</p><h2 id="9c9e" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">动态获取</h2><p id="31d9" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">数据获取并不总是静态的，我们可能需要动态地获取数据。例如，如果用户单击一个按钮来重新运行fetch，我们需要这样一个状态。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="027d" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这是回调中预取的一个例子，但是这种模式可以应用于所有非React回调。只是简单地把它当作把可挂起的结果输入到一个反应树中。</p><h2 id="f17d" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">增量提取</h2><p id="a8d0" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果两个fetch调用是相关的，并且我们想要向用户显示中间状态，我们需要增量加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6db4" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">它一可用就显示<code class="fe na nb nc nd b">Person Name</code>，并显示<code class="fe na nb nc nd b">Loading films…</code>直到它们准备好。</p><p id="987c" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这需要一个窍门。预取中的<code class="fe na nb nc nd b">person =&gt; person.films</code>功能可以暂停，就像React渲染可以暂停一样。不然我们不知道什么时候开始取片。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="28e6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">代理的使用</h1><p id="6e1f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果我们想像对待本地数据一样对待远程数据，避免间接性是很重要的。<a class="ae ky" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank">代理</a>允许这样的接口。</p><p id="28fc" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">使用代理，我们可以像下面这样做:</p><pre class="kj kk kl km gt ns nd nt nu aw nv bi"><span id="7896" class="ne lh it nd b gy nw nx l ny nz">console.log(result.name); // throws a promise until it's resolved</span><span id="3dfa" class="ne lh it nd b gy oa nx l ny nz">console.log(result.name); // works as expected after that</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="221d" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">缓存注意事项</h1><p id="4517" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们如何处理缓存很重要。我们目前的方法是不提供全局缓存。缓存是一个难题。相反，我们只是像普通数据一样存储结果。它非常直观，适用于简单的用例。</p><p id="3b80" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">对于数据规范化的复杂缓存方法，请查看这些不同的项目。</p><ul class=""><li id="0963" class="ob oc it ma b mb mv me mw mh od ml oe mp of mt og oh oi oj bi translated"><a class="ae ky" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">阿波罗客户端</a></li><li id="6706" class="ob oc it ma b mb ok me ol mh om ml on mp oo mt og oh oi oj bi translated"><a class="ae ky" href="https://swr.now.sh/" rel="noopener ugc nofollow" target="_blank"> SWR </a></li><li id="740e" class="ob oc it ma b mb ok me ol mh om ml on mp oo mt og oh oi oj bi translated"><a class="ae ky" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank">继电器</a></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="84c4" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">实验项目</h1><p id="2002" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我们上面描述的不是梦想，我们一直在开发一些实验库。它们是正在进行的项目，将来不会反映这篇文章中所描述的内容。</p><h2 id="b587" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">反应-暂记-提取</h2><div class="op oq gp gr or os"><a href="https://github.com/dai-shi/react-suspense-fetch" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">代时/反应-悬念-获取</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">REST APIs的即时渲染模式新的即时渲染模式令人震惊。到目前为止…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><p id="b3c2" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">该项目提供了上述的<code class="fe na nb nc nd b">prefetch</code>。它的实现实际上与React无关，但它遵循了抛出承诺的约定。</p><p id="a623" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">请注意，API可能会很快发生变化。</p><h2 id="88b6" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">反应-挂钩-获取</h2><div class="op oq gp gr or os"><a href="https://github.com/dai-shi/react-hooks-fetch" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">戴式/反应钩取</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">如果你正在寻找用于Fecth API的React钩子，请访问…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg ks os"/></div></div></a></div><p id="6158" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">这个项目是为反应悬念提供挂钩。虽然不是现在，它将基于反应-暂停-获取。</p><p id="8ae6" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">API也将很快改变。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="7e32" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结束语</h1><p id="07a4" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">提取即渲染是一种全新的模式，基于<code class="fe na nb nc nd b">useEffect</code>的数据提取将会过时。</p><p id="661a" class="pw-post-body-paragraph ly lz it ma b mb mv ju md me mw jx mg mh mx mj mk ml my mn mo mp mz mr ms mt im bi translated">如果很多开发者讨论这个话题，提出各种想法和用例，那就好了。</p></div></div>    
</body>
</html>