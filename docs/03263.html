<html>
<head>
<title>Dynamically Remove Children From a DOM Element in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中动态移除DOM元素的子元素</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamically-removing-children-from-a-dom-element-in-javascript-new-node-new-you-6143dabaea89?source=collection_archive---------8-----------------------#2020-01-30">https://betterprogramming.pub/dynamically-removing-children-from-a-dom-element-in-javascript-new-node-new-you-6143dabaea89?source=collection_archive---------8-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2dca" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">新节点，新的你</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a8441d61e4abe274cb101de0285e5527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbYLDYXkxoYAMpsgHhstXg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约翰·施诺布里奇在<a class="ae kv" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下:你已经完成了用HTML/CSS创建一个伟大的动态页面的所有工作，还在上面洒了一点JavaScript。</p><p id="45c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你已经有了一个<code class="fe ls lt lu lv b">list</code>或<code class="fe ls lt lu lv b">div</code>,里面展示了各种各样的精彩内容，而且你从未对它的外观感到如此自豪。</p><p id="cc39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了——拿着手机——当你去过滤它或重新渲染数据时，它只是在你已经渲染的数据上添加内容！列表在不断增长，你的滚动条也在一秒一秒地变长。程序员要做什么？</p><p id="4e38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题可以分解为一个容易诊断的问题和一个容易规定的修复方法:</p><ol class=""><li id="f4c7" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">您的页面或应用程序试图根据动态过滤器或更新的数据库将新信息呈现到HTML容器中，但它是在已经显示的内容上添加信息，而不是刷新容器。</li><li id="7290" class="lw lx iq ky b kz mf lc mg lf mh lj mi ln mj lr mb mc md me bi translated">为了解决这个问题，我们需要“刷新”DOM中的元素。有多种方法可以做到这一点，但是我们将只关注一种方法:删除该元素已经存在的“子元素”。</li></ol></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="8741" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">问题</h1><p id="dff6" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">假设这是您正在处理的代码的相关部分，来自一个列出动物并允许您在搜索栏中输入文本并动态过滤显示的动物的页面:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/618f2dd2875b3383808631a5fc993f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TMgWa0m6aAQhDDc3nTUgA.png"/></div></div></figure><p id="0688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有一个搜索栏(<code class="fe ls lt lu lv b">form</code>)和一个容器(<code class="fe ls lt lu lv b">div</code>)，通过<code class="fe ls lt lu lv b">.querySelector</code>保存到HTML的变量中。您已经在搜索中设置了一个监听器，它根据用户在该领域的输入，实时过滤所有动物的数组。</p><p id="cd99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">过滤后的数组作为参数发送给呈现函数，该函数将改变附加到容器中并显示在页面上的结果。简单吧？</p><p id="8d49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，这里缺少的是完成交付件的一段关键代码。每次调用<code class="fe ls lt lu lv b">handleInput</code>函数时，它都会呈现一个新过滤的动物数组，并将其添加到之前呈现的数组中。</p><p id="cbdd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次搜索栏中的输入改变时都会发生这种情况，一次一个字符，所以现在你的页面上有了一大堆动物。缺少什么关键代码？</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d8d3" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">修复</h1><p id="ff96" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated"><code class="fe ls lt lu lv b">renderAnimals</code>函数在不“刷新”容器的情况下渲染一个新的过滤动物数组。</p><p id="b9ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种“刷新”是通过在新渲染到节点中之前移除已经存在的节点子节点来完成的。这可以通过两种方式之一用纯JavaScript代码简单地完成:</p><h2 id="e969" class="nq ms iq bd mt nr ns dn mx nt nu dp nb lf nv nw nd lj nx ny nf ln nz oa nh ob bi translated">1.使用<em class="oc"> while </em>循环和。移除孩子</h2><p id="7884" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">被渲染到容器中的每个动物都是该父节点的“子节点”，即<code class="fe ls lt lu lv b">animalContainer</code> <em class="np"> </em> div，可以通过一个<code class="fe ls lt lu lv b">while</code>循环动态地一次移除一个。</p><p id="5a19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现有的代码如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/739df59fd988b0f570fbb5ec24837653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*rFFL6wi-4V99QpBAuoCGig.png"/></div></figure><p id="42bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们更新后的代码如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/2640751a7178e0d03f1c925cd5f44008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkSHeQrLtwateooLd-YpOg.png"/></div></div></figure><p id="5734" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">while</code>循环检查<code class="fe ls lt lu lv b">animalContainer.firstChild</code>是否返回<code class="fe ls lt lu lv b">true</code>，确认至少存在一个子元素。它用<code class="fe ls lt lu lv b">.removeChild()</code> <em class="np">，</em>删除那个孩子，然后重复循环，直到不再有孩子存在。</p><p id="990f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器现在是空的，可以用动态过滤的数据重新填充了！该函数将继续其定期计划的渲染。</p><h2 id="f304" class="nq ms iq bd mt nr ns dn mx nt nu dp nb lf nv nw nd lj nx ny nf ln nz oa nh ob bi translated">2.使用。innerHTML来完全重置容器</h2><p id="1ae5" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">另一种选择稍微不那么优雅和“程序化”，但同样有效。您可以一次清除整个容器，而不是使用循环来遍历每个子元素:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/98e82b13f05b1c0b8d2ab1706e8ddb46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*xYBbgEMmr9cnjFhn2uL4IQ.png"/></div></figure><p id="fc48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ls lt lu lv b">animalContainer</code> <code class="fe ls lt lu lv b">div</code>上使用<code class="fe ls lt lu lv b">.innerHTML</code> <em class="np"> </em>方法允许您在向其中呈现新信息之前，简单地将其中的所有HTML代码设置为一个空字符串，有效地一次性销毁所有子元素，而不是一次删除一个。</p><h2 id="f285" class="nq ms iq bd mt nr ns dn mx nt nu dp nb lf nv nw nd lj nx ny nf ln nz oa nh ob bi translated">为什么用一个而不用另一个？</h2><p id="edc1" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">这两种方法做的事情完全一样，但做起来略有不同。决定哪一个更适合您的应用程序和DOM真的取决于您。</p><p id="cff3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些可以应用于页面上的任何父元素，该元素包含您想要移除的子元素，无论父元素是<code class="fe ls lt lu lv b">div</code>、<code class="fe ls lt lu lv b">ul</code>还是其他元素。</p><p id="1912" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与一次清除所有元素相比，使用循环的主要优势在于，如果您希望对保留多少子元素有更多的控制。</p><p id="ae48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过一个更复杂的循环来指定只删除一定数量的内容，通过在循环中运行<code class="fe ls lt lu lv b">if else</code>语句来过滤您想要删除的子项，等等<em class="np">。</em></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="845f" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">结论</h1><p id="c4d7" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果您已经读到这里，那么现在您已经获得了一个新的、方便的JavaScript动态DOM编程工具。希望它能很好地为您服务，并为您现在和将来的项目开辟一些新的思路。</p></div></div>    
</body>
</html>