<html>
<head>
<title>Custom Validation in Spring Boot Explained Through Cases, Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过案例解释Spring Boot的自定义验证，第2部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/custom-validation-in-spring-boot-best-explained-part-2-f99bfb4e66a4?source=collection_archive---------17-----------------------#2022-09-12">https://betterprogramming.pub/custom-validation-in-spring-boot-best-explained-part-2-f99bfb4e66a4?source=collection_archive---------17-----------------------#2022-09-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9e5a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例2——使用数据库实现“主-细节”验证</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ed24b32db2369002ce1af476064f88d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XEPIB9qPo4wd4pyA"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迈克尔·泽兹奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="a904" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="c2d2" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是如何在Spring Boot实现自定义验证的第二部分。因此，为了让您更好地理解，如果您之前已经经历过<a class="ae ky" href="https://medium.com/@zzpzaf.se/custom-validation-in-spring-boot-best-explained-part-1-1105a8c2711" rel="noopener">案例1 </a>就更好了:</p><div class="mn mo gp gr mp mq"><a rel="noopener  ugc nofollow" target="_blank" href="/custom-validation-in-spring-boot-best-explained-part-1-1105a8c2711"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">通过案例解释Spring Boot的自定义验证，第1部分</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">探索用数组进行验证等等</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">better编程. pub</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne ks mq"/></div></div></a></div><p id="e0f5" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">正如我们在开始时提到的，我们现在准备实现一个“主-细节”定制验证示例。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/405160dff5c537dfa120f83861ac8258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-B6ZNgBIpoZ79-md.png"/></div></div></figure><h1 id="62a6" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">问题是</h1><blockquote class="nl"><p id="13fc" class="nm nn it bd no np nq nr ns nt nu mm dk translated">像我这样“成熟”的人可能对术语(或概念)“主细节”很熟悉无论是在我们使用MS-DOS的“古代”，还是在我们必须为给定的订单带来产品——细节——主数据的时候</p></blockquote><p id="38a1" class="pw-post-body-paragraph lr ls it lt b lu nv ju lw lx nw jx lz ma nx mc md me ny mg mh mi nz mk ml mm im bi translated">假设您想要控制销售POST请求，并且您想要将销售仅限于给定供应商(“主”)的特定类别(“细节”)的项目。假设您希望限制所有或部分供应商销售仅属于每个供应商特定类别的商品。</p><p id="f307" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">例如，一个带有<code class="fe oa ob oc od b"> vendorId = 2</code>的卖家允许你发布带有<code class="fe oa ob oc od b">categoryId</code>的<code class="fe oa ob oc od b">{2, 17, 33, 5, 28}</code>的商品。带有<code class="fe oa ob oc od b">vendorId = 7</code>的卖家可以发布带有<code class="fe oa ob oc od b">categoryId</code> : <code class="fe oa ob oc od b">{3, 12, 41, 28}</code>的商品，以此类推。</p><p id="63f6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">最初，您可能认为如果我们在前面的案例上做更多的工作，这是可以实现的。也许您是对的，但是您应该花更多的精力使用两个字段来定义自定义验证:供应商和类别。你可以自己尝试，也可以按照下面的例子来做。</p><h1 id="fb07" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据准备</h1><p id="e868" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">正如我们已经说过的，这里我们将实现一个基于数据库的解决方案。这允许我们在数据库层中定义示例case逻辑，使我们的代码独立于固定的数据值。</p><p id="d6bc" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">为了简化我们的示例，我们必须定义三个主数据库表和最后一个多对多表:</p><ul class=""><li id="30f3" class="oe of it lt b lu nf lx ng ma og me oh mi oi mm oj ok ol om bi translated"><code class="fe oa ob oc od b">CATEGORIES </code> —用于物品类别</li><li id="b861" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated"><code class="fe oa ob oc od b">VENDORS</code> —针对供应商、品牌等。,</li><li id="35d0" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated"><code class="fe oa ob oc od b">ITEMS </code> —用于物品</li><li id="c5e1" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated"><code class="fe oa ob oc od b">VENDORCATEGORIES </code> —用于将<code class="fe oa ob oc od b">vendorId</code>与允许的<code class="fe oa ob oc od b">categoryIds</code>匹配</li></ul><p id="b47b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">三个主要表格不言自明:</p><p id="4658" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe oa ob oc od b">CATEGORIES</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/1fa86f97688ba53dfabea2ebe0c158fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RmJLZXCsxe3_cVNo.png"/></div></div></figure><p id="75db" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe oa ob oc od b">VENDORS</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/077fe0de612e8d75fa20da9422822148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/0*j26aesgDkTtGnj2q.png"/></div></figure><p id="da8b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe oa ob oc od b">ITEMS</code></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/bd68cdf93efe93d439be5979153f682b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AEX_A-z3rzIUNz18.png"/></div></div></figure><p id="84dc" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe oa ob oc od b">VENDORCATEGORIES</code></p><p id="634a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">最后，对于我们的逻辑，我们还必须定义一个多对多表，即表。<code class="fe oa ob oc od b">VENDORCATEGORIES</code>表用于将一个<code class="fe oa ob oc od b">vendorId</code>与<code class="fe oa ob oc od b">categoryIds</code>匹配，它们被允许发送物品销售的post请求。</p><p id="cfa8" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这里的方法是再使用一列(布尔列<code class="fe oa ob oc od b">0</code>或<code class="fe oa ob oc od b">1</code>)来表示特定的供应商是否允许某个特定的类别。将<code class="fe oa ob oc od b">true</code>切换到<code class="fe oa ob oc od b">false</code>，反之亦然，可以快速允许/禁止类别(无需添加或删除条目)。对于我们的例子，只定义两个供应商就足够了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/cb152848b6dfadeea2be5fff18cd3fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/0*e81eAWN3IME1mnVq.png"/></div></figure><h1 id="d702" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">数据库ˌ资料库</h1><p id="629c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">作为数据库，我们要用<a class="ae ky" href="https://mariadb.org/" rel="noopener ugc nofollow" target="_blank"> MariaDB </a>。MariaDB是MySQL 的开源(二进制)替代品。如果您尚未在您的计算机上安装它，您可以通过选择以下两个选项之一来完成:</p><ul class=""><li id="7379" class="oe of it lt b lu nf lx ng ma og me oh mi oi mm oj ok ol om bi translated"><a class="ae ky" href="https://www.devxperiences.com/pzwp1/2022/05/21/installing-and-using-mariadb-via-docker/" rel="noopener ugc nofollow" target="_blank">通过Docker </a>安装和使用MariaDB</li><li id="8e57" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated"><a class="ae ky" href="https://www.devxperiences.com/pzwp1/2021/01/08/install-mariadb-10-5-8-ga-via-homebrew-on-macos/" rel="noopener ugc nofollow" target="_blank">安装MariaDB (10.5.8。-GA)通过macOS上的自制软件</a></li></ul><p id="04e4" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">如果您想了解如何将REST API项目连接到MariaDB，需要添加到项目的<code class="fe oa ob oc od b">pom.xml</code>中的Maven <a class="ae ky" href="https://mvnrepository.com/artifact/org.mariadb.jdbc/mariadb-java-client" rel="noopener ugc nofollow" target="_blank"> MariaDB依赖关系</a>是什么，并开始使用MariaDB数据库，请看看我下面的文章:</p><div class="mn mo gp gr mp mq"><a href="https://blog.devgenius.io/quick-intro-to-rest-api-development-with-spring-boot-64583dabbe8c" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd iu gy z fp mv fr fs mw fu fw is bi translated">Spring Boot Rest API开发快速入门</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">一个快速、简单、解释清晰且真正有效的Spring Boot REST API项目。提供回购！</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">blog.devgenius.io</p></div></div><div class="mz l"><div class="ow l nb nc nd mz ne ks mq"/></div></div></a></div><p id="c287" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在是时候开始使用MariaDB数据库创建表并添加上面的采样数据了。你可以通过使用你的终端和<a class="ae ky" href="https://mariadb.com/kb/en/mysql-command-line-client/" rel="noopener ugc nofollow" target="_blank"> MySQL CLI </a>或者使用GUI，比如<a class="ae ky" href="https://www.mysql.com/products/workbench/" rel="noopener ugc nofollow" target="_blank"> MySQL Workbench </a>或者基于web的<a class="ae ky" href="https://www.phpmyadmin.net/" rel="noopener ugc nofollow" target="_blank"> phpMyAdmin </a>来实现。其他工具也可以。</p><p id="c9ad" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">为了方便起见，下面是可用于生成表并将采样数据添加到表中的SQL脚本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="6497" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><strong class="lt iu">注</strong>:该。带有上述脚本的sql文件也包含在下面的启动存储库中。</p><h1 id="2622" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">项目的起始存储库</h1><p id="2598" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，一切顺利。现在是时候开始实现我们的“主-细节”自定义验证了。</p><p id="041a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">👉我们的起点将是这个<a class="ae ky" href="https://github.com/zzpzaf/customvalidation2/tree/3ac01cee488fffb97256cb1ec9c99ca31d98de24" rel="noopener ugc nofollow" target="_blank">回购</a> (the。zip文件<a class="ae ky" href="https://github.com/zzpzaf/customvalidation2/archive/3ac01cee488fffb97256cb1ec9c99ca31d98de24.zip" rel="noopener ugc nofollow" target="_blank">此处</a>)。repo是一个简单的REST API应用程序，用于处理我们之前见过的MariaDB数据库中的数据表。</p><p id="3370" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">它公开了三个主表(实体)的三个主要端点:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/9098d9b5c3f62bb2b6cf2039d9c49117.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IdhidRUtResoHnox.png"/></div></div></figure><p id="113d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">repo为上述实体/端点提供所有标准的<a class="ae ky" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener ugc nofollow" target="_blank"> CRUD操作</a>。</p><p id="c8f1" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">项目结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/836285af38981df791af7750c4c7b40b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U7ENBlfqz8MEEVKa.png"/></div></div></figure><p id="bbb9" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">正如您所看到的，这里有所有的“标准”包(项目文件夹):</p><p id="d028" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">–服务于端点的控制器<br/>–数据类的数据对象和数据传输对象(dto)<br/>–通过JDBCTemplate和原始SQL查询访问数据库数据的存储库。</p><p id="a7fa" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">请注意:我们已经在<code class="fe oa ob oc od b">Validators</code>文件夹包中留下了<code class="fe oa ob oc od b">OneOfIntegers</code>定制验证文件，只是为了在任何情况下您都想使用我们之前的案例/例子中的约束。然而，我们已经移除了(实际上，我们已经注释掉了)这个为<code class="fe oa ob oc od b">itemDTO.java</code>文件中的<code class="fe oa ob oc od b">itemVendorId</code>字段定制的约束注释。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/edc20d835378a89836b9c486323ca6d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uXC8fpw8wjy_govw.png"/></div></div></figure><p id="f437" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这是因为我们将为字段<code class="fe oa ob oc od b">itemVendorId</code>和<code class="fe oa ob oc od b">itemCategoryId</code>的组合实现我们的“主-细节”定制验证。</p><p id="082d" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">最后，请注意，正如我们已经说过的，我们不会使用JPA/Hibernate或任何其他ORM，我们也避免了拥有单独的服务类。</p><h1 id="8cee" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated"><code class="fe oa ob oc od b">Maven/pom.xml</code>依赖关系</h1><p id="76a3" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面给出了为MariaDB和核心JDBC功能(JDBCTemplate)添加到我们的<code class="fe oa ob oc od b">pom.xml</code>中的依赖项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h1 id="321a" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">MariaDB连接参数</h1><p id="f77b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">下面是添加到<code class="fe oa ob oc od b">application.properties </code>文件中的连接参数(在参考资料中):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><h1 id="0520" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">“主-详细信息”自定义验证的实现</h1><p id="df47" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们所要做的，与我们在之前的案例中所做的非常相似。</p><p id="9caa" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">首先，让我们将新的定制注释命名为<code class="fe oa ob oc od b">DBMasterDetails</code>。</p><p id="ccb9" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">之后，我们必须创建<code class="fe oa ob oc od b">DBMasterDetails</code>验证接口和<code class="fe oa ob oc od b">DBMasterDetailsValidator</code>类。它们都位于Validators文件夹/包中。</p><p id="62de" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">下面给出了<code class="fe oa ob oc od b">DBMasterDetails</code>约束注释接口的初始版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="43b9" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">将它与前一个案例<code class="fe oa ob oc od b">OneOfIntegers</code>约束注释接口进行比较，我们可以分辨出一些变化:</p><ul class=""><li id="9883" class="oe of it lt b lu nf lx ng ma og me oh mi oi mm oj ok ol om bi translated">首先，我们将目标限制为字段类型(这里没有参数)。这是因为“主-细节自定义验证器”应该只应用于类(DTO)级别的字段，我们很快就会看到。</li><li id="b74b" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated">其次，我们必须为我们的“主-详细信息”自定义验证定义两个将参与组合的字段。这里，我们使用两个字符串变量，分别命名为<code class="fe oa ob oc od b">fieldName1</code>和<code class="fe oa ob oc od b">fieldName2</code>。</li><li id="7425" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated">最后，(也是最重要的)，我们还使用一个“内部”注释接口，它将处理我们将结合使用的<code class="fe oa ob oc od b">Itemdto</code>的两个字段(前面提到过的<code class="fe oa ob oc od b">itemVendorId</code>和<code class="fe oa ob oc od b">itemCategoryId</code>)。我们使用一个相同类型的注释接口的列表(一个数组)(<code class="fe oa ob oc od b">DBMasterDetails</code>)，我们将这个列表命名为<code class="fe oa ob oc od b">value</code>。</li></ul><p id="b46a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在让我们继续进行<code class="fe oa ob oc od b">DBMasterDetailsIDsValidator</code>类。</p><p id="ce2c" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">首先，我们必须获得先前定义的两个字段(在注释接口中)。类似地，对于前一种情况(带有<code class="fe oa ob oc od b">OneOfIntegersValidator</code>的情况)，我们通过覆盖<code class="fe oa ob oc od b">initialize()</code>方法来实现。</p><p id="e045" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">之后，我们可以读取它们的值，并通过检查它们是否为空来执行我们在<code class="fe oa ob oc od b">isValid()</code>方法中的第一次检查(否则，我们可以返回一个早期的<code class="fe oa ob oc od b">false</code>)。</p><p id="898b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">初始<code class="fe oa ob oc od b">DBMasterDetailsIDsValidator</code>等级如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="7937" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在我们可以继续构建<code class="fe oa ob oc od b">DBMasterDetailsIDsValidator</code>类，通过处理来自我们的回购协议的数据。为此，我们将在我们的<code class="fe oa ob oc od b">VendorsRepo</code>中添加一个方法(我们将其命名为<code class="fe oa ob oc od b">getVendorAllowedCategories()</code>),该方法应该用于从<code class="fe oa ob oc od b">vendorcategories</code>表中只获取允许的类别id(对于给定的<code class="fe oa ob oc od b">vendorId</code>)。</p><p id="4559" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated"><code class="fe oa ob oc od b">getVendorAllowedCategories()</code>(在<code class="fe oa ob oc od b">VendorsRepo.java</code>内部)如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="884a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">该方法将<code class="fe oa ob oc od b">vendorId</code>作为一个参数，并返回一个整数列表，其中为特定的<code class="fe oa ob oc od b">vendorId</code>启用(允许)了所有类别id。</p><p id="9d75" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在，我们通过将ItemsRepo类“自动连接”到<code class="fe oa ob oc od b">DBMasterDetailsIDsValidator</code>类来访问它。然后，在<code class="fe oa ob oc od b">isValid()</code>方法中，我们调用回购的<code class="fe oa ob oc od b">getVendorAllowedCategories()</code>方法，并向其传递在那里获得的<code class="fe oa ob oc od b">vendorId</code>值。最后，我们检查返回的类别id整数列表是否包含也在那里获得的<code class="fe oa ob oc od b">categoryId</code>。如果列表包含它，则验证成功。否则，它会失败。</p><p id="aa95" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">你可以在下面看到<code class="fe oa ob oc od b">DBMasterDetailsIDsValidator</code>类的更新版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="2f39" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">这里的最后一步是通过用我们的<code class="fe oa ob oc od b">DBMasterDetails</code>验证约束在类级别更新<code class="fe oa ob oc od b">ItemsDTO.java</code>来准备它。注释应该在类级别，因为它处理字段的组合(列表)。我们必须传递相关的字段名，如果我们愿意，还可以传递一条我们更喜欢的消息，而不是在验证注释接口中定义的消息。这是多么简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/7614ca86a45844cbb12c882caa80d4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wX7TP9gPakRnlWsX.png"/></div></div></figure><p id="9c22" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">请注意，我们没有向相关字段添加任何验证。(但是，您可以添加应用程序和/或业务逻辑所需的任何验证约束注释)。</p><p id="9675" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">现在，是测试的时候了！(使用邮递员)。下面，我们在POST请求中使用一个JSON body对象，其中<code class="fe oa ob oc od b">vendorId</code>的值为<code class="fe oa ob oc od b">2</code>，而<code class="fe oa ob oc od b">categoryId</code>的值为<code class="fe oa ob oc od b">1</code>(因此我们预计验证会失败)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/8a3f543781170edb108239184de9ffed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zqLILrKT0YbX1-nK.png"/></div></div></figure><p id="4292" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">正如你所看到的，这是不成功的(403错误请求)，正如我们所料。</p><p id="96bb" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">然后使用值<code class="fe oa ob oc od b">vendorId=2</code>和<code class="fe oa ob oc od b">categoryId=4</code>进行尝试，POST成功，一个新的条目被添加到条目表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/db80dd8a9fdfaecb191428cbe02eda59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HmIeqM2Ke6E-CnUs.png"/></div></div></figure><p id="205b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">👉你可以下载<a class="ae ky" href="https://github.com/zzpzaf/customvalidation2/tree/01da96dd0d50a1c9af91d78d1fff956c2d298f83" rel="noopener ugc nofollow" target="_blank">完整回购</a>和我们在这里看到的<a class="ae ky" href="https://github.com/zzpzaf/customvalidation2/archive/01da96dd0d50a1c9af91d78d1fff956c2d298f83.zip" rel="noopener ugc nofollow" target="_blank">的代码</a>！</p><h1 id="2104" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">丰富</h1><p id="2703" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">到目前为止，一切顺利！然而，我们的代码还有改进的空间。</p><h2 id="6de1" class="pa la it bd lb pb pc dn lf pd pe dp lj ma pf pg ll me ph pi ln mi pj pk lp pl bi translated">将全权委托给回购公司</h2><p id="3b7f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">一个小而快速的升级是将检查返回的类别id列表中是否存在<code class="fe oa ob oc od b">categoryId</code>字段值的任务委托给<code class="fe oa ob oc od b">VendorsRepo</code>的功能。例如，这可以通过向该回购添加一个方法来实现，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/719d3d5cdb44ee2dca2747c77d698f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LnJy0PjBIrBisheb.png"/></div></div></figure><p id="b57b" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">然后我们可以在“DBMasterDetailsValidator”中使用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/e69946a0b653b5c5db6a7f51ea74dd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Faefhd8ePr3zlMa.png"/></div></div></figure><h2 id="37f3" class="pa la it bd lb pb pc dn lf pd pe dp lj ma pf pg ll me ph pi ln mi pj pk lp pl bi translated">将特定消息传递到验证上下文中</h2><p id="ce7c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这是可以的。然而，这并不重要。最重要的是在验证不成功(403错误请求)的情况下给出更好的信息响应信息。到目前为止，我们只使用了一个通用消息(默认的或首选的消息，以及类级注释的字段定义)，例如，“无效的<code class="fe oa ob oc od b">itemVendorId</code>和/或<code class="fe oa ob oc od b">itemCategoryId</code>！”关于这两个领域。</p><p id="ed31" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">更好的方法是提供更具体的消息，通知导致失败的字段。</p><p id="54ea" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们可以区分许多不同的情况，但出于演示目的，我们可以停留在以下情况:</p><ul class=""><li id="49e0" class="oe of it lt b lu nf lx ng ma og me oh mi oi mm oj ok ol om bi translated">无效的供应商id</li><li id="8bb4" class="oe of it lt b lu on lx oo ma op me oq mi or mm oj ok ol om bi translated">此<code class="fe oa ob oc od b">Vendor</code>不允许<code class="fe oa ob oc od b">Category</code></li></ul><p id="0fb6" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我们可以通过取消默认验证上下文并重新构建它，传递导致失败的字段和所需的消息来实现这一点。下面，你可以看到我们可以添加到我们的<code class="fe oa ob oc od b">DBMasterDetailsValidator</code>类的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="3d52" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">然后我们可以在<code class="fe oa ob oc od b">isValid()</code>方法中检查这些情况，并相应地构建验证上下文。</p><p id="2538" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">下面给出了<code class="fe oa ob oc od b">DBMasterDetailsIDsValidator</code>类的更新版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ox oy l"/></div></figure><p id="b485" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">最后，您可以通过Postman测试它，并查看具体的消息:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/45df59f633e49c33602f47baa96c2d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yBB0k6Swq16p5xkT.png"/></div></div></figure><p id="05c4" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">或者</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/7c68ad055021bbc2332d7cfb52f6792d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FMa1n3EYE48naZNY.png"/></div></div></figure><p id="9e6e" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">当然，您可以进行任何其他定制的内部检查，并返回更详细的失败消息(例如，检查类别Id是否驻留在来自<code class="fe oa ob oc od b">CategoriesRepo</code>的<code class="fe oa ob oc od b">categoryIds</code>范围内)，但是现在您更清楚该如何做了！</p><p id="904e" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">就是这样！你做到了！</p><p id="4fc4" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">👉你可以在这里找到<a class="ae ky" href="https://github.com/zzpzaf/customvalidation2" rel="noopener ugc nofollow" target="_blank">整个回购的最终版本。下载最后一次提交(最终实现)。zip文件</a><a class="ae ky" href="https://github.com/zzpzaf/customvalidation2/archive/5cc509f94e16340b7e29244704070963d0583631.zip" rel="noopener ugc nofollow" target="_blank">此处</a>。用它来深入春天和Spring Boot冒险！</p><p id="6464" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">我希望你喜欢这篇文章！</p><p id="374a" class="pw-post-body-paragraph lr ls it lt b lu nf ju lw lx ng jx lz ma nh mc md me ni mg mh mi nj mk ml mm im bi translated">感谢阅读！👏</p></div></div>    
</body>
</html>