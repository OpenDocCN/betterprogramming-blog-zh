# 创建定制的高阶函数可以帮助你编写更抽象的 Swift 代码

> 原文：<https://betterprogramming.pub/creating-custom-higher-order-functions-can-help-you-write-more-abstract-swift-code-b0158793300e>

## 通过发明基于标准基础库的新的数组转换方法来改进您的 SDK

![](img/84a6fefd850a9035d084e3c6ffd4ba6b.png)

作者图片

假设我们的一个应用程序屏幕上有一个普通的表格视图。这个表视图的单元格包含两个标签:一个反映用户名，另一个反映这个用户拥有的手机型号。由于将域模型与视图模型分离被认为是一个好的实践，我们已经创建了两个实体来满足我们的需求。下面是它们的样子:

因此，`User`结构拥有我们需要的所有信息(是的，在现实生活中，它会有更多的属性，我知道)，而`ViewModel`结构拥有细胞构建所需的属性。为了构建一个表格视图，我们需要一组`ViewModel`对象。

客户端的要求是只显示年龄超过 21 岁的用户。因此，我们需要根据年龄过滤用户，然后从每个剩余的`User`中初始化一个`ViewModel` 。你会如何处理这种情况？让我猜猜，您将创建一个单独的函数，用于过滤一组用户并将其转换为一组视图模型，大致如下所示(方法可能有所不同):

看起来很安全。您正在传递一个以年龄作为谓词的用户数组，并且可以确保不显示小于 21 岁的用户。如果与此屏幕相关的业务需求保持不变，这种逻辑是完美的，但老实说，业务需求保持不变的频率有多高？

如果您的客户不仅要求按年龄过滤用户，还要求按他们拥有的手机型号过滤用户，该怎么办？或者，如果新的要求是只显示 30 岁以下的用户呢？

在我们的例子中，可能的谓词数量相对较少，所以向函数中添加一些参数可以解决这个问题。但是想象一下会有多乱。

为了保持功能的整洁和美观，您可以为每种情况指定一个单独的函数，并有一个方法列表来处理每个过滤选项，但是想象一下这些方法会有多少重复的代码。

如果重复代码被分离到一个函数中，第二种方法很好，但是如果我们有不止一个需要使用这种功能的类呢？在每个类中创建一个函数列表是正确的吗？不，不会的。抽象是这里的一个线索。

> 关于抽象的几句话:
> 
> “抽象是通过减少概念或可观察现象的信息内容进行概括的过程，通常是为了只保留与特定目的相关的信息。— [新世界百科](https://www.newworldencyclopedia.org/entry/abstraction)

因此，为了使上面例子中的功能对多个类可用，我们需要将其抽象化。要做到这一点，我们需要“减少特定类别的信息内容”，并“只保留与特定目的相关的信息”。这种情况下的信息是一个方法实现，所以我们需要创建一个“与特定目的相关”的函数，也就是说，将返回一个排序和映射元素的数组。

如果我们想让任何类扩展一些与数组相关的功能，在 Swift 中我们做一种反转 wy，提供一个具有这种功能的数组。

在我们的例子中，我们需要根据一些谓词从用户那里构建一个视图模型。因此，如果用户不满足某些要求，我们跳过它们。这意味着我们需要使用一个`map()`函数来将`User`转换成`ViewModel`，但是我们如何进行过滤呢？编写一个定制的高阶`mapif`函数会有所帮助:

现在，我们有了一个通用方法，它可以在任何可能的上下文中的任何数组上启动。它接受两个闭包，对数组的每个元素运行它们，并返回一个转换后的序列。看起来是这样的:

*   `condition`类型“Element - > Bool”的闭包接受某个元素，用该元素编译给定代码并返回一个布尔值
*   `mappingAction`类型“Element - > T”的闭包使用输入元素运行其代码，并返回另一个泛型类型的值`T`。

函数内部的逻辑和 SomeClass 的'`getViewModel`'函数的逻辑是一样的，只是所有的类型和实体都是抽象的。

我们的'`mapif`'函数的当前用例是在[`User`]数组上运行它，将用户转换为表视图数据源的[`ViewModel`:

从现在开始，如果我们需要使用更多的谓词进行过滤，我们可以用更多的参数修改“条件”闭包。看起来是这样的:

编写抽象代码可以使您的开发过程更容易、更快，因为您不必重复做同样的操作。但是重要的是要记住，在某些情况下可能不需要抽象，最好将功能封装在某个类中。

基本上由你决定。经验法则是，如果你在两个不同的地方做同样的操作，并且这个操作的逻辑有同样的潜在变化的原因，那么最好把这样的逻辑抽象出来。