<html>
<head>
<title>Functional Programming: Using the Applicative Type Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程:使用应用类型类</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-programming-using-the-applicative-type-class-3f4ac1a72ebc?source=collection_archive---------12-----------------------#2020-06-26">https://betterprogramming.pub/functional-programming-using-the-applicative-type-class-3f4ac1a72ebc?source=collection_archive---------12-----------------------#2020-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b9e6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">探索应用类型类及其用例</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/889447db0ee852f5a812deeb1da8db19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*667Im0UaVuuAD4_90U3r_g.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@windows?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">车窗</a>在<a class="ae kv" href="https://unsplash.com/photos/EaB4Ml7C7fE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">挡泥板</a>上拍照</p></figure><p id="70b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一系列文章的一部分，在这些文章中，我试图解释和展示一些函数式编程模式的用例。我们将使用TypeScript并使用函数式编程库<a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>。</p><p id="4e45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些例子和解释的灵感来自于<code class="fe ls lt lu lv b">fp-ts</code>作者的伟大文章系列，你可以在这里阅读<a class="ae kv" href="https://dev.to/gcanti/getting-started-with-fp-ts-ord-5f1e" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="a169" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这篇文章是关于<code class="fe ls lt lu lv b">Applicative type class</code>的。我们将探索什么是<code class="fe ls lt lu lv b">Applicatives</code>以及我们可以用它们做什么。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="db81" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">函子的问题是</h1><p id="b0a4" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">在我之前关于<code class="fe ls lt lu lv b">Functors</code>的文章中，我们看到它们允许我们用<code class="fe ls lt lu lv b">effectful</code>函数、<code class="fe ls lt lu lv b">(a: A =&gt; F&lt;B&gt;</code>组合<code class="fe ls lt lu lv b">pure</code>函数、<code class="fe ls lt lu lv b">(a: A) =&gt; B</code>。</p><p id="6c40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有一个限制。<code class="fe ls lt lu lv b">Functors</code>只允许我们用<code class="fe ls lt lu lv b">unary effectful</code>函数组合<code class="fe ls lt lu lv b">unary</code>函数(只有一个参数的函数)。如果我们想用<code class="fe ls lt lu lv b">unary effectful</code>函数组合<code class="fe ls lt lu lv b">binary</code>或<code class="fe ls lt lu lv b">n-ary</code>函数(带有两个(<code class="fe ls lt lu lv b">binary</code>或更多(<code class="fe ls lt lu lv b">n-ary</code>)参数的函数)该怎么办？</p><p id="2fd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<code class="fe ls lt lu lv b">Apply type class</code>的用武之地。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="a47d" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">应用类型类</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8240" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所见，<code class="fe ls lt lu lv b">Apply</code>用另一个叫做<code class="fe ls lt lu lv b">ap()</code>的方法扩展了我们的<code class="fe ls lt lu lv b">Functor type class</code>。</p><p id="97ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ap()</code>是一个可以解开<code class="fe ls lt lu lv b">effect F</code>内部函数的方法(记住<code class="fe ls lt lu lv b">effect</code>是类似于<code class="fe ls lt lu lv b">Option</code>、<code class="fe ls lt lu lv b">Either</code>等的东西)。)然后它可以将一个也包装在<code class="fe ls lt lu lv b">effect F</code>中的值应用于该函数。</p><p id="501d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这听起来很像来自<code class="fe ls lt lu lv b">Functors</code>的<code class="fe ls lt lu lv b">map()</code>。唯一的区别是参数顺序被重新安排(首先是函数，然后是值)，并且函数也被包装在一个<code class="fe ls lt lu lv b">effect F</code>中。在<code class="fe ls lt lu lv b">ap()</code>方法的实现中，我们还使用了来自<code class="fe ls lt lu lv b">Functor type class</code>的<code class="fe ls lt lu lv b">map()</code>方法。</p><ul class=""><li id="41a0" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">地图:<code class="fe ls lt lu lv b">&lt;A, B&gt;(fa: F&lt;A&gt;, f: (a: A) =&gt; B) =&gt; F&lt;B&gt;</code></li><li id="7fd3" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">美联社:<code class="fe ls lt lu lv b">&lt;A, B&gt;(fab: F&lt;(a: A) =&gt; B&gt;, fa: F&lt;A&gt;) =&gt; F&lt;B&gt;</code></li></ul><p id="edc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，<code class="fe ls lt lu lv b">ap()</code>如何帮助我们用<code class="fe ls lt lu lv b">effectful</code>函数组合<code class="fe ls lt lu lv b">pure n-ary</code>函数呢？</p><p id="64ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">老实说，现在还没有。但是请耐心听我说——我们会谈到它的！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="d003" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">Currying</h1><p id="0128" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">如果我们想用<code class="fe ls lt lu lv b">ap()</code>将<code class="fe ls lt lu lv b">pure n-ary</code>函数和<code class="fe ls lt lu lv b">effectful</code>函数组合起来，我们需要一个叫做<code class="fe ls lt lu lv b">currying</code>的东西。</p><p id="068d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">引用维基百科上关于<a class="ae kv" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">阿谀奉承的文章:</a></p><blockquote class="nq nr ns"><p id="6880" class="kw kx nt ky b kz la jr lb lc ld ju le nu lg lh li nv lk ll lm nw lo lp lq lr ij bi translated">“Currying是一种将带有多个参数的函数的求值转化为一系列函数的求值的技术，每个函数只有一个参数。例如，一个带有两个参数的函数，一个来自<code class="fe ls lt lu lv b">B</code>，一个来自<code class="fe ls lt lu lv b">C</code>，并在<code class="fe ls lt lu lv b">D</code>中产生输出，通过currying转换成一个带有一个来自<code class="fe ls lt lu lv b">C</code>的参数的函数，并产生从<code class="fe ls lt lu lv b">B</code>到<code class="fe ls lt lu lv b">C</code>的输出函数</p></blockquote><p id="da13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子，我们可以用currying将一个<code class="fe ls lt lu lv b">binary</code>函数重写为一个<code class="fe ls lt lu lv b">unary</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="6107" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">用Apply构造N元函数</h1><p id="a5b8" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">也许你已经意识到为什么我们需要处理我们的<code class="fe ls lt lu lv b">n-ary</code>函数，以便与<code class="fe ls lt lu lv b">ap()</code>一起使用。</p><p id="9b96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经看到，<code class="fe ls lt lu lv b">ap()</code>可以解开一个在<code class="fe ls lt lu lv b">effect F</code>内部的函数，并向它应用一个也在<code class="fe ls lt lu lv b">effect F</code>内部的值。</p><p id="7014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果我们获取一个<code class="fe ls lt lu lv b">binary</code>函数并对其进行处理(让我们从上面获取<code class="fe ls lt lu lv b">addCurried()</code>函数)，我们可以做<code class="fe ls lt lu lv b">map(F&lt;5&gt;, addCurried)</code>，它将返回<code class="fe ls lt lu lv b">F&lt;(y) =&gt; 5 + y&gt;</code>。其中在函数结束时，数字<code class="fe ls lt lu lv b">5</code>被分配给<code class="fe ls lt lu lv b">x</code>。然后，我们可以使用<code class="fe ls lt lu lv b">ap()</code>将第二个参数<code class="fe ls lt lu lv b">y</code>应用于<code class="fe ls lt lu lv b">addCurried()</code>函数。所以，如果我们做了<code class="fe ls lt lu lv b">ap(F&lt;(y) =&gt; 5 + y&gt;, F&lt;2&gt;)</code>，就会得到<code class="fe ls lt lu lv b">F&lt;7&gt;</code>的返回。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0517" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里你可以看到<code class="fe ls lt lu lv b">Apply type class</code>在工作。它给了我们用<code class="fe ls lt lu lv b">effectful</code>函数组合<code class="fe ls lt lu lv b">pure n-ary</code>函数的能力。</p><p id="1f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通过组合<code class="fe ls lt lu lv b">map()</code>和<code class="fe ls lt lu lv b">ap()</code>的功能来实现这一点。<br/>首先，我们使用<code class="fe ls lt lu lv b">map()</code>来提升一个<code class="fe ls lt lu lv b">pure unary</code>函数来处理一个<code class="fe ls lt lu lv b">effect</code>中的值。因为我们使用<code class="fe ls lt lu lv b">map()</code>处理了<code class="fe ls lt lu lv b">binary</code>函数和<code class="fe ls lt lu lv b">partially applied</code>函数，所以我们现在在<code class="fe ls lt lu lv b">effect</code>中有了一个<code class="fe ls lt lu lv b">partially applied</code>函数，我们可以将它作为第一个参数传递给<code class="fe ls lt lu lv b">ap()</code>。</p><p id="4468" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，我们使用<code class="fe ls lt lu lv b">ap()</code>从<code class="fe ls lt lu lv b">effect</code>中打开<code class="fe ls lt lu lv b">partially applied</code>函数，然后在<code class="fe ls lt lu lv b">ap()</code>方法中使用<code class="fe ls lt lu lv b">map()</code>将第二个/最后一个参数应用到我们的函数中，然后执行该函数并在<code class="fe ls lt lu lv b">effect</code>中返回结果。</p><p id="f04c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">按照这种逻辑，我们可以用任何<code class="fe ls lt lu lv b">arity</code>组合任何函数。对于一个<code class="fe ls lt lu lv b">ternary</code>函数，我们可以这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="23b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们使用了像<code class="fe ls lt lu lv b">O.none</code>或<code class="fe ls lt lu lv b">O.some()</code>这样的东西。这些是来自<code class="fe ls lt lu lv b">fp-ts</code>的函数。它们允许我们轻松地创建新的<code class="fe ls lt lu lv b">effects</code>实例——在本例中是<code class="fe ls lt lu lv b">Option effect</code>。我用它们来简化例子。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="87aa" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">应用类型类</h1><p id="1d03" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">我们谈到了<code class="fe ls lt lu lv b">Apply type class</code>，但还没有谈到<code class="fe ls lt lu lv b">Applicative type class</code>。</p><p id="0938" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经在前面的要点中使用了<code class="fe ls lt lu lv b">Applicatives</code>。当我们使用<code class="fe ls lt lu lv b">O.none</code>和<code class="fe ls lt lu lv b">O.some()</code>时，我们使用了一个<code class="fe ls lt lu lv b">Applicative type class</code>实例。我们从<code class="fe ls lt lu lv b">fp-ts</code>中导入了这个功能。</p><p id="37a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看看<code class="fe ls lt lu lv b">Applicative type class</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4cad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Applicative type class</code>用<code class="fe ls lt lu lv b">of()</code>方法扩展了<code class="fe ls lt lu lv b">Apply type class</code>，该方法接受<code class="fe ls lt lu lv b">A</code>类型的东西并返回一个新的<code class="fe ls lt lu lv b">effect F&lt;A&gt;</code>。</p><p id="645d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，<code class="fe ls lt lu lv b">of()</code>将类型<code class="fe ls lt lu lv b">A</code>的值提升为类型<code class="fe ls lt lu lv b">F&lt;A&gt;</code>的值。</p><p id="2f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常有用，因为现在我们也可以对<code class="fe ls lt lu lv b">ap()</code>所需的参数进行<code class="fe ls lt lu lv b">of(A)</code>。实际上，这正是我们在使用<code class="fe ls lt lu lv b">fp-ts</code>、<code class="fe ls lt lu lv b">O.none</code>和<code class="fe ls lt lu lv b">O.some()</code>中的函数时所做的。</p><p id="7ef9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以像这样实现它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="676f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看，没有什么神奇或过于复杂的事情发生——它实际上非常简单。</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="ce10" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">用有效函数构成纯N元函数</h1><p id="d704" class="pw-post-body-paragraph kw kx iq ky b kz mv jr lb lc mw ju le lf mx lh li lj my ll lm ln mz lp lq lr ij bi translated">为了用一个<code class="fe ls lt lu lv b">effectful</code>函数组合一个<code class="fe ls lt lu lv b">pure n-ary</code>函数，我们只需要将<code class="fe ls lt lu lv b">pure n-ary</code>函数组合成<code class="fe ls lt lu lv b">lift</code>函数。</p><p id="f3d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们需要创建接受<code class="fe ls lt lu lv b">pure</code>函数并返回接受<code class="fe ls lt lu lv b">effects</code>函数的<code class="fe ls lt lu lv b">lift</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d081" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们创建了两个<code class="fe ls lt lu lv b">lift</code>函数。两者都是为了<code class="fe ls lt lu lv b">Option effect</code>。<code class="fe ls lt lu lv b">liftA2</code>用于<code class="fe ls lt lu lv b">arity</code>为2的<code class="fe ls lt lu lv b">pure</code>功能，而<code class="fe ls lt lu lv b">liftA3</code>用于<code class="fe ls lt lu lv b">arity</code>为3的<code class="fe ls lt lu lv b">pure</code>功能。我们可以为任何<code class="fe ls lt lu lv b">arity</code>和任何<code class="fe ls lt lu lv b">effect</code>创建<code class="fe ls lt lu lv b">lift</code>函数。</p><p id="6ad7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您阅读来自<code class="fe ls lt lu lv b">lift</code>函数的代码，您可以看到我们使用<code class="fe ls lt lu lv b">ap()</code>和<code class="fe ls lt lu lv b">map()</code>方法来处理<code class="fe ls lt lu lv b">n-ary</code>函数。</p><p id="1027" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以用<code class="fe ls lt lu lv b">Apply type class</code>将<code class="fe ls lt lu lv b">pure n-ary</code>函数与<code class="fe ls lt lu lv b">effectful</code>函数组合起来。此外，我们现在可以用<code class="fe ls lt lu lv b">Applicative type class</code>将类型<code class="fe ls lt lu lv b">A</code>的值提升为类型<code class="fe ls lt lu lv b">F&lt;A&gt;</code>的值。</p><p id="c8ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是不要太激动——如果我们想要组合两个函数，都是<em class="nt"/><code class="fe ls lt lu lv b">effectful</code>呢？</p><p id="7c82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，这个问题有一个解决方案:<code class="fe ls lt lu lv b">Monads</code>。我们将在下一篇文章中讨论它们！</p></div><div class="ab cl lw lx hu ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ij ik il im in"><h1 id="afd1" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">参考</h1><ul class=""><li id="bd6b" class="nc nd iq ky b kz mv lc mw lf nx lj ny ln nz lr nh ni nj nk bi translated">fp-ts库:<a class="ae kv" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank">https://github.com/gcanti/fp-ts</a></li></ul></div></div>    
</body>
</html>