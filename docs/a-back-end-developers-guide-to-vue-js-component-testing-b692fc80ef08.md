# Vue.js 组件测试后端开发人员指南

> 原文：<https://betterprogramming.pub/a-back-end-developers-guide-to-vue-js-component-testing-b692fc80ef08>

## 我是如何破解 UI 组件架构并构建可靠的可重用测试的

![](img/6e973c631456118d8b764e65baf1f082.png)

照片由[马腾·戴克斯](https://unsplash.com/@maartendeckers?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

作为一名钻研 Vue 开发世界的后端开发人员，我很快意识到单元测试对我的产品的成功至关重要。感觉 UI 开发就像玩打地鼠游戏，修复一个东西导致撤销另一个先前修复的东西。

起初，我认为组件测试意味着我必须将 DOM 输出与道具、插槽、触发器和数据源的组合进行比较。但是编写测试来验证组件的 HTML 似乎会导致脆弱、笨拙的测试，对于我快速发展的代码库来说不切实际。相反，我将注意力从 HTML 输出整体上转移，转向基于影响组件行为的输入的更有针对性的结果。

# 我的设置

您并不完全需要这些工具来理解本文中的概念，但有时对我来说，了解辅助细节有助于理解更大的图景。

*   [Vue 2](https://vuejs.org/)
*   [Vue 测试工具](https://vue-test-utils.vuejs.org/)
*   [莫卡吉斯](https://mochajs.org/)
*   [柴吉斯](https://www.chaijs.com/)

# 一个超级简单的例子

让我们从一个向用户显示消息的 Vue 组件开始:

看一下这个例子，似乎要验证的事情是确保消息在模板中呈现，所以测试看起来像下面这样。

但是，如果模板更改为类似下面这样的内容会怎么样呢？

```
<template>
  <div style="background-color: green">
    <p>{{ message }}</p>
  </div>
</template>
```

尽管模板发生了变化，但测试的基本概念并没有改变。`message`字段的目的是确保它显示在组件中，这个目的在这个版本和它的前身之间并没有真正改变。

但是`background-color: green`呢？这难道不应该用组件测试来验证吗？在这个特殊的例子中，没有，因为这个值对于模板本身是静态的。组件没有正式规定改变这个值的方法，因此对于组件本身的有效性并不重要。如果去掉无关的信息，剩下的就是下面的内容。

![](img/6fc1d36b7eeaa59a20fb1d0a9750c92e.png)

它描述了最初构建的同一个组件。

# 具有同级的组件

前面的组件向用户显示了一条消息，但是如果组件稍微复杂一点会怎么样呢？

现在测试必须改变，因为根组件的内部文本现在类似于`'This is my demo!'+ {{ some whitespace }} + message`。正如我之前提到的，静态数据与道具的行为无关。重写这个测试的一个简单方法是这样的:

尽管这个测试可以工作，但是它对于组件的内部工作来说太具体了。如果消息的包装器变成了一个`div`或者一个`span`，或者不在第一个索引处，那么你必须重写测试。一种可能的补救方法是为组件分配一个标识符(比如 ref 或 id ),然后在测试中引用这个标识符。在这种情况下，您的模板应该如下所示。

最终的测试如下所示:

这样，不管模板如何演变，`messageField`的 ref 将总是与包含`message`属性的值相关联。

# 组件的样式更改

如果我们的组件包含一个改变背景颜色的属性怎么办？

`success`属性的真实性决定了`background-color`属性的结果。因此，需要更多的测试来验证特定的行为。

注意，尽管组件有一个用于`message`的道具，但是在这两个测试中既没有描述也没有提到它。为什么？因为`message`对组件的颜色是否修改没有影响。另一种思考方式是，如果这个对象被描述为一个类，而不是 Vue 组件，会怎么样:

如果您正在测试成功的结果值，您应该设置并调用`.success`。设置和获取`.message`的值对`.success`字段的结果没有影响，应该有自己独立的验证集。

更进一步，除了将元素的背景颜色设置为绿色，消息文本需要加下划线。模板可能看起来像这样:

可以编写一个测试来验证`div`元素的样式，然后验证`p`元素的样式。但是如果增加或改变更多的风格特征呢？这变得有点麻烦，反过来使测试变得更加脆弱。说到底，组件测试*并不是真的关注组件看起来怎么样*，而是关注它是如何工作的。因此，从功能上来说，这个实现相当于以下内容。

测试是这样的:

如果你像我一样不擅长样式表，你甚至可以使用这样的模板:

在这种情况下，测试仍然有效，因为 CSS 类`success-me`是设置`success`属性时发生的主要结果。

# 组件中的组件

当涉及到测试导入其他组件的组件时，经验法则是表现得好像子组件工作得很好。父组件没有必要对子组件进行单元测试。这应该已经在子组件的单元测试中完成了。父组件的目标是验证它是否向子组件传递了正确的信息，以及它是否正确地处理了子组件发出的触发器。

我没有描述`MyCoolWhatever`代表什么，因为它在`MyCoolParent`组件的上下文中无关紧要。重要的是`MyCoolParent`如何与那个组件交互以呈现它自己的模板。

如果子组件是静态呈现的，前面的规则也适用。如果`blah`属性被设置为硬编码值，或者触发器没有绑定到该组件，那么就没有必要编写单元测试来验证模板的这一部分。

# 分解和拆卸组件

现在我们需要知道组件应该在什么时候被分解成更小、更易管理的块。解决这个问题的一个方法是计算你在描述一个组件时使用单词*和*的次数。如果是两次以上，那么你可能要考虑分手的组成部分。

*   用一句话描述一个组件的功能。如果不使用单词*和*就无法描述目的，那么每一个从句都代表潜在的子成分。

```
The purpose of this component is to display a toolbar (1) AND left navigation (2) AND main content (3).
```

*   下一步是描述组件如何实现它的目的。同样，如果不使用单词*和*就无法描述如何实现，那么这些子句中的每一个都代表一个潜在的新的子组件。

```
This component displays the weekly calendar.  It displays the calendar by showing the days of the week (1) AND the hours of the day (2) AND scheduled events (3) AND holidays (4)
```

通过使组件变得更小，您减少了总的测试表面积，这限制了复杂错误的可能性，并通过更少的测试提高了总的代码覆盖率。

组件单元测试不是将输入匹配到相应的 HTML。也不是验证单个方法调用或内部状态。它是对每个组件的预期行为做出有针对性的决策，以提高灵活性，提供稳定性，最重要的是，节省时间。

感谢阅读！