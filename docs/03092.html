<html>
<head>
<title>Dynamic Import and Tree Shaking in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的动态导入和树抖动</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-import-and-tree-shaking-in-javascript-ddc2f3cd69f?source=collection_archive---------6-----------------------#2020-01-20">https://betterprogramming.pub/dynamic-import-and-tree-shaking-in-javascript-ddc2f3cd69f?source=collection_archive---------6-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9a21" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">为什么动态导入不总是最佳解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77be5bcb71854f9b518fcbe715bc9276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fMKuHdYjy3yGOvnd"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kewal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯瓦尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="836f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从ES2020年开始，我们正式能够使用动态导入功能。在最新版本的所有功能中，这个功能看起来尤为突出。一些人对我的另一篇文章发表了评论，谈到ES2020 中的<a class="ae ky" href="https://medium.com/javascript-in-plain-english/new-features-in-es2020-you-should-check-b4974d9d7edc" rel="noopener">新功能，他们一直期待着手中有这个功能。</a></p><p id="7a64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章讲述了当涉及到<strong class="lb iu">树摇动</strong>时，通常导入和动态导入的区别。我希望这是对你有用的信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b29" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是树摇动？</h1><p id="0bce" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">树摇动，死代码消除的另一个名字，随着Webpack进入JavaScript世界。嗯……它可能很久以前就存在了，但是是Webpack开始认真地使用这个术语。他们甚至给了你一个让Webpack执行死代码清除的方法。</p><p id="47a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">树抖动可以减小捆绑的JavaScript文件的大小。它只适用于<code class="fe mz na nb nc b">import</code>和<code class="fe mz na nb nc b">export</code>语法。因此，不支持常见的JavaScript语法<code class="fe mz na nb nc b">require</code>。例如，Webpack命名每个模块，它包括在构建时从其他文件调用到捆绑文件中的模块。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9d7c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">项目设置</h1><p id="a3b7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是我用于测试的项目。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b7ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">a.ts</code>文件中有四个函数，还有项目的主文件，从<code class="fe mz na nb nc b">a.ts</code>调用导出的函数。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="a10c" class="nj md it nc b gy nk nl l nm nn">import { pow } from './a';</span><span id="6528" class="nj md it nc b gy no nl l nm nn">pow(1, 2);</span></pre><p id="2556" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">main.ts</code>只导入<code class="fe mz na nb nc b">add</code>并使用。这个项目中没有使用其他函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a3e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Webpack设置文件:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="dad8" class="nj md it nc b gy nk nl l nm nn">mode: 'development',<br/>optimization: {<br/>  usedExports: true<br/>}</span></pre><p id="73f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将<code class="fe mz na nb nc b">mode</code>设置为<code class="fe mz na nb nc b">development,</code>这样捆绑文件就不会被缩小，并将<code class="fe mz na nb nc b">usedExported</code>设置为<code class="fe mz na nb nc b">true</code>用于树抖动。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3acd" class="nj md it nc b gy nk nl l nm nn">"build": "webpack"</span></pre><p id="ca40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我将在终端上运行这个脚本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5a70" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">静态导入的结果(部分)</h1><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="9da9" class="nj md it nc b gy nk nl l nm nn">&gt; npm run build</span></pre><p id="f7a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件被打包了。<code class="fe mz na nb nc b">main.ts</code>用<code class="fe mz na nb nc b">import</code>关键字从<code class="fe mz na nb nc b">a.ts</code>中抓取<code class="fe mz na nb nc b">pow</code>函数。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="84dc" class="nj md it nc b gy nk nl l nm nn">// main.ts<br/>import { pow } from './a';</span><span id="9416" class="nj md it nc b gy no nl l nm nn">pow(1, 2);</span></pre><p id="8969" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe mz na nb nc b">bundle.js</code>中，你可以看到这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="519a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使所有导出的函数都包含在包中，实际上只有<code class="fe mz na nb nc b">pow</code>被抓取。</p><p id="f71f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">unused harmony export ...</code>只是一条消息，让您和Webpack知道哪些已经导出。</p><p id="7cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样的结果呢？：</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="5cab" class="nj md it nc b gy nk nl l nm nn">// main.ts<br/>import { pow, multiply } from './a';</span><span id="d9d9" class="nj md it nc b gy no nl l nm nn">pow(1, 2);</span></pre><p id="8ce8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">multiply</code>不用，尽管是进口的。捆绑文件的结果是相同的，这意味着Webpack将实际使用的方法放在它的导出列表中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9e39" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">静态导入的结果(完全)</h1><p id="5698" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我想知道如果我一次导入所有的函数会有什么不同:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="fe6d" class="nj md it nc b gy nk nl l nm nn">// main.ts<br/>import * as module from './a';</span><span id="0764" class="nj md it nc b gy no nl l nm nn">module.pow(1, 2);</span></pre><p id="1532" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是一样的。</p><p id="3c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有<code class="fe mz na nb nc b">default</code>功能的情况呢？</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3d87" class="nj md it nc b gy nk nl l nm nn">export default divide;</span></pre><p id="faa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，<code class="fe mz na nb nc b">divide</code>是默认的函数，当您没有指定要导入的函数时，它将被导出。</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3830" class="nj md it nc b gy nk nl l nm nn">// main.js<br/>import divide, { pow } from './a';</span><span id="8af9" class="nj md it nc b gy no nl l nm nn">divide(1, 2);<br/>pow(1, 2);</span></pre><p id="7289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果略有不同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="61ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，Webpack增加了<code class="fe mz na nb nc b">divide</code>作为默认导出功能。</p><p id="5422" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但关键是Webpack <em class="np">知道</em>哪些函数实际上被使用了，并以自己的方式对它们进行分类。</p><p id="7b90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="np">注</em> </strong> <em class="np"> <br/>在Webpack的官方文档中，它说决定哪些函数需要包含在捆绑文件中实际上是极其困难的。它还讨论了每个函数的副作用——例如，在其当前作用域的外部作用域中更改值。这个例子很容易测试。</em></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b793" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态导入的结果</h1><p id="e798" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，让我们更改代码以使用动态导入:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="867d" class="nj md it nc b gy nk nl l nm nn">import('./a').then(module =&gt; {<br/>  const { pow } = module;<br/>  pow(1, 2);<br/>});</span></pre><p id="5aca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动态导入返回一个<code class="fe mz na nb nc b">Promise</code>，您可以链接<code class="fe mz na nb nc b">then</code>或<code class="fe mz na nb nc b">catch</code>方法。如果文件加载成功，结果将发送至<code class="fe mz na nb nc b">then</code>。它需要一个参数，通常命名为<code class="fe mz na nb nc b">module</code>。<code class="fe mz na nb nc b">module</code>包含每一个导出功能。</p><p id="de68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，动态导入被认为是一个非树摇动支持特性。让我们看看这个包文件是什么样子的。</p><p id="cfeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我运行<code class="fe mz na nb nc b">npm run build</code>时，一个新的包文件被命名为<code class="fe mz na nb nc b">0.bundle.js</code>(我想如果你愿意，你可以改变它们的名字):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="7301" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个函数都包含在导出列表中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4b8f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模式:生产完全排除未使用的功能</h1><p id="2815" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你之所以能看到捆绑文件中也包含了未使用的函数，是因为你在<code class="fe mz na nb nc b">webpack.config.json</code>中的<code class="fe mz na nb nc b">mode</code>是<code class="fe mz na nb nc b">development</code>，而不是<code class="fe mz na nb nc b">production</code>。</p><p id="b06f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按如下方式更改模式:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="3ed2" class="nj md it nc b gy nk nl l nm nn">"mode": "production"</span></pre><p id="594d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后去掉这部分:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="7ded" class="nj md it nc b gy nk nl l nm nn">// remove<br/>"optimization": {<br/>  "usedExports": true<br/>}</span></pre><p id="f987" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，运行<code class="fe mz na nb nc b">npm run build</code>你会看到这个。</p><h2 id="4ebd" class="nj md it bd me nq nr dn mi ns nt dp mm li nu nv mo lm nw nx mq lq ny nz ms oa bi translated">使用静态导入</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="fe1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如我所说，动态导入返回一个<code class="fe mz na nb nc b">promise</code>，它链接了<code class="fe mz na nb nc b">then</code>，但是似乎唯一使用的函数也包含在捆绑文件中。</p><p id="6042" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，还有一个文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f07f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个功能都包括在内。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="218d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么动态导入不支持摇树</h1><p id="eb63" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可能会奇怪为什么这个功能不支持摇树。是因为进口时机不明确。例如，假设您只想在数量为奇数时导入:</p><pre class="kj kk kl km gt nf nc ng nh aw ni bi"><span id="7b9b" class="nj md it nc b gy nk nl l nm nn">if (isOdd(num)) {<br/>  import('./odd').then(module =&gt; ...);<br/>}</span></pre><p id="d2d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从Webpack的角度来看，它不知道该文件最终是否会被导入。因为<code class="fe mz na nb nc b">isOdd</code>并不能保证它永远是真的。</p><p id="46f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Webpack Github库有一个<a class="ae ky" href="https://github.com/webpack/webpack/issues/7500" rel="noopener ugc nofollow" target="_blank">问题——维护者回答如下。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/fbf25aa198b543b8d783283cfae02397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*634wtE0Lxe--Lq8Vp2NNmA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Florent Cailhol说Webpack不支持树抖动</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e8f3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="1df3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我认为动态导入是一个很好的特性，因为它减少了运行时加载所有函数和模块的时间。当您不需要时，可以避免导入不必要的文件。</p><p id="5067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，由于动态导入不允许你做树抖动，它的所有功能都会被导入，所以你不应该滥用这个特性。</p><h1 id="c699" class="mc md it bd me mf oe mh mi mj of ml mm jz og ka mo kc oh kd mq kf oi kg ms mt bi translated">资源</h1><ul class=""><li id="7276" class="oj ok it lb b lc mu lf mv li ol lm om lq on lu oo op oq or bi translated"><a class="ae ky" href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking" rel="noopener ugc nofollow" target="_blank">通过树抖动减少JavaScript负载——网络基础</a></li><li id="6982" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated"><a class="ae ky" href="https://webpack.js.org/guides/tree-shaking/#root" rel="noopener ugc nofollow" target="_blank">摇树—网络包</a></li><li id="8dfa" class="oj ok it lb b lc os lf ot li ou lm ov lq ow lu oo op oq or bi translated"><a class="ae ky" href="https://github.com/tc39/proposal-dynamic-import" rel="noopener ugc nofollow" target="_blank">动态导入建议书— TC39 </a></li></ul></div></div>    
</body>
</html>