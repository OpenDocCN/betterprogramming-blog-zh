<html>
<head>
<title>Parametrizing Fixtures in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的参数化夹具</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/parametrizing-fixtures-in-python-ef0a413bbfe4?source=collection_archive---------9-----------------------#2022-12-14">https://betterprogramming.pub/parametrizing-fixtures-in-python-ef0a413bbfe4?source=collection_archive---------9-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8169" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Pytest中实现带参数的fixtures的两种方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/10a95df4b742caf99d6f5b07e80e654f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xIrK3BOfnqfVp-e8pLDh5g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae ky" href="https://unsplash.com/@cdr6934?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="1ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用参数定制夹具是一个常见的用例。然而，我发现很少有人记载和交流这是可能的。</p><p id="ed74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将介绍Pytest中参数化夹具的两种方法(夹具工厂和隐式参数化)，并以讨论何时使用哪种方法结束。</p><h1 id="8c39" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">夹具概述</h1><p id="9607" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Fixtures是减少重复代码块的辅助函数。主要的例子是一组单元测试，我们在每个测试中做一些或多或少复杂的初始化——比如创建一个类:</p><p id="f07a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这篇文章，推荐理解一般的单元测试，特别是<code class="fe ms mt mu mv b">pytest</code>:一个可能的阅读是我以前的一篇文章，也是<a class="ae ky" href="https://medium.com/@hrmnmichaels/unit-testing-with-pytest-5c59cdf89529" rel="noopener">介绍夹具和参数化</a>——我们在这里构建的基础。</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="c28a" class="na lw it mv b be nb nc l nd ne">class MySummationClass:<br/>    def sum(self, x, y):<br/>        return x + y<br/><br/>def test_sum():<br/>    my_summation_class = MySummationClass()<br/>    assert my_summation_class.sum(2, 3) == 5<br/>    <br/>def test_sum_neg():<br/>    my_summation_class = MySummationClass()<br/>    assert my_summation_class.sum(-2, -3) == -5</span></pre><p id="857a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将这些共享的代码封装在一个夹具中，并将其合并到每个测试中，而不是放在每个单元测试中:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="4b47" class="na lw it mv b be nb nc l nd ne">@pytest.fixture<br/>def my_summation_class():<br/>    return MySummationClass()<br/><br/>def test_sum(my_summation_class):<br/>    my_summation_class = MySummationClass()<br/>    assert my_summation_class.sum(2, 3) == 5<br/><br/>def test_sum_neg(my_summation_class):<br/>    my_summation_class = MySummationClass()<br/>    assert my_summation_class.sum(-2, -3) == -5</span></pre><h1 id="68f4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参数化夹具</h1><p id="9546" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们看看下面这个激励人心的例子:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="059d" class="na lw it mv b be nb nc l nd ne">import math<br/>from dataclasses import dataclass<br/>from typing import Callable<br/>import pytest<br/><br/>@dataclass<br/>class Circle:<br/>    radius: float<br/>    def get_area(self) -&gt; float:<br/>        return 2 * math.pi * self.radius<br/><br/>@pytest.fixture<br/>def new_circle() -&gt; Circle:<br/>    return Circle(5)<br/><br/>def test_get_area_v1(new_circle: Circle) -&gt; None:<br/>    assert new_circle.get_area() == pytest.approx(31.4159265359)</span></pre><p id="84a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了一个定义圆的<a class="ae ky" href="https://medium.com/better-programming/how-to-setup-data-classes-in-python-ffd85549523c" rel="noopener">数据类</a>:它通过半径来描述，并提供了一个计算圆的面积的函数。</p><p id="6589" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们定义一个fixture，创建并返回一个新的<code class="fe ms mt mu mv b">Circle</code>实例——最后测试函数<code class="fe ms mt mu mv b">get_area</code>,使用这个fixture提供一个样本对象。</p><p id="4655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果我们想要参数化这个夹具——也就是说，有某种方法来定义一个以半径为参数并返回相应圆的夹具，该怎么办？这迟早会派上用场，而且也很容易做到——尽管在我看来交流很少。因此，我们在这里对此进行详细描述。</p><h1 id="09fd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">方法一:夹具工厂</h1><p id="e150" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">每当我们想在函数内部的任何地方创建多个对象时，都可以使用fixture factory。</p><p id="3d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用一个普通的Pytest fixture，但是我们没有返回容易构造的对象，而是返回一个function对象，将<code class="fe ms mt mu mv b">radius</code>作为一个参数并创建一个适当的圆。另外，注意正确的<a class="ae ky" href="https://mypy.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> mypy注释</a>:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="5c8d" class="na lw it mv b be nb nc l nd ne">@pytest.fixture<br/>def new_circle_factory() -&gt; Callable[[float], Circle]:<br/>    def _create(radius: float) -&gt; Circle:<br/>        return Circle(radius)<br/>    return _create<br/><br/>def test_get_area_v2(new_circle_factory: Callable[[float], Circle]) -&gt; None:<br/>    assert new_circle_factory(5).get_area() == pytest.approx(31.4159265359)<br/>    assert new_circle_factory(15).get_area() == pytest.approx(94.2477796077)</span></pre><h1 id="3717" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">方法2:隐式参数化</h1><p id="f258" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">另一种方法源于夹具已经隐式支持参数化这一事实。当我们想将参数化夹具与其他类型的参数化结合起来时，可以使用这种方法。</p><p id="a732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们向fixture函数添加一些参数——然后在我们的“普通”参数化修饰器中定义这些参数——但是不要在测试函数的签名中包含这些参数。这样，<code class="fe ms mt mu mv b">pytest</code>将隐式地把这个参数传递给fixture:</p><pre class="kj kk kl km gt mw mv mx bn my mz bi"><span id="af9e" class="na lw it mv b be nb nc l nd ne">@pytest.fixture<br/>def new_circle_parametrized(radius: float) -&gt; Circle:<br/>    return Circle(radius)<br/><br/>@pytest.mark.parametrize(<br/>    "radius, expected_area", [(5, 31.4159265359), (15, 94.2477796077)]<br/>)<br/>def test_get_area_v3(new_circle_parametrized: Circle, expected_area: float) -&gt; None:<br/>    assert new_circle_parametrized.get_area() == pytest.approx(expected_area)</span></pre><h1 id="c3e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">比较</h1><p id="ed68" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我们以关于何时使用这两种方法的简短讨论来结束本文:没有哪一种方法更好或更差，两者都有其合理的用例及应用场景。相反，正如在他们各自的介绍中已经提到的，这主要取决于我们想在哪里以及如何使用固定物。以下是一些使用它们的方法:</p><ol class=""><li id="3190" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">当我们想要灵活地使用fixture来定义对象时，可能是按需的，并且在一个或多个测试函数中的许多不同的地方——我们需要方法1。</li><li id="b22f" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">如果我们需要“在正常程序范围之外”的fixture，例如，在另一个参数化的装饰器内部——我们必须求助于方法2。</li></ol><p id="0db9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就结束了参数化夹具的使用。希望这对你有用。感谢阅读！</p></div></div>    
</body>
</html>