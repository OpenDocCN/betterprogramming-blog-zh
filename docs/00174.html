<html>
<head>
<title>Testing HTTP Requests in Angular with HttpClientTestingModule</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用HttpClientTestingModule测试Angular中的HTTP请求</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-http-requests-in-angular-with-httpclienttestingmodule-3880ceac74cf?source=collection_archive---------0-----------------------#2018-08-18">https://betterprogramming.pub/testing-http-requests-in-angular-with-httpclienttestingmodule-3880ceac74cf?source=collection_archive---------0-----------------------#2018-08-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5b0ee0a80f1ed9ce32f0a784fd28ef9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ii536-zgr1Nrww7H56hR3g.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">伊恩·杜利在<a class="ae kf" href="https://unsplash.com/search/photos/sky?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0c32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇简短的文章中，我将向您展示如何在Angular中测试您的HTTP请求，使用来自<strong class="ki iu">@ Angular/common/HTTP/testing的<strong class="ki iu"> HttpClientTestingModule </strong>和<strong class="ki iu">HttpTestingController</strong>。</strong></p><p id="a26e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从课程服务的基本测试设置开始:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">我们课程服务的基本测试设置</p></figure><p id="2376" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望此服务允许我们执行两个不同的请求:</p><ol class=""><li id="8dff" class="lk ll it ki b kj kk kn ko kr lm kv ln kz lo ld lp lq lr ls bi translated">一个<strong class="ki iu">帖子请求</strong>添加属于特定主题的新课程。</li><li id="2b4e" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld lp lq lr ls bi translated">一个<strong class="ki iu"> GET请求</strong>获取属于特定主题的所有课程。</li></ol><p id="7f1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，带着测试优先的心态，让我们为第一种情况编写一个测试:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">#为课程服务添加课程测试—发布请求</p></figure><p id="5b8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们分解这个测试。这基本上是我们想要实现的目标，也是我们必须在服务中实施的目标:</p><ul class=""><li id="cb68" class="lk ll it ki b kj kk kn ko kr lm kv ln kz lo ld ly lq lr ls bi translated">我们<strong class="ki iu">创建一个带有名称和描述的<em class="lz">模拟课程</em> </strong>。</li><li id="58d8" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated">我们<strong class="ki iu">运行<em class="lz"> addCourse </em> </strong>函数，我们期望当请求被执行(当可观察解析)时，我们将得到的响应中的属性名称是'<em class="lz">ches able</em>'(与<em class="lz"> mockCourse </em>中的相同)。</li><li id="de4e" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated">然后我们有一个req URL，当我们调用函数addCourse时，我们期望我们可以调用定义为参数<strong class="ki iu"> expectOne </strong>的端点，这是<strong class="ki iu">检查只有一个请求</strong>。</li><li id="0f98" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated">我们还检查了<strong class="ki iu">类型的请求是POST </strong>。</li><li id="40e9" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated"><strong class="ki iu">然后，我们“刷新”或响应模拟数据，我们将模拟数据作为参数</strong>传递，这导致可观察对象解析并评估第10行上的期望。</li><li id="3064" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated">最后，我们从第一个图像运行afterEach块到<strong class="ki iu">验证</strong>没有<strong class="ki iu">未决的HTTP请求</strong>。</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="153d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道了用Angular编写HTTP请求测试的步骤，让我们在服务中实现addCourse函数:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><ul class=""><li id="5444" class="lk ll it ki b kj kk kn ko kr lm kv ln kz lo ld ly lq lr ls bi translated"><strong class="ki iu">我们将HttpClient </strong>(执行HTTP请求的Angular模块)的私有变量注入到我们的构造函数中。不像在测试中，我们不真正执行真正的HTTP请求，感谢Angular提供的模拟，我们现在需要使用这个模块。</li><li id="9b18" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated">现在<strong class="ki iu">我们创建一个函数(<em class="lz"> addCourse </em> ) </strong>，它将返回一个可观察对象，我们可以从我们的组件订阅这个可观察对象<strong class="ki iu">，以使用它们将携带的数据。</strong></li><li id="0a11" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated"><strong class="ki iu">我们将课程信息作为参数</strong>传递，以便能够保存它。</li><li id="5641" class="lk ll it ki b kj lt kn lu kr lv kv lw kz lx ld ly lq lr ls bi translated"><strong class="ki iu">我们使用指定为POST请求数据的过程的topicId </strong>来访问端点。</li></ul><p id="0eb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的一点是，我们将能够直接从响应对象<strong class="ki iu">读取数据，而无需显式解析JSON </strong>，这与Angular 4.3发布之前的<em class="lz"> HttpModule </em>不同。</p><p id="6a22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您因为新模块而遇到导入错误，首先确保您当前的Angular版本不低于4.3。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="adbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们添加测试，按主题获取我们的课程:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="ab15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们测试对象中的所有信息。如你所见，它看起来非常相似。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="45a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们将<em class="lz"> getCoursesByTopic </em>函数实现到服务中，与我们使用<em class="lz"> addCourse </em>函数的方式相同:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="3762" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们只需要获取一个topicId来匹配端点，并只检索特定topicId的课程。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="5704" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">我希望你喜欢这篇文章，并希望你能为自己的服务编写一些测试。</strong></p></div></div>    
</body>
</html>