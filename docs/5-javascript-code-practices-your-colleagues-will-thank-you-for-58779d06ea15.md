# 你的同事会感谢你的 5 个 JavaScript 代码实践

> 原文：<https://betterprogramming.pub/5-javascript-code-practices-your-colleagues-will-thank-you-for-58779d06ea15>

## 编写清晰的代码

![](img/652b7d7ba27637afab03ffb876830a74.png)

照片由[在](https://unsplash.com/@jannerboy62?utm_source=medium&utm_medium=referral) [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的刻痕拍摄

在这篇文章中，我将回顾 JavaScript 中的一些实践，从长远来看，这些实践将对您有所帮助。你可能已经听说过其中的一些(或全部)，但是下面的细节才是最重要的。

其中一些例子是取自生产代码库的真实例子。既然它们已经交付生产，我想借此机会帮助其他人理解我们编写代码时的好与坏。

# 1.处理不同的数据类型

久而久之意识到这成为一项重要实践的日子比以往任何时候都更近了。如果不处理进入函数的不同数据类型，你的程序很可能迟早会出错。你要么从一个真正的错误中学习，要么从帮助你避免未来错误的资源中学习。

我在代码中遇到过许多类似这样的情况:

虽然这运行得很好，没有任何问题，但我发现开发人员经常将此理解为“空数组的默认列表”，并假设这将防止列表作为*意外/错误类型*传入的错误。但是 JavaScript 将它理解为“当它没有默认值或者值为`undefined`时，默认列表为空数组。”

在 ES6 之前，我们大多数人初始化值的方式是像这样使用`||`操作符:

这与前一个示例的行为非常相似，因为代码已经(按照惯例)使用默认参数来完成这一任务，所以学习 JavaScript 的新开发人员在新旧教程之间相互学习时，可能会将这误认为是相同的行为，因为这种做法是为了实现相同的目标。

因此，如果这个函数在`null`中被调用和传递，我们将收到一个`TypeError`，因为我们对一个`null`值使用了一个*数组方法*。由于`null`是一个值，JavaScript 将接受这个值并使用它将`list`默认为`null`。

如果您使用 *TypeScript* ，它会捕捉到这一点并向您显示一条错误消息。这是真的，但我看到人们通过写`// @ts-ignore`来掩盖关键错误的情况并不少见。请不要忽略打字稿错误，它们是为了帮助你在不好的事情发生之前修复它们。

# 2.赋值时尽可能使用三元运算符，而不是&&运算符

当试图给某个东西赋值时，三元运算符和`&&`(逻辑 and)之间的区别并不大。虽然这两者之间的微小差异实际上可能比你想象的更经常地成为你的救世主。

我说的不是在`if`语句中使用它的场景:

在这些情况下，`&&`操作符非常好，是以更简洁的方式编写代码的好选择。

但是当你开始分配价值时，这是一个糟糕的做法！依靠`&&`，作为开发人员，您有责任确保当接收到不同的数据类型时它不会产生错误。

例如，在如下意外情况下:

这将产生一个意想不到的结果:

发生这种情况是因为当我们使用`&&`时，它将立即返回第一个操作数的值，该值评估为`false`

通过使用三元运算符，它迫使我们默认一个我们期望的值，使我们的代码更可预测:

现在，当一个坏类型被传入时，我们至少可以期待*一个更干净的结果:*

```
<ul></ul>
```

不是技术天才的用户可能不知道`undefined`是什么意思，而技术人员会很快发现这是人类的编码缺陷。

说到三元运算符，这里有一个由某人编写的真实世界的代码示例:

对于那些可能不知道的人，这可以改写为:

这是因为三元运算符的工作方式是将第一个操作数作为条件*进行评估，该条件用于决定是返回第二个还是第三个操作数中的值。*

虽然代码是有效的，但我提出这个问题的原因是为了解释三元运算符最适合用来缩小确定性和不确定性之间的差距。

在前面的例子中，我们并不确定`item`的写法是什么:

如果我们使用三元运算符，我们可以确定`item`不会被隐式包含为父`ul`元素的子元素:

# 3.当实用程序可以在多种情况下使用时，创建实用程序助手

一旦你意识到你在不止一个地方使用两段代码，开始考虑创建一个助手工具是一个好主意。

考虑这个例子:

这样做的问题是，从长远来看，它不太容易管理。如果我们制作了更多处理动作对象的函数，并且需要在继续之前验证它们是否是对象，我们就必须编写更多这样的函数:

除了抛出一个错误之外，也没有太多的控制。如果我们不希望程序失败，但仍然希望值通过验证过程，该怎么办？

函数实用程序将解决这些问题:

然后还有验证来检查 action.type 是否为`undefined`:

因为我们有一个`validateObject`实用程序，所以我们可以重用它:

由于我们现在有两个验证器，但是具有相似的行为，我们可以进一步创建一个更高级的实用程序来产生不同的/定制的验证器:

现在我们可以制作一套验证器，而不必到处写`throw new Error('...')`:

# 4.当你认为别人会质疑你的代码做了什么时，就对它进行注释

我怎么强调这对你的代码有多重要都不为过。如果您的代码将被其他人而不是您自己查看，那么解释您的代码在做什么是一个很好的做法

当我通读代码时，这是我最大的烦恼之一，因为最终发生的事情是你强迫读者在代码的其他部分搜索线索来理解发生了什么。当你*需要*去理解它以便能够理解接下来发生的事情时，这可能是一件令人头疼的事情。下面是一些代码:

现在，我不是说像这样评论你的代码，然后就到此为止:

这不仅含糊不清，而且我们不知道消息来自哪里*或者*是什么*。是一串吗？字符串数组？是*要求*吗？这是你在邮件中收到的真实信息吗？换个称呼可以吗？它的真正含义是什么？*

帮大家一个忙，做一个团队成员，代码如下:

# 5.用积极的方式命名你的函数

一个可以遵循的好习惯是，当我们想到生活中的美好事物时，用一种类似于你的头脑已经习惯的方式来命名你的函数。

比如，当我们想到一杯水的时候，什么是比较积极的？玻璃杯是半满的还是半空的？

虽然它们的意思完全一样，但后者有一个消极的想法，即如果杯子是半空的，我们需要尽快考虑再装满。我们还有水吗？如果不能，我们能坚持一整天吗？

现在，如果我们说杯子是半满的，这是一个积极的概念，即我们“快到了”

现在让我们跳到代码中的函数命名。如果我们正在处理 DOM 节点，并且正在创建一个函数来隐藏或显示元素，那么如何命名一个函数来检查输入元素是否可用呢？

你更愿意用哪一个？两者都没有错。它们都是可以毫无问题地实现相同功能的函数，只是名称不同。

这有什么大不了的？

如果我们想一想我们编写条件语句或检查某件事是否成功的所有时间，大多数时间我们习惯于接收成功尝试的`true`和失败尝试的`false`。

这种情况经常发生，以至于当我们编写或通读代码时，我们可以快速浏览条件语句，并避开我们假设函数行为符合预期的场景，看到如果一切正常，它将返回`true`。

但是仔细想想。如果我们坚持使用`isEnabled`，我们就不必担心“enabled”这个词背后的其他含义。如果`isEnabled`返回 true，那就非常简单了，我们确信如果*未*启用，那么它就意味着*禁用*或`false`。

如果我们坚持使用`isDisabled`，我们必须记住`true`是*而不是*这个函数的正结果。这违背了我们已经习惯的东西！由于这个原因，更容易犯错误的行为会增加代码出错的风险。

这是另一个场景。如果我们从 YAML 字符串中解析值，有时我们会遇到一个(看似)布尔值，其中`true`被写成`"true"`或者`false`被写成`"false"`。

考虑 YAML 语法中的这个例子:

这会解析为 JSON，如下所示:

如果我们要检查一个元素是否隐藏，我们有两个选项可以选择:`isBooleanTrue`和`isBooleanFalse`。

让我们看看如果我们选择`isBooleanFalse`会是什么样子:

即使在写这个函数的时候，我也发现这个语义有点混乱。尽管该行为实现了`toggle`函数的意图，但这种混乱支持了我们的代码应该简单、可读和可维护的一般思想，这就是为什么命名函数如此重要。

# 结论

本帖到此结束！我希望你发现这是有价值的，并期待在未来更多！