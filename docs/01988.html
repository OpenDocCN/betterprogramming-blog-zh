<html>
<head>
<title>Power-Up Your Python Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">启动Python日志记录</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/power-up-your-python-logging-6dd3ed38f322?source=collection_archive---------2-----------------------#2019-10-29">https://betterprogramming.pub/power-up-your-python-logging-6dd3ed38f322?source=collection_archive---------2-----------------------#2019-10-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2a92" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Python的内置日志工具，从初学者到专业人员的指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21175872aca89b6f48de700c4ee14dee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CZSECkpz4Tki4NSqFE71g.jpeg"/></div></div></figure><p id="e712" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">调试大型应用程序很糟糕。特别是当你有一个bug在生产中显示出来，但是在开发环境中却无法重现。使用Python的内置日志工具可以更容易地找到这些问题。</p><p id="0116" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本指南旨在帮助新手理解Python的日志模块。天知道当我第一次开始的时候我很困惑。最终，我们将拥有一个能够将错误抛出到不和谐通道的工作日志记录器。</p><p id="8362" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个问题的代码可以在<a class="ae lq" href="https://github.com/civicsoft/ieddit/tree/master/app/utilities/log_utils" rel="noopener ugc nofollow" target="_blank"> civicsoft/ieddit </a> GitHub资源库中找到。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8b6b" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">日志记录的快速概述</h1><p id="c1da" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">在我们开始日志记录之前，有一点需要注意:下面的日志记录器和处理程序都使用我们所说的<a class="ae lq" href="https://docs.python.org/3/library/logging.html#logging-levels" rel="noopener ugc nofollow" target="_blank">级别</a>。这是如何处理事情的等级制度。</p><p id="161a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，当我们将一个处理程序设置为<code class="fe mv mw mx my b">DEBUG</code>级别时，它将接收调试语句和它上面的所有级别。这些级别用于根据数据的重要性过滤数据。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8d57d966cc18ade66d777e58e0f537c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*Hp-v16ZQbei_bAyvXE2KAw.png"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3ebb" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">记录器</h1><p id="4563" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一个<a class="ae lq" href="https://docs.python.org/3/library/logging.html#logger-objects" rel="noopener ugc nofollow" target="_blank">日志记录器</a>仅仅是日志记录对象的一个命名实例。所有的记录器在你的程序中都是“全局”的。这是一个看起来像什么的例子。</p><p id="d6dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在<code class="fe mv mw mx my b">app.py</code>中定义了一个名为<code class="fe mv mw mx my b">app</code>的记录器。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="a1f3" class="ne lz it my b gy nf ng l nh ni"># ieddit/app.py</span><span id="f6fc" class="ne lz it my b gy nj ng l nh ni">import logging<br/>logger = logging.getLogger("app")</span></pre><p id="785e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们愿意，我们可以放入另一个文件，并访问我们之前创建的那个logger实例。</p><p id="ccc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是它看起来的样子:</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="7f2d" class="ne lz it my b gy nf ng l nh ni"># ieddit/utils.py</span><span id="9906" class="ne lz it my b gy nj ng l nh ni">import logging<br/>logger = logging.getLogger("app")</span></pre><p id="42c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在<code class="fe mv mw mx my b">utils.py</code>可以访问同一个记录器实例了！这意味着我们可以在需要记录器之前声明我们想要的所有记录器，稍后我们将看到这一点。</p><p id="f907" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里要注意的是:最佳实践是使用<code class="fe mv mw mx my b">__name__</code>属性来命名记录器，如下所示:<code class="fe mv mw mx my b">logging.getLogger(__name__)</code>。这样，每个文件都有自己唯一的记录器名称。</p><p id="321e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Logger的核心工作是将<code class="fe mv mw mx my b"><a class="ae lq" href="https://docs.python.org/3/library/logging.html#logrecord-objects" rel="noopener ugc nofollow" target="_blank">LogRecords</a></code>发送给不同的处理程序。<code class="fe mv mw mx my b">LogRecords</code>记录他们被呼叫时发生的事情的细节。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="8a9e" class="ne lz it my b gy nf ng l nh ni">logger.info("Emitting Info LogRecord")<br/>logger.error("Emitting Error LogRecord")</span></pre><p id="fd5a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面是一个发出事件的例子。发出的事件附带一个级别。这让记录器知道<code class="fe mv mw mx my b">LogRecord</code>有多紧急。</p><p id="1f1f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面代码的问题是，我们没有告诉记录器这些记录应该放在哪里。这就是处理程序介入的地方。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f61f" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">经理人</h1><p id="ccae" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated"><a class="ae lq" href="https://docs.python.org/3/library/logging.html#handler-objects" rel="noopener ugc nofollow" target="_blank">处理程序</a>控制<code class="fe mv mw mx my b">LogRecords</code>的去向。处理程序是可以附加到记录器实例的独立对象。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="cf34" class="ne lz it my b gy nf ng l nh ni">logger = logging.getLogger(__name__)<br/>fileHandle = logging.FileHandler('ieddit.log')<br/>logger.addHandler(fileHandle)</span></pre><p id="4cf3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码告诉记录器，任何时候一个<code class="fe mv mw mx my b">LogRecord</code>被创建，它应该被发送到文件<code class="fe mv mw mx my b">ieddit.log</code>。现在的问题是<code class="fe mv mw mx my b">ieddit.log</code>将被一吨原木塞满。</p><p id="093a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">设置处理程序应该管理的级别有助于我们过滤日志。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="f22d" class="ne lz it my b gy nf ng l nh ni">logger = logging.getLogger(__name__)<br/>fileHandle = logging.FileHandler('ieddit.log')<br/>fileHandle.setLevel(logging.WARNING)<br/>logger.addHandler(fileHandle)</span><span id="7321" class="ne lz it my b gy nj ng l nh ni">logger.info("This won't show in ieddit.log")<br/>logger.error("This will show.")</span></pre><p id="57e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以上是我们如何使用级别来过滤日志。使用本节开头的图表，我们可以看到<code class="fe mv mw mx my b">ERROR</code>高于<code class="fe mv mw mx my b">WARNING</code>，因此将对其进行处理。信息低于警告，因此处理程序将忽略该记录。</p><p id="b25a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有几种类型的处理程序可以使用。完整列表见<a class="ae lq" href="https://docs.python.org/3/library/logging.handlers.html#module-logging.handlers" rel="noopener ugc nofollow" target="_blank">处理程序文档</a>。</p><p id="3599" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mv mw mx my b">StreamHandler</code>将输出发送到控制台。文件处理程序将信息发送到输出文件。最动态的处理程序是<code class="fe mv mw mx my b">QueueHandler</code>和<code class="fe mv mw mx my b">QueueListener</code>，但更多的是在后面。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="69db" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">格式化程序</h1><p id="1a06" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">只有一个消息说:“有一个错误”是没有帮助的。这就是格式化程序的用武之地。当处理程序处理日志记录时，格式化程序依赖于处理程序。</p><p id="78ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">他们可以添加附加信息，如地点、内容、原因、时间和方式。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="02ea" class="ne lz it my b gy nf ng l nh ni">logger = logging.getLogger("__main__")<br/>consoleHandle = logging.StreamHandler()<br/>consoleHandle.setLevel(logging.INFO)</span><span id="91f6" class="ne lz it my b gy nj ng l nh ni"># Setup the formatter<br/>formatter = logging.Formatter('<em class="nk">%(asctime)s</em> - <em class="nk">%(name)s</em> - <em class="nk">%(levelname)s</em> - <em class="nk">%(message)s</em>')<br/>consoleHandle.setFormatter(formatter)</span><span id="9cf0" class="ne lz it my b gy nj ng l nh ni">logger.addHandler(consoleHandle)</span><span id="0219" class="ne lz it my b gy nj ng l nh ni">logger.info("Message")</span><span id="fa68" class="ne lz it my b gy nj ng l nh ni">&gt;&gt;&gt; 2019-10-25 00:01:42,283 - __main__ - INFO - Message</span></pre><p id="8840" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面是创建的控制台中的输出。</p><p id="d361" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">格式化程序插入时间、记录器名称、记录级别和消息。注意这里我们手动输入<code class="fe mv mw mx my b">__main__</code>，但是如果你使用<code class="fe mv mw mx my b">__name__</code>，它将是这里的模块名称。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="1e17" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">从上到下</h1><p id="b9aa" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">这是我们目前所知道的关于伐木的情况。</p><p id="f21f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建一个可以在任何地方通过名字访问的记录器。该记录器创建具有相关级别的日志记录。这些记录由一个或多个关联的处理程序处理。如果存在格式化程序，处理程序将相应地格式化输出。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="989a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">队列处理程序和队列监听程序</h1><p id="fe08" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在真正有趣的事情开始了。任何时候你把<code class="fe mv mw mx my b">logger.info(“message”)</code>放入你的代码，你的程序必须等待它完成。</p><p id="c5d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果只是简单地输出到控制台，这不是什么大问题，对吗？</p><p id="8e24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将日志发送到数据库，等待记录创建可能需要一些时间。然后，每次创建日志记录时，您的程序都需要暂停。</p><p id="361d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是<code class="fe mv mw mx my b">QueueHandler</code>和<code class="fe mv mw mx my b">QueueListener</code>出现的地方。<code class="fe mv mw mx my b">QueueHandler</code>将消息放入独立线程的队列中。然后，<code class="fe mv mw mx my b">QueueListener</code>介入，将日志记录发送给所有其他处理程序。</p><p id="160a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，您的程序就不必停下来等待日志记录的创建。</p><p id="23a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我会把你指向<a class="ae lq" href="https://github.com/rob-blackbourn" rel="noopener ugc nofollow" target="_blank">Rob black burn的</a>文章，<a class="ae lq" href="https://medium.com/@rob.blackbourn/how-to-use-python-logging-queuehandler-with-dictconfig-1e8b1284e27a" rel="noopener"> <em class="nk">如何用dictConfig </em> </a>使用Python日志QueueHandler。为了节省篇幅，我将告诉您阅读他的文章，然后回到这里看看如何在我们的自定义记录器中使用它。</p><p id="1c8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">将他文章中的代码添加到一个名为<code class="fe mv mw mx my b">logging_util.py</code>的文件中。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="87fc" class="ne lz it my b gy nf ng l nh ni"># run.py<br/>import logging_util<br/>import logging<br/>from queue import Queue</span><span id="24d4" class="ne lz it my b gy nj ng l nh ni"># Initialize Logger<br/>logger = logging.getLogger(__name__)<br/>logger.setLevel(logging.WARNING)</span><span id="3875" class="ne lz it my b gy nj ng l nh ni">fileHandle = logging.FileHandler('ieddit.log')<br/>queueHandle = logging_util.QueueListenerHandler(<br/>                                     queue=Queue(-1), <br/>                                     handlers=[fileHandle])</span><span id="61d5" class="ne lz it my b gy nj ng l nh ni">logger.warning("Ack!")</span></pre><p id="c92a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的示例中，数据将像这样流动:</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="c9de" class="ne lz it my b gy nf ng l nh ni">Warning Log Record Created<br/>   |<br/>   V<br/>Log record added to QueueHandler on separate thread<br/> -&gt; Main program is no longer blocked<br/>   |<br/>   V<br/>QueueListener picks up the log and hands it to the other handlers for processing<br/>   |<br/>   V<br/>Other handlers format the message and output appropriately</span></pre><p id="1eef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果队列处理程序没有到位，程序将不得不等到结束才能继续。如果您在等待HTTP调用解析，这将耗费宝贵的时间。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2bda" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">自定义不一致处理程序</h1><p id="618e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">现在我们可以进入一些更有趣的东西。Ieddit.com有一个不和谐的服务器。由于网站的设置方式，只有创建者可以访问网站发布的错误日志。</p><p id="6910" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">唯一合乎逻辑的补救办法是将错误输出到一个不协调的通道。这就是我们所做的。这需要一些设置。参见<a class="ae lq" href="https://pypi.org/project/discord-webhook/" rel="noopener ugc nofollow" target="_blank"> discord-webhook的</a>文档进行配置。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="248f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码创建了一个扩展了<code class="fe mv mw mx my b">logging.Handler</code>类的类。当它被初始化时，它根据配置文件设置它的webhook URL。然后，当一个记录被发出时，它被转发到Discord。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="18c2" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">使用文件初始化记录器</h1><p id="2eaf" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">最后要做的是创建一个文件来初始化我们所有的记录器。在需要它们之前创建它们可以让我们避免重复代码。我们可以在一个地方创建和连接所有的记录器。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="db08" class="ne lz it my b gy nf ng l nh ni"># Logger Config.yaml<br/>version: 1<br/>objects:<br/>  queue:<br/>    class: queue.Queue<br/>    maxsize: 1000<br/>formatters:<br/>  simple:<br/>    format: '%(asctime)s - %(levelname)s - %(name)s - %(message)s'</span><span id="10f7" class="ne lz it my b gy nj ng l nh ni">handlers:<br/>  discord:<br/>    class: utilities.log_utils.logger_util.DiscordHandler<br/>    level: ERROR<br/>    formatter: simple<br/>  queue_listener:<br/>    class: utilities.log_utils.logger_util.QueueListenerHandler<br/>    handlers:<br/>      - cfg://handlers.console<br/>      - cfg://handlers.file<br/>      - cfg://handlers.discord<br/>    queue: cfg://objects.queue</span><span id="04ec" class="ne lz it my b gy nj ng l nh ni">loggers:<br/>  __main__:<br/>    level: WARNING<br/>    handlers:<br/>      - queue_listener<br/>    propagate: false<br/>  ieddit:<br/>    level: WARNING<br/>    handlers:<br/>      - queue_listener<br/>    propagate: false</span></pre><p id="cbf6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个示例配置文件的样子。注意，对于类之类的东西，我们使用定义好的模块名。</p><p id="754d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们可以使用一个<code class="fe mv mw mx my b">logger_init.py</code>文件来获取所有这些组件并生成日志程序。</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="a84a" class="ne lz it my b gy nf ng l nh ni"># logger_init.py<br/>import os<br/>import config</span><span id="5ea5" class="ne lz it my b gy nj ng l nh ni"># Setup For Logging Init<br/>import yaml<br/>import logging<br/>import utilities.log_utils.logger_util</span><span id="927a" class="ne lz it my b gy nj ng l nh ni"># Pull in Logging Config<br/>with open('logger_config.yaml', 'r') as stream:<br/>  try:<br/>    logging_config = yaml.load(stream, Loader=yaml.SafeLoader)<br/>  except yaml.YAMLError as exc:<br/>    print("Error Loading Logger Config")<br/>    pass</span><span id="51fe" class="ne lz it my b gy nj ng l nh ni"># Load Logging configs<br/>logging.config.dictConfig(logging_config)</span></pre><p id="e4f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用这段相当短的代码，我们可以初始化所有我们想要的记录器和处理程序。</p><p id="6c89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，为了使用它们，我们只需要将<code class="fe mv mw mx my b">logger_init.py</code>导入到我们的顶层文件中。然后，在所有其他的函数中，我们导入<code class="fe mv mw mx my b">logging</code>并设置我们的记录器！</p><pre class="kj kk kl km gt na my nb nc aw nd bi"><span id="16e7" class="ne lz it my b gy nf ng l nh ni"># run.py<br/>import logging<br/>import logger_init # Only call at the top file in </span><span id="f99a" class="ne lz it my b gy nj ng l nh ni">import logging</span><span id="5ea0" class="ne lz it my b gy nj ng l nh ni">logger = logging.getLogger("__main__")</span><span id="a1f2" class="ne lz it my b gy nj ng l nh ni">logger.warning("Woohoo I am Logging!")</span></pre><p id="8aaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要查看这段代码的运行情况，请查看ieddit.com的<a class="ae lq" href="https://github.com/civicsoft/ieddit/tree/master/app/utilities/log_utils" rel="noopener ugc nofollow" target="_blank"> GitHub </a>页面，在这里可以使用所有的示例。</p><p id="8778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读，请继续关注更多Python和编程内容。再次特别感谢Rob Blackbourn允许我在这篇文章中使用他的代码。</p></div></div>    
</body>
</html>