<html>
<head>
<title>RxJS Testing — Write Unit Tests for Observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS测试——为可观察性编写单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjs-testing-write-unit-tests-for-observables-603af959e251?source=collection_archive---------2-----------------------#2022-06-14">https://betterprogramming.pub/rxjs-testing-write-unit-tests-for-observables-603af959e251?source=collection_archive---------2-----------------------#2022-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="225c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过使用RxJS测试特性编写测试来提高您的单元测试技能。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ed38d5876f3f0eb8aa00f1b9a67f51c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NOPLpI2t91VPvGg9"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@davynben?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Davyn Ben </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="06f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">RxJS是一套非常强大和酷的工具，用于创建反应式应用程序。在开发Angular应用程序时，您很可能会遇到RxJS，所以我假设您熟悉如何使用它。</p><p id="2f48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，当我大约三年前开始使用Angular时，当我问他们如何用observables进行测试时，我得到了一些困惑的表情。下面是我是如何开始和结束为可观测性编写单元测试的。</p><h1 id="3a39" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">天真的初学者示例</h1><p id="bfcf" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们从一个简短的例子开始:一个函数，它接受一个句子，并以相反的顺序返回它。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c4f5" class="mu lt iq mq b gy mv mw l mx my">export function myFunction1(x: string): Observable&lt;string&gt; {<br/>  return of(x).pipe(<br/>    map((x) =&gt; x.split(' ')),<br/>    map((x) =&gt; x.reverse()),<br/>    map((x) =&gt; x.join(' '))<br/>  );<br/>}</span></pre><p id="1db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我想向您展示当我开始用observables进行单元测试时，典型的单元测试是什么样子的:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="0f2f" class="mu lt iq mq b gy mv mw l mx my">describe('RxJS', () =&gt; {<br/>  it('returns simple value', () =&gt; {<br/>    const y = myFunction1('humans eat tomatoes');</span><span id="d7c1" class="mu lt iq mq b gy mz mw l mx my">    y.subscribe((value) =&gt; expect(value).toBe('tomatoes eat humans'));<br/>  });<br/>});</span></pre><p id="8030" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，这是一个简单的方法，毫无疑问，它很有效。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/a0cd245460237a6573cd7179e2f36b2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*MnIUuf-QQxdMj9OzK2v4sA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">成功测试</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="780c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不知道这部电影，它是人类历史上最糟糕的恐怖电影之一。如果你想浪费时间，绝对值得一看。</p><p id="65f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，让我们异步调用并增加一些延迟:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4dd5" class="mu lt iq mq b gy mv mw l mx my">export function myFunction1(x: string): Observable&lt;string&gt; {<br/>  return of(x).pipe(<br/>    map((x) =&gt; x.split(' ')),<br/>    map((x) =&gt; x.reverse()),<br/>    map((x) =&gt; x.join(' ')),<br/>    delay(10)<br/>  );<br/>}</span></pre><p id="331e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍看之下，这个测试显然是成功的，但是当你仔细观察时，你会发现这个测试没有任何预期。这意味着我们的测试没有检查任何东西。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/1c557454218d9ae5870a55c92551c38e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*Mtk_3fhuXmIB3uKKVdHnEA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">成功的测试，但没有期望。</p></figure><p id="a783" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可能会收到以下警告:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/870b49e3c45423b1c1bd1811e1defb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1170/format:webp/1*r1s4Qh3pUuw_Ovr9wTkHvA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由于超时，测试失败。</p></figure><p id="4c29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试只是在计算发出的值之前完成。一种简单的方法是对其进行异步测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><p id="386b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干得好！它工作了。顺便说一下，将<code class="fe ng nh ni mq b">async</code>放在测试用例回调的前面是不起作用的，除非你运行一个可承诺的测试用例。另一方面，您可以使用<code class="fe ng nh ni mq b"><a class="ae kv" href="https://angular.io/api/core/testing/fakeAsync" rel="noopener ugc nofollow" target="_blank">@angular/testing</a></code>包中的<code class="fe ng nh ni mq b">fakeAsync()</code>来代替，并使用<code class="fe ng nh ni mq b">tick()</code>来模拟一个计算周期。</p><p id="d374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这不是我们想要用于复杂RxJS测试的。我们想用正确的方式来做:RxJS测试</p><h1 id="852e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">大理石图</h1><p id="2698" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所以，让我们从大理石图的一些基础开始。如果您使用可观测量，您可以考虑像溪流或流动一样的值的发射。当您将运算符应用于流时，值将会改变，并且后续的流会发出其他值。你有某种输入值，相应的操作符，它修改输入值和结果输出值(见下面的<code class="fe ng nh ni mq b">map()</code>操作符的例子)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/06e8099e4ed39a6b22fa61ae9b916872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPeRnQMWq9Wn69r6kDtfNg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">简单的大理石图</p></figure><p id="dcdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在你可以给每个发射值分配一个字母，比如<code class="fe ng nh ni mq b">a</code>、<code class="fe ng nh ni mq b">b</code>和<code class="fe ng nh ni mq b">c</code>。流的末端用管道<code class="fe ng nh ni mq b">|</code>表示。错误用一个<code class="fe ng nh ni mq b">#</code>来表示。现在可能的情况是，在发射值之间经过了一段时间。可观测的时间可以用虚拟帧来表示，虚拟帧通常为1毫秒长，用<code class="fe ng nh ni mq b">-</code>或类似于<code class="fe ng nh ni mq b">5s</code>或<code class="fe ng nh ni mq b">100ms</code>的时间级数值来表示。如果在同一时间范围内发出多个值，您可以使用<code class="fe ng nh ni mq b">()</code>将它们组合在一起。一些例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="56e6" class="mu lt iq mq b gy mv mw l mx my">a--b| // emits 'a' then after ~40ms 'b' and completes<br/>(a|)  // emits 'a' and completes immediately <br/>a--b-a--c-a--| // emits a series of values<br/>a---# // emits 'a' and errors out after some time.</span></pre><h1 id="114e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><code class="fe ng nh ni mq b">rxjs/testing</code></h1><p id="23bb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">RxJS附带了一个方便的工具集，使用如上所述的大理石图来测试可观测量。</p><p id="4a9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要一个<code class="fe ng nh ni mq b">TestScheduler</code>，我们把它放在单元测试文件的顶部:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><p id="caa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以再次调整我们的单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><p id="79fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试又变绿了。万岁！但是让我们检查一下我们在这里添加了什么。首先，我们定义我们期望的大理石图(1)。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="202f" class="mu lt iq mq b gy mv mw l mx my">----------(a|) // after 10 'ticks' the observable emits 'a' and completes immediately after that.</span></pre><p id="6a7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用写<code class="fe ng nh ni mq b">---------- </code>来表示10ms的时间，也可以直接写<code class="fe ng nh ni mq b">10ms (a|)</code>。</p><p id="0f56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们定义我们的期望值(2)，其中我们用来自我们的大理石图的键和相应的值创建一个对象结构。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3ff8" class="mu lt iq mq b gy mv mw l mx my">const expectedValues = {<br/>  a: 'tomatoes eat humans',<br/>};</span></pre><p id="0a1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们让测试调度程序运行(3)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><h1 id="787f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">读取错误</h1><p id="c7e2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在，当一切正常时，单元测试是绿色的，我们都很好。然而，通常情况下，事情不会马上解决。如果出了问题，我们会得到什么？</p><p id="3c15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看我们的测试调度程序实际上在比较什么。概括一下，这是我们的比较器:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6bbd" class="mu lt iq mq b gy mv mw l mx my">(actual, expected) =&gt; { return expect(actual).toEqual(expected) }</span></pre><p id="75fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是对类型为<code class="fe ng nh ni mq b">any</code>的实际值和期望值的深度相等检查，咄！<br/>无论如何，这项检查实际上是在验证几件事情，这可能发生在订阅期间。</p><p id="f5ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有四种类型的问题:</p><ul class=""><li id="f03b" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">帧的长度(即意外发射的项目数)</li><li id="67d5" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">帧的数量(即，预期的时间帧是意外的)</li><li id="0600" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">帧的种类(即项目、完成、错误、订阅、取消订阅)</li><li id="1728" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">帧值(即发出的项目值或错误消息)</li></ul><p id="a545" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设，我们在函数中忘记了一些东西:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="642c" class="mu lt iq mq b gy mv mw l mx my">export function myFunction1(x: string): Observable&lt;string&gt; {<br/>  return of().pipe(           // we forgot to call of(x)<br/>    map((x) =&gt; x.split(' ')),<br/>    map((x) =&gt; x.reverse()),<br/>    map((x) =&gt; x.join(' ')),<br/>    delay(10)<br/>  );<br/>}</span></pre><p id="a38e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们得到的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/4b452a6e07ece2832e30699c1e86d9e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFRc1yRNnXkK8Fyplb_22Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">各种错误</p></figure><h2 id="7be6" class="mu lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">帧长度不正确</h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c781" class="mu lt iq mq b gy mv mw l mx my">Expected $.length = 1 to equal 2.</span></pre><p id="a05c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的错误告诉我们，我们期望两个帧，但只得到一个。所以你得到了<code class="fe ng nh ni mq b">Expected $.length = X to equal Y</code>，当你发射的物品比预期的多或少。</p><h2 id="2375" class="mu lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">帧号不正确</h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="db96" class="mu lt iq mq b gy mv mw l mx my">Expected $[0].frame = 0 to equal 10.</span></pre><p id="44e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述错误表明，帧号不正确。所以你得到了<code class="fe ng nh ni mq b">Expected $[i].frame = X to equal Y</code>，其中<code class="fe ng nh ni mq b">i</code>是该帧的索引，也就是我们例子中的第一帧。</p><h2 id="3fba" class="mu lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">框架类型不正确</h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d261" class="mu lt iq mq b gy mv mw l mx my">Expected $[0].notification.kind = 'C' to equal 'N'.</span></pre><p id="3722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述错误表明帧的种类或类型不正确。因此，如果流发出另一种类型的信号，你就会得到<code class="fe ng nh ni mq b">Expected $[i].notification.kind = '...' to equal '...'</code>。典型的信号有:</p><ul class=""><li id="a754" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><code class="fe ng nh ni mq b">N</code> =发射项目</li><li id="afec" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe ng nh ni mq b">C</code> =完成</li><li id="6c2a" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe ng nh ni mq b">E</code> =错误</li></ul><p id="bff5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们期望在第一帧有一个项目，但是得到了一个完成信号。</p><h2 id="c60c" class="mu lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">帧值不正确</h2><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bc86" class="mu lt iq mq b gy mv mw l mx my">Expected $[0].notification.value = undefined to equal 'tomatoes eat humans'.</span><span id="bbd3" class="mu lt iq mq b gy mz mw l mx my">Expected $[1] = undefined to equal Object({ frame: 10, notification: Object({ kind: 'C', value: undefined, error: undefined }) }).</span></pre><p id="0415" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述错误表明框架/项目的值不正确。所以如果实际值不正确，就会得到<code class="fe ng nh ni mq b">Expected $[i].notification.value = ... to equal ...</code>。在第二个误差中，你可以看到，这种误差也适用于整个帧。在我们的例子中，第一帧的值是未定义的，但应该包含“番茄吃人”，而第二帧根本不存在。</p><h1 id="339d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">科目呢？</h1><p id="3d28" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">有时您有事件驱动的用例，其中您有触发器，它导致任何类型的动作，和事件管道，您可以在其中监听更新。</p><p id="bc93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的例子是一个带有初始值的<code class="fe ng nh ni mq b">BehaviorSubject</code>。每次我们调用<code class="fe ng nh ni mq b">add</code>或<code class="fe ng nh ni mq b">minus</code>函数时，我们都使用<code class="fe ng nh ni mq b">scan</code>操作符来计算当前值和新值之和。例如，这两个函数可以绑定到按钮和输入字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><p id="3e14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们为此编写单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><p id="9aad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是结果，目前为止是好的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/97bd0cd54f0bb0aceea7cd2e6039d653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Movo-OiYxoMddgdaqxXHg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">科目测试成功</p></figure><p id="1524" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我们现在如何触发函数调用呢？一个简单的实现应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><p id="0e7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但这是行不通的。根本没有发射任何项目。为什么会这样？本质上是因为<code class="fe ng nh ni mq b">testScheduler</code>在自己的同步范围内运行，因此<code class="fe ng nh ni mq b">setTimeout</code>的两个任务在测试后执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/8d881016c135268940b7c27f019b97d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuUeCCbRjkJzfac4KzpopA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">使用触发器时测试失败</p></figure><p id="ccc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们必须在<code class="fe ng nh ni mq b">testScheduler</code>范围内运行触发器。除了<code class="fe ng nh ni mq b">expectObservable</code>之外，<code class="fe ng nh ni mq b">testScheduler</code>还提供了一些额外的助手。你可以在这里找到关于他们的文档:<a class="ae kv" href="https://rxjs.dev/guide/testing/marble-testing#api" rel="noopener ugc nofollow" target="_blank">https://rxjs.dev/guide/testing/marble-testing#api</a></p><p id="03c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe ng nh ni mq b">triggerMarbles</code>和<code class="fe ng nh ni mq b">triggerValues</code>我们可以创建函数调用，它会在我们需要的确切时间发生。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="28e3" class="mu lt iq mq b gy mv mw l mx my">const triggerMarbles = '-abcabc';<br/>const triggerValues = {<br/>  a: () =&gt; add(5),<br/>  b: () =&gt; add(2),<br/>  c: () =&gt; minus(7),<br/>};</span></pre><p id="3409" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在需要<code class="fe ng nh ni mq b">cold</code>助手来运行这些触发器:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c342" class="mu lt iq mq b gy mv mw l mx my">testScheduler.run(({ expectObservable, cold }) =&gt; {<br/>  ...<br/>  expectObservable(<br/>    cold(triggerMarbles, triggerValues).pipe(tap(fn =&gt; fn()))<br/>  );<br/>});</span></pre><p id="dc07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mq b">expectObservable</code>订阅(以及退订)我们的cold observable。用<code class="fe ng nh ni mq b">.pipe(tap(fn =&gt; fn()))</code>我们运行相应的触发功能。</p><p id="cf34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以调整预期输出:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="58ad" class="mu lt iq mq b gy mv mw l mx my">const expectedMarbles = 'abcabca';<br/>const expectedValues = {<br/>  a: 0,<br/>  b: 5,<br/>  c: 7,<br/>};</span></pre><p id="72bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">把所有东西放在一起，我们有这个单元测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf nc l"/></div></figure><h1 id="8054" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">已知限制</h1><p id="ab03" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可以在这里了解已知的限制:<a class="ae kv" href="https://rxjs.dev/guide/testing/marble-testing#known-issues" rel="noopener ugc nofollow" target="_blank">已知问题</a>。然而，我想总结其中一些，因为它们可能不是那么明显。</p><h2 id="64fb" class="mu lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">Promises / setTimeout()</h2><p id="0603" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">承诺不支持作为可观察的来源，即类似下面的代码不能用<code class="fe ng nh ni mq b">testScheduler</code>断言:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="02c7" class="mu lt iq mq b gy mv mw l mx my">from(Promise.resolve('something'))</span></pre><p id="b752" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着，每个API都会返回一个承诺，比如封装在observables中的<code class="fe ng nh ni mq b">fetch()</code>或<code class="fe ng nh ni mq b">async</code>函数。为了让这些工作，你必须退回到上面解释的异步测试，例如使用<code class="fe ng nh ni mq b">done()</code>。</p><h1 id="4e65" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">鳍！</h1><p id="6cee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可以在这个stackblitz项目中找到上面的例子:<a class="ae kv" href="https://stackblitz.com/edit/rxjs-testing-kit?file=main.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/rxjs-testing-kit?file=main.ts</a></p><p id="d611" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这能帮助你用RxJS observables编写单元测试。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/62d436b7e8a228168717ba1c0b09eb03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_oIIrKQw9mJ85uDS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@theblowup?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">上的</a>放大<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">去飞溅</a></p></figure></div></div>    
</body>
</html>