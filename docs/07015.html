<html>
<head>
<title>The Objective-C Runtime — Want to See Some Weird Things?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Objective-C运行时——想看看一些奇怪的东西吗？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/objective-c-runtime-want-to-see-some-weird-things-3a236e422767?source=collection_archive---------5-----------------------#2020-11-27">https://betterprogramming.pub/objective-c-runtime-want-to-see-some-weird-things-3a236e422767?source=collection_archive---------5-----------------------#2020-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7760" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">4样东西和额外的小费</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/22848d7f8f11d112339cc8fe150641e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xIZloEvksIC1sKM4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jonatan Pie </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄。</p></figure><p id="c62a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">iOS开发如今更侧重于基于Swift的代码。但是Objective-C还在，而且很长一段时间都不会移除。您可能已经看过一些ObjC代码，许多人在看到这些代码时都会感到震惊:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">括号无处不在。我对此并不感到震惊。也许我应该去找个人谈谈。</p><p id="b7b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论如何，ObjC可以很强大，ObjC运行时可以做出一些疯狂的事情。我会在这篇文章中分享一些例子。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="f6a1" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">如何使用ObjC运行时</h1><p id="5901" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">这很简单。导入它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ff1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，Swift中没有要导入的内容。就用吧。方法很多，我就不一一解释了。就几个。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="6111" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">这篇文章将涵盖哪些内容？</h1><ul class=""><li id="6a9e" class="my mz iq ky b kz mt lc mu lf na lj nb ln nc lr nd ne nf ng bi translated">搅拌方法</li><li id="fed8" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">方法创建和替换方法实现</li><li id="81e0" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">获取所有可用的类</li><li id="b63c" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">我对运行时做的最奇怪的事情</li><li id="ec4b" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">额外小费</li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="6453" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">搅拌方法</h1><p id="f333" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">这是开发人员在使用ObjC-runtime时最常做的一件事。事实上，我不确定Swift开发者意识到通过使用swizzling方法，他们是在使用ObjC。</p><p id="ac37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是什么是“swizzling”呢？</p><p id="0df2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Swizzling方法可以翻译成“交换方法的内容”</p><p id="1206" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">等等，什么？交换方法的内容？这是巫术。</em></p><p id="c1da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是对的。确实是。</p><p id="191c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，让我们说，你想拦截所有的推送通知之前，给应用程序。乍一看是不行的，因为iOS大部分时候是把通知内容传给<code class="fe nn no np nq b">UNUserNotificationCenterDelegate</code>、<em class="nm">、</em>也就是<code class="fe nn no np nq b">AppDelegate</code>或者<code class="fe nn no np nq b">SceneDelegate</code>。所以你被它卡住了，你只能在<code class="fe nn no np nq b">UNUserNotificationCenterDelegate</code>收到通知后调用你的一个方法。</p><p id="4a18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是ObjC-runtime与<code class="fe nn no np nq b">method_exchangeImplementations</code>的关系。</p><p id="e2ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事情会变得很奇怪:</p><ol class=""><li id="91ef" class="my mz iq ky b kz la lc ld lf nr lj ns ln nt lr nu ne nf ng bi translated">获取您想要交换的类(是的，类—不是实例化的对象)的方法实现。</li><li id="4bf5" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nu ne nf ng bi translated">获取要与之交换方法的类的方法实现。</li><li id="bbdb" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nu ne nf ng bi translated">进行方法交换。</li></ol><p id="7de8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就这么简单。</p><p id="9a60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许用一点代码，你会更容易得到它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="bf91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里最重要的要求是在初始化时继续搅拌。如果之后进行重组，它将无法正常工作或运行。</p><p id="1748" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嘿，没那么简单。嗯，没有。只是看一下这个方法的内容:</p><pre class="kg kh ki kj gt nv nq nw nx aw ny bi"><span id="de30" class="nz mc iq nq b gy oa ob l oc od">myClassPushApplication:didReceiveRemoteNotification:fetchCompletionHandler:</span></pre><p id="21c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你刚刚注意到最奇怪的事情，不是吗？</p><p id="91e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，该方法调用自身。嗯，不完全是因为您通过ObjC-runtime交换了方法的实现。您在方法中编写的代码:</p><pre class="kg kh ki kj gt nv nq nw nx aw ny bi"><span id="7216" class="nz mc iq nq b gy oa ob l oc od">myClassPushApplication:didReceiveRemoteNotification:fetchCompletionHandler:</span></pre><p id="6e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行中的方法<code class="fe nn no np nq b">AppDelegate</code>:</p><pre class="kg kh ki kj gt nv nq nw nx aw ny bi"><span id="004a" class="nz mc iq nq b gy oa ob l oc od">application:didReceiveRemoteNotification:fetchCompletionHandler<strong class="nq ir"><em class="nm">:</em></strong></span></pre><p id="32eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一开始你不会注意到。你的大脑还没有准备好阅读这样的东西，这很正常。为了简化，假设您在<code class="fe nn no np nq b">AppDelegate</code>中编写代码，但是在<code class="fe nn no np nq b">MyClass</code>中，ObjC运行时交换方法实现。</p><p id="9c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是您应该注意到一些事情:当swizzling完成一次时，它将为所有的<code class="fe nn no np nq b">MyClass</code>实例完成。这就是为什么你会看到一个<code class="fe nn no np nq b">sharedInstance</code>。这是为了避免多次痛饮。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="6c03" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">方法创建和替换方法实现</h1><p id="f0b7" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">什么？！</p><p id="d02f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你没看错。我们正在讨论方法创建和替换。对于整个班级来说。</p><p id="6c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以推送通知为例，我们可以检查原始方法是否存在(在<code class="fe nn no np nq b">AppDelegate</code>中的那个)。</p><p id="fff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是怎么变魔术的？</p><p id="f8e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，你可能会想到<code class="fe nn no np nq b">respondsToSelector</code>，但是它需要原始类的一个实例。在我的例子中，我只有<code class="fe nn no np nq b">class</code>——没有实例变量。</p><p id="d91e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我将使用ObjC运行时方法<code class="fe nn no np nq b">class_addMethod</code>。</p><p id="fa75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果结果为假，则说明该方法存在于原<code class="fe nn no np nq b">class</code>中。如果为真，则为<code class="fe nn no np nq b">class</code>创建方法，但不实现。就像一个内部空无一物的方法签名。</p><p id="4dff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑到这一点，你会问，“为什么我要添加一个空方法，因为它在任何地方都没有被引用，所以不能被调用？”好吧，你可以用你自己的方法替换创建的方法:<code class="fe nn no np nq b">class_replaceMethod</code>。</p><p id="01c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，让我们改进一下之前的搅酒方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="bfdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它通过检查原始方法是否存在于<code class="fe nn no np nq b">AppDelegate</code>中来提高方法的切换能力。如果您构建一个依赖于<code class="fe nn no np nq b">PushNotification</code>的SDK，但是应用程序的开发人员并没有在其<code class="fe nn no np nq b">AppDelegate</code>中包含所有的委托方法，那么这可能是有用的。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="200e" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">获取所有可用的类</h1><p id="fac8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">这个技巧非常简单。它列出了所有可用的类。</p><p id="bb68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">全部？</em></p><p id="7beb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，是的。你也有iOS的。</p><p id="139e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">但是……为什么？</em></p><p id="821c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您的应用程序中有多个组件，但是不知道这些类。但是，您可以确定您想要定位的每个类都遵守一个协议。列出所有可用的类并测试协议符合性将是获得您想要的特定类的最佳方式。</p><p id="a624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了做到这一点，ObjC运行时让我们可以访问一个名为<code class="fe nn no np nq b">objc_getClassList</code>的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="b00f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一次调用中使用参数<code class="fe nn no np nq b">NULL</code>和<code class="fe nn no np nq b">0</code>，您将只得到可用类的总数，而没有类定义。创建一个数组，对象<code class="fe nn no np nq b">classList</code>，大小为数字<strong class="ky ir">是很有用的。</strong>第二次调用<code class="fe nn no np nq b">objc_getClassList</code><strong class="ky ir"/>将用类定义填充数组。</p><p id="5272" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，您可以检查这些类是否响应特定的选择器，并对这些类执行您想要的操作。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="3898" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">我对运行时做的最奇怪的事情</h1><p id="a848" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">假设你想窥探类的道具和值。</p><p id="147b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我现在就阻止你。你为什么要窥探职业的道具和价值？</p><p id="7b2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，对于一些用例来说，统计一些屏幕的可见性或来自未知<code class="fe nn no np nq b">ViewControllers</code>的一些数据可能会很棒。我不会进一步详述，但这是我得到的一个用例。</p><p id="e0a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将使用ObjC运行时的两个方法:<code class="fe nn no np nq b">class_copyPropertyList</code>和<code class="fe nn no np nq b">property_getName</code>。</p><p id="a9cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是<code class="fe nn no np nq b">class_copyPropertyList</code>，将给出一个类中可用的属性数组。第二个，<code class="fe nn no np nq b">property_getName</code>，将给出属性的名称。</p><p id="ea99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">就这样？</em></p><p id="df08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不，没那么简单。当您获得属性的名称时，它不是一个直接可用的字符串。因此，您需要进行一些字符串解析，以便只获得作为可用字符串的属性名。</p><p id="6fcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们深入一些代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，但是我现在如何使用它呢？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="fd7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不错！有了这段代码，我可以从所有可用的类中提取所有的对象。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="0ede" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">结论</h1><p id="9e60" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">Objective-C运行时有一些您可以使用的强大工具。这是一个奇怪的工具，但要小心你能做什么。有人说强大的能力伴随着巨大的责任，所以你要对你在ObjC运行时所做的事情负责。</p><p id="acda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也应该意识到一些工具是危险的。例如，多次使用同一个方法是非常危险的，会导致一些很难调试的崩溃。</p><p id="7f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">特别感谢</em></p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="f19b" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">额外提示:在Info.plist中没有声明字体的情况下加载字体</h1><p id="07a5" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">嗯，这不使用ObjC运行时，但我认为这是伟大的分享。要在iOS上使用自定义字体，必须在项目的<code class="fe nn no np nq b">Info.plist</code>中声明字体。</p><p id="e950" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是理论。您实际上只能加载带有代码的字体。CGFont和朋友可以做得很好:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1a05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提供的<code class="fe nn no np nq b">NSData</code>是字体文件内容。</p><p id="011a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nm">好吧，但显然有些事情你不能这么做。</em></p><p id="d68e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你说得对。不能用故事板或者Xib的字体。你只能在代码中使用它。</p></div></div>    
</body>
</html>