<html>
<head>
<title>Stop Using Express.js For Web Servers, Consider NestJS Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止对Web服务器使用Express.js，考虑使用NestJS</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stop-using-express-js-to-make-web-servers-faed1942eaf3?source=collection_archive---------0-----------------------#2021-08-23">https://betterprogramming.pub/stop-using-express-js-to-make-web-servers-faed1942eaf3?source=collection_archive---------0-----------------------#2021-08-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="92b5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这就是为什么NestJS是更好的选择</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/49837b0f70e76b8375353d9d796992e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZI-pSuTo4BrKb1cv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="72c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在Google上搜索如何在Node.js中构建web服务器，大多数教程都会推荐Express.js，理由很充分——对于那些不熟悉Node.js、Javascript、HTTP服务器或这三者的人来说，它是一个灵活而简单的工具。然而，它的流行经常给新开发人员留下一个错误的概念，即Express是在Node中构建服务器的最佳方式。</p><p id="d255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，这并不是一个很好的选择，尤其是对于企业应用来说。</p><p id="daec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今——尤其是在Node.js领域——人们神秘地偏爱轻量级、非个人化的库，而不是包含电池的框架。这是为什么还不完全清楚。使用为个人设计选择留有余地的极简框架可能感觉很好，但是是什么让你的设计选择比那些经验丰富的软件工程师的设计选择更好呢？可能没什么。</p><p id="4781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非个性化框架迫使开发人员重新设计已经设计好的轮子。</p><p id="3716" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么高效的软件开发人员会利用现有的工具，这些工具已经在许多不同的用例中经过了多年的尝试和测试。</p><p id="7df6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，有哪些替代的表达方式呢？</p><p id="9b01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有像Koa，Fastify，<code class="fe lw lx ly lz b">hapi</code>这样的库。但是它们只共享Express采用极简、轻量级的方法——因此在提供更健壮的开箱即用的体系结构方面几乎没有帮助。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9aae" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">输入NestJS</h1><p id="f2c7" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">NestJS是一个真正包含电池的框架。它是一个类型脚本优先的库，为模块化web服务器应用程序使用基于类的架构。它为GraphQL和WebSockets等工具提供官方支持，包括一流的文档。它的依赖注入架构改进了代码组织，简化了测试，增加了测试覆盖率。</p><p id="fdab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切可能会让你想起Angular，这是应该的，因为NestJS从Angular那里借鉴了很多设计。如果这让你感到害怕，那也不应该——但稍后会有更多的内容。</p><p id="3938" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从了解NestJS的一些常见的第一反应开始。</p><h2 id="1c13" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">“Javascript中的类？Ew。”</h2><p id="b9af" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我通常建议Javascript开发人员避免使用类，原因很简单:它们通常不是必需的，越简单越好。但是回想一下，NestJS采用了依赖注入方法(稍后将详细介绍)，这几乎需要使用类——在NestJS中，它工作得非常好。</p><p id="9fbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还怀疑？我也在这个时候。继续读。</p><h2 id="38f5" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">“打字稿？似乎太多了”</h2><p id="e1b2" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">您<em class="lv">可以</em>将NestJS与普通的旧Javascript一起使用，但是我(和NestJS团队)强烈建议不要这样做。您将失去依赖注入的许多好处— <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/the-bad-reasons-people-avoid-typescript-and-the-better-reasons-why-they-shouldnt-86f8d98534de">并且无论如何您都应该对Node.js项目使用TypeScript。</a></p><p id="4890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有开始学习TypeScript，但是有兴趣的话，这是一个很好的学习机会。</p><h2 id="4ccb" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">“我还不如用Java构建一个服务器”</h2><p id="71ab" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">如果你习惯于轻量级库，很容易将任何较大的框架视为仅仅是在Node.js中模仿Java和OOP架构的尝试，毫无疑问，与Express这样的库相比，具有OOP背景的开发人员会更熟悉NestJS。但是不要因为这个原因而放弃它，保持开放的心态，您将会看到NestJS使用的设计模式是如何令人惊讶的有意义，即使对于像TypeScript这样的非面向对象语言。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5094" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">NestJS有什么好的？</h1><p id="7a4c" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">诚然，这是一种后天养成的习惯，但也有很多东西值得喜爱。</p><h2 id="d1b3" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">模块性</h2><p id="daad" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">无论你喜欢OOP还是函数式，类型脚本还是Javascript，每个软件工程师都喜欢模块化。</p><p id="d309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代REST APIs通常对每种数据模型类型都有不同的路径——例如，与文章相关的路由可能位于<code class="fe lw lx ly lz b">/articles</code>，而用户的路由位于<code class="fe lw lx ly lz b">/users</code>。因此，按模型分离代码很有意义。</p><p id="b92f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<em class="lv">是Express中的</em>标准实践，但是它绝对是NestJS架构不可或缺的。一个NestJS应用程序由每种数据类型的模块组成——例如，<code class="fe lw lx ly lz b">ArticlesModule</code>和<code class="fe lw lx ly lz b">UsersModule</code>——它们都位于一个根<code class="fe lw lx ly lz b">AppModule</code>下。</p><h2 id="0197" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">控制器和服务</h2><p id="cf80" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">所以，<code class="fe lw lx ly lz b">ArticlesModule</code>处理与阅读和更新文章的路线和逻辑有关的一切。但是我们可以进一步分离处理路由和执行业务逻辑的不同关注点——这正是控制器和服务(分别)的用武之地。</p><p id="7200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lw lx ly lz b">ArticlesModule</code>会有一个<code class="fe lw lx ly lz b">ArticlesController</code>和一个<code class="fe lw lx ly lz b">ArticlesService</code>。我们将从服务开始，它定义了对文章进行CRUD操作的方法。例如，在<code class="fe lw lx ly lz b">ArticlesService</code>类中，我们可以定义一个通过id获取文章的方法:</p><pre class="kj kk kl km gt nq lz nr ns aw nt bi"><span id="2e00" class="ne mi it lz b gy nu nv l nw nx">getArticleById(articleId: string) {<br/>  return this.db.articles.findById(articleId);<br/>}</span></pre><p id="18a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相比之下，控制器为每条<code class="fe lw lx ly lz b">articles</code>路线定义了一种方法。每个方法指定路由的路径，处理路由参数和请求体，以及许多其他可能的职责。</p><p id="1097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以在<code class="fe lw lx ly lz b">ArticlesController</code>中定义以下路线:</p><pre class="kj kk kl km gt nq lz nr ns aw nt bi"><span id="f80e" class="ne mi it lz b gy nu nv l nw nx">@Get('/:articleId')<br/>getArticleById(@Param() params) {<br/>  return this.articlesService.getArticleById(params.articleId);<br/>}</span></pre><p id="c418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里需要注意一些事情:</p><ul class=""><li id="9e78" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">你已经可以看出NestJS喜欢装修工(比如<code class="fe lw lx ly lz b">@Get</code>和<code class="fe lw lx ly lz b">@Param</code>)。它隐藏了各种常见行为的重复代码——在本例中，定义GET routes并从请求中提取参数。</li><li id="5e91" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">当我们使用NestJS CLI生成一个控制器时(稍后会有更多介绍)，CLI会为控制器添加前缀<code class="fe lw lx ly lz b">articles</code>，因此每条路由都会自动添加前缀<code class="fe lw lx ly lz b">/articles</code>。</li><li id="d06e" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">控制器方法如何向客户端返回响应？这非常直观:方法返回的任何对象或值都将被转换成JSON并作为响应发送。</li><li id="d711" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">最后，您可能想知道控制器如何访问<code class="fe lw lx ly lz b">ArticlesService</code>中的方法。这就是依赖注入的由来。</li></ul><h2 id="b39e" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">依赖注入</h2><p id="4feb" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">基本上NestJS中的所有东西都是类。这些类中有许多是相互依赖的——例如，正如我们在上面看到的，控制器通常需要访问同一个模块中的服务。有时，他们甚至需要从另一个模块访问服务。</p><p id="a536" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖注入允许我们定义模块和它们的提供者<strong class="lb iu"> </strong>(通常是像<code class="fe lw lx ly lz b">ArticlesService</code>这样的类，但也可以是普通的旧函数或任何其他Javascript值)之间的依赖关系。</p><p id="47ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">理解提供者的关键是:模块中的任何提供者都可以访问该模块中任何其他提供者的实例。模块中的控制器(不是提供者，但工作方式相同)也可以访问任何提供者。</p><p id="5e6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们的<code class="fe lw lx ly lz b">ArticlesModule</code>可能看起来像这样:</p><pre class="kj kk kl km gt nq lz nr ns aw nt bi"><span id="52e6" class="ne mi it lz b gy nu nv l nw nx">@Module({<br/>  providers: [ArticlesService],<br/>  controllers: [ArticlesController],<br/>})<br/>export class ArticlesModule {}</span></pre><p id="dc02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将服务指定为提供者，我们可以将服务注入控制器。那么依赖关系到底是怎么注入的呢？</p><p id="b53c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与大多数基于类的依赖注入实现一样，NestJS中的依赖是在构造函数中声明的。例如，如果我们希望我们的<code class="fe lw lx ly lz b">ArticlesController</code>使用<code class="fe lw lx ly lz b">ArticlesService</code>中的方法，我们只需将服务列为控制器构造函数的参数:</p><pre class="kj kk kl km gt nq lz nr ns aw nt bi"><span id="07eb" class="ne mi it lz b gy nu nv l nw nx">@Controller('articles')<br/>export class ArticlesController {  <br/>  constructor(<strong class="lz iu">private articlesService: ArticlesService</strong>) {}</span><span id="12a4" class="ne mi it lz b gy om nv l nw nx">  @Get('/:articleId')<br/>  getArticleById(@Param() params) {<br/>    return this.articlesService.getArticleById(params.articleId);<br/>  }<br/>}</span></pre><p id="f452" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以在任何方法中使用<code class="fe lw lx ly lz b">ArticlesService</code>的实例。当NestJS运行时发现<code class="fe lw lx ly lz b">ArticlesController</code>需要一个<code class="fe lw lx ly lz b">ArticlesService</code>来初始化时，它将在模块中搜索类型为<code class="fe lw lx ly lz b">ArticlesService</code>的提供者。</p><h2 id="838e" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">但是为什么呢？</h2><p id="0d19" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">您可能会问为什么在NestJS中使用依赖注入。毕竟，您可以使用<code class="fe lw lx ly lz b">import</code>或<code class="fe lw lx ly lz b">require</code>关键字来调用不同类和文件之间的依赖关系。为什么所有这些花哨的构造函数和提供程序的东西？</p><p id="9f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个原因。</p><p id="ad81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，它帮助你清楚地推理依赖关系。例如，构造函数会让你快速浏览每个类的重要函数依赖关系，而不是去搜索文件中无数的<code class="fe lw lx ly lz b">import</code>来理解它们之间的关系。</p><p id="51d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，它改变了你对代码的思考方式。它迫使您将服务和控制器视为其依赖项之上的功能扩展。这鼓励你的代码更加整洁，更加模块化。</p><p id="6fad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，也是最重要的，依赖注入极大地简化了测试。因为每个类都只是一个扩展其依赖项功能的接口，所以我们可以模拟那些依赖项的功能，并隔离出我们真正想要测试的东西——类本身的方法。</p><p id="afcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，为了测试我们的控制器，我们可以为它的方法编写一个简单的、可预测的实现的<code class="fe lw lx ly lz b">MockArticlesService</code>类。然后，我们通过传入模拟类来初始化<code class="fe lw lx ly lz b">ArticlesController</code>；这样，我们可以只测试控制器引入的代码层，而忽略服务的真正实现和任何其他依赖。</p><h2 id="6562" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">CLI</h2><p id="53f5" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对像NestJS这样的框架的一个普遍批评是，即使对于最简单的应用程序来说，过多的样板文件也是必要的。很高兴，像Angular一样，NestJS包含了一个现成的命令行界面，可以很容易地为典型用例生成项目和文件。</p><p id="a97a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要创建项目，请执行以下操作:</p><pre class="kj kk kl km gt nq lz nr ns aw nt bi"><span id="470a" class="ne mi it lz b gy nu nv l nw nx">nest new myproject</span></pre><p id="2e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将为您创建一个默认的<code class="fe lw lx ly lz b">AppModule</code>。要创建另一个模块:</p><pre class="kj kk kl km gt nq lz nr ns aw nt bi"><span id="0b90" class="ne mi it lz b gy nu nv l nw nx">nest g module users</span></pre><p id="01ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将在一个新的<code class="fe lw lx ly lz b">users</code>文件夹中创建一个<code class="fe lw lx ly lz b">UsersModule</code>。要创建服务:</p><pre class="kj kk kl km gt nq lz nr ns aw nt bi"><span id="0aea" class="ne mi it lz b gy nu nv l nw nx">nest g service users</span></pre><p id="0f9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CLI足够智能，可以将<code class="fe lw lx ly lz b">UsersService</code>放在<code class="fe lw lx ly lz b">users</code>文件夹中，并自动将其指定为<code class="fe lw lx ly lz b">UsersModule</code>的提供者。</p><p id="878d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击阅读关于CLI <a class="ae ky" href="https://docs.nestjs.com/cli/overview" rel="noopener ugc nofollow" target="_blank">的更多信息。</a></p><h2 id="2e7e" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">精彩的文档</h2><p id="8980" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">任何库或框架都只能和它的文档质量一样好。如果没有关于如何使用工具的有用指导——尤其是像NestJS这样复杂的框架——开发人员将无法实现其全部潜力。</p><p id="fd47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">NestJS文档中有一页又一页详尽的、写得很好的教程、指南和对某些设计选择动机的解释。</p><h2 id="ef03" class="ne mi it bd mj nf ng dn mn nh ni dp mr li nj nk mt lm nl nm mv lq nn no mx np bi translated">对现代工具的一流支持</h2><p id="b3a9" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">NestJS的一个经常被忽视的好处是对GraphQL、WebSockets、OpenAPI等工具的官方支持。这使得将这些工具与您的服务器集成更加容易，消除了寻找最佳npm包的需要(并祈祷它有良好的文档记录)。</p><p id="b4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，Nest的高级文档也适用于这些工具。除了全面和准确的文档，NestJS团队还编写了深入的教程和与这些工具集成的示例，如GraphQL和WebSockets。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0379" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="2640" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">毫无疑问——express . js<em class="lv">是一个很好的库(实际上，NestJS是在它的基础上构建的)。但是它缺乏设计观点，这就要求你产生你自己的设计模式，这些设计模式几乎肯定不如那些由经验丰富的工程师设计和生产测试的框架。</em></p><p id="4667" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于您的下一个web应用程序，与其尝试重新设计轮子，不如我鼓励您尝试一下NestJS。许多人，包括我自己，在第一次了解它的时候都有所保留——然而，以我的经验来看，这些人中的大部分都非常喜欢<em class="lv"> </em>。</p><p id="a7d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS docs </a>是一个开始的好地方。</p></div></div>    
</body>
</html>