# 如何在 Go 中编写原子库

> 原文：<https://betterprogramming.pub/how-to-write-atomic-repositories-in-go-f4fdef01f769>

## 执行原子操作，而不会将事务泄漏到业务逻辑中

![](img/ac62e41a195893655aee704167c18182.png)

丹·迈耶斯在 [Unsplash](https://unsplash.com/s/photos/atomic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

编写一个在事务内部执行数据库操作的存储库，而不将其实现细节泄露到我的业务逻辑中，这是我最近的一个困扰。

在遵循[六边形](https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749)或[干净架构](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)的 Go 项目中，你会看到关注点沿着包边界的分离。通过使用接口，支持业务逻辑的代码与负责数据存储的代码分离开来。

假设有一个应用程序在课程中招收学生。业务逻辑可能将课程和学生的关联表示为类，并验证这些类上的某些约束。例如，确保它们不会被超额认购。

为此，它需要访问课程和学生数据，但它不应该关心数据源是 SQL 数据库、内存缓存还是实习生在终端上输入数据。业务逻辑只关心它得到的任何数据源对它注册学生所需的方法的响应。

# 通常练习

通常，这采用一个`Repository`接口的形式。为了简洁起见，我省略了结构类型的定义，比如`Class`、`Course`和`Student`。

由`repository`包中的具体类型来满足:

`ClassRepository`具体类型知道如何与 SQL 数据库交互。它实现了`class.Repository`接口，这样业务逻辑就可以使用它，而不需要知道它背后有一个关系数据库。

在应用程序启动时，我们可以实例化一个新的类`Service`来处理我们的业务需求，向它传递任何接口类型`Repository`的具体东西。

这是一种处理与数据存储简单交互的干净方式。

# 问题是

当您需要自动执行一系列操作时，这种模式就失效了。也就是说，当您需要在一个事务中发生多个存储库操作时。

假设您想在注册学生之前验证课程是否能够容纳他们。使用这种模式，您可以通过存储库以`Class`对象的形式检索课程和学生数据，根据注册请求中的学生长度加上已经注册的学生数量检查其容量，如果班级中没有足够的空间，则返回一个错误。

**但是，如果在您从商店中检索到班级数据之后，但在您注册新生之前，并发注册请求完成了，该怎么办呢？**如果第二个请求让班级满员，而我们的第一个 goroutine 招收了更多的学生，我们的课程最终会悄无声息地超额预订。我们的初始注册请求无法知道课程中注册的学生人数已经更改，也无法在它执行自己的注册时防止这种情况发生。

我们需要自动执行这些步骤。获取类数据、验证它是否有容量以及持久化注册必须发生在单个事务中。

这是个问题。只有存储库层知道如何管理事务，我们不想将我们的业务逻辑移到存储库中。我们可以定义存储库接口，使其方法返回和接受事务，但这会将数据存储的实现细节泄露到业务逻辑中。

另一方面，这些操作自动发生的需求是一个*业务*需求。数据库不关心一门课程是否被超额预订。这是一个愚蠢的字节存储，即使不是这样，我们也不希望最终陷入这样的境地:我们必须为将来可能使用的每个存储库实现新的注册验证。这使我们的`Repository`接口失去了意义。

我们如何在业务逻辑中保持我们的验证，同时确保所有注册自动发生？

# 尝试 1:将验证注入数据库层

如何在业务层定义验证，并通过一个方法调用将它们注入到存储库中，然后自动运行所有的注册操作？

这看起来很整洁，但是我们通过期望存储库知道何时调用验证，将业务领域泄露到了存储库层。

因此，在验证代码中存在一些令人困惑的歧义。例如，我们如何知道第 11 行的`len(class.Students)`是指已经在这个班级的学生人数，还是我们已经添加了注册学生的人数？

向前看。

# 尝试 2:定义事务接口

我们已经确定事务性是一个业务概念，所以让我们以一种不暴露事务实现细节的方式将事务引入我们的业务层。实现这一点的方法是使用接口。

现在我们有进展了。我们的业务逻辑不得不操作一个`Tx`对象，这仍然令人感到奇怪，但是我们已经将事务的使用从它的实现中分离出来，所以我们不再关心它是否是一个 SQL 数据库事务，甚至只是假装成一个事务。我们现在可以为单元测试创建`Tx`的模拟实现。这是一个很大的进步。

存储库方面的情况并不乐观:

由于要求我们的存储库方法接受接口类型`class.Tx`，我们必须在接口上执行一个类型断言，以便在对数据库表进行任何操作之前再次获得具体的事务类型。

这不是不合理的。只有当我们做了一些极其愚蠢的事情时，类型转换才会失败，比如将两个具有不同底层数据存储的独立存储库的事务混合在一起。尽管它很丑。通过让我们的业务逻辑处理事务对象，我们创建了许多样板文件。我们可以做得更好。

# 尝试 3:从业务逻辑触发事务，但是在存储库中管理它们

告诉存储库它应该原子地运行它的操作是一个业务问题，但是我们不希望伴随着从业务层管理事务而来的笨拙的类型断言。

让我们定义一个可以管理自己事务的存储库，从它在业务层的接口开始:

`AtomicRepository`嵌入了一个`Transactor`，这是一个可以开始、提交和回滚事务的对象。请注意，这些方法不会返回或接受任何事务。事务本身的管理是一个实现细节。这允许业务逻辑调用`AtomicRepository.Begin`,然后调用它喜欢的任何其他回购方法，安全地知道存储库的操作现在是原子的。完成后，业务逻辑调用`Commit`。

方法命名——`Begin`、`Commit`、`Rollback`——是我们与 SQL 数据库联系在一起的术语，但是如果你想强调这是一个表示任何数据存储的接口，你可以使用`Start`、`Save`、`Undo`或`Open`、`Write`、`Cancel`。没关系。命名声明了一个操作，而不是一个实现。

结果是业务逻辑不再需要争论事务对象，存储库不再需要执行类型断言，因为它不接受调用点的事务接口。相反，它在内部保留事务。让我们看看这是如何实现的:

我们定义了未导出的类型`transactor`，它同时具有数据库和事务字段，并实现了`class.Transactor`所需的所有方法。当我们调用`(*transactor).Begin`时，它从其数据库中创建一个新的事务，并将其存储在 struct 上。

`AtomicClassRepository`嵌入了一个`*transactor`，因此当调用存储库方法时，它首先检查活动事务的嵌入事务字段，如果存在，它使用嵌入事务执行所需的数据库操作。

因此，我们的业务逻辑可以控制何时开始和结束事务，但不必管理具体或接口事务类型，这是存储库层的责任。

好看吗？不，这是个灾难性的问题。

如您所知，我们的`class.Service` struct 定义了类似`Enroll`的业务方法，它有一个`AtomicRepository`类型的`repo`字段，提供了对`Service`与数据存储交互所需的所有方法的访问。

`class.Service`将作为指针在我们的程序中传递，`*class.Service`。处理注册请求的所有 goroutines 共享一个服务。

这意味着一个以上的同时注册请求将导致对同一个存储库的并发调用。

其中包含单个不受保护的事务。

当这种情况发生时——它将会发生——一切都完了。您可能会在单个事务中获得写入数据库的注册请求的合并。您可能会在尚未调用`Begin`的 goroutines 中得到`TransactionInProgress`错误。你肯定会毁掉你的数据库。

# 尝试 4:管理自己事务的单一用途、线程安全的存储库

我们来盘点一下。我们不希望我们的业务逻辑泄露到存储库中。我们不希望存储库的实现细节泄露到业务逻辑中。我们必须原子地运行业务操作，但我们不想在业务层处理事务对象，也不想在存储库层的事务接口上执行类型断言。更重要的是，我们希望对存储库的读写是线程安全的。

我们已经成功了 90%。还有一个诀窍要透露。

传统上，存储库是在程序启动时创建并在应用程序退出时清除的长期对象。

在这种范例中，存储库不能保存对事务的无保护引用，因为来自程序的许多请求处理程序的并发访问会使它崩溃。用互斥锁锁定事务引用是没有用的，因为这将有效地把我们的数据库连接池减少到 1，并且当请求排队等待获取锁时，我们的程序将会中断。

但是，如果我们开始把一个储存库想象成一只短暂存在、完成其目的、然后死亡的蜉蝣，这些问题就消失了。

我们可以为每个注册请求实例化一个新的存储库，而不是一个长期存在的存储库。这个存储库管理单个 goroutine 中的单个事务。当我们完成事务时，我们扔掉整个存储库。

从业务角度来看:

我们现在存储了一个`AtomicRepositoryFactory`，而不是在`Service`上持有一个`AtomicRepository`。当被调用时，`AtomicRepositoryFactory`返回一个新的`AtomicRepository` *，其作用域为当前函数。我们在这个存储库实例上开始的事务受到保护，不受任何外部影响，其他 goroutines 可以自由地实例化它们自己的存储库，充分利用数据库连接池。*

让我们在存储库层实现`AtomicRepository`及其工厂函数:

`NewAtomicClassRepositoryFactory`返回`AtomicRepositoryFactory`，我们的类服务将使用它来为每个请求实例化一个新的存储库。存储库本身是轻量级的。创建一个 repo 需要创建两个新的指针，所以除非您正在使用一个对性能高度敏感的应用程序，否则实例化短期存储库不会成为一个需要关注的瓶颈。

注意，我们从`NewAtomicClassRepositoryFactory`返回的`AtomicRepositoryFactory`是指向底层数据库的指针周围的闭包，而*是*一个长寿、线程安全的对象。闭包允许我们在应用程序启动时传递一个数据库引用，然后在程序运行时的剩余时间里忘记数据库。每当我们使用工厂创建一个新的存储库时，没有必要传递一个新的数据库引用。

在`main.go`完成这一切很简单:

## 更进一步

使用工厂函数来创建单一用户存储库给了我们更大的能力来从业务层抽象事务。

例如，您可能会决定每个新的存储库都应该以一个活动的事务开始，从而消除业务代码调用回购上的`Begin`的需要。

我选择了反对这种方法，因为很容易想象这种行为会让其他开发人员感到惊讶。启动一个事务还需要从池中获取一个数据库连接。一个不知情的同事可能实例化一个 repo 并保存它以备后用，而不知道他们正在泄漏一个连接。

小心不要让事务管理过于含蓄。你不需要理解一个仓库的内部结构来安全地使用它。

# 额外收获:尝试 5:用交易装饰非原子回购协议

**编辑**:这最后一个建议来自我在 Qonto 的同事。我已经发表了这篇文章，但它太好了，不能不包括在内。

现在我们对我们实例化以执行单个任务的存储库的想法感到满意了，让我们考虑一下如何将`Transactor`接口从我们的业务逻辑中完全分离出来。尽管我们当前在业务层手动开始和结束事务的方法是与数据存储无关的，但是如果我们以某种方式让存储库为我们做这件事，我们就会消除干扰。

为了实现这一点，我们*了两个*存储库接口和一个函数类型。

第 4 行新增:`AtomicOperation`，一个接受上下文和非原子`Repository`并返回错误的函数类型。

在第 6 行，我们定义了`AtomicRepository`，它有一个单独的方法:`Execute`。`Execute`接受一个`AtomicOperation`，并且，你猜对了，自动执行它。

10 号线是我们熟悉的`Repository`。当操作被调用时，这种类型的东西被传递到一个`AtomicOperation`中。

下面是我们如何使用这些类型:

`Service`现在被一个长寿的`AtomicRepository`实例化了，但是我们直到第 15 行才遇到我们的香草`Repository`，在那里我们在`Enroll`中定义了一个函数。这个函数是一个`AtomicOperation`——它接受一个`context.Context`和一个`Repository`作为参数，并返回一个错误。在这个函数中，我们的行为就像是在一个事务中运行一样。没有提到`Begin`或`Commit`；我们可以随意调用`Repository`方法。

定义这个函数后，我们将它传递给`Service`的`AtomicRepository`以在第 26 行执行。这相当于说“在事务内部运行这个函数”。接下来就要靠`AtomicRepository`来实现了。

这里发生了很多事情，所以我会一步一步地告诉你。

`tableOperator`(第 5 行)是一个接口，描述任何能够与数据库表交互的对象。`Queryer`和`Execer`是标准库 sql 包使用的命名约定，所以为了简洁起见，我省略了这些简单接口的实现。在实践中，`tableOperator`可能是*或者是*一个数据库或者是一个事务。您很快就会明白为什么这很有用。

`beginner`是任何可以开始事务的对象。`Begin`返回一个具体的`*sqlx.Tx`，它实现了开箱即用的`tableOperator`，但是你可以通过实现你自己的`tx`接口类型来提高这个包的可测试性，这个接口类型也满足`tableOperator`。

`AtomicClassRepository`(第 21 行)满足`class.AtomicRepository`。我们马上就会看到它的`Execute`方法是什么样子的。它用一个`beginner`实例化。即可以启动事务的对象。

`ClassRepository`是由`tableOperator`支持的`class.Repository`的实现。这意味着我们可以用事务或数据库实例化`ClassRepository`，只要它们实现了`tableOperator`，存储库就不会知道其中的区别。

这里是缺失的拼图:让我们将知道事务的`AtomicClassRepository`连接到不知道事务的`ClassRepository`。

`Execute`开始一个事务，并推迟回滚以防出错。回滚已提交的事务不会有任何效果。

然后它实例化一个短命的`ClassRepository`，传递给它新创建的事务，这满足了`tableOperator`。如果我们想在代码中的其他地方进行非原子类相关的数据库查询，我们可以通过完全跳过`AtomicClassRepository`并传递一个实现`tableOperator`而不是事务的数据库`ClassRepository`来实现。`ClassRepository`不知道它是否是原子性的。

然后我们调用`Execute`从业务逻辑接收的`class.AtomicOperation`，传入包含实时事务的`ClassRepository`实例。我们在 `[class.Enroll](https://gist.github.com/AngusGMorrison/26f4c1d631e2cdbeedde9dfba03bd6da)`中定义的`AtomicOperation` [调用这个存储库，而不需要知道任何关于事务的信息。](https://gist.github.com/AngusGMorrison/26f4c1d631e2cdbeedde9dfba03bd6da)

当`AtomicOperation`返回时，`Execute`要么提交要么回滚事务，`classRepository`被丢弃，就像我们在**尝试 4** 中的“蜉蝣”库一样。

这种方法对业务层隐藏了事务的复杂性，代价是在存储库层增加了一点接口的复杂性。

# 摘要

这就是了。两种干净、线程安全的方法来处理原子数据库操作，同时尊重业务逻辑和存储库之间的关注点分离。

要点是:

*   决定您是更喜欢在业务层开始和结束事务的认知简单性，还是通过将所有事务性都降低到存储库层来实现最严格的关注点分离。
*   从长期存储库转移到单一用途的“蜉蝣”存储库，这些存储库的作用范围是在单个 goroutine 中运行一个函数。
*   如果您更喜欢将事务完全隐藏在存储库层中，那么您将需要一个长寿的原子存储库来管理许多单用户存储库的生命周期。