<html>
<head>
<title>Angular Standalone Components and Their Impact on Modularity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有角度的独立组件及其对模块化的影响</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-standalone-components-and-their-impact-on-modularity-e186806aa28a?source=collection_archive---------3-----------------------#2022-02-01">https://betterprogramming.pub/angular-standalone-components-and-their-impact-on-modularity-e186806aa28a?source=collection_archive---------3-----------------------#2022-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c2e0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“可选模块”一瞥</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d06be7d9715458775d861fc2aadaaa5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pBtcMN_W1mcG-lOXy26tPQ.png"/></div></div></figure><p id="6e2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Angular框架中即将出现的特性之一将是“独立组件”(SC)或“可选NgModules”。它将消除<code class="fe lq lr ls lt b">NgModules</code>的必要性。</p><p id="536f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有很多博文，文章等。关于SC。本文回答了一个不常讨论的问题:SC将如何影响Angular应用程序中的模块化？</p><p id="4c03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">NgModule包含术语模块。当SC让<code class="fe lq lr ls lt b">NgModules</code>成为可选的，并且从长远来看可能会弃用它们，这是否意味着我们将不再拥有模块？鉴于Angular是一个企业框架，以及Angular团队对稳定性的持续努力，这将是一个意想不到的举动。</p><p id="084d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我首先总结一下什么是SC，以及它们带来的优势。然后我关注主要问题，即可选性<code class="fe lq lr ls lt b">NgModules</code>和模块化是否形成矛盾。最后一部分是关于我们现在可以为SC准备的最好方法。</p><p id="041e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">源代码可在<a class="ae lu" href="https://github.com/rainerhahnekamp/angular-standalone-components-and-modularity" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="be52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你喜欢看而不是读，这里有视频版本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="a007" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">1.什么是独立组件？</h1><p id="b53f" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">围绕SC的讨论已经在社区中持续了几个月。Angular的主要开发者之一Igor Minar 表示，从Angular的早期测试版开始，他就一直想开发NgModules。这是在2016年。因此，当Pawel Kozlowski在GitHub上发布独立组件的官方RFC时，这是一件大事。</p><p id="b230" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Angular中的关键元素是组件。每个组件都属于一个为其提供依赖关系的<code class="fe lq lr ls lt b">NgModule</code>。一个<code class="fe lq lr ls lt b">NgModule</code>的装饰者的属性声明创建了这种关系。</p><p id="700d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果组件需要<code class="fe lq lr ls lt b">formGroup</code>指令，NgModule通过<code class="fe lq lr ls lt b">ReactiveFormsModule</code>提供该指令。</p><p id="5b0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样的规则也适用于其他可视元素，如管道和指令。为了简单起见，当我们谈到一个组件时，这两个都包括在内。</p><p id="ed8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这不仅仅是额外的开销。考虑到组件和模块之间额外的链接，以及一个<code class="fe lq lr ls lt b">NgModule</code>可以声明多个组件的事实，要弄清楚一个特定的组件需要哪些依赖项并不容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/8930c02e0592cfe50bdf6e07aafe3dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qfvnd6k59uTKgYNyKiWW7Q.png"/></div></div></figure><p id="605e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了组件之外，还需要考虑服务——以及如何提供服务的三种不同方式。NgModule可以做到这一点，组件可以做到这一点，或者服务可以通过<code class="fe lq lr ls lt b">providedIn</code>属性提供自己。最后一个选项是首选方式，在Angular 6中引入。</p><p id="1846" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，我们看到，即使是包含一个表单和一个服务的单个组件也包含相对较高的复杂性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/c9202608e577a9db303d45b65a7aa133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oi5jNmrBslep9ONj5jvi9A.png"/></div></div></figure><p id="0d95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">独立组件去除了NgModule的附加层。</p><p id="2490" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个组件的装饰者会收到额外的属性。提供服务也将变得更加容易，因为只有两种选择。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/40155583d390f6108cacdc434cb93891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EDdHfn9YAD67xhqlSrhH8A.png"/></div></div></figure><h1 id="5055" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">2.如何在独立组件中模块化？</h1><p id="a696" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">NgModules能在角度应用中实现模块化吗？如果是的话，我们现在应该不用模块来编写我们的应用程序吗？</p><h2 id="db15" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated">2.1什么是模块？</h2><p id="8f2a" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">一个好的模块定义应该是应用程序中属于一起的一组元素。“归属在一起”有不同的可能。它可以是一个只包含表示性组件的组，一个包含NgRx特性状态的所有相关元素的组，或者一些其他标准。</p><p id="e52f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">模块最重要的功能是封装。模块可以从外部隐藏某些元素。封装是稳定架构的关键，因为它防止每个元素访问任何其他元素。</p><h2 id="312e" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated">2.2 ng module是模块吗？</h2><p id="52c2" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">那么，NgModule在这个意义上是一个模块吗？不幸的是，NgModule只能部分满足这些需求。它至少为可视元素(组件、指令、管道)提供封装，但不能强制它们。</p><p id="36fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">理论上，我可以创建一个从封装组件扩展而来的组件，创建一个新的选择器，瞧。没有什么可以阻止我访问一个没有导出的类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh lw l"/></div></figure><p id="1c27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它不会因为服务而变得更好。如上所述，它们可以不受NgModule的控制。</p><p id="c737" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe lq lr ls lt b">NgModules</code>不能提供完全的模块化，我们已经可以回答本文的主要问题:</p><blockquote class="ni nj nk"><p id="ac64" class="ku kv nl kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">独立组件或可选模块不会对应用程序的模块化产生影响。</p></blockquote><p id="09f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，我们现在有了一个新的问题:一直以来，我们应该对模块使用什么？</p><h2 id="0585" class="mv ly it bd lz mw mx dn md my mz dp mh ld na nb mj lh nc nd ml ll ne nf mn ng bi translated">2.3如何在Angular中实现模块？</h2><p id="0faa" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Angular里除了NgModule还有别的东西，只是它用不同的名字伪装了自己。它是图书馆或只是图书馆。从Angular 6开始，Angular CLI支持库的生成。</p><p id="d4fe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">库在实际应用程序的文件夹旁边有自己的文件夹。这个库也有一个所谓的桶文件<code class="fe lq lr ls lt b">index.ts</code>，在那里进行封装。从那个<code class="fe lq lr ls lt b">index.ts</code>输出的一切都暴露在外面。一切都可以是服务、类型脚本接口、函数，甚至是<code class="fe lq lr ls lt b">NgModules</code>。</p><p id="ab6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于库中NgModule的补充说明:在SC可用之前，我们仍然需要ng module来公开组件。这就是为什么一个库也包含了<code class="fe lq lr ls lt b">NgModules</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh lw l"/></div></figure><p id="f4af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么强制封装呢？每当开发人员从库中导入非公开文件时，都会发生这种情况。有了现代的IDE，一切都变得非常快。当非公开元素通过相对路径导入，而公开元素通过使用库名导入时，我们经常会看到这种情况。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/7936bd2b73bca8450ba8d63175f86fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8QujR6IbQJHFOV7J1fn-8g.png"/></div></div></figure><p id="bfc2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不幸的是，Angular CLI中没有任何东西可以阻止我们这样做。这就是nx介入的地方。</p><p id="02f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Nx是Angular CLI的扩展，在众多特性中，它提供了模块化的林挺规则。如果发生所谓的深度导入，即对非公开文件的直接访问，该林挺规则将抛出错误。请参阅这篇精彩的文章了解更多信息。</p><p id="3b91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Nx提供了另一个林挺规则，我们也可以在其中定义模块之间的依赖规则。我们可以制定一些规则，比如模块A可以访问模块B和模块C，但模块B只能访问模块C。这些规则也通过林挺进行验证。</p><blockquote class="ni nj nk"><p id="f90f" class="ku kv nl kw b kx ky ju kz la lb jx lc nm le lf lg nn li lj lk no lm ln lo lp im bi translated">因此，满足模块需求的是库(与nx结合)而不是NgModule。</p></blockquote><h1 id="950a" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">3.我如何为迁移做最好的准备？</h1><p id="d63e" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">我们还没有SC，但是我们现在能为它们做准备以使迁移尽可能顺利吗？</p><p id="ec69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一段时间以来，早在SC公布之前，模式单组件角模块或“骗局”已经在社区中流行。使用SCAM，NgModule只声明一个组件。</p><p id="7aac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您已经使用了SCAM，那么迁移到SC的工作可能只是将<code class="fe lq lr ls lt b">imports</code>和<code class="fe lq lr ls lt b">providers</code>属性移动到<code class="fe lq lr ls lt b">@Component</code>装饰器。脚本可以自动完成这项任务。你可以在这里找到更多信息<a class="ae lu" href="https://netbasal.com/aim-to-future-proof-your-standalone-angular-components-accb574d273f" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7959" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您是否应该将SCAM应用到现有的应用程序中？如果您有一个大的应用程序，并且非常希望尽快迁移到SC，那么SCAM可以帮助您实现这一目标。一般来说，我会一直等到SC发布。</p><p id="ec36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在还有一个<a class="ae lu" href="https://stackblitz.com/edit/ng-standalone?file=standaloneShim.ts" rel="noopener ugc nofollow" target="_blank">垫片</a>提供SC。该垫片仅用于演示目的，对生产而言并不安全。</p><h1 id="0f22" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">摘要</h1><p id="b325" class="pw-post-body-paragraph ku kv it kw b kx mp ju kz la mq jx lc ld mr lf lg lh ms lj lk ll mt ln lo lp im bi translated">Angular中的依赖管理有不同的变化。这可能会降低一致性，对新人来说是一个障碍。</p><p id="9486" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尤其是NgModule，会产生不必要的开销。独立组件(可选NgModules)将消除NgModules，这将是一个很大的改进。</p><p id="3e63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可选的NgModules对库提供的模块化基本上没有影响。对于遵循SCAM模式的应用程序，脚本可以自动完成迁移。没有骗局，你将不得不手动完成。</p></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="f7a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我要感谢Pawel Kozlowski审阅了这篇文章并提供了宝贵的反馈。</p><h1 id="8fc8" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">进一步阅读</h1><ul class=""><li id="0e8f" class="nx ny it kw b kx mp la mq ld nz lh oa ll ob lp oc od oe of bi translated">Igor Minar在Twitter上写道:“独立组件、指令和管道(也称为可选NgModules)的Angular提案背后的故事。很长… 🧵" /推特</li><li id="6294" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae lu" href="https://netbasal.com/aim-to-future-proof-your-standalone-angular-components-accb574d273f" rel="noopener ugc nofollow" target="_blank">🎯旨在让您的独立角形组件面向未来| Netanel Basal | Netanel Basal</a></li><li id="fcd1" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae lu" href="https://dev.to/this-is-angular/emulating-tree-shakable-components-using-single-component-angular-modules-13do" rel="noopener ugc nofollow" target="_blank">使用单个组件角度模块模拟树摇动组件——开发社区</a></li><li id="e24a" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae lu" href="https://blog.nrwl.io/mastering-the-project-boundaries-in-nx-f095852f5bf4" rel="noopener ugc nofollow" target="_blank">用Nx中的模块边界驯服代码组织|作者Miroslav jona | 2021年12月| Nrwl </a></li><li id="b979" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae lu" href="https://github.com/angular/angular/discussions/43784" rel="noopener ugc nofollow" target="_blank"> RFC:独立组件、指令和管道—使Angular的NgModules成为可选讨论#43784 angular/angular GitHub </a></li><li id="437e" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae lu" href="https://stackblitz.com/edit/ng-standalone?file=standaloneShim.ts" rel="noopener ugc nofollow" target="_blank">https://stackblitz.com/edit/ng-standalone?file=standaloneShim.ts </a></li><li id="6867" class="nx ny it kw b kx og la oh ld oi lh oj ll ok lp oc od oe of bi translated"><a class="ae lu" href="https://www.angulararchitects.io/aktuelles/angulars-future-without-ngmodules-part-2-what-does-that-mean-for-our-architecture/" rel="noopener ugc nofollow" target="_blank"> Angular没有NgModules的未来——第二部分:这对我们的架构意味着什么？—角度架构</a></li></ul></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><p id="6a55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="nl">最初发表于</em><a class="ae lu" href="https://www.rainerhahnekamp.com/en/angular-standalone-components-and-their-impact-on-modularity/" rel="noopener ugc nofollow" target="_blank"><em class="nl">www.rainerhahnekamp.com</em></a></p></div></div>    
</body>
</html>