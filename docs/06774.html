<html>
<head>
<title>Building a Distributed Redis Cache From the Ground Up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始构建分布式Redis缓存</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-a-distributed-redis-cache-from-ground-up-2fa6c341c8c6?source=collection_archive---------12-----------------------#2020-11-03">https://betterprogramming.pub/building-a-distributed-redis-cache-from-ground-up-2fa6c341c8c6?source=collection_archive---------12-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6da2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">纵向扩展内存缓存，实现水平扩展</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b75190dce12e57b9b26056f9f815b661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BYT1U1MqMvnu0Mco.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Redis与特使代理</p></figure><p id="d67a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为您的应用程序提供一个缓存层是大规模处理API请求的最常用和最有效的解决方案之一。拥有缓存的响应或部分响应比重做整个工作流来服务请求要快得多。</p><p id="b591" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们关注的是基于内存的缓存，以及如何将内存缓存扩展为可水平伸缩的。也就是说，我们可以向我们的系统添加更多的缓存机器，所有机器都应该像一个实例一样工作，将所有缓存命中/写入作为一个缓存实例来服务。我们将使用<a class="ae lr" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> Redis </a>进行演示，但是您可以使用任何您喜欢的缓存层。</p><p id="7ad0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您可能已经知道的，有许多现成的解决方案，可以用来扩展Redis。你可能听说过<a class="ae lr" href="https://redis.io/topics/cluster-tutorial" rel="noopener ugc nofollow" target="_blank"> Redis集群</a>或者<a class="ae lr" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank">特使代理</a>。今天，我们将尝试从表面上了解这些服务是如何由内向外构建的。有关现成解决方案的更多详细信息，我建议您查看<a class="ae lr" href="https://medium.com/dev-genius/redis-topologies-d9e16a7fa8e0" rel="noopener">这篇很棒的文章</a>。</p><p id="9c63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不做进一步介绍，我们来深入探讨一下这篇文章的核心。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="77d9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们试图解决的问题</h1><p id="475a" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">让我们从一个基本架构开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/0e26478e5d920bf4b26d389388eaaa7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*S1S8GIVj-akF1KlEO1Q6mQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">简单的单实例客户端/缓存通信</p></figure><p id="7a1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常，我们有一个Redis服务器的实例正在运行，任何对读/写缓存感兴趣的人都可以联系这个服务器并获得想要的结果。Redis速度超快，因为它从内存中为您的操作服务。但是我们如何在不同的机器上分配内存呢？</p><p id="104e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们希望能够像特使一样做一些事情。</p><p id="0185" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要一个代理服务器，它可以与任何想要从缓存中读写数据的客户端进行通信，并隐藏与我们实际使用了多少个Redis实例来存储缓存信息或这些信息如何在每个实例中路由/存储相关的所有信息。</p><p id="6ab4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里出现的一个典型问题是我们如何分配数据。我们如何在代理级别记住，比如说，密钥X存储在哪里？</p><p id="42d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在写作上也有问题。我们需要能够在实例之间几乎均匀地分配密钥，这样我们就不会在其他实例空闲时使其中一个实例过载。</p><p id="9cbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，我们在这里做的事情叫做<em class="mx">分片</em>。基本上，分片意味着我们希望将存储在一台机器上的数据分布到多台机器上，同时保留在对单台机器上的数据进行分片之前对新的分布式系统进行读写的方法。</p><h2 id="474b" class="my ma iq bd mb mz na dn mf nb nc dp mj le nd ne ml li nf ng mn lm nh ni mp nj bi translated">散列法</h2><p id="3573" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated"><em class="mx">哈希</em>，简单来说，就是将数据映射到一个以更小的形式表示该数据的哈希，这对我们的目的很有用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/e07a3f9fa16590342a09aae59793e806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BOhNowj2bnmAHwb0.png"/></div></div></figure><p id="4d4f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以把我们想要存储在Redis中的键想象成我们想要散列的数据。我们拥有的Redis实例的服务器名称是可用的简化散列字符串，我们应该将每个键映射到该字符串。</p><p id="be31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这实际上解决了我们两个的问题。通过使用下面的过程，我们可以知道每次我们有一个键时，在哪里存储和从哪里读取数据:</p><ul class=""><li id="3582" class="nl nm iq kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated">从客户端检索一个密钥和一个带参数的命令。</li><li id="fa4d" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">散列密钥</li><li id="dd90" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">决定这个哈希值属于哪个服务器(可以是范围或离散值)</li></ul><p id="e80b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！我们现在可以轻松地构建分布式缓存了。</p><p id="2ac2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">没那么快——我们仍然需要找到一个最佳的散列函数来散列我们的密钥。这是因为如果我们不断散列新的键，如果函数将我们选择的所有键名散列到同一个服务器，它们可能都在同一个桶或服务器中结束！</p><p id="fc67" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，我们还有另一个问题，那就是处理我们代理下的操作服务器数量的增加或减少。假设我们使用这个散列函数将值散列到服务器<code class="fe nz oa ob oc b">server = hash(key) mod NumServers</code>。通过此功能，我们可以根据当前拥有的服务器数量来分配密钥。这种分配不是线性的，所以键没有排序，A、B、C在S1，D在S2，依此类推。</p><p id="5e2f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们的一台服务器因为某种原因关闭了呢？现在我们必须将<code class="fe nz oa ob oc b">NumServers</code>减少-1，对吗？这实际上是灾难性的，因为现在有了新的模，我们已经散列的值已经改变了。存放在S1的钥匙现在可能会被送往S2，反之亦然。这将导致我们对所有服务器进行全面检查，以重新散列所有密钥——哎呀！</p><p id="11ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们需要一种更好的方法来散列我们的密钥，以便每当我们必须从我们的池中添加/删除服务器时，我们只需付出最少的努力。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ce93" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">一致散列法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/e3b954f67f533553154d4a8d2c10086c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*j8pC8pQzdaCEceFP.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">映射到一个圆的键(图片来源:<a class="ae lr" href="https://www.toptal.com/big-data/consistent-hashing" rel="noopener ugc nofollow" target="_blank">一致性散列指南</a></p></figure><p id="2e2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们从一个有2π或360度的空圆开始。现在，我们不再使用像modulo这样的散列函数直接将值映射到服务器，而是将键映射到圆圈上的某个点或度数。</p><p id="d2b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如上所示，对一些示例键进行这样的操作，我们可以得到一个类似上面所示的圆，键分布在整个圆上。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/9e5f61d0c7a4a5ce45ff1252f4ffa607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5uI_smX-MSqbOceg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在圆周的某些预定义的度数上添加服务器(图片来源:<a class="ae lr" href="https://www.toptal.com/big-data/consistent-hashing" rel="noopener ugc nofollow" target="_blank">一致性散列指南</a>——再次感谢Juan关于一致性散列的精彩文章)</p></figure><p id="e4d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，我们将在圆的不同角度分配并均匀分布服务器，使它们之间的角度相等。</p><p id="7024" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这创建了一种不同的哈希算法，即一致哈希算法。现在我们有了每个服务器的度数范围，每当一个新值被散列到圆圈中时，我们只需检查这个值属于哪个范围。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/b6c1a66207856faf8c3af75bb5bd54ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eSH0Ih6PV0L014FH.png"/></div></div></figure><p id="11ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这如何解决我们添加新服务器或处理退役旧服务器的问题？</p><p id="f6d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个场景:添加一个新的服务器。</p><p id="68d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每当我们添加一个新的服务器，我们将为该服务器分配一个新的学位。让我们称这个服务器为D。当然，这个服务器会落在圈里的其他两个服务器之间——比如B和C——所以我们把D放在中间，在B和C之间。</p><p id="25b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了适应添加新服务器的变化，我们将开始重新分配仅从服务器B窃取的密钥，因为现在服务器D已经占据了它的部分领土。与我们的第一个解决方案相比，这实际上非常高效。现在我们只需要从一台服务器上重新分发密钥。</p><p id="8fc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看第二个场景，服务器A停机了。服务器B现在不得不要求服务器A下的所有密钥，因为现在它拥有它在圆圈中的领土，加上A的领土。</p><p id="6455" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这真的很棒。让我们重申一下我们的工作流程:</p><ul class=""><li id="61d5" class="nl nm iq kx b ky kz lb lc le nn li no lm np lq nq nr ns nt bi translated">我们从在代理处接收来自客户机的命令细节和密钥开始。</li><li id="c924" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">然后，我们将密钥散列到循环中的某个程度。</li><li id="5bed" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">检查此键属于哪个范围/地区。</li><li id="e320" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">向/从区域/范围的所有者(又名服务器)分配/读取密钥。</li><li id="0636" class="nl nm iq kx b ky nu lb nv le nw li nx lm ny lq nq nr ns nt bi translated">接收来自缓存服务器的响应，并将其返回给客户端。</li></ul><p id="1473" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就是这样！我们做了一个简单的架构，类似于特使代理在其主要控股框架。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="6215" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的旅程到此结束。您可以在以下网址查看示例代码</p><div class="oe of gp gr og oh"><a href="https://github.com/Kareem-Emad/redis-grid" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd ir gy z fp om fr fs on fu fw ip bi translated">卡里姆-艾玛德/雷迪斯网格</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">分布式缓存层的一个基本实现，主要面向redis服务器，支持数据分片和…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">github.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov kp oh"/></div></div></a></div><p id="3546" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢谢你的耐心，如果你有任何疑问/意见/问题，请在评论中告诉我。</p></div></div>    
</body>
</html>