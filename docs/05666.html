<html>
<head>
<title>Build Your First Widget in iOS 14 With WidgetKit</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用WidgetKit构建你在iOS 14中的第一个Widget</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-your-first-widget-in-ios-14-with-widgetkit-9b893423e815?source=collection_archive---------0-----------------------#2020-07-27">https://betterprogramming.pub/build-your-first-widget-in-ios-14-with-widgetkit-9b893423e815?source=collection_archive---------0-----------------------#2020-07-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5ca3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">今天是开始打造苹果新部件的好日子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2c1c26ec571af0cfcff6ee195eedc5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*abZ1Oa1cJQnjb8A6hm0KFA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Widgets with WidgetKit】苹果HIG </p></figure><p id="c38b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在有史以来第一次完全在线的全球开发者大会WWDC20上，苹果宣布在iOS 14的主屏幕上引入小工具。这一举动，以及将应用程序转移到应用程序库，是一个意想不到的举动，因为自第一版iOS推出以来，主屏幕没有发生任何变化。</p><p id="de42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在“<a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2020/10028/" rel="noopener ugc nofollow" target="_blank">Meet widget kit”WWDC会议</a>中，我们看到来自苹果的Nahir和Neil向我们展示了新发布的主屏幕小部件(这些小部件完全由SwiftUI构建，可以在iOS 14、iPadOS和MacOS Big Sur之间互操作)。</p><p id="4aab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我的<a class="ae kv" href="https://medium.com/better-programming/widgetkit-in-ios-14-wwdc20-81cf10f51af9" rel="noopener">另一篇文章</a>中，有主题演讲要点的摘要文本，一篇四分钟的阅读。一定要仔细阅读，因为这篇文章是纯技术性的，建立在我在上面链接的文章中提到的概念之上。</p><h2 id="1670" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">先决条件</h2><p id="babb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">确保您拥有:</p><ul class=""><li id="3568" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">运行macOS Catalina 10.15.5或更高版本的Mac设备</li><li id="63e6" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">安装了Xcode 12.0 beta 1或更高版本(尽管由于某种原因，我无法在Xcode 12.0 beta 1的SwiftUI预览窗格中预览小部件，这在我转移到beta 2后得到了解决)</li><li id="b963" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">SwiftUI的基础知识。你可能会发现raywenderlich.com大学的这门免费课程很有帮助。</li></ul></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="9f81" class="nl lt iq bd lu nm nn no lx np nq nr ma jw ns jx md jz nt ka mg kc nu kd mj nv bi translated">入门指南</h1><p id="afb6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">打开您想要添加widgets的Xcode项目。如果你还没有一个，创建一个新的空白的也完全没问题。</p><p id="1a16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该应用程序可以在UIKit或SwiftUI中制作，但由于小部件仅用于SwiftUI，我将继续使用SwiftUI界面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/9a86d0a311c2253b11e7685a41feef1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OH4YQddUn5WFYG0R7DVcmA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建一个空白Xcode项目</p></figure><p id="3d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，通过进入文件➡新➡目标➡选择小部件扩展来添加新的小部件扩展。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/c51b062a9640a870f0091ae49bbaa64e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qSPqJ2NSQZz5ejHroLGFIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">添加小部件扩展</p></figure><p id="2d22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您有一个允许您“包含配置意图”的复选框在本教程中，我们将涵盖静态配置，因为我们不想给用户一个选项来编辑小部件中的东西。取消选中复选框，并选择“完成”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/8e7f1b15f310478827a1f674020038a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IHq7vp-EJBLJDb82Y5mdQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">选择您的静态意图模板</p></figure><p id="87d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在接下来的屏幕上选择“激活”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/c14805ec94d9de3825ecac773601814d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-rsmVBnqg2pBGNWW3ilvgQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">激活新创建的方案</p></figure><p id="ab9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">导航到新创建的扩展下的Swift文件，以在预览窗格中查看小部件的预览。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/0bfd40f74a60aa27942aa961d7ec798e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aoPy8IMrIeVhnBmEaFLsmw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">预览新创建的模板小部件</p></figure><p id="9c59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以通过在预览画布中点击小工具上方的播放图标来预览小工具在手机上的外观。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="0352" class="nl lt iq bd lu nm nn no lx np nq nr ma jw ns jx md jz nt ka mg kc nu kd mj nv bi translated">理解样板文件</h1><p id="bd3a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">查看小部件类的框架，您会看到类型为<code class="fe ob oc od oe b">TimelineEntry</code>的<code class="fe ob oc od oe b">struct Provider</code>，它有两个功能:<code class="fe ob oc od oe b">snapshot</code>和<code class="fe ob oc od oe b">timeline</code>。我们将在稍后的时间点回到这些。</p><p id="a052" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，有一个类型为<code class="fe ob oc od oe b">TimelineEntry</code>的结构<code class="fe ob oc od oe b">SimpleEntry</code>，具有<code class="fe ob oc od oe b">date</code>属性。这通常是要在小部件中显示的数据结构。</p><p id="d27d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后就是两个视图，<code class="fe ob oc od oe b">PlaceholderView</code>和<code class="fe ob oc od oe b">Static_WidgetEntryView</code>。这些视图最终显示在您将要创建的小部件的主屏幕上。<code class="fe ob oc od oe b">PlaceholderView</code>在没有数据可显示时显示，例如，当用户刚刚安装了您的应用程序，还没有打开它，但已经在屏幕上放置了一个widget。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/cf472d4f607e32c97f42b6e80bd95e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*AfY_QyorYdZUD8d_Z_rCog.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">iPhone重新启动时显示的占位符widgets</p></figure><p id="02fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个<code class="fe ob oc od oe b">Static_WidgetEntryView</code>，这是一个在主屏幕上看起来不错的视图，其中填充了数据。在正常情况下显示。在接下来的几分钟内，我们将全面设计要在小部件中显示的视图。</p><p id="5dd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后还有这个重要的<code class="fe ob oc od oe b">struct</code>类型<code class="fe ob oc od oe b">Widget</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="86c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，第7行返回了定制的小部件视图，需要根据您想要在小部件的实际空间中显示的视图进行修改。当用户将小部件添加到主屏幕时，<code class="fe ob oc od oe b">configurationDisplayName</code>和<code class="fe ob oc od oe b">description</code>会显示给用户，所以您可能也想修改它们。</p><p id="aff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，<code class="fe ob oc od oe b">PreviewProvider</code>结构负责在预览画布中显示您的小部件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="c41b" class="nl lt iq bd lu nm nn no lx np nq nr ma jw ns jx md jz nt ka mg kc nu kd mj nv bi translated">让我们来玩吧！</h1><h2 id="a92c" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">‘时间线提供者’</strong></h2><p id="2b9b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe ob oc od oe b">TimelineProvider</code>是小部件的引擎——<code class="fe ob oc od oe b">provider</code>类主要负责在时间轴中提供一组视图，以及一个提供小部件快照的选项。</p><p id="64af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，当用户想要放置微件时，微件的预览显示给用户，这是从<code class="fe ob oc od oe b">snapshot</code>获得的。放置在屏幕上后，<code class="fe ob oc od oe b">timeline</code>将返回要在主屏幕上显示的视图。</p><p id="cf86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于微件加载在主屏幕上，苹果不希望用户看到一堆加载的微件。因此，iOS 14中的小部件只是捆绑在时间轴中的一堆视图。</p><p id="c4aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当应用程序打开时，它给系统一堆视图和一个时间标签。例如，如果您的应用程序希望在一个小部件中显示某个事件的倒计时，您的应用程序需要从当前时间到事件日期制作一系列视图，并且它需要告诉系统在什么时间显示哪个视图。</p><p id="1f1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果活动还有四天，应用程序可以发送五个视图:</p><ul class=""><li id="a76a" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">视图1: </strong>今天要展示的。“有内容”活动还有4天</li><li id="c809" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">观点二:</strong>明天上映。“有内容”活动将在3天后举行</li><li id="5206" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">视图三:</strong>后天上映。“有内容”活动将在两天后举行</li><li id="3bfd" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">视图4: </strong>在活动前一天显示。“有内容”活动将在1天后举行</li><li id="05f0" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><strong class="ky ir">视图5: </strong>活动当天显示。“有内容”事件已经开始</li></ul><p id="b9bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">iOS根据系统时间显示适当的视图，因此小部件在任何时间点都会正确显示。</p><p id="dfb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，创建这样一堆视图是一项廉价的任务，不需要恒定的计算时间。因此，这也有助于iOS保存电池，增加流畅的性能。</p><p id="03fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">查看代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="d9e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第14行，创建了五个条目，每小时一个。对于每个条目，用<code class="fe ob oc od oe b">Static_WidgetEntryView</code>创建一个视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="6372" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些视图随后被提供给iOS系统，以便根据时间显示适当的视图。</p><p id="e382" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以试着用<code class="fe ob oc od oe b">byAdding: .minute</code>代替<code class="fe ob oc od oe b">byAdding: .hour</code>，在模拟器中测试。显示小部件后，在最初的五分钟内，小部件视图将每分钟更新一次。在此之后，小工具不会改变，并将继续显示小工具扩展发送到iOS的最后一个视图。</p><h2 id="a3d4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">设计小部件视图</h2><p id="0071" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">现在，让我们创建一个自定义视图，它的内容将被呈现到小部件中。</p><p id="aefc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，我们将分离小部件视图和提供商，因为所有内容都在同一个Swift文件中。</p><p id="e597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道<code class="fe ob oc od oe b">TimelineProvider</code>负责构建视图并将其显示在时间轴上。(时间线只不过是基于当前时间在主屏幕上显示的一系列带有时间标签的视图。更多理论可以在我的<a class="ae kv" href="https://medium.com/better-programming/widgetkit-in-ios-14-wwdc20-81cf10f51af9" rel="noopener">上一篇</a>中找到。)</p><p id="ab9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主结构<code class="fe ob oc od oe b">Static_Widget</code>负责定义应用程序中的小部件视图。我们将把小部件视图移动到一个新文件中。</p><p id="f54e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先通过添加新文件来创建一个<code class="fe ob oc od oe b">WidgetView</code> Swift文件➡ SwiftUI查看➡接下来。命名为<code class="fe ob oc od oe b">WidgetView</code>。确保在目标扩展下选中了小部件扩展，然后单击“创建”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/cdbad191513ebb7a5dfef212cbe72844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kH9TW1xnsQWdqncLqpITew.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">添加新的SwiftUI视图以呈现到小部件中</p></figure><p id="5901" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建的Swift文件将具有SwiftUI视图的模板代码；然而，我们想在这里设计一个小部件。在新创建的文件中，<code class="fe ob oc od oe b"><strong class="ky ir">import</strong> WidgetKit</code>也是如此。</p><p id="799a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看要创建的小部件</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/1676d9d962f777aeb726da8a2426469f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DtP6_Uo2yJZFWJO_XHSng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">要创建的小部件</p></figure><p id="1747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个时髦的静态小部件，显示静态重量和相对时间——需要保持更新。</p><p id="dace" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于小部件只需要两个变量，我们将创建一个结构来存储它们。此外，我们将创建一个struct的扩展来预览数据，以便轻松地填充<code class="fe ob oc od oe b">WidgetData</code>，这只是为了演示的目的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="97d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然已经添加了数据结构，让我们为小部件准备视图和预览。为预览创建一个<code class="fe ob oc od oe b">WidgetView</code>和一个提供者，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/c4ebba50cab808e2b5c2c2885a889d6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6ueaVmrtWEJCeecwhDSyw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">写样板文件</p></figure><p id="9802" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，您会注意到预览已经用<code class="fe ob oc od oe b">.previewContext(WidgetPreviewContext(family: .systemSmall))</code>预览了<code class="fe ob oc od oe b">WidgetView</code>，它像一个小部件一样渲染视图。在这里，该系列可以更改为<code class="fe ob oc od oe b">systemMedium</code>和<code class="fe ob oc od oe b">systemLarge</code>以预览中大型格式的内容。</p><p id="cb5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过添加其他小部件系列的预览，<code class="fe ob oc od oe b">WidgetView</code>的代码更新为:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="71e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从在第17行向小部件主体添加视图开始。查看设计，我们需要两个标签:一个用于静态文本<code class="fe ob oc od oe b">“Weight”</code>，另一个用于来自<code class="fe ob oc od oe b">data: WidgetData</code>的权重。所以在一个<code class="fe ob oc od oe b">VStack</code>中添加了两个<code class="fe ob oc od oe b">Text(“”)</code>视图，中间有一个<code class="fe ob oc od oe b">Spacer()</code>之后，让我们也添加字体和前景色，让它们看起来更好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/1f4c5e7a424150b30cc987464a55beb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RhnkVfhr9EFJLCwdOb39eA.png"/></div></div></figure><p id="1cb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使小部件的内容左对齐，请将VStack的<code class="fe ob oc od oe b">alignment</code>设置为<code class="fe ob oc od oe b">leading</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/d3bc212faa972243ec4d6e6432e80aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZYCF1iC6g25vo1B9vItfHw.png"/></div></div></figure><p id="08a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要将这个VStack放在另一个背景颜色为青色的视图中，所以让我们将VStack放在一个HStack中，并添加背景颜色。此外，一点点填充可能看起来不错。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/a50599eec0ff3124b464214d314dbe08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7S3pw9VMt4Dt6zZ0FHIS-g.png"/></div></div></figure><p id="b7ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们使用<code class="fe ob oc od oe b">ContainerRelativeShape().fill()</code>作为背景的半径。值得注意的是，根据小部件设计指南，不建议使用固定圆角，而是使用<code class="fe ob oc od oe b">CornerRelativeShape</code>，它的半径与其超级视图同心。</p><p id="30c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让HStack完全占据视图，让我们在HStack中添加一个<code class="fe ob oc od oe b">Spacer(minLength: 0)</code>和VStack。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/d9114e64ee413c78bb00d64fd2784d26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5oaQjX_VZZDJ09ggkf_yOg.png"/></div></div></figure><p id="56c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们差不多已经完成了需要建设的一半。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/1676d9d962f777aeb726da8a2426469f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2DtP6_Uo2yJZFWJO_XHSng.png"/></div></div></figure><p id="40b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了构建<code class="fe ob oc od oe b">last checked</code>视图，添加一个新的VStack来添加两个<code class="fe ob oc od oe b">Text</code>视图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/734e25f89885efd594305a12ddcad0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-ECjpUfDzIB6NtoP3YjaQ.png"/></div></div></figure><p id="7f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们为<code class="fe ob oc od oe b">Text</code>使用了新的Swift语法来显示相对于当前时间的日期，例如<code class="fe ob oc od oe b">Text(“data.date, style: .relative”)</code>。将它与小部件一起使用可以确保小部件中显示的时间相对于当前系统时间，并且总是每秒更新一次。</p><p id="d4a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Widget视图并不意味着每秒更新一次，所以iOS提供了一个放置动态时间文本的选项。每秒的更新得到有效处理。</p><p id="609e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，最后，将它们放在ZStack中以获得黄色背景色，并为其中的VStack添加一些填充，让我们使用Xcode将两个子视图提取到<code class="fe ob oc od oe b">WeightView</code>和<code class="fe ob oc od oe b">LastUpdatedView</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/b97415d459ba004525d0c57f9c95f26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OjRd_nsQ3m7jQkcTw8UB4g.png"/></div></div></figure><p id="96b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">完成后，<code class="fe ob oc od oe b">WidgetView</code>的最终代码将是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ecd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建的小部件看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/0569ae9900b17bfb2a33757073ad17f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*45pXDgR2pdfiLkNOVnvS1Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新创建的小部件的预览</p></figure><p id="4d9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，您可能已经注意到我们已经为<code class="fe ob oc od oe b">.systemSmall</code>家族设计了视图，而这个小部件对于其他尺寸来说看起来不太好。为了让<code class="fe ob oc od oe b">.systemMedium</code>小部件看起来更吸引人，让我们添加一个相关图标，该图标只为<code class="fe ob oc od oe b">.systemMedium</code>小部件显示。</p><p id="0a51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，使用以下内容创建一个环境变量:</p><p id="d22f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ob oc od oe b">@Environment(\.widgetFamily) <strong class="ky ir">var</strong> widgetFamily</code></p><p id="a24b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果用户在主屏幕上放置了一个中等大小的窗口小部件，这个变量的值被设置为<code class="fe ob oc od oe b">.systemMedium</code>。在这种情况下，您可以使用:</p><pre class="kg kh ki kj gt or oe os ot aw ou bi"><span id="d4b9" class="ls lt iq oe b gy ov ow l ox oy">if widgetFamily == .systemMedium {<br/>  //Render view here<br/>}</span></pre><p id="e25b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以将图像添加到当前内容的任意一侧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oz"><img src="../Images/cd96b63b02bd2cd3d83705908fb5d499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9vXtACK-qBkQvXN4oytvQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">制作。“systemMedium”小部件更漂亮</p></figure><h2 id="df23" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">练习</strong></h2><p id="a73f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为<code class="fe ob oc od oe b">.systemLarge</code>格式设计好看的小部件。目前，它看起来像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/59bdd1929cf48d98029f6a5f9269f11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m9tpE5RzgGjXZcvnnq61Gg.png"/></div></div></figure><p id="2fae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，我们不会支持大尺寸的部件。为了只支持想要的小部件尺寸系列，直接进入主函数，添加<code class="fe ob oc od oe b">.supportedFamilies([.systemSmall, .systemMedium])</code>以确保用户不能在主屏幕上放置<code class="fe ob oc od oe b">.systemLarge</code>小部件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">正在添加。第9行的“supportedFamilies”显示具体的尺寸等级</p></figure><h2 id="d4da" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">把所有的放在一起</h2><p id="0ffe" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">既然我们已经设计了widget视图，剩下的就是将这个widget视图添加到应用程序的widget扩展中。还记得我们之前说过的<code class="fe ob oc od oe b">@main</code>函数吗？(滚动到上面的“了解样板文件”部分。)将<code class="fe ob oc od oe b">WidgetView</code>作为应用程序中的小部件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/9fd3b52ff5fbec6c3ed3e9581b08af15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n15QNoF5JR-UUpjYz_kx3g.png"/></div></div></figure><p id="7a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加<code class="fe ob oc od oe b">WidgetView(data: .previewData)</code>，如图所示，替换默认的小部件视图，并在模拟器上运行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pc"><img src="../Images/e727fc809db6b122511fbd59b583429b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eqjcvYYMbgrR4DC3CWweHw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">添加到主屏幕的Widgets</p></figure><p id="d749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">瞧啊。您已经将第一个小部件添加到了您的iOS应用程序中！</p><p id="9045" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以<a class="ae kv" href="https://github.com/iAkashlal/SwiftUI-Widgets" rel="noopener ugc nofollow" target="_blank">在GitHub这里下载完成的项目</a>。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="38ec" class="nl lt iq bd lu nm nn no lx np nq nr ma jw ns jx md jz nt ka mg kc nu kd mj nv bi translated">从这里去哪里</h1><p id="a882" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">祝贺您将第一个widget添加到您的iOS应用程序。到目前为止，我们讨论的只是使用widgetss可以做的最基本的事情，所以我想我应该添加一些可以使用widget完成的事情。</p><h2 id="4d21" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> 'TimelineReloadPolicy' </strong></h2><p id="0e7c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe ob oc od oe b">TimelineProvider</code>提供一系列时间的小部件视图。然而，在提供并显示了最后一个条目之后，<code class="fe ob oc od oe b">TimelineReloadPolicy</code>可以用来帮助WidgetKit安排更新，以便可以刷新小部件。<code class="fe ob oc od oe b">TimelineReloadPolicy</code>是一个带有:</p><pre class="kg kh ki kj gt or oe os ot aw ou bi"><span id="1b6b" class="ls lt iq oe b gy ov ow l ox oy">struct TimelineReloadPolicy{<br/>   atEnd<br/>   after(date)<br/>   never<br/>}</span></pre><ul class=""><li id="d233" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><code class="fe ob oc od oe b">atEnd</code>:显示最后一个条目后，会安排一次更新。当更新发生时，iOS可以从<code class="fe ob oc od oe b">TimelineProvider</code>请求后续条目，这可以循环发生。</li><li id="6691" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe ob oc od oe b">after(date)</code>:计划在提供的日期更新，不考虑现有条目</li><li id="b50f" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><code class="fe ob oc od oe b">never</code>:系统不会独立更新小工具。我们可以在小部件通过<a class="ae kv" href="https://developer.apple.com/documentation/widgetkit/widgetcenter" rel="noopener ugc nofollow" target="_blank"> WidgetCenter API </a>重新加载时进行设置。</li></ul><p id="7d34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，该系统还智能地安排更新——通过板载智能并基于用户行为，确保小部件始终保持最新。您可以在“<a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2020/10035" rel="noopener ugc nofollow" target="_blank">Widgets-Code Along(第2部分)</a>”中了解更多信息</p><h2 id="e53e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">“相关性”</strong></h2><p id="3b47" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><code class="fe ob oc od oe b">Relevance</code>是时间轴条目上的一个可选属性，当多个小部件被放置在一个堆栈中时，它帮助WidgetKit决定在顶部显示哪个小部件。在计算时间轴中的条目时，您可以为每个条目添加一个浮点值<code class="fe ob oc od oe b">relevance</code>，帮助WidgetKit处理与您的小部件最相关的所有提交条目。</p><p id="2dec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在WWDC20会议的第2部分“Widgets-Code Along”中有说明。</p><h2 id="516a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">配置</strong></h2><p id="156f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果您想给用户一个选项来编辑小部件，并从几个影响小部件显示方式的可用选项中进行选择，那么您需要在小部件中进行配置。WidgetKit配置由SiriKit驱动，配置的核心技术是SiriKit。</p><p id="fce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多信息可在WWDC20 " <a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2020/10194/" rel="noopener ugc nofollow" target="_blank">将配置和智能添加到您的小部件</a>"专题讲座中获得。</p><h2 id="4e28" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">深度链接</strong></h2><p id="2027" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用视图上的<code class="fe ob oc od oe b">.widgetURL</code>修改器，微件的整个实体可以深度链接到应用程序的一个部分，而<code class="fe ob oc od oe b">.systemMedium</code>和<code class="fe ob oc od oe b">.systemLarge</code>微件可以使用<code class="fe ob oc od oe b">.widgetURL</code>修改器或SwiftUI链接API来创建可点击区域，以链接到不同的页面。这显示在“<a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2020/10036/" rel="noopener ugc nofollow" target="_blank"> WWDC20小部件—会话代码(第3部分)</a>”中</p><h2 id="377e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">多个微件(微件包)</strong></h2><p id="199a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果你的应用想拥有多个widget，你就不能一直添加多个widget扩展。由于一个小部件扩展只能有一个main方法，所以不能使用我们以前添加更多小部件视图的方式。为此，您可以使用<code class="fe ob oc od oe b">WidgetBundle</code>并将主标签移动到那里，例如:</p><pre class="kg kh ki kj gt or oe os ot aw ou bi"><span id="e796" class="ls lt iq oe b gy ov ow l ox oy">@main<br/>struct MultipleWidgets: WidgetBundle{<br/>  @WidgetBundleBuilder<br/>  var body: some Widget{<br/>    WidgetView1()<br/>    WidgetView2()<br/>  }<br/>}</span></pre><p id="4a4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ob oc od oe b">WidgetView1()</code>和<code class="fe ob oc od oe b">WidgetView2()</code>是有效的SwiftUI视图。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="a272" class="nl lt iq bd lu nm nn no lx np nq nr ma jw ns jx md jz nt ka mg kc nu kd mj nv bi translated">资源</h1><p id="97b8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果没有以下内容，这部分内容是不可能的:</p><ul class=""><li id="51b0" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/better-programming/widgetkit-in-ios-14-wwdc20-81cf10f51af9" rel="noopener">“了解iOS 14中的widget kit</a>”</li><li id="809c" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2020/10033" rel="noopener ugc nofollow" target="_blank">为小部件构建SwiftUI视图</a></li><li id="623b" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://developer.apple.com/videos/play/wwdc2020/10034/" rel="noopener ugc nofollow" target="_blank">“小部件——沿着</a>的代码”(第1、2和3部分)</li><li id="50b7" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated"><a class="ae kv" href="https://www.raywenderlich.com/11303363-getting-started-with-widgets" rel="noopener ugc nofollow" target="_blank">"关于WidgetKit的更多信息</a>"</li></ul></div></div>    
</body>
</html>