<html>
<head>
<title>Common JavaScript Mistakes — Part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">常见的JavaScript错误—第3部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/common-javascript-mistakes-part-3-6756605f40b1?source=collection_archive---------8-----------------------#2019-11-08">https://betterprogramming.pub/common-javascript-mistakes-part-3-6756605f40b1?source=collection_archive---------8-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ef2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">重载函数、缺少参数等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbf20bdd9f7c021154eced57fa2f3e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CrXFVZmAr3JnOvkj"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@joshcouchdesign?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔希·考奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="81a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种比世界上许多其他编程语言更友好的语言。然而，在编写JavaScript代码时，由于误解或忽略我们已经知道的东西，仍然很容易犯错误。通过避免下面的一些错误，我们可以通过防止代码中的错误和错别字来使我们的生活变得更容易，这些错误和错别字会使我们陷入意想不到的结果。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1d46" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">试图重载函数</h1><p id="71fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">函数重载是一些编程语言的一个特性，在这里你可以用相同的名字但是不同的签名来声明函数。在JavaScript中，我们不能重载函数。每当一个函数被声明不止一次时，后面声明的函数会覆盖前面声明的函数。这是因为函数是对象，声明一个函数就像将一个对象赋给一个变量。当你将一个对象多次赋给一个变量时，后赋的值会覆盖前赋的值。这意味着在JavaScript的同一个模块中不能有两个同名的函数。例如，如果我们有以下内容，</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="e83a" class="ne md it na b gy nf ng l nh ni">function add(a, b, c) {<br/>  return a + b + c;<br/>}</span><span id="8145" class="ne md it na b gy nj ng l nh ni">function add(a, b) {<br/>  return a + b;<br/>}</span><span id="05a2" class="ne md it na b gy nj ng l nh ni">console.log(add(1, 2, 3));</span></pre><p id="3d3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到三个，因为后来声明的<code class="fe nk nl nm na b">add</code>函数覆盖了之前声明的函数。要解决这个问题，我们必须重命名其中一个。我们也可以把它们放在两个不同的物体里。那么他们可以有相同的名字，因为他们不在同一个级别。另外，我们可以写一个直接调用的函数表达式，简称IIFE。生命一旦被定义就开始运行。要将它们包装在一个对象中，我们可以编写以下代码:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="70db" class="ne md it na b gy nf ng l nh ni">const a = {<br/>  add(a, b, c) {<br/>    return a + b + c;<br/>  }<br/>}</span><span id="1414" class="ne md it na b gy nj ng l nh ni">const b = {<br/>  add(a, b) {<br/>    return a + b;<br/>  }<br/>}</span><span id="0344" class="ne md it na b gy nj ng l nh ni">console.log(a.add(1, 2, 3));<br/>console.log(b.add(1, 2, 3));</span></pre><p id="7dcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，如果我们运行代码，那么第一个的<code class="fe nk nl nm na b">console.log</code>将是6，第二个将是3，因为<code class="fe nk nl nm na b">a.add</code>有3个参数而<code class="fe nk nl nm na b">b.add</code>有2个。</p><p id="124c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以像下面的例子一样使用IIFE:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="bd3d" class="ne md it na b gy nf ng l nh ni">const sum1 = (function add(a, b, c) {<br/>  return a + b + c;<br/>})(1, 2, 3);</span><span id="e6d9" class="ne md it na b gy nj ng l nh ni">const sum2 = (function add(a, b) {<br/>  return a + b;<br/>})(1, 2, 3);</span><span id="cdcf" class="ne md it na b gy nj ng l nh ni">console.log(sum1);<br/>console.log(sum2);</span></pre><p id="b09a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们将函数包装在括号内，然后在定义后立即调用它。然后我们将返回的结果赋给一个变量。在那之后，我们得到了我们想要的6和3。因为我们立即调用了每个函数并返回了结果，所以我们得到了正确的结果，因为它们没有重叠。这也意味着它们不能被再次调用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="67f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">缺少参数</h1><p id="c180" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们给函数添加一个新参数时，我们必须记住在函数调用中传递额外的参数。否则可能会出现<code class="fe nk nl nm na b">undefined</code>错误。为了避免未定义的参数产生错误，我们可以在函数中检查它，或者设置参数的默认值。例如，如果我们有以下函数</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3c0d" class="ne md it na b gy nf ng l nh ni">function addressFn(address, city, region) { ... }</span></pre><p id="72a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想添加一个<code class="fe nk nl nm na b">country</code>参数，我们程序的其他部分调用了上面的函数，然后我们可以添加一个默认参数。我们可以通过编写以下代码来做到这一点:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="35d2" class="ne md it na b gy nf ng l nh ni">function addressFn(address, city, region, country = 'US') { ... }</span></pre><p id="9b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，如果<code class="fe nk nl nm na b">country</code>参数没有被传入，<code class="fe nk nl nm na b">country</code>将被设置为<code class="fe nk nl nm na b">'US'</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/7a678ff73d48bc7f431d75978604f99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*niITEMlzUrkNDxSO"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kendall3lane?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">肯德尔巷</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a9f9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">忘记了this关键字</h1><p id="6fb0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当我们试图从一个对象中的另一个属性访问某个属性时，我们应该使用<code class="fe nk nl nm na b">this</code>关键字来获取我们想要的属性值。例如，如果我们有以下内容，</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="9165" class="ne md it na b gy nf ng l nh ni">let obj = {<br/>  prop: "some text",<br/>  method() {<br/>    console.log(prop);<br/>  }<br/>};</span><span id="0d61" class="ne md it na b gy nj ng l nh ni">obj.method();</span></pre><p id="abd9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们将得到一个<em class="no">未捕获的引用错误:属性未定义</em>错误。这是因为我们忘记了将<code class="fe nk nl nm na b">this</code>关键字放在prop变量之前。相反，我们需要编写以下内容:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ed0e" class="ne md it na b gy nf ng l nh ni">let obj = {<br/>  prop: "some text",<br/>  method() {<br/>    console.log(this.prop);<br/>  }<br/>};</span><span id="251f" class="ne md it na b gy nj ng l nh ni">obj.method();</span></pre><p id="e9be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们运行上面的代码时，我们得到了<code class="fe nk nl nm na b">'some text'</code>，这就是我们想要的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="918c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">遍历对象键</h1><p id="d33d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nk nl nm na b">for...in</code>循环将遍历当前对象的关键点以及所有原型的关键点。这并不适合所有情况。它也比其他遍历对象键的方法慢。使用<code class="fe nk nl nm na b">for...in</code>循环，我们需要使用<code class="fe nk nl nm na b">Object.hasOwnProperty</code>函数来检查属性最初是在对象中定义的。这使得循环更加缓慢。如果我们有一个有很多属性的大对象，这是一个问题。例如，如果我们有，</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="8b41" class="ne md it na b gy nf ng l nh ni">const parent = {<br/>  pa: 1,<br/>  pb: 2<br/>}<br/>let obj = Object.create(parent);</span><span id="4948" class="ne md it na b gy nj ng l nh ni">obj.a = 1;<br/>obj.b = 2;<br/>obj.c = 3;<br/>obj.d = 4;<br/>obj.e = 5;</span></pre><p id="3daa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe nk nl nm na b">for...in</code>循环将遍历<code class="fe nk nl nm na b">parent</code>的所有属性和添加到<code class="fe nk nl nm na b">obj</code>的属性。如果我们只想遍历<code class="fe nk nl nm na b">obj</code>中的属性，那么我们必须使用<code class="fe nk nl nm na b">hasOwnProperty</code>函数进行循环，如以下代码所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="abb9" class="ne md it na b gy nf ng l nh ni">for (const key in obj) {<br/>  if (obj.hasOwnProperty(key)) {<br/>    console.log(obj[key]);<br/>  }<br/>}</span></pre><p id="dc1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这比新的替代方法要慢，新的替代方法是用<code class="fe nk nl nm na b">Object.keys</code>获取对象的键，用<code class="fe nk nl nm na b">Object.entries</code>获取对象的键值对。然后我们用<code class="fe nk nl nm na b">for...of</code>循环遍历它们，因为它们都返回数组。它们只遍历对象的属性，不遍历原型链。遍历条目的最快方法是这两个函数。我们可以如下使用它们:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="79ab" class="ne md it na b gy nf ng l nh ni">const parent = {<br/>  pa: 1,<br/>  pb: 2<br/>}<br/>let obj = Object.create(parent);</span><span id="5428" class="ne md it na b gy nj ng l nh ni">obj.a = 1;<br/>obj.b = 2;<br/>obj.c = 3;<br/>obj.d = 4;<br/>obj.e = 5;</span><span id="b858" class="ne md it na b gy nj ng l nh ni">for (const key of Object.keys(obj)) {<br/>  console.log(obj[key]);<br/>}</span><span id="76b9" class="ne md it na b gy nj ng l nh ni">for (const [key, value] of Object.entries(obj)) {<br/>  console.log(value);<br/>}</span></pre><p id="d8e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在每个示例中，我们都记录了以下内容，</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3c2b" class="ne md it na b gy nf ng l nh ni">a 1<br/>b 2<br/>c 3<br/>d 4<br/>e 5</span></pre><p id="ccea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着我们从<code class="fe nk nl nm na b">Object.keys</code>和<code class="fe nk nl nm na b">Object.entries</code>函数中得到了我们想要的东西。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="10c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使JavaScript是一种友好的语言，在编写JavaScript代码时仍然很容易出错。记住，在JavaScript中，我们不能重载函数，所以我们不能在同一个级别中定义两个同名的函数。如果某个函数参数有可能没有被设置，那么我们可以设置一个默认参数，这样它就永远不会是<code class="fe nk nl nm na b">undefined</code>。此外，当我们从同一个对象的另一个属性访问一个属性时，我们不能忘记<code class="fe nk nl nm na b">this</code>对象。最后，我们不应该再使用<code class="fe nk nl nm na b">for...in</code>循环来遍历一个对象的键，因为如果我们只是想遍历当前对象的键而不遍历其原型的键，那么它会很慢而且笨拙。我们想使用<code class="fe nk nl nm na b">Object.keys</code>或<code class="fe nk nl nm na b">Object.entries</code>函数来代替，这样我们就可以分别获得作为数组的键或键值对，并且我们可以像其他数组一样遍历它们。</p></div></div>    
</body>
</html>