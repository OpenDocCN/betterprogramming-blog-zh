# JavaScript 中的递归与循环

> 原文：<https://betterprogramming.pub/recursion-vs-loops-in-javascript-d588c5b0df31>

## 递归不一定是可怕的

![](img/1f44b2ef1921159f08181845ba6d6c2d.png)

照片由[对比](https://unsplash.com/@comparefibre?utm_source=medium&utm_medium=referral)[上的纤维](https://unsplash.com?utm_source=medium&utm_medium=referral)和

递归是每个开发人员的克星，只有它的朋友正则表达式才能与之匹敌。

递归可能很难理解，原因有两个。首先，你必须掌握函数调用自身的概念。其次，您必须理解基本情况和递归情况之间的区别，否则您可能会发现自己陷入了一个无限循环，直到导致堆栈溢出。

如果你能掌握这两个概念，递归就没有你想象的那么可怕或复杂。递归代码通常写起来更短，而且(在某些情况下)更容易阅读。

让我们一起浏览五个代码示例。我们将首先使用循环来解决每个问题，然后使用递归来解决它。哪种方法更好？这由你来决定。

# 例子#1:阶乘

让我们写一个函数来计算正整数的阶乘。阶乘是这样写的:`5!`。阶乘的公式是这样的:

```
n! = n * (n - 1) * (n - 2) * ... * 1
```

所以`5!`应该是:

```
5! = 5 * 4 * 3 * 2 * 1 = 120
```

我们如何为此编写一个函数呢？一种方法是使用`while loop`。我们可以为我们的`result`创建一个变量，然后在一个循环中将它与`x`相乘，每次将`x`减 1。代码如下所示:

注意，我们也处理过小于 0 的错误输入，并且我们已经简化了 0 和 1 的情况，因为`0!`和`1!`都等于 1。

这是一个利用循环的解决方案。如果我们想递归地写这个函数呢？递归解决方案可能如下所示:

哇哦。那就短多了。注意，在最后一行，我们返回的是用`x — 1`作为参数再次调用同一个`factorial`函数的结果乘以`x`。这是递归的情况。

如果我们只是递归调用我们的函数，我们会陷入一个无限循环，所以我们需要一些方法来摆脱它。这就是为什么我们有处理 when `x <= 1`的条件。当我们到达那个点时，我们停止递归调用我们的`factorial`函数。这是基本情况。

准备好再举一个例子了吗？

# 示例 2:电源

让我们试一个类似的例子。这一次让我们实现幂函数，它计算基数的幂的结果。所以，比如说，`2^3`是 2 的 3 次方，或者说`2 * 2 * 2`，是 8。

在 JavaScript 中，有几种方法可以实现幂函数，比如调用`Math.pow(2, 3)`或者使用像`2 ** 3`这样的求幂语法。现在，让我们假装这些工具不存在。我们如何自己编写这个功能呢？

使用一个`while loop`，我们可以写一个类似这样的函数:

注意，我们将忽略这个例子中的负指数，尽管在现实生活中负指数是完全有效的。我们还将处理指数为 0 的情况，因为任何升到 0 的数总是 1 ( `2^0 = 1`)。

就像我们对阶乘例子所做的一样，我们从 1 的初始`result`开始。然后，我们在循环中用`result`乘以`x`，同时递减`y`，直到达到 0。

现在，递归解决方案会是什么样的呢？这个怎么样:

哇，又短了很多！在最底部，我们有一个递归的例子，我们将`x`乘以用`x`和递减的`y — 1`调用`power`函数的结果。

在此之上，我们有我们的基本情况，如果`y`等于 0，我们返回 1。这样，我们可以摆脱无限调用我们的`power`函数。

一个有趣的说明是，在我们的两个递归解决方案中，我们不必跟踪一个`result`变量。调用栈为我们做了这些！

准备好继续生活了吗？

# 例 3:对数组中的数字求和

让我们写一个对数组中所有数字求和的函数。在 JavaScript 中，`reduce`方法提供了一个简单的工具来将一个数组简化为一个总和，如下所示:

```
numbers.reduce((number, sum) => number + sum, 0);
```

暂且就当`reduce`不存在吧。我们如何编写自己的函数呢？一种选择是使用`for loop`遍历数组中的所有项，并将它们加在一起。代码如下所示:

简短明了。如果我们想递归地做这件事呢？我们可以写一个这样的递归解:

每次我们将第一个数字加到调用数组其余部分的`sumNumbersArray`函数的结果上，不包括第一个数字。

这是比使用`for loop`更好的方法吗？这是一个主观的问题，但在我看来，在这里使用递归感觉比仅仅使用循环更不自然。你怎么想呢?

同时，让我们考虑另一个例子。

# 例 4:找出数组中的最大数字

让我们编写一个函数，它接受一个数字数组并返回最大的一个。在 JavaScript 中，我们可以像这样使用`Math.max`实用函数:

```
Math.max(...numbers);
```

但是为了便于讨论，让我们假设我们没有这个功能。我们怎么能自己写呢？使用一个`for loop`，我们的代码可能看起来像这样:

我们首先假设数组中的第一个数字是最大的数字。然后我们在数组中循环，从第二个元素开始，比较当前元素和最大值。如果当前元素大于最大数量，我们用那个值更新最大数量。一旦我们完成了列表的循环，我们就找到了最大的数字。

所以，相当简单。现在，如果我们想递归地写这个呢？我们可以这样写我们的函数:

这个是不是感觉有点难以直观把握？让我们走一遍。

如果数组包含零个元素或一个元素，我们将只返回第一个元素(在空数组的情况下为`undefined`)。这是我们的基本情况。

我们将对包含两个或更多元素的数组进行比较。我们将获取数组中的第一个元素，然后将其与递归调用数组剩余部分的`maxNumberArray`的结果进行比较。然后我们将返回较大的数字。

还不清楚？我也没有。

让我们来看一个调用的例子，让我们每次都走一遍这些步骤。假设我们用这个参数调用函数:

```
maxNumberArray([1, 9, 5, 7, 3, 8, 2, 4])
```

当函数递归调用自身时，未解析的函数被推到调用堆栈上。一旦我们到达只有一个元素的数组的基本情况，函数就开始解析。这就是我们的对比结果:

```
Is 2 greater than 4? 4 is our max number.
Is 8 greater than 4? 8 is our max number.
Is 3 greater than 8? 8 is our max number.
Is 7 greater than 8? 8 is our max number.
Is 5 greater than 8? 8 is our max number.
Is 9 greater than 8? 9 is our max number.
Is 1 greater than 9? 9 is our max number.
```

因此，从概念上讲，我们从最后两个数字开始向后遍历数组。我们比较这两个数字，并保留最大的一个。然后我们向左移动一个元素，并将其与当前的最大值进行比较。

我们继续向左移动，直到到达数组的开头，在这里我们比较了所有的数字，找到了最大的一个。

这个递归的例子更好吗？同样，这是一个主观问题，但我觉得答案是否定的。掌握这个递归函数如何工作的认知复杂性高于理解用循环实现的函数所需的努力。

递归函数感觉像是一个“聪明”的解决方案，但不是一个“清晰”的解决方案。

在我们结束之前，让我们再做一个例子。

# 例 5:在盒子里的盒子里找到一把钥匙

这将是我们最复杂的例子，但它是递归的完美用例。假设你有一个盒子。此框可以包含多个其他框、其他框等等。盒子也可能是空的。最后，我们要找的盒子里有一把钥匙。

所以想象一下:

*   第一个框(框 A)包含其他三个框(框 B、框 C 和框 D)。
*   盒子 B 里面什么也没有。
*   盒子 C 里面有两个盒子(盒子 E 和盒子 F)。
*   盒子 E 里面有一个盒子(盒子 G)。
*   G 框包含密钥(万岁！).
*   盒子 F 里面什么也没有。
*   盒子 D 里面有一个盒子(盒子 H)。
*   盒子 H 里面什么也没有。

你的头还疼吗？

我们如何编写一个函数来搜索盒子，直到找到密钥？

我们可以像这样使用`while loop`来编写这个函数:

我们从一个空的堆(一个可以用作堆栈数据结构的数组)开始，然后将第一个盒子添加到这个堆中。

然后，趁那堆东西不是空的，我们从那堆东西中抓起一个盒子，往里面看。

我们在盒子里找到的每样东西都可能是钥匙(耶，我们找到了！)或者另一个盒子(棒极了……)。如果我们找到了钥匙，那我们就完事了。如果我们找到一个盒子，我们就把它加入到我们的堆里。

我们重复这个循环，直到我们用完所有的盒子或者找到钥匙。

现在，如果我们想找到这个问题的递归解决方案呢？我们可以这样写我们的函数:

请注意我们的递归解决方案和循环解决方案之间的差异。在递归求解中，我们不跟踪栈。我们简单地浏览第一个盒子，然后，如果我们找到更多的盒子，我们递归地调用这个盒子上的`findKeyInBox`函数。调用堆栈再次为我们跟踪我们的状态！

# 结论

那么，循环和递归哪个更好呢？这由你来决定。循环和递归之间通常没有显著的性能差异，大 O 符号是相同的，因为在每种情况下执行相同数量的操作。

你真正要优化的是可读性。你更容易理解递归解还是循环解？那么下一个会阅读这段代码的开发人员呢？

代码被读的次数比写的次数多 10 倍，所以要优化可读性。

感谢阅读！如果你想重温这些例子并查看测试用例，你可以在这个 [GitHub repo](https://github.com/thawkin3/recursion-vs-loops-js) 中找到我们讨论过的所有功能。