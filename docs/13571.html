<html>
<head>
<title>Improve Your Swift Tests With “justBeforeEach”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“justBeforeEach”改进您的Swift测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-quickspec-lazier-proposing-the-assignbefore-operator-2abc9df47b8d?source=collection_archive---------15-----------------------#2022-09-07">https://betterprogramming.pub/making-quickspec-lazier-proposing-the-assignbefore-operator-2abc9df47b8d?source=collection_archive---------15-----------------------#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4f68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Quick framework的最新命令使得BDD测试更加枯燥</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b41ceeff0c119da42c27b302d6556e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6-At_p8GU9mOZyFJRnYUXg.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">较小的“it”块跟随较大的“beforeEach”块。由<a class="ae kv" href="https://unsplash.com/@tchompalov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Vlad Tchompalov </a>在<a class="ae kv" href="https://unsplash.com/s/photos/ducks-in-a-row?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="6033" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何在Swift中为一个API调用编写有效的单元测试？</p><p id="9fff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能已经看过或写过几十个(几百个？)的次数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="28b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种测试方法很好，但是当您的调用应该在用户完成之前的操作之后才被调用时会发生什么呢？</p><p id="ead5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你现在开始描述<a class="ae kv" href="https://cucumber.io/blog/bdd/bdd-vs-tdd/#:~:text=BDD%20is%20designed%20to%20test,pieces%20of%20functionality%20in%20isolation." rel="noopener ugc nofollow" target="_blank"> BDD测试和</a>TDD测试。任何时候你进行多个方法调用，你都是在进行一种“旅行”,并且必须决定如何设置你的测试。无论您是否实践BDD测试，假设您正在编写测试，测试设置和模拟是一个主要的决策点。</p><h1 id="233e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">设置你的测试，不重复你自己</h1><p id="56f2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">开箱即用，<code class="fe mr ms mt mu b">XCTestCase</code>为我们提供了一个<code class="fe mr ms mt mu b">setUp</code>方法。我们用它来配置我们的<code class="fe mr ms mt mu b">apiService</code>和<code class="fe mr ms mt mu b">apiRepository</code>类，但是我们仍然需要重复分配<code class="fe mr ms mt mu b">apiService.postCallResult =</code>和<code class="fe mr ms mt mu b">apiRepository.postCall()</code>。</p><p id="3036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可能希望将对<code class="fe mr ms mt mu b">postCall</code>的调用从<code class="fe mr ms mt mu b">test</code>函数中提升到<code class="fe mr ms mt mu b">setUp</code>函数中，但是考虑到Swift中函数的范围，我们无法在测试中分配不同的<code class="fe mr ms mt mu b">postCallResult</code>。</p><h1 id="c8df" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">更好的快速BDD测试编写</h1><p id="4dac" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">几年前，iOS社区发布了<a class="ae kv" href="https://github.com/Quick/Quick" rel="noopener ugc nofollow" target="_blank"> Quick </a>，“一个Swift和Objective-C的行为驱动开发框架”，其灵感来自<a class="ae kv" href="https://rspec.info/" rel="noopener ugc nofollow" target="_blank"> Rspec </a>和其他人。</p><p id="13cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Quick使您能够嵌套Swift块来创建BDD风格的测试。在我们的示例中，这可能采用以下形式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="0765" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">代码中的旅程</h1><p id="1526" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">这种嵌套结构使我们能够更好地在代码中创建旅程。在旧的方法中，如果我们在调用<code class="fe mr ms mt mu b">postCall</code>成功后有一个额外的测试，我们将需要复制粘贴并编写一个新的复合测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="78df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在新的方法中，我们可以将这个测试嵌入到我们的嵌套块中，并避免重复我们自己:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="d7fb" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">但我们不还是在重复自己吗？</h1><p id="a0aa" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">尽管在组织上有所改进，但我们仍然需要使用Quick为成功和失败的上下文重复调用<code class="fe mr ms mt mu b">.postCall()</code> API。</p><p id="74bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为我们在<code class="fe mr ms mt mu b">postCallResult</code>模拟API上设置了不同的值，我们需要在调用API之前设置这些值。如果我们要编写如下的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ea2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">context(“failure”)</code>块中的行总是被求值，并且会破坏我们的<code class="fe mr ms mt mu b">context(“success”)</code>案例。如果我们要编写如下的测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="73ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当第一个<code class="fe mr ms mt mu b">beforeEach</code>被执行时<code class="fe mr ms mt mu b">postCallResult</code>将会是<code class="fe mr ms mt mu b">nil</code>，并且测试将会崩溃，因为<code class="fe mr ms mt mu b">beforeEach</code>块是按照声明的顺序被评估的。</p><p id="f9e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一定有更好的方法！</p><h1 id="5a0f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">快速介绍新的“justBeforeEach”命令</h1><p id="7dd2" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们需要的是一种特殊类型的块，它允许我们在<code class="fe mr ms mt mu b">beforeEach</code>块之后、示例执行之前分配变量值，并且只在我们的<code class="fe mr ms mt mu b">context</code>或<code class="fe mr ms mt mu b">describe</code>组的范围内执行。</p><p id="ec0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要的是<code class="fe mr ms mt mu b"><a class="ae kv" href="https://github.com/Quick/Quick/blob/be947fe35f2745650ef3aecf4f54d9de5811ab9f/Documentation/en-us/QuickExamplesAndGroups.md#sharing-setupteardown-code-using-justbeforeeach" rel="noopener ugc nofollow" target="_blank">justBeforeEach</a></code>块。</p><p id="2e04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我的公司在今年夏天早些时候提出的一个命令，并于2022年9月并入Quick。通过添加这个新命令，我们可以编写如下测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="86f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您可以在测试内部分配变量值，但是在测试外部和上面的块中使用公共代码中的变量值。</p><p id="8647" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将<a class="ae kv" href="https://relishapp.com/rspec/rspec-core/v/2-11/docs/helper-methods/let-and-let" rel="noopener ugc nofollow" target="_blank"> RSpec的</a> <code class="fe mr ms mt mu b">let</code>操作符的懒惰评估的<a class="ae kv" href="https://stackoverflow.com/questions/5359558/when-to-use-rspec-let" rel="noopener ugc nofollow" target="_blank">好处带到了我们在Swift中的快速测试中，并且在名称和行为上与</a><a class="ae kv" href="https://onsi.github.io/ginkgo/#separating-creation-and-configuration-justbeforeeach" rel="noopener ugc nofollow" target="_blank"> Gingko的</a> <code class="fe mr ms mt mu b"><a class="ae kv" href="https://onsi.github.io/ginkgo/#separating-creation-and-configuration-justbeforeeach" rel="noopener ugc nofollow" target="_blank">justBeforeEach</a></code>相似。</p><h1 id="4985" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">这真的有那么重要吗？</h1><p id="0bd4" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">一旦你的应用程序发展到足够大的规模，你将拥有数百个，甚至数千个类。大多数方法调用都有一个成功和失败的场景，这些场景意味着测试中的大量复制。</p><p id="0a49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">编写测试可能会很耗时，所以我们认为任何提高开发人员满意度的测试改进都是值得做的。</p><h1 id="e5b0" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">如何使用justBeforeEach？</h1><p id="f5de" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">因为Quick project最近引入了这一变化，为了从中受益，您应该将您的测试指向Github中的<code class="fe mr ms mt mu b">main</code>分支。</p><pre class="kg kh ki kj gt mv mu mw mx aw my bi"><span id="9c31" class="mz lv iq mu b gy na nb l nc nd">.package(url: "https://github.com/Quick/Quick.git", .branch("main"))</span></pre><p id="ec8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢<a class="ae kv" href="https://github.com/Quick/Quick" rel="noopener ugc nofollow" target="_blank">快速项目</a>及其<a class="ae kv" href="https://github.com/younata" rel="noopener ugc nofollow" target="_blank">维护者</a>如此迅速地考虑并采用这个新特性！</p><h1 id="26a0" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">想要连接吗？</h1><p id="a59e" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated"><em class="ne">埃里克·西尔弗伯格是佩里街软件</em> <a class="ae kv" href="https://www.perrystreet.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ne">的首席执行官，佩里街软件</em> </a> <em class="ne">是LGBTQ+约会应用SCRUFF和Jack'd的发行商，在全球拥有超过3000万会员。</em></p></div></div>    
</body>
</html>