<html>
<head>
<title>Service Workers With Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用普通JavaScript的服务人员</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/service-workers-with-vanilla-javascript-49b63224a4fb?source=collection_archive---------0-----------------------#2020-07-19">https://betterprogramming.pub/service-workers-with-vanilla-javascript-49b63224a4fb?source=collection_archive---------0-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5fb3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的前端web应用增添动力</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/33d1c293bcf0015b9d46bcaa996361c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5S0JslyxyrXjvTuZCfAvxw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片由<a class="ae kv" href="https://www.pexels.com/@padrinan" rel="noopener ugc nofollow" target="_blank">米盖尔·Á</a>在<a class="ae kv" href="https://www.pexels.com/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><h1 id="2cb0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">服务人员:什么和为什么</h1><p id="e6a0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一个<em class="mk">服务工作器</em>是一个脚本，它将自己关联到浏览器窗口。web浏览器运行这个服务工作器，它在后台包含JavaScript源代码。</p><p id="12a2" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些服务人员通过向典型的web应用程序添加后台同步、离线渲染和推送通知等功能，缩小了本地应用程序和web应用程序之间的差距。它的主要任务之一是充当代理。这就是我们在这篇文章中要解决的问题。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="e72f" class="kw kx iq bd ky kz mx lb lc ld my lf lg jw mz jx li jz na ka lk kc nb kd lm ln bi translated">小心阻挡者</h1><p id="9d9f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">尽管他们才华横溢，但还是有一些你应该知道的潜在障碍。</p><p id="7cb7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">服务工作者在不同的线程中执行，不能直接访问DOM。如果您希望使用服务人员，您应该启用HTTPS。由于服务人员在设计上可以操纵请求，因此在基于HTTP的web应用程序中使用它们将被证明是对安全性的威胁。但是，您可以在<code class="fe nc nd ne nf b">localhost</code>上使用维修人员，没有任何问题。</p><p id="d1f5" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">另一个障碍可能是您选择的web浏览器。虽然服务人员在大多数浏览器上工作，但在深入研究之前检查兼容性是个好主意。浏览者的详细列表以及他们对服务人员的看法可以在这里找到。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="229d" class="kw kx iq bd ky kz mx lb lc ld my lf lg jw mz jx li jz na ka lk kc nb kd lm ln bi translated">服务人员的生命周期</h1><p id="f864" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用服务人员的第一步是注册。一旦服务工作者被注册，它就触发工作者脚本的安装。</p><p id="5100" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">第二步是安装工人。在本文的当前设置和范围内，如果能够缓存静态内容，服务工作器的安装将会成功。如果用户没有连接到互联网，这些静态内容就会呈现给用户。如果内容无法存储，服务人员将在后续请求中重试。</p><p id="eb03" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因此，在至少一个成功的请求中，服务工作者必须充当网络代理。安装成功后，将进入激活状态。</p><p id="197d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">激活状态表示服务工作者的运行状态，并导致服务工作者休眠的空闲状态。如果它保持休眠一段时间，它就会终止。当发出类似于<code class="fe nc nd ne nf b">sync</code>或<code class="fe nc nd ne nf b">fetch</code>的消息事件时，另一个分支被激活。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/ccfdc79888580a36e967ae5e00ce2195.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*Vwp6-1TJ2U3jsJOOuD0f8Q.jpeg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务人员的生命周期</p></figure><p id="c3fe" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">有了这些背景信息，让我们试着实现一个基本的worker，如果用户离线，它会用一个定制页面来响应。我们打算不使用任何闪亮的前端框架来实现这一点。</p><p id="27fd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然而，服务人员并不依赖于框架，从本文中获得的大部分知识应该很容易转移到您选择的前端JavaScript框架。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="e224" class="kw kx iq bd ky kz mx lb lc ld my lf lg jw mz jx li jz na ka lk kc nb kd lm ln bi translated">使用服务人员离线加载内容</h1><p id="03be" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这个想法是使用一个服务工作者作为web代理，如果internet连接可用，它将返回所请求的资源。万一请求失败，它应该返回一个静态缓存资源。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/a8c595078a486481983ab21962e56d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*fFKJgLjg7eYOEO9JZqeneQ.jpeg"/></div></figure><p id="8c0c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们从注册服务人员开始。服务工作者本身是一个JavaScript文件，必须由应用程序JavaScript文件注册。我们从一个结构开始，其中<code class="fe nc nd ne nf b">app.js</code>是包含在HTML页面中的JavaScript文件，而<code class="fe nc nd ne nf b">worker.js</code>是包含服务人员相关代码的文件。</p><p id="2bbf" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在<code class="fe nc nd ne nf b">app.js</code>文件中，我们在加载时添加了一个注册服务工作者的事件监听器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="eac9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">接下来，我们要安装服务人员。我们在<code class="fe nc nd ne nf b">worker.js</code>文件中这样做。我们添加一个事件<code class="fe nc nd ne nf b">install</code>。</p><p id="5850" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe nc nd ne nf b">install</code>是我们缓存所需文件的生命周期状态。我们缓存<code class="fe nc nd ne nf b">offline.html</code>并将其写入名为<code class="fe nc nd ne nf b">web-workr-cache-1</code>的缓存中，其中<code class="fe nc nd ne nf b">1</code>是缓存的版本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="8dcb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果我们打开浏览器的开发人员控制台并导航到application选项卡，我们应该会看到名为<code class="fe nc nd ne nf b">web-workr-cache-1</code>的缓存以及缓存的详细信息<code class="fe nc nd ne nf b">offline.html</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/b53748e93b67d11726caff63c17f5de0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ibfAyWuxB82J7WA8lfHFg.png"/></div></div></figure><p id="76be" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">按照生命周期的要求，下一步需要我们激活服务人员。这也进入到<code class="fe nc nd ne nf b">worker.js</code>文件中。这是我们试图消除以前的缓存的部分。我打算跳过这个方法。然而，它看起来像这样:</p><pre class="kg kh ki kj gt nl nf nm nn aw no bi"><span id="530b" class="np kx iq nf b gy nq nr l ns nt">self.addEventListener('activate', <em class="mk">e</em> =&gt; {</span><span id="07b9" class="np kx iq nf b gy nu nr l ns nt">console.log('Activation!');</span><span id="7d39" class="np kx iq nf b gy nu nr l ns nt">});</span></pre><p id="1024" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们要处理的最后一个事件是<code class="fe nc nd ne nf b">fetch</code>事件。在<code class="fe nc nd ne nf b">fetch</code>事件中，如果互联网连接失效，我们拦截请求并返回离线页面。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c295" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当从浏览器发出web请求时，上面的代码就会出现。线<code class="fe nc nd ne nf b">event.request.mode === 'navigate'</code>表示用户导航的意图。更多关于<code class="fe nc nd ne nf b">event.request.mode</code>的信息可以在这里找到<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/mode" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="14cf" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果导航请求失败，我们捕获错误，因为我们不想对错误对象本身做任何事情，所以我们使用一个占位符，<code class="fe nc nd ne nf b">_</code>。从<code class="fe nc nd ne nf b">catch</code>街区我们返回<code class="fe nc nd ne nf b">caches.match(pageToSave)</code>。</p><p id="f8e9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">回忆<code class="fe nc nd ne nf b">pageToSave</code>是在我们服务人员的安装阶段保存的一个HTML文件。<code class="fe nc nd ne nf b">pageToSave</code>对应<code class="fe nc nd ne nf b">offline.html</code>。</p><p id="3246" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这个代码片段的效果可以理解如下:当用户请求web上的资源并且该请求可以被成功地服务时，用户能够访问该资源。请求资源就像导航到不同的网页一样简单。</p><p id="c3ca" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">但是，如果用户请求某个资源，而该请求由于互联网连接或服务器不可用或任何其他原因而失败，则会显示之前缓存的离线页面。</p><p id="037d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">为了演示这一点，我们使用了Live Server，它可以在这里<a class="ae kv" href="https://www.npmjs.com/package/live-server" rel="noopener ugc nofollow" target="_blank">获得</a>。</p><p id="bd02" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当服务器在线时:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/e20267f4632c9a9d45ae229d130ef1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkPOJ3meEo7t7W5UYOwLSg.png"/></div></div></figure><p id="f12d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">下面我们可以看到一个离线服务器。我没有勾选离线复选框，而是关闭了实时服务器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/38f30525ce2287ecd187d18ea6e755ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xejLMqD8ID2oZpzlxHX-IQ.png"/></div></div></figure><p id="1ff7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">请注意，对于这两种情况，URL保持不变。在第一种情况下，获取远程资源，在第二种情况下，呈现缓存的页面。</p><p id="4d17" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">完整的源代码可以在我的<a class="ae kv" href="https://github.com/sumitmukhija/service-worker-demo" rel="noopener ugc nofollow" target="_blank"> GitHub这里</a>找到。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="7a81" class="kw kx iq bd ky kz mx lb lc ld my lf lg jw mz jx li jz na ka lk kc nb kd lm ln bi translated"><em class="nw">参考文献</em></h1><ul class=""><li id="7e91" class="nx ny iq lq b lr ls lu lv lx nz mb oa mf ob mj oc od oe of bi translated"><a class="ae kv" href="https://developers.google.com/web/fundamentals/primers/service-workers" rel="noopener ugc nofollow" target="_blank">《服务人员:介绍》</a></li><li id="8e53" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" rel="noopener ugc nofollow" target="_blank">“Service _ Worker _ API</a></li><li id="eb1d" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=ksXwaWHCW6k&amp;t=1341s" rel="noopener ugc nofollow" target="_blank">“服务人员简介&amp;缓存”</a></li><li id="da28" class="nx ny iq lq b lr og lu oh lx oi mb oj mf ok mj oc od oe of bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=jVfXiv03y5c" rel="noopener ugc nofollow" target="_blank">“服务人员简介”</a></li></ul></div></div>    
</body>
</html>