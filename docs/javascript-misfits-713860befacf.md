# JavaScript 不合群:决定你一天成败的琐事

> 原文：<https://betterprogramming.pub/javascript-misfits-713860befacf>

## Bignums、NaN、奇数真值等等

资料来源:Giphy.com

# NaN 类型

有时候，你的函数会返回一些不定形式(比如 0/0，无穷大-无穷大等等。)并且该值被赋予特殊的数字`NaN`，其代表*而不是数字*。

`NaN` 听起来很诡异，本身就有一种类型的*号*！

```
typeof(NaN);
--> “number”
```

如果你认为，`NaN`实际上是赋给一个 JavaScript 无法解释的数字的值。这是一个数字，就我们的常识而言，这不是一个数字。所以，它还是一个数字，对吗？对吗？

# 9999999999999999

这并不像看起来那么棘手，但总是在人们第一眼看到它时就被吸引住。只需在控制台中键入这个巨大的数字:

```
console.log(9999999999999999);--> 10000000000000000
```

好吧，刚刚发生了什么？JS 是在给我四舍五入数字吗？你可以从它上面去掉一些 9 来检查。

```
console.log(9999999999999);--> 9999999999999
```

很明显这不是四舍五入。那么，这个全是 9 的 16 位数是怎么回事呢？

```
console.log(1234567892345671);--> 1234567892345671
```

等等，1234567892345671 保持原样。那么，有什么条件呢？

JavaScript 没有整数，只有浮点数，只包含有限的精度，最多 15 位。这个数字的精度有所损失，因为在 64 位中，只有 52 位可用于存储数字，在这种情况下，它是不够的。

# 0.1 + 0.2 !=0.3

等等，你疯了吗？那是一些六年级数学 JS 搞不定的！

```
console.log(0.1 + 0.2!=0.3);--> true
```

或者，也许，这是一些你不能处理的 JavaScript

```
console.log(0.1 + 0.2);--> 0.30000000000000004
```

JavaScript 存储小数和分数不像我们在头脑中存储它们那样容易，它将它们转换成二进制数，仅仅是 0 和 1 的组合。

你刚刚偶然发现了一个不符合二进制的数字(0.3)！放松，你和 JavaScript 都能像专家一样处理六年级的数学！

# Math.max()和 Math.min()

```
console.log(Math.max());
--> -Infinityconsole.log(Math.min());
--> Infinity
```

`Math`是一个 JavaScript 对象，您已经使用了无数次，上面的表达式产生的结果似乎不合理。

`max()`和`min()`是挂在`Math`对象上的方法，它们分别从一组值中返回最大值和最小值。

当您没有传递任何参数时，`Math.max()`会取可能的最小值，因为它实际上是一组空值中的最大值。有道理？

还记得在编程的早期课程中，给我们一组数字，我们需要从中找出最大的数字吗？

我们首先取一个变量`‘Max’`，并给它分配一个尽可能小的值。然后我们遍历数组，用这个`‘Max’`在每次迭代中使用蛮力检查值。

在任何时刻，这个`‘Max’`保存了目前为止遇到的最大值。你能把这个简单的算法和我们刚刚读到的`Math.max()`的意外结果联系起来吗？

# [ ] + [ ]

看起来我们正在添加两个空数组…

```
[]+[]
--> “”
```

我们能得到一串吗？什么？

`+`操作符只用于数字和字符串。当用于任何其他类型时，JS 首先将该类型转换为 string。

# [ ] + { }

```
console.log([]+{});--> [object Object]
```

这个有什么特别的？我们只是拿回一个东西！是吗？仔细看。大写 O 的`Object`是您非常熟悉的`object`数据结构的构造函数的名称。

JavaScript 中的大多数对象实际上都是`Object objects.`

# true===1

很多时候，我们利用了这样一个事实:除了零，一切都是真理。

```
true==1
--> true
```

然而:

```
true===1
--> false
```

这个并不是真的不适合，但是因为我们习惯于把 1 当作真，把 0 当作假，所以它有时可能是一个真正的骗子。

```
typeof(true)
--> “boolean”typeof(1);
--> “number”
```

我们在比较两种不同的类型，必然会得到错误的比较结果。

三重相等检查类型和值。

# [ ]==0

```
[]==0
--> true
```

没有值的数组是假值？

在 JavaScript 中，空数组被转换为空字符串，而空字符串被视为 falsy 值。

# (!+[ ]+[ ]+![ ])

```
console.log((!+[]+[]+![]).length)
 --> 9
```

不，我的猫没有跑过我的键盘。去挠头一会儿吧…

提示:这与操作符的优先级和字符串的长度有关。

对了，我没养猫！

资料来源:Giphy.com

2020 快乐。

你可以在栈溢出中找到对每个问题的详细解释。请在评论中让我知道有多少你已经知道了，能想出来，又有多少让你感到惊讶！