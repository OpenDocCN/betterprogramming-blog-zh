<html>
<head>
<title>SwiftUI Binding Extensions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI绑定扩展</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-binding-extensions-b6a9f27d2858?source=collection_archive---------1-----------------------#2022-11-19">https://betterprogramming.pub/swiftui-binding-extensions-b6a9f27d2858?source=collection_archive---------1-----------------------#2022-11-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="afad" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使SwiftUI视图和预览中的绑定像ABC一样简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f9d0f1cca649a630e9e04ee83e4daf0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P32-jZX197Zxwhf579xkvA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae ky" href="https://unsplash.com/s/photos/easy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是一些常见的SwiftUI问题，属于“必须有更好的方法”一类。</p><h1 id="7a2f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">可选值</h1><p id="49b6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们从期权开始。由于API需求，在我们的代码中有可选值是很常见的，但是在SwiftUI中使用它们可能有点痛苦。考虑一下。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="aa76" class="mx lw it mt b be my mz l na nb">class SomeViewModel: ObservableObject {<br/>    @Published var name: String?<br/>}<br/><br/>struct SomeView: View {<br/>    @StateObject var viewModel = SomeViewModel()<br/>    var body: some View{<br/>        TextField("Name", text: $viewModel.name) // does not compile<br/>    }<br/>}</span></pre><p id="0909" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个带有可选名称字符串的视图模型，我们希望能够编辑该值。不幸的是，TextField绑定没有可选的初始化器，Swift编译器会给我们一个错误。<em class="nc">"无法转换类型'绑定&lt;字符串的值？&gt;'到预期参数类型'绑定&lt;字符串&gt;'。</em></p><p id="a1ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么办？我的意思是，如果它是一个<code class="fe nd ne nf mt b">Text</code>视图，我们只需使用一个nil合并操作符来为所讨论的字符串提供一个默认值。</p><p id="ebba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们如何为绑定提供默认值呢？</p><h1 id="a9d6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">绑定扩展</h1><p id="2e9b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">根据文章标题，您可能已经猜到了部分解决方案。是的，我们将创建绑定的扩展。</p><p id="17e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是代码。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="67d1" class="mx lw it mt b be my mz l na nb">extension Binding {<br/>    public func defaultValue&lt;T&gt;(_ value: T) -&gt; Binding&lt;T&gt; where Value == Optional&lt;T&gt; {<br/>        Binding&lt;T&gt; {<br/>            wrappedValue ?? value<br/>        } set: {<br/>            wrappedValue = $0<br/>        }<br/>    }<br/>}</span></pre><p id="f761" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，有了这些，我们就可以做了。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="f386" class="mx lw it mt b be my mz l na nb">struct SomeView: View {<br/>    @StateObject var viewModel = SomeViewModel()<br/>    var body: some View{<br/>        TextField("Name", text: $viewModel.name.defaultValue(""))<br/>    }<br/>}</span></pre><p id="fb83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要做的就是给我们的字符串一个默认值，然后我们就可以开始了。如果存在，扩展将提供name的值，如果不存在，则提供默认值。无论哪种方式，它看起来都像是对文本字段的非可选绑定，所以我们的代码现在像预期的那样工作。</p><p id="8fef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们的<code class="fe nd ne nf mt b">defaultValue</code>扩展是通用的，它可以处理字符串、整数、布尔…我们需要的任何东西。</p><h1 id="5f59" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">空字符串</h1><p id="4822" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果我们处理大量的字符串，如果我们总是将它们默认为空，我们可以借用RxSwift在<em class="nc"> it </em>需要进行可选文本绑定时使用的概念。</p><p id="a4a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们再增加一个节目。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="3b4f" class="mx lw it mt b be my mz l na nb">extension Binding where Value == Optional&lt;String&gt; {<br/>    public var orEmpty: Binding&lt;String&gt; {<br/>        Binding&lt;String&gt; {<br/>            wrappedValue ?? ""<br/>        } set: {<br/>            wrappedValue = $0<br/>        }<br/>    }<br/>}</span></pre><p id="8cce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许…</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="0f47" class="mx lw it mt b be my mz l na nb">struct SomeView: View {<br/>    @StateObject var viewModel = SomeViewModel()<br/>    var body: some View{<br/>        TextField("Name", text: $viewModel.name.orEmpty)<br/>    }<br/>}</span></pre><p id="9a2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和<code class="fe nd ne nf mt b">defaultValue("")</code>一样，只是要写的代码少一点。</p><h1 id="026d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">SwiftUI预览中的绑定</h1><p id="383d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们继续，看看下面令人惊讶的复杂SwiftUI视图。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="dba2" class="mx lw it mt b be my mz l na nb">struct AmazinglyComplexView: View {<br/><br/>    @Binding var value: Bool<br/><br/>    var body: some View {<br/>        Toggle(isOn: $value) {<br/>            Text("Toggle Me")<br/>        }<br/>        .padding()<br/>    }<br/>}</span></pre><p id="fa0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有一个带有<code class="fe nd ne nf mt b">Toggle</code>的视图，它绑定到某个值。现在我们想预览一下我们的视图。简单对吗？</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="2137" class="mx lw it mt b be my mz l na nb">struct AmazinglyComplexView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        AmazinglyComplexView(value: .constant(true))<br/>    }<br/>}</span></pre><p id="445d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们有一个绑定，所以我们遵循SwiftUI约定，并将<code class="fe nd ne nf mt b">.constant(true)</code>传递给视图的绑定参数。一旦我们这样做了，我们看到了我们的观点预览。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8d167d01b89fa7251fe7edadfd20bca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*don3wnKQvs5T1w4ZelZJgg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">样本预览</p></figure><p id="9c88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，只有一个问题。在Xcode 14中，预览现在是活动的…但是我们不能切换我们的视图并看到我们的开关改变，因为我们为我们的绑定传入了一个常量值。按下开关没有任何作用。</p><p id="40a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">怎么办？</p><h1 id="233b" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">查看包装</h1><p id="14d1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">嗯，如果你检查一下StackOverflow，你会看到普遍的共识是用另一个定义了<code class="fe nd ne nf mt b">@State</code>变量的<em class="nc">视图来包装我们的视图，然后将那个</em>值的绑定传递给我们的视图。</p><p id="72bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你知道，我们首先想要测试的观点。看起来是这样的。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="287c" class="mx lw it mt b be my mz l na nb">struct AmazinglyComplexView_Previews: PreviewProvider {<br/>    struct Wrapper: View {<br/>        @State var value: Bool<br/>        var body: some View {<br/>            AmazinglyComplexView(value: $value)<br/>        }<br/>    }<br/>    static var previews: some View {<br/>        Wrapper(value: true)<br/>    }<br/>}</span></pre><p id="2223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，这实际上是苹果在<a class="ae ky" href="https://developer.apple.com/wwdc20/10149" rel="noopener ugc nofollow" target="_blank"> WWDC 2020开发者视频</a>中推荐的方法。</p><p id="331a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论哪种方式，结果都是一样的，我们的预览是有效的。</p><p id="f6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是……真的吗？每当我们想要预览一个包含绑定的视图时，我们都必须经历这种繁琐的过程吗？</p><h1 id="e294" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">仿制药来拯救！</h1><p id="55ca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我想，我们可以展示一下我们的SwiftUI-fun，并编写一些通用视图。将我们的预览视图包装在一个<code class="fe nd ne nf mt b">ViewBuilder</code>中，并创建一个适当类型的状态对象。也许类似于…</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="9511" class="mx lw it mt b be my mz l na nb">struct StateWrapper&lt;Value, Content:View&gt;: View {<br/>    @State var value: Value<br/>    let content: (_ value: Binding&lt;Value&gt;) -&gt; Content<br/>    init(value: Value, @ViewBuilder content: @escaping (_ value: Binding&lt;Value&gt;) -&gt; Content) {<br/>        _value = .init(initialValue: value)<br/>        self.content = content<br/>    }<br/>    var body: some View {<br/>        content($value)<br/>    }<br/>}<br/><br/>struct AmazinglyComplexView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        StateWrapper(value: true) {<br/>            AmazinglyComplexView(value: $0)<br/>        }<br/>    }<br/>}</span></pre><p id="a682" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">答对了。我们有另一个解决方案。算是吧。我的意思是，至少现在我们不必每次想用单个绑定测试某个视图时都创建一个包装器…</p><p id="ed91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哦。见鬼。</p><p id="24c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要用两个绑定测试一个视图呢？还是三个？我们开始用一个、两个、三个和四个绑定来编写StateWrappers吗？</p><p id="0ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应该有更简单的方法。</p><h2 id="1692" class="nh lw it bd lx ni nj dn mb nk nl dp mf li nm nn mh lm no np mj lq nq nr ml ns bi translated">可变的</h2><p id="6cd3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">SwiftUI非常非常接近于提供我们所需要的<code class="fe nd ne nf mt b">.constant</code>。</p><p id="3e7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是你可能知道，只有在马蹄铁、手榴弹和你的除臭剂不起作用的时候，亲密才算数。记住这一点，请允许我介绍<code class="fe nd ne nf mt b">.variable</code>。</p><p id="2006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将以下扩展添加到您的代码中。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="b187" class="mx lw it mt b be my mz l na nb">extension Binding {<br/>    public static func variable(_ value: Value) -&gt; Binding&lt;Value&gt; {<br/>        var state = value<br/>        return Binding&lt;Value&gt; {<br/>            state<br/>        } set: {<br/>            state = $0<br/>        }<br/>    }<br/>}</span></pre><p id="2a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们创建一个扩展函数，它将初始值赋给一个内部状态变量。绑定的get和set闭包捕获该状态变量，并根据需要对其进行变异。</p><p id="b3de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样。现在，当您想在预览中测试您的视图时，只需这样做。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="5b66" class="mx lw it mt b be my mz l na nb">struct AmazinglyComplexView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        AmazinglyComplexView(value: .variable(true))<br/>    }<br/>}</span></pre><p id="8f61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以随心所欲地切换视图的<code class="fe nd ne nf mt b">Toggle</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/72a734d9ad9699c5a72953f64fe22fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*hISeRoysAykCindkAQdwRA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">切换2预览</p></figure><p id="b084" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的是，有了<code class="fe nd ne nf mt b">.variable</code>，我们可以根据需要随时使用它们。</p><p id="df0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc">请注意，这项技术并不完美。最大的缺点是它不会触发一个完整的视图刷新，所以依赖于我们的toggle值的任何其他视图都不会更新。</em></p><p id="540c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道，对吧？无论如何，variable仍然是一个有用的扩展，当你做原型的时候，如果需要的话，你总是可以使用<code class="fe nd ne nf mt b">StateWrapper</code>。</p><h1 id="beca" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更多手榴弹</h1><p id="c271" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">鉴于<code class="fe nd ne nf mt b">.variable</code>在呈现视图时的上述缺点，我为需要多达四个不同绑定的视图添加了一些额外的通用绑定包装器。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="988d" class="mx lw it mt b be my mz l na nb">struct Bindings&lt;Value, Content:View&gt;: View {<br/>    @State var value: Value<br/>    let content: (_ value: Binding&lt;Value&gt;) -&gt; Content<br/>    init(value: Value, @ViewBuilder content: @escaping (_ value: Binding&lt;Value&gt;) -&gt; Content) {<br/>        _value = .init(initialValue: value)<br/>        self.content = content<br/>    }<br/>    var body: some View {<br/>        content($value)<br/>    }<br/>}<br/><br/>struct Bindings2&lt;V0, V1, Content:View&gt;: View {<br/>    @State var v0: V0<br/>    @State var v1: V1<br/>    let content: (_ v0: Binding&lt;V0&gt;, _ v1: Binding&lt;V1&gt;) -&gt; Content<br/>    init(_ v0: V0, _ v1: V1, @ViewBuilder content: @escaping (_ v0: Binding&lt;V0&gt;, _ v1: Binding&lt;V1&gt;) -&gt; Content) {<br/>        _v0 = .init(initialValue: v0)<br/>        _v1 = .init(initialValue: v1)<br/>        self.content = content<br/>    }<br/>    var body: some View {<br/>        content($v0, $v1)<br/>    }<br/>}<br/><br/>struct Bindings3&lt;V0, V1, V2, Content: View&gt;: View {<br/>    @State var v0: V0<br/>    @State var v1: V1<br/>    @State var v2: V2<br/>    let content: (_ v0: Binding&lt;V0&gt;, _ v1: Binding&lt;V1&gt;, _ v2: Binding&lt;V2&gt;) -&gt; Content<br/>    init(_ v0: V0, _ v1: V1, _ v2: V2,<br/>         @ViewBuilder content: @escaping (_ v0: Binding&lt;V0&gt;, _ v1: Binding&lt;V1&gt;, _ v2: Binding&lt;V2&gt;) -&gt; Content) {<br/>        _v0 = .init(initialValue: v0)<br/>        _v1 = .init(initialValue: v1)<br/>        _v2 = .init(initialValue: v2)<br/>        self.content = content<br/>    }<br/>    var body: some View {<br/>        content($v0, $v1, $v2)<br/>    }<br/>}<br/><br/>struct Bindings4&lt;V0, V1, V2, V3, Content: View&gt;: View {<br/>    @State var v0: V0<br/>    @State var v1: V1<br/>    @State var v2: V2<br/>    @State var v3: V3<br/>    let content: (_ v0: Binding&lt;V0&gt;, _ v1: Binding&lt;V1&gt;, _ v2: Binding&lt;V2&gt;, _ v3: Binding&lt;V3&gt;) -&gt; Content<br/>    init(_ v0: V0, _ v1: V1, _ v2: V2, _ v3: V3,<br/>         @ViewBuilder content: @escaping (_ v0: Binding&lt;V0&gt;, _ v1: Binding&lt;V1&gt;, _ v2: Binding&lt;V2&gt;, _ v3: Binding&lt;V3&gt;) -&gt; Content) {<br/>        _v0 = .init(initialValue: v0)<br/>        _v1 = .init(initialValue: v1)<br/>        _v2 = .init(initialValue: v2)<br/>        _v3 = .init(initialValue: v3)<br/>        self.content = content<br/>    }<br/>    var body: some View {<br/>        content($v0, $v1, $v2, $v3)<br/>    }<br/>}</span></pre><p id="9965" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">挑一个你需要的。</p><pre class="kj kk kl km gt ms mt mu bn mv mw bi"><span id="9fe4" class="mx lw it mt b be my mz l na nb">struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        Bindings2(true, "Mike") {<br/>            AnotherComplexView(value: $0, name: $1)<br/>        }<br/>    }<br/>}</span></pre><p id="78a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你要传递超过四个不同的绑定…你可能要考虑重构一些代码。</p><p id="9ec7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随便说说。</p><h1 id="4011" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">完成块</h1><p id="835b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">所以你有它。今天没有什么惊天动地的事情，只是我们在代码中经常遇到的一些常见的SwiftUI绑定问题，以及一些我最喜欢的绑定扩展和视图包装器，它们让我们可以精简它们。</p><p id="7b6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有自己喜欢的吗？请在下面的评论中告诉我。</p><p id="d999" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下次见。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="381e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nc">本文是</em><a class="ae ky" href="https://michaellong.medium.com/the-swiftui-series-abc180690a9d" rel="noopener"><em class="nc">SwiftUI系列</em> </a> <em class="nc">的一部分。</em></p></div></div>    
</body>
</html>