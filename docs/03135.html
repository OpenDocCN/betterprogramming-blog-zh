<html>
<head>
<title>Strongly Keyed Maps in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的强键控映射</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/strongly-keyed-maps-in-typescript-3c1c28377627?source=collection_archive---------8-----------------------#2020-01-22">https://betterprogramming.pub/strongly-keyed-maps-in-typescript-3c1c28377627?source=collection_archive---------8-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2fd3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">表示映射对象<em class="ki">可能只包含在某个类型T </em>的成员的域中找到的键</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/f695fd721a4166b808d803f53de1fa8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AnrL2GUCBsGJAOLhNiOKFg.png"/></div></div></figure><p id="03bb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">简单来说:</p><p id="c12d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">唯一有效的键是那些对应于给定类型<code class="fe lr ls lt lu b">T</code>中同名属性的键。</p><p id="1f89" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们称之为<em class="lv">强键控映射，</em>它可以表示为:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="8929" class="ma mb it lu b gy mc md l me mf">type StronglyKeyedMap&lt;T, K extends keyof T, V&gt; = { [k in K]: V }</span></pre><p id="9d32" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在，我们将给出一些实际类型的实例化:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="7b43" class="ma mb it lu b gy mc md l me mf">interface Foo<br/>{<br/>  x : number;<br/>  y : string;<br/>  z : boolean;<br/>}</span><span id="2a72" class="ma mb it lu b gy mg md l me mf">type FooTrueSKM = StronglyKeyedMap&lt;Foo, keyof Foo, true&gt;</span></pre><p id="8d8f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这表明只允许<code class="fe lr ls lt lu b">Foo</code>的成员，并且每个成员必须映射到常量值<code class="fe lr ls lt lu b">true</code>:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="3fbc" class="ma mb it lu b gy mc md l me mf">const example : FooTrueSKM = { <br/>  x : true, <br/>  y : true,<br/>  a : true, // not ok because `a` does not exist in `Foo`<br/>  z : 123, // not ok because not mapped to true<br/>}</span></pre><p id="bc3d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">好的，这是可行的，但是每次在实例化中使用<code class="fe lr ls lt lu b">keyof</code> ( <a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#index-types" rel="noopener ugc nofollow" target="_blank">索引类型</a>)有点不太合适。因此，我们可以提供一个额外的间接层来清理这个问题:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="6353" class="ma mb it lu b gy mc md l me mf">type SKM&lt;T, V&gt; = StronglyKeyedMap&lt;T, keyof T, V&gt;</span><span id="de7f" class="ma mb it lu b gy mg md l me mf">type FooTrueSKM = SKM&lt;Foo, true&gt; // one less type argument</span></pre><p id="584e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第二个问题是如果所有的<code class="fe lr ls lt lu b">Foo</code>成员都不在映射中，那么<code class="fe lr ls lt lu b">FooTrueSKM</code>的用法将无法通过类型检查。</p><p id="a645" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是很多时候，我们只想拥有一个键的子集。幸运的是，TypeScript提供了一个内置的<code class="fe lr ls lt lu b"><a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt" rel="noopener ugc nofollow" target="_blank">Partial&lt;T&gt;</a></code> <a class="ae mh" href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt" rel="noopener ugc nofollow" target="_blank">实用程序类型</a>供我们使用:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="6b27" class="ma mb it lu b gy mc md l me mf">type FooTrueSKM = Partial&lt;SKM&lt;Foo, true&gt;&gt; // now partial</span></pre><p id="bccb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这意味着我们现在可以做:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="8212" class="ma mb it lu b gy mc md l me mf">const example : FooTrueSKM = { <br/>  x : true,<br/>  y : true  <br/>  // note: omitting `z` would fail typechecking <strong class="lu iu">without</strong> Partial&lt;T&gt;<br/>}</span></pre><p id="46d2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，这为我们提供了一个非常紧凑的通用解决方案，我们可以用它来表达特定实例的辅助/相关信息，而不会污染底层的类型定义(事件类型—例如，<code class="fe lr ls lt lu b">Foo</code>)。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="b7a1" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">枚举</h1><p id="0d8a" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">当事件类型<code class="fe lr ls lt lu b">T</code>实际上是一个enum时，这个解决方案也可以工作，但是它需要一点额外的工作。</p><p id="23cd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">给定以下枚举定义…</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="d9f7" class="ma mb it lu b gy mc md l me mf">enum Bar {<br/>  hello,<br/>  world<br/>}</span></pre><p id="9acf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">…考虑一下我们是否对类型实例化使用相同的底层策略:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="9469" class="ma mb it lu b gy mc md l me mf">type BarSKM = Partial&lt;StronglyKeyedMap&lt;Bar, keyof Bar, true&gt;&gt;;</span><span id="fe1d" class="ma mb it lu b gy mg md l me mf">const example : BarSKM = { hello : true }</span></pre><p id="626a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将导致类型检查失败，因为映射是针对枚举的隐式属性的:<code class="fe lr ls lt lu b">toString</code>、<code class="fe lr ls lt lu b">valueOf</code>等。</p><p id="8dfe" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然而，我们希望这更像是一个<em class="lv">强成员映射</em>(SMM)——也就是说，映射中唯一有效的键是枚举的成员。</p><p id="efdf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">您可能认为在解决方案中使用<code class="fe lr ls lt lu b">typeof</code>和<code class="fe lr ls lt lu b">keyof</code>:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="827b" class="ma mb it lu b gy mc md l me mf">type BarSMM = Partial&lt;StronglyKeyedMap&lt;<strong class="lu iu">typeof Bar</strong>, keyof Bar, true&gt;&gt;</span></pre><p id="1f9d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是，尽管这更接近了，它仍然产生与以前相同的问题。</p><p id="45ab" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正确的定义是:</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="63a0" class="ma mb it lu b gy mc md l me mf">type BarSMM = Partial&lt;StronglyKeyedMap&lt;typeof Bar, <strong class="lu iu">keyof typeof Bar</strong>, true&gt;&gt;</span></pre><p id="5d43" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意keys domain参数中的附加<code class="fe lr ls lt lu b">typeof</code>。</p><pre class="kk kl km kn gt lw lu lx ly aw lz bi"><span id="a126" class="ma mb it lu b gy mc md l me mf">const example : BarSMM = {<br/>  hello : true, // ok!<br/>  toString : true // not ok because `toString` is <strong class="lu iu">not in key domain</strong><br/>}</span></pre></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="62cf" class="mp mb it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">结论</h1><p id="13d7" class="pw-post-body-paragraph kv kw it kx b ky ng ju la lb nh jx ld le ni lg lh li nj lk ll lm nk lo lp lq im bi translated">所以我们有了它:在TypeScript中强键/成员映射的解决方案。</p><p id="b356" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">只是要确保在实际的产品代码中使用稍微好一点的类型命名。</p></div></div>    
</body>
</html>