<html>
<head>
<title>Live Reloading With Docker Compose for Efficient Development</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker Compose进行实时重新加载，以提高开发效率</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/live-reloading-with-docker-compose-for-efficient-development-356d50e91e39?source=collection_archive---------4-----------------------#2019-12-11">https://betterprogramming.pub/live-reloading-with-docker-compose-for-efficient-development-356d50e91e39?source=collection_archive---------4-----------------------#2019-12-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5299" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">即插即用现场重装在docker-组成与docker-看门狗</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ced5e4a3e62abc53e56b833ed2696176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SJ8e4-ZANeo7q1bB1vq8oA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@frankiefoto?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰克·麦肯纳</a>在<a class="ae ky" href="https://unsplash.com/s/photos/containers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的原始照片</p></figure><h1 id="25f2" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="e1e1" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">毫无疑问，Docker容器已经变得无处不在。考虑到集装箱化提供的灵活性和好处。这自然是意料之中的。</p><p id="14ea" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">更重要的是，有了这些新的软件架构范例。例如微服务和无服务器，对独立的、隔离的软件组件的需求是突出的。即使事情变得更加复杂和相互关联，也有像docker-compose这样的补充工具，通过管理和链接许多容器使开发人员的生活变得更容易。</p><p id="e5b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">然而，随着这种情况的发展以及新技术的采用和部署，软件开发方法、实践和过程也必须跟上。否则，大量的时间会浪费在开发上，最终会与目的背道而驰。当我甚至不能一键本地测试时，一键部署有什么意义？</p><p id="7495" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">也就是说，这篇文章旨在通过演示如何配置一个<code class="fe ms mt mu mv b">docker-compose</code>模板栈来允许在文件被修改时实时重新加载服务——而无需修改您现有的代码，来涵盖这个论点的一小部分。</p><p id="4917" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">只是澄清一下，这篇文章假设你熟悉Docker和<code class="fe ms mt mu mv b">docker-compose</code>。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="3f10" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">到底有什么问题？</h1><p id="412d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">这个<code class="fe ms mt mu mv b">docker-compose</code>设计模式背后的灵感来源于我在本地运行<code class="fe ms mt mu mv b">docker-compose</code>栈时的挫败感，每次修改代码都需要重启。</p><p id="807f" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">想象一下下面的场景:你正在使用一个web框架开发一个web应用程序，比如说一个Django应用程序(可以是任何语言的任何web框架)。</p><p id="0ed8" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">通常，您可以使用Django的命令行工具轻松开发应用程序，这些工具提供了开箱即用的自动加载功能。然而，随着项目的进展，您决定使用Postgres，而不是Django默认的后端SQLite。您还添加了芹菜工人的芹菜任务，为不同的应用程序功能添加了另一个Flask服务，最后，添加了一个nginx web代理。</p><p id="9fd9" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">如果没有容器，这将要求每个开发人员在他们的开发环境中分别运行Postgres服务器、celery workers、Flask应用程序和Django应用程序，这样整个工作才能正常进行。除此之外，为一个新的开发人员设置开发环境来开始这个项目将是一场噩梦。而这一切都会污染你的个人机器。</p><p id="5627" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">那么解决这个问题的办法是什么呢？码头工人作曲。</p><p id="c1b2" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">所有这些都可以划分到Docker容器中，不同的服务可以在一个<code class="fe ms mt mu mv b">docker-compose.yml</code>模板中定义，该模板允许开发人员只需一个命令就可以运行和链接整个堆栈。然后，一切都部署在它自己的隔离环境中，不再需要担心您的工作环境和依赖性。但是现在还有另一个问题。</p><p id="1f99" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">每次你修改代码，你都必须重启<code class="fe ms mt mu mv b">docker-compose</code>栈。这包括切换到终端，通常终止已经运行的<code class="fe ms mt mu mv b">docker-compose</code>服务，因为它们是附加的。然后你等到它们被关闭并重新运行时，才发现你在代码中有一个打字错误。也许总共需要15秒钟。</p><p id="3b21" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">我知道，我知道。十五秒听起来不算多。但是如果你要一遍又一遍地做这件事，那么浪费的努力会累积到你想都不敢想的程度。这是在考虑你的大脑在执行所有这些步骤时所遭受的环境转换之前。</p><p id="ec86" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">很多时候，如果您使用开箱即用的框架开发工具进行实时重装(从而将源代码安装到容器上)，您就可以开始了，但是我已经看到并经历了很多容器的入口点非常复杂并且不支持实时重装的情况。这是一个确切的使用案例，其中这一块可以来拯救。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="9c5d" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">解决方案</h1><p id="f3c8" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">为了实现上述功能，我可以使用一个名为<a class="ae ky" href="https://pythonhosted.org/watchdog/" rel="noopener ugc nofollow" target="_blank"> watchdog、</a>的文件监视工具，但是我想创建一个方法:</p><ul class=""><li id="fa0b" class="ni nj it lt b lu mn lx mo ma nk me nl mi nm mm nn no np nq bi translated">语言不可知</li><li id="86b1" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">平台无关的</li><li id="d050" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">不需要修改现有的代码</li><li id="e90f" class="ni nj it lt b lu nr lx ns ma nt me nu mi nv mm nn no np nq bi translated">没有任何依赖关系</li></ul><p id="8de4" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">考虑到这些，我想出了以下解决方案:</p><p id="605a" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">一个公共Docker映像，本质上是Docker中的Docker (dind)映像，安装了Python和watchdog，后者被用作重载服务。因为这是一个dind映像，所以它可以访问运行在主机上的容器，从而能够重新启动它们。它只需要通过环境变量正确安装和配置源代码目录。</p><p id="3162" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">回到前面定义的需求，一个单独的Docker图像标记了所有的框。它将是与语言和平台无关的，不需要任何依赖，并且它可以作为现有<code class="fe ms mt mu mv b">docker-compose</code>文件的扩展，不需要修改。</p><p id="0117" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">以下是该项目的相关存储库:</p><div class="nw nx gp gr ny nz"><a href="https://github.com/apogiatzis/docker-compose-livereloader" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">apogiatzis/docker-compose-liver loader</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这个docker-compose模式旨在为docker-compose栈提供即插即用的实时重载功能。一个…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="oj l ok ol om oi on ks nz"/></div></div></a></div></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="dd42" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">入门指南</h1><p id="aafd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">使用<code class="fe ms mt mu mv b">docker-compose</code>直播重装器非常简单。首先，你需要有一份<code class="fe ms mt mu mv b">docker-compose</code>文件。这个想法是创建一个新的本地<code class="fe ms mt mu mv b">docker-compose</code>文件，扩展您现有的文件，并在您的堆栈中添加reloader服务。</p><p id="0fd1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">按照以下步骤为您的项目启用实时重装:</p><h2 id="7f25" class="oo la it bd lb op oq dn lf or os dp lj ma ot ou ll me ov ow ln mi ox oy lp oz bi translated">1.创建一个新的docker-compose yml文件— <code class="fe ms mt mu mv b">docker-compose-with-reloading.yml — </code>，并添加以下内容:</h2><pre class="kj kk kl km gt pa mv pb pc aw pd bi"><span id="034d" class="oo la it mv b gy pe pf l pg ph">version: '3'<br/><br/>services:<br/><br/>    service-name:<br/>        container_name: &lt;SERVICE_CONTAINER_NAME&gt;<br/>        volumes:<br/>            - "&lt;SOURCE CODE DIR&gt;:&lt;DIRECTORY_TO_MOUNT_CODE&gt;"<br/></span></pre><p id="be6c" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这将覆盖您想要自动重新加载的服务。</p><p id="44b0" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">service-name</code>应与现有名称的名称相匹配。此外，<code class="fe ms mt mu mv b">volumes</code>标记是可选的，只有在您现有的<code class="fe ms mt mu mv b">docker-compose</code>服务还没有安装源代码目录时才应该添加。</p><h2 id="65eb" class="oo la it bd lb op oq dn lf or os dp lj ma ot ou ll me ov ow ln mi ox oy lp oz bi translated">2.将实时重载图像添加到新创建的docker-compose文件中，使其与以下内容相匹配:</h2><pre class="kj kk kl km gt pa mv pb pc aw pd bi"><span id="fd0d" class="oo la it mv b gy pe pf l pg ph">version: '3'<br/><br/>services:<br/><br/>    service-name:<br/>        container_name: &lt;SERVICE_CONTAINER_NAME&gt;<br/>        volumes:<br/>            - "&lt;SOURCE CODE DIR&gt;:&lt;DIRECTORY_TO_MOUNT_CODE&gt;"<br/>    <br/>    live-reloader:<br/>        image: apogiatzis/livereloading<br/>        container_name: livereloader<br/>        privileged: true<br/>        environment:<br/>          - RELOAD_DELAY=1.5              # seconds<br/>          - RELOAD_CONTAINER=&lt;SERVICE_CONTAINER_NAME&gt;<br/>        volumes:<br/>          - "/var/run/docker.sock:/var/run/docker.sock"<br/>          - "&lt;SOURCE CODE DIR&gt;:&lt;DIRECTORY_TO_MOUNT_CODE&gt;"</span></pre><p id="b660" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">这里有几点需要强调。首先。请注意配置参数。</p><p id="69d1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">RELOAD_DELAY</code>指定执行重新启动之前的时间，以便多次连续文件更改仅导致一次重新启动。默认值为1.5秒。</p><p id="b3d1" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">RELOAD_CONTAINER</code>是应该在文件改变时重启的容器名。这应该与上面服务的<code class="fe ms mt mu mv b">container_name</code>中指定的名称相匹配。</p><p id="cac3" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated"><code class="fe ms mt mu mv b">RELOAD_DIR</code>可选参数，用于显式设置需要关注的目录。如果未提供，映像将使用在<code class="fe ms mt mu mv b">volumes</code>部分中指定的挂载点的根文件夹。</p><h2 id="0347" class="oo la it bd lb op oq dn lf or os dp lj ma ot ou ll me ov ow ln mi ox oy lp oz bi translated">3.运行docker-撰写</h2><p id="986d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">要运行带实时重装的<code class="fe ms mt mu mv b">docker-compose</code>，使用以下命令:</p><pre class="kj kk kl km gt pa mv pb pc aw pd bi"><span id="680b" class="oo la it mv b gy pe pf l pg ph">docker-compose -f docker-compose.yml -f docker-compose-with-reloading.yml up</span></pre><p id="4f1d" class="pw-post-body-paragraph lr ls it lt b lu mn ju lw lx mo jx lz ma mp mc md me mq mg mh mi mr mk ml mm im bi translated">相应地修改命令以匹配您的<code class="fe ms mt mu mv b">docker-compose</code>文件。</p></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="8b47" class="kz la it bd lb lc nd le lf lg ne li lj jz nf ka ll kc ng kd ln kf nh kg lp lq bi translated">例子</h1><p id="aae6" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果说明不够清楚，您可以查看相关GitHub资源库中提供的示例:</p><div class="nw nx gp gr ny nz"><a href="https://github.com/apogiatzis/docker-compose-livereloader" rel="noopener  ugc nofollow" target="_blank"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd iu gy z fp oe fr fs of fu fw is bi translated">apogiatzis/docker-compose-liver loader</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">这个docker-compose模式旨在为docker-compose栈提供即插即用的实时重载功能。一个…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">github.com</p></div></div><div class="oi l"><div class="pi l ok ol om oi on ks nz"/></div></div></a></div></div></div>    
</body>
</html>