<html>
<head>
<title>How to Use Mongoose With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中使用Mongoose</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-mongoose-with-node-js-913a8073b29c?source=collection_archive---------1-----------------------#2020-05-12">https://betterprogramming.pub/how-to-use-mongoose-with-node-js-913a8073b29c?source=collection_archive---------1-----------------------#2020-05-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0aa7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向您的MongoDB应用程序添加更多传统的关系数据库功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3bebfb18203e12179c88a37e04c64785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tQHFa_X6fBXceFLDgTAkA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@sandrokatalina?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">桑德罗·卡塔琳娜</a>在<a class="ae ky" href="https://unsplash.com/s/photos/techno?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7f4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您终于学会了如何在您的节点中使用<a class="ae ky" href="https://medium.com/swlh/use-mongodb-with-node-js-14781ec11c0a" rel="noopener"> MongoDB。Js </a>应用程序为您的图书馆后端。现在，您当地的超市老板听说了您所做的出色工作，希望您也能为他做同样的事情。</p><p id="802f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有一些警告。他希望他的数据记录有一个结构，他希望在应用程序内置验证。你做了一些研究，发现一个叫做Mongoose的工具可以满足他的需求。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c4ba" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">简介:猫鼬是什么？</h1><p id="98ac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Mongoose是位于节点之上的对象文档建模(ODM)层。Js MongoDB API。如果您来自SQL背景，那么Mongoose类似于ORM(对象关系映射)。</p><p id="4a4e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在MongoDB原生API上使用Mongoose并不是强制性的。然而，这样做也有一些好处。</p><h2 id="da1b" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">为什么选择Mongoose而不是MongoDB？</h2><ul class=""><li id="e6e8" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu">模式</strong>:还记得我说过超市老板的数据记录需要结构化吗？这种结构被称为模式。这些将在本文后面更详细地讨论。</li><li id="a35d" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">内置验证</strong>:这意味着您不必编写额外的代码，而这些代码是您必须用MongoDB驱动程序编写的。通过简单地在模式定义中包含类似于<code class="fe nz oa ob oc b">required:true</code>的东西，Mongoose为您的集合(包括数据类型)提供了内部验证。</li><li id="c7a6" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">实例方法:</strong>您可以用最少的代码在文档上定义定制方法。虽然在MongoDB中也可以做到这一点，但是Mongoose使得在模式定义中创建和组织这样的方法更加容易。反过来，这意味着您在MongoDB中有更多的样板代码。</li></ul><ol class=""><li id="4480" class="nl nm it lb b lc ld lf lg li od lm oe lq of lu og nr ns nt bi translated"><strong class="lb iu">返回结果</strong>:在Mongoose中，返回查询生成的文档一般比较容易。一个例子是<code class="fe nz oa ob oc b">update</code>查询。在MongoDB中，这个查询只返回一个带有成功标志和修改的文档数的对象。另一方面，Mongoose为您提供更新的文档本身，因此您可以轻松地处理结果。</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="53ee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">通用术语</h1><ul class=""><li id="8a9a" class="nl nm it lb b lc mu lf mv li nn lm no lq np lu nq nr ns nt bi translated"><strong class="lb iu">模式</strong>:mongose中的一切都以模式开始。每个模式映射到一个MongoDB集合，并定义该集合中文档的形状。它有关于文档的属性/字段类型的信息。模式还可以存储关于验证和默认值的信息，以及特定属性是否是必需的。换句话说，它们是文件的蓝图。</li><li id="d6bc" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">模型</strong>:模型是我们用来构造文档的类。</li></ul><p id="0c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他的术语<strong class="lb iu">、</strong>在我之前的<a class="ae ky" href="https://medium.com/better-programming/use-mongodb-with-node-js-14781ec11c0a" rel="noopener">文章</a>中已经深入讨论过了。然而，总而言之:</p><ul class=""><li id="800d" class="nl nm it lb b lc ld lf lg li od lm oe lq of lu nq nr ns nt bi translated"><strong class="lb iu">文档</strong>:简单的数据记录。</li><li id="d3f3" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><strong class="lb iu">集合</strong>:一套文档。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f4fb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">入门指南</h1><p id="e509" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">只需通过npm安装<code class="fe nz oa ob oc b">mongoose</code>模块。</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="0a61" class="mz md it oc b gy ol om l on oo">npm install mongoose</span></pre><p id="a541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如需npm指南，请点击<a class="ae ky" href="https://medium.com/@hussainarifkl/the-basics-of-npm-a32ee1d79901" rel="noopener">此处</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">初始化我们的数据库</h1><p id="8b27" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在机器上已经安装了Mongoose，我们将使用<code class="fe nz oa ob oc b">mongoose.connect</code>连接到我们的数据库，就像这样:</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="2aaa" class="mz md it oc b gy ol om l on oo">const mongoose = require('mongoose')<br/><strong class="oc iu">mongoose.connect('mongodb://localhost/test', {useNewUrlParser: true});</strong></span></pre><p id="d196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们连接到一个名为<code class="fe nz oa ob oc b">test</code>的数据库。第一个参数是<code class="fe nz oa ob oc b">URI</code>，第二个参数是<code class="fe nz oa ob oc b">options</code>。</p><p id="ddb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">网址的格式是<code class="fe nz oa ob oc b">type://username:password@host:port/database_name</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dca0" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义模式</h1><p id="afe5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们创建一个模式，<code class="fe nz oa ob oc b">BookSchema</code>，它将有一个类型为<code class="fe nz oa ob oc b">String</code>的属性<code class="fe nz oa ob oc b">name</code>。</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="e789" class="mz md it oc b gy ol om l on oo">const Schema = mongoose.Schema<br/>const BookSchema = new Schema({<br/>name : String<br/>})</span></pre><p id="befe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着通过这个<code class="fe nz oa ob oc b">BookSchema</code>定义的文档将有一个字段，这是一个类型为<code class="fe nz oa ob oc b">String</code>的<code class="fe nz oa ob oc b">name</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5eb5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义模型</h1><p id="b496" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用我们刚刚创建的<code class="fe nz oa ob oc b">BookSchema</code>，让我们创建模型<code class="fe nz oa ob oc b">Books</code>。</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="b824" class="mz md it oc b gy ol om l on oo">const Model = mongoose.model<br/>const Book = Model('Books',BookSchema)</span></pre><p id="cbc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nz oa ob oc b">mongoose.model</code>的第一个参数是我们集合的名称。第二个参数是模型将使用的模式。</p><p id="adf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们的集合的名称是<code class="fe nz oa ob oc b">Books</code>，它将使用<code class="fe nz oa ob oc b">BookSchema</code>的模式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e75a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建/插入文档</h1><p id="be96" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在已经完成了，让我们在数据库中创建一本书，名为<code class="fe nz oa ob oc b">NodeJS : A Guide</code>。</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="18d4" class="mz md it oc b gy ol om l on oo">const NodeJsGuide = new Book({name : 'NodeJS : A Guide' })</span></pre><p id="558a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">剩下的就是用<code class="fe nz oa ob oc b">book.save</code>保存了，像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="44cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是代码的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/c4527db72b5ac2e4a303d1cfaee1ffd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*MTsY6I531RKLNuJnWLvLew.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行save()时的代码输出</p></figure><p id="fcd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您也一直在使用MongoDB，请注意创建文档所需的代码相对较少。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f3e5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">查找/阅读文档</h1><h2 id="9c94" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">阅读所有文档</h2><p id="e106" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了读取所有文档，我们使用了<code class="fe nz oa ob oc b">model.find</code>方法，而没有指定查询。这给出了集合中所有可用文档的数组。</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="adc3" class="mz md it oc b gy ol om l on oo">model.find((err,document)=&gt; {<br/>console.log(document)<br/>})</span></pre><p id="cc62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的例子是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="a4ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是应用的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/12796199926e46073fb59d5a0a6dd950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*BwgjV6mQ66d84LFsFJ6YMg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">返回的文档数组</p></figure><h2 id="a94c" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">读取查询的文档</h2><p id="c249" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">然而，为了使用查询，我们在<code class="fe nz oa ob oc b">model.find</code>方法中指定了<code class="fe nz oa ob oc b">query</code>参数:</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="21be" class="mz md it oc b gy ol om l on oo">model.find(query,(err,document)=&gt; {<br/>console.log(document)<br/>})</span></pre><p id="348b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这个例子，我在数据库中添加了一本名为<code class="fe nz oa ob oc b">Ali &amp; Hussain: Best Friends</code>的书。让我们运行一个查询并输出结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/a023acf136b143811ca74f3df52120d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*mPnC0165DcPpqfitso-ykQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">查询后返回的结果。</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b40b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更新文档</h1><p id="fc4b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">更新文档的方法有多种，这里讨论<a class="ae ky" href="https://mongoosejs.com/docs/api.html#model_Model.updateOne" rel="noopener ugc nofollow" target="_blank">。最常见的是<code class="fe nz oa ob oc b">model.updateOne</code>。顾名思义，我们将更新匹配该查询的第一个文档。</a></p><p id="546e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法定义如下:</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="82a7" class="mz md it oc b gy ol om l on oo">model.updateOne(query,fieldsToUpdate,(err,result)=&gt;{<br/>//code<br/>})</span></pre><p id="487c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个回调中的<code class="fe nz oa ob oc b">result</code>属性将提供:</p><ul class=""><li id="2bf6" class="nl nm it lb b lc ld lf lg li od lm oe lq of lu nq nr ns nt bi translated">匹配此查询的文档数(<code class="fe nz oa ob oc b">n</code>)</li><li id="96d1" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">修改的文档数。(<code class="fe nz oa ob oc b">nModified</code>)</li><li id="e2aa" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">手术是否成功。(<code class="fe nz oa ob oc b">ok</code>)</li></ul><p id="2df4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，让我们将名为<code class="fe nz oa ob oc b">Ali &amp; Hussain: Best Friends</code>的书更新为<code class="fe nz oa ob oc b">Maarij And Hussain: Best Friends</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="8ed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/ad3b8e7bc88f8da2c773c2423100d675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*I0qoBA-ib8jSsWq7cdWnaQ.png"/></div></figure><p id="b747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，让我们使用<code class="fe nz oa ob oc b">find</code>方法来遍历我们的文档。这是输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/f2817ae24116cf692d429d31c9c978c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*0nU7wqihEdPzULp5VHLukA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行find()方法时的输出</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cc7e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">删除文档</h1><p id="bbf3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">要删除文档，我们将使用<code class="fe nz oa ob oc b">model.deleteOne</code>或<code class="fe nz oa ob oc b">model.deleteMany</code>。两者具有相似的参数。</p><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="4689" class="mz md it oc b gy ol om l on oo">model.deleteOne(query,(err,result)=&gt;{<br/>//code<br/>})</span></pre><p id="6414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回调中的<code class="fe nz oa ob oc b">result</code>参数为我们提供了一个对象，它告诉我们:</p><ul class=""><li id="4b11" class="nl nm it lb b lc ld lf lg li od lm oe lq of lu nq nr ns nt bi translated">删除了多少文档，(<code class="fe nz oa ob oc b">deletedCount</code>)</li><li id="396b" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">有多少文档与查询匹配，(<code class="fe nz oa ob oc b">n</code>)</li><li id="71cc" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated">以及操作是否成功(<code class="fe nz oa ob oc b">ok</code>)</li></ul><p id="ddc6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将删除一个匹配名称<code class="fe nz oa ob oc b">NodeJS : A Guide</code>的文档。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="b00f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做的结果将如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/5629f82b06f86c22634b78c0b56b47a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*QJWGxn6ISC8G-FRYuC7f9A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">updateOne运行时的输出</p></figure><p id="f874" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nz oa ob oc b">find</code>方法迭代结果，最终得到以下结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/0e8275e23d78d3f3aca41e5dc0c2aea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*7CtjWB6IvmjX5qxnxEpkWQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行find()时的输出</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c8b3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">自定义模式方法</h1><p id="e597" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些方法被附加到模式中。它们的类型有:</p><h2 id="9e37" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">实例方法</h2><p id="83fe" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从各自的模式派生的文档可以使用这些方法。</p><p id="6bd5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个例子，让我们更新我们的<code class="fe nz oa ob oc b">BookSchema</code>来创建一个为我们提供书名和作者的方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="e752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是代码的输出:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/48ad993a91fc27e28c75a501d416a429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*u2gnZZ_ntMrlEzt6qNIQ1A.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行上述代码时的输出。</p></figure><p id="0a00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="os">记住:为了在函数中保留Mongoose的</em> <code class="fe nz oa ob oc b"><em class="os">this</em></code> <em class="os">的含义，您需要为静态函数使用普通的函数声明，而不是使用arrow语法。</em></p><h2 id="7d72" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">静态方法</h2><p id="539b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">每当我们没有特定的对象或者我们不需要它的时候，就会用到这些。从它们各自的模式中派生出来的模型可以使用这些方法。</p><p id="b0ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，让我们创建一个函数，通过查询书名在数据库中搜索书籍。这里，我们假设书已经被保存了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="ab35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/330f30e43662e7c94e106f0bf813c316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*uOq3fC2un26tttqeJqVA3g.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码运行时的输出。</p></figure><h2 id="837f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">钩住</h2><p id="dc16" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些也称为中间件功能。它们是在异步函数执行时被传递控制的函数。</p><p id="cb93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些常见的中间件功能包括:</p><ul class=""><li id="63db" class="nl nm it lb b lc ld lf lg li od lm oe lq of lu nq nr ns nt bi translated"><code class="fe nz oa ob oc b"><a class="ae ky" href="https://mongoosejs.com/docs/api/document.html#document_Document-validate" rel="noopener ugc nofollow" target="_blank">validate</a></code></li><li id="8f2a" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe nz oa ob oc b"><a class="ae ky" href="https://mongoosejs.com/docs/api/model.html#model_Model-save" rel="noopener ugc nofollow" target="_blank">save</a></code></li><li id="43b1" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe nz oa ob oc b"><a class="ae ky" href="https://mongoosejs.com/docs/api/model.html#model_Model-remove" rel="noopener ugc nofollow" target="_blank">remove</a></code></li><li id="c7dc" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe nz oa ob oc b"><a class="ae ky" href="https://mongoosejs.com/docs/api/document.html#document_Document-updateOne" rel="noopener ugc nofollow" target="_blank">updateOne</a></code></li><li id="2a57" class="nl nm it lb b lc nu lf nv li nw lm nx lq ny lu nq nr ns nt bi translated"><code class="fe nz oa ob oc b"><a class="ae ky" href="https://mongoosejs.com/docs/api/model.html#model_Model-deleteOne" rel="noopener ugc nofollow" target="_blank">deleteOne</a></code></li></ul><p id="d9aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们将使用<strong class="lb iu"> </strong>一个<strong class="lb iu">预挂钩</strong>函数——即它将在函数执行之前执行。在这里，我们将检查是否存在同名的图书—如果存在，将不会保存该图书。假设名为<code class="fe nz oa ob oc b">Maarij And Ali: Best Friends</code>的书已经被保存，我们将再次保存它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="8010" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用中间件功能的完整列表可以在<a class="ae ky" href="https://mongoosejs.com/docs/middleware.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="c09f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/fc9fd03640bad6ca13386465417be202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*llLxRR93FbCrGZAAWev_zw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">代码运行时的输出</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3855" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">虚拟字段</h1><p id="0fd8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这些属性不需要存储在数据库中。它们通常用于文档中的计算属性。例如，您不需要数据库中的<code class="fe nz oa ob oc b">full name</code>字段——您可以将数据库中的<code class="fe nz oa ob oc b">lastname</code>和<code class="fe nz oa ob oc b">first name</code>组合起来。</p><p id="db52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟字段有<code class="fe nz oa ob oc b">get</code>和<code class="fe nz oa ob oc b">set</code>方法。</p><p id="2449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们将连接<code class="fe nz oa ob oc b">author</code>字段和<code class="fe nz oa ob oc b">name</code>字段，然后使用<code class="fe nz oa ob oc b">get</code>方法返回它们。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="op oq l"/></div></figure><p id="251b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码的输出如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/ff5d73d47c33e0235b5896bd138719d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*Gb5j6lhETC-RELRO1ISXEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">虚拟字段的输出-示例</p></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="37a3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">外部资源和阅读</h1><p id="e363" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我只是触及了MongooseJS的皮毛。最好你多读读这个API。以下是可用的最佳资源:</p><div class="pd pe gp gr pf pg"><a href="https://code.tutsplus.com/articles/an-introduction-to-mongoose-for-mongodb-and-nodejs--cms-29527" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">Mongoose for MongoDB和Node.js简介</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">Mongoose是一个JavaScript框架，通常用在带有MongoDB数据库的Node.js应用程序中。在这个…</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">code.tutsplus.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div><div class="pd pe gp gr pf pg"><a href="https://mongoosejs.com/docs/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">mongose v 5 . 9 . 11:入门</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">首先确保您已经安装了MongoDB和Node.js。接下来从命令行使用npm: $ npm安装Mongoose</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">mongoosejs.com</p></div></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pv oq l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f25f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概述</h1><h2 id="2bec" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">发现</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="ac52" class="mz md it oc b gy ol om l on oo">model.find(query?,(err,document)=&gt; {<br/>//code<br/>})</span></pre><h2 id="1122" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">创造</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="b34a" class="mz md it oc b gy ol om l on oo">document.save((err,document)=&gt;{<br/>//code<br/>})</span></pre><h2 id="ff8f" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">更新</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="5e25" class="mz md it oc b gy ol om l on oo">model.updateOne(query,fieldsToUpdate,(err,result)=&gt;{<br/>//code<br/>})</span></pre><h2 id="37e4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">删除</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="957e" class="mz md it oc b gy ol om l on oo">model.deleteOne(query,(err,result)=&gt;{<br/>//code<br/>})</span></pre><h2 id="3bce" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">实例方法</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="476f" class="mz md it oc b gy ol om l on oo">schema.methods.functionName = function() {<br/>//code<br/>})<br/>document.functionName()</span></pre><h2 id="45f3" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">静力学方法</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="e4fe" class="mz md it oc b gy ol om l on oo">schema.statics.functionName = function() {<br/>//code<br/>})<br/>model.functionName()</span></pre><h2 id="83a4" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">预挂钩功能</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="1d0f" class="mz md it oc b gy ol om l on oo">schema.pre('functionName' , function() {<br/>//code<br/>})<br/>document.functionName()</span></pre><h2 id="c355" class="mz md it bd me na nb dn mi nc nd dp mm li ne nf mo lm ng nh mq lq ni nj ms nk bi translated">虚拟字段</h2><pre class="kj kk kl km gt oh oc oi oj aw ok bi"><span id="76f3" class="mz md it oc b gy ol om l on oo">schema.virtual('fieldName')<br/>       .get() {<br/>        //code<br/>     }.set(value){<br/>       //code<br/>     })<br/>document.fieldName = 'value'<br/>document.fieldName; //returns value</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="ab28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://medium.com/better-programming/simple-notes-app-with-node-js-and-mongoosejs-6595cd5d15b" rel="noopener">下一个教程</a>中，我们会用到所有关于Mongoose和上一个Node的知识。Js教程来构建一个简单的Notes应用程序。</p><p id="9a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，猫鼬似乎是一个棘手的话题。然而，如果您尝试本文中的示例，就很容易理解。记住，你只能在实践中学习，不要放弃！</p><p id="0ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢你坚持到最后。祝你愉快。希望你学到了很多！</p></div></div>    
</body>
</html>