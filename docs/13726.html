<html>
<head>
<title>Image Processing With Python and Pillow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和Pillow进行图像处理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/image-processing-with-python-and-pillow-1394de194ae8?source=collection_archive---------10-----------------------#2022-09-20">https://betterprogramming.pub/image-processing-with-python-and-pillow-1394de194ae8?source=collection_archive---------10-----------------------#2022-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6417" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解如何使用Python和Pillow库处理和转换图像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2efc88f9f1a5f52350df774255015be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n364RHCzp3r_i88pBZeTrg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="7613" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">图像处理和计算机视觉是我有空的时候经常会去做的事情。即使我做了一些人工智能和图像处理的工作，我仍然做了很多“手动”图像处理，以更好地理解我们可以用来让计算机从图像中收集信息的技术。</p><p id="dd92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">毕竟，图像处理是我最初开始写博客的原因，当时我的第一篇文章是“<a class="ae lu" href="https://livecodestream.dev/post/finding-lanes-without-deep-learning/" rel="noopener ugc nofollow" target="_blank">寻找没有深度学习的道路</a>”</p><p id="5f72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些都是有趣的话题(至少对我来说)。尽管如此，我从未真正写过图像操作的其他方面，比如触摸、调整大小、裁剪以及对图像的各种操作。更有甚者，完全用Python生成图像是一个有许多实际应用的奇妙想法，例如，为博客文章生成缩略图或构建一个像<a class="ae lu" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> Canva </a>这样的服务。</p><p id="a5c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用Python可以使用多个库进行图像处理，但是今天我们将使用<a class="ae lu" href="https://pillow.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Pillow </a>进行处理，因为它简单并且专注于我们想要执行的任务。</p><h1 id="3ca2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">安装和项目设置</h1><p id="0ba9" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">将Pillow作为项目的一部分进行安装就像安装Python包一样简单。您需要运行以下命令:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="8335" class="mx lw it mt b gy my mz l na nb">python3 -m pip install --upgrade Pillow</span></pre><p id="464e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们的项目，我们将在<a class="ae lu" href="https://colab.research.google.com/" rel="noopener ugc nofollow" target="_blank"> Google Colab </a>上运行<a class="ae lu" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中的所有命令。你可以在你自己的笔记本上跟随，或者我在这里提供完整的代码。</p><p id="57d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为我们将在Google Colab中安装依赖项，所以我们需要运行:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="f8ce" class="mx lw it mt b gy my mz l na nb">!python3 -m pip install --upgrade Pillow</span></pre><p id="0cdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，在我们进入代码之前，我们需要一个样例图像来工作。我选择了这张照片，但你可以使用其他任何照片。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/665226bcad89dfbe3da50ee21f0b59e0.png" data-original-src="https://miro.medium.com/v2/format:webp/1*wkfQrM6h6AR3xI0QVUTqow.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">一个孩子在水中戏水的图像，这正是我的孩子喜欢做的。| <a class="ae lu" href="https://unsplash.com/@jwwhitt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">乔丹·惠特</a>上<a class="ae lu" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">下</a></p></figure><p id="84ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于我们将在整个教程中使用这个图像，我们将在Google Colab上存储一个副本。即使从网络上加载图像是可能且容易的，我们也将从系统中加载，在本例中，从Google Colab环境中加载。</p><p id="a9cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">必须考虑到，当环境被破坏时，所有上传到Google Colab的文件都将被删除。为此，我们将直接在笔记本中上传图像。这样，当我们运行代码时，我们可以提供我们想要处理的图像，并且当我们需要它时，它总是可用的。</p><p id="8352" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了将图像加载到Google Colab中，我们将插入以下代码:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="910b" class="mx lw it mt b gy my mz l na nb">from google.colab import files<br/>uploaded = files.upload()</span><span id="b7f4" class="mx lw it mt b gy nd mz l na nb">original_image_name = ''<br/>if len(uploaded.keys()) &gt; 0:<br/> original_image_name = next(iter(uploaded.keys()))<br/> print('We will be working with the image: {}'.format(original_image_name))<br/>else:<br/> raise ValueError('Please upload an image to continue')</span></pre><p id="3e5d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ne nf ng mt b">google.colab</code>库抽象了上传文件的所有逻辑。我们只需要考虑用户是否有效地上传了文件。如果没有，则引发一个错误或警告用户，因为将无法继续执行剩余的代码。</p><h1 id="fb08" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">图像对象</h1><p id="67e8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">舞台中央是代表PIL形象的<code class="fe ne nf ng mt b">Image</code>类。对图像的所有操作都将从图像对象开始。有多种方法可以将图像加载到对象实例中。其中一些是:从文件中加载图像，作为操作的结果创建新图像，等等。</p><p id="85e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了从文件中加载图像，我们使用了<code class="fe ne nf ng mt b">Image</code>模块中的<code class="fe ne nf ng mt b">open()</code>方法，将图像路径传递给它，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="10c6" class="mx lw it mt b gy my mz l na nb">from PIL import Image</span><span id="ef70" class="mx lw it mt b gy nd mz l na nb">original_image = Image.open(original_image_name)</span></pre><p id="5773" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要查看加载的图像，我们可以用下面的代码行在单元格中显示它:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0faf" class="mx lw it mt b gy my mz l na nb">display(original_image)</span></pre><blockquote class="nh ni nj"><p id="558c" class="ky kz nk la b lb lc ju ld le lf jx lg nl li lj lk nm lm ln lo nn lq lr ls lt im bi translated">请注意，如果您不在笔记本环境中，您可能希望使用<a class="ae lu" href="https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.show" rel="noopener ugc nofollow" target="_blank"> Image.show() </a>来代替:</p></blockquote><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3c62" class="mx lw it mt b gy my mz l na nb">original_image.show()</span></pre><p id="2977" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这并不是<code class="fe ne nf ng mt b">Image</code>物体包含的全部信息。此外，您还可以获得关于图像的一些信息，如:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="55b4" class="mx lw it mt b gy my mz l na nb"># Output the file format<br/>print(original_image.format)<br/> <br/># Output the pixel format, e.g. RGB<br/>print(original_image.mode)<br/> <br/># Image size<br/>print(original_image.size)<br/> <br/># Output the color palette, if any<br/>print(original_image.palette)<br/> <br/># A dictionary with data associated with the image<br/>print(original_image.info)</span></pre><p id="f461" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于我们的图像，我们得到以下输出:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="5c5a" class="mx lw it mt b gy my mz l na nb">JPEG<br/>RGB<br/>(1920, 1282)<br/>None<br/>{'jfif': 257, 'jfif_version': (1, 1), 'dpi': (72, 72), 'jfif_unit': 1, 'jfif_density': (72, 72), 'progressive': 1, 'progression': 1, 'icc_profile': b'\x00\x00\x02\ ... \xff\xff'}</span></pre><p id="e256" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以对图像对象做更多的事情，并在官方文档<a class="ae lu" href="https://pillow.readthedocs.io/en/stable/reference/Image.html" rel="noopener ugc nofollow" target="_blank">中了解更多。</a></p><p id="5f2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们已经加载了图像，我们可以开始对它进行修改了。</p><h1 id="bc4c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">调整图像大小</h1><p id="1d31" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当讨论图像操作时，最常见的是用Python调整图像大小。我在博客上多次遇到这个问题，在Stack Overflow上也到处都是，但它是一个带枕头的一行程序。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="180a" class="mx lw it mt b gy my mz l na nb">resized_image = original_image.resize((240, 160))<br/>display(resized_image)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/cb0ae0064a3c64e5e6cef57e41912bec.png" data-original-src="https://miro.medium.com/v2/format:webp/1*5aS5th7pGgPNqBiKNG0Rug.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">240x160的结果图像</p></figure><p id="bea1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的示例中，我们故意调整了图像的大小，保持了纵横比，但这并不是必需的，如下例所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3a3b" class="mx lw it mt b gy my mz l na nb">square_image = original_image.resize((240, 240))<br/>display(square_image)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/468aa239b9e9335f28b052aba7238ff2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*FCMdoM4BzhZsEfMc5AITEQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">240x240的结果图像</p></figure><p id="40b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本例中，生成的图像是一个240x240的正方形，并且图像的纵横比发生了变化。因此，图像看起来有点奇怪。</p><p id="249d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，如果我们想要在保持纵横比的同时调整图像的大小，而不需要手动计算新的宽度和高度，该怎么办呢？<code class="fe ne nf ng mt b">thumbnail()</code>方法已经覆盖了你。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="da10" class="mx lw it mt b gy my mz l na nb">thumbnail_image = original_image.copy()<br/>thumbnail_image.thumbnail((240, 240))<br/>display(thumbnail_image)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/cb0ae0064a3c64e5e6cef57e41912bec.png" data-original-src="https://miro.medium.com/v2/format:webp/1*5aS5th7pGgPNqBiKNG0Rug.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">240x160的结果图像</p></figure><p id="2eaf" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">方法<code class="fe ne nf ng mt b">thumbnail()</code>的工作方式与方法<code class="fe ne nf ng mt b">resize</code>不同，因为第一个方法会修改对象，而不是返回图像的新实例。出于这个原因，我们通过制作原始图像的副本，然后调用<code class="fe ne nf ng mt b">thumbnail()</code>方法来启动代码示例。</p><p id="999e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">该方法将生成原始图像的缩略图，具有相同的纵横比，宽度和高度不超过给定的大小。</p><h1 id="01a8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">种植</h1><p id="c37d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">方法<code class="fe ne nf ng mt b">crop()</code>从源图像中返回一个矩形区域。矩形或方框是一个四元组，分别表示左、上、右和下坐标。</p><p id="286e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="541f" class="mx lw it mt b gy my mz l na nb">box = (<br/>   720, # left<br/>   600, # top<br/>   1300, # right<br/>   980 # bottom<br/>)<br/>cropped_image = original_image.crop(box)<br/>display(cropped_image)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/5209d6676f2862ad97897081e080f358.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Uq87WahUufp4yZZPLAT_FA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">仅显示脚的裁剪图像</p></figure><p id="9f9f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果图像包含原始图像的一小部分，只显示了孩子的鞋子。</p><h1 id="4bfd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">堆叠图像</h1><p id="486d" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">通过堆叠图像，我们的意思是将一个图像插入到另一个中，或者将一个图像插入到另一个中。用Pillow做这个很容易，但是你至少需要两张图片来展示它。</p><p id="74dc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在下一个例子中，我们将把我们的原始图像和裁剪后的版本(只是脚)粘贴到右下角。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="3282" class="mx lw it mt b gy my mz l na nb">stacked_image = original_image.copy()<br/> <br/>position = (stacked_image.width - cropped_image.width, stacked_image.height - cropped_image.height)<br/>stacked_image.paste(cropped_image, position)<br/>display(stacked_image)</span></pre><p id="7134" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数<code class="fe ne nf ng mt b">paste()</code>改变了图像对象，而不是返回一个新的实例，所以我们首先复制原始图像，计算裁剪图像的位置，并将其粘贴到堆叠图像中。</p><p id="d619" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/400aaadc5b4e75dd9ed785062ec04f19.png" data-original-src="https://miro.medium.com/v2/format:webp/1*trgqrPM8rEZrUD2cW8f5lw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始图像，裁剪后的图像堆叠在右下角</p></figure><p id="7eca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">很酷，对吧？</p><h1 id="8cd6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">旋转图像</h1><p id="9d12" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Pillow还提供了<code class="fe ne nf ng mt b">rotate()</code>功能来旋转图像。该方法采用一个表示旋转度数的数值参数。此方法返回图像的新副本，而不改变原始副本。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0eb7" class="mx lw it mt b gy my mz l na nb">rotated_image = original_image.rotate(90)<br/>display(rotated_image)</span></pre><p id="364d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是生成的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/c3c2fd38b23834e30923691d362879d4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*F0uoSNGSBJajaJFG9JhNPw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旋转90度的图像</p></figure><p id="ccb9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，默认情况下，旋转后的图像保持原始图像的尺寸。由于图像在原始帧中旋转，这可能会导致您看到黑色边框和图像被裁剪的情况。</p><p id="4b62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想改变这种行为，您可以使用参数<code class="fe ne nf ng mt b">expand</code>设置为<code class="fe ne nf ng mt b">True</code>，如下所示:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="bdfb" class="mx lw it mt b gy my mz l na nb">rotated_expanded_image = original_image.rotate(90, expand=True)<br/>display(rotated_expanded_image)</span></pre><p id="d3f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的图像如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/39156bed24e9505dcc6da881a056cfe2.png" data-original-src="https://miro.medium.com/v2/format:webp/1*BweC8so6VfLGhVUjmg2K_Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">旋转并扩展图像以适合</p></figure><h1 id="1587" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">调换图像</h1><p id="bd92" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">与旋转类似，Pillow允许您使用<code class="fe ne nf ng mt b">transpose()</code>方法转置图像。同样需要一个参数来表示您想要应用的移调类型。以下是可能的常数值:</p><ul class=""><li id="17d9" class="no np it la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><code class="fe ne nf ng mt b">PIL.Image.Transpose.FLIP_LEFT_RIGHT</code></li><li id="b563" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe ne nf ng mt b">PIL.Image.Transpose.FLIP_TOP_BOTTOM</code></li><li id="740e" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe ne nf ng mt b">PIL.Image.Transpose.ROTATE_90</code></li><li id="2328" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe ne nf ng mt b">PIL.Image.Transpose.ROTATE_180</code></li><li id="1d2f" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe ne nf ng mt b">PIL.Image.Transpose.ROTATE_270</code></li><li id="f436" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe ne nf ng mt b">PIL.Image.Transpose.TRANSPOSE</code></li><li id="62d0" class="no np it la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><code class="fe ne nf ng mt b">PIL.Image.Transpose.TRANSVERSE</code></li></ul><p id="6d3f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用transpose，您可以翻转或旋转图像。然而，旋转角度已经预先定义，所以如果你想使用不同的角度，建议使用我们上面提到的<code class="fe ne nf ng mt b">rotate()</code>功能。</p><p id="a1eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此方法返回图像的新副本，而不改变原始副本。</p><p id="c494" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一些例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="9047" class="mx lw it mt b gy my mz l na nb">flipped_lr_image = original_image.transpose(Image.FLIP_LEFT_RIGHT)<br/>display(flipped_lr_image)</span></pre><p id="df03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的图像是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/0d4dbe98e811c4403b392488572f8b32.png" data-original-src="https://miro.medium.com/v2/format:webp/1*sAl37DaqYVXdMlVXI3hf2Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像在Y轴上翻转</p></figure><p id="dc08" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一个例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="0930" class="mx lw it mt b gy my mz l na nb">flipped_lr_image = original_image.transpose(Image.FLIP_TOP_BOTTOM)<br/>display(flipped_lr_image)</span></pre><p id="f851" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的图像是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/af4403601bd6224302f0734ca4ac90da.png" data-original-src="https://miro.medium.com/v2/format:webp/1*ccbdyaAtOlbbB4by5sx-8Q.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像在X轴上翻转</p></figure><h1 id="b5fa" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在图像上绘图</h1><p id="54fa" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">Pillow提供了转换图像的方法，您还可以使用<a class="ae lu" href="https://pillow.readthedocs.io/en/stable/reference/ImageDraw.html" rel="noopener ugc nofollow" target="_blank"> ImageDraw </a>模块在图像上绘图。</p><p id="08f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">模块允许你绘制线条、矩形、弧线、任何其他类型的不规则形状、文本、多行文本等等。</p><p id="0ddd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个加载图像并在上面随意绘制一些东西的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="5fe4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的图像是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/796d0b2663d4d0d78058dfa3667362a8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*GfeuovHh32lqLVmHPvNsgw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">原始图像有一个正方形、一条线和一些文本，上面写着“Hello world！”</p></figure><h1 id="50af" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">颜色转换</h1><p id="7897" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在其他文章中，如<a class="ae lu" href="/post/finding-lanes-without-deep-learning/" rel="noopener ugc nofollow" target="_blank">在没有深度学习的情况下找到车道</a>，我们讨论了在不同颜色空间中工作以及对图像应用颜色转换以执行计算和区分模式的重要性。</p><p id="7510" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了切换图像颜色模式，我们使用函数<code class="fe ne nf ng mt b">convert()</code>，它需要一个带有颜色模式的参数。对于灰度，我们使用一个相当具体的参数<code class="fe ne nf ng mt b">L</code>，代表<code class="fe ne nf ng mt b">luminance</code>。您也可以应用<code class="fe ne nf ng mt b">RGB</code>或<code class="fe ne nf ng mt b">CMYK</code>模式。</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="d402" class="mx lw it mt b gy my mz l na nb">grayscale_image = original_image.convert('L')<br/>display(grayscale_image)</span></pre><p id="b2b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是生成的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/b07088f63490c1f990509fb493412251.png" data-original-src="https://miro.medium.com/v2/format:webp/1*X9mvBZipkmYwSnNEs351Zw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像的灰度版本</p></figure><h1 id="0207" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">模糊图像</h1><p id="3f93" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">枕头有一个强大的过滤系统，其中我们有多个选项来模糊图像。</p><p id="5ff8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们来看一个使用高斯模糊滤镜的例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="13c5" class="mx lw it mt b gy my mz l na nb">from PIL import ImageFilter<br/> <br/>blurred_image = original_image.filter(filter=ImageFilter.GaussianBlur(20))<br/>display(blurred_image)</span></pre><p id="6798" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">生成的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="ab gu cl nc"><img src="../Images/79e3b7ca51b83aadf94211daa86592eb.png" data-original-src="https://miro.medium.com/v2/format:webp/1*xHA-ceNp_51Cd6FkTRU7cQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用高斯滤波器的模糊图像</p></figure><p id="1678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">检查<a class="ae lu" href="https://pillow.readthedocs.io/en/stable/reference/ImageFilter.html#module-PIL.ImageFilter" rel="noopener ugc nofollow" target="_blank">图像滤镜模块</a>以了解更多关于滤镜和不同模糊模式的信息。</p><h1 id="e410" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">保存图像</h1><p id="ac2c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">我们今天讨论的最后一个方法是<code class="fe ne nf ng mt b">save()</code>方法，它允许您将图像对象保存到文件中。</p><p id="6e03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这很简单，让我们看一个例子:</p><pre class="kj kk kl km gt ms mt mu mv aw mw bi"><span id="e2cb" class="mx lw it mt b gy my mz l na nb">blurred_image.save('blurred_image.png') # save as PNG<br/> <br/>blurred_image.save('blurred_image.jpg') # save as JPG</span></pre><p id="62cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的例子将保存两个图像到磁盘，一个PNG和一个JPG副本。如果您正在使用Google Colab，您会在<code class="fe ne nf ng mt b">content</code>文件夹中找到这些图像。如果您正在使用本地文件，您将在当前目录中找到它们。</p><h1 id="cfa2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="d443" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">本文介绍了使用Python和Pillow库的一些常见图像处理操作。</p><p id="55f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管我们进行了多次手术，并获得了许多乐趣，但我们还没有触及枕头提供的许多选项的表面。</p><p id="33ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对图像处理感兴趣，我强烈推荐查看<a class="ae lu" href="https://pillow.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> Pillow的官方文档</a>。</p><p id="76fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>