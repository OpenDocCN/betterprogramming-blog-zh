<html>
<head>
<title>How to Test Ethereum Smart Contracts for Access Restriction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试以太坊智能合约的访问限制</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-test-ethereum-smart-contracts-for-access-restriction-9dff445400d0?source=collection_archive---------10-----------------------#2020-06-09">https://betterprogramming.pub/how-to-test-ethereum-smart-contracts-for-access-restriction-9dff445400d0?source=collection_archive---------10-----------------------#2020-06-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4b0e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写可靠性测试，以确保对功能的访问受到正确的限制</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3547358e7fbdadfbeb19821798467f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9Z_-y5PxXKiwmi7xNupnQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@kelli_mcclintock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·麦克林托克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/restricted?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d25b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">先决条件:这篇文章假设你对Solidity和以太坊智能合约有所了解。</em></p><p id="0165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制对智能合同的访问对于确保安全性至关重要。常见的模式，如<a class="ae ky" href="https://openzeppelin.com/" rel="noopener ugc nofollow" target="_blank"> OpenZeppelin的</a> <code class="fe lw lx ly lz b">Ownable</code>和<code class="fe lw lx ly lz b">AccessControl</code>契约，使开发人员能够轻松实现各种级别的功能访问。</p><p id="7639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些库是很棒的，因为它们是由一个大型开发人员社区审核和审查的，从而最小化了风险，最大化了它们的效用。但是你怎么知道你正在正确地使用它们呢？</p><p id="f54f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都会犯错，即使是最优秀的人。如果您在函数中遗漏了一个<code class="fe lw lx ly lz b">onlyOwner</code>声明，该怎么办？如果没有测试，您可能会部署带有巨大漏洞的代码。</p><p id="570c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何确保函数被正确地限制？</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="1269" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">使用可靠性测试“仅所有者”访问</h1><p id="7588" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">假设我们有一个名为<code class="fe lw lx ly lz b">ExampleContract</code>的契约，它实现了OpenZeppelin的<code class="fe lw lx ly lz b"><a class="ae ky" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol" rel="noopener ugc nofollow" target="_blank">Ownable</a></code>契约。它有许多功能，其中一些可以由任何地址调用，一些只能由契约的所有者执行。这就是使用<code class="fe lw lx ly lz b">Ownable</code>中的<code class="fe lw lx ly lz b">onlyOwner</code>修改器的地方:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="72b5" class="ni mi it lz b gy nj nk l nl nm">function somethingSomethingTheOwnerCanDo() public onlyOwner {<br/>    ...<br/>}</span></pre><p id="046c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们的合同有很多功能，很容易漏掉一个简单的修饰符。因此，我们需要为代码中每一条成功的路径和每一条不成功的路径编写测试。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="8e66" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">松露套房</h1><p id="ff93" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">Truffle套件允许我们用JavaScript和Solidity编写测试。使用JavaScript测试来测试<code class="fe lw lx ly lz b">onlyOwner</code>修饰符的存在是很容易的，因为可以将多个帐户注入到测试运行程序中。从错误的帐户发送邮件，您将获得回复。</p><p id="590e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在可靠性测试中，这更加困难，因为所有的测试都是从一个地址运行的:测试合同。那么我们如何在可靠性测试中模仿这一点呢？</p><h2 id="c402" class="ni mi it bd mj nn no dn mn np nq dp mr li nr ns mt lm nt nu mv lq nv nw mx nx bi translated"><strong class="ak">答案:通过使用代理合同</strong></h2><p id="7e81" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">使用我们的<code class="fe lw lx ly lz b">somethingSomethingTheOwnerCanDo()</code>函数作为我们测试的目标，我们需要一个测试来确保如果不是所有者的其他人调用它，它会恢复。</p><p id="020a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从创建<code class="fe lw lx ly lz b">ProxyContract</code>开始，它发出我们预计会失败的调用，因为它不是所有者。</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="e450" class="ni mi it lz b gy nj nk l nl nm">pragma solidity ^0.6.7;</span><span id="12ed" class="ni mi it lz b gy ny nk l nl nm">import "./ExampleContract.sol"</span><span id="7ffa" class="ni mi it lz b gy ny nk l nl nm">contract ProxyContract {<br/>  function attemptNonOwnerCall(ExampleContract _contract) public {<br/>    _contract.somethingSomethingTheOwnerCanDo();<br/>  }<br/>}</span></pre><p id="32e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的测试中，我们需要初始化这个<code class="fe lw lx ly lz b">ProxyContract</code>,并使用被测试的<code class="fe lw lx ly lz b">ExampleContract</code>的实例作为参数来调用<code class="fe lw lx ly lz b">attemptNonOwnerCall</code>。这个测试需要断言调用将失败。我们可以用<code class="fe lw lx ly lz b">try</code> - <code class="fe lw lx ly lz b">catch</code>来做。这是我们的测试:</p><pre class="kj kk kl km gt ne lz nf ng aw nh bi"><span id="d697" class="ni mi it lz b gy nj nk l nl nm">function testNonOwnerFails() public {<br/>    ExampleContract testTarget = new ExampleContract();<br/>    ProxyContract proxy = new ProxyContract();<br/>    string expectedReason = "Owner: caller is not the owner";<br/>    try proxy.attemptNonOwnerCall(testTarget) {<br/>        revert("It should fail");<br/>    } catch Error(string memory reason) {<br/>        Assert.equal(reason, expectedReason, "It should fail");<br/>    }<br/>}</span></pre><p id="65c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一行一行地看一下:</p><ul class=""><li id="533c" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated"><code class="fe lw lx ly lz b">testTarget</code>是我们正在测试的合同，具有受限功能</li><li id="1ddd" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">我们创建一个新的<code class="fe lw lx ly lz b">proxy</code>合同</li><li id="ccbf" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated"><code class="fe lw lx ly lz b">expectedReason</code>是当调用违反<code class="fe lw lx ly lz b">onlyOwner</code>修饰符时<code class="fe lw lx ly lz b">Ownable</code>返回的消息</li><li id="4fd9" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">我们试图通过我们的<code class="fe lw lx ly lz b">proxy</code>调用受限函数，他不是所有者，所以我们期望捕捉到一个错误</li><li id="357c" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果没有错误，<code class="fe lw lx ly lz b">revert</code>命令在<code class="fe lw lx ly lz b">try</code>块中运行，导致我们的测试失败</li><li id="4a3b" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">如果有错误，就调用<code class="fe lw lx ly lz b">catch</code>块，我们断言这就是我们预期的错误:<code class="fe lw lx ly lz b">expectedReason</code></li></ul><p id="f5d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只起作用，因为<code class="fe lw lx ly lz b">ExampleContract</code>的所有者是我们的测试契约(初始化<code class="fe lw lx ly lz b">ExampleContract</code>的契约)，调用<code class="fe lw lx ly lz b">somethingSomethingTheOwnerCanDo()</code>的<code class="fe lw lx ly lz b">msg.sender</code>是<code class="fe lw lx ly lz b">ProxyContract</code>，它有不同的地址。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="a8d8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">结论</h1><p id="1b6a" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">很容易假设，因为我们使用经过良好测试的库，所以我们的代码是安全的。虽然这是一个公平的假设，但知道你是否正确使用它们的唯一方法是彻底测试每个功能，并确保你对它们的期望与现实相符。</p></div></div>    
</body>
</html>