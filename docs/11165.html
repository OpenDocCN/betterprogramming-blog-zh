<html>
<head>
<title>How to Use Custom Authorizer in AWS API Gateway With Serverless</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在AWS API网关中使用无服务器的自定义授权器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-custom-authorizer-in-aws-api-gateway-with-serverless-4ddf42f32390?source=collection_archive---------5-----------------------#2022-02-23">https://betterprogramming.pub/how-to-use-custom-authorizer-in-aws-api-gateway-with-serverless-4ddf42f32390?source=collection_archive---------5-----------------------#2022-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f90" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">自定义授权器和无服务器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/48fd24ed592077efdd5d56b8aadaf871.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5K50di-vqPNUxsbr"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://unsplash.com/@adigold1" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/@adigold1</a></p></figure><h1 id="c4af" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="fca7" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本教程中，我们将回顾如何设置两个<em class="mn">相似的</em>API。我们将在无服务器的帮助下，比较AWS中使用REST API和HTTP API的异同。每个解决方案都有自己的优点和缺点。</p><p id="4bfa" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">要开始本教程，您必须至少熟悉基本的Javascript编程，安装了VS代码(或您喜欢的任何IDE)，熟悉命令提示符，安装了<code class="fe mt mu mv mw b">npm</code>和<code class="fe mt mu mv mw b">aws-cli</code>，最重要的是拥有配置了凭证的AWS帐户。如果你正在读这篇文章，那么我认为你已经具备了所有的先决条件。</p><p id="a551" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">首先，让我们快速回顾一下AWS及其令人困惑的<em class="mn">命名约定。</em></p><p id="bce4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">AWS  —显然代表亚马逊网络服务。为了遵循本教程，你必须至少有一些基本的AWS知识或兴趣来学习一些新的东西。</p><p id="b6e6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> API </strong> —应用编程接口。连接计算机程序并允许数据交换的软件。很快我们将意识到API缩略词几乎无处不在:</p><p id="9bb9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> API网关</strong> —顾名思义，是我们API的网关。登录AWS帐户后，我们可以导航到API Gateway，以便检查或手动配置不同的API。</p><p id="b279" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> REST API </strong>又名<strong class="lt iu">API Gateway v1</strong>——当今最常见的API类型。</p><p id="2393" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> HTTP API </strong>又名<strong class="lt iu">API Gateway v2</strong>——我们刚刚说了一些令人困惑的命名约定吗？现在开始。HTTP API也是REST API！但是，AWS决定命名HTTP API (v2)，以区别于REST API (v1)。此外，HTTP代表超文本传输协议，REST API (v1)和HTTP API (v2)都可以使用。因此，我们将使用HTTP <em class="mn">协议</em>向REST API (v1)和HTTP API (v2)发送请求。</p><p id="92e4" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu"> API Key </strong> —我们API的密钥，随机字母和数字格式。REST API (v1)支持这一点，而HTTP API (v2)不支持。</p><p id="0ca1" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated"><strong class="lt iu">授权人</strong>—API访问控制的另一种形式。但是，这种方法更加复杂，可以根据访问策略和用户权限授予对某些资源的访问权限。</p><h1 id="a044" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">无服务器</h1><p id="cf25" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果你还没有<code class="fe mt mu mv mw b">serverless</code>(简称<code class="fe mt mu mv mw b">sls</code>，那么最简单的方法就是通过<code class="fe mt mu mv mw b">npm</code>在全球范围内安装它:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="cd8a" class="nb la it mw b gy nc nd l ne nf">npm install -g serverless</span></pre><p id="2c5a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">不过，让我们先启动空的<code class="fe mt mu mv mw b">npm</code>项目</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="4016" class="nb la it mw b gy nc nd l ne nf">mkdir aws-nodejs-project<br/>cd aws-nodejs-project<br/>npm init -y</span><span id="7ec5" class="nb la it mw b gy ng nd l ne nf"># Right now we have empty project<br/># Let's add sls</span><span id="aea8" class="nb la it mw b gy ng nd l ne nf">npm install serverless --save-dev</span><span id="f18b" class="nb la it mw b gy ng nd l ne nf"># Create empty SLS project</span><span id="1720" class="nb la it mw b gy ng nd l ne nf">npx sls create -t aws-nodejs</span></pre><p id="0834" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">成功完成最后一个命令后，我们的aws-nodejs-project将包含以下文件或目录:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="96dd" class="nb la it mw b gy nc nd l ne nf">handler.js<br/>node_modules<br/>package-lock.json<br/>package.json<br/>serverless.yml</span></pre><h1 id="b31e" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">REST API</h1><p id="cdde" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们打开<code class="fe mt mu mv mw b">serverless.yml</code>做必要的修改吧。如果你正在学习本教程，那么<code class="fe mt mu mv mw b">serverless.yml</code>将会有很多例子，注释掉配置，因为我们已经使用了<code class="fe mt mu mv mw b">aws-nodejs</code>模板(那是我们在<code class="fe mt mu mv mw b">sls create</code>命令中使用的<code class="fe mt mu mv mw b">-t</code>参数)。</p><p id="5805" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们可以清理干净然后离开，不多不少于:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9af8" class="nb la it mw b gy nc nd l ne nf">service: aws-nodejs-project<br/>frameworkVersion: '2'</span><span id="4714" class="nb la it mw b gy ng nd l ne nf">provider:<br/>  name: aws<br/>  runtime: nodejs12.x<br/>  lambdaHashingVersion: 20201221</span><span id="f90a" class="nb la it mw b gy ng nd l ne nf">functions:<br/>  hello:<br/>    handler: handler.hello</span></pre><p id="093c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在这个阶段，我们应该能够使用<code class="fe mt mu mv mw b">npx sls deploy -s dev -r eu-west-1</code>部署我们的功能</p><p id="8d0f" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">作为回报，我们将获得:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="f02d" class="nb la it mw b gy nc nd l ne nf">Serverless: Uploading service aws-nodejs-project.zip file to S3 (69.31 kB)...<br/>Serverless: Validating template...<br/>Serverless: Updating Stack...<br/>Serverless: Checking Stack update progress...<br/>...............<br/>Serverless: Stack update finished...<br/>Service Information<br/>service: aws-nodejs-project<br/>stage: dev<br/>region: eu-west-1<br/>stack: aws-nodejs-project-dev<br/>resources: 6<br/>api keys:<br/>  None<br/>endpoints:<br/>functions:<br/>  hello: aws-nodejs-project-dev-hello<br/>layers:<br/>  None</span></pre><p id="97b2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">然而，我们并没有真正配置任何端点，因为<code class="fe mt mu mv mw b">events</code>部分被注释掉了。让我们在<code class="fe mt mu mv mw b">functions</code>下快速重新添加这个</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="77d4" class="nb la it mw b gy nc nd l ne nf">functions:<br/>  hello:<br/>    handler: handler.hello<br/>    events:<br/>      - http:<br/>          path: /hello-rest<br/>          method: get</span></pre><p id="6e95" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">一旦再次部署，我们将获得我们的端点地址，并且我们将能够对<code class="fe mt mu mv mw b">/hello-rest</code>进行<code class="fe mt mu mv mw b">GET</code>请求</p><p id="62c2" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">尽管没有安全性，但任何人都可以访问我们的端点。我们先添加API key，将<code class="fe mt mu mv mw b">private: true</code>和<code class="fe mt mu mv mw b">my-secret-api-key</code>添加到<code class="fe mt mu mv mw b">serverless.yml</code>配置中:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="0f27" class="nb la it mw b gy nc nd l ne nf">service: aws-nodejs-project<br/>frameworkVersion: '2'</span><span id="6ceb" class="nb la it mw b gy ng nd l ne nf">provider:<br/>  name: aws<br/>  runtime: nodejs12.x<br/>  lambdaHashingVersion: 20201221<br/>  apiKeys:<br/>    - my-secret-api-key</span><span id="4aa9" class="nb la it mw b gy ng nd l ne nf">functions:<br/>  hello:<br/>    handler: handler.hello<br/>    events:<br/>      - http:<br/>          path: /hello-rest<br/>          method: get<br/>          private: true</span></pre><p id="f946" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">像往常一样，在做出更改后，我们需要重新部署我们的功能:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="bf80" class="nb la it mw b gy nc nd l ne nf">npx sls deploy -s dev -r eu-west-1</span></pre><p id="75e6" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">作为回报，我们将获得API密钥:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="9599" class="nb la it mw b gy nc nd l ne nf">Service Information<br/>service: aws-nodejs-project<br/>stage: dev<br/>region: eu-west-1<br/>stack: aws-nodejs-project-dev<br/>resources: 14<br/>api keys:<br/>  my-secret-api-key: 4Td1Hmm66v35l93Ih73cM2h3WKltmaeN9JOBpvs5<br/>endpoints:<br/>  GET - <a class="ae ky" href="https://gp1wiczlvf.execute-api.eu-west-1.amazonaws.com/dev/hello-rest" rel="noopener ugc nofollow" target="_blank">https://gp1wiczlvf.execute-api.eu-west-1.amazonaws.com/dev/hello-rest</a><br/>functions:<br/>  hello: aws-nodejs-project-dev-hello<br/>layers:<br/>  None</span></pre><p id="2012" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果我们只是试图打开URL(例如在网络浏览器中)，我们将得到<code class="fe mt mu mv mw b">403 Forbidden</code>错误。重要的是API Gateway实际上已经停止了那个请求。</p><p id="c726" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">因此，让我们切换到POSTMAN并将<code class="fe mt mu mv mw b">X-API-Key</code>头添加到<code class="fe mt mu mv mw b">GET</code>请求中。我们使用<code class="fe mt mu mv mw b">deploy</code>命令返回的密钥作为密钥值。</p><p id="5987" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">一旦我们发送更新的请求，那么作为回报，我们将得到<code class="fe mt mu mv mw b">200 OK</code>和由<code class="fe mt mu mv mw b">handler.js</code>生成的主体:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="99a1" class="nb la it mw b gy nc nd l ne nf">module.exports.hello = async (event) =&gt; {<br/>  return {<br/>    statusCode: 200,<br/>    body: JSON.stringify(<br/>      {<br/>        message: 'Go Serverless v1.0! Your function executed successfully!',<br/>        input: event,<br/>      },<br/>      null,<br/>      2<br/>    ),<br/>  };</span><span id="8950" class="nb la it mw b gy ng nd l ne nf">// Use this code if you don't use the http event with the LAMBDA-PROXY integration<br/>// return { message: 'Go Serverless v1.0! Your function executed successfully!', event };<br/>};</span></pre><p id="498d" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">目前，我们的REST API正在工作，并受到<code class="fe mt mu mv mw b">X-API-Key</code>的保护</p><p id="f1bb" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果我们登录AWS并转到API Gateway，我们可以在那里找到我们的API:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/574b66bb8598b52774d651bb0ef00f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KZ9XCX7SPVZpa4UZN2Luqg.png"/></div></div></figure><p id="ce3c" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">API密钥在这里:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/d89c7e4cca40ef4c1be77debbda33558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K_iYoAvJ1kksNk5edV0PPQ.png"/></div></div></figure><h2 id="7af6" class="nb la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">REST API中的自定义授权者</h2><p id="ae55" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们单击“授权人”链接，我们会看到还没有授权人:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/d2c8b2b2c6644be3973cb8df46dc7256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHHgKcu4oIRlQ1yuWkbp9g.png"/></div></div></figure><p id="d0c7" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">但是，我们将使用无服务器，而不是通过Web控制台手动创建授权者。让我们回到我们的IDE，修改几个文件:</p><p id="25ed" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">创建一个新文件<code class="fe mt mu mv mw b">authorizer.js</code>并添加以下代码。请注意，我们没有使用合适的令牌，而是硬编码了<code class="fe mt mu mv mw b">ABCDEF</code>:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="0310" class="nb la it mw b gy nc nd l ne nf">'use strict';</span><span id="de7e" class="nb la it mw b gy ng nd l ne nf">module.exports.handler = async (event) =&gt; {<br/>  if (event.authorizationToken === 'Bearer ABCDEF') {<br/>    return {<br/>      principalId: 'anonymous',<br/>      policyDocument: {<br/>        Version: '2012-10-17',<br/>        Statement: [<br/>          {<br/>            Action: 'execute-api:Invoke',<br/>            Effect: 'Allow',<br/>            Resource: event.methodArn,<br/>          },<br/>        ],<br/>      },<br/>    };<br/>  }<br/>  throw Error('Unauthorized');<br/>};</span></pre><p id="abdf" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">接下来，让我们修改<code class="fe mt mu mv mw b">serverless.yml</code>并向其添加自定义授权人:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="ed3b" class="nb la it mw b gy nc nd l ne nf">functions:<br/>  hello:<br/>    handler: handler.hello<br/>    events:<br/>      - http:<br/>          path: /hello-rest<br/>          method: get<br/>          private: true<br/>          authorizer: custom-authorizer</span><span id="6ecd" class="nb la it mw b gy ng nd l ne nf">custom-authorizer:<br/>  handler: authorizer.handler</span></pre><p id="5718" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">最后，我们需要用<code class="fe mt mu mv mw b">sls deploy</code>命令重新部署我们的功能。</p><p id="2eb9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在，让我们在POSTMAN中测试一下。如果我们不对请求做任何更改，我们将得到<code class="fe mt mu mv mw b">401 Unauthorized</code>错误:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/a8f8a3814c8ac54b2735096dfbf8eada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mqUDC7ObCHPXykdd_0K5JA.png"/></div></div></figure><p id="828b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">为了通过授权，我们必须在请求中添加<code class="fe mt mu mv mw b">Authorization</code>标题:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nu"><img src="../Images/27fb154f4d5ab962eec3ecfa8075ade8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuzSk3rP-XkPEZJaxInV2w.png"/></div></div></figure><p id="c5f8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在，我们的端点受到了<code class="fe mt mu mv mw b">API Key</code>和自定义授权器的保护，该授权器授予对某些资源的访问权限！</p><h1 id="6eb4" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">HTTP API</h1><p id="e50f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">如果我们想使用HTTP API (API Gateway v2 ),那么我们可以通过创建一个新项目或者修改现有的项目来重新开始。事实上，我们可以在同一个项目中拥有API v1和API v2！</p><p id="4156" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在<code class="fe mt mu mv mw b">functions</code>下的<code class="fe mt mu mv mw b">serverless.yml</code>中，让我们添加一个名为<code class="fe mt mu mv mw b">hello-http</code>的新功能:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="ecaf" class="nb la it mw b gy nc nd l ne nf">functions:<br/>...<br/>  hello-http:<br/>    handler: handler.hello<br/>    events:<br/>      - httpApi:<br/>          path: /hello-http<br/>          method: get</span></pre><p id="1335" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">对于这个例子，我们没有创建新的处理程序。我们只是重复使用现有的。HTTP API与REST API的主要区别在于<code class="fe mt mu mv mw b">events</code>下的<code class="fe mt mu mv mw b">httpApi</code>。此外，没有API键，我们还没有配置自定义授权！</p><p id="e1f8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">一旦我们重新部署项目，那么这个端点将对每个人开放。</p><p id="6f51" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">如果我们返回AWS Web控制台，那么在API Gateway中，我们将看到两个API！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/1323b6f6aab4b56980cf833490cf5c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kCRKG0tPYLfhKUyhpQBDQw.png"/></div></div></figure><p id="ef70" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现有的REST API和新增的HTTP API。值得注意的是，如果我们在API Gateway中打开我们的HTTP API，那么可用的配置选项将会不同:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/77b68a43911e99394204dc7918f4d82f.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*t1CALI2pVtY02jBv21iawQ.png"/></div></figure><p id="0147" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">一个很大的区别是没有API键。对于所有的差异，我们可以查看这个比较页面:<a class="ae ky" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html" rel="noopener ugc nofollow" target="_blank">在HTTP APIs和REST APIs之间选择</a></p><h2 id="0297" class="nb la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">HTTP API中的自定义授权者</h2><p id="bae4" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">我们有一个工作的HTTP API端点，现在我们只需要用自定义授权器来保护它。然而，REST和API授权者之间有一个微妙的区别。因此，让我们删除现有的REST API，只留下HTTP API。</p><p id="803b" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">先修改一下<code class="fe mt mu mv mw b">serverless.yml</code>。我们可以删除现有的REST API函数，连同API键。然后，我们可以向HTTP API添加自定义授权器。我们的<code class="fe mt mu mv mw b">serverless.yml</code>最终看起来会像:</p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="13df" class="nb la it mw b gy nc nd l ne nf">service: aws-nodejs-project<br/>frameworkVersion: '2'</span><span id="a3dc" class="nb la it mw b gy ng nd l ne nf">provider:<br/>  name: aws<br/>  runtime: nodejs12.x<br/>  lambdaHashingVersion: 20201221<br/>  httpApi:<br/>    authorizers:<br/>      customAuthorizer:<br/>        type: request<br/>        functionName: custom-authorizer</span><span id="dcf7" class="nb la it mw b gy ng nd l ne nf">functions:<br/>  hello-http:<br/>  handler: handler.hello<br/>  events:<br/>    - httpApi:<br/>        path: /hello-http<br/>        method: get<br/>        authorizer:<br/>          name: customAuthorizer</span><span id="c157" class="nb la it mw b gy ng nd l ne nf">custom-authorizer:<br/>  handler: authorizer.handler</span></pre><p id="8864" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在我们重新部署我们的项目之前，我们必须在<code class="fe mt mu mv mw b">authorizer.js</code>中做一些小而重要的改变</p><p id="612a" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">我们必须用现在的<code class="fe mt mu mv mw b">event.headers.authorization</code>代替<code class="fe mt mu mv mw b">event.authorizationToken</code>，并且我们必须用<code class="fe mt mu mv mw b">Resource: event.routeArn</code>替换<code class="fe mt mu mv mw b">Resource: event.methodArn</code></p><p id="0eb8" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">此处更新<code class="fe mt mu mv mw b">authorizer.js</code></p><pre class="kj kk kl km gt mx mw my mz aw na bi"><span id="a403" class="nb la it mw b gy nc nd l ne nf">'use strict';</span><span id="c03c" class="nb la it mw b gy ng nd l ne nf">module.exports.handler = async (event) =&gt; {<br/>  if (event.headers.authorization === 'Bearer ABCDEF') {<br/>    return {<br/>      principalId: 'anonymous',<br/>      policyDocument: {<br/>        Version: '2012-10-17',<br/>        Statement: [<br/>          {<br/>            Action: 'execute-api:Invoke',<br/>            Effect: 'Allow',<br/>            Resource: event.routeArn,<br/>          },<br/>        ],<br/>      },<br/>    };<br/>  }<br/>  throw Error('Unauthorized');<br/>};</span></pre><p id="0b70" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">接下来，在重新部署项目后，如果没有<code class="fe mt mu mv mw b">Authorization</code>头，我们的HTTP API端点将无法访问:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/b873277f58037a3b93db74e0a70fd616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ssbZtmrBWOS9lUtkNpqAw.png"/></div></div></figure><p id="c546" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这正是我们所期待的！</p><p id="bf2e" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">现在让我们用我们的超级机密<code class="fe mt mu mv mw b">ABCDEF</code>令牌添加<code class="fe mt mu mv mw b">Authorization</code>头:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/cf1d9f92560a29bc682d8e61ce64f8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXRrL4BVAxfqGGsmmYSgXA.png"/></div></div></figure><p id="01b9" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">这就结束了我们使用定制授权器的REST和HTTP API比较。</p><h1 id="31b5" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">结论</h1><p id="f550" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">HTTP和REST APIs非常相似。甚至命名约定也可以互换使用。然而，我们必须注意我们使用的是哪一个，因为有细微的差别。</p><p id="8159" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">你将选择哪一个取决于几个因素。比如你是否从头开始构建一个全新的API，是否需要API Keys等。</p><p id="6ce5" class="pw-post-body-paragraph lr ls it lt b lu mo ju lw lx mp jx lz ma mq mc md me mr mg mh mi ms mk ml mm im bi translated">在这两种情况下，我们可以使用配置和代码非常相似的定制授权器。</p></div></div>    
</body>
</html>