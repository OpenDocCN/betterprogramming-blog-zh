<html>
<head>
<title>Clean Code Applied to JavaScript (Part 7: Practical Refactoring)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用于JavaScript的干净代码(第7部分:实用重构)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/clean-code-applied-to-javascript-part-7-practical-refactoring-4f18eff33350?source=collection_archive---------11-----------------------#2020-04-09">https://betterprogramming.pub/clean-code-applied-to-javascript-part-7-practical-refactoring-4f18eff33350?source=collection_archive---------11-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a682" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">关于编写和维护干净代码的惊人好处的系列文章</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/34749ea1482570e186a9bd988e177106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DaWhZ22ATLOMRpMQgYAPg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">梅勒妮·范·卢文在<a class="ae ky" href="https://unsplash.com/s/photos/caesar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="827c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是深入研究干净代码主题的系列文章的第7部分，应用于JavaScript。</p><p id="8a85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本系列中，我们将讨论每个程序员都应该知道的关于干净代码的经典技巧，并将它们应用于特定的JavaScript/TypeScript语言。</p><ul class=""><li id="f31b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-1-9f3badd5715" rel="noopener">第1部分:开始之前</a></li><li id="7551" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-ii-variables-8302f01e539c" rel="noopener">第二部分:变量</a></li><li id="2277" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/@ccaballero/clean-code-applied-to-javascript-part-3-functions-f9f26b221736" rel="noopener">第3部分:功能</a></li><li id="64f5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-4-3f6db21ee4e5" rel="noopener">第4部分:注释</a></li><li id="546a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-5-exceptions-d46e07691c19" rel="noopener">第5部分:例外情况</a></li><li id="655a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/better-programming/clean-code-applied-to-javascript-part-6-avoid-conditional-complexity-5ee9cbb1b26a" rel="noopener">第6部分:避免条件复杂性</a></li><li id="20dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="http://www.carloscaballero.io/clean-code-applied-to-javascript-part-vii-practical-refactoring-example-ceaser-chipher" rel="noopener ugc nofollow" target="_blank">第七部分:实际重构示例:凯撒密码</a></li></ul></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><p id="8542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这一系列文章中，我们介绍了允许我们生成更易维护的代码的编程技术。大多数编程技术和建议来自于<a class="ae ky" href="https://www.goodreads.com/book/show/3735293-clean-code" rel="noopener ugc nofollow" target="_blank">“干净的代码”一书</a>以及这些技术在多年经验中的应用。</p><p id="0166" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将一步一步地描述重构技术的应用，我已经将这种技术应用到为我的一个编程基础类编写的代码中。如果你开始开发软件，我建议你先尝试用你知道的技术和工具解决问题(我们将使用JavaScript作为编程语言)。</p><p id="9c51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你已经有编程知识，解决问题很容易，练习就不一样了。在这种情况下，提供了一个解决方案——起始代码——挑战是应用不同的重构技术来深入理解代码并使其更易于维护。</p><p id="1438" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我准备了一个GIT存储库，在这里你可以找到我们将在本文中使用JavaScript一步一步解决的算法的所有版本。它还有一系列npm脚本，允许您使用以下术语执行每个步骤的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="a28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<a class="ae ky" href="https://github.com/Caballerog/blog/tree/master/refactoring-caesar" rel="noopener ugc nofollow" target="_blank"> Git库</a>，在这里你可以找到代码。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="9da7" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">问题:凯撒密码</h1><p id="7f2e" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这个问题的描述摘自<a class="ae ky" href="https://en.wikipedia.org/wiki/Caesar_cipher" rel="noopener ugc nofollow" target="_blank">维基百科</a>。</p><blockquote class="np nq nr"><p id="dab8" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">凯撒密码是最简单也是最广为人知的加密技术之一。这是一种替代密码，明文中的每个字母都被替换为字母表中某个固定位置的字母。例如，右移3，E将被H替换，F将变成I，依此类推。</p><p id="7529" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated">这种转换可以通过对齐两个字母来表示；密码字母表是向右旋转一些位置的普通字母表。</p></blockquote><p id="03e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，这是一个凯撒密码，它使用了6位的右旋转，相当于右移6位:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="aab4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">加密时，一个人在“明文”行中查找消息的每个字母，并在“密码”行中写下相应的字母。</p><ul class=""><li id="bc7a" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">明文:敏捷的棕色狐狸跳过懒惰的狗</li><li id="ffab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">密文:QEB NRFZH约尔特克CLU GRJMP LSBO QEB IXWV ALD</li></ul><p id="ebb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">破译是反向进行的，左移6。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5fa2" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">什么是重构，为什么要重构？</h1><p id="3471" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">重构是软件开发行业中一个众所周知的话题。至此，我们对这个话题做一个介绍，但我推荐你阅读<a class="ae ky" href="https://www.cuelogic.com/blog/what-is-refactoring-and-why-is-it-important" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><blockquote class="np nq nr"><p id="636e" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><em class="it">重构不是</em> <strong class="lb iu">银弹</strong> <em class="it">但是它是一件有价值的武器，它有助于你很好地掌握你的代码&amp;以至于项目(软件/应用)。</em></p><p id="d1b5" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><a class="ae ky" href="https://www.cuelogic.com/blog/what-is-refactoring-and-why-is-it-important" rel="noopener ugc nofollow" target="_blank">“什么是重构，为什么它很重要？”</a></p><p id="bdc1" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><em class="it">这是一个获取现有代码并对其进行改进的科学过程，同时使代码更具可读性、可理解性和整洁性。此外，添加新功能、构建大型应用程序和修复bug也变得非常方便。</em></p><p id="cb91" class="kz la ns lb b lc ld ju le lf lg jx lh nt lj lk ll nu ln lo lp nv lr ls lt lu im bi translated"><a class="ae ky" href="https://www.cuelogic.com/blog/what-is-refactoring-and-why-is-it-important" rel="noopener ugc nofollow" target="_blank">“什么是重构，为什么它很重要？”</a></p></blockquote><h2 id="872a" class="nw mt it bd mu nx ny dn my nz oa dp nc li ob oc ne lm od oe ng lq of og ni oh bi translated"><strong class="ak">为什么重构很重要</strong></h2><ul class=""><li id="0009" class="lv lw it lb b lc nk lf nl li oi lm oj lq ok lu ma mb mc md bi translated">它改进了软件/应用程序的设计。</li><li id="25fe" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它使软件更容易理解。</li><li id="eda6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它有助于发现错误。</li><li id="ea07" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它有助于修复现有的遗留数据库。</li><li id="e596" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">它为用户提供了更大的一致性。</li></ul><p id="89dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们知道了我们想要解决的问题，我们就执行一个实现，任何一个刚开始开发的人都可以用很少的时间来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f99a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们要开发的代码有两种方法:</p><ul class=""><li id="4379" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><code class="fe ol om on oo b">cipher</code> —将文本和偏移应用于一个方向。</li><li id="8ca7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><code class="fe ol om on oo b">decipher</code> —执行与<code class="fe ol om on oo b">cipher</code>相反的操作。也就是说，它解读文本。</li></ul><p id="8336" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我建议，无论何时你对代码执行重构，你都要有一系列的自动化测试来帮助你验证你没有“破坏”代码。在这个具体的例子中，我没有创建测试套件，而是使用标准的<code class="fe ol om on oo b">console.assert</code>创建了两个检查。</p><p id="0732" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，将通过以下断言来检查算法是否稳定:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="9713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经有了要进行的挑战，让我们开始吧！</p><p id="282a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是通过赋予代码语义值的变量名来删除代码中出现的幻数。这样，下列数字将被修改:</p><ul class=""><li id="e30c" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">字母表中的字母数(26)。</li><li id="eae1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">属于算法应该循环的极限的每个字母，即:</li></ul><pre class="kj kk kl km gt op oo oq or aw os bi"><span id="614a" class="nw mt it oo b gy ot ou l ov ow">a: 65<br/>z: 90<br/>A: 97<br/>Z: 122</span></pre><p id="ae7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们定义了以下常量，这些常量使我们能够了解这些数字所代表的含义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="15ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，更改后的代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="22da" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">第二步。从if-else中提取类似的代码</h1><p id="498c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">下一步是识别那些重复的代码行，以便可以将它们提取到函数中。具体来说，存在于<code class="fe ol om on oo b">if</code>控制结构主体中的赋值在整个代码中重复出现——这些是可以提取的。</p><p id="23e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，下面的代码片段<code class="fe ol om on oo b">cipher = cipher.concat (String.fromCharCode (</code>可以从代码中存在的不同<code class="fe ol om on oo b">if</code>中提取。该行在<code class="fe ol om on oo b">if</code>结构之后执行，而<code class="fe ol om on oo b">if</code>仅包含根据每种情况的不同逻辑。</p><p id="c263" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们对<code class="fe ol om on oo b">cipher</code>功能执行的操作也同样适用于<code class="fe ol om on oo b">decipher</code>功能。</p><p id="d655" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是应用此重构后的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="b1a0" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">第三步。避免否则</h1><p id="2dac" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">下一步是避免与<code class="fe ol om on oo b">else</code>控制结构块相关的代码。避免它是相当容易的。我们所要做的就是在循环开始之前将代码从<code class="fe ol om on oo b">else</code>移动到变量<code class="fe ol om on oo b">character</code>，所以这个值被指定为默认值。</p><p id="41ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重构后的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="611a" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">第四步。合并IF逻辑</h1><p id="0efd" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">接下来的路是曲折的。我们必须合并对应于<code class="fe ol om on oo b">if-elseif</code>的逻辑，这样我们只有两个控制结构<code class="fe ol om on oo b">if</code>。</p><p id="e8e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个动作将允许我们在后面的步骤中观察到，我们真的有两条可选择的路径，而不是我们看起来的那些。</p><p id="b9e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并后的代码<code class="fe ol om on oo b">if</code>逻辑如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="da09" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">第五步。简化算法的逻辑</h1><p id="fe40" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在这一步，我们要推理出我们的算法不需要两个<code class="fe ol om on oo b">if </code>控制结构。相反，<code class="fe ol om on oo b">cipher</code>和<code class="fe ol om on oo b">decipher</code>功能都有一个<code class="fe ol om on oo b">if-else</code>控制结构。关注函数<code class="fe ol om on oo b">cipher </code>，可以观察到有两种可能的选项来为变量<code class="fe ol om on oo b">character</code>赋值。第一种可能性是从相应的第一个<code class="fe ol om on oo b">if</code>获得的可能性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个可能的值，在默认情况下和从另一个控制结构<code class="fe ol om on oo b">if</code>中获得，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="61f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，可以移除第二个<code class="fe ol om on oo b">if</code>的逻辑，并将控制结构转换为<code class="fe ol om on oo b">else</code>，对应于第一个控制结构<code class="fe ol om on oo b">if</code>，因为，在不满足此<code class="fe ol om on oo b">if</code>的条件的情况下，将为变量<code class="fe ol om on oo b">character</code>分配第二个可能的值——无论第二个<code class="fe ol om on oo b">if</code>在由默认值分配时是否满足。</p><p id="a21e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是这次重构后的<a class="ae ky" href="https://gist.github.com/42d7ad086daf7d39506598c04f502742" rel="noopener ugc nofollow" target="_blank">代码。</a></p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="5407" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated"><strong class="ak">第六步。封装条件</strong></h1><p id="f473" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">我们算法的条件相当复杂，难以理解，因为它缺乏语义值。因此，代码中的下一步被称为“封装条件”</p><p id="edfc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，我们专注于封装<code class="fe ol om on oo b">cipher</code>和<code class="fe ol om on oo b">decipher</code>条件。</p><p id="cef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ol om on oo b">cipher</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f866" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ol om on oo b">decipher</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="c098" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，这种逻辑可以概括为以下四个功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0502" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">执行此封装后的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8c23" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">第七步。移除if-else结构控制</h1><p id="0c28" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">控制结构<code class="fe ol om on oo b">if-else</code>对同一变量(<code class="fe ol om on oo b">character</code>)进行赋值。因此，您可以从<code class="fe ol om on oo b">if</code>中提取条件逻辑并将其存储在一个变量中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="045a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe ol om on oo b">character</code>的赋值仅由旋转值修改，旋转值有两个可能值:</p><ol class=""><li id="dfb2" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ox mb mc md bi translated"><code class="fe ol om on oo b">NUMBER_LETTERS (26)</code></li><li id="16d1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ox mb mc md bi translated"><code class="fe ol om on oo b">NO_ROTATION (0)</code></li></ol><p id="2897" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们可以定义变量<code class="fe ol om on oo b">rotation</code>,以便它允许我们提高代码中的粒度级别，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="84a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">生成的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5cda" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步之后产生的两个函数的代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="441a" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">第八步。变量命名</h1><p id="9b05" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">完成重构算法的最后一步是将循环中的变量<code class="fe ol om on oo b">i</code>重命名为一个更合适的名称，比如<code class="fe ol om on oo b">position</code>(这个变化看起来很小，但重要的是我们要为变量赋予语义值，包括循环中经典的<code class="fe ol om on oo b">i</code>、<code class="fe ol om on oo b">j</code>和<code class="fe ol om on oo b">k</code>)。</p><p id="e8f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用这些简单的步骤后，我们算法的最终结果如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="aaa8" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="7657" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">在本文中，我们提出了一些从基本解决方案到可理解代码的重构建议。</p><p id="b71a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经一步一步地展示了我的推理。当然，从你的角度来看，还有其他方式和一些决定可能不是最合适的。出于所有这些原因，只要你的想法有建设性，我邀请你与社区分享你的想法！</p><p id="2b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个挑战旨在让我的业内同事(他们认为这对他们来说很难)看到其他同事如何一步一步地执行重构任务。</p><p id="9ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一篇文章中，我将继续改进代码，尝试从函数式编程的角度给出解决方案的愿景。</p><p id="70dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们提出了以下几点:</p><ul class=""><li id="8771" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">神奇的数字</li><li id="ffcb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">从if-else中提取类似的代码</li><li id="8887" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">避免其他</li><li id="0137" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">合并IF逻辑</li><li id="dda5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">简化算法的逻辑</li><li id="ebe6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">封装条件</li><li id="93b9" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">移除if-else结构控制</li><li id="41bf" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">变量命名</li></ul><p id="0316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我给你留下了代码，包括原始代码和最终代码，这样你就可以对它进行最后的平衡:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="db59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="347b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="http://www.carloscaballero.io/clean-code-applied-to-javascript-part-vii-practical-refactoring-example-ceaser-chipher" rel="noopener ugc nofollow" target="_blank"> <em class="ns">。</em>T15】</a></p></div></div>    
</body>
</html>