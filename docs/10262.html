<html>
<head>
<title>Parsing Indeterminate Types With Decodable and Either Enum in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用Decodable和Enum解析不确定类型</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/parsing-indeterminate-types-with-decodable-and-either-enum-using-swift-93e6e1bc0c3a?source=collection_archive---------3-----------------------#2021-12-18">https://betterprogramming.pub/parsing-indeterminate-types-with-decodable-and-either-enum-using-swift-93e6e1bc0c3a?source=collection_archive---------3-----------------------#2021-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8252" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Swift中有效处理各种JSON响应</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/385f19f77a927d7d0d94d5b1651b22f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yEgQplfdHnL20evY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">费伦茨·阿尔马西</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bf68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你们中的一些人可能已经知道的，<code class="fe ls lt lu lv b">Decodable</code>是一种用于从外部表示(如JSON和属性列表)中解码类型的协议，在Swift 4中发布。</p><p id="8671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.apple.com/documentation/swift/decodable" rel="noopener ugc nofollow" target="_blank">根据苹果</a>的说法，一个<code class="fe ls lt lu lv b">Decodable</code>是:</p><blockquote class="lw lx ly"><p id="448a" class="kw kx lz ky b kz la jr lb lc ld ju le ma lg lh li mb lk ll lm mc lo lp lq lr ij bi translated">一种可以从外部表示中自我解码的类型。</p></blockquote><p id="191e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们得到一个JSON，如下所示:</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="7a41" class="mh mi iq lv b gy mj mk l ml mm">[<br/>    {<br/>        "type": "car",<br/>        "identifier": "12345",<br/>        "model": "Audi"<br/>    }<br/>]</span></pre><p id="294e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以定义一个符合<code class="fe ls lt lu lv b">Decodable</code> <em class="lz"> </em>的<code class="fe ls lt lu lv b">Car</code>类型，并使用<code class="fe ls lt lu lv b">JSONDecoder</code>实例对其进行解码。您可以在Swift playground中尝试以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="f888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设后端团队决定在同一个响应中也包含<code class="fe ls lt lu lv b">Motorcycles</code>:</p><pre class="kg kh ki kj gt md lv me mf aw mg bi"><span id="ae55" class="mh mi iq lv b gy mj mk l ml mm">[<br/>    {<br/>        "type": "car",<br/>        "identifier": "12345",<br/>        "model": "Audi"<br/>    },<br/>    {<br/>        "type": "Motorcyle",<br/>        "brand": "Yamaha"<br/>    }<br/>]</span></pre><p id="df0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在理想情况下，我们应该有两个不同的键:一个用于<code class="fe ls lt lu lv b">Cars</code>，一个用于<code class="fe ls lt lu lv b">Motorcycle</code>。但是，尽管这并不常见(或者至少不应该如此)，我们有时还是会收到设计糟糕的JSON响应。</p><p id="c72b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以想象，我们的<code class="fe ls lt lu lv b">Car</code>类型不再足以解码整个JSON响应。这是一个利用我们强大的swift枚举的好场景。</p><p id="ba7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们将利用<code class="fe ls lt lu lv b">Either</code> enum，它是一个只有两种情况的枚举，一次只能使用其中一种。关于这个自定义实现有很多好的参考资料，所以我就不深入介绍了。</p><p id="a785" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">Either</code>枚举的一个常见实现如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="3fcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让<code class="fe ls lt lu lv b">Either</code>和<code class="fe ls lt lu lv b">Decodable</code><em class="lz"/>一起工作，我们需要扩展它的功能。如果我们使用类似于<code class="fe ls lt lu lv b">Either&lt;Car, Motorcycle&gt;</code>的东西直接尝试解码JSON响应，编译器将会抛出一个错误，因为<code class="fe ls lt lu lv b">Either</code>需要符合<code class="fe ls lt lu lv b">Decodable</code>协议。</p><p id="8a18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于枚举不能包含任何存储的属性，因此不能为<code class="fe ls lt lu lv b">Either</code>合成编码键。因此，它还需要实现<code class="fe ls lt lu lv b"><a class="ae kv" href="https://developer.apple.com/documentation/swift/decodable/2894081-init" rel="noopener ugc nofollow" target="_blank">init(from: Decoder)</a></code>初始化器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4e94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们应该准备好使用我们的<code class="fe ls lt lu lv b">Either</code>枚举来解析JSON响应:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="466f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应该就是这样了！这样，您应该能够从JSON响应中检索到<code class="fe ls lt lu lv b">Cars</code>或<code class="fe ls lt lu lv b">Motorcycles</code>。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="196b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，你可能会问:如果我们得到一辆额外的车会怎么样？如果我们得到两个额外的呢？或者更多？</p><p id="5e9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您可能已经猜到的那样，<code class="fe ls lt lu lv b">Either</code>在这种情况下不起作用。更好的方法是使用类型擦除来定义一个<code class="fe ls lt lu lv b">AnyDecodable</code>类型。</p><p id="764d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将在以后的文章中讨论这个主题。您可以在这个GitHub资源库中找到完整的示例代码:</p><div class="mw mx gp gr my mz"><a href="https://github.com/DeluxeAlonso/Decodable-Either" rel="noopener  ugc nofollow" target="_blank"><div class="na ab fo"><div class="nb ab nc cl cj nd"><h2 class="bd ir gy z fp ne fr fs nf fu fw ip bi translated">GitHub-DeluxeAlonso/Decodable-要么:用Decodable和要么枚举解析不确定类型…</h2><div class="ng l"><h3 class="bd b gy z fp ne fr fs nf fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nh l"><p class="bd b dl z fp ne fr fs nf fu fw dk translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn kp mz"/></div></div></a></div></div></div>    
</body>
</html>