<html>
<head>
<title>How a Popular Feature Declined by Svelte Went Live in Malina.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个受欢迎的特色节目如何在Malina.js上线</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-a-popular-feature-declined-by-svelte-went-live-in-malina-js-1a08fdb9dbc4?source=collection_archive---------6-----------------------#2020-08-28">https://betterprogramming.pub/how-a-popular-feature-declined-by-svelte-went-live-in-malina-js-1a08fdb9dbc4?source=collection_archive---------6-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4abf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将CSS类传递给子组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/2ef8348b0d5a337481d1973577294610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvWCS5FbmX_gkZEujbdqfA.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">在<a class="ae kr" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kr" href="https://unsplash.com/@alvannee" rel="noopener ugc nofollow" target="_blank"> Alvan Nee </a>拍摄的照片。</p></figure><p id="bf38" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我发现在<a class="ae kr" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Svelte </a>社区中的开发人员经常谈论将类传递给子组件，父组件如何影响子组件的样式，以及改变边距、颜色和其他样式。除此之外，Svelte还有一系列与此相关的问题:</p><ul class=""><li id="75bd" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><a class="ae kr" href="https://github.com/sveltejs/svelte/issues/2870" rel="noopener ugc nofollow" target="_blank">将类传递给组件#2870 </a></li><li id="4c07" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><a class="ae kr" href="https://github.com/sveltejs/svelte/issues/4843" rel="noopener ugc nofollow" target="_blank">允许作用域类传递给子组件#4843 </a></li><li id="90b8" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><a class="ae kr" href="https://github.com/sveltejs/svelte/issues/5236" rel="noopener ugc nofollow" target="_blank">部件#5236的分类指令</a></li><li id="9a77" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><a class="ae kr" href="https://github.com/sveltejs/rfcs/pull/22" rel="noopener ugc nofollow" target="_blank">允许父组件影响子组件CSS #22 </a></li><li id="96df" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><a class="ae kr" href="https://github.com/sveltejs/svelte/pull/4749" rel="noopener ugc nofollow" target="_blank">部件#4749的分类指令</a></li></ul><p id="7f4b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">使用<code class="fe mc md me mf b">:global</code>可以解决一些情况，但是这不是一个非常方便的方法，并且会对其他组件产生不必要的影响。</p><p id="0b8e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">所以我们在<a class="ae kr" href="https://github.com/malinajs/malinajs" rel="noopener ugc nofollow" target="_blank"> Malina.js </a>社区(是的，我们有一个小社区)尝试了一些东西，并决定尝试将一个类传递给一个组件。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f668" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">属性$class</h1><p id="7a1e" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">因此，我们想到的第一种方法是创建一些<code class="fe mc md me mf b">$class</code> -object/string，其中包含带有父组件的CSS-hash的转移类。但是使用父散列会产生不必要的效果，CSS类可能会流出。为了使这些类相互隔离，它们应该有自己的CSS-hash。因此，除了父组件和子组件有自己的CSS-hash之外，被转移的类也必须有自己的CSS-hash，以便与父组件隔离开来，并且只影响某些组件。</p><p id="4f64" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">结果，一个父组件收集了所有的类，并通过<em class="nk">和</em>将它们传输到一个<code class="fe mc md me mf b">$class</code>中的子组件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi nl"><img src="../Images/adabbf1b68bd1de1220959b0357f9429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mmvUCC31Zgm8NEajWrhrw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">将类传递给子组件的$class。</p></figure><ul class=""><li id="b179" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><a class="ae kr" href="https://malinajs.github.io/repl/#/gist/df8f752ffdbd5531b2ff9449d93a186b&amp;version=0.5.24" rel="noopener ugc nofollow" target="_blank">活生生的例子</a></li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="af6e" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">名为$class</h1><p id="7c62" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">但是只有一个<code class="fe mc md me mf b"><strong class="ku ir">$</strong>class</code>可能还不够。如果一个组件有头和体怎么办？在本例中，我想传递2个类属性。为此，您可以在子组件中使用<code class="fe mc md me mf b">$class.header</code>和<code class="fe mc md me mf b">$class.body</code>。对于一个父组件，应该可以指定一个子类名称和父类名称，但是我们还没有找到一个好的语法。<br/> <code class="fe mc md me mf b">&lt;Child class.header:parentclass={cond} /&gt;</code>长得很丑，所以我们就把它截成了<code class="fe mc md me mf b">&lt;Child .header="parent" /&gt;</code>。对于类指令:</p><pre class="kg kh ki kj gt nq mf nr ns aw nt bi"><span id="388a" class="nu mo iq mf b gy nv nw l nx ny">&lt;Child .header:parent={cond} /&gt;</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1a462ecc3ab56cf081d4bd15f77bb15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*ayL18nS19NeLfVDj7DO-Yw.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">传递class.header和class.body</p></figure><ul class=""><li id="10a9" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><a class="ae kr" href="https://malinajs.github.io/repl/#/gist/3f0c69dffaaaae04695cce521670cbf1&amp;version=0.5.24" rel="noopener ugc nofollow" target="_blank">实例</a></li></ul><p id="3de5" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果你对什么语法更合适有任何想法，请在评论中留下。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="2748" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">导出或导入类</h1><p id="4ff5" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">在模板中使用<code class="fe mc md me mf b">$class</code>看起来不太自然，所以我们可以从父类中采用一个类，这样就可以像普通类一样使用它，并使用类指令。</p><p id="e57a" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在Svelte中，我们使用关键字<code class="fe mc md me mf b">export</code>来接受来自父组件的属性/属性以及特定的CSS语法<code class="fe mc md me mf b">:global</code>。因此，我们制定了一个类似的语法来接受来自父类的CSS类:</p><pre class="kg kh ki kj gt nq mf nr ns aw nt bi"><span id="8cd1" class="nu mo iq mf b gy nv nw l nx ny">:export(.class-name) {…default-style…}</span></pre><p id="04a1" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">对此可能有一个更好的关键词。你也可以在评论中提出建议。</p><p id="c5e4" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">示例:我们在子组件中有一个按钮。它有一个<code class="fe mc md me mf b">.btn</code>类，所以在样式中，我可以将<code class="fe mc md me mf b">.btn</code>分成两个规则:</p><pre class="kg kh ki kj gt nq mf nr ns aw nt bi"><span id="56a0" class="nu mo iq mf b gy nv nw l nx ny">.btn {font-style: italic}<br/>:export(.btn) {color: deepskyblue}</span></pre><p id="ea30" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在这种情况下，第一个规则(使用<code class="fe mc md me mf b">font-style</code>)总是应用于按钮，但是第二个规则(使用<code class="fe mc md me mf b">color</code>)仅在父类没有通过<code class="fe mc md me mf b">btn</code>类时才应用。否则，父类中的类将应用于按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi oa"><img src="../Images/8c2fc4dcc25b552ed08bad7a97ccca1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QpFEUWteMfJoxPgayafhUw.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">如何从父类中继承类的示例</p></figure><ul class=""><li id="a462" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><a class="ae kr" href="https://malinajs.github.io/repl/#/gist/8943e3b6ce77ce38125072033e7e6560&amp;version=0.5.24" rel="noopener ugc nofollow" target="_blank">活生生的例子</a></li></ul><p id="51c0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">示例中的散列(<code class="fe mc md me mf b">css-1, css2…</code>)由选项<code class="fe mc md me mf b">cssGenId</code>设置，看起来更简单。你可以为一个散列指定任何样式(不在苗条<a class="ae kr" href="https://github.com/sveltejs/svelte/issues/2900" rel="noopener ugc nofollow" target="_blank">问题</a>)。</p><p id="4fba" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">如果您想在父组件中使用另一个名称的类，很容易重新映射它。在下面的例子中，我将类<code class="fe mc md me mf b">red + bold</code>转发到一个按钮，将<code class="fe mc md me mf b">purple</code>转发到另一个按钮。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nm nn di no bf np"><div class="gh gi ob"><img src="../Images/675b96c375a46fc82a56a7c221404fe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQSZFcmJHScE9hvSzeG_CQ.png"/></div></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">重映射类:红色+粗体-&gt; btn</p></figure><ul class=""><li id="bf55" class="lo lp iq ku b kv kw ky kz lb lq lf lr lj ls ln lt lu lv lw bi translated"><a class="ae kr" href="https://malinajs.github.io/repl/#/gist/dd1727edd04661badb535caa0a88b8fa&amp;version=0.5.24" rel="noopener ugc nofollow" target="_blank">实例</a></li></ul><p id="e018" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此外，您可以使用类指令。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1e61b8ec4a6eb4df7c00a3c67919bc3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*HigooIbdUrE9hm2PJi1faQ.png"/></div><p class="kn ko gj gh gi kp kq bd b be z dk translated">用类指令传递类。</p></figure></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="7458" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">隔离</h1><p id="30b8" class="pw-post-body-paragraph ks kt iq ku b kv nf jr kx ky ng ju la lb nh ld le lf ni lh li lj nj ll lm ln ij bi translated">js为传递类创建了一个额外的CSS-hash。它可以让你隔离这些类，以免影响其他组件，就像使用<code class="fe mc md me mf b">:global</code>一样。另外，这并不意味着父类可以将任何类转发给你的组件。通过使用关键字<code class="fe mc md me mf b">:export</code>，您可以指定想要接受哪些类，这就像是父组件和子组件之间的契约。这类似于<code class="fe mc md me mf b">export</code>对房地产所做的。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="8e8b" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">结论</h1><ul class=""><li id="5f03" class="lo lp iq ku b kv nf ky ng lb od lf oe lj of ln lt lu lv lw bi translated">这个解决方案没有创建新的样式(规则)。它只是将新的选择器附加到现有的样式上，所以CSS不会快速增长。</li><li id="bc3c" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated">几乎所有的工作都是在编译时完成的。运行时相当轻便。</li><li id="feaa" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><code class="fe mc md me mf b">Transfer-hash</code>确保课程不会外流。</li><li id="8a3a" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><code class="fe mc md me mf b">:export</code>关键字让你只接受期望的类，所以你仍然有一个子组件中的控件。</li></ul><p id="61fe" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这些要点表明，将类传递给组件是安全的、轻量级的，并且为设计可重用的组件提供了一定的灵活性。</p><p id="054b" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">此外，你可以阅读一篇关于片段的文章。</p><p id="1908" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">我们应该尝试的下一个功能是什么？感谢阅读。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="fbe8" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">链接</h1><ul class=""><li id="b7fa" class="lo lp iq ku b kv nf ky ng lb od lf oe lj of ln lt lu lv lw bi translated"><a class="ae kr" href="https://github.com/malinajs/malinajs" rel="noopener ugc nofollow" target="_blank"> Malina.js </a></li><li id="7ac6" class="lo lp iq ku b kv lx ky ly lb lz lf ma lj mb ln lt lu lv lw bi translated"><a class="ae kr" href="https://malinajs.github.io/repl/" rel="noopener ugc nofollow" target="_blank"> REPL为Malina.js </a></li></ul></div></div>    
</body>
</html>