<html>
<head>
<title>React Testing Library Configuration for Productive Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生产单元测试的反应测试库配置</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/react-testing-library-configuration-for-productive-unit-testing-5d0c446f3b3d?source=collection_archive---------12-----------------------#2022-07-11">https://betterprogramming.pub/react-testing-library-configuration-for-productive-unit-testing-5d0c446f3b3d?source=collection_archive---------12-----------------------#2022-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7bdb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Redux和GraphQL的一个例子</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cb21a6ccd792bb8f01d38712d4b9a06c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CL4cRRQ6-f3k3W-vmqs74g.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/s/photos/disorder" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ky" href="https://unsplash.com/@sharonmccutcheon" rel="noopener ugc nofollow" target="_blank"> sharonmccutcheon </a>的照片</p></figure><p id="2de2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我经常加入一个新的React项目，那里缺少单元测试，无论是数量还是质量。有几个原因，但我今天想讨论的是糟糕的测试环境。</p><p id="d602" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">的确，测试需要技巧、彻底性，并且绝对是耗时的(即使那是值得的！).如果测试比必要的更痛苦，它就变成了避免编写测试的信号。</p><h1 id="c0ef" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">环境</h1><p id="f294" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于React，我推荐的工具是Jest和React测试库。这里没有什么花哨的；他们是社区中事实上的标准。</p><div class="ms mt gp gr mu mv"><a href="https://morintd.medium.com/react-testing-understand-and-chose-the-right-tools-858236d3c4e1" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">React测试:理解并选择正确的工具</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">通过选择适当的测试工具，使用React和React Native节省时间和精力。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">morintd.medium.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ks mv"/></div></div></a></div><h1 id="cd9d" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">例子</h1><p id="d927" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">为了演示如何在一个好的环境中编写好的测试，我们需要一个组件来测试，对吗？让我们使用一个常见的功能:计数器。</p><p id="6ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将从下面的组件开始，在它自己的<code class="fe nk nl nm nn b">Counter.tsx</code>文件中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想指定我的应用程序入口点仍然是<em class="nq"> App.tsx. </em>它将在本文后面被修改以演示我们的配置<em class="nq">！</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h1 id="a98f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">试验</h1><p id="ea57" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">完整的资源库可以在<a class="ae ky" href="https://github.com/morintd/rtl-composable-providers" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><h2 id="9075" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">反应测试库</h2><p id="d9a1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在遵循<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/intro" rel="noopener ugc nofollow" target="_blank">介绍</a>并添加<a class="ae ky" href="https://testing-library.com/docs/ecosystem-jest-dom/" rel="noopener ugc nofollow" target="_blank"> jest-dom </a>之后，我设置了我的测试的第一个版本，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ef68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以找到三个基本的测试。它们帮助我们验证我们已经显示了一个默认值，当相应的按钮被点击时，该值增加或减少。</p><p id="0296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用当前的配置，我能够成功运行我的测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/84a00ce46386ec100a999ae77e192e6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*jwVQc7Lrrx3NYhj_PY7CpA.png"/></div></figure><p id="5320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当处理更大的代码库、更多的功能和依赖性时，问题就出现了。在本文中，我将演示我们如何处理相当常见的Redux和GraphQL。</p><h2 id="10b1" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">添加Redux</h2><p id="baf1" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我在关注<a class="ae ky" href="https://redux-toolkit.js.org/tutorials/quick-start" rel="noopener ugc nofollow" target="_blank"> RTK快速入门</a>，它方便地展示了一个带有计数器app的例子。我以下面的片段结束:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5e9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下商店:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9289" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及更新的<code class="fe nk nl nm nn b">Counter.tsx</code>组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的计数器的行为没有改变，但是测试失败，并显示以下错误消息:</p><blockquote class="oe of og"><p id="044b" class="kz la nq lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">找不到react-redux上下文值；请确保组件包装在<provider>中。</provider></p></blockquote><p id="d118" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很简单。我们试图隔离测试一个组件，但是它需要一个react-redux提供者来工作。我将它添加到我的<code class="fe nk nl nm nn b">App.tsx</code>中，但是从我的测试角度来看，它无处可寻。</p><p id="8b7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，对于每个测试，我们需要声明一个新的存储，并使用来自react-redux的提供者呈现我们的组件。从技术上讲，它可以与以下代码一起工作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="443c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，这是正确的解决方案吗？那是许多不需要的样板代码。如果您有更多的依赖项，您的测试将呈指数增长。这使得它们很难编写和维护。</p><p id="600e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，React测试库解释了如何设置一个<a class="ae ky" href="https://testing-library.com/docs/react-testing-library/setup" rel="noopener ugc nofollow" target="_blank">自定义渲染</a>。</p><div class="ms mt gp gr mu mv"><a href="https://testing-library.com/docs/react-testing-library/setup#custom-render" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">设置|测试库</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">React测试库不需要使用任何配置。然而，有些事情你可以做，当…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">testing-library.com</p></div></div><div class="ne l"><div class="ok l ng nh ni ne nj ks mv"/></div></div></a></div><h2 id="7546" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">设置改进</h2><p id="f2b9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在完成定制渲染部分之后，我创建了一个包含<code class="fe nk nl nm nn b">testing.tsx</code>文件的测试/目录:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我添加了一个<code class="fe nk nl nm nn b">index.ts</code>文件，从我的测试/目录中重新导出所有东西，然后，我从这个目录中导入实用程序，而不是从<code class="fe nk nl nm nn b">@testing-library/react</code>中导入我的Redux样板代码和实用程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4e2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那就好多了！但是，如果我们需要在测试期间触发对Redux存储的一些更改呢？此外，当我们的应用程序增长时，在我们的<code class="fe nk nl nm nn b">testing.tsx</code>中增加几十个提供者会使它更难阅读和维护。</p><p id="3806" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我想让我的渲染更加可定制。如果你看一下<code class="fe nk nl nm nn b">customRender </code>方法，你可以看到它需要一些与React测试库相关的选项。</p><p id="a12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这些选项来定制我们的提供商。我将允许一个新的属性providers，它是一个包含与我们的提供者相关的数据的对象。目前，需要采取以下措施:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="0f7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3e03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来不错，我甚至会加入一个helpers函数来构建一个商店:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f6d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我能够编写一个更高级的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="cedc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那看起来相当不错！但是我们仍然有一个问题:<code class="fe nk nl nm nn b">testing.tsx</code>文件将会变得不可维护。</p><p id="4757" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我想将提供者的声明移动到不同的文件中，并动态构建函数<code class="fe nk nl nm nn b">allTheProviders</code>。还有，构建它有一个很棒的模式:函数组合！</p><div class="ms mt gp gr mu mv"><a href="https://javascript.plainenglish.io/a-working-example-of-function-composition-in-javascript-5e8c704a13ca" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd iu gy z fp na fr fs nb fu fw is bi translated">举例说明JavaScript中的函数组合</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">函数式编程:函数组合是在执行长代码时保持代码整洁、可读的一种极好的方式。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ne l"><div class="ol l ng nh ni ne nj ks mv"/></div></div></a></div><p id="3b96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我解释一下。我没有创建一个庞大的函数，而是为我想添加的每个提供者创建一个。这些新函数接受选项、一个React节点，并返回一个React节点(可能有一个新的提供者)。</p><p id="a54b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于Redux，这个函数看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a74a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果它们具有这种结构，我可以将它们链接起来，或者换句话说，将它们组合起来，以构建一个具有多个提供者的组件。如果我将我的提供者列表、致力于组合它们的函数以及函数<code class="fe nk nl nm nn b">AllTheProviders</code>分开，看起来如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="81c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！这样，我们可以在不同的文件中声明新的(可组合的)提供者函数，并将它们添加到我们的列表中。</p><h2 id="770a" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">添加GraphQL</h2><p id="e465" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">让我们通过添加GraphQL来改进我们的演示。我们将添加加载和保存当前计数器的功能。</p><p id="9205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的模式和解析器如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4835" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae ky" href="https://www.apollographql.com/docs/apollo-server/getting-started" rel="noopener ugc nofollow" target="_blank">服务器</a>和<a class="ae ky" href="https://www.apollographql.com/docs/react/get-started" rel="noopener ugc nofollow" target="_blank">前端</a>上设置了Apollo之后，我向我的计数器添加了两个查询:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f912" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我更新了我的Redux片，并添加了两个按钮来保存和加载当前计数器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="af18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是现在，就像Redux一样，我们的测试抛出了一个错误:</p><blockquote class="oe of og"><p id="c6b8" class="kz la nq lb b lc ld ju le lf lg jx lh oh lj lk ll oi ln lo lp oj lr ls lt lu im bi translated">固定冲突:在上下文中找不到“客户端”或作为选项传入。将根组件包装在<apolloprovider>中，或者通过选项传递一个ApolloClient实例。</apolloprovider></p></blockquote><p id="c07e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们遵循阿波罗的<a class="ae ky" href="https://www.apollographql.com/docs/react/development-testing/testing/" rel="noopener ugc nofollow" target="_blank">测试部分</a>，并将其集成到我们的自定义渲染中。我们可以从为GraphQL模拟添加一个选项开始，并为apollo创建一个可组合的测试提供程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7b28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以将这个可组合的提供者添加到我们的<code class="fe nk nl nm nn b">providers</code>中。请记住，<code class="fe nk nl nm nn b">providers</code>的顺序会影响我们如何添加提供商。</p><p id="2ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与函数合成的工作原理有关。列表中最左边的是内层的<code class="fe nk nl nm nn b">providers</code>，而最右边的是外层的<code class="fe nk nl nm nn b">providers</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c1ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我能够编写下面的测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1633" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！您现在能够在健康的环境中编写适当的测试了。此外，当您的应用程序变大时，您不会有任何问题，只要您继续创建可组合的测试提供者。</p><p id="71b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘了在<a class="ae ky" href="https://github.com/morintd/rtl-composable-providers" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上有一个完整的资源库。</p><p id="4d32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>