<html>
<head>
<title>Modify Ethereum Storage on Hardhat’s “mainnet” Fork</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">修改Hardhat的“mainnet”分支上的以太坊存储</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/modify-ethereum-storage-on-hardhats-mainnet-fork-8abb504f6388?source=collection_archive---------4-----------------------#2022-08-14">https://betterprogramming.pub/modify-ethereum-storage-on-hardhats-mainnet-fork-8abb504f6388?source=collection_archive---------4-----------------------#2022-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">分析了如何在以太坊状态中为不同类型的变量找到插槽以及如何读取和修改它们的值的例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/acae319cf7c7e0a104503e82e97dff93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RPrgiwDW3EGWoW2gBjyZhQ.jpeg"/></div></div></figure><p id="52f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Hardhat有一个很酷的功能，可以用<code class="fe ln lo lp lq b">hardhat_setStorageAt</code>手动设置任何存储槽的值。这个特性对于怀特·哈茨在以太坊<code class="fe ln lo lp lq b">mainnet</code>上演示一个有效的利用是有用的，不会造成真正的破坏。分叉<code class="fe ln lo lp lq b">mainnet</code>的能力对于集成测试的开发人员也很有用:模拟可能不会考虑到<code class="fe ln lo lp lq b">mainnet</code>中真实契约的所有特性。</p><p id="f4a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将建立一个Hardhat <code class="fe ln lo lp lq b">mainnet</code> fork，并通过几个例子来了解如何在fork上找到和修改真实契约中的存储变量。我们将讨论不同类型的变量，包括简单整数、打包值、映射和数组。</p><h1 id="fc28" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">设置mainnet分支</h1><p id="a39b" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">首先你需要安装一个安全帽。查看本教程，了解如何安装Hardhat并创建您的第一个项目:</p><ul class=""><li id="6e4f" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm mt mu mv mw bi translated"><a class="ae mx" href="https://hardhat.org/tutorial/setting-up-the-environment" rel="noopener ugc nofollow" target="_blank">https://hardhat.org/tutorial/setting-up-the-environment</a></li></ul><p id="0715" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">简而言之，你需要跑步:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="06d4" class="nc ls iq lq b gy nd ne l nf ng">$ mkdir modify-storage-tutorial<br/>$ cd modify-storage-tutorial</span><span id="c172" class="nc ls iq lq b gy nh ne l nf ng">$ npm init -y<br/>$ npm install dotenv hardhat <a class="ae mx" href="http://twitter.com/nomiclabs/hardhat-ethers" rel="noopener ugc nofollow" target="_blank">@nomiclabs/hardhat-ethers</a> <a class="ae mx" href="http://twitter.com/nomiclabs/hardhat-waffle" rel="noopener ugc nofollow" target="_blank">@nomiclabs/hardhat-waffle</a> ethereum-waffle ethers chai</span></pre><p id="9266" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在简单模式下，Hardhat在你的电脑上模拟区块链。在fork模式下，它会将您的请求重定向到一个具有真实区块链快照的服务器。例如，这样的API由alchemy.com的<a class="ae mx" href="https://www.alchemyapi.io/" rel="noopener ugc nofollow" target="_blank">和quicknode.com的</a>和<a class="ae mx" href="https://quicknode.com/" rel="noopener ugc nofollow" target="_blank">提供。</a></p><p id="ce79" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以查看他们关于如何叉以太坊<code class="fe ln lo lp lq b">mainnet</code>的教程:</p><ul class=""><li id="f307" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm mt mu mv mw bi translated"><a class="ae mx" href="https://docs.alchemy.com/alchemy/guides/how-to-fork-ethereum-mainnet" rel="noopener ugc nofollow" target="_blank">https://docs . alchemy . com/alchemy/guides/how-to-fork-ether eum-mainnet</a></li><li id="2bd9" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://www.quicknode.com/guides/web3-sdks/how-to-fork-ethereum-mainnet-with-hardhat" rel="noopener ugc nofollow" target="_blank">https://www . quick node . com/guides/web 3-sdks/how-to-fork-ether eum-mainnet-with-hard hat</a></li></ul><p id="fda1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，我们将使用炼金术API。您必须访问<a class="ae mx" href="https://www.alchemyapi.io/" rel="noopener ugc nofollow" target="_blank">https://www . alchemyapi . io</a>，注册并在其仪表盘中创建新应用。在那里，您将获得配置Hardhat所需的API密钥。将它放在<code class="fe ln lo lp lq b">.env</code>文件中，不要忘记将文件名添加到<code class="fe ln lo lp lq b">.gitignore</code>中，因为这个密钥是一个秘密:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="a9e4" class="nc ls iq lq b gy nd ne l nf ng">echo 'ALCHEMY_API_KEY=XXXXXXXXXX' &gt;&gt; .env<br/>echo '.env' &gt;&gt; .gitignore</span></pre><p id="e768" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在创建一个<code class="fe ln lo lp lq b">hardhat.config.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="np nq gj gh gi nr ns bd b be z dk translated">配置文件</p></figure><p id="d2ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，您可以检查一切是否正常:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="b375" class="nc ls iq lq b gy nd ne l nf ng">$ npx hardhat test</span></pre><h1 id="3bc5" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">如何修改单个槽变量</h1><h2 id="2998" class="nc ls iq bd lt nt nu dn lx nv nw dp mb la nx ny md le nz oa mf li ob oc mh od bi translated">更改Tether USD合同所有人地址</h2><p id="4d5a" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">USDT智能合同有一个公共变量<code class="fe ln lo lp lq b"><a class="ae mx" href="https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#readContract" rel="noopener ugc nofollow" target="_blank">address owner</a></code>。让我们找到它的插槽，并将其更改为我们的签名者地址。一旦完成，我们将能够运行一些特权方法，如增加总供应量。</p><p id="dd4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们添加一个与USDT通信的接口。该接口依赖于IERC20，因此我们需要安装Openzeppelin合同:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="a2e1" class="nc ls iq lq b gy nd ne l nf ng">$ npm install @openzeppelin/contracts</span></pre><p id="e4fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在添加一个<code class="fe ln lo lp lq b">contracts/IUSDT.sol</code>文件:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="0c98" class="nc ls iq lq b gy nd ne l nf ng">import "@openzeppelin/contracts/token/ERC20/IERC20.sol";</span><span id="4b15" class="nc ls iq lq b gy nh ne l nf ng">interface IUSDT is IERC20 {<br/>    function getOwner() external view returns (address);</span><span id="548b" class="nc ls iq lq b gy nh ne l nf ng">    function issue(uint256) external;<br/>}</span></pre><p id="6f85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个猜测是<code class="fe ln lo lp lq b">owner</code>变量位于零槽。这似乎是真的！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="np nq gj gh gi nr ns bd b be z dk translated">test/ChangeUSDTOwner.js</p></figure><p id="0909" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以运行测试来查看它是否通过:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="4e22" class="nc ls iq lq b gy nd ne l nf ng">$ npx hardhat test test/ChangeUSDTOwner.js</span></pre><h1 id="3344" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">薄荷USDT</h1><p id="fce7" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">现在我们是所有者，我们可以铸造额外的代币:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="e361" class="nc ls iq lq b gy nd ne l nf ng">const { expect } = require("chai");<br/>const { ethers } = require("hardhat");</span><span id="8132" class="nc ls iq lq b gy nh ne l nf ng">const usdtAddress = "0xdac17f958d2ee523a2206206994597c13d831ec7"</span><span id="7315" class="nc ls iq lq b gy nh ne l nf ng">// the slot must be a hex string stripped of leading zeros! no padding!<br/>// <a class="ae mx" href="https://ethereum.stackexchange.com/questions/129645/not-able-to-set-storage-slot-on-hardhat-network" rel="noopener ugc nofollow" target="_blank">https://ethereum.stackexchange.com/questions/129645/not-able-to-set-storage-slot-on-hardhat-network</a><br/>const ownerSlot = "0x0"</span><span id="63d1" class="nc ls iq lq b gy nh ne l nf ng">it("Mint USDT", async function () {<br/>    const usdt = await ethers.getContractAt("IUSDT", usdtAddress);<br/>    const [signer] = await ethers.getSigners();<br/>    const signerAddress = await signer.getAddress();</span><span id="8503" class="nc ls iq lq b gy nh ne l nf ng">    // storage value must be a 32 bytes long padded with leading zeros hex string<br/>    const value = ethers.utils.hexlify(ethers.utils.zeroPad(signerAddress, 32))</span><span id="eb80" class="nc ls iq lq b gy nh ne l nf ng">    await ethers.provider.send("hardhat_setStorageAt", [usdtAddress, ownerSlot, value])</span><span id="518f" class="nc ls iq lq b gy nh ne l nf ng">    expect(await usdt.getOwner()).to.be.eq(signerAddress)</span><span id="b190" class="nc ls iq lq b gy nh ne l nf ng">    const amount = 1000<br/>    const before = await usdt.totalSupply()<br/>    await usdt.issue(1000)<br/>    const after = await usdt.totalSupply()</span><span id="3a54" class="nc ls iq lq b gy nh ne l nf ng">    expect(after - before).to.be.eq(amount)<br/>})</span></pre><p id="6b4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行测试以查看它是否通过:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="8929" class="nc ls iq lq b gy nd ne l nf ng">$ npx hardhat test test/MintUSDT.js</span></pre><h1 id="fb26" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">如何修改映射</h1><h2 id="2c94" class="nc ls iq bd lt nt nu dn lx nv nw dp mb la nx ny md le nz oa mf li ob oc mh od bi translated">更改USDC用户余额</h2><p id="7ca9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">现在让我们在<a class="ae mx" href="https://etherscan.io/token/0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" rel="noopener ugc nofollow" target="_blank"> USDC智能合约</a>中更改一个用户余额。</p><p id="272a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用户余额存储在<code class="fe ln lo lp lq b">mapping(address =&gt; uint) balanceOf</code>变量中。</p><p id="c40d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过<code class="fe ln lo lp lq b">hardhat_setStorageAt</code>直接编辑平衡，但首先我们需要找到正确的插槽。这有点棘手。您可以在<a class="ae mx" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#mappings-and-dynamic-arrays" rel="noopener ugc nofollow" target="_blank">https://docs . solidy lang . org/en/latest/internals/layout _ in _ storage . html # mappings-and-dynamic-arrays</a>中查看映射是如何存储在以太坊存储中的</p><p id="757e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">基本上，用户余额存储在插槽中:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="33ea" class="nc ls iq lq b gy nd ne l nf ng">keccak256(padZeros(userAddress).mappingSlot)</span></pre><p id="b041" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用javascript来说就是:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="ab0a" class="nc ls iq lq b gy nd ne l nf ng">function getSlot(userAddress, mappingSlot) {<br/>    return ethers.utils.solidityKeccak256(<br/>        ["uint256", "uint256"],<br/>        [userAddress, mappingSlot]<br/>    )<br/>}</span></pre><p id="6f53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么我们怎么知道<code class="fe ln lo lp lq b">mappingSlot</code>？那是<code class="fe ln lo lp lq b">balanceOf</code>变量的槽？我们会用暴力解决它。你可以在<a class="ae mx" href="https://blog.euler.finance/brute-force-storage-layout-discovery-in-erc20-contracts-with-hardhat-7ff9342143ed" rel="noopener ugc nofollow" target="_blank">https://blog . Euler . finance/brute-force-storage-layout-discovery-in-ERC 20-contracts-with-hard hat-7ff 9342143 ed</a>中看到一个例子</p><p id="5b48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将通过一个简单的检查来强制它:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="5461" class="nc ls iq lq b gy nd ne l nf ng">async function checkSlot(erc20, mappingSlot) {<br/>    const contractAddress = erc20.address<br/>    const userAddress = ethers.constants.AddressZero</span><span id="644b" class="nc ls iq lq b gy nh ne l nf ng">    // the slot must be a hex string stripped of leading zeros! no padding!<br/>    // <a class="ae mx" href="https://ethereum.stackexchange.com/questions/129645/not-able-to-set-storage-slot-on-hardhat-network" rel="noopener ugc nofollow" target="_blank">https://ethereum.stackexchange.com/questions/129645/not-able-to-set-storage-slot-on-hardhat-network</a><br/>    const balanceSlot = getSlot(userAddress, mappingSlot)</span><span id="625e" class="nc ls iq lq b gy nh ne l nf ng">    // storage value must be a 32 bytes long padded with leading zeros hex string<br/>    const value = 0xDEADBEEF<br/>    const storageValue = ethers.utils.hexlify(ethers.utils.zeroPad(value, 32))</span><span id="c454" class="nc ls iq lq b gy nh ne l nf ng">    await ethers.provider.send(<br/>        "hardhat_setStorageAt",<br/>        [<br/>            contractAddress,<br/>            balanceSlot,<br/>            storageValue<br/>        ]<br/>    )<br/>    return await erc20.balanceOf(userAddress) == value<br/>}</span></pre><p id="7f99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是暴力方法:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="0804" class="nc ls iq lq b gy nd ne l nf ng">async function findBalanceSlot(erc20) {<br/>    const snapshot = await network.provider.send("evm_snapshot")<br/>    for (let slotNumber = 0; slotNumber &lt; 100; slotNumber++) {<br/>        try {<br/>            if (await checkSlot(erc20, slotNumber)) {<br/>                await ethers.provider.send("evm_revert", [snapshot])<br/>                return slotNumber<br/>            }<br/>        } catch { }<br/>        await ethers.provider.send("evm_revert", [snapshot])<br/>    }<br/>}</span></pre><p id="c1b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">需要<code class="fe ln lo lp lq b">try..catch</code>和<code class="fe ln lo lp lq b">evm_revert</code>是因为随机存储修改可能会破坏契约并导致异常。</p><p id="0e8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们可以编写一个最终测试来检查我们是否可以在USDC契约中找到并修改用户余额:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="7df5" class="nc ls iq lq b gy nd ne l nf ng">it("Change USDC user balance", async function() {<br/>    const usdc = await ethers.getContractAt("IERC20", usdcAddress)<br/>    const [signer] = await ethers.getSigners()<br/>    const signerAddress = await signer.getAddress()<br/>    <br/>    // automatically find mapping slot<br/>    const mappingSlot = await findBalanceSlot(usdc)<br/>    console.log("Found USDC.balanceOf slot: ", mappingSlot)</span><span id="8ffb" class="nc ls iq lq b gy nh ne l nf ng">    // calculate balanceOf[signerAddress] slot<br/>    const signerBalanceSlot = getSlot(signerAddress, mappingSlot)<br/>    <br/>    // set it to the value<br/>    const value = 123456789<br/>    await ethers.provider.send(<br/>        "hardhat_setStorageAt",<br/>        [<br/>            usdc.address,<br/>            signerBalanceSlot,<br/>            ethers.utils.hexlify(ethers.utils.zeroPad(value, 32))<br/>        ]<br/>    )</span><span id="aa09" class="nc ls iq lq b gy nh ne l nf ng">    // check that the user balance is equal to the expected value<br/>    expect(await usdc.balanceOf(signerAddress)).to.be.eq(value)<br/>})</span></pre><p id="4ca8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行测试以查看它是否通过:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="d292" class="nc ls iq lq b gy nd ne l nf ng">npx hardhat test test/ChangeBalanceOf.js</span></pre><h1 id="8585" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">如何修改数组</h1><h2 id="e570" class="nc ls iq bd lt nt nu dn lx nv nw dp mb la nx ny md le nz oa mf li ob oc mh od bi translated">修改Aave LendingPoolAddressesProviderRegistry</h2><p id="5eda" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">让我们分析一个简单的例子，如何在Aave的<a class="ae mx" href="https://docs.aave.com/developers/v/2.0/the-core-protocol/addresses-provider-registry" rel="noopener ugc nofollow" target="_blank">LendingPoolAddressesProviderRegistry</a>中找到、读取和修改私有动态<code class="fe ln lo lp lq b">address</code>数组，该数组存储在<a class="ae mx" href="https://etherscan.io/address/0x52D306e36E3B6B02c153d0266ff0f85d18BCD413#code" rel="noopener ugc nofollow" target="_blank">0x 52d 306 e 36 e 3 b 6 b 02 c 153d 0266 ff 0 f 85d 18 BCD 413</a>。</p><p id="bb49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先我们需要知道一个<code class="fe ln lo lp lq b">address</code>数组是如何在以太坊状态下存储的:</p><ol class=""><li id="b48b" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm oe mu mv mw bi translated">诸如<code class="fe ln lo lp lq b">private</code>、<code class="fe ln lo lp lq b">public</code>或<code class="fe ln lo lp lq b">internal</code>的可见度修改符不影响存储机制</li><li id="c8d6" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm oe mu mv mw bi translated">对于一个<code class="fe ln lo lp lq b">address</code>动态数组，变量的槽<code class="fe ln lo lp lq b">p</code>存储元素的数量。例如，如果数组中有两个元素，那么槽<code class="fe ln lo lp lq b">p</code>存储<code class="fe ln lo lp lq b">0x02</code>。</li><li id="2226" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm oe mu mv mw bi translated">相应的两个元素从<code class="fe ln lo lp lq b">keccak256(p)</code>开始存储。</li><li id="aa7d" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm oe mu mv mw bi translated">即使<code class="fe ln lo lp lq b">address</code>类型是20字节长——每个数组元素仍然存储在一个单独的32字节槽中。因此，数组的第一个元素将位于槽位<code class="fe ln lo lp lq b">keccak256(p) + 0</code>，第二个元素将位于<code class="fe ln lo lp lq b">keccak256(p) + 1</code>。</li></ol><p id="537a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你对其他类型的数组的存储方式感兴趣，请阅读<a class="ae mx" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html#mappings-and-dynamic-arrays" rel="noopener ugc nofollow" target="_blank">https://docs . soliditylang . org/en/latest/internals/layout _ in _ storage . html # mappings-and-dynamic-arrays</a></p><p id="5e32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">LendingPoolAddressesProviderRegistry</code>的代码在<a class="ae mx" href="https://github.com/aave/protocol-v2/blob/master/contracts/protocol/configuration/LendingPoolAddressesProviderRegistry.sol" rel="noopener ugc nofollow" target="_blank">https://github . com/aave/protocol-v2/blob/master/contracts/protocol/configuration/lendingpooladdressesproviderregistry . sol</a></p><p id="06e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们对这部分感兴趣:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="af40" class="nc ls iq lq b gy nd ne l nf ng">contract LendingPoolAddressesProviderRegistry is ... {<br/>  mapping(address =&gt; uint256) private _addressesProviders;<br/>  address[] private _addressesProvidersList;<br/>  <br/>  ...</span><span id="325b" class="nc ls iq lq b gy nh ne l nf ng">  function getAddressesProvidersList() <br/>    external <br/>    view <br/>    returns (address[] memory) <br/>  { ... }</span><span id="b70e" class="nc ls iq lq b gy nh ne l nf ng">  function getAddressesProviderIdByAddress(<br/>    address addressesProvider<br/>  ) <br/>    external <br/>    view<br/>    returns (uint256)<br/>  { ... }</span><span id="0fde" class="nc ls iq lq b gy nh ne l nf ng">  ...</span></pre><p id="5b2d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们想找到<code class="fe ln lo lp lq b">_addressesProvidersList</code>插槽。首先让我们通过调用<code class="fe ln lo lp lq b">getAddressesProvidersList</code>方法来检查它的内容。为此，我们需要向我们的项目添加一个<code class="fe ln lo lp lq b">LendingPoolAddressesProviderRegistry</code>接口:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="535a" class="nc ls iq lq b gy nd ne l nf ng">interface ILendingPoolAddressesProviderRegistry {<br/>    function getAddressesProvidersList() external view returns (address[] memory);</span><span id="62b6" class="nc ls iq lq b gy nh ne l nf ng">    function getAddressesProviderIdByAddress(address addressesProvider) external view returns (uint256);<br/>}</span></pre><p id="ae7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们可以在Hardhat的控制台中运行它。使用以下命令运行控制台</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="2b05" class="nc ls iq lq b gy nd ne l nf ng">$ npx hardhat console</span></pre><p id="8473" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后运行javascript代码:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="10a4" class="nc ls iq lq b gy nd ne l nf ng">const target = await ethers.getContractAt("ILendingPoolAddressesProviderRegistry", "0x52D306e36E3B6B02c153d0266ff0f85d18BCD413")</span><span id="488a" class="nc ls iq lq b gy nh ne l nf ng">await target.getAddressesProvidersList()</span></pre><p id="4cd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="0f78" class="nc ls iq lq b gy nd ne l nf ng">[<br/>  '0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5',<br/>  '0xAcc030EF66f9dFEAE9CbB0cd1B25654b82cFA8d5'<br/>]</span></pre><p id="9752" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以这个数组有两个元素。现在我们知道了<code class="fe ln lo lp lq b">_addressesProvidersList</code>的槽存储了值<code class="fe ln lo lp lq b">0x02</code>。让我们阅读前几个槽来寻找值:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="95bc" class="nc ls iq lq b gy nd ne l nf ng">await ethers.provider.getStorageAt(target.address, "0x0")<br/>await ethers.provider.getStorageAt(target.address, "0x1")<br/>await ethers.provider.getStorageAt(target.address, "0x2")</span></pre><p id="7de7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="c28e" class="nc ls iq lq b gy nd ne l nf ng">0x000000000000000000000000b9062896ec3a615a4e4444df183f0531a77218ae<br/>0x0000000000000000000000000000000000000000000000000000000000000000<br/>0x0000000000000000000000000000000000000000000000000000000000000002</span></pre><p id="cb4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们分析一下存储布局:</p><ul class=""><li id="566e" class="mo mp iq kt b ku kv kx ky la mq le mr li ms lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">slot 0</code>被我们范围之外的变量使用。</li><li id="4f85" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">slot 1</code>似乎被映射<code class="fe ln lo lp lq b">_addressesProviders</code>使用，因为映射槽不存储元素，它总是零。</li><li id="ec0c" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><code class="fe ln lo lp lq b">slot 2</code>存储<code class="fe ln lo lp lq b">0x02</code>，似乎是<code class="fe ln lo lp lq b">_addressesProvidersList</code>的插槽！</li></ul><p id="4a3d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们将<code class="fe ln lo lp lq b">slot 2</code>的值改为<code class="fe ln lo lp lq b">0x03</code>，这样数组<code class="fe ln lo lp lq b">_addressesProvidersList</code>将有3个元素:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="2138" class="nc ls iq lq b gy nd ne l nf ng">await ethers.provider.send(<br/>  "hardhat_setStorageAt", [<br/>    target.address, </span><span id="4ebf" class="nc ls iq lq b gy nh ne l nf ng">    // the slot must be a hex string stripped of leading zeros! no padding!<br/>    // <a class="ae mx" href="https://ethereum.stackexchange.com/questions/129645/not-able-to-set-storage-slot-on-hardhat-network" rel="noopener ugc nofollow" target="_blank">https://ethereum.stackexchange.com/questions/129645/not-able-to-set-storage-slot-on-hardhat-network</a><br/>    "0x2",</span><span id="b3b3" class="nc ls iq lq b gy nh ne l nf ng">    // storage value must be a 32 bytes long padded with leading zeros hex string<br/>    ethers.utils.hexlify(ethers.utils.zeroPad(3, 32))<br/>  ]<br/>)</span></pre><p id="c188" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们调用<code class="fe ln lo lp lq b">getAddressesProvidersList</code>来看看这是否有效:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="b247" class="nc ls iq lq b gy nd ne l nf ng">await target.getAddressesProvidersList()</span></pre><p id="edc0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="c4da" class="nc ls iq lq b gy nd ne l nf ng">[<br/>  '0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5',<br/>  '0xAcc030EF66f9dFEAE9CbB0cd1B25654b82cFA8d5',<br/>  '0x0000000000000000000000000000000000000000'<br/>]</span></pre><p id="67ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">成功了！现在让我们将数组的第三个元素设置为<code class="fe ln lo lp lq b">0xDEADBEEF</code>:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="c0d5" class="nc ls iq lq b gy nd ne l nf ng">const arraySlot = ethers.BigNumber.from(ethers.utils.solidityKeccak256(["uint256"], [2]))<br/>const elementSlot = arraySlot.add(2).toHexString()<br/>const value = "0xDEADBEEF"<br/>const value32 = ethers.utils.hexlify(ethers.utils.zeroPad(value, 32))</span><span id="99e8" class="nc ls iq lq b gy nh ne l nf ng">await ethers.provider.send(<br/>  "hardhat_setStorageAt", [<br/>    target.address, <br/>    elementSlot, <br/>    value32,<br/>  ])</span></pre><p id="bd85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，如果我们再次运行<code class="fe ln lo lp lq b">getAddressesProvidersList</code>，我们将得到:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="a651" class="nc ls iq lq b gy nd ne l nf ng">[<br/>  '0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5',<br/>  '0xAcc030EF66f9dFEAE9CbB0cd1B25654b82cFA8d5',<br/>  '0x0000000000000000000000000000000000000000'<br/>]</span></pre><p id="81f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是为什么呢？我们不是改了第三要素吗？原因在于<code class="fe ln lo lp lq b">getAddressesProvidersList</code>的工作方式。它只输出存储在映射<code class="fe ln lo lp lq b">_addressesProviders</code>中的数组元素。请参见位于<a class="ae mx" href="https://github.com/aave/protocol-v2/blob/master/contracts/protocol/configuration/LendingPoolAddressesProviderRegistry.sol#L33" rel="noopener ugc nofollow" target="_blank">https://github . com/aave/protocol-v2/blob/master/contracts/protocol/configuration/lendingpooladdressesprovideregistry . sol # L33</a>的代码:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="3fd9" class="nc ls iq lq b gy nd ne l nf ng">for (uint256 i = 0; i &lt; maxLength; i++) {<br/>  if (_addressesProviders[addressesProvidersList[i]] &gt; 0) {<br/>    activeProviders[i] = addressesProvidersList[i];<br/>  }<br/>}</span><span id="c9e8" class="nc ls iq lq b gy nh ne l nf ng">return activeProviders;</span></pre><p id="8adc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，我们已经知道了<code class="fe ln lo lp lq b">_addressesProviders</code>映射的槽:它是<code class="fe ln lo lp lq b">slot 1</code>。我们可以直接将我们的<code class="fe ln lo lp lq b">0xDEADBEEF</code>添加到<code class="fe ln lo lp lq b">_addressesProviders</code>中:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="f94a" class="nc ls iq lq b gy nd ne l nf ng">const deadBeefSlot = ethers.utils.solidityKeccak256(<br/>  ["uint256", "uint256"],<br/>  [0xDEADBEEF, 1]<br/>)<br/>await ethers.provider.send(<br/>  "hardhat_setStorageAt",<br/>  [<br/>    target.address,<br/>    deadBeefSlot,<br/>    ethers.utils.hexlify(ethers.utils.zeroPad(1, 32))<br/>  ]<br/>)</span></pre><p id="cd4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再次检查我们的数组:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="ee6e" class="nc ls iq lq b gy nd ne l nf ng">await target.getAddressesProvidersList()</span></pre><p id="24c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="d85d" class="nc ls iq lq b gy nd ne l nf ng">[<br/>  '0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5',<br/>  '0xAcc030EF66f9dFEAE9CbB0cd1B25654b82cFA8d5',<br/>  '0x00000000000000000000000000000000DeaDBeef'<br/>]</span></pre><p id="62ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太好了！值<code class="fe ln lo lp lq b">0x00000000000000000000000000000000DeaDBeef</code>存储为<code class="fe ln lo lp lq b">_addressesProvidersList</code>数组的第三个元素。</p><p id="8285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以运行完整的脚本，如下所示:</p><pre class="kg kh ki kj gt my lq mz na aw nb bi"><span id="31c9" class="nc ls iq lq b gy nd ne l nf ng">$ npx hardhat run scripts/ChangeAaveAddressProviderList.js</span></pre><h1 id="c560" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">с结束语</h1><p id="e6f9" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">在本文中，我们分析了几个例子，如何在以太坊状态中为不同类型的变量找到槽，如何读取和修改它们的值。我们研究了如何在USDT、USDC和Aave等合同中修改<code class="fe ln lo lp lq b">public address</code>、<code class="fe ln lo lp lq b">public mapping(address =&gt; uint)</code>和<code class="fe ln lo lp lq b">private address[]</code>。</p><p id="3af0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种技巧一定会帮助你准备和展示工作的成功。如果你不是whitehat，而是一名开发人员，那么这肯定会帮助你编写集成测试。来自<a class="ae mx" href="https://mixbytes.io" rel="noopener ugc nofollow" target="_blank"> mixbytes </a>团队的材料。</p><p id="9875" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="of">祝你好运！</em></p><h1 id="67c4" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">链接</h1><ul class=""><li id="8109" class="mo mp iq kt b ku mj kx mk la og le oh li oi lm mt mu mv mw bi translated"><a class="ae mx" href="https://blog.euler.finance/brute-force-storage-layout-discovery-in-erc20-contracts-with-hardhat-7ff9342143ed" rel="noopener ugc nofollow" target="_blank"> Euler:与Hardhat签订的ERC20合同中的强力存储布局发现</a></li><li id="34fa" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://hardhat.org/tutorial/setting-up-the-environment" rel="noopener ugc nofollow" target="_blank">安全帽:设置环境</a></li><li id="da19" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://hardhat.org/hardhat-network/docs/guides/forking-other-networks" rel="noopener ugc nofollow" target="_blank">安全帽:分流其他网络</a></li><li id="9472" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://docs.alchemy.com/alchemy/guides/how-to-fork-ethereum-mainnet" rel="noopener ugc nofollow" target="_blank">炼金术:如何叉以太坊Mainnet </a></li><li id="375e" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://www.quicknode.com/guides/web3-sdks/how-to-fork-ethereum-mainnet-with-hardhat" rel="noopener ugc nofollow" target="_blank"> Quicknode:如何用Hardhat分叉以太坊Mainnet</a></li><li id="7baa" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://ethereum.stackexchange.com/questions/129645/not-able-to-set-storage-slot-on-hardhat-network" rel="noopener ugc nofollow" target="_blank">无法在安全帽网络上设置存储槽</a></li><li id="8845" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html" rel="noopener ugc nofollow" target="_blank">可靠性:状态变量在存储器中的布局</a></li><li id="09f3" class="mo mp iq kt b ku ni kx nj la nk le nl li nm lm mt mu mv mw bi translated"><a class="ae mx" href="https://docs.aave.com/developers/v/2.0/the-core-protocol/addresses-provider-registry" rel="noopener ugc nofollow" target="_blank"> Aave:地址提供商注册中心</a></li></ul></div></div>    
</body>
</html>