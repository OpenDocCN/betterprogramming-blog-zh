<html>
<head>
<title>Delicious React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">美味的React应用</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/delicious-react-recipes-43e75077de0e?source=collection_archive---------5-----------------------#2019-07-01">https://betterprogramming.pub/delicious-react-recipes-43e75077de0e?source=collection_archive---------5-----------------------#2019-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2fef" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提升您的应用的高级配方</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0e480ef72f2f91f35621c949bf2316bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cByq6lo3fvp5c1RZwqh_lw.png"/></div></div></figure><p id="a6aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我通常不做饭，但是当我做饭的时候，我<em class="ln">会按照食谱</em>来做，而且通常会做出美味的食物！</p><p id="98d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样的事情也适用于<strong class="kt ir">网络应用</strong>。通过遵循食谱，也称为<a class="ae lo" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式</a>，你可以得到一些美味的应用程序。</p><p id="99e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有很多方法可以帮助提升你的应用。在这篇文章中，我将带你浏览三个高级的，你可以添加到你的代码库，以改善你的<strong class="kt ir"> React应用的表现:</strong></p><ol class=""><li id="da86" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">上下文API</li><li id="b36d" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">展示/容器组件</li><li id="9a35" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">渲染道具</li></ol><h2 id="c015" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">我们开始做饭吧！</h2></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="a0a7" class="nd me iq bd mf ne nf ng mi nh ni nj ml jw nk jx mo jz nl ka mr kc nm kd mu nn bi translated"><strong class="ak">配方#1:上下文API </strong></h1><p id="eabd" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">为了清楚地了解我们的第一个<strong class="kt ir">配方</strong>是什么，让我们以这段代码为例:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="c20a" class="md me iq nu b gy ny nz l oa ob">import React from 'react';<br/>import Dashboard from 'components/Dashboard';<br/><br/>const user = {<br/>  name: "John Doe"<br/>}<br/><br/>const App = () =&gt; {<br/>    const { name } = user;<br/><br/>    return (<br/>        &lt;Dashboard user={ name } /&gt;<br/>    );<br/>};<br/><br/>export default App;</span></pre><p id="ceac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">向下传递一个道具不是一个大问题，但是如果我们在<code class="fe oc od oe nu b">&lt;Dashboard/&gt;</code>中有另一层组件会发生什么？</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="84da" class="md me iq nu b gy ny nz l oa ob">import React from 'react';<br/>import Profile from 'components/Profile';<br/><br/>const Dashboard = (props) =&gt; {<br/>    const { user } = props;<br/><br/>    return (<br/>        &lt;Profile user={ user } /&gt;<br/>    );<br/>};<br/><br/>export default Dashboard;</span></pre><p id="d9b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让<em class="ln">用户名</em>从<code class="fe oc od oe nu b">&lt;App/&gt;</code>进入<code class="fe oc od oe nu b">&lt;Profile/&gt;</code>，它需要通过<code class="fe oc od oe nu b">&lt;Dashboard/&gt;</code>，即使那个道具在那个级别没有被使用，所以我们最终通过一个不需要它的组件将那个道具传递到我们的树中。</p><p id="1ffa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想象一个更复杂的情况，在那里将<strong class="kt ir">令人沮丧的</strong>通过一堆不使用它的组件传递道具…</p><p id="db4b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想到的解决方案之一是使用<a class="ae lo" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> Redux </em> </a>，但这是一个复杂的实现。您所要做的就是沿着链向下传递一个道具，而不必通过中间组件。</p><blockquote class="of"><p id="65f8" class="og oh iq bd oi oj ok ol om on oo lm dk translated">但是如果我们可以从一个深度嵌套的组件中访问一个全局状态呢？</p></blockquote><p id="91e9" class="pw-post-body-paragraph kr ks iq kt b ku op jr kw kx oq ju kz la or lc ld le os lg lh li ot lk ll lm ij bi translated">谢天谢地，我们可以——使用<strong class="kt ir">上下文API。</strong></p><p id="2a96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React <a class="ae lo" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>作为一个实验特性已经存在一段时间了，但是只有在React的版本<a class="ae lo" href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" rel="noopener ugc nofollow" target="_blank"> 16.3.0 </a> <em class="ln">，</em>中它才可以安全地用于生产。</p><p id="ca1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">API解决了<strong class="kt ir">道具钻取</strong>的问题，让我们能够通过组件树传递数据，而不必在每一层手动传递道具。</p><h2 id="e336" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">这种行为是如何完成的？</h2><p id="b954" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">让我们以前面的例子为例，看看我们如何使用上下文API传递属性。</p><p id="4b96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们需要设置<strong class="kt ir">上下文</strong>:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="d9ea" class="md me iq nu b gy ny nz l oa ob">import React from "react";<br/><br/>const MyContext = React.createContext({});<br/><br/>export default MyContext;</span></pre><p id="d590" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，把我们的道具存放在<strong class="kt ir">供应商</strong>那里:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="0e9e" class="md me iq nu b gy ny nz l oa ob">import React from 'react';<br/>import Dashboard from 'components/Dashboard';<br/><br/>const props = {<br/>  name: "John Doe"<br/>}<br/><br/>const App = () =&gt; {<br/>    const { name } = props;<br/><br/>    return (<br/>        // wrap the app in our Provider<br/>        // pass in the value we want to access in our deeply nested component<br/>        &lt;React.Provider value={ name }&gt;<br/>            &lt;Dashboard /&gt;<br/>        &lt;/React.Provider&gt;<br/>    );<br/>};<br/><br/>export default App;</span></pre><p id="06dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，使用<strong class="kt ir">消费者</strong>访问<strong class="kt ir">提供者</strong>上存储的数据:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="b8e3" class="md me iq nu b gy ny nz l oa ob">import React from 'react';<br/><br/>const Profile = () =&gt; {<br/><br/>    return (<br/>        // consume the value holds by the Context's Provider<br/>        &lt;React.Consumer&gt;<br/>          { value =&gt; &lt;p&gt;{ value.user.name }&lt;/p&gt; }<br/>        &lt;/React.Consumer&gt;<br/>    );<br/>};<br/><br/>export default Profile;</span></pre><p id="4d3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们没有向<code class="fe oc od oe nu b">&lt;Dashboard/&gt;</code>传递任何属性，因为<em class="ln">用户名</em>只在我们的深层组件<code class="fe oc od oe nu b">&lt;Profile/&gt;</code>中需要。</p><p id="f4d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那<strong class="kt ir">是不是很牛逼</strong>？</p><h2 id="b2ff" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">那么，什么时候应该使用上下文API呢？</h2><ul class=""><li id="c9b1" class="lp lq iq kt b ku no kx np la ou le ov li ow lm ox lv lw lx bi translated">当你发现自己把道具传到树的深处时</li><li id="aa54" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">你需要一个<strong class="kt ir">全局状态</strong>(用户设置、翻译、主题等)</li><li id="ee05" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">有人告诉你在不需要的时候使用Redux</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="e475" class="nd me iq bd mf ne nf ng mi nh ni nj ml jw nk jx mo jz nl ka mr kc nm kd mu nn bi translated"><strong class="ak">配方#2:展示/容器组件</strong></h1><p id="5bda" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">现在，我要向你介绍我们的第二个配方，它是由<a class="oy oz ep" href="https://medium.com/u/a3a8af6addc1?source=post_page-----43e75077de0e--------------------------------" rel="noopener" target="_blank">丹·阿布拉莫夫</a>提出的，虽然他的文章<a class="ae lo" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">表示和容器组件</a>写于2015年，它已经很老了，但我仍然在我的React应用程序上使用它，因为我相信它是最重要的设计模式之一，它也可以应用于React范围之外。</p><p id="fca8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了给你更多的背景，让我们想象我们正在构建一个<strong class="kt ir">天气小部件应用</strong>。为此，我们必须做两件事:</p><ol class=""><li id="908e" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">从API请求一些天气数据</li><li id="1626" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">在页面上呈现数据</li></ol><p id="8b7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这看起来非常简单，让我们来构建它:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="8d7e" class="md me iq nu b gy ny nz l oa ob">import React from 'react';<br/><br/>class WeatherWidget extends React.Component {<br/>   state = { weather: null }<br/><br/>   componentDidMount() {<br/>      // fetch weather data<br/>      getWeather().then(weather =&gt; {<br/>         this.setState({ weather })<br/>      })<br/>   }<br/><br/>   render() {<br/>      // display weather data<br/>      return (<br/>         &lt;div&gt;<br/>            &lt;h1&gt;{ weather.city } - { weather.country }&lt;/h1&gt;<br/>            &lt;ul&gt;<br/>               &lt;li&gt;{ weather.temp }&lt;/li&gt;<br/>               &lt;li&gt;{ weather.description }&lt;/li&gt;<br/>            &lt;/ul&gt;<br/>         &lt;/div&gt;<br/>      )<br/>   }<br/>}<br/><br/>export default WeatherWidget;</span></pre><p id="d221" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很好——你对你的组件很有信心，因为它很小。但是，如果你需要添加更多的东西和逻辑，会发生什么呢？你最终肯定会得到一个臃肿的组件,这是一个庞大而复杂的组件:</p><ul class=""><li id="0d51" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm ox lv lw lx bi translated">难以理解</li><li id="9a61" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">难以修改/重用</li><li id="3b88" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">对其他用户不友好</li></ul><blockquote class="of"><p id="872f" class="og oh iq bd oi oj pa pb pc pd pe lm dk translated">如果有一个<em class="pf">关注点分离</em>不是更好吗？</p></blockquote><p id="78a2" class="pw-post-body-paragraph kr ks iq kt b ku op jr kw kx oq ju kz la or lc ld le os lg lh li ot lk ll lm ij bi translated">这正是表示和容器组件背后的关键思想。</p><p id="2aa3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回到我们的例子，我们有两个主要关注点:</p><ol class=""><li id="563b" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">UI关注点:它与在屏幕上显示数据更相关</li><li id="a23e" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">逻辑问题:它与管理状态有关，并从API请求数据</li></ol><p id="427e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每个问题都需要有自己的组成部分:</p><ul class=""><li id="be10" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm ox lv lw lx bi translated"><strong class="kt ir">呈现组件</strong>，负责呈现我们的布局</li><li id="bf1e" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated"><strong class="kt ir">容器组件</strong>，它基本上是负责管理我们组件的逻辑部分的组件</li></ul><p id="58cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住这一点，让我们重写<code class="fe oc od oe nu b">&lt;WeatherWidget/&gt;</code>来应用这一行为:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="d9b5" class="md me iq nu b gy ny nz l oa ob">// Presentation component</span><span id="0eab" class="md me iq nu b gy pg nz l oa ob">import React from 'react';<br/><br/>const WeatherWidget = (props) =&gt; {<br/>    const { weather } = props;<br/>    return (<br/>        &lt;div&gt;<br/>            &lt;h1&gt;{ weather.city } - { weather.country }&lt;/h1&gt;<br/>            &lt;ul&gt;<br/>                &lt;li&gt;{ weather.temp }&lt;/li&gt;<br/>                &lt;li&gt;{ weather.description }&lt;/li&gt;<br/>            &lt;/ul&gt;<br/>        &lt;/div&gt;<br/>    )<br/>}<br/><br/>export default WeatherWidget;</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><pre class="nt nu nv nw aw nx bi"><span id="9aa0" class="md me iq nu b gy ph pi pj pk pl nz l oa ob">// Container component</span><span id="a15a" class="md me iq nu b gy pg nz l oa ob">import React from 'react';<br/>import WeatherWidget from 'components/WeatherWidget';<br/><br/>class WeatherWidgetContainer extends React.Component {<br/>   state = { weather: null }<br/><br/>   componentDidMount() {<br/>      // fetch weather data<br/>      getWeather().then(weather =&gt; {<br/>         this.setState({ weather })<br/>      })<br/>   }<br/><br/>   render() {<br/>      // display weather data<br/>      return (<br/>        // the presentation component is responsible <br/>        // for visually displaying the widget<br/>        &lt;WeatherWidget weather={ this.state.weather }&gt;<br/>      )<br/>   }<br/>}<br/><br/>export default WeatherWidget;</span></pre><p id="0ef5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你所看到的，我们已经创建了一个<em class="ln">关注点分离</em>，并且使我们的组件更加简单易读。</p><h2 id="9455" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">为什么这是有用的？</h2><ul class=""><li id="feda" class="lp lq iq kt b ku no kx np la ou le ov li ow lm ox lv lw lx bi translated">这将使代码<strong class="kt ir">可读</strong></li><li id="d925" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">它将<strong class="kt ir">可维护</strong></li><li id="3ed1" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">这将使组件<strong class="kt ir">可重用</strong></li><li id="9961" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">这将使代码<strong class="kt ir">的每个块都是可测试的</strong></li></ul><h2 id="995c" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">你应该什么时候使用它？</h2><ul class=""><li id="a810" class="lp lq iq kt b ku no kx np la ou le ov li ow lm ox lv lw lx bi translated">当你的组件包含<strong class="kt ir">太多东西</strong></li><li id="e5f2" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">当有<em class="ln">混合</em>的<strong class="kt ir">逻辑</strong>和<strong class="kt ir">呈现</strong>时</li><li id="9a80" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">当你有一个<strong class="kt ir">臃肿的组件</strong></li></ul><p id="06b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过实现这种模式，你将使你的应用程序对你和其他开发者来说更加愉快。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="8f07" class="nd me iq bd mf ne nf ng mi nh ni nj ml jw nk jx mo jz nl ka mr kc nm kd mu nn bi translated"><strong class="ak">配方3:渲染道具</strong></h1><p id="c654" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">现在该给你介绍我们的<strong class="kt ir">第三招</strong>了。这是我学到的一种新的React设计模式——我真的很喜欢它背后的逻辑，并想与你分享。</p><p id="3892" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们对以前的食谱所做的那样，让我们举一个具体的例子。</p><p id="6502" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们想要构建一个<strong class="kt ir"> PuppyFeed </strong> <strong class="kt ir">应用程序</strong>，它将显示一个狗狗画廊，该组件需要:</p><ul class=""><li id="730b" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm ox lv lw lx bi translated">提出<code class="fe oc od oe nu b">GET</code>请求<strong class="kt ir">API/小狗</strong></li><li id="d1a3" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">显示一个<strong class="kt ir">装载旋转器</strong>等待</li><li id="2ff6" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">渲染小狗列表</li><li id="8c9f" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">如果错误，渲染<strong class="kt ir">错误</strong></li></ul><p id="9967" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你完成了应用程序的构建，它看起来令人难以置信，一切都按预期运行。但是有一天，你的经理找到你，问你这次能否用小猫做同样的事情。你感到非常自信，因为你已经设置好了几乎所有的东西，你只需要做一些小的调整，并遵循相同的模式。</p><p id="cb4f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这样做，你很快意识到你是在<strong class="kt ir">重复完全相同的代码——</strong>唯一的区别是<code class="fe oc od oe nu b">&lt;PuppyFeed/&gt;</code>显示的是<strong class="kt ir">小狗</strong>而<code class="fe oc od oe nu b">&lt;KittenFeed/&gt;</code>显示的是<strong class="kt ir">小猫</strong>。这是一个<em class="ln">抽象</em> <em class="ln">机会</em>，让我们为两者制作一个通用组件，称之为<code class="fe oc od oe nu b">&lt;PetFeed/&gt;</code>，并以这种方式使用它:</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="e245" class="md me iq nu b gy ny nz l oa ob">&lt;PetFeed pet='puppies' /&gt; 🐶<br/>&lt;PetFeed pet='kittens' /&gt; 🐱</span></pre><p id="8c5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">完美，抽象正确地完成了，并且它像预期的那样工作。但是，你的经理又一次找到你，想知道我们是否可以应用相同的逻辑，但是对于<strong class="kt ir">用户配置文件</strong>，它需要呈现用户表单而不是宠物图库。</p><p id="f01d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，你开始挠头，考虑如何将相同的逻辑用于宠物<em class="ln">和</em>并将其应用于用户资料。你决定使用一个<em class="ln">条件渲染技术</em>，根据给定的道具显示宠物图库或用户表单。</p><blockquote class="of"><p id="8de9" class="og oh iq bd oi oj ok ol om on oo lm dk translated">如果有另一种技术可以用来在React组件之间共享代码，那会怎么样呢？</p></blockquote><p id="9bc6" class="pw-post-body-paragraph kr ks iq kt b ku op jr kw kx oq ju kz la or lc ld le os lg lh li ot lk ll lm ij bi translated">这正是<a class="ae lo" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln">渲染道具</em> </a>负责的事情，太神奇了。</p><p id="4a3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">之所以叫<strong class="kt ir">渲染道具</strong>是因为我们传递给组件的道具名称叫<strong class="kt ir">渲染</strong>，但不一定要这样命名。</p><p id="a032" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">记住这一点，让我们重写<code class="fe oc od oe nu b">&lt;PetFeed/&gt;</code>来适应我们所有的三个场景——小狗、小猫和用户资料。</p><p id="28e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们首先需要定义它们的共同点和不同点。</p><h2 id="e77d" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">他们有什么共同点？</h2><ul class=""><li id="7baf" class="lp lq iq kt b ku no kx np la ou le ov li ow lm ox lv lw lx bi translated">它们都从API请求数据</li><li id="dfff" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">它们都显示出装载状态</li><li id="4944" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">它们都有一个错误状态</li></ul><h2 id="15b0" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">它们有什么不同？</h2><ul class=""><li id="0adc" class="lp lq iq kt b ku no kx np la ou le ov li ow lm ox lv lw lx bi translated">它们各自呈现不同的布局</li><li id="36bd" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">它们每个都可以渲染不同的加载微调器</li></ul><p id="ebd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所看到的，它们有共同的<strong class="kt ir">逻辑</strong>但有不同的<strong class="kt ir">呈现方式</strong>。让我们从将组件重命名为<code class="fe oc od oe nu b">&lt;Resource/&gt;</code>开始，并编写一些代码。</p><pre class="kg kh ki kj gt nt nu nv nw aw nx bi"><span id="232d" class="md me iq nu b gy ny nz l oa ob">// Puppies</span><span id="2b50" class="md me iq nu b gy pg nz l oa ob">import React from 'react';<br/>import Resource from 'components/Resource';<br/><br/>const PuppyFeed = () =&gt; (<br/>  &lt;Resource <br/>    path='api/puppies' render={ data =&gt; {<br/>      if (data.loading) return &lt;p&gt;Loading Puppies…&lt;/p&gt;<br/>      return data.paypload.map(puppy =&gt; &lt;div&gt;{ puppy }&lt;/div&gt;)<br/>    }}<br/>  /&gt;<br/>)<br/><br/>export default PuppyFeed;</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><pre class="nt nu nv nw aw nx bi"><span id="3d68" class="md me iq nu b gy ph pi pj pk pl nz l oa ob">// Kittens</span><span id="4387" class="md me iq nu b gy pg nz l oa ob">import React from 'react';<br/>import Resource from 'components/Resource';<br/><br/>const KittenFeed = () =&gt; (<br/>  &lt;Resource <br/>    path='api/kittens' render={ data =&gt; {<br/>      if (data.loading) return &lt;p&gt;Loading Kittens…&lt;/p&gt;<br/>      return data.paypload.map(kitten =&gt; &lt;div&gt;{ kitten }&lt;/div&gt;)<br/>    }}<br/>  /&gt;<br/>)<br/><br/>export default KittenFeed;</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><pre class="nt nu nv nw aw nx bi"><span id="eaba" class="md me iq nu b gy ph pi pj pk pl nz l oa ob">// User profile</span><span id="412a" class="md me iq nu b gy pg nz l oa ob">import React from 'react';<br/>import Resource from 'components/Resource';<br/><br/>const UserProfile = () =&gt; (<br/>  &lt;Resource <br/>    path='api/profile' render={ data =&gt; {<br/>      if (data.loading) return &lt;p&gt;Loading Profil…&lt;/p&gt;<br/>      return (<br/>        &lt;form&gt;<br/>          &lt;label&gt;Name&lt;/label&gt;<br/>          &lt;input value={ data.paypload.name }&gt;<br/>        &lt;/form&gt;<br/>      )<br/>    }}<br/>  /&gt;<br/>)<br/><br/>export default UserProfile;</span></pre><p id="a91b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里的想法是，在从API获得所需数据后，我们可以将我们的表示推迟到以后，这使得我们的组件非常灵活，经得起未来的考验。</p><h2 id="e8c3" class="md me iq bd mf mg mh dn mi mj mk dp ml la mm mn mo le mp mq mr li ms mt mu mv bi translated">什么时候应该使用渲染道具？</h2><ul class=""><li id="db38" class="lp lq iq kt b ku no kx np la ou le ov li ow lm ox lv lw lx bi translated">不要从渲染道具开始。从简单开始，以后再重构。</li><li id="a017" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">在组件之间共享逻辑，但不共享UI</li><li id="0bf5" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">其他开发者重用你的代码</li><li id="ca5e" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">将用户界面的呈现推迟到以后</li><li id="0899" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">处理不同组件中的常见状态/事件。</li></ul><h1 id="bc28" class="nd me iq bd mf ne pm ng mi nh pn nj ml jw po jx mo jz pp ka mr kc pq kd mu nn bi translated"><strong class="ak">最终想法</strong></h1><p id="f7b7" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">本文档中介绍的所有方法都必须处理管理状态，我不认为这是一个巧合——大多数错误来自于<em class="ln">不正确的</em> <em class="ln">状态管理。请记住，如果你真正了解你的应用程序的状态，你将对你的项目有更好的控制。</em></p><p id="0f91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">食谱很重要，有几个原因，它们是:</p><ul class=""><li id="7c9f" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm ox lv lw lx bi translated">经过战斗考验的</li><li id="b604" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">可分担的</li><li id="702a" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">使用起来很有趣</li><li id="ef74" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm ox lv lw lx bi translated">熟悉的</li></ul><p id="7337" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">祝你烹饪愉快！</p></div></div>    
</body>
</html>