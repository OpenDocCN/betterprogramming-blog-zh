<html>
<head>
<title>Exploring Inherited Widget in Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Flutter中探索继承的小部件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/exploring-inherited-widget-in-flutter-10ab959017cb?source=collection_archive---------4-----------------------#2022-01-24">https://betterprogramming.pub/exploring-inherited-widget-in-flutter-10ab959017cb?source=collection_archive---------4-----------------------#2022-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a85" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过示例了解如何使用继承的小部件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f18e907b4a0d2abc1995bbc736cd5870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pUi3vkj06Vqp_sXeiI-UbQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">詹姆斯·哈里森在<a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="92f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一个用例，当互联网连接不可用时，您想要更新小部件树中的一些元素。实现这一点的一个可能方法是使用继承的小部件，它解决了您希望从树的任何位置访问数据的用例。</p><p id="e9a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能已经不知不觉地在Flutter中使用了继承的小部件。因为Flutter framework在内部使用它来解决多种用例，例如主题化、设备大小调整、路由等等。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="65b2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">但是什么是继承的小部件呢？</strong></h1><p id="eac6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">您在一个小部件树中嵌套了多个小部件，并且您试图访问树中某处的数据。</p><p id="bfa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过构造函数来传播数据，但这并不麻烦，所以继承的小部件就派上了用场。</p><p id="d93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的小部件树是继承的小部件的子部件，那么您可以在小部件树中的任何位置访问数据。</p><p id="da8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将一步一步来，看看如何使用继承的小部件？</p><p id="3236" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以为了使用继承的小部件，你必须在你的类中扩展它。例如:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6500" class="nb ma iq mx b gy nc nd l ne nf">class InheritedNetworkHandler extends InheritedWidget { </span><span id="fae0" class="nb ma iq mx b gy ng nd l ne nf">}</span></pre><p id="a626" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是只要你扩展<code class="fe nh ni nj mx b">InheritedWidget</code>，编译器就会抱怨——“缺少<code class="fe nh ni nj mx b">InheritedWidget.updateShouldNotify</code> <em class="nk">的具体实现”。</em>如果你跳到继承的小部件的定义(<code class="fe nh ni nj mx b">cmd + click</code>，你会看到它被定义为一个<code class="fe nh ni nj mx b">Abstract</code> <strong class="ky ir"> </strong>类，有两个方法:-</p><ul class=""><li id="2fd0" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><code class="fe nh ni nj mx b">createElement</code>，这是一个被覆盖的方法。</li><li id="1c42" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><code class="fe nh ni nj mx b">updateShouldNotify</code>，未实现的方法。</li></ul><p id="13e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将研究这种方法，让我们修复错误，-</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="4c37" class="nb ma iq mx b gy nc nd l ne nf">class InheritedNetworkHandler extends InheritedWidget {</span><span id="b3fc" class="nb ma iq mx b gy ng nd l ne nf">  @override<br/>  bool updateShouldNotify(InheritedWidget oldWidget) {<br/>    return true;<br/>  }<br/>}</span></pre><p id="01be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">返回类型</strong> : <br/>返回值决定了当继承的小部件中的数据发生变化时，Flutter是否应该重新绘制小部件。</p><blockquote class="nz oa ob"><p id="fcbf" class="kw kx nk ky b kz la jr lb lc ld ju le oc lg lh li od lk ll lm oe lo lp lq lr ij bi translated">注意:-在重绘的情况下，它只会重绘使用继承的小部件的小部件。</p></blockquote><p id="b40e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">参数</strong> : <br/>但是参数名<code class="fe nh ni nj mx b">OldWidget</code>是什么意思呢？<br/> <code class="fe nh ni nj mx b">OldWidget</code>是一个继承的小部件，在用新部件重建之前，使用旧数据。</p><p id="23ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在前面几行提到的数据是什么？</p><p id="8b72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们到达那里之前，你可能还会看到编译器在报错。我们将遵从编译器的建议，并且不要忘记将子参数传递给超类，因为它是一个必需的参数。子树将使用继承的小部件的数据。</p><p id="5147" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更新后的代码如下所示:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0a45" class="nb ma iq mx b gy nc nd l ne nf">class InheritedNetworkHandler extends InheritedWidget {</span><span id="e701" class="nb ma iq mx b gy ng nd l ne nf">  const InheritedNetworkHandler({required Widget child}) :      super(child: child);</span><span id="cdd1" class="nb ma iq mx b gy ng nd l ne nf">  @override<br/>  bool updateShouldNotify(covariant InheritedWidget oldWidget) {          return true;<br/>  }<br/>}</span></pre><p id="ed7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到数据，它是一个在继承的小部件中定义的字段。可以在整个子小部件树中访问该字段。我们将向继承的小部件添加一个字段:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="4e50" class="nb ma iq mx b gy nc nd l ne nf">class InheritedNetworkHandler extends InheritedWidget {</span><span id="5e2a" class="nb ma iq mx b gy ng nd l ne nf">  // Data hold by inherited widget<br/>  final bool isNetworkAvailable;</span><span id="6388" class="nb ma iq mx b gy ng nd l ne nf">  const InheritedNetworkHandler({required this.isNetworkAvailable, required Widget child}): super(child: child);</span><span id="afa2" class="nb ma iq mx b gy ng nd l ne nf">  @override<br/>  bool updateShouldNotify(covariant InheritedWidget oldWidget) { return true;<br/>  }<br/>}</span></pre><p id="c245" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这里我们定义了<code class="fe nh ni nj mx b">InheritedNetworkHandler</code> <em class="nk">中的<code class="fe nh ni nj mx b">isNetworkAvailable</code>属性。</em></p><blockquote class="nz oa ob"><p id="5bc3" class="kw kx nk ky b kz la jr lb lc ld ju le oc lg lh li od lk ll lm oe lo lp lq lr ij bi translated">注意:- <em class="iq"> isNetworkAvailable </em>被标记为final，因为继承的小部件是不可变的，这意味着这些数据在应用程序的生命周期中不会改变。<br/>改变它的唯一方法，是通过重建继承的小部件。</p></blockquote><p id="6c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以在任何子部件中访问继承部件的值，</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c269" class="nb ma iq mx b gy nc nd l ne nf">class ChildWidget extends StatelessWidget {<br/>  const ChildWidget({Key? key}) : super(key: key);</span><span id="67e7" class="nb ma iq mx b gy ng nd l ne nf">  @override<br/>  Widget build(BuildContext context) {<br/>  <br/>    // Something new?<br/>    final bool? isNetworkAvailable =   context.dependOnInheritedWidgetOfExactType&lt;InheritedNetworkHandler&gt;()?.isNetworkAvailable;</span><span id="8836" class="nb ma iq mx b gy ng nd l ne nf">    return Container();<br/>  }<br/>}</span></pre><p id="7e96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们正在使用一种方法<code class="fe nh ni nj mx b">dependOnInheritedWidgetOfExactType</code>。顾名思义，它试图在小部件树上找到给定类型T的具体实现。</p><p id="aa46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这对于跨部件使用来说是不是太长了？</p><p id="7e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">是的，它是，我们将简化它。我们将把它作为助手方法添加到<code class="fe nh ni nj mx b">InheritedNetworkHandler</code>:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="c98c" class="nb ma iq mx b gy nc nd l ne nf">class InheritedNetworkHandler extends InheritedWidget {<br/>  ...</span><span id="ebf2" class="nb ma iq mx b gy ng nd l ne nf">  static InheritedNetworkHandler? <em class="nk">of</em>(BuildContext context) =&gt; context.dependOnInheritedWidgetOfExactType&lt;InheritedNetworkHandler&gt;();<br/>}</span></pre><p id="1d7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了一个静态助手方法<code class="fe nh ni nj mx b">of</code>，它将<code class="fe nh ni nj mx b">BuildContext</code>作为参数并返回一个<code class="fe nh ni nj mx b">InheritedNetworkHandler</code>。让我们在子部件中使用它。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="f334" class="nb ma iq mx b gy nc nd l ne nf">class ChildWidget extends StatelessWidget {<br/>  const ChildWidget({Key? key}) : super(key: key);</span><span id="6e5d" class="nb ma iq mx b gy ng nd l ne nf">@override<br/>  Widget build(BuildContext context) {<br/>  <br/>    // Updated version<br/>    final bool? isNetworkAvailable = InheritedNetworkHandler.<em class="nk">of</em>(context)?.isNetworkAvailable;;</span><span id="2853" class="nb ma iq mx b gy ng nd l ne nf">   return Container();<br/>  }<br/>}</span></pre><p id="fcde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你以前遇到过<code class="fe nh ni nj mx b">of</code>方法吗？</p><ul class=""><li id="3253" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><code class="fe nh ni nj mx b">MediaQuery.of(context)</code></li><li id="c301" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><code class="fe nh ni nj mx b">Navigator.of(context)</code></li></ul><p id="8cc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看我告诉你你已经使用了一个继承的小部件，所以如果你跳到<code class="fe nh ni nj mx b">of</code> <em class="nk"> </em>方法的定义，它也使用<code class="fe nh ni nj mx b">dependOnInheritedWidgetOfExactType</code> <em class="nk">。现在每次你使用<code class="fe nh ni nj mx b">.of(context)</code> <em class="nk"> </em>你就知道它是干什么的了。</em></p><p id="4698" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将这些片段连接在一起，并看到完整的代码。</p><p id="1972" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了这个实现，我使用了<a class="ae kv" href="https://pub.dev/packages/connectivity_plus" rel="noopener ugc nofollow" target="_blank"> connectivity_plus </a>插件。<br/>还将把我们的<code class="fe nh ni nj mx b">InheritedWidget</code>包装在一个有状态的小部件上，这样这个小部件的任何状态变化都会重建<code class="fe nh ni nj mx b">InheritedWidget</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="27dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是继承的小部件的实现，现在我们来看看它的用法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><blockquote class="nz oa ob"><p id="977e" class="kw kx nk ky b kz la jr lb lc ld ju le oc lg lh li od lk ll lm oe lo lp lq lr ij bi translated">您可以在定义继承的小部件的上下文中访问它。</p></blockquote><p id="a014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，上下文只能由<code class="fe nh ni nj mx b">ChildWidget</code>子树使用。<br/>如果您导航到新路线，您将无法访问继承的小工具，因为上下文发生了变化。</p><p id="17ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想在整个应用程序中访问继承的小部件，用继承的小部件包装<code class="fe nh ni nj mx b">MaterialWidget</code>(上面代码片段中的选项2)。</p><p id="2269" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想知道当我在继承的小部件中更新数据时是否需要重新构建整个树，答案是否定的。</p><p id="a8fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Flutter执行某些优化，它只重建使用继承的小部件中的数据的小部件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="544c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><p id="b797" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">从Flutter团队继承的小部件的一些有用资源，</p><ul class=""><li id="bc11" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=Zbm3hjPjQMk" rel="noopener ugc nofollow" target="_blank">继承的小工具解释</a></li><li id="4701" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=1t-8rBCGBYw" rel="noopener ugc nofollow" target="_blank">继承的小部件(本周小部件)</a></li><li id="945d" class="nl nm iq ky b kz nu lc nv lf nw lj nx ln ny lr nq nr ns nt bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=LFcGPS6cGrY" rel="noopener ugc nofollow" target="_blank">使用继承的小部件管理应用程序状态</a></li></ul></div></div>    
</body>
</html>