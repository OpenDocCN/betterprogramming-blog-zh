<html>
<head>
<title>Building and Deploying a Simple App to Kubernetes Using “werf”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“werf”在Kubernetes上构建和部署一个简单的应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/building-and-deploying-a-simple-app-to-kubernetes-using-werf-51bee0b3718d?source=collection_archive---------6-----------------------#2022-04-21">https://betterprogramming.pub/building-and-deploying-a-simple-app-to-kubernetes-using-werf-51bee0b3718d?source=collection_archive---------6-----------------------#2022-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9454" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">知道如何使用开源工具</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8d4a737fa17121894a99a89f88f23a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVnGu4oC8Xa188UNHLkfHA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@michael75?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="7ed0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文着眼于构建一个极简应用程序的Docker映像，并使用名为werf的开源工具将其部署到Kubernetes集群。我还将展示如何在应用程序的代码和运行它的基础设施中进一步交付您的更改。</p><p id="0159" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用一个基于shell脚本的小型echo服务器作为示例应用程序。该服务器返回字符串<code class="fe ls lt lu lv b">Hello, werfer!</code>以响应<code class="fe ls lt lu lv b">/ping</code>端点请求。</p><p id="ebd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">T9】NB</strong>T12】。您可以探索这个极简应用程序的所有文件，并从 <a class="ae kv" href="https://github.com/werf/first-steps-example" rel="noopener ugc nofollow" target="_blank"> <em class="lw">这个资源库</em> </a> <em class="lw">下载它们。</em></p><p id="4332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在本文中使用的Kubernetes集群是基于<a class="ae kv" href="https://minikube.sigs.k8s.io/docs/" rel="noopener ugc nofollow" target="_blank"> minikube </a>的，因此您不需要任何特定的硬件来遵循指令:您的普通台式机/笔记本电脑就可以了。</p><h1 id="66f4" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">简短介绍</h1><p id="d14e" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">对于不熟悉这个CLI实用程序的人来说，werf在Kubernetes中实现了完整的应用交付工作流。它使用Git作为应用程序代码和配置的单一来源:</p><ul class=""><li id="cf6d" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">每次提交反映一个特定的应用程序状态；</li><li id="c1ea" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe ls lt lu lv b">werf</code>将其与容器注册中心(通过构建最终Docker映像的缺失层)和Kubernetes中运行的应用程序(通过重新部署已更改的资源)同步；</li><li id="2434" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe ls lt lu lv b">werf</code>还使用基于Git历史和用户定义的策略的独特算法来清理容器注册中心中过时的工件。</li></ul><p id="4688" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">werf的显著特点是集成了许多面向开发者和DevOps/SRE工程师的知名工具，如Git、Docker、container registry、CI system、Helm和Kubernetes。这些组件组合在一起，确保固执己见的CI/CD工作流将您的应用交付到Kubernetes。将它们结合在一起可以最大限度地减少实现CI/CD所需的工作。</p><p id="b158" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看它的实际效果。</p><h1 id="1c89" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">准备系统</h1><p id="e513" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在开始之前，在你的系统上安装最新的稳定版本的werf(来自稳定发布渠道的v1.2)(参考<a class="ae kv" href="https://werf.io/installation.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>)。</p><p id="9533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">文中给出的所有命令和动作都适用于Linux操作系统(在Ubuntu 20.04.03上测试)。虽然对于其他系统(如Windows和macOS)来说，这些命令通常是相同的，但可能存在细微的差异。<em class="lw">如果你对你的操作系统有任何特殊的要求，请查看本文末尾的链接。</em></p><h1 id="b6bf" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">建立形象</h1><p id="4de9" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先，我们必须创建应用程序本身。让我们创建一个工作目录(在我们的例子中，它是用户主目录中的app目录):</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="f7b8" class="nm ly iq lv b gy nn no l np nq">mkdir app</span></pre><p id="801c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在目录中创建一个hello.sh脚本，内容如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">hello.sh</p></figure><p id="8836" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在目录中初始化一个新的Git存储库，并提交第一批更改——我们刚刚创建的脚本:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="586c" class="nm ly iq lv b gy nn no l np nq">cd ~/app<br/>git init<br/>git add .<br/>git commit -m initial</span></pre><p id="3c34" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的应用程序将在Docker中构建和运行，所以让我们也创建一个Docker文件，其中包含构建应用程序映像的说明:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Dockerfile文件</p></figure><p id="2a29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让werf使用Dockerfile进行构建，我们需要在项目根目录下创建一个<code class="fe ls lt lu lv b">werf.yaml</code>配置文件，其中包含Dockerfile描述:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">werf.yaml</p></figure><blockquote class="nt nu nv"><p id="aa79" class="kw kx lw ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/werf/first-steps-example" rel="noopener ugc nofollow" target="_blank"> werf/first-steps-example </a>存储库的<a class="ae kv" href="https://github.com/werf/first-steps-example/tree/main/001_build" rel="noopener ugc nofollow" target="_blank"> this directory </a>中有一个存储库，其中包含到目前为止创建的文件。</p></blockquote><p id="c98d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经<strong class="ky ir">准备好构建我们的应用程序</strong>。注意，您需要将所有的变更提交到项目存储库(Dockerfile，等等)。)之前，即首先运行以下命令:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="810c" class="nm ly iq lv b gy nn no l np nq">git add .<br/>git commit -m FIRST</span></pre><p id="ceed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用下面的命令开始构建:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="3a55" class="nm ly iq lv b gy nn no l np nq">werf build</span></pre><p id="99ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到以下输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">werf构建输出</p></figure><p id="3418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要检查构建是否成功，请使用以下命令运行应用程序:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="22ab" class="nm ly iq lv b gy nn no l np nq">werf run app --docker-options="-ti --rm -p 8000:8000" -- /app/hello.sh</span></pre><p id="a5ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们仔细看看上面的命令。<code class="fe ls lt lu lv b">—-docker-options</code>选项指定了一组<a class="ae kv" href="https://docs.docker.com/engine/reference/run/" rel="noopener ugc nofollow" target="_blank"> Docker相关参数</a>，而要在容器中执行的命令(在末尾)前面有两个连字符。</p><p id="2753" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下<strong class="ky ir">是否一切正常，并按预期运行</strong>。为此，请在您的浏览器中访问<a class="ae kv" href="http://127.0.0.1:8000/ping" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/ping</a>或在另一个终端中使用以下CURL请求:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="9062" class="nm ly iq lv b gy nn no l np nq">curl <a class="ae kv" href="http://127.0.0.1:8000/ping" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/ping</a></span></pre><p id="da19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你应该看到“你好，沃弗！”问候。此外，正在运行的容器的日志中应该会出现以下消息:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="4744" class="nm ly iq lv b gy nn no l np nq">GET /ping HTTP/1.1<br/>Host: 127.0.0.1:8000<br/>User-Agent: curl/7.68.0<br/>Accept: */*</span></pre><h1 id="0e1d" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">准备部署</h1><p id="9ee4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">构建一个应用程序是问题的一半(甚至是三分之一)。毕竟，您仍然需要将它部署到生产服务器上。为此，让我们创建一个本地“生产”Kubernetes集群，并配置werf来使用它。以下是需要采取的步骤列表:</p><ul class=""><li id="5ee8" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">安装并运行minikube，一个最小的Kubernetes发行版(它是测试目的的理想选择)；</li><li id="9908" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">安装NGINX入口控制器，负责流量路由的集群组件；</li><li id="8ae6" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">编辑<code class="fe ls lt lu lv b">/etc/hosts</code>文件，使用应用程序域名启用群集访问；</li><li id="9ab8" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">登录Docker Hub，使用所需的凭证设置密码；</li><li id="edd1" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">将应用程序部署到Kubernetes。</li></ul><h2 id="b0ac" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">1.安装和运行minikube</h2><p id="2e57" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先，按照官方文档中的描述安装<a class="ae kv" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank"> minikube </a>。如果您已经安装了它，请确保您的版本是最新的。</p><p id="13be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们使用minikube启动一个Kubernetes集群:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="fcb2" class="nm ly iq lv b gy nn no l np nq"># Delete the existing minikube cluster (if there is one).<br/>minikube delete<br/># Start a new minikube cluster.<br/>minikube start --driver=docker</span></pre><p id="5bf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设置默认的Kubernetes名称空间，这样您就不必在每次使用kubectl时都输入它(注意，我们只配置默认名称，并不创建名称空间本身——我们稍后会这样做):</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="6f65" class="nm ly iq lv b gy nn no l np nq">kubectl config set-context minikube --namespace=werf-first-app</span></pre><p id="08fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您没有安装kubectl，有两种方法可以安装它:</p><ul class=""><li id="435d" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">使用<a class="ae kv" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">官方文件</a>手动安装；</li><li id="5e6e" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">使用minikube附带的kubectl二进制文件。为此，请运行以下命令:</li></ul><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="f994" class="nm ly iq lv b gy nn no l np nq">alias kubectl="minikube kubectl --"<br/>echo 'alias kubectl="minikube kubectl --"' &gt;&gt; ~/.bash_aliases</span></pre><blockquote class="nt nu nv"><p id="039e" class="kw kx lw ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">如果您选择第二个选项，那么在您第一次使用上面的别名调用kubectl时，将会下载并安装这个实用程序。</p></blockquote><p id="1d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过列出在新创建的集群中运行的所有pod来检查kubectl是否工作:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="1697" class="nm ly iq lv b gy nn no l np nq">kubectl get --all-namespaces pod</span></pre><blockquote class="nt nu nv"><p id="5067" class="kw kx lw ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">Pod是一个短暂的Kubernetes实体，它托管一个或多个应用程序容器以及在这些容器之间共享的资源。</p></blockquote><p id="550a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">运行此命令应该会产生类似于下面的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">kubectl get - all-namespaces pod</p></figure><p id="0ac0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仔细观察<code class="fe ls lt lu lv b">READY</code>和<code class="fe ls lt lu lv b">STATUS</code>列。如果所有的pod都有一个<code class="fe ls lt lu lv b">Running </code>状态，并且Ready列中的数字是1/1(注意左边的数字必须等于右边的数字)，那么我们的集群就可以使用了。如果您没有看到与上面类似的输出，请尝试等待一段时间，然后重新运行上面的命令(可能有些Pods没有时间启动)。</p><h2 id="1652" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">2.安装NGINX入口控制器</h2><p id="0496" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">下一步是安装和配置NGINX入口控制器。它会将外部HTTP请求路由到我们的集群。</p><p id="c6c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下命令安装它:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="53e8" class="nm ly iq lv b gy nn no l np nq">minikube addons enable ingress</span></pre><p id="d204" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此过程可能需要一些时间，具体取决于您电脑的性能。例如，我的机器花了大约四分钟安装这个插件。</p><p id="337d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该过程完成后，您应该会看到以下成功消息:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="225b" class="nm ly iq lv b gy nn no l np nq">The 'ingress' addon is enabled</span></pre><p id="5d51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">等待加载项启动并检查它是否工作:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="09f1" class="nm ly iq lv b gy nn no l np nq">kubectl -n ingress-nginx get pod</span></pre><p id="065f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到类似下面的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">kubectl -n ingress-nginx get pod</p></figure><p id="3ccf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一行是我们感兴趣的。<code class="fe ls lt lu lv b">Running</code>状态表示一切正常，控制器正在运行。</p><h2 id="e13b" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">3.编辑主机文件</h2><p id="6917" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">设置环境的最后一步是编辑<code class="fe ls lt lu lv b">hosts</code>文件，这样所有对测试域的请求都会在本地集群中结束。</p><p id="7f25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们将使用<code class="fe ls lt lu lv b">werf-first-app.test</code>地址。在终端中运行<code class="fe ls lt lu lv b">minikube ip</code>命令，查看它是否输出有效的IP地址。如果输出<strong class="ky ir">和</strong>看起来不像有效的IP地址(在我的例子中是<code class="fe ls lt lu lv b">192.168.49.2</code>，返回并重新安装minikube集群。</p><p id="5c2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，运行以下命令:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="4032" class="nm ly iq lv b gy nn no l np nq">echo "$(minikube ip) werf-first-app.test" | sudo tee -a /etc/hosts</span></pre><p id="0de3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以通过查看hosts文件来检查上述命令是否成功。应该有这样一句台词:<code class="fe ls lt lu lv b">192.168.49.2 werf-first-app.test</code>。</p><p id="cc3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们看看一切是否如预期的那样工作。为此，我们将向应用程序端点发送一个CURL请求:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="6712" class="nm ly iq lv b gy nn no l np nq">curl http://werf-first-app.test/ping</span></pre><p id="e7f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，NGINX入口控制器应返回404页面，指示端点尚不可用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">404页</p></figure><h2 id="ca64" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">4.登录Docker Hub</h2><p id="7a9d" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">现在，我们需要为构建的图像建立一个存储库。我们建议使用私有的Docker Hub库。为了方便起见，我们将使用应用程序名称(<code class="fe ls lt lu lv b">werf-first-app</code>)作为存储库名称。</p><p id="b75c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过运行以下命令登录Docker Hub:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="bcec" class="nm ly iq lv b gy nn no l np nq">docker login<br/>Username: &lt;DOCKER HUB USERNAME&gt;<br/>Password: &lt;DOCKER HUB PASSWORD&gt;</span></pre><p id="56e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到<code class="fe ls lt lu lv b">Login Succeeded</code>消息。</p><h2 id="65c6" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">5.为注册表访问创建密码</h2><p id="64d3" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">要使用私有注册表存储图像，您必须使用注册表登录凭据创建一个密码。请注意，机密必须位于与应用程序相同的名称空间中。</p><p id="29dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，您需要事先为应用程序创建一个名称空间:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="96de" class="nm ly iq lv b gy nn no l np nq">kubectl create namespace werf-first-app</span></pre><p id="fdf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该看到新名称空间已经创建的消息(<code class="fe ls lt lu lv b">namespace/werf-first-app created</code>)。</p><p id="46b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，创建一个名为<code class="fe ls lt lu lv b">registrysecret</code>的秘密:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="5187" class="nm ly iq lv b gy nn no l np nq">kubectl create secret docker-registry registrysecret \<br/>  --docker-server='<a class="ae kv" href="https://index.docker.io/v1/'" rel="noopener ugc nofollow" target="_blank">https://index.docker.io/v1/'</a> \<br/>  --docker-username='&lt;DOCKER HUB USERNAME&gt;' \<br/>  --docker-password='&lt;DOCKER HUB PASSWORD&gt;'</span></pre><p id="50b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果成功，您应该会看到一条消息<code class="fe ls lt lu lv b">secret/registrysecret created</code>。如果您在创建密码时出错，使用<code class="fe ls lt lu lv b">kubectl delete secret registrysecret</code>命令将其删除并重新创建。</p><blockquote class="nt nu nv"><p id="9cbd" class="kw kx lw ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">注意，上面描述的方法是在Kubernetes中创建秘密的标准方法。</p></blockquote><p id="cc0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就完成了将应用程序部署到集群的环境准备工作。</p><p id="c4c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用上面创建的秘密，通过在设置pod时在<code class="fe ls lt lu lv b">imagePullSecrets</code>字段中指定它，从注册表中提取应用程序映像。</p><h1 id="46b2" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">将应用程序部署到集群</h1><p id="3976" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在部署应用程序之前，我们必须创建定义所需资源的Kubernetes清单。为此，我们将使用舵图表格式。Helm图表(或Helm包)包含在Kubernetes集群中运行应用程序或服务所需的所有资源定义。</p><p id="5857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的应用程序需要三个K8s资源。部署负责在容器中运行应用程序，而入口和服务分别在集群中路由外部和内部流量。</p><p id="5381" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们以下面的文件结构结束:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">文件的结构</p></figure><p id="73e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将把上面提到的清单放在隐藏的<code class="fe ls lt lu lv b">.helm</code>目录的<code class="fe ls lt lu lv b">templates</code>子目录中。</p><p id="3015" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:您必须将包含清单的目录添加到<code class="fe ls lt lu lv b">.dockerignore</code>文件中，以便从Docker映像构建的上下文中排除这些文件:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="6b43" class="nm ly iq lv b gy nn no l np nq">/.helm/</span></pre><p id="8e2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们仔细看看我们的资源清单。</p><h2 id="926d" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">1.部署</h2><p id="60f6" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">部署资源创建一组用于运行应用程序的pod。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">部署</p></figure><p id="05db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，<code class="fe ls lt lu lv b">{{ .Values.werf.image.app }}</code>模板变量用于插入应用Docker图像的全名。注意，您必须使用在<code class="fe ls lt lu lv b">werf.yaml</code>中使用的相同组件名(在我们的例子中是<em class="lw"> app </em>)。</p><p id="298d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">werf自动将待构建图像的全名和其他<a class="ae kv" href="https://werf.io/documentation/v1.2/advanced/helm/configuration/values.html" rel="noopener ugc nofollow" target="_blank">服务值</a>插入舵图表值(<code class="fe ls lt lu lv b">.Values</code>)。您可以使用<code class="fe ls lt lu lv b">werf</code>键访问它们。</p><p id="0bec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">werf仅在添加的文件发生变化时(Dockerfile <code class="fe ls lt lu lv b">COPY/ADD</code>指令中使用的文件)或<code class="fe ls lt lu lv b">werf.yaml</code>本身发生变化时重建映像。重新构建会导致映像标记发生变化，这将自动导致部署更新。如果这些文件没有更改，应用程序映像及其相关部署将保持不变，这意味着应用程序在集群中的状态是最新的。</p><h2 id="d5c8" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">2.服务</h2><p id="38e5" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">服务资源允许集群中的其他应用程序连接到我们的应用程序。看起来是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">服务</p></figure><h2 id="6e5d" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">3.进入</h2><p id="c634" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">与前面的资源不同，服务入口开放了从集群外部<em class="lw">对我们的应用的访问。它的目的是将<code class="fe ls lt lu lv b">werf-first-app.test</code>公共领域的流量重定向到我们的Kubernetes服务。看起来是这样的:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="005b" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">部署应用程序</h2><p id="df42" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">让我们将配置更改(部署应用程序所需的K8s资源)提交给Git:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="30ea" class="nm ly iq lv b gy nn no l np nq">git add .<br/>git commit -m FIRST</span></pre><blockquote class="nt nu nv"><p id="9a1a" class="kw kx lw ky b kz la jr lb lc ld ju le nw lg lh li nx lk ll lm ny lo lp lq lr ij bi translated">在<a class="ae kv" href="https://github.com/werf/first-steps-example" rel="noopener ugc nofollow" target="_blank"> werf/first-steps-example </a>存储库的<a class="ae kv" href="https://github.com/werf/first-steps-example/tree/main/002_deploy" rel="noopener ugc nofollow" target="_blank"> this directory </a>中有一个存储库，其中包含到目前为止创建的文件。</p></blockquote><p id="be5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下命令启动部署过程:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="1871" class="nm ly iq lv b gy nn no l np nq">werf converge --repo &lt;DOCKER HUB USERNAME&gt;/werf-first-app</span></pre><p id="c0a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这个过程是否成功:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">werf汇聚输出</p></figure><p id="2494" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次运行:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="30c9" class="nm ly iq lv b gy nn no l np nq">curl <a class="ae kv" href="http://werf-first-app.test/ping" rel="noopener ugc nofollow" target="_blank">http://werf-first-app.test/ping</a></span></pre><p id="5140" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到以下响应:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="be05" class="nm ly iq lv b gy nn no l np nq">Hello, werfer!</span></pre><p id="4bad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜，您已经成功地将应用程序部署到了Kubernetes集群中！</p><h1 id="1212" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">对应用程序进行更改</h1><p id="384c" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">让我们试着修改我们的应用程序，看看werf如何将它重新构建并重新部署到集群中。</p><h2 id="1b00" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">缩放比例</h2><p id="2de4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们的web服务器作为web优先应用部署的一部分运行。让我们看看有多少副本正在运行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序的副本</p></figure><p id="e3fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，我们只有一个运行的副本(以werf-first-app开始的那个)。将其数量增加到四个:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="3cf9" class="nm ly iq lv b gy nn no l np nq">kubectl edit deployment werf-first-app</span></pre><p id="c36f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将打开一个包含清单文件内容的文本编辑器。找到<code class="fe ls lt lu lv b">spec.replicas</code>行，将副本数改为四:<code class="fe ls lt lu lv b">spec.replicas=4</code>。稍等片刻，检查正在运行的应用程序副本的数量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序的4个副本</p></figure><p id="8890" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们通过直接编辑清单并绕过Git，手动增加了集群中副本的数量。现在，运行<code class="fe ls lt lu lv b">werf converge</code>命令:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="9b8e" class="nm ly iq lv b gy nn no l np nq">werf converge --repo &lt;DOCKER HUB USERNAME&gt;/werf-first-app</span></pre><p id="40de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再次检查副本的数量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">副本的数量</p></figure><p id="04b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，<strong class="ky ir">正在运行的副本数量对应于Git </strong>中存储的清单中指定的数量(我们没有编辑它)。这是因为werf已经将集群状态恢复到当前Git提交中描述的状态。这种机制叫做<a class="ae kv" href="https://werf.io/documentation/v1.2/advanced/giterminism.html" rel="noopener ugc nofollow" target="_blank">Giterminism</a>(Git+determinism)。</p><p id="7852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了尊重这一原则并正确地做每一件事，您需要改变存储库中项目文件的副本数量。因此，让我们编辑<code class="fe ls lt lu lv b">deployment.yaml</code>文件并将更改提交到存储库:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">部署</p></figure><p id="988f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用以下命令提交更改并重建应用程序:</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="76aa" class="nm ly iq lv b gy nn no l np nq">werf converge —-repo &lt;DOCKER HUB USERNAME&gt;/werf-first-app</span></pre><p id="56d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们再次检查副本的数量:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">应用程序的4个副本</p></figure><p id="222e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，有四个副本。让我们把它们的数量减回1。为此，编辑<code class="fe ls lt lu lv b">deployment.yaml</code>文件，提交更改，并通过<code class="fe ls lt lu lv b">werf converge</code>命令重新部署应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h2 id="26bd" class="nm ly iq bd lz nz oa dn md ob oc dp mh lf od oe mj lj of og ml ln oh oi mn oj bi translated">更改代码</h2><p id="c69a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">目前，我们的应用程序用<code class="fe ls lt lu lv b">Hello, werfer!</code>来响应，让我们更改答案并将更新后的应用程序重新部署到集群中。在编辑器中打开<code class="fe ls lt lu lv b">hello.sh</code>，用别的东西替换现有的行(例如<code class="fe ls lt lu lv b">Say hello one more time!</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">新hello.sh</p></figure><p id="05b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，提交更改并运行<code class="fe ls lt lu lv b">werf converge</code>。我们最终会得到什么？</p><pre class="kg kh ki kj gt ni lv nj nk aw nl bi"><span id="114e" class="nm ly iq lv b gy nn no l np nq">curl <a class="ae kv" href="http://werf-first-app.test/ping" rel="noopener ugc nofollow" target="_blank">http://werf-first-app.test/ping</a><br/>Say hello one more time!</span></pre><p id="b480" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">恭喜你，一切正常，运行正常！</p><h1 id="0120" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">外卖食品</h1><p id="a8c3" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在本文中，我们使用werf为Kubernetes集群构建并部署了基本应用程序。我希望它能帮助您熟悉werf，并获得一些将应用程序部署到K8s的经验。</p><p id="c444" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文基于<a class="ae kv" href="https://werf.io/guides.html" rel="noopener ugc nofollow" target="_blank">在线自学指南</a>的<em class="lw">第一步</em>章节。为了尽可能地简洁，我选择不深入完整指南中涵盖的理论问题，例如Kubernetes模板和清单、运行应用程序的基本K8s资源(部署、服务、入口)、werf操作模式和Giterminism、在werf中使用Helm的特性等。你可以在上述指南中了解更多。那里还提供了更具体的说明，包括针对其他操作系统的说明。</p><p id="fa59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎在文章评论或<a class="ae kv" href="https://t.me/werf_io" rel="noopener ugc nofollow" target="_blank"> werf_io </a>电报聊天中提出任何问题和建议。</p><h1 id="c75a" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">资源</h1><ul class=""><li id="9432" class="mu mv iq ky b kz mp lc mq lf ok lj ol ln om lr mz na nb nc bi translated"><a class="ae kv" href="https://werf.io/" rel="noopener ugc nofollow" target="_blank">werf . io</a>—werf实用程序官方网站；</li><li id="d4ae" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://werf.io/documentation/v1.2/advanced/giterminism.html" rel="noopener ugc nofollow" target="_blank"> Giterminism </a> —关于Giterminism，实用程序使用的原理；</li><li id="8800" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><a class="ae kv" href="https://github.com/werf/first-steps-example" rel="noopener ugc nofollow" target="_blank"> GitHub </a> —源代码库。</li></ul></div></div>    
</body>
</html>