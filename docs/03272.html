<html>
<head>
<title>Implement a Model-View-Presenter Architecture in Swift 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift 5中实施模型-视图-演示者架构</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/implement-a-model-view-presenter-architecture-in-swift-5-dfa21bbb8e0b?source=collection_archive---------2-----------------------#2020-01-31">https://betterprogramming.pub/implement-a-model-view-presenter-architecture-in-swift-5-dfa21bbb8e0b?source=collection_archive---------2-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4406" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用领域数据库作为业务逻辑层</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2440485df6c42ba2a2af3b28c7b6f8f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JxQh6_x-HmQ5dE40"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克-奥利维尔·乔多因</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="97ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将学习如何在iOS应用程序中实现模型-视图-展示者(MVP)设计模式。</p><p id="ce5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例项目是一个简单的应用程序，允许您向列表中添加项目，在<code class="fe lv lw lx ly b">UITableView</code>中显示它们，并使用<a class="ae ky" href="https://github.com/realm/realm-cocoa" rel="noopener ugc nofollow" target="_blank">领域数据库</a>对它们执行<code class="fe lv lw lx ly b">Create</code>、<code class="fe lv lw lx ly b">Read</code>和<code class="fe lv lw lx ly b">Delete</code>操作。</p><p id="7632" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该项目的源代码可在GitHub 上获得<a class="ae ky" href="https://github.com/zafarivaev/MVP-Demo" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/637547e97c045d063560c54f35cc4636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsG5-00nC1kDr3iCEfg7NA.png"/></div></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="4165" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">项目结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/bba788ab3571c3f88511ce7cd060985a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*IzERm-Dp2P84p5Bz4Tb5fA.png"/></div></figure><p id="570e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">项目的根分为三个文件夹:<code class="fe lv lw lx ly b">App</code>、<code class="fe lv lw lx ly b">Presenter</code>和<code class="fe lv lw lx ly b">View</code>。你还会发现<code class="fe lv lw lx ly b">Supporting Files</code>。</p><p id="16d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，这就是MVP中每个组件的职责:</p><ul class=""><li id="464c" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated"><code class="fe lv lw lx ly b">Model</code>是演示者使用的普通对象。在我们的例子中，它只是一个带有<code class="fe lv lw lx ly b">title</code>属性的<code class="fe lv lw lx ly b">Item</code>。</li><li id="c529" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe lv lw lx ly b">Presenter</code>独立于UIKit。它接收来自视图的消息，并执行所有业务逻辑。完成作业后，它为视图准备数据，以合适的格式显示。</li><li id="7cb3" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated"><code class="fe lv lw lx ly b">View</code>包含视图控制器和XIB文件(如果有的话),它本身并不做太多事情。它的职责是将事件发送给演示者并等待结果。得到结果后，如果需要，它会自我更新。</li></ul><p id="ec59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">清楚了这一点，让我们在实践中探索MVP架构。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="ea91" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">模型</h1><p id="2aa3" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这里我们定义了一个简单的领域<code class="fe lv lw lx ly b">Object</code>和一个<code class="fe lv lw lx ly b">title</code>属性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="0a8d" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">视角</h1><p id="f7e9" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">首先，我们应该定义我们的<code class="fe lv lw lx ly b">ItemsView</code>协议，而<code class="fe lv lw lx ly b">ItemsViewController</code>将遵循该协议。这里，我们定义了我们的<code class="fe lv lw lx ly b">ItemsPresenter</code>将根据特定业务逻辑任务的结果向<code class="fe lv lw lx ly b">ItemsViewController</code>发送数据的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="60f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们使<code class="fe lv lw lx ly b">ItemsViewController</code>符合<code class="fe lv lw lx ly b">ItemsView</code>协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="02a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在定义了<code class="fe lv lw lx ly b">Presenter</code>之后更新这个文件，这正是我们现在要做的。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="f814" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">提出者</h1><p id="4c7c" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">让我们定义一下<code class="fe lv lw lx ly b">ItemsPresenter</code>将遵循的<code class="fe lv lw lx ly b">ItemsViewPresenter</code>协议。在它里面，我们指定一个初始化器作为参数传入<code class="fe lv lw lx ly b">ItemsView</code>。</p><p id="3a78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还提供了<code class="fe lv lw lx ly b">ItemsViewController</code>将触发的事件方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="afee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以实现<code class="fe lv lw lx ly b">ItemsPresenter</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们将view声明为一个<code class="fe lv lw lx ly b">weak</code>属性以避免保留周期— <code class="fe lv lw lx ly b">View</code>应该拥有<code class="fe lv lw lx ly b">Presenter</code>，并且<code class="fe lv lw lx ly b">Presenter</code>应该能够通过其<code class="fe lv lw lx ly b">weak</code>与<code class="fe lv lw lx ly b">View</code>对话(不要太强！)财产。这里，我们也声明私有的<code class="fe lv lw lx ly b">items</code>和<code class="fe lv lw lx ly b">realm</code>属性。</p><h1 id="f8c6" class="mh mi it bd mj mk nv mm mn mo nw mq mr jz nx ka mt kc ny kd mv kf nz kg mx my bi translated">最后润色</h1><p id="5478" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">最后，让我们通过调用其中的<code class="fe lv lw lx ly b">ItemsPresenter</code>方法来更新我们的<code class="fe lv lw lx ly b">ItemsViewController</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="d583" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在剩下的就是将<code class="fe lv lw lx ly b">view</code>与<code class="fe lv lw lx ly b">presenter</code>钩住，并将<code class="fe lv lw lx ly b">rootViewController</code>放入<code class="fe lv lw lx ly b">AppDelegate.swift</code>内的<code class="fe lv lw lx ly b">window</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="02dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经成功地用一个领域数据库实现了一个MVP架构。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6b0b" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">包扎</h1><p id="0d17" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">有了MVP，我们在应用程序中有了明确的分工。现在，<code class="fe lv lw lx ly b">UIViewController</code>子类对<code class="fe lv lw lx ly b">Model</code>一无所知，所有的业务逻辑都在一个<code class="fe lv lw lx ly b">Presenter</code>内部实现。建议你看一下<a class="ae ky" href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52" rel="noopener">这篇文章</a>，我发现在学习MVP的时候真的很有帮助。</p><p id="16f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对不同的建筑模式感到好奇，请随意查看我的其他相关作品:</p><div class="oa ob gp gr oc od"><a href="https://medium.com/better-programming/this-is-how-you-implement-mvc-architecture-in-2020-b39d65b4212f" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">新MVC:单一责任原则和委托</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">苹果的模型视图控制器，终于做对了</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or ks od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://medium.com/better-programming/reactive-mvvm-and-the-coordinator-pattern-done-right-88248baf8ca5" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">反应式MVVM和协调模式做对了</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">使用Swift 5、RxSwift和RxDataSources</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="os l oo op oq om or ks od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://medium.com/better-programming/implement-a-service-oriented-architecture-in-swift-5-fc70b8117616" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">在Swift 5中实施面向服务的架构</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">为什么只用MVC/MVVM/蝰蛇还不够</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="ot l oo op oq om or ks od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://medium.com/better-programming/how-to-implement-viper-architecture-in-your-ios-app-rest-api-and-kingfisher-f494a0891c43" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">如何使用Swift 5在您的iOS应用中实现VIPER架构</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">使用方便的Xcode模板和参考报告</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="ou l oo op oq om or ks od"/></div></div></a></div><p id="6717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">非常感谢您的阅读！</p></div></div>    
</body>
</html>