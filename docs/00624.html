<html>
<head>
<title>Kubernetes: A Detailed Example of Deployment of a Stateful Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes:部署有状态应用程序的详细示例</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-a-detailed-example-of-deployment-of-a-stateful-application-de3de33c8632?source=collection_archive---------1-----------------------#2019-06-20">https://betterprogramming.pub/kubernetes-a-detailed-example-of-deployment-of-a-stateful-application-de3de33c8632?source=collection_archive---------1-----------------------#2019-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e384" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这篇文章是两部分系列的第二部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e795968349d31fe506c80032ea5d14d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XODQ5FYsqWyqr_TR9KrxiA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/photos/sMB8yPFnbAE" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@ihor_dvoretskyi" rel="noopener ugc nofollow" target="_blank"> Ihor Dvoretskyi </a>拍摄</p></figure><p id="d46d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本系列的<a class="ae kv" href="https://medium.com/engineering-zemoso/kubernetes-what-is-it-what-problems-does-it-solve-how-does-it-compare-with-its-alternatives-937fe80b754f" rel="noopener">第一部分</a>中，我们讨论了:</p><ul class=""><li id="8ab3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">什么是<a class="ae kv" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>？</li><li id="7ede" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它旨在解决什么问题？</li><li id="6647" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">什么时候应该选择使用Kubernetes？有哪些替代方案？</li></ul><p id="737e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将探索</p><ul class=""><li id="f2db" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Kubernetes的设计原则和架构<strong class="ky ir"> </strong>是什么？</li><li id="e377" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何使用Kubernetes，还有一个简单的例子。</li></ul><p id="a2a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要理解一个描述如何在Kubernetes上部署应用程序的例子，首先应该对Kubernetes的体系结构和对象有一个初步的了解。因此，我们将首先概述Kubernetes的设计原则和架构，然后简要解释相关的Kubernetes对象，最后是示例本身。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="b6c0" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">【Kubernetes背后的设计原则和架构</h1><p id="09da" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Kubernetes的架构遵循一套设计原则。为了更好地理解为什么Kubernetes是这样设计的，我们应该熟悉这些原则。那么，我们就从这里开始讨论吧。</p><h2 id="c254" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">Kubernetes的设计原则</h2><ul class=""><li id="9e77" class="ls lt iq ky b kz nf lc ng lf nw lj nx ln ny lr lx ly lz ma bi translated"><strong class="ky ir">便携:</strong> Kubernetes可以在任何地方跑。Kubernetes在各种环境中以一致的行为运行，包括公共云、私有云、内部部署或个人笔记本电脑。部署在Kubernetes上的应用程序可以轻松地跨不同的环境进行移植。</li><li id="c521" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">通用:</strong> Kubernetes对于可以通过它部署什么类型的应用程序没有任何限制。虽然它侧重于微服务和云原生应用程序的部署和管理，但任何类型的工作负载(批处理作业、无状态或有状态服务、遗留单片单实例应用程序)都可以通过Kubernetes部署。应用程序可以用任何语言或框架编写，没有任何限制。</li><li id="7a50" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">灵活:</strong> Kubernetes允许用定制的内置解决方案替换其许多功能。这提供了在必要时使用Kubernetes和一个专门的解决方案的能力。为了确保这种灵活性，Kubernetes被构建为一个可插拔组件和层的集合。</li><li id="bb8a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">可扩展:</strong> Kubernetes有助于在必要时添加专门的功能。这是通过公开接口来实现的，实现接口可以在现有功能的基础上添加新功能。这允许<a class="ae kv" href="https://github.com/kubernetes/kubernetes/tree/master/cluster/addons" rel="noopener ugc nofollow" target="_blank">为Kubernetes开发大量的附加组件</a>。</li><li id="7c7b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">可自动化:</strong> Kubernetes旨在减轻人工操作的负担。配置完成后，通过Kubernetes部署的应用将无需任何人工干预即可扩展和自我修复。Kubernetes可以与持续集成(CI)管道集成，允许开发人员提交的代码更改自动部署到测试环境中。</li></ul><p id="7585" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些原则都为使用Kubernetes的最终用户增加了巨大的价值。可移植性允许在各种环境下对应用程序进行可靠的测试，例如测试和生产，并防止被单一的云提供商或供应商所束缚。</p><p id="28da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通用目的使开发人员可以自由选择满足业务功能所需的开发工具和框架，而不必担心基础设施或部署。</p><p id="4d7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">灵活性和可扩展性允许在内置功能不足的地方添加定制功能。</p><p id="edf8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自动化确保维护大型应用程序所需的人工工作保持在最低水平。这允许相对较小的团队成功地维护部署在云上的大规模分布式应用程序。</p><p id="92ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们讨论Kubernetes架构，它是在考虑这些原则的基础上开发的</p><h2 id="bd06" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">库伯内特斯的建筑</h2><p id="9290" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">高级Kubernetes由主系统和工人组成。主系统控制工人并在他们身上运行应用程序。集群的期望状态(计算资源)被表示为抽象对象。这些抽象的Kubernetes对象是意图的记录。Kubernetes将不断地工作，以确保这些抽象对象中表示的状态是集群的实际物理状态。外部客户端可以连接到主服务器，获取关于集群状态的信息，并根据需要发出命令来更改集群状态。</p><p id="eecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当人们希望更新集群的物理状态时，他们所要做的就是更新抽象的Kubernetes对象，Kubernetes会处理其余的事情。让我们更深入地讨论一下主系统和工人的组成。</p><h2 id="80c4" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">Kubernetes master的组件</h2><p id="dc31" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Kubernetes主系统，也称为控制面板，设计为一组组件。让我们简单讨论一下它的关键组件。</p><ul class=""><li id="021e" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir"> API服务器:</strong> Kubernetes大多使用REST API进行内外通信。所有抽象的Kubernetes对象都作为REST资源公开。API服务器是负责处理REST请求、验证它们并对相应的抽象Kubernetes对象执行适当的CRUD操作的组件。</li><li id="a602" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">集群状态存储:</strong>为了执行CRUD操作，API服务器需要一个后备数据存储。顾名思义，集群状态存储是一个持久性存储实例，它存储系统中配置的所有抽象Kubernetes对象的状态。群集状态存储支持监视功能。通过这一功能，每当对象发生变化时，所有协调组件都可以迅速得到通知。</li><li id="f11d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">控制器管理器:</strong>这是运行控制器的master的组件。控制器运行循环并监控实际的集群状态和抽象Kubernetes对象中表示的状态。每当集群状态的改变被通知时，它们负责执行必要的动作，使得实际状态和抽象状态彼此一致。Kubernetes有许多控制器，每个控制器负责一组不同的Kubernetes对象。</li><li id="141d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">调度器:</strong>它是master的组件，负责<strong class="ky ir"> </strong>在集群上分配物理资源，以运行添加到抽象数据存储中的应用程序/作业。这些调度决策是在考虑诸如硬件/软件约束等众多因素的情况下做出的。</li></ul><p id="3ce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubernetes主系统可以拥有这些组件的多个副本，以确保高可用性，并且可以与工作节点组件一起部署在单个物理实例上。但是，为了简单起见，安装脚本通常在同一台机器上启动所有主组件，并且不在这台机器上运行任何工作实例。</p><p id="3394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">确切的集群设置取决于最终用户的要求。对于较小的应用程序，同时具有主组件和工作组件的单个实例就足够了。对于较大的应用程序，定制工作对于配置Kubernetes集群是必不可少的。</p><h2 id="bc1e" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">Kubernetes worker的组件</h2><p id="8d91" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">工作实例或节点也由多个组件组成。Kubernetes worker组件的主要功能是处理来自master的指令，并在节点上执行。以下是工作节点的关键组件:</p><ul class=""><li id="3f39" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir"> Kubelet: </strong>它是worker的组件，负责确保主节点上调度的容器正在运行并且是健康的。</li><li id="9f66" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">容器运行时:</strong>容器运行时是负责运行容器的软件。Kubernetes支持几个运行时和任何对Kubernetes CRI 的实现。每个工作节点使用它来运行由主节点调度的容器化应用程序。Kubernetes不鼓励也不支持运行非容器化的应用程序。</li><li id="c7fd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> Kube proxy: </strong>是worker的组件，负责维护Worker上的网络规则，执行连接转发。这实质上实现了整个集群中高效和有效的通信。外部应用程序流量将通过这些组件重定向到适当的容器。</li></ul><h2 id="87b3" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak">外部Kubernetes客户端</strong></h2><p id="0a4d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">理论上，外部Kubernetes客户机可以是任何能够通过定义良好的REST API与API服务器通信的应用程序。但是最主要的选择是使用<a class="ae kv" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">ku bectl</a>T11】。</p><p id="718d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kubectl是一个命令行工具，供负责管理应用程序部署的最终用户使用。Kubectl用户可以在终端上执行命令。这些命令中的每一个都在后台被转换成一个API调用，并发送到Kubernetes master上的API服务器，在那里执行必要的操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/14d1e719c5f3626eedf968d2126e3569.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qC23lB5QHvlK88WorDzqLg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">高层库伯内特建筑</p></figure><p id="0ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们后退一步，看看Kubernetes的整体架构。人们可能会注意到，它被设计成一组松散耦合的组件一起工作，而不是一个单一的整体实例负责所有的功能。我们已经讨论了这种架构风格的各种优势。特别是，这种选择允许Kubernetes保持灵活性和延展性。</p><p id="4ae8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">选择使用<code class="fe ob oc od oe b">rest </code>来创建和更新集群配置可以确保在一个环境中创建的任何配置都可以在任何其他环境中工作。这允许在Kubernetes上创建的应用程序部署保持可移植性。</p><p id="2b92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">控制器管理器和调度器充当持续监视集群状态存储中抽象对象的变化的组件。它们在必要时向工作节点发送指令，以自动更新集群的实际状态。这种设计选择消除了大量的人工工作，并确保Kubernetes是一个自动系统。事实上，这种集群管理的声明式方法是导致Kubernetes被迅速采用的主要特性之一。</p><p id="fd29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过接口与容器运行时交互来选择只运行容器化的应用程序，这确保了任何类型的应用程序都可以在Kubernetes上运行，并允许Kubernetes保持通用目的。</p><p id="5c27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们可以看看Kubernetes中用于表示和管理集群状态的抽象对象。这些Kubernetes对象的知识是我们在深入研究这个例子之前需要理解的最后一块拼图</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="f202" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak"> Kubernetes物件</strong></h1><p id="7d91" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Kubernetes定义了一个<a class="ae kv" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/" rel="noopener ugc nofollow" target="_blank">大量的抽象对象</a>。为了简洁起见，我们将只讨论那些对理解我们的例子绝对必要的Kubernetes对象。</p><ul class=""><li id="ea13" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们知道，通过Kubernetes，我们可以运行容器化的应用程序。Kubernetes没有将单个容器抽象为一个Kubernetes对象，而是定义了<em class="nz"> pod，</em>，它是一组一个或多个容器。这种选择有一个好处。对于更简单的情况，系统中的每个pod可以代表单个容器。但是，每当需要部署与容器的核心业务功能不直接相关的附加功能时——比如对日志记录、缓存等的支持——我们可以选择将这些附加功能打包到单独的容器中，并将它们放在单个pod中。这确保了它们总是逻辑地在一起。Pods是可以在Kubernetes中创建和管理的最小可部署计算单元。它是最终用户实现的实际应用程序代码运行的地方。每个pod都有自己的IP地址，并且与主机完全分离。</li><li id="2f37" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">服务:</strong>在库伯内，<strong class="ky ir"> </strong>豆荚是挥发性的。为了确保高可用性和计算资源的最佳利用，Kubernetes可以动态地删除和创建pod。因此，pod的IP地址不是访问pod提供的业务功能的可靠方式。相反，Kubernetes建议使用一个<em class="nz">服务</em>来访问业务功能。Kubernetes服务是一种抽象，它定义了一组逻辑单元和访问它们的策略。每个Kubernetes服务都有一个IP地址，但与pod的IP地址不同，它是稳定的。Kubernetes服务持续跟踪系统中的所有pod，并识别其预期的目标pod。每当访问特定业务功能的请求到达服务时，它会将该请求重定向到当时系统中活动的一个pod的IP地址。理想情况下，要从集群外部访问pod，必须使用<a class="ae kv" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank"> <em class="nz">入口</em> </a> <em class="nz">。</em>然而，截至目前，Kubernetes <em class="nz"> Ingress </em>功能仍是测试版。<em class="nz"> </em>因此，在这个例子中，我们将使用一个服务对外公开流量。</li><li id="5695" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">持久卷和持久卷声明:</strong>管理存储与管理计算是截然不同的问题。Kubernetes定义了两个关键的抽象来处理这个问题，p <em class="nz">持久容量，</em>和p <em class="nz">持久容量声明</em>。在Kubernetes中，<strong class="ky ir"> </strong>持久卷是集群中的一块存储，已被提供给集群用于其存储需求。持久卷声明是应用程序请求消耗通过持久卷声明的抽象存储资源。要使持久存储对Kubernetes内部运行的应用程序可用，应该首先声明持久卷，然后配置应用程序来声明使用该卷。</li><li id="eb53" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">config map:</strong><em class="nz">config map</em>是一个Kubernetes抽象，旨在将依赖于环境的应用程序配置数据从容器化的应用程序中分离出来，使它们能够跨环境保持可移植性。</li><li id="be29" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">秘密:</strong>秘密<em class="nz">秘密</em>是包含少量敏感数据的对象，如密码、令牌或密钥。将如此敏感的信息隐藏起来，可以更好地控制其使用方式，并降低意外暴露的风险。</li><li id="b599" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">部署:</strong> <em class="nz">部署</em>是一个抽象概念，表示Kubernetes上实际部署的期望状态。部署对象通常包含所需的所有信息——获取和构建容器化应用程序的位置、预期打包和运行这些容器的pod的配置、应该维护的每个pod的副本数量、容器使用的配置映射和机密方面的应用程序配置的位置、数据存储的配置(如果应用程序需要持久的数据存储)。所有这些都可以在部署内部声明。虽然可以在Kubernetes中创建单独的pod和服务，但是建议使用部署来管理部署。通过使用部署对象，诸如转出、回滚和监控之类的典型操作得到了极大的简化。</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="a1bb" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated"><strong class="ak">如何使用Kubernetes，以及一个简单的例子</strong></h1><p id="0d89" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">现在我们已经了解了Kubernetes的基础知识，我们将详细了解一个简单的示例。在这个例子中，我们将使用Kubernetes部署一个web应用程序。我们将使用<a class="ae kv" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>作为我们的容器运行时。我们示例中的应用程序有三个不同的部分:</p><ul class=""><li id="732f" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">数据库(MySQL服务器)</li><li id="3438" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">后端(Java Spring Boot应用程序)</li><li id="312d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">前端(角度应用)</li></ul><p id="16e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在Kubernetes集群上部署所有这些组件。我们将有一个数据库副本，两个后端副本<em class="nz"> </em>和两个前端副本<em class="nz">。</em>前端实例将通过HTTP与后端通信。后端实例将与数据库通信。为了促进这种交流，我们必须相应地配置Kubernetes。</p><p id="5888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过创建Kubernetes对象来配置集群。这些Kubernetes对象将包含我们部署的期望状态。一旦这些对象被持久化到集群状态存储中，Kubernetes的内部架构将采取必要的步骤来确保集群状态存储中的抽象状态与集群的物理状态相同。</p><p id="1e12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用<a class="ae kv" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> kubectl </a>来创建对象。Kubernetes支持创建对象的命令式和声明式方式。生产环境通常由声明式方法配置。在这个例子中，我们将使用声明性方法。对于每个对象，我们将首先准备一个清单文件，一个包含与该对象相关的所有信息的<code class="fe ob oc od oe b">yaml</code>文件。然后我们将执行kubectl命令，<code class="fe ob oc od oe b">kubectl apply -f &lt;FILE_NAME&gt;</code>将对象持久化到集群状态存储中。</p><p id="5ec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将首先封装我们已经实现的应用程序代码。之后，我们将配置数据库的部署，然后是后端。我们将通过配置前端来结束示例。</p><h2 id="df67" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">第一步。将应用程序容器化，并将图像上传到容器图像注册表</h2><p id="e953" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">第一步是为我们已经实现的应用程序创建一个<em class="nz">容器映像</em>，并将其上传到<em class="nz">容器注册表</em>。</p><p id="b9d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器映像是容器化应用程序的打包形式。它可以跨计算机传输，就像任何普通文件一样。容器运行时环境可以使用容器映像创建容器化应用程序的运行实例。</p><p id="acdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器注册表通常是存储容器图像的集中存储库。人们可以将容器图像上传到容器注册中心，并在需要时随时随地下载它们。可用的容器注册服务有很多:<a class="ae kv" href="https://azure.microsoft.com/en-us/services/container-registry/" rel="noopener ugc nofollow" target="_blank"> Azure容器注册</a>、<a class="ae kv" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank"> Google容器</a> <a class="ae kv" href="https://cloud.google.com/container-registry/" rel="noopener ugc nofollow" target="_blank">注册</a>、<a class="ae kv" href="https://aws.amazon.com/ecr/" rel="noopener ugc nofollow" target="_blank"> Amazon ECR </a>等。在这个例子中，我们将使用<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker hub </a>,但是可以使用任何适合其用例的图像注册中心(公共的或私有的)。</p><p id="3dd3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将要部署的应用程序的前端用<a class="ae kv" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular框架</a>实现，后端用<a class="ae kv" href="https://spring.io/projects/spring-boot" rel="noopener ugc nofollow" target="_blank"> Spring Boot框架</a>实现。本文的最后一节提供了包含代码的GitHub库的链接。一旦我们按照我们的要求实现了代码，我们将使用构建工具构建可执行文件(在本例中是<!-- --> Angular CLI <!-- -->和<a class="ae kv" href="https://maven.apache.org/" rel="noopener ugc nofollow" target="_blank"> Maven </a>)。</p><p id="97e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将通过<a class="ae kv" href="https://docs.docker.com/engine/reference/commandline/image_build/" rel="noopener ugc nofollow" target="_blank">使用<code class="fe ob oc od oe b"><a class="ae kv" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank">Dockerfil</a>e</code>构建docker图像</a>来创建容器图像。本例中使用的前端和后端的Dockerfile如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">前端角度应用的Dockerfile文件</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">后端弹簧引导应用程序的docker文件</p></figure><p id="1f3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦创建了容器映像，我们就可以将它们上传到任何容器映像注册中心。在这里，我们将把这些图像上传到Docker Hub。我们已经上传了名为<code class="fe ob oc od oe b"><a class="ae kv" href="https://hub.docker.com/r/kubernetesdemo/to-do-app-frontend" rel="noopener ugc nofollow" target="_blank">kubernetesdemo/to-do-app-frontend</a></code>的前端图像和名为<code class="fe ob oc od oe b"><a class="ae kv" href="https://hub.docker.com/r/kubernetesdemo/to-do-app-backend" rel="noopener ugc nofollow" target="_blank">kubernetesdemo/to-do-app-backend</a></code>的后端图像。我们将从官方MySQL docker库<code class="fe ob oc od oe b"><a class="ae kv" href="https://hub.docker.com/_/mysql" rel="noopener ugc nofollow" target="_blank">mysql</a>.</code>获取数据库镜像，官方docker镜像一般没有任何前缀，比如<code class="fe ob oc od oe b">mysql</code>。非官方的图片需要有一个类似<code class="fe ob oc od oe b">kubernetesdemo/</code>的前缀。</p><p id="bc56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们必须在Kubernetes清单文件中提到这些图像的名称，我们将在下面看到。Kubernetes将在需要时在各自的集群节点上获取并运行这些映像。</p><h2 id="76d5" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated"><strong class="ak">第二步。设置Kubernetes集群和CLI </strong></h2><p id="10a4" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">建立Kubernetes集群有多种解决方案。不同的Kubernetes解决方案满足不同的需求:易维护性、安全性、控制、可用资源以及操作和管理集群所需的专业知识。人们可以参考官方文档<a class="ae kv" href="https://kubernetes.io/docs/setup/" rel="noopener ugc nofollow" target="_blank">来获得更多关于如何建立集群的细节。这个例子已经在本地(</a><a class="ae kv" href="https://kubernetes.io/docs/setup/minikube/" rel="noopener ugc nofollow" target="_blank"> Minikube </a>)和云提供商(<a class="ae kv" href="https://cloud.google.com/kubernetes-engine/" rel="noopener ugc nofollow" target="_blank"> GKE </a>)的设置中复制。<a class="ae kv" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> K </a> <a class="ae kv" href="https://github.com/kubernetes/kops" rel="noopener ugc nofollow" target="_blank"> ops </a>是一个旨在简化Kubernetes集群设置过程的项目。</p><p id="dd96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如前所述，我们将使用kubectl作为我们的CLI。安装说明<code class="fe ob oc od oe b">kubectl</code>可在处<a class="ae kv" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">找到。一旦安装了<code class="fe ob oc od oe b">kubectl</code>,它应该被配置为与我们已经设置的Kubernetes集群通信。在Minikube的情况下，<code class="fe ob oc od oe b">minikube start</code>命令会自动配置<code class="fe ob oc od oe b">kubectl</code>。对于云设置，可以在各自的快速入门指南中找到说明(例如:</a><a class="ae kv" href="https://cloud.google.com/kubernetes-engine/docs/quickstart" rel="noopener ugc nofollow" target="_blank"> GKE </a>)。</p><h2 id="6fc9" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">第三步。数据库配置设置</h2><p id="79c9" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">后端实例需要与数据库通信。连接数据库所需的所有配置细节都存储在一个配置文件中。</p><p id="b64c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看这个例子中的后端spring配置文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">后端配置文件</p></figure><p id="62cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个配置文件需要一些环境变量，比如<code class="fe ob oc od oe b">DB_USERNAME</code>、<code class="fe ob oc od oe b">DB_PASSWORD</code>、<code class="fe ob oc od oe b">DB_HOST</code>、<code class="fe ob oc od oe b">DB_NAME</code>。我们将通过<code class="fe ob oc od oe b">configMaps</code>和<code class="fe ob oc od oe b">secrets</code>将这些变量的值传递给Kubernetes。然后我们将配置后端pod从<code class="fe ob oc od oe b">configMaps</code>和<code class="fe ob oc od oe b">secrets</code>中读取环境变量。</p><p id="9333" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">MySQL数据库docker映像<a class="ae kv" href="https://docs.docker.com/samples/library/mysql/#environment-variables" rel="noopener ugc nofollow" target="_blank">需要一些环境变量</a>。我们需要配置以下环境变量<code class="fe ob oc od oe b">MYSQL_ROOT_PASSWORD</code>、<code class="fe ob oc od oe b">MYSQL_USER</code>、<code class="fe ob oc od oe b">MYSQL_PASSWORD</code>、<code class="fe ob oc od oe b">MYSQL_DATABASE</code>。</p><p id="bdd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们已经对应用程序所需的配置有了一个概念，我们将在Kubernetes集群中用所需的数据创建<code class="fe ob oc od oe b">configMaps</code>和<code class="fe ob oc od oe b">secrets</code>。</p><p id="51b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，为了保存数据库特定信息，我们将创建一个<code class="fe ob oc od oe b">configMap</code>和两个<code class="fe ob oc od oe b">secrets</code>。<code class="fe ob oc od oe b">configMap</code>将包含关于数据库设置的非敏感信息，如数据库托管位置和数据库名称。我们将定义一个<code class="fe ob oc od oe b">Kubernetes service</code>，这将暴露数据库的位置。<a class="ae kv" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/" rel="noopener ugc nofollow" target="_blank"> Kuberebetes DNS </a>将在运行时将数据库的<code class="fe ob oc od oe b">service</code>名称解析为实际的<code class="fe ob oc od oe b">ip address</code>。下面是configMap，在此示例中，它用于存储与数据库相关的非敏感信息</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="46f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将使用两个<code class="fe ob oc od oe b">secrets</code>来存储敏感数据。第一个<code class="fe ob oc od oe b">secret</code>将包含数据库根用户凭据，第二个<code class="fe ob oc od oe b">secret</code>将包含应用程序用户凭据。下面是这两个文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库根用户凭据</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">数据库应用程序用户凭据</p></figure><p id="4eeb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过执行<code class="fe ob oc od oe b">kubectl apply -f &lt;FILE_NAME&gt;</code>我们将在Kubernetes集群状态存储中创建<code class="fe ob oc od oe b">ConfigMap</code>和<code class="fe ob oc od oe b">Secret</code>对象。我们将<code class="fe ob oc od oe b">host</code>、<code class="fe ob oc od oe b">name</code>的值保存在该<code class="fe ob oc od oe b">ConfigMap</code>对象中，将<code class="fe ob oc od oe b">username</code>、<code class="fe ob oc od oe b">password</code>的值保存在<code class="fe ob oc od oe b">Secret</code>对象中。我们将在后面的步骤中访问这些<code class="fe ob oc od oe b">secrets</code>和<code class="fe ob oc od oe b">ConfigMaps</code>来配置我们的<code class="fe ob oc od oe b">deployments</code>。</p><p id="ece0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似地，前端的配置需要环境变量<code class="fe ob oc od oe b">SERVER_URI</code>来指示后端的宿主位置。我们将在配置后端<code class="fe ob oc od oe b">Deployment</code>后创建此<code class="fe ob oc od oe b">configMap</code></p><h2 id="972c" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">第四步。为数据库配置聚氯乙烯、服务和部署</h2><p id="21b0" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">我们的下一步是创建数据库设置所需的<code class="fe ob oc od oe b">services</code>和<code class="fe ob oc od oe b">deployments</code>。下面是为该应用程序中的数据库设置创建相关库本内特<code class="fe ob oc od oe b">Service</code>和库本内特<code class="fe ob oc od oe b">Deployment</code>的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在Kubernetes集群上部署MySQL数据库的配置</p></figure><p id="3002" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这个文件，我们创建了多个Kubernetes对象。首先，我们创建了一个名为<code class="fe ob oc od oe b">mysql</code>的Kubernetes <code class="fe ob oc od oe b">Service</code>，用于访问运行MySQL容器的pod。接下来，我们创建了一个1gb的<code class="fe ob oc od oe b">Persistent Volume Claim (PVC)</code>，这将导致<a class="ae kv" href="https://kubernetes.io/docs/concepts/storage/dynamic-provisioning/" rel="noopener ugc nofollow" target="_blank"> Kubernetes集群为MySQL动态分配</a>所需的持久存储(启用默认动态存储，如果您的集群中没有启用)。在这之后，我们创建了一个<code class="fe ob oc od oe b">Deployment</code>对象，它配置MySQL服务器在集群中的部署。在MySQL容器中，我们使用上一步中创建的<code class="fe ob oc od oe b">configMaps</code>和<code class="fe ob oc od oe b">services</code>注入了环境变量，如<code class="fe ob oc od oe b">MYSQL_ROOT_PASSWORD</code>、<code class="fe ob oc od oe b">MYSQL_USER</code>、<code class="fe ob oc od oe b">MYSQL_PASSWORD</code>和<code class="fe ob oc od oe b">MYSQL_DATABASE</code>。</p><h2 id="cb5a" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">第五步。为后端配置服务和部署</h2><p id="bd96" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">接下来，我们设置后端应用程序部署。下面是创建所需Kubernetes对象的<code class="fe ob oc od oe b">yaml</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="8ff1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们首先创建了一个类型为<code class="fe ob oc od oe b">LoadBalancer</code>的<code class="fe ob oc od oe b">Service</code>(如果您在本地运行Kubernetes，请使用<code class="fe ob oc od oe b">NodePort</code>)，它公开了后端实例。<code class="fe ob oc od oe b">Loadbalancer</code> type提供了一个<code class="fe ob oc od oe b">External-IP</code>，通过它可以从外部访问后端服务。(如果使用<code class="fe ob oc od oe b">minikube</code>，请将<code class="fe ob oc od oe b">minikube ip</code>与<code class="fe ob oc od oe b">port</code>一起使用)。接下来，我们创建了被配置为包含后端实例的两个副本的<code class="fe ob oc od oe b">Deployment</code>对象。然后从我们之前创建的<code class="fe ob oc od oe b">configMaps</code>和<code class="fe ob oc od oe b">secrets</code>中注入所需的环境变量。这个部署将使用我们在第一步中创建的映像<code class="fe ob oc od oe b">kubernetesdemo/to-do-app-backend</code>。</p><h2 id="6028" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">第六步。前端配置设置</h2><p id="57ed" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">前端期望以上步骤生成的后端的<code class="fe ob oc od oe b">External-IP</code>的值以环境变量<code class="fe ob oc od oe b">SERVER_URI</code>的形式传递。我们现在将创建一个配置映射来存储与后端设置相关的信息。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">存储与后端服务器URI相关的信息的配置映射</p></figure><p id="8078" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一步配置前端部署时，我们将使用这个<code class="fe ob oc od oe b">configMap</code>来注入<code class="fe ob oc od oe b">SERVER_URI</code>值。</p><h2 id="7004" class="nk mo iq bd mp nl nm dn mt nn no dp mx lf np nq mz lj nr ns nb ln nt nu nd nv bi translated">第七步。为前端配置服务和部署</h2><p id="4ebe" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">接下来，我们设置前端应用程序部署。下面是创建所需Kubernetes对象的<code class="fe ob oc od oe b">yaml</code>文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div></figure><p id="708f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们首先创建了一个<code class="fe ob oc od oe b">LoadBalancer</code>类型的<code class="fe ob oc od oe b">Service</code>(如果您在本地运行Kubernetes，请使用<code class="fe ob oc od oe b">NodePort</code>)，它公开了前端实例。<code class="fe ob oc od oe b">Loadbalancer</code>类型提供了一个<code class="fe ob oc od oe b">External-IP</code>，通过它可以从外部访问前端服务。(如果使用<code class="fe ob oc od oe b">minikube</code>，则使用<code class="fe ob oc od oe b">minikube ip</code>和<code class="fe ob oc od oe b">port</code>)。接下来，我们创建了被配置为包含前端实例的两个副本的<code class="fe ob oc od oe b">Deployment</code>对象。这个部署将使用我们在第一步中创建的映像<code class="fe ob oc od oe b">kubernetesdemo/to-do-app-frontend</code>。之后，我们从<code class="fe ob oc od oe b">configMap</code>注入环境变量<code class="fe ob oc od oe b">SERVER_URI</code>，这是我们在上面的设置中创建的。</p><p id="dce6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。我们的简单应用程序现在已经完全部署好了。此后，应用程序的前端应该可以从任何浏览器使用前端服务<code class="fe ob oc od oe b">External-IP</code>进行访问。Angular应用程序将通过HTTP调用后端，后端将与MySQL数据库通信，我们的应用程序数据将保存在该数据库中。下图显示了本例中描述的整体设置</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/139470239cbdb66b8b2bbc2ea4caf198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*78_FSXLxWFY8eOQS-zJ8qA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Kubernetes上待办应用部署设置的高级视图</p></figure><p id="83fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个部署现在由Kubernetes管理。如果其中一个pod因未知原因关闭，Kubernetes将在没有任何人工干预的情况下启动一个新的pod。使用<a class="ae kv" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> kubectl，</a>我们可以在任何需要的时候监控和更新这个部署。</p><h1 id="b203" class="mn mo iq bd mp mq oi ms mt mu oj mw mx jw ok jx mz jz ol ka nb kc om kd nd ne bi translated">外部链接</h1><ul class=""><li id="cdc8" class="ls lt iq ky b kz nf lc ng lf nw lj nx ln ny lr lx ly lz ma bi translated">本文中讨论的包含用于Kubernetes集群部署和配置的清单文件的GitHub存储库可以在这里找到<a class="ae kv" href="https://github.com/shri-kanth/kuberenetes-demo-manifests" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="7da7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">包含本文讨论的后端实现的GitHub库可以在这里找到<a class="ae kv" href="https://github.com/shri-kanth/kubernetes-demo-backend" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="0794" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">包含本文讨论的前端实现的GitHub存储库可以在<a class="ae kv" href="https://github.com/shri-kanth/kubernetes-demo-frontend" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li></ul></div></div>    
</body>
</html>