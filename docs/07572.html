<html>
<head>
<title>Writing Unit Tests for SwiftUI Views</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为SwiftUI视图编写单元测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/writing-unit-tests-for-swiftui-views-11aa5eb48d8e?source=collection_archive---------3-----------------------#2021-01-28">https://betterprogramming.pub/writing-unit-tests-for-swiftui-views-11aa5eb48d8e?source=collection_archive---------3-----------------------#2021-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bfb0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">确保您的应用程序运行良好</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b9a69dc75ee2b26b7af8f905914b54e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h1DjhmUwXIQhBJFe"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@dtravisphd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">大卫·特拉维斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="adca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">单元测试有助于我们确保我们的应用程序按预期工作，而不必在每次更改后启动应用程序并手动导航。与UI测试相比，它们测试的是孤立的单个视图，而不是完整的用户流。他们速度更快，注意力更集中。</p><p id="e61b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了容易开始，我们使用<code class="fe ls lt lu lv b">ContentView</code>。它最初是在创建新项目时生成的，并在屏幕中央绘制字符串<code class="fe ls lt lu lv b">“Hello, world!”</code>。是SwiftUI代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="51e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何测试它是否拉动了绳子<code class="fe ls lt lu lv b">“Hello, world!”</code>？一种方法是创建一个UI测试，就像创建UIKit一样。</p><p id="84fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是使用库<a class="ae kv" href="https://github.com/nalexn/ViewInspector" rel="noopener ugc nofollow" target="_blank"> ViewInspector </a>。</p><p id="3afb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ViewInspector是一个用于单元测试SwiftUI视图的库。它允许在运行时遍历视图层次结构，提供对底层<code class="fe ls lt lu lv b">View</code>结构的直接访问。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="3e1d" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">测试静态视图</h1><p id="6d2f" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在测试中，我们首先创建被测对象。在我们的例子中，那就是<code class="fe ls lt lu lv b">ContentView</code>。我们通过<code class="fe ls lt lu lv b">inspect().text().string()</code>访问<code class="fe ls lt lu lv b">Text</code>视图的<code class="fe ls lt lu lv b">text</code>，并且能够断言它。测试通过。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e6d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">ContentView</code>采用了<code class="fe ls lt lu lv b">Inspectable</code>协议，使神奇的库能够完成它的工作。</p><p id="7a5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们给我们的<code class="fe ls lt lu lv b">ContentView</code>添加一些额外的元素。除了<code class="fe ls lt lu lv b">“Hello, world!”</code>之外，还有一个<code class="fe ls lt lu lv b">navigationTitle</code>表示<code class="fe ls lt lu lv b">“Greetings”</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们重新运行我们的初始测试，它会失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/53b33a8b31cc9e05647fe54f48ab5434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B69LxRxV4S9B-2nWVaQBag.png"/></div></div></figure><p id="d8d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">的确<code class="fe ls lt lu lv b">inspect().text()</code>会失败。<strong class="ky ir">视图层次结构已经改变</strong>。应该是<code class="fe ls lt lu lv b">inspect().navigationView().text(0)</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6db1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">text(0)</code>表示<code class="fe ls lt lu lv b">Text</code>视图是我们<code class="fe ls lt lu lv b">NavigationView</code>中的第一个元素。测试通过。</p><p id="e1a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们后退一步。用户仍然可以看到<code class="fe ls lt lu lv b">"Hello, world!"</code>，但是<strong class="ky ir">测试需要改变，因为视图层次结构已经改变</strong>。测试与视图紧密耦合。当视图改变时，改变测试的行为经常被用作反对测试的论据。</p><p id="4e71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了缓解这个问题，我们提取了一个<code class="fe ls lt lu lv b">GreetingsView</code>。</p><p id="1bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将我们的视图分解成更小的构建块是一个很好的实践——为了可读性、可组合性，以及我们将很快看到的测试目的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">提取的问候视图</p></figure><p id="14eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们添加一个测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c247" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它看起来和我们最初的<code class="fe ls lt lu lv b">ContentView</code>和<code class="fe ls lt lu lv b">ContentViewTests</code>非常相似。我们开始在<code class="fe ls lt lu lv b">ContentView</code>内部使用新的<code class="fe ls lt lu lv b">GreetingsView</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="89fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">Text</code>视图现在是<code class="fe ls lt lu lv b">GreetingsView</code>的一部分。是时候为<code class="fe ls lt lu lv b">ContentView</code>调整测试了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6e3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">GreetingsViewTests</code>和<code class="fe ls lt lu lv b">ContentViewTests</code>都通过。但是有一个问题:我们测试同样的东西两次。<code class="fe ls lt lu lv b">ContentViewTests</code>和<code class="fe ls lt lu lv b">GreetingsViewTests</code>都测试用户是否与<code class="fe ls lt lu lv b">"Hello, world!”</code>打招呼，测试<code class="fe ls lt lu lv b">greetsWithHelloWorld</code>。</p><p id="7625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是重复测试。相反，我们可以在<code class="fe ls lt lu lv b">ContentViewTests</code>中测试<code class="fe ls lt lu lv b">GreetingView</code>是否出现在<code class="fe ls lt lu lv b">ContentView</code>中。然后我们可以测试在<code class="fe ls lt lu lv b">GreetingsViewTests</code>中向用户问候的措辞。我们改变<code class="fe ls lt lu lv b">ContentViewTests</code>来反映这个变化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="f859" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，我们:</p><ol class=""><li id="0d29" class="nd ne iq ky b kz la lc ld lf nf lj ng ln nh lr ni nj nk nl bi translated"><strong class="ky ir">排列</strong>:创建被测视图</li><li id="f417" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><strong class="ky ir">动作</strong>:浏览视图层次结构以获得我们感兴趣的元素</li><li id="3aae" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><strong class="ky ir">断言</strong>:对元素使用断言</li></ol></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="b0ff" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">添加逻辑</h1><p id="ac29" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">到目前为止，我们只测试了静态视图。可能有一种观点认为测试静态视图没有意义。毕竟，我们可以信任SwiftUI在使用视图<code class="fe ls lt lu lv b">Text("Hello, world")</code>时显示文本<code class="fe ls lt lu lv b">"Hello, world!"</code>。但是，我们仍然可以使用测试作为规范来告诉我们视图做了什么。我们可以读取测试的名称，而不是呈现视图或读取实现。</p><p id="0b2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，视图可能不会长时间保持静态。引入了逻辑，视图变成了动态的。</p><p id="ce0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们需要两个问候语，一个是针对登录用户的，另一个是针对客人的。创建<code class="fe ls lt lu lv b">UserState</code>来存储用户是否为<code class="fe ls lt lu lv b">loggedIn</code>和<code class="fe ls lt lu lv b">userName</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们在<code class="fe ls lt lu lv b">GreetingsView</code>使用新的<code class="fe ls lt lu lv b">UserState</code>。让我们从将它传递到构造函数中进行可测试性开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="98d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们改变测试以适应新的<code class="fe ls lt lu lv b">UserState</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5036" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们有一个名字为<code class="fe ls lt lu lv b">Peter</code>的<code class="fe ls lt lu lv b">loggedIn</code>用户，他会被问候为<code class="fe ls lt lu lv b">Hello, Peter!</code>。如果该应用程序是由一个未经认证的用户使用，一个客人，我们将显示<code class="fe ls lt lu lv b">Hello, world!</code>。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="b802" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">使用环境对象</h1><p id="1360" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">如果我们将状态移动到一个<code class="fe ls lt lu lv b">@EnvironmentObject</code>中，因为我们将在应用程序的多个视图中使用它，会怎么样？</p><p id="51f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe ls lt lu lv b">UserState</code>采用<code class="fe ls lt lu lv b">ObservableObject</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="a99c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">EnvironmentObject</code>是在我们的<code class="fe ls lt lu lv b">@main</code>中创建的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="0b5b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后用在<code class="fe ls lt lu lv b">GreetingsView</code>里。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d7a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要添加<code class="fe ls lt lu lv b">didAppear</code>功能来允许<code class="fe ls lt lu lv b">ViewInspector</code>测试视图。同步测试不会起作用。测试如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3fd9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不得不使用异步测试语法起初看起来很奇怪，但却是必需的。我们也需要对<code class="fe ls lt lu lv b">@State</code>和<code class="fe ls lt lu lv b">@Environment</code>使用异步测试。<code class="fe ls lt lu lv b">@ObservedObject</code>或<code class="fe ls lt lu lv b">@Binding</code>不需要，但出于<a class="ae kv" href="https://github.com/nalexn/ViewInspector/blob/master/guide.md#views-using-observedobject" rel="noopener ugc nofollow" target="_blank">测试一致性原因</a>仍应使用。</p><p id="92cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些人可能对在<code class="fe ls lt lu lv b">GreetingsView</code>中使用额外的可测试性代码有疑问。我个人认为可测试性比视图的实现美学更重要。</p><p id="8743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许未来苹果会提供SwiftUI视图的原生测试方案？也许我们会有新的工具为我们创建的每个新视图创建一个初始测试？让我们看看！</p></div></div>    
</body>
</html>