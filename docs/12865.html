<html>
<head>
<title>Solidity Storage Variables with Ethers.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Ethers.js的实度存储变量</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-storage-variables-with-ethers-js-ca3c7e2c2a64?source=collection_archive---------4-----------------------#2022-07-07">https://betterprogramming.pub/solidity-storage-variables-with-ethers-js-ca3c7e2c2a64?source=collection_archive---------4-----------------------#2022-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b1fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Ethers.js库访问字符串、动态数组、映射、结构和字节打包变量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/61d726286b1a0bc825d08bb62c096970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EsLTINlE9XJkO3fN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@live_for_photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">滕玉红</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="a6c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">*滚动到Ethers.js代码示例文章的后半部分，或者访问此</em> <a class="ae kv" href="https://github.com/hking2/solidity-storage-access" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> GitHub库</em> </a> <em class="ls">查看完整的代码和测试文件。</em></p><h1 id="68d9" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">以太坊和智能契约状态</h1><p id="cdf1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">以太坊虚拟机(EVM)上的数据使用改进的Merkle Patricia Trie数据结构进行组织。区块链上的每个块引用四个尝试:[全局]状态trie、存储trie、事务trie和接收trie。状态trie包含EOA(外部拥有的帐户)数据，作为地址到ETH余额的映射，而智能合同数据存储在指向状态trie的存储trie中。</p><p id="42b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">存储trie中的智能合约数据表示合约的持久状态，并且可以随着更新全局状态的事务而改变。在solidity smart contract中，动态变量存储在<strong class="ky ir">存储器</strong>中，这是持久的。在<strong class="ky ir">存储器</strong>中初始化的任何变量都是临时的，在执行下一个外部函数调用之前将被擦除。此外，不可修改的常量变量不占用存储空间，因此使用的气体更少。</p><h1 id="a7b0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">智能合同存储布局</h1><p id="5703" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">以太坊虚拟机(EVM)中的每个智能合约都有自己的永久存储空间，在键-值对的映射中包含32字节的槽(键和值都是32字节)。</p><h2 id="6360" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak">32字节的固定大小变量</strong></h2><p id="dac0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">固定大小的32字节变量(如字符串、uint256和int256)按照它们在智能协定中列出的顺序被分配到单独的存储槽。在<em class="ls"> StorageLayoutOne </em>契约中，常量变量<strong class="ky ir"> hello </strong>没有存储槽，因为它不能被修改。变量<strong class="ky ir"> numOne </strong>、<strong class="ky ir"> goodbye </strong>、<strong class="ky ir"> </strong>和<strong class="ky ir"> num </strong>分别使用存储槽0x0、0x1和0x2。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="9b98" class="mq lu iq nd b gy nh ni l nj nk">contract StorageLayoutOne {</span><span id="a81d" class="mq lu iq nd b gy nl ni l nj nk">​ ​ ​​string constant hello = "hello world"; // no storage<br/>​ ​ ​​uint256 numOne = 1; // slot 0x0<br/>​ ​ ​​string goodbye = "goodbye world"; // slot 0x1<br/>​ ​ ​​int256 num; // slot 0x2</span><span id="cbf4" class="mq lu iq nd b gy nl ni l nj nk">}</span></pre><h2 id="e79e" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak">固定大小变量&lt; 32字节</strong></h2><p id="01ac" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">少于32字节的固定大小变量将尽可能按字节打包到单个存储槽中。在<em class="ls"> StorageLayoutTwo </em>契约中，变量<strong class="ky ir"> lock </strong>、<strong class="ky ir"> byteX </strong>、<strong class="ky ir"> bytesY </strong>和<strong class="ky ir"> bytesZ </strong>都将被打包到槽0x0 (1+1+4+16 = 22字节)中。下一个变量<strong class="ky ir"> bytesA </strong>存储在槽0x1中，因为它不能放入前一个。最后，变量<strong class="ky ir"> bytesB </strong>和<strong class="ky ir"> bytesC </strong>被打包到槽0x2中。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="7b49" class="mq lu iq nd b gy nh ni l nj nk">contract StorageLayoutTwo {</span><span id="254a" class="mq lu iq nd b gy nl ni l nj nk">​ ​ ​​bool lock; // slot 0x0<br/> ​ ​​byte byteX; // slot 0x0<br/>​ ​ ​​bytes4 bytesY; // slot 0x0<br/>​ ​ ​​bytes16 bytesZ; // slot 0x0</span><span id="cc46" class="mq lu iq nd b gy nl ni l nj nk">​​​ ​ ​​bytes28 bytesA; // slot 0x1</span><span id="b4ca" class="mq lu iq nd b gy nl ni l nj nk">​​​ ​ ​​bytes16 bytesB; // slot 0x2<br/>​​​ ​ ​​bytes16 bytesC; // slot 0x2</span><span id="f902" class="mq lu iq nd b gy nl ni l nj nk">}</span></pre><p id="8f35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要注意的是，EVM对32字节进行操作，因此使用小于32字节的变量可能会由于额外的转换操作而导致更高的气体成本。然而，字节打包通过允许EVM编译器在同一个存储槽内组合对变量的多个读写操作来弥补这一点。因此，以最有效的方式将少于32字节的变量分组在一起以降低总的气体成本是很重要的。</p><h2 id="f4b0" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak">动态调整大小的变量</strong></h2><p id="9170" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">可能超过32字节的动态大小的变量(如动态数组和映射)使用keccak-256哈希算法哈希到防冲突存储位置，该算法伪随机地选择2个⁵⁶存储槽范围内的位置。如果你想知道，2 ⁵⁶ =</p><p id="3aef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi">115792089237316195423570985008687907853269984665640564039457584007913129639936</p><p id="1c6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这种广阔的存储空间(比已知宇宙中的恒星更多的可用插槽)，EVM可以分配存储位置而无需分配存储，因为每个键的分配距离其他任何键都以光年计。EVM不跟踪未分配的槽，查询一个槽将简单地返回零。</p><p id="ef9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">动态数组从由槽的散列确定的存储位置开始。后续数组项与前一项相邻。当数组项为16字节或更少时，应用字节打包规则。</p><p id="6405" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与数组相反，映射通过首先将映射键与存储槽连接起来，然后将其散列到一个唯一的槽来分散数据。</p><p id="7ca6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在StorageLayoutThree协定中，<strong class="ky ir"> arrayOfNums </strong>，槽0x0(填充为32字节)被散列以找到第一项arrayOfNums[0]的存储位置。对于<strong class="ky ir"> userBalances </strong>，用户的地址与槽0x1连接，并被散列以提供值的位置。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="cf8f" class="mq lu iq nd b gy nh ni l nj nk">contract StorageLayoutThree { ​</span><span id="46d4" class="mq lu iq nd b gy nl ni l nj nk">​ ​ uint[] public arrayOfNums; // slot 0x0 =&gt; keccak256(0x0)</span><span id="d77d" class="mq lu iq nd b gy nl ni l nj nk">​ ​ ​​mapping(address =&gt; uint256) public userBalances;<br/> ​ // slot 0x1 =&gt; keccak256(key + 0x1)</span><span id="7baf" class="mq lu iq nd b gy nl ni l nj nk">}</span></pre><p id="3c5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，映射通常嵌套在其他映射中，并且可能包含结构。同样，数组可以嵌套在其他数组中，也可以在数组中嵌套映射。当处理嵌套的数据结构时，可以用嵌套的keccak-256散列找到数据位置。本文下面的编码教程中提供了这样的例子。</p><h2 id="391a" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated"><strong class="ak">非存储变量</strong></h2><p id="83a7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">常数、枚举、结构定义、事件和用户定义的错误不使用存储空间。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="495d" class="lt lu iq bd lv lw nt ly lz ma nu mc md jw nv jx mf jz nw ka mh kc nx kd mj mk bi translated">Ether.js代码教程</h1><p id="e2d4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Ethers-JavaScript库提供了许多有用的工具来与以太坊区块链上的智能合约进行交互，包括直接访问存储变量的实用程序，下面将通过代码示例进行解释。完整的代码可以在这个<a class="ae kv" href="https://github.com/hking2/solidity-storage-access" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> GitHub库</strong> </a> <strong class="ky ir"> </strong>找到，包括一个智能合约示例和单元测试文件。</p><p id="0a3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要安装Ether.js，请在项目根目录的终端中键入以下命令:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="3157" class="mq lu iq nd b gy nh ni l nj nk">npm install ethers</span></pre><h2 id="364e" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">定义可重复使用的Ethers.js常量</h2><p id="c11f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这里有一些常量定义可以添加到我们的JavaScript文件的顶部，这将有助于编写更干净的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="5c96" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">用线串</h2><p id="d61b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">一个32字节的存储槽最多可以容纳32个字符的字符串，因此，如果要访问的字符串超过32个字符，就需要从多个连续的槽中读取数据。对于不超过32个字符的字符串，使用<strong class="ky ir"> getShortStr </strong>函数，对于超过32个字符的字符串，使用<strong class="ky ir"> getLongStr </strong>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="b1c8" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">数字</h2><p id="c84d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">256位数字占据了整个存储槽，因此它们不需要任何位移位，除非字节打包有优势，否则应该用作默认的整数类型。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="56de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的映射函数中将使用<strong class="ky ir"> getUint256 </strong>函数。</p><h2 id="685f" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">映射</h2><p id="f08e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">与只需要存储槽和约定地址参数的字符串和数字不同，映射需要一个附加的键参数。键加上存储槽被散列以找到对应于该键的值的位置。</p><p id="b18e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如,[EOA]地址到[uint256]余额的映射将采用参数:存储槽、合同地址和EOA地址。该槽被2分割以移除“0x”，因为该键已经包含指示十六进制数的“0x”。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="11d6" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">结构映射</h2><p id="b51b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">初始化的结构存储数据的方式类似于数组存储数据的方式；感染和字节包装(如果适用的话)。因此，在找到slot +键的散列之后，必须确定类型，因为结构通常保存各种类型的数据。对于这个函数，我将类型限制为字符串、字节或数字。最后，我们需要在结构中选择一个属性，它就像数组中的一个元素。项目编号将对应于结构属性的顺序。</p><p id="4b05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，此函数不处理字节打包的结构，而是假设结构属性占用全部存储槽。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="0a31" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">到结构中嵌套映射的映射</h2><p id="e6a6" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">最后一个映射函数处理映射中结构内部的映射。与前面的示例相比，“type”已被替换为“nestedKey”。我们不需要类型，因为映射将一种类型映射到另一种类型，这意味着最终值将是一种类型。在这种情况下，最终值被假定为Uint256。</p><p id="416e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">新参数nestedKey引用另一个映射中的结构内的映射的键。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="f01e" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">字节打包槽</h2><p id="2382" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">当少于32字节的连续变量被打包到单个槽中时，发生字节打包。以最有效的字节打包方式在smart contract的顶部一起定义所有少于32字节的变量是一种很好的做法，这样可以最大化存储空间并节省汽油。</p><p id="3ea4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要你会做基本的数学运算，写一份可靠的智能合同是很容易的。然而，访问字节打包的变量有点棘手，因为它需要通过存储槽移位来找到一个特定的变量。</p><p id="27fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript很难处理大数，这就是为什么对于大于6字节的字节大小递归调用这个函数，并返回完整变量的连接结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b254" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的动态数组函数中会用到<strong class="ky ir"> getBytePackedVar </strong>函数。</p><h2 id="be27" class="mq lu iq bd lv mr ms dn lz mt mu dp md lf mv mw mf lj mx my mh ln mz na mj nb bi translated">动态数组</h2><p id="f8b7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">数组被散列到一个存储位置，在这个位置上所有的项都是连续的。一旦定位了数组的头，就可以通过槽或位移位来找到后面的项。如果项目是16字节或更少，存储槽将被字节打包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="e237" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="c591" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">理解solidity智能契约存储对于编写高效、安全和数据优化的代码非常重要。Ethers.js提供了许多有用的方法，可用于访问智能合约持久状态中的存储变量。在您自己部署的智能合约上使用或修改上面提供的代码示例将有助于您更好地理解EVM的存储级别。</p></div></div>    
</body>
</html>