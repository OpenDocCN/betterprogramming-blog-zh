<html>
<head>
<title>Determine Soccer Player Jersey Colors From Video Footage Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python从视频片段中确定足球运动员球衣的颜色</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/determining-soccer-player-jersey-colors-from-video-footage-31365e12e39c?source=collection_archive---------8-----------------------#2022-10-21">https://betterprogramming.pub/determining-soccer-player-jersey-colors-from-video-footage-31365e12e39c?source=collection_archive---------8-----------------------#2022-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7791" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用K-均值聚类识别球员球衣颜色</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fb9b4f61f250e9ad7939dcf180c25243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlvTXQdqSIibAcfID1OPyQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Krzysztof Dubiel 在<a class="ae ky" href="https://unsplash.com/s/photos/soccer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="7177" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">足球是世界上最受欢迎的运动。在洪都拉斯(我出生的国家)，足球能够完全阻止许多事件，吸引大众的注意力，并在90分钟内将人群卷入情绪的漩涡。</p><p id="abb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从我记事起，我就是一个足球迷。我选择的球队是巴塞罗那足球俱乐部，我从五岁开始就支持他们。这些年来，我看到了各种各样的技术被实现来获得关于游戏中发生的事情和玩家表现的各种统计数据和信息。这些球员的数据会让我着迷，因为它指向了体育背后的数字游戏…任何认识我的人都可以证明我喜欢数字。</p><p id="e0f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在已经开发/实现的最有趣的技术应用中，一般来说，不仅用于足球，而且用于许多其他运动，是计算机视觉。计算机视觉(CV)是关于开发能够理解图像或视频等视觉数据的算法和/或人工智能的领域。CV功能极其强大，在Instagram滤镜、自动驾驶汽车、MRI重建、癌症检测等应用中司空见惯。</p><p id="01a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个项目中，我从Trace获取了一系列在不同足球比赛中拍摄的视频片段，并使用K-Means聚类算法确定了球员球衣的颜色。</p><p id="1f14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章将详细介绍我实现这个目标的过程。这里开发的例程将视频镜头作为输入，并生成一个包含聚类过程结果的pandas数据帧作为输出。这个项目需要我执行数据清理、聚类、图像/视频处理、图像中对象的初步分类、读取JSON文件以及各种pandas/numpy数组/列表操作。我将这篇文章分成三个不同的部分，您可以通过下面可点击的目录很容易地找到它们:</p><ul class=""><li id="181f" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="#5d33" rel="noopener ugc nofollow">图像处理基础</a></li><li id="a581" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#c6d6" rel="noopener ugc nofollow">从图像中提取颜色</a></li><li id="1e29" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#c83b" rel="noopener ugc nofollow">从视频文件中提取帧</a></li><li id="8d8c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#698c" rel="noopener ugc nofollow">从JSON文件中提取玩家包围盒</a></li><li id="3cee" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#b61b" rel="noopener ugc nofollow">实现K均值聚类以确定球员球衣颜色</a></li><li id="7227" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#fe40" rel="noopener ugc nofollow">制作快速可视化聚类结果的GUI</a></li><li id="4fe1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="#607b" rel="noopener ugc nofollow">结论</a></li></ul><p id="82bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">说完了，我们开始吧！</p><h1 id="5d33" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">图像/视频处理基础知识</h1><p id="a028" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">本节将涵盖对本项目很重要的图像和视频处理/操作的基础知识。我使用足球历史上我最喜欢的一个时刻作为参考图像，尝试各种可用的处理技术。那个时刻是2005年11月19日，罗纳尔迪尼奥代表巴塞罗那队对阵皇家马德里队的精彩进球，如下图所示。</p><p id="2c99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这张照片不仅勾起了我美好的回忆，它还包含了一些对我未来发展有用的元素。例如，它有一些非常清晰的玩家对象，我可以尝试为其生成边界框，它有大量的“字段”作为图像的一部分，我可以用它来学习如何屏蔽某些颜色，它有两个队的玩家，我可以用它来开始弄清楚如何对东西进行分类。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/6bcda5c5ec847fe4f8da66b3c8a52246.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iM7IsXFQkaGGsWDctuxwbw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">罗纳尔迪尼奥在2005年11月19日对阵皇家马德里的比赛中进球。图片由巴塞罗那足球俱乐部提供</p></figure><h2 id="475f" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">使用OpenCV加载图像</h2><p id="f06c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我需要做的第一件事是将图像加载到我的笔记本中。如果您已经将图像保存在电脑上，那么您可以简单地使用<code class="fe nt nu nv nw b">cv2.imread</code>功能。然而，对于我在这部分工作中使用的图片，我是通过URL获取的。加载图像需要我们:</p><ol class=""><li id="4c58" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">将我们的网址传入<code class="fe nt nu nv nw b">urllib.request.urlopen</code></li><li id="5ba1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">从URL中的图像创建一个numpy数组</li><li id="afa6" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">使用<code class="fe nt nu nv nw b">cv2.imdecode</code>从内存缓存中读取图像数据，并将其转换为图像格式。</li><li id="c506" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">由于<code class="fe nt nu nv nw b">cv2.imdecode</code>默认加载BGR格式的图像，我将使用<code class="fe nt nu nv nw b">cv2.cvtColor(img, cv2.COLOR_BGR2RGB)</code>来处理和渲染原始RGB格式的图像。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="2ff7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该过程的结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/8c2824648ae14257cccf6a2ac1a86ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*k3bDbsPL2GKzMxkzgFxFPA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用OpenCV在BGR空间加载图像。作者修改的图像。</p></figure><p id="e817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，我加载的这个图像中的颜色与原始图像中看到的颜色不匹配。这是因为OpenCV默认加载的图像在BGR颜色空间中。不过没问题，因为切换到RGB色彩空间可以通过一行快速代码来完成，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/6663a103e40bdcfc8304ca4e8e9bffed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/format:webp/1*_XX8qgOFxKqQRTGPs14hLw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用OpenCV在BGR空间加载图像。作者修改的图像。</p></figure><p id="cfcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，我们开始工作了！现在我可以开始玩各种图像处理/操作技术了。我将在这里展示其中的一些，但是如果你想让我展示其他的，请告诉我！</p><h2 id="e9fc" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">旋转图像</h2><p id="ec51" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">旋转图像有几种不同的方法。imutils包通过<code class="fe nt nu nv nw b">imutils.rotate_bound</code>函数实现起来最简单，因为它只需要旋转图像和我们想要旋转图像的角度。除此之外，该函数确保显示的旋转图像不会被裁剪，并且完全包含在边界内。其他方法要求首先构建旋转矩阵，然后应用旋转矩阵。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="49b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此操作的结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/500ec0a9c2d04835b3e161b2ede82e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qc33kz6KZ80lSRgD7Dw_AA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的旋转图像。作者修改的图片。</p></figure><h2 id="eff7" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">裁剪图像</h2><p id="a589" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当通过OpenCV加载图像时，图像作为numpy数组加载。然后，要裁剪图像，我们可以简单地使用numpy切片来裁剪内容。有多种方法可以裁剪东西。我将在这里展示一个简单的例子，我们可以通过不同的高度和宽度百分比来裁剪图像。通过定义感兴趣区域(ROI)和轮廓，还有更好的裁剪方式，我将在后面的章节中介绍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/9de5ab0a4e34cbfc68393ca56f5e83d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_pe9OAjZecbrtELm8KLo-g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中通过numpy切片裁剪图像。作者修改的图片。</p></figure><h2 id="e70d" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">调整图像大小</h2><p id="6cba" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">有许多方法可以调整图像的大小。在这里，我将展示如何使用OpenCV中的resize函数来调整图像的大小。尽管图像看起来完全相同，但当我们调整图像大小时，可以看出图像的大小(高度和宽度)发生了变化。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/99a3c34c37556be8deaea0ae3f3de897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N7SshtppRKEBNMoxOnBStw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Python中调整图像大小。作者修改的图片。</p></figure><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="1d2c" class="nh mk it nw b gy oi oj l ok ol">The width, height and depth of this image are  (304, 486, 3)<br/>The width, height and depth of this image are  (202, 324, 3)<br/>The width, height and depth of this image are  (101, 162, 3)</span></pre><h2 id="baa3" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">调整图像的亮度/对比度</h2><p id="1020" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通过OpenCV中的<code class="fe nt nu nv nw b">addWeighted</code>功能可以调整图像的亮度/对比度。这是一个称为混合的过程。该函数使用以下变换对图像进行调整:</p><p id="bdec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nt nu nv nw b">result = αsrc1 + βsrc2 + γ</code></p><p id="7967" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的等式中，通过将<code class="fe nt nu nv nw b">α</code>值应用于源图像，将<code class="fe nt nu nv nw b">β</code>值应用于某个其他图像(它可以是相同的源图像)并将其值增加<code class="fe nt nu nv nw b">γ</code>来修改混合图像。</p><p id="4d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">混合的效果如下图所示。图的第一行显示了在保持其他两个参数不变的情况下改变<code class="fe nt nu nv nw b">α</code>的效果(<code class="fe nt nu nv nw b">α</code>从左到右减小)。图的第二行显示了在保持其他两个参数不变的情况下改变<code class="fe nt nu nv nw b">β</code>的效果(<code class="fe nt nu nv nw b">β</code>从左到右增加)。图的第三行显示了在保持其他两个参数不变的情况下改变<code class="fe nt nu nv nw b">γ</code>的效果(<code class="fe nt nu nv nw b"><strong class="lb iu">γ</strong></code>从左到右增加)。</p><ul class=""><li id="d1a0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">减少<code class="fe nt nu nv nw b">α</code>会导致图像变暗。</li><li id="4b1f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">增加<code class="fe nt nu nv nw b">β</code>会使图像具有更高的对比度。</li><li id="5090" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">减少<code class="fe nt nu nv nw b">γ</code>会使图像变得柔和。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/7d8e6258cfaab3bf10ec4e64c4c608bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-71LYrITbqfTdTB-ZHMbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Python中改变图像的亮度和对比度。作者修改的图片。</p></figure><h2 id="172a" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">改变图像的色彩空间</h2><p id="9203" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">图像处理中使用了多种颜色空间，这些颜色空间有助于完成各种任务，例如边缘检测、颜色检测和遮罩等。通过<code class="fe nt nu nv nw b">cvtColor</code>函数，OpenCV可以很容易地在色彩空间之间进行转换</p><p id="2cf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面列出了一些常见的色彩空间:</p><ul class=""><li id="731e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">RGB -&gt;许多图像最初都是使用这种格式编码的</li><li id="0f7c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">HSV--&gt;对颜色色调提供更好的控制</li><li id="deab" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">灰色-&gt;使许多图像处理方法更加精确</li></ul><p id="7b6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面显示了一些已更改色彩空间的示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/8970ca137571c32d7bb269b64a4d37fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vE8U6upUQS3MyyCBwo4M_g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Python中改变色彩空间。图片由作者修改。</p></figure><h2 id="26e4" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">模糊图像</h2><p id="3db4" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">当试图检测边缘(即，描绘从一组像素到另一组像素的过渡的线)时，模糊是重要的操作，因为它使对象边界之间的过渡更平滑。例如，这可以用来将对象从背景中分离出来。</p><p id="6482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个项目，我研究了四个类别:</p><ul class=""><li id="d962" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">平均模糊-&gt;快速，但可能无法保留对象边缘</li><li id="ecf7" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">高斯模糊-&gt;比平均模糊慢，但边缘保留更好</li><li id="c2df" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">中值滤波-&gt;对异常值稳健</li><li id="73e2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">双边过滤-&gt;比上面的方法慢很多。更多参数(更多可调参数)。</li></ul><p id="b386" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用不同模糊方法的效果如下图所示。图的第一行显示了在从左到右增加内核大小时使用平均模糊的效果。图的第二行显示了在从左到右增加内核大小时使用高斯模糊的效果。图的第三行显示了在从左到右增加内核大小时使用中值模糊的效果。第四行图显示了从左至右增加<code class="fe nt nu nv nw b">diameter</code>、<code class="fe nt nu nv nw b">sigmaColor</code>和<code class="fe nt nu nv nw b">sigmaSpace</code>参数时使用双边模糊的效果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/b2bca4d3c2ae908f886fff8eef947161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ACgknn8EoWxr-ShL90fvw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的模糊图像。作者修改的图片。</p></figure><h2 id="5e1f" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">检测图像的边缘</h2><p id="d81e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">边缘检测是一种识别图像中对象边界(即边缘)的图像处理技术。边缘允许我们识别图像的底层结构，使它们成为我们从图像中需要的最重要的信息之一。</p><p id="fdff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面使用Canny算法来检测图像的边缘。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/cbce9bc93f8c799498849e9f0e0b352d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8u14lY_QHz6IyLW54QxPag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中Canny的边缘检测。作者修改的图片。</p></figure><h2 id="b1c3" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">遮蔽图像中的颜色</h2><p id="9e1f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通常，人们可能希望在图像中只显示特定的颜色。这可以通过掩蔽来实现。OpenCV中的<code class="fe nt nu nv nw b">inRange</code>函数允许在HSV空间中工作时很容易地做到这一点。</p><p id="6668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面显示的图像(从左到右)是没有应用遮罩，分别遮罩绿色、红色和蓝色的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/112b8a0498dfee42346f573ed6e6a39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGykfaMFa_gVZlEIKjMs5w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Python中的遮罩颜色。作者修改的图片。</p></figure><h2 id="ab2b" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">选择图像中的感兴趣区域</h2><p id="2bd9" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">选择ROI是另一种形式的裁剪。如果你不需要处理太多的图片，这里展示的方法是一个快速裁剪图片的好方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/5071df75b44f0e4ea547c5aaabb4ef84.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/1*UEMZ_CFKMTNZ5sAt26R0zQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">ROI图像。作者修改的图片。</p></figure><h1 id="c6d6" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">从图像中提取颜色</h1><p id="fc6c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">至此，我已经介绍了许多基本的处理操作，这些操作应该足以从图像中确定球员的颜色。为了确定颜色，我尝试了以下方法:</p><ul class=""><li id="a5ad" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">提取单个像素的颜色</li><li id="c3c1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">通过逐像素平均提取颜色</li><li id="7407" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">使用K-均值聚类获得图像中的K-颜色</li></ul><h2 id="0971" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">提取单个像素的颜色</h2><p id="765a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通过向图像阵列提供像素的x，y坐标，读取该像素的RGB通道的结果，并将这些RGB通道分配到一个阵列中，可以很容易地提取单个像素的颜色。我写了一个小函数，为下图中的各种像素做这个。下面显示了17个不同像素的结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/afe101e9fd5c2d5177b69e2db4a97ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRNMJC2PtfwvHmU0GbgVyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提取像素颜色的方法1。图片作者。</p></figure><h2 id="b7d8" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">通过逐像素平均提取主色</h2><p id="efee" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">既然我们可以提取单个像素的颜色，我们可以扩展该方法来确定图像的平均颜色。向我们的图像数组传递一个x，y坐标会返回一个像素的RGB元组。然后，通过在每个像素处添加元组中每个元素的值，我们可以获得与每个RGB通道相关联的“总计数”。最后，我们可以将每个RGB颜色通道中的计数除以图像中的像素总数，以获得图像的平均颜色。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="12a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此过程的结果如下所示，其中平均颜色变成了十六进制值为<code class="fe nt nu nv nw b">#787561</code>的灰绿色，通过对图像的视觉检查，这看起来是合理的。然而，我们能改善这一点吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a71bbfdc3b7c8474631b231f1c44f849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*EGZtQiEUKSsHD7WxZUT0GQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图像中最常见的用户颜色通过平均确定。图片作者。</p></figure><h2 id="2ed0" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">通过K-均值聚类提取主色</h2><p id="3378" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">K-Means聚类算法可以进一步改进球员球衣颜色检测程序。这个例程将允许我们通过指定该例程应该使用的聚类数<code class="fe nt nu nv nw b">k</code>来提取图像中的几个“主色”。如果人们知道数据应该落入多少个聚类中，则可以先验地确定<code class="fe nt nu nv nw b">k</code>的值。</p><p id="44ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">否则，确定k值的常用方法是通过弯管法，如下所示。肘方法图获取模型的变形，并根据<code class="fe nt nu nv nw b">k</code>的值绘制它们。图表的拐点(也称为肘部)是应该使用的k值。使用我一直在处理的图像的肘图的结果表明最佳k值是<code class="fe nt nu nv nw b">3</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/cf9b343b002c010033ebe17d2ab798b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrynMV38tgBVy6gEHdf5zg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对小罗图片进行肘击的结果。图片作者。</p></figure><h2 id="72e0" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">对图像运行k-means聚类</h2><p id="2647" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">确定了<code class="fe nt nu nv nw b">k</code>应该是<code class="fe nt nu nv nw b">3</code>之后，我可以编写一个小程序来获取图像并确定它的k主色。<code class="fe nt nu nv nw b">k = 3</code>、<code class="fe nt nu nv nw b">k = 4</code>和<code class="fe nt nu nv nw b">k = 10</code>(我做的最后两个只是为了好玩)案例的结果如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="c935" class="nh mk it nw b gy oi oj l ok ol">#Call K-Means function with K = 3<br/>nClusters = 3<br/>rgb_array = KMeansTest(rgb_img, nClusters)<br/>plotKMeansResult(nClusters,rgb_array)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d1c5d95ed441a6d26b1ce08be091be8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QSJ7gDLYj8swsuUbpjvSQw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">根据K-Means聚类确定的图像中的前三种颜色。图像中的颜色从左到右逐渐减少。图片作者。</p></figure><p id="1316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nt nu nv nw b">k=3</code>确定的顶部颜色是绿色，通过目测，在“绿色区域”普遍存在的情况下，该颜色看起来是正确的</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="019a" class="nh mk it nw b gy oi oj l ok ol">#Call K-Means function with K = 4<br/>nClusters = 4<br/>rgb_array = KMeansTest(rgb_img, nClusters)<br/>plotKMeansResult(nClusters,rgb_array)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/a67cb8beb7143b7d4ef1f691b30357e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L3uKUFkRFz_NpfFK06cgGg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">根据K-Means聚类确定的图像中的前四种颜色。图像中的颜色从左到右逐渐减少。图片作者。</p></figure><p id="d5dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nt nu nv nw b">k=4</code>确定的顶部颜色也是绿色。然而，它的色调要亮得多。</p><pre class="kj kk kl km gt oe nw of og aw oh bi"><span id="75bc" class="nh mk it nw b gy oi oj l ok ol">#Call K-Means function with K = 10<br/>nClusters = 10<br/>rgb_array = KMeansTest(rgb_img, nClusters)<br/>plotKMeansResult(nClusters,rgb_array)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/4c8cb02dddf16b5e960d1433eb1cbe14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1XoSu4gdSspxdnnXV3Qlg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">根据K均值聚类确定的图像中前10种颜色。图像中的颜色从左到右逐渐减少。图片作者。</p></figure><p id="7097" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe nt nu nv nw b">k=10</code>确定的顶部颜色也是绿色。然而，它比前两个例子要亮得多。通过<code class="fe nt nu nv nw b">k=10</code>的使用可以看出，通过使用更多的簇可以获得更高的颜色特异性。要点是k-means例程可以准确地检测颜色，并提供图像中最常见的颜色。</p><h1 id="3a39" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">在图像中识别人类</h1><p id="8dbb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在开始处理视频片段之前，我还有一件感兴趣的事情。我想检查图像中玩家/人类的分类和/或识别。这些物品的分类不是作业的一部分，但是我想简单地探索一下以满足我的好奇心。</p><p id="deac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">OpenCV中的HOG包包含经过训练的模型的数据库，这些模型能够检测不同的对象，如猫、脸和人。在以后的文章中，我将展示我为解决这个分类问题而构建的神经网络模型。但是现在，我将展示HOG包的用法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/b8570719aa45c73062869e9b480937b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8axQRrjD5LcZH0hii_MjCg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">尝试使用Python中的HOG包在图像中检测球员失败。作者修改的图片。</p></figure><p id="f901" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我花了一点时间摆弄探测器的参数，没有得到更好的结果。我尝试使用<code class="fe nt nu nv nw b">DefaultPeopleDetector</code>和Haar级联分类器<code class="fe nt nu nv nw b">haarcascade_fullbody</code>，但无法得到我想要的结果。即使检测玩家本身不是项目的一部分(我得到了一个包含玩家边界框坐标的JSON文件)，我仍然想确保我成功地尝试了使用HOG检测器。</p><p id="395a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我尝试了下面的一个不同的图像，我认为它会给我一个成功的检测。在参数上玩了几分钟后，我发现了一个有效的组合！我决定只使用玩家边界框(BB)来生成图像，并将K-means例程应用于BB的内容。结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/4cb2166725a47167ca29f75d426d8ffe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3d9BHmXnrHDc3OwtPVKLw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用HOG包检测玩家并提取包含玩家的包围盒。作者修改的图片。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/fc861dc33539cb85b32ab3b7a535f611.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p30Y1bj7_2URexQF4GKtAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过K-Means聚类确定的上图中的前4种颜色。图片作者。</p></figure><p id="7f20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将需要研究细化/自动化对象检测器功能的参数，但我对目前为止的进展感到满意。</p><h1 id="c83b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">处理视频和提取帧</h1><p id="f653" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在熟悉了各种图像操作和处理技术并了解了如何实现K-Means来提取图像中的主色之后，我决定开始处理视频素材，因为我相信我已经具备了开发一个功能例程来从图像中确定球衣颜色的基础。</p><p id="c759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的文件中有一部分是从两台不同的摄像机拍摄的足球比赛视频。需要做的第一件事是获取视频文件，我可以使用以下例程来完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d416" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我有了mp4文件的列表，我可以使用下面的例程从视频中提取单个帧:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a0de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我可以看到从两台摄像机提取的画面。帧2500作为示例显示如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/b8ad8d6f5df4f145f94e4ed67eced62b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IR__Z4aAte9MTR9YTHkbw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分别从左右摄像机提取帧。图片作者。</p></figure><p id="ea60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想从视频中提取的另一件事是视频中的帧数。这可以使用以下例程来完成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="698c" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">加载JSON文件并检查边界框</h1><p id="0e4d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">JSON文件包含玩家边界框坐标。需要做的第一件事是加载JSON文件，这可以使用我之前制作的例程来完成。JSON文件与MP4文件相关联，所以我必须确保当我批处理所有文件时，正确的JSON文件与正确的MP4文件是成对的。</p><p id="0d38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我将首先去除路径和。json扩展名，并将结果放入一个名为<code class="fe nt nu nv nw b">json_strip.</code>的列表中。然后，我将从我之前为每个相机(LCAMERA和RCAMERA)生成的MP4文件列表中删除路径，并将结果分别放入两个名为<code class="fe nt nu nv nw b">mp4_strip_LC</code>和<code class="fe nt nu nv nw b">mp4_strip_RC</code>的列表中。最后，我将使用这些列表从每台摄像机获取与这些文件相关联的索引。完成上述步骤的程序如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以读取JSON文件，并获得上述框架的绑定框信息。为此，我将为正在处理的视频中的每一帧生成一个字典，其中包含每个玩家边界框(检测)的坐标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fb34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码给出了当前视频中每一帧的边界框。接下来，我将确定给定帧中有多少个边界框。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将确定视频中包含玩家检测的第一帧。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="942d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，对不同视频可能不同的<code class="fe nt nu nv nw b">frame_index</code>值进行检测。让我们根据JSON文件计算出视频的检测收集时间间隔。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fa16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将从JSON文件中提取当前帧的所有边界框坐标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="78b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我将从JSON文件中提取特定边界框的边界框坐标。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="38f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过可视化边界框来看看我的程序是否有效！以下是视频中第一个帧的示例，分别包含对左右摄像机的检测。第一帧分别被确定为帧0和帧62。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/4713f87e42ed7fca2e484929e202bc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uqLhUdGNKIqEhwQAQS8gwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自左右摄像机的视频镜头的原始第一帧。图片作者。</p></figure><p id="4693" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">绘制了玩家边界框的帧如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/29ccb5a08170f6e021f60f89d0d2b4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LG0TAw0yOIGKh6PlbM1Wrw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从带有玩家边界框的左右摄像机获得的视频镜头的帧。图片作者。</p></figure><p id="7fee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这里是每个玩家在画面中的边界框。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/4c9e05385c8ecad71eea9a87c9956ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2cRSYrtRiO1ZeetVJ1g8xQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">玩家从左边相机包围盒。图片作者。</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/f45ab2aad70a064d44f3f6dd9fae8204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d1OcfWI2OzFfSKaPiYIOoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来自右边相机的玩家边界框。图片作者。</p></figure><p id="cb87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">厉害！到目前为止，这些方法允许我成功地提取玩家边界框。从一些边界框中可以看到一些东西。首先，有假阳性的例子。这个数据中的假阳性需要没有玩家的包围盒。这是将来需要解决的问题。</p><h1 id="b61b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">应用K-均值聚类确定运动员球衣颜色</h1><p id="30d7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">太好了！现在，我的数据处于适当的状态。现在，让我们尝试在边界框上应用K-Means聚类例程，看看会发生什么。我将坚持处理我到目前为止一直使用的相同视频和帧，以便我可以稍微关注一下聚类本身。聚类例程如下所示。该程序需要以下步骤:</p><ol class=""><li id="d7ea" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu nx mb mc md bi translated">将图像(玩家边界框)转换到HSV颜色空间</li><li id="15dc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">将图像展平成1D阵列，以便于处理</li><li id="e042" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">运行K均值聚类</li><li id="d97f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">确定图像上每种颜色的百分比</li><li id="3ee1" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu nx mb mc md bi translated">按降序排列这些颜色，并将它们放入一个数组中</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3298" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对前四个边界框运行此例程的结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/978cfc0346af72bb7d4fae145e57de39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8SYal-JsVDx4ygyX89oTQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">显示的边界框上的聚类结果。图片作者。</p></figure><p id="4014" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的结果中可以看出，绿色是所有边框的主色。绿色主要来自于田野里的草。这就是掩蔽发挥作用的地方。</p><h2 id="a867" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">将遮罩应用于图像数据</h2><p id="5b1c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">为了更好地处理边界框中草地的存在，我将使用遮罩。我的方法包括为构成HSV颜色空间的三个值(即色调、饱和度、亮度)中的每一个设置低阈值和高阈值。如果一种颜色落在这个阈值的范围内，那么它将被屏蔽掉。</p><p id="5d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我还添加了一些错误处理功能，以应对蒙版过程移除过多像素的情况。聚类例程要求待处理的图像至少具有与聚类一样多的唯一像素。因此，如果得到的屏蔽图像的维数低于所需的聚类数，则该图像将被忽略。这种情况很可能发生在边界框只有一个字段的情况下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ff83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面显示了几种不同情况下使用掩码的结果。使用蒙版去除绿色对改进颜色检测程序有很大帮助！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ow"><img src="../Images/09f54259abee2db7c714178a5308dceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKbRv-L-t-9CCTDou6HxXg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">应用绿色遮罩后，玩家边界框中的主色。图片作者。</p></figure><h2 id="3200" class="nh mk it bd ml ni nj dn mp nk nl dp mt li nm nn mv lm no np mx lq nq nr mz ns bi translated">移除边界框的下半部分，以关注球衣数据</h2><p id="2443" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">由于任务是仅确定球衣颜色，裁剪图像的底部也有助于支持分析，因为我们可以专注于更重要的区域，并提高球员球衣颜色检测的准确性。这可以通过下面的程序简单地完成。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="be63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掩蔽和裁剪后的聚类例程的结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/c441c92b0534e70b601600eed93624ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHv800_yzf7xjcJbZj1S0Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">遮罩区域和裁剪图像底部后的主色。</p></figure><p id="177d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了！</p><h1 id="b93d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">正在处理整个MP4文件</h1><p id="1139" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们尝试处理每一帧，看看会发生什么！到目前为止，我把所有的例程都放在了下面的包装函数中。这个包装器函数将JSON文件的路径、mp4文件的路径、要处理的视频和k-means的聚类数作为输入。这个函数的输出是一个pandas数据帧，包含当前视频的每一帧中每个边界框的RGB格式的主色。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5d88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">723帧可以在10分钟内处理完毕。平均帧处理速率为1.23帧/秒。该速率取决于给定帧处理了多少个边界框。让我们来看看我做的数据框。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/d32f16cb3257a979373b2367c43d3334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*21FEBO1sJAfDdn4Dg-4uvw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">包含视频聚类结果的熊猫数据帧。图片作者。</p></figure><p id="951b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据帧具有所需的结构。可以看出，总共处理了9，307个边界框。这意味着每秒可以处理15.8个边界框。我将删除数据帧中包含nan数组的所有行(这些数组包含误报)。</p><p id="43e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，在处理的数据集中有281个误报，这意味着玩家对象的分类过程有97%的准确率，这相当不错！现在，我将尝试使用K-Means例程在我们的数据帧的RGB列上查看当前处理的MP4帧中的前五种颜色。</p><h1 id="6b12" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">所有处理过的边界框中最常见的颜色是什么？</h1><p id="5c68" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">另外，我认为在处理过的MP4文件中看到最频繁出现的颜色会很有趣。这个过程可以帮助识别视频片段中出现的球队球衣颜色，然后可以用来开发一个能够区分不同球队球员的算法例程。</p><p id="95b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我有一个熊猫数据帧，其中包含每个边界框中出现的最多、第二最多和第三最多的主色，所以我可以利用与我前面介绍的相似的聚类例程来从这些类别中获得最多的主色。该过程的结果如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/8d4e6b259d51e666dad4359c66ab6ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*qGdQlGvBIIcbeRDEyajIgA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">最常见的颜色出现在所有玩家的边界框中。图片作者。</p></figure><p id="c39e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的图像中可以看出，深灰色对应于总颜色的29.32%，褐红色对应于所有边界框中找到的颜色的27.60%。经过处理的视频中的球队球衣是红白相间的。然而，由于阴影和光照的差异，这里观察到的顶部两种颜色准确地描绘了球队球衣，并可随后用于球队分类。</p><h1 id="11ec" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">处理整个游戏</h1><p id="308e" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我下面展示的例程已经在一个MP4文件上演示过了。然而，这个MP4文件对应的是几分钟游戏时间的镜头。也就是说，我开发的代码例程是相当模块化的，因此，通过下面的例程连接从每个MP4文件获得的结果，它可以很容易地用于处理整个游戏:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="fe40" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">用于快速可视化聚类结果的GUI</h1><p id="ddfb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">熊猫数据帧整齐地存储了聚类结果。然而，所有这些数字可能有点难以理解。因此，我编写了一个GUI，它将使用跟踪条在我的熊猫数据帧的行之间移动，并沿着三种最主要的颜色绘制裁剪的玩家边界框。它将标记由聚类算法确定的十六进制代码。下面显示了相关的代码，以及运行中的GUI演示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/03eedc60e1f7662d00bb99e6c66a34e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/1*evfs6_NPDqCN6j2MPjGCTQ.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">展示聚类结果的GUI演示。图片作者。</p></figure><h1 id="607b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="a53a" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">上面显示的工作演示了如何使用K-Means聚类算法从足球比赛视频片段中提取球衣颜色。在这个过程中，某些方面肯定可以改进。例如，我确信我可以通过多重处理和/或批处理视频来提高代码的效率。</p><p id="4c47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在处理假阳性(即裁判、非玩家对象)时，可以通过包括更好的错误处理来改进例程。聚类过程结果与预期输出一致(即，主色是红色和白色的阴影，而团队球衣颜色是红色和白色)。我希望这篇文章对你来说是有趣的或者至少是有用的。我很高兴听到你对此的任何建议或想法！</p><p id="3b13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p><p id="9a84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你愿意支持我的编码工作，请考虑通过我的推荐链接加入Medium:<a class="ae ky" href="https://victormurcia-53351.medium.com/membership" rel="noopener">https://victormurcia-53351.medium.com/membership</a></p></div></div>    
</body>
</html>