<html>
<head>
<title>A Simple Guide to Creating REST APIs With TypeScript and Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript和Node.js创建REST APIs的简单指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-and-node-js-a-simple-guide-to-creating-rest-apis-7bfac9f58b34?source=collection_archive---------3-----------------------#2019-12-13">https://betterprogramming.pub/typescript-and-node-js-a-simple-guide-to-creating-rest-apis-7bfac9f58b34?source=collection_archive---------3-----------------------#2019-12-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="34c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Liftr通过TypeScript快速创建Express APIs</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d5b84701041f595339bb1741776b3778.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HH3hOXVl7pMK_LBjG36PRQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@agkdesign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历山大·奈特</a>在<a class="ae kv" href="https://unsplash.com/s/photos/laptop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="eb88" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TypeScript已经成为开发人员最流行的编程语言之一。将TypeScript与<a class="ae kv" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>一起使用可以增强您构建REST APIs的方式，并带来一些现成的好处:</p><ul class=""><li id="92a5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">还有<em class="mb">可选</em>静态打字。</li><li id="4bba" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">TypeScript <a class="ae kv" href="https://marketplace.visualstudio.com/items?itemName=sourcegraph.javascript-typescript" rel="noopener ugc nofollow" target="_blank"> IntelliSense </a>为您的IDE提供了很好的编码提示和工具。</li><li id="0974" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">JavaScript变得更加可读和可调试。</li></ul><p id="339c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当试图用Node.js和TypeScript创建REST API时，弄清楚如何设置您的环境会变得非常困难。借助<a class="ae kv" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>的强大功能，我将通过创建一个简单的商店API来展示TypeScript的好处。</p><p id="16e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于本教程，我们也将使用一个框架，所有人都可以使用这个框架，称为<a class="ae kv" href="https://github.com/farisT/liftr" rel="noopener ugc nofollow" target="_blank"> Liftr </a>。Liftr是用TypeScript创建Express APIs的一种无压力的方式。让我们更深入地了解Liftr及其优势。</p><div class="mh mi gp gr mj mk"><a href="https://github.com/farisT/liftr-cli" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">farisT/liftr-cli</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">liftr-cli是一个与liftr框架一起工作的快速项目启动cli，它将为…</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="mu l mv mw mx mt my kp mk"/></div></div></a></div><ul class=""><li id="cab8" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Liftr建立了一个你可以<strong class="ky ir"> </strong>遵循的基本API结构。留在这个结构中有好处，但是你可以随时定制它，使它成为你自己的。</li><li id="5a2e" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Liftr可以为您生成路线，并为您添加一个链接到该路线的控制器。</li><li id="dbc8" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Liftr路线可以添加<em class="mb"> joi </em>模式，以便在开发时提供额外的说明和文档。</li><li id="a3f1" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Liftr可以生成基本的中间件。</li><li id="dcf5" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Liftr会帮你把它们绑在一起！(确保所有线路连接正确。)</li><li id="31fd" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Liftr内置了测试用的<a class="ae kv" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>和代码覆盖率用的<a class="ae kv" href="https://github.com/istanbuljs/nyc#readme" rel="noopener ugc nofollow" target="_blank"> Nyc </a>。</li><li id="d7f4" class="ls lt iq ky b kz mc lc md lf me lj mf ln mg lr lx ly lz ma bi translated">Liftr框架有许多支持包，可以帮助构建更具可持续性的API，比如<a class="ae kv" href="https://github.com/jeroenouw/liftr-tscov" rel="noopener ugc nofollow" target="_blank"> liftr-tscov </a>包可以帮助检查你的类型覆盖率。</li></ul><p id="9747" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">举个例子，我们一起来设置一个商店API。首先，确保将liftr-cli安装为全局cli。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="69bc" class="ne nf iq na b gy ng nh l ni nj">npm i -g @liftr/cli</span></pre><p id="6516" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将允许我们在我们的机器上使用Liftr。完成后，<code class="fe nk nl nm na b">cd</code>进入一个文件夹或<code class="fe nk nl nm na b">mkdir</code>一个您想要在其中设置API的父文件夹，然后运行:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="f688" class="ne nf iq na b gy ng nh l ni nj">liftr -s ShopApi</span></pre><p id="b0c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Liftr现在将为我们创建必要的文件，开始构建和扩展我们自己的用TypeScript构建的Node.js API。一旦这个命令完成，你可以运行<code class="fe nk nl nm na b">cd ShopApi</code>，你将进入你的项目文件夹。</p><p id="6792" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您的项目布局应该如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/5ad1a4411461e50469906ed8922e92ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*XuZavhTBgq3K75EfAbkpVA.png"/></div></figure><p id="9259" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用Liftr从项目中运行许多命令，这些命令将帮助您快速构建API结构。</p><p id="c32c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，在我们的商店API中，除了作为设置的一部分创建的路线或模块之外，我们没有其他路线或模块，所以让我们创建一个模块来容纳我们的商店。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="01dd" class="ne nf iq na b gy ng nh l ni nj">liftr --module shop</span></pre><p id="5ba3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将创建一个<code class="fe nk nl nm na b">shop.module.ts</code>和一个<code class="fe nk nl nm na b">shop.routes.ts</code>。</p><p id="823c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该模块将作为<a class="ae kv" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>中提供给它的所有路线的布局和文档。除此之外，还可以通过中间件和joi模式来全面了解您的路线需要什么。</p><p id="943a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">商店有产品，因此应该创建一个可以提供产品的<code class="fe nk nl nm na b">/products</code>端点。使用Liftr，可以在模块中快速创建一条我们希望它所在的路径。</p><p id="1e68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过运行以下命令，该路线将自动添加到该模块和该模块的coherent <code class="fe nk nl nm na b">.routes.ts</code>中。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="c193" class="ne nf iq na b gy ng nh l ni nj">liftr --route products --target shop</span></pre><p id="ac10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们看一下代码，我们应该在<code class="fe nk nl nm na b">shop.module.ts</code>中有一个有效的GET路径<code class="fe nk nl nm na b">/products</code>。让我们向端点的控制器添加一些产品，以了解真正的商店API是什么样子的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c24f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我创建了一个简单的接口，这样就可以定义更复杂的类型。这样，我们的目标是确定一个产品必须有一个string类型的名称和一个number类型的数量。</p><p id="b832" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Liftr的另一个很棒的特性是，在幕后，我们可以提供一些信息来为我们的端点自动创建文档。</p><p id="b976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一般来说，在使用Swagger时，我们必须创建包含所有信息的大型Swagger文档。使用Liftr，一旦创建并注册了路线，它将自动显示在Swagger中！</p><p id="d1f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用一些文档创建另一个端点。因为我们已经通过CLI完成了这项工作，所以让我们手动添加它，看看连接是在哪里进行的。</p><p id="ec4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">商店应该能够将产品添加到其库存中，因此，应该有一个添加产品的端点。由于我们试图遵守REST标准，我们将创建另一个<code class="fe nk nl nm na b">/products</code>路由，这将是一个POST端点。</p><p id="b9d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是端点的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bce1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，在<code class="fe nk nl nm na b">addProductsRoute</code>中我增加了一个<code class="fe nk nl nm na b">addProducts</code>控制器。因为我们没有通过CLI创建路由，所以我们必须使用liftr-cli创建一个名为<code class="fe nk nl nm na b">addProducts</code>的基本控制器，使用以下命令:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4ae5" class="ne nf iq na b gy ng nh l ni nj">liftr --controller addProducts --flat</span></pre><p id="b8ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe nk nl nm na b">--flat</code>标志，我们可以指定希望CLI创建一个控制器文件，而不是在<code class="fe nk nl nm na b">controllers</code> <strong class="ky ir"> </strong>文件夹中创建子文件夹。</p><p id="487f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们还可以创建一个joi模式，将请求体添加到POST route文档中，并验证我们的路由。</p><p id="3976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的POST路线，我们希望能够将产品添加到我们的商店，因此为了这样做，我们需要发送产品和该产品的数量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以将这个模式添加到<code class="fe nk nl nm na b">shop.module.ts</code>以及我们的<code class="fe nk nl nm na b">addProducts.controller.ts</code>中，以确保我们的路由在我们的文档中注册了这个模式，并检查路由中是否有正确的请求体。</p><p id="fe83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，你可以看到另一个使用方法<code class="fe nk nl nm na b">req.validate</code>的Liftr特性。我们传入我们的主体以及刚刚创建的joi模式来检查传入的数据。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f830" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以启动开发服务器来测试我们的端点:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1e77" class="ne nf iq na b gy ng nh l ni nj">npm start</span></pre><p id="cdac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看哪！我们自己的商店API，使用两个产品端点运行。</p><p id="97fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们转到<a class="ae kv" href="http://localhost:4000/docs" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/docs</a>，我们可以看到我们有端点的文档(名称和类型)。</p><p id="8fd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，有了POST端点，我们还在文档中添加了必要的POST主体，我们甚至可以测试端点！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/5dd51e88509e26a2b86883130bcd57da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p90zZeNAPYIvusG3o29sHw.png"/></div></div></figure><p id="7180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Liftr还提供了一种方法来检查项目中的类型以及您遗漏了哪些类型，这可以让您更深入地了解代码。</p><p id="d97e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行<code class="fe nk nl nm na b">npm run test:types</code>，您将获得可用和未覆盖类型的详细摘要。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="4851" class="ne nf iq na b gy ng nh l ni nj">_____   ____     ____    ___   __     __<br/> |_   _| / ___|   / ___|  / _ \  \ \   / /<br/>   | |   \___ \  | |     | | | |  \ \ / / <br/>   | |    ___) | | |___  | |_| |   \ V /  <br/>   |_|   |____/   \____|  \___/     \_/   <br/>                                          <br/>The TypeScript CLI to calculate type coverage</span><span id="8a1e" class="ne nf iq na b gy nr nh l ni nj">------------- uncovered types ---------------<br/>/Users/ftangastani/develop/liftr/src/controllers/liftr.controller.spec.ts: 8:9 - req<br/>/Users/ftangastani/develop/liftr/src/controllers/liftr.controller.spec.ts: 19:25 - req</span><span id="4db1" class="ne nf iq na b gy nr nh l ni nj">----------------- coverage ------------------<br/>148 - max reachable type coverage<br/>146 - types covered<br/>2 - types uncovered</span></pre><p id="1e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一篇关于如何用TypeScript和Node.js设置REST API的简短指南。</p><p id="8931" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了像<a class="ae kv" href="https://github.com/farisT/liftr-cli" rel="noopener ugc nofollow" target="_blank"> Liftr </a>这样的框架，模块化和动态创建新路线变得非常容易。随着项目规模的扩大，我们还可以添加文档来明确每条路线的要求。</p><p id="7d4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你走到这一步。如果有人能为Liftr框架和它的任何一个包做出贡献，那将会非常酷。投稿不需要任何技能，只需更新一个文档或修复一个小错误。任何东西都是高度赞赏的！</p><div class="mh mi gp gr mj mk"><a href="https://github.com/farisT/liftr" rel="noopener  ugc nofollow" target="_blank"><div class="ml ab fo"><div class="mm ab mn cl cj mo"><h2 class="bd ir gy z fp mp fr fs mq fu fw ip bi translated">farisT/liftr</h2><div class="mr l"><h3 class="bd b gy z fp mp fr fs mq fu fw dk translated">这个项目是用liftr-cli启动的。liftr-cli是一个快速的项目启动cli，可与Liftr……</h3></div><div class="ms l"><p class="bd b dl z fp mp fr fs mq fu fw dk translated">github.com</p></div></div><div class="mt l"><div class="ns l mv mw mx mt my kp mk"/></div></div></a></div></div></div>    
</body>
</html>