<html>
<head>
<title>How to Detect Vulnerabilities in Docker Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测Docker图像中的漏洞</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/detect-vulnerabilities-in-docker-images-d21f1b762898?source=collection_archive---------7-----------------------#2020-01-04">https://betterprogramming.pub/detect-vulnerabilities-in-docker-images-d21f1b762898?source=collection_archive---------7-----------------------#2020-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高码头集装箱的安全性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cac38a951b07618889118ae0b2f148dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y7sVex_t2cK601b9"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">卡米洛·希门尼斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="854c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/quay/clair" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Clair </em> </a> <em class="lv">是针对应用程序容器中的</em> <a class="ae ky" href="https://en.wikipedia.org/wiki/Static_program_analysis" rel="noopener ugc nofollow" target="_blank"> <em class="lv">漏洞进行静态分析</em> </a> <em class="lv">的开源项目。</em></p><p id="a300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统部署和Docker部署的主要区别之一是处理软件依赖的方式。在传统部署中，软件依赖关系需要由专门的团队来安装和管理。他们安装所需版本的依赖项，在出现安全问题时对其进行升级，并定期对操作系统软件包进行修补。在主机上管理和安装所有依赖关系，以及解决同一台服务器上不同软件之间的依赖关系冲突是一项挑战，而且非常耗时。</p><p id="ef10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Docker部署通过将给定软件所需的所有依赖项封装在其自己的Docker映像中来解决这些挑战。这些依赖项是在Docker构建时安装的，并且只适用于与生成的Docker映像一起运行的容器(这些依赖项也不会影响主机)。然而，由于Docker映像由多个层组成，从操作系统(ubuntu、alpine、centos等)到应用层本身，因此Docker映像存在漏洞的风险，这些漏洞可能会暴露一些安全风险，并为攻击者提供访问托管服务器的方法。</p><p id="2e62" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据<a class="ae ky" href="https://nvd.nist.gov/vuln/search" rel="noopener ugc nofollow" target="_blank">国家漏洞D </a>数据库，已知漏洞超过75000个。其中一些漏洞是众所周知的，比如影响OpenSSL的<a class="ae ky" href="http://heartbleed.com/" rel="noopener ugc nofollow" target="_blank"> Heartbleed </a>。这意味着用于部署应用程序的Docker映像很有可能包含这些漏洞。获取此信息需要扫描Docker图像，并针对已知漏洞进行分析和比较。不幸的是，这个特性在Docker registry和Portus中都不可用，所以需要另一个工具来实现这个目标。</p><p id="6818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/quay/clair" rel="noopener ugc nofollow" target="_blank"> Clair </a>是一款工具，可用于扫描Docker图像并报告发现的任何漏洞。<a class="ae ky" href="https://github.com/quay/clair" rel="noopener ugc nofollow" target="_blank"> Clair </a>公开了一个用于索引docker映像的API，并向数据库查询特定映像的漏洞。在我们开始部署<a class="ae ky" href="https://github.com/quay/clair" rel="noopener ugc nofollow" target="_blank"> Clair </a>并将其与<a class="ae ky" href="http://port.us.org/" rel="noopener ugc nofollow" target="_blank"> Portus </a>集成之前，让我们快速了解一下<a class="ae ky" href="https://github.com/quay/clair" rel="noopener ugc nofollow" target="_blank"> Clair </a>是如何工作的:</p><ul class=""><li id="2b7d" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">Clair定期提取外部数据库，并用已知漏洞更新其内部数据库。</li><li id="1925" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">客户端(注册或Portus)将图像发送到<a class="ae ky" href="https://github.com/quay/clair" rel="noopener ugc nofollow" target="_blank"> Clair </a> API进行分析。</li><li id="8d58" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">出于性能和效率的原因，Clair逐层分析Docker图像，而不是基于图像。这是因为Docker图像共享图层，无需多次分析相同的数据/图层。</li><li id="b534" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">Clair将图像层传递给工作人员，以检测每个层中的漏洞。Clair支持三种不同的检测器来查找Docker图像层中的漏洞。</li></ul><ol class=""><li id="302b" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mk mc md me bi translated">第一种类型是<code class="fe ml mm mn mo b">Data Detector</code>，它负责扫描层中任何不应该包含在生产中的静态配置。</li><li id="ef6c" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">第二种类型是<code class="fe ml mm mn mo b">Feature Detector</code>，它基本上可以是Docker容器中的任何东西，从OpenSSL这样的包到配置参数。</li><li id="8a26" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mk mc md me bi translated">最后一个探测器是<code class="fe ml mm mn mo b">Namespace Detector</code>。该检测器基于<code class="fe ml mm mn mo b">features</code>和<code class="fe ml mm mn mo b">vulnerabilities</code>之间的上下文。该检测器能够发现在<code class="fe ml mm mn mo b">centos7</code>上安装<code class="fe ml mm mn mo b">centos6</code>封装等问题。</li></ol><h2 id="8c70" class="mp mq it bd mr ms mt dn mu mv mw dp mx li my mz na lm nb nc nd lq ne nf ng nh bi translated">克莱尔部署</h2><p id="fb6a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">如上所述，Clair将收集的关于Docker图像的数据存储在内部数据库(PostgreSQL数据库)中。因此，我们需要访问HA PostgreSQL数据库，以便在生产环境中执行部署。为了简单起见，我将使用Clair Docker栈部署一个PostgreSQL服务器(这也可以在测试环境中完成)。</p><p id="c593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免在Clair服务中使用Docker卷，我决定构建一个自定义映像，它包含一个配置模板，可以使用environment valuables进行配置。这里是定制docker图像的<code class="fe ml mm mn mo b">Dockerfile</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克莱尔·多克尔文件</p></figure><p id="742d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是入口点文件，它负责呈现模板并为Clair生成配置文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克莱尔入口点</p></figure><p id="41cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这里是我用来部署Clair及其依赖项的Docker swarm堆栈:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克莱尔码头栈</p></figure><p id="2ce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">部署Clair堆栈(Clair服务器和PostgreSQL数据库)后，下一步是将Clair与Portus集成，以便能够扫描Docker图像。默认情况下，Clair在端口<code class="fe ml mm mn mo b">6060</code>上公开其API。因此，要集成Clair和Portus，我们需要用Clair URL来配置Portus，如下所示:<code class="fe ml mm mn mo b"><a class="ae ky" href="http://clair_server:86060," rel="noopener ugc nofollow" target="_blank">http://clair_server:86060</a></code>。我们需要将这个值添加到环境变量<code class="fe ml mm mn mo b">PORTUS_SECURITY_CLAIR_SERVER</code>，或者通过更新Portus <a class="ae ky" href="http://port.us.org/features/6_security_scanning.html" rel="noopener ugc nofollow" target="_blank">配置</a>。</p><p id="bb2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将Clair与Portus集成并向Docker注册表推送一些图像后，我们可以开始看到漏洞报告，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/6e582210854f3167cf1582d839ebe080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h5d_2OzcEoSKXdPhw4GZPA.png"/></div></div></figure></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="26a9" class="nx mq it bd mr ny nz oa mu ob oc od mx jz oe ka na kc of kd nd kf og kg ng oh bi translated"><strong class="ak">最后一个字</strong></h1><p id="6455" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我更新了在这篇<a class="ae ky" href="https://medium.com/@wshihadeh/how-to-deploy-portus-in-swam-a3b71c7519b5" rel="noopener">帖子</a>中创建的Swarm orca项目，也包括了Clair。您可以简单地通过执行下面的命令来部署Clair(您还需要部署其他服务来使它在您的本地机器上工作):</p><pre class="kj kk kl km gt oi mo oj ok aw ol bi"><span id="eceb" class="mp mq it mo b gy om on l oo op">SCM=copy bundle exec cap local deploy:setup deploy:clair</span></pre></div><div class="ab cl nq nr hx ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="im in io ip iq"><h1 id="eb06" class="nx mq it bd mr ny nz oa mu ob oc od mx jz oe ka na kc of kd nd kf og kg ng oh bi translated"><strong class="ak">结论</strong></h1><p id="0e98" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了提高生成的Docker映像的质量并避免暴露于已知漏洞，建议:</p><ul class=""><li id="d09a" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated">开始扫描Docker图像寻找漏洞。</li><li id="4906" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated">将扫描过程与软件应用程序的发布周期相结合。</li></ul></div></div>    
</body>
</html>