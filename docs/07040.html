<html>
<head>
<title>Speed Up Your DeFi Queries Using Multicall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多呼叫加速您的DeFi查询</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/speed-up-your-defi-queries-using-multicall-d4cf652d8ab6?source=collection_archive---------4-----------------------#2020-12-01">https://betterprogramming.pub/speed-up-your-defi-queries-using-multicall-d4cf652d8ab6?source=collection_archive---------4-----------------------#2020-12-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="878b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak">如何对呼叫进行分组以更快的方式从以太坊的DeFi协议中获取数据的实例</strong></h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9283490b8162c745f97684070630189a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VMPbayu951_F6zCx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CHUTTERSNAP </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="a777" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">编者按:本文仅供教育娱乐之用，不构成理财建议。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="316d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">简介</strong></h1><p id="0d05" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">有时，从区块链获取数据在时间和发送给它的请求数量方面会很昂贵。如果我们希望同时获得大量数据，在仪表板中显示或进行分析，并且我们必须调用合同的不同功能或使用不同参数的相同功能，这可能会导致很长的查询时间。如果我们使用一个像<a class="ae ky" href="https://infura.io/" rel="noopener ugc nofollow" target="_blank"> Infura </a>这样的提供者，我们可能会达到连接的极限。</p><h2 id="d823" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated"><strong class="ak">什么是Multicall？</strong></h2><p id="15d9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated"><a class="ae ky" href="https://github.com/cavanmflynn/ethers-multicall#readme" rel="noopener ugc nofollow" target="_blank"> Multicall </a>是一个npm包，它将几个HTTP调用组合成一个。这样，如果我们想要从<em class="lv"> n个</em>不同的请求中获取数据，我们可以在发送之前将它们分组，并且只发送一个HTTP请求，从而改善响应时间和我们的<code class="fe nm nn no np b">eth_call</code>调用的消耗。</p><h2 id="01fa" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated">测试它是如何工作的</h2><p id="2ef9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了了解这种机制是如何工作的，以及是否真的比传统方法有所改进——为每个函数调用<em class="lv"> n </em>次——我们将做一个例子，演示我们如何在不使用和使用Multicall的情况下做到这一点，然后分析结果。为此，我们将通过调用函数<code class="fe nm nn no np b">getAccountLiquidity</code>来查询复合协议。我们将使用1000个不同的地址来获取所有这些地址的信息。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ff5e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">创建项目</strong></h1><h2 id="f2ce" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated"><strong class="ak">安装依赖关系</strong></h2><p id="8fd9" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了进行这个测试，我们将创建一个节点项目，我们将安装<a class="ae ky" href="https://docs.ethers.io/v5/" rel="noopener ugc nofollow" target="_blank"> ethers.js </a>的依赖项来与区块链交互，<a class="ae ky" href="https://money-legos.studydefi.com/#/" rel="noopener ugc nofollow" target="_blank"> money-legos </a>以更简单的方式引用ABIs和契约，以及Multicall包。</p><p id="1200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们使用以下内容创建项目:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="81e5" class="na me it np b gy nu nv l nw nx">npm init -y</span></pre><p id="a370" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们安装我们已经讨论过的依赖项:</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="4cd3" class="na me it np b gy nu nv l nw nx">npm install -S @studydefi/money-legos ethers ethers-multicall</span></pre><h2 id="38d9" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated"><strong class="ak">导入依赖关系</strong></h2><p id="8477" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">在这两种情况下，我们都必须使用公共依赖项，并实例化提供者以连接区块链。我们通过以下方式做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8847" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还将创建一个函数来显示结果和执行时间，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="5ed6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">调用合同</strong></h1><h2 id="49a2" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated"><strong class="ak">来自循环的调用</strong></h2><p id="589e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了用传统方法进行测试，我们将遍历地址数组，在一个<code class="fe nm nn no np b">map</code>循环中，我们将逐个返回每个查询的结果，直到我们到达文件拥有的1000个地址。为此，我们将执行如下功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="ac4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们实例化复合审计员合同，并为每个地址调用帐户流动性函数。</p><h2 id="72d5" class="na me it bd mf nb nc dn mj nd ne dp mn li nf ng mp lm nh ni mr lq nj nk mt nl bi translated"><strong class="ak">进行多呼叫</strong></h2><p id="619b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">当使用Multicall调用时，这个函数需要做一点修改，留下如下形式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5ad1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在这里做的是利用Multicall包中的<code class="fe nm nn no np b">Provider</code>和<code class="fe nm nn no np b">Contract</code>类。首先我们初始化这个提供者，传递我们的提供者<code class="fe nm nn no np b">web3</code>和带有地址及其ABI的契约。</p><p id="b06e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们创建了它，我们做和以前一样的过程。通过一个<code class="fe nm nn no np b">map</code>，我们调用账户流动性函数。但在这种情况下，我们不是将它们发送到网络，而是将它们分组到一个数组中。一旦创建了这个数组，就调用创建的提供者的<code class="fe nm nn no np b">all</code>函数，这就调用了网络。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="aa20" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">分析结果</strong></h1><p id="3319" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">要看是否真的有了明显的改善，我们先来看时差。</p><p id="9bf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正常方法(不使用多调用执行)</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="f965" class="na me it np b gy nu nv l nw nx">Time to process in milliseconds: 124653</span><span id="d26a" class="na me it np b gy oa nv l nw nx">Time to process in seconds: 124.653</span><span id="8fcd" class="na me it np b gy oa nv l nw nx">Number of entries in the result: 1000</span></pre><p id="f80b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用多呼叫</p><pre class="kj kk kl km gt nq np nr ns aw nt bi"><span id="e9d7" class="na me it np b gy nu nv l nw nx">Time to process in milliseconds: 9591</span><span id="aa2f" class="na me it np b gy oa nv l nw nx">Time to process in seconds: 9.591</span><span id="116e" class="na me it np b gy oa nv l nw nx">Number of entries in the result: 1000</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1d4e" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated"><strong class="ak">结论</strong></h1><p id="bc05" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">正如我们所看到的，时间的减少是相当可观的，从124秒到9.5秒，所以它的成本会少十分之一。</p><p id="aa6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果我们比较一下<code class="fe nm nn no np b">eth_call</code>呼叫的数量，我们还会看到一个非常显著的下降，从一千多次下降到只有一次。因此，如果我们依赖一个以太坊的访问提供者，其中对API的调用是有限的，这是需要考虑的事情。</p></div></div>    
</body>
</html>