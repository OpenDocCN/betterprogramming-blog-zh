<html>
<head>
<title>Understanding Recursion, Recursively</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解递归，递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-recursion-recursively-181f5f4dc528?source=collection_archive---------1-----------------------#2019-05-29">https://betterprogramming.pub/understanding-recursion-recursively-181f5f4dc528?source=collection_archive---------1-----------------------#2019-05-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5c18" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一种解决问题的方法，其解决方案依赖于问题的一个简单实例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ee93675d9af48004b5eb1a5856057b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6dZZD9UjIx9-t5NXrZNVQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/search/photos/fractal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/photos/uQMyw1VFKqI?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Taras Chernus </a>拍摄的照片</p></figure><blockquote class="kz"><p id="c329" class="la lb it bd lc ld le lf lg lh li lj dk translated">要理解递归，首先必须理解递归。</p><p id="90bb" class="la lb it bd lc ld lk ll lm ln lo lj dk translated">——斯蒂芬·霍金</p></blockquote><p id="1a84" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj lj im bi translated">我在我的第一门计算机科学课程中学习了递归，然后很少使用它。我们被明确告知何时何地使用递归——在这些领域之外，我们班很少有人使用递归。回过头来看，这是可以理解的——递归是计算机科学中的一个主题，对许多人来说，它不是自然产生的。在大多数计算机科学项目中，学生在接触递归主题之前就已经学会了迭代思考。因此，大多数人在前进的过程中都会坚持迭代。</p><p id="05da" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">递归是一种解决问题的方法，其解决方案依赖于问题的一个简单实例。与试图建立解决方案的迭代相反，递归旨在将问题分解成最基本的形式。引入主题最常见的问题是阶乘。最起码，每个递归算法都需要两样东西:</p><ol class=""><li id="8ea9" class="mp mq it lr b ls mk lv ml ly mr mc ms mg mt lj mu mv mw mx bi translated">一个基础案例，它是问题的最简单形式的解决方案。基本情况的功能是作为一种摆脱递归调用的方式。</li><li id="13e6" class="mp mq it lr b ls my lv mz ly na mc nb mg nc lj mu mv mw mx bi translated">递归调用，这是方法调用自身的点。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ab50" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">以上是ruby中阶乘问题的示例解决方案。阶乘问题最简单的例子是0。0的阶乘是1，不需要进一步分解问题就可以解决。因此，我们首先检查给定的数字是否等于0。如果是，我们简单地返回1。在所有其他情况下，我们返回的数字乘以前一个数字的阶乘。事实上，大问题的解决方案是小问题解决方案的超集，这是这里的关键。它允许我们进行递归调用。不管起始数字是多少，我们知道如果我们继续分解问题，我们最终会得到一个小问题。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="4920" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">递归的一个必须强调的方面是它从来都不是必需的。递归只是解决问题的另一种方式。任何可以递归解决的问题也可以迭代解决。对于大多数程序员来说，递归思维通常比迭代思维更困难，除非你经常使用完全依赖递归的语言编程，否则你很可能会迭代地解决大部分问题。所有这些都回避了一个问题，为什么你要费心递归地思考。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="540e" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">幸运的是，在Ruby中，我们有inject/reduce方法。这两种方法互为别名，两者之间没有性能差异。这个方便的小方法意味着我们可以相对容易地解决这个问题。事实上，我们仍然使用相同的三元运算符将我们的解保留在一行中。首先我们检查数字是否为0，如果为真，我们返回1。在所有其他情况下，我们从1号开始并保存一个滚动产品，在最后返回它。</p><p id="3fc4" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">然而，在这方面，并不是所有的语言都像Ruby一样慷慨。如果您正在使用的编程语言没有reduce/inject等价函数，或者您从来不知道它，那么您的解决方案将类似于下图。您仍然使用相同的算法—检查数字是否等于0，如果为真，则返回1，否则保持滚动乘积，直到达到该数字。但是，看看为了实现相同的解决方案，还需要编写多少行代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0f03" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">一些解决方案在递归执行时看起来更简洁。更少的代码通常也意味着更易维护的代码。这意味着更少的逻辑错误区域和更好的可读性。例如，这段代码非常容易出错。如果你在<code class="fe nm nn no np b">while</code>条件下或者在总数乘以计数器时忘记了等号，你将会得到一个错误的答案。每一个逻辑和语法都是另一个潜在的错误点，迭代解决方案比上面的递归解决方案有更多的错误。</p><p id="deb1" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">现在我们已经看到了一个问题的递归解决方案的例子，让我们来理解为什么它会起作用。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="866f" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">谈到递归时，最常见的问题之一是，“它是如何工作的？”。初级程序员的困惑点包括不理解如何跟踪他们在递归调用中的位置，以及如何从基本情况返回到他们的问题实例。</p><p id="81f9" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">(不那么)简单的答案是调用堆栈。顾名思义，调用堆栈是一种堆栈类型的数据结构，它遵循先进先出(或者后进先出，如果您愿意的话)的方法来存储数据。这个特殊的堆栈存储计算机程序的各种子程序的信息。我们一直与调用堆栈进行交互，尽管在大多数情况下，这个过程是自动的，并且通常是隐藏的。放心，任何时候你编程，你给的指令被发送到调用栈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/8446e8ff91b1e3d9fd5470979cf00729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0NTojR47Qo7VDiCX455nA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">调用堆栈的可视化表示。</p></figure><p id="79b6" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">当我们第一次调用factorial(5)时，三元组的计算结果是5 * factorial(4)。被扔进调用堆栈。Following suit factorial(4)现在的计算结果是4 * factorial(3 ),这也将被抛出到调用堆栈中，位于之前的计算结果之上。然后是3 *阶乘(2)等等。这个过程一直持续到我们遇到调用factorial(0)的基本情况，这里我们简单地返回1。从这里，我们开始从调用堆栈中弹出。从调用堆栈中弹出factorial(0)后，我们弹出factorial(1)，其计算结果为1 * factorial(0)。但这次我们将factorial(0)计算为1，因此我们得到1 * 1，它被计算为1，因此我们在调用堆栈factorial(2)中弹出下一个实例，它被计算为2 * factorial(1)。到现在为止，你可能已经注意到我们也有阶乘(1)的解，并且，事实上，我们可以回到我们最初的问题。</p><p id="bf89" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">假设说，如果我们永远不中断递归调用会怎么样？事实上，我们可以做到这一点，只要简单地从我们的递归方法中删除我们的基本情况，或者绕过它。那么，在阶乘的情况下，如果我们，比如说，插入-1，会发生什么？在这种情况下，我们的阶乘(-1)将计算为-1 *阶乘(-2)，这又将计算为-2 *阶乘(-3)。所有这些指令都会被扔进堆栈，但是在这种情况下，我们的堆栈不会停止增长。这就是我们所说的堆栈溢出错误。我们不断地将指令压入堆栈，但从不弹出它们。最终，就像一堆文件，它变得太大，翻倒，程序崩溃。</p><p id="8ce2" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">我们现在可以更好地理解斯蒂芬·霍金在这个问题上的名言:“要理解递归，首先必须理解递归。”这似乎是一个奇怪的陈述——它天生就是递归的！如果我理解递归的唯一方法是理解递归，那么我如何理解递归呢？</p><p id="83ee" class="pw-post-body-paragraph lp lq it lr b ls mk ju lu lv ml jx lx ly mm ma mb mc mn me mf mg mo mi mj lj im bi translated">答案很简单…理解递归。这个循环会一直持续下去，直到你理解了递归。你对递归的理解是这个递归调用的基础。在此之前，您将永远陷入堆栈溢出错误！</p></div></div>    
</body>
</html>