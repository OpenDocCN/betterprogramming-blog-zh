<html>
<head>
<title>How to Handle Multiple Async Operations in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中处理多个异步操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/best-way-to-handle-multiple-async-operations-in-swift-85b5d82149b7?source=collection_archive---------3-----------------------#2020-05-01">https://betterprogramming.pub/best-way-to-handle-multiple-async-operations-in-swift-85b5d82149b7?source=collection_archive---------3-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cbb7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">提示:不要嵌套它们！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c2c839365ee9c1bf65324576d4da7dea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pWxo-bZQul3JiGNN"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@hjrc33?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">埃克托尔·j·里瓦斯</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="ff2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们遇到过这样的情况，我们需要等待一些API完成，然后处理进一步的逻辑或者相应地更新UI。我们将看到我(可能还有许多其他人)过去是怎么做的，然后是使用Swift的最佳方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="30e2" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">问题</h1><p id="5c58" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">正如你在下面看到的，我们调用了两个API，然后我们想更新UI。我们将使用Alamofire来简化API请求。我们还记录了两个API完成所花费的时间。</p><p id="20a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果你自己尝试这个，那么不要忘记在你的<code class="fe mw mx my mz b">Info.plist</code>文件中设置应用传输安全设置➡允许任意负载到<code class="fe mw mx my mz b">YES</code>。</p><h2 id="7986" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated">密码</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="438f" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated">代码解释</h2><ul class=""><li id="204b" class="no np iq ky b kz mr lc ms lf nq lj nr ln ns lr nt nu nv nw bi translated">端点是将我们稍后要调用的API的URL保存在一起的结构</li><li id="7c86" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">需要一个<code class="fe mw mx my mz b">IBOutlet</code>来访问UI对象，以便在API响应状态改变时更新它们</li><li id="eb28" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe mw mx my mz b">startTimeInterval</code>是指我们开始第一次API调用的时间</li><li id="0c19" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe mw mx my mz b">isWaiting</code>正在跟踪是否有我们正在等待响应的API请求。当状态改变时，它更新用户界面。</li><li id="1d4e" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">在<code class="fe mw mx my mz b">viewDidLoad()</code>中，我们使用Alamofire调用两个API。请记住，我们正在嵌套它们。所以这些API请求将一个接一个地执行，而不是同时执行。</li><li id="e2d7" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated"><code class="fe mw mx my mz b">updateUI()</code>实际上就是分别用适当的文本和动画更新标签和<code class="fe mw mx my mz b">activityIndicatorView</code></li></ul><h2 id="95e5" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated">故事板</h2><p id="ad53" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你想知道我们的故事板是什么样子的，它已经非常精简了。它只是一个标签和一个活动指示器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/9beaa26c7a898f8d1102da5622912473.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*Ld0kmRDYsI-ZRpz1kLDMmA.png"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="8f8c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">解决方案:“调度组”</h1><p id="daf6" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在进入(双关语！)的<code class="fe mw mx my mz b"><a class="ae kv" href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener ugc nofollow" target="_blank">DispatchGroup</a></code>。它是专门为这种情况设计的，将多个任务组合在一起，然后等待它们完成。当所有任务完成时，它可以通过快速关闭来通知，这样我们就可以继续进行。</p><h2 id="7d88" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated">密码</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="7d65" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated">代码解释</h2><ul class=""><li id="03f0" class="no np iq ky b kz mr lc ms lf nq lj nr ln ns lr nt nu nv nw bi translated">我们已经添加了一个<code class="fe mw mx my mz b">DispatchGroup</code>实例</li><li id="22c6" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">我们对组使用<code class="fe mw mx my mz b">enter()</code>方法。这是为了告诉<code class="fe mw mx my mz b">DispatchGroup</code>我们在等待什么。把<code class="fe mw mx my mz b">DispatchGroup</code>想象成它在计算<code class="fe mw mx my mz b">enter()</code>被调用了多少次。因此，每次调用<code class="fe mw mx my mz b">enter()</code>时，计数器都会加1。</li><li id="b0f4" class="no np iq ky b kz nx lc ny lf nz lj oa ln ob lr nt nu nv nw bi translated">我们已经删除了嵌套的API调用，以及我们如何同时调用这两个API。总的来说，这使得API等待时间更短。这里，注意我们使用<code class="fe mw mx my mz b">leave()</code>方法告诉<code class="fe mw mx my mz b">DisaptchGroup</code>任务已经完成，意味着已经收到API响应。通过调用<code class="fe mw mx my mz b">leave()</code>方法，我们将把我们的虚计数器减1。一旦我们的虚计数器达到零，<code class="fe mw mx my mz b">DispatchGroup</code>就会调用<code class="fe mw mx my mz b">notify()</code>方法。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/ebf16fb2e2606d88a6b9f78d486e9c29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2JcrRGFk3j0Er45jsIArIA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:苹果文档</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/36dceef1176e1b1651e30fed344be118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gx1HTfS2Ub2TZ28ULiSdCw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:苹果文档</p></figure><p id="23f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>每个<code class="fe mw mx my mz b">enter()</code>呼叫还应伴随一个<code class="fe mw mx my mz b">leave()</code>呼叫。否则，根本不会执行<code class="fe mw mx my mz b">notify()</code>方法。</p><p id="38f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能只想在API调用之前调用<code class="fe mw mx my mz b">enter()</code>,如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="64fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是我建议你避免这种情况，因为在非常非常罕见的情况下，如果API响应太快，那么组几乎会立即进入和离开，如果组中没有其他调度的任务，它会调用<code class="fe mw mx my mz b">notify()</code>方法，而不会等待你的下一个任务。</p><p id="2d5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我个人认为，如果我们事先知道要开始多少任务，我们应该将<code class="fe mw mx my mz b">enter()</code>个电话组合在一起。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="fa79" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="6690" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">太好了！今天我们学习了如何使用<code class="fe mw mx my mz b">DispatchGroup</code>来等待异步操作。使用<code class="fe mw mx my mz b">DispatchGroup</code>有不同的方法，但那是另外一天。</p><p id="43e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读。</p><h2 id="9d8c" class="na ma iq bd mb nb nc dn mf nd ne dp mj lf nf ng ml lj nh ni mn ln nj nk mp nl bi translated">下载代码</h2><div class="of og gp gr oh oi"><a href="https://github.com/akshitzaveri/DispatchGroupExamples" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">akshitzaveri/dispatch group示例</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">通过在GitHub上创建一个帐户，为akshitzaveri/dispatchgroupemples开发做出贡献。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kp oi"/></div></div></a></div></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="473c" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><div class="of og gp gr oh oi"><a href="https://developer.apple.com/documentation/dispatch/dispatchgroup" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">调度组</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">声明组允许您聚合一组任务并同步组上的行为。您附加了多个…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">developer.apple.com</p></div></div></div></a></div></div></div>    
</body>
</html>