<html>
<head>
<title>Indexing Strings in Rust and TypeScript: A Case Study of Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust和TypeScript中的索引字符串:字符串的案例研究</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/indexing-strings-in-rust-and-typescript-a-case-study-of-strings-805b351ca4d6?source=collection_archive---------6-----------------------#2021-12-29">https://betterprogramming.pub/indexing-strings-in-rust-and-typescript-a-case-study-of-strings-805b351ca4d6?source=collection_archive---------6-----------------------#2021-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="996c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Rust和JavaScript如何处理字符串，以及如何处理字形甚至表情符号等细微差别。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/94f6afadfe67880ca2e856475a23981f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOx9Gq9b4yyMaLRZxLljpw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><h1 id="908c" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="dbbb" class="lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">🪢访问带索引的字符串中的字符在Rust中是不可编译的。</li><li id="5149" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">🎸我们将讨论Rust如何看待字符串。</li><li id="39e6" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">🤖我们将讨论JavaScript如何处理字符串。</li><li id="aedc" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">🧑‍🔬我们将比较Rust和TypeScript中的一个经典算法<code class="fe mn mo mp mq b">is_palindrome</code>。</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="7b69" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">文本在编程语言中是必不可少的。String是Rust和JavaScript的定义，用于处理世界各地书面语言中的文本。通过字符串索引的简单概念，我们将讨论Rust和JavaScript如何处理字符串，以及它们如何处理字符串中的细微差别，如字形，甚至表情符号。</p><p id="5212" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">让我们用一个经典算法<code class="fe mn mo mp mq b">is_palindrome</code>来介绍一下字符串索引的概念。</p><h1 id="161e" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated"><code class="fe mn mo mp mq b">is_palindrome</code>在生锈</h1><p id="0295" class="pw-post-body-paragraph my mz it ls b lt lu ju nb lv lw jx nd lx nn nf ng lz no ni nj mb np nl nm md im bi translated">一个<a class="ae nq" href="https://en.wikipedia.org/wiki/Palindrome" rel="noopener ugc nofollow" target="_blank">回文</a>，用一种非常一般的方式来解释，就是一个前后读起来一样的字符串。”<strong class="ls iu"> Ana </strong>是回文，“<strong class="ls iu">一条狗！宝塔里的恐慌！</strong>"是回文，甚至"<strong class="ls iu"> 02/02/2020 </strong>"也是回文。</p><p id="2466" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">出于本文的目的，我们将使用一个更窄的定义来保持算法简单。这里的回文被定义为“没有空格的小写ASCII字母字符的连续序列”。</p><p id="57b2" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">一种直观的方法是使用两个指针。一个从给定字符串的开头开始向末尾移动，另一个从末尾向开头移动。移动指针时，比较指向字符。如果所有的比较都相等，那么给定的字符串就是一个回文。像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d486" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">如果你试着编译这个程序，你会注意到Rust编译器不允许我们通过索引访问字符。这是一个非常有趣的约束，因为像JavaScript、Go和Python这样的许多语言都提供了这个特性。</p><p id="10ce" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">随着我们深入挖掘，标准库中有一些字符串方法可以访问字符串中的字符，比如<code class="fe mn mo mp mq b"><a class="ae nq" href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.chars" rel="noopener ugc nofollow" target="_blank">chars()</a></code>。<code class="fe mn mo mp mq b">chars()</code>返回字符串切片的<code class="fe mn mo mp mq b">char</code>上的迭代器。所以我们必须遍历一个字符串片，通过索引来访问字符。像这样:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="372e" class="nx kz it mq b gy ny nz l oa ob">let left = str.as_str().chars().nth(lp).unwrap();</span></pre><p id="927b" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">访问字符串中一个字符的简单任务的时间复杂度是<code class="fe mn mo mp mq b">O(n)</code>而不是<code class="fe mn mo mp mq b">O(1)</code>。</p><p id="3b98" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">这是为什么呢？</p><h1 id="8e11" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">Rust的字符串是Unicode和UTF 8编码的</h1><p id="fdd0" class="pw-post-body-paragraph my mz it ls b lt lu ju nb lv lw jx nd lx nn nf ng lz no ni nj mb np nl nm md im bi translated">我们可以从<a class="ae nq" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">官方锈书</a>中找到锈弦的<a class="ae nq" href="https://doc.rust-lang.org/book/ch08-02-strings.html#internal-representation" rel="noopener ugc nofollow" target="_blank">内参</a>。</p><blockquote class="oc od oe"><p id="d882" class="my mz of ls b lt na ju nb lv nc jx nd og ne nf ng oh nh ni nj oi nk nl nm md im bi translated">字符串是Vec &lt; u8 &gt;上的包装器。</p></blockquote><p id="9547" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">对于<a class="ae nq" href="https://en.wikipedia.org/wiki/ASCII" rel="noopener ugc nofollow" target="_blank"> ASCII码</a>中的字符串，每个字符由在<a class="ae nq" href="https://en.wikipedia.org/wiki/UTF-8" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a>中编码的1个字节表示。然而，对于其他书面语言中的字符串，如Rust book中的梵文脚本中的<a class="ae nq" href="https://doc.rust-lang.org/book/ch08-02-strings.html#bytes-and-scalar-values-and-grapheme-clusters-oh-my" rel="noopener ugc nofollow" target="_blank">“नमस्ते”,每个字符都以UTF-8编码，具有多个</a><a class="ae nq" href="https://en.wikipedia.org/wiki/Unicode" rel="noopener ugc nofollow" target="_blank"> Unicode值</a>(代码单元)。</p><p id="545d" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">所以在锈书里，它说:</p><blockquote class="oc od oe"><p id="ce95" class="my mz of ls b lt na ju nb lv nc jx nd og ne nf ng oh nh ni nj oi nk nl nm md im bi translated"><em class="it">对字符串进行索引通常不是一个好主意，因为不清楚字符串索引操作的返回类型应该是什么:字节值、字符、字素簇还是字符串片段。</em></p></blockquote><p id="25a2" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">这也是Rust编译器不允许直接访问字符串中的字符的原因之一。我真的推荐你在<a class="ae nq" href="https://doc.rust-lang.org/book/ch08-02-strings.html" rel="noopener ugc nofollow" target="_blank">锈书</a>里多看看。非常好读，很有见地。</p><h1 id="6be3" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">校正<code class="fe mn mo mp mq b">is_palindrome</code></h1><p id="cf2b" class="pw-post-body-paragraph my mz it ls b lt lu ju nb lv lw jx nd lx nn nf ng lz no ni nj mb np nl nm md im bi translated">我们可以对<a class="ae nq" href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.bytes" rel="noopener ugc nofollow" target="_blank">字节</a>进行迭代，并将字符串的前半部分与反转的后半部分进行比较。如果它们相等，这是一个回文:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a0cc" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">时空复杂度:</p><ul class=""><li id="0771" class="lq lr it ls b lt na lv nc lx oj lz ok mb ol md me mf mg mh bi translated">O(n) time，其中n是字符串的长度。</li><li id="8ae2" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">O(1)空间。</li></ul><p id="6621" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">空间复杂度是<code class="fe mn mo mp mq b">O(1)</code>，因为每个迭代器创建一个指针和一个计数器。</p><p id="0eac" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">另一种方法是使用<a class="ae nq" href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html" rel="noopener ugc nofollow" target="_blank"> DoubleEndedIterator </a>特征，并用<code class="fe mn mo mp mq b"><a class="ae nq" href="https://doc.rust-lang.org/std/iter/fn.zip.html" rel="noopener ugc nofollow" target="_blank">zip()</a></code>组合前向和后向迭代器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="db29" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">时空复杂度:</p><ul class=""><li id="1c4f" class="lq lr it ls b lt na lv nc lx oj lz ok mb ol md me mf mg mh bi translated">O(n) time，其中n是字符串的长度。</li><li id="8ea5" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">O(1)空间。</li></ul><p id="cb1d" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated"><a class="ae nq" href="https://www.reddit.com/r/programming/comments/rr9dlw/indexing_strings_in_rust_and_typescript_a_case/" rel="noopener ugc nofollow" target="_blank">Reddit</a>上建议采用这种方式。非常感谢！</p><h1 id="3cce" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">在打字稿中</h1><p id="553d" class="pw-post-body-paragraph my mz it ls b lt lu ju nb lv lw jx nd lx nn nf ng lz no ni nj mb np nl nm md im bi translated">JavaScript允许字符串索引。所以我们实际上可以翻译rust中没有编译的双指针算法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="5abf" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">时间和空间复杂度为:</p><ul class=""><li id="e142" class="lq lr it ls b lt na lv nc lx oj lz ok mb ol md me mf mg mh bi translated">O(n) time，其中n是字符串的长度</li><li id="1872" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">O(1)空间。两个指针的恒定空间。</li></ul><p id="c41f" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">或者只是向前和向后比较字符串:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="1829" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">时空复杂度:</p><ul class=""><li id="2692" class="lq lr it ls b lt na lv nc lx oj lz ok mb ol md me mf mg mh bi translated">O(n) time，其中n是输入字符串的长度</li><li id="d271" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated">O(n)空间，其中n是输入字符串的长度</li></ul><p id="3d33" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">这在JavaScript中相当容易。这是否意味着JavaScript对待字符串的方式与Rust不同？</p><h1 id="0267" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">JavaScript字符串是UTF-16编码的</h1><p id="38b6" class="pw-post-body-paragraph my mz it ls b lt lu ju nb lv lw jx nd lx nn nf ng lz no ni nj mb np nl nm md im bi translated">我们可以在<a class="ae nq" href="https://tc39.es/ecma262/#sec-terms-and-definitions-string-value" rel="noopener ugc nofollow" target="_blank"> ECMAScript标准</a>中找到字符串原始值的定义:</p><blockquote class="oc od oe"><p id="aea9" class="my mz of ls b lt na ju nb lv nc jx nd og ne nf ng oh nh ni nj oi nk nl nm md im bi translated"><em class="it">原始值，即零个或多个16位无符号整数值的有限有序序列</em></p><p id="ccc7" class="my mz of ls b lt na ju nb lv nc jx nd og ne nf ng oh nh ni nj oi nk nl nm md im bi translated"><em class="it">字符串值是字符串类型的成员。序列中的每个整数值通常表示UTF-16文本的一个16位单元。</em></p></blockquote><p id="5be0" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">换句话说，每个JavaScript字符用两个字节的Unicode表示，用UTF-16编码。</p><p id="6b79" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">让我们来看一些例子。我们可以使用一个或两个代码单元来创建一个角色:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="0476" class="nx kz it mq b gy ny nz l oa ob">const s1: string = '\u00E1' // á<br/>const s2: string = '\u0061\u0301' // á</span></pre><p id="680d" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated"><code class="fe mn mo mp mq b">s1</code>和<code class="fe mn mo mp mq b">s2</code>组成一个<code class="fe mn mo mp mq b">á</code>。如果我们检查两根弦的长度:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="ec4d" class="nx kz it mq b gy ny nz l oa ob">console.log(s1.length) // 1<br/>console.log(s2.length) // 2</span></pre><p id="6cb3" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">即使它们都表示相同的字符，长度也是不同的。让我们用字符串索引查看字符串内部，找出字符串中的元素:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="2165" class="nx kz it mq b gy ny nz l oa ob">console.log(s1[0]) // á<br/>console.log(s1[1]) // undefined</span><span id="78bb" class="nx kz it mq b gy om nz l oa ob">console.log(s2[0]) // a<br/>console.log(s2[1]) //  ́<br/>console.log(s2[2]) //  undefined</span></pre><p id="87f2" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">我们可以看到<code class="fe mn mo mp mq b">s2</code>是由两个独立的元素<code class="fe mn mo mp mq b">a</code>和<code class="fe mn mo mp mq b">́</code>组成的。</p><p id="2de3" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">仅仅是看到同一个字符可以用不同的方式表示，很明显JavaScript中的字符串索引也不可靠。</p><p id="5566" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">让我们检查是否相等:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="a026" class="nx kz it mq b gy ny nz l oa ob">console.log(s1 === s2) // false 🧐</span></pre><p id="c84a" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">更有趣的是，还有另一种方法来组合角色<code class="fe mn mo mp mq b">á</code>:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="901c" class="nx kz it mq b gy ny nz l oa ob">const s3: string = 'a\u0301' // á</span></pre><p id="56c7" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">在<code class="fe mn mo mp mq b">s3</code>中，我们将代码单元<code class="fe mn mo mp mq b">\u0061</code>替换为其代表字符<code class="fe mn mo mp mq b">a</code>。让我们做一些检查:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="0b9b" class="nx kz it mq b gy ny nz l oa ob">console.log(s3.length === 2) // true<br/>console.log(s2 === s3) // true 🧐<br/>console.log(s1 === s3) // false</span></pre><p id="a233" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">到目前为止，我们看到的是，有多个代码单元组合来表示同一个字符。相等性是由代码单元组合定义的。</p><p id="af44" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">这非常不方便，所以JavaScript引入了一个字符串方法<code class="fe mn mo mp mq b"><a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize" rel="noopener ugc nofollow" target="_blank">normalize()</a></code>来返回给定字符串的Unicode范式。让我们用<code class="fe mn mo mp mq b">s1</code>、<code class="fe mn mo mp mq b">s2</code>和<code class="fe mn mo mp mq b">s3</code>来试试:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="7d69" class="nx kz it mq b gy ny nz l oa ob">console.log(s1.normalize() === s2.normalize()) // true<br/>console.log(s1.normalize() === s3.normalize()) // true</span></pre><p id="28eb" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">让我们来看看<code class="fe mn mo mp mq b">á</code>的规范化形式:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="6219" class="nx kz it mq b gy ny nz l oa ob">// `escape` is deprecated.<br/>escape(s1.normalize()) // '%E1'<br/>escape(s2.normalize()) // '%E1'<br/>escape(s3.normalize()) // '%E1'</span></pre><p id="65ba" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">注意<code class="fe mn mo mp mq b"><a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape" rel="noopener ugc nofollow" target="_blank">escape()</a></code>已经从ECMAScript标准中删除。</p><p id="882e" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">由于标准化，现在处理字符串更加容易预测。</p><p id="ce71" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">JavaScript实际上提供了官方的<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/Encoding_API" rel="noopener ugc nofollow" target="_blank">编码API </a>。我们可以使用<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder" rel="noopener ugc nofollow" target="_blank"> TextEncoder </a>和<a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder" rel="noopener ugc nofollow" target="_blank"> TextDecoder </a>来处理字符串编码和解码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="c164" class="ky kz it bd la lb on ld le lf oo lh li jz op ka lk kc oq kd lm kf or kg lo lp bi translated">综上</h1><p id="c2a9" class="pw-post-body-paragraph my mz it ls b lt lu ju nb lv lw jx nd lx nn nf ng lz no ni nj mb np nl nm md im bi translated">字符串很复杂。Rust提供了一个健壮的系统来处理字符串，并提供了一个严格的编译器来鼓励我们提前考虑字符串处理。另一方面，JavaScript提供了方便的API来处理像ASCII这样的简单用例。在幕后，它们都实现了Unicode标准和编码，以支持国际性的书写语言。</p><h1 id="99a2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">参考</h1><ul class=""><li id="d45d" class="lq lr it ls b lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><a class="ae nq" href="https://en.wikipedia.org/wiki/ASCII" rel="noopener ugc nofollow" target="_blank"> ASCII码</a></li><li id="4e6d" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://en.wikipedia.org/wiki/Unicode" rel="noopener ugc nofollow" target="_blank"> Unicode </a></li><li id="1b8d" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://en.wikipedia.org/wiki/UTF-8" rel="noopener ugc nofollow" target="_blank"> UTF-8 </a></li><li id="f9fd" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://en.wikipedia.org/wiki/UTF-16" rel="noopener ugc nofollow" target="_blank"> UTF-16 </a></li><li id="fa97" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://en.wikipedia.org/wiki/Palindrome" rel="noopener ugc nofollow" target="_blank">回文</a></li><li id="285f" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://doc.rust-lang.org/book/" rel="noopener ugc nofollow" target="_blank">Rust编程语言</a></li><li id="a55d" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://doc.rust-lang.org/book/ch08-02-strings.html#internal-representation" rel="noopener ugc nofollow" target="_blank"> Rust的字符串内部表示</a></li><li id="e768" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.chars" rel="noopener ugc nofollow" target="_blank">锈弦法</a> <code class="fe mn mo mp mq b"><a class="ae nq" href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.chars" rel="noopener ugc nofollow" target="_blank">chars()</a></code></li><li id="1ed5" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.bytes" rel="noopener ugc nofollow" target="_blank">锈弦法</a> <code class="fe mn mo mp mq b"><a class="ae nq" href="https://doc.rust-lang.org/stable/std/string/struct.String.html#method.bytes" rel="noopener ugc nofollow" target="_blank">bytes()</a></code></li><li id="4900" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://doc.rust-lang.org/std/iter/fn.zip.html" rel="noopener ugc nofollow" target="_blank">锈弦法</a>T2】</li><li id="d829" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html" rel="noopener ugc nofollow" target="_blank">锈弦性状</a>T3】</li><li id="dc60" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://tc39.es/ecma262/#sec-terms-and-definitions-string-value" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2022语言规范</a></li><li id="6e11" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize" rel="noopener ugc nofollow" target="_blank">JavaScript</a>T4】</li><li id="b815" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://developer.mozlla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/escape" rel="noopener ugc nofollow" target="_blank">JavaScript</a>T5】</li><li id="1195" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/Encoding_API" rel="noopener ugc nofollow" target="_blank"> JavaScript编码API </a></li><li id="fcad" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder" rel="noopener ugc nofollow" target="_blank"> JavaScript TextEncoder </a></li><li id="a1db" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder" rel="noopener ugc nofollow" target="_blank"> JavaScript TextDecoder </a></li><li id="05d3" class="lq lr it ls b lt mi lv mj lx mk lz ml mb mm md me mf mg mh bi translated"><a class="ae nq" href="https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/" rel="noopener ugc nofollow" target="_blank">每个JavaScript开发人员应该知道的Unicode知识</a></li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="a97d" class="pw-post-body-paragraph my mz it ls b lt na ju nb lv nc jx nd lx ne nf ng lz nh ni nj mb nk nl nm md im bi translated">这篇文章最初发布在<a class="ae nq" href="https://dawchihliou.github.io/articles/indexing-strings-in-rust-and-typescript" rel="noopener ugc nofollow" target="_blank">道智的网站</a>。</p></div></div>    
</body>
</html>