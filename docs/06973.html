<html>
<head>
<title>Introducing Coroutines StateFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引入协程StateFlow</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/introducing-coroutines-stateflow-ca1b13133265?source=collection_archive---------3-----------------------#2020-11-23">https://betterprogramming.pub/introducing-coroutines-stateflow-ca1b13133265?source=collection_archive---------3-----------------------#2020-11-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6492" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">这是Android版LiveData的终结吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1bc59a15e8eba5191edfd1d6175f2890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fIzZ0At5spRQ_39M"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@ravipinisetti?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ravi Pinisetti </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="c4ca" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">这篇文章的要点</h1><p id="761d" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在本文中，您将了解什么是<a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/" rel="noopener ugc nofollow" target="_blank"> StateFlow </a>，如何使用它，使用它的优势，以及一些实时问题的解释和解决方案。通过将其与<code class="fe mn mo mp mq b"><a class="ae ky" href="https://developer.android.com/topic/libraries/architecture/livedata" rel="noopener ugc nofollow" target="_blank">LiveData</a></code>进行比较，我将发表我对使用StateFlow胜过使用<code class="fe mn mo mp mq b">LiveData</code>的想法。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="2366" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">介绍</h1><p id="2913" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><a class="ae ky" href="https://kotlinlang.org/docs/reference/coroutines-overview.html" rel="noopener ugc nofollow" target="_blank">协程</a>中的<a class="ae ky" href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="noopener ugc nofollow" target="_blank">流API </a>是处理数据流的更好方式；StateFlow试图利用Flow的强大功能来管理应用程序中的状态。如果你看到StateFlow的语法，它是由<a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/index.html" rel="noopener ugc nofollow" target="_blank"> SharedFlow </a>扩展的。看一看:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="f6ea" class="nh la it mq b gy ni nj l nk nl">@ExperimentalCoroutinesApi interface <strong class="mq iu">StateFlow</strong>&lt;out T&gt; : <br/>    <a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/index.html" rel="noopener ugc nofollow" target="_blank"><strong class="mq iu">SharedFlow</strong></a>&lt;<a class="ae ky" href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/index.html#T" rel="noopener ugc nofollow" target="_blank">T</a>&gt;<!-- --> <a class="ae ky" href="https://github.com/kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/StateFlow.kt#L139" rel="noopener ugc nofollow" target="_blank">(source)</a></span></pre><p id="06b9" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">SharedFlow是具有单个可更新数据值的只读状态，它向其收集器发出更新。与常规流不同，状态流是一个<em class="nr">热</em>流，因为它的活动实例独立于收集器的存在而存在。StateFlow的当前值可以通过value属性检索。</p><p id="db99" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">StateFlow有两种变体— <code class="fe mn mo mp mq b"> StateFlow</code>和<code class="fe mn mo mp mq b">MutabaleStateFlow</code>。</p><ul class=""><li id="6271" class="ns nt it lt b lu nm lx nn ma nu me nv mi nw mm nx ny nz oa bi translated"><code class="fe mn mo mp mq b">StateFlow&lt;T&gt;</code>接口是一个只读视图，它提供对当前<code class="fe mn mo mp mq b">value</code>的访问，并实现一个<code class="fe mn mo mp mq b">Flow&lt;T&gt;</code>来收集值的更新。</li><li id="34de" class="ns nt it lt b lu ob lx oc ma od me oe mi of mm nx ny nz oa bi translated"><code class="fe mn mo mp mq b">MutabaleStateFlow&lt;T&gt;</code>接口增加了修改值操作。</li></ul></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="732f" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">如何使用StateFlow</h1><p id="3626" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，让我们创建一个<code class="fe mn mo mp mq b">enum</code>类，并在视图中包含一些由<code class="fe mn mo mp mq b">viewModel</code>触发时需要管理的状态。看一下<code class="fe mn mo mp mq b">enum</code>类:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="da96" class="nh la it mq b gy ni nj l nk nl">enum class <strong class="mq iu">CustomStates</strong>{<br/>    SHOW_LOADING, HIDE_lOADING, SHOW_TOAST, HOMESCREEN, BACK<br/>}</span></pre><p id="7fff" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">现在我们需要创建<code class="fe mn mo mp mq b">CustomStates</code> <strong class="lt iu"> </strong>类型的<code class="fe mn mo mp mq b">MutableStateFlow</code>和<code class="fe mn mo mp mq b">StateFlow</code>变体。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="e0ce" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">这里的<code class="fe mn mo mp mq b">MutableStateFlow</code>是只能从<code class="fe mn mo mp mq b">viewModel</code>更新的私有含义。<code class="fe mn mo mp mq b">StateFlow</code>是公共的，意味着可以从视图中访问它来观察<code class="fe mn mo mp mq b">MutableStateFlow</code>中的变化。</p><p id="40ff" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">现在我们需要创建一个函数来更新<code class="fe mn mo mp mq b">MutableStateFlow</code>的值。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="a471" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">我忘记提到StateFlow是一个实验性的特性，所以我们需要提到<code class="fe mn mo mp mq b">ExperimentalCoroutinesApi</code>来显式地禁用警告。</p><p id="22f2" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">我们已经完成了状态流的创建和更新；下一步是收集视图中发出的值。这类似于从正常流中收集值。看一看:</p><pre class="kj kk kl km gt nd mq ne nf aw ng bi"><span id="9c09" class="nh la it mq b gy ni nj l nk nl">viewModel.customState.<strong class="mq iu">collect </strong>{<br/>    "Latest state is  $it".print()<br/>}</span></pre><p id="5b38" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">这就是全部——我们已经使用协程中新的StateFlow完成了对来自<code class="fe mn mo mp mq b">viewModel</code>的UI状态的管理。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="a250" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">隐藏的问题和解决方案</h1><p id="726e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">最初实现StateFlow时，我们似乎没有注意到两个问题:</p><h2 id="b003" class="nh la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">问题</h2><ul class=""><li id="c06a" class="ns nt it lt b lu lv lx ly ma ot me ou mi ov mm nx ny nz oa bi translated">我们不能将StateFlow限制到一组特定的订阅者或视图，因此即使在视图被销毁后，它也可以收集值。</li><li id="3f76" class="ns nt it lt b lu ob lx oc ma od me oe mi of mm nx ny nz oa bi translated">StateFlow是热的，这意味着它是活动的，与收集器无关。这是个问题。当您重新创建使用StateFlow的片段时，将发出最后一个值，而不是初始值。</li><li id="634b" class="ns nt it lt b lu ob lx oc ma od me oe mi of mm nx ny nz oa bi translated"><code class="fe mn mo mp mq b">LiveData</code>仅在<code class="fe mn mo mp mq b">LifecycleOwner</code>处于激活状态时发出。如果生命周期状态比开始状态“低”,它将暂停消耗。这与StateFlow中的行为不同。</li></ul><h2 id="6b10" class="nh la it bd lb oi oj dn lf ok ol dp lj ma om on ll me oo op ln mi oq or lp os bi translated">解决方法</h2><ul class=""><li id="a53a" class="ns nt it lt b lu lv lx ly ma ot me ou mi ov mm nx ny nz oa bi translated">将状态流限制为片段或活动是不可能的。我们仍然可以用那个视图的生命周期范围来包装它，所以一旦这个片段被销毁，我们不会收到任何更新，因为这个范围会取消所有的作业。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="2ac9" class="ns nt it lt b lu nm lx nn ma nu me nv mi nw mm nx ny nz oa bi translated">第二个问题的解决方案是在重新创建视图时接收初始值，而不是最后一个值。我们可以通过在<code class="fe mn mo mp mq b">viewModel</code>的<code class="fe mn mo mp mq b">onCleared</code>函数中发布StateFlow的初始值来实现这一点。看一看:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure><ul class=""><li id="cc2b" class="ns nt it lt b lu nm lx nn ma nu me nv mi nw mm nx ny nz oa bi translated">为了让StateFlow生命周期意识到复制这种<code class="fe mn mo mp mq b">LiveData</code>行为，我们需要使用<code class="fe mn mo mp mq b">launchWhenStarted</code>。看一看:</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="fbb0" class="kz la it bd lb lc my le lf lg mz li lj jz na ka ll kc nb kd ln kf nc kg lp lq bi translated">StateFlow与LiveData</h1><p id="803b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated"><code class="fe mn mo mp mq b">LiveData</code>是一个可观察的数据持有者类——意味着<code class="fe mn mo mp mq b">LiveData</code>可以保存一组可以被其收集器观察到的数据，这类似于StateFlow。我们在这里所做的一切也可以通过<code class="fe mn mo mp mq b">LiveData</code>来实现。那有什么区别呢？</p><p id="fc57" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">各有千秋，比如<code class="fe mn mo mp mq b">LiveData</code>目前比StateFlow更成熟。但是有了StateFlow，我们可以使用强大的功能，如combine、zip等。高级功能也有一些缺点，比如当与之相关的视图被销毁时，需要手动分配初始状态。</p><p id="2f09" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">我不认为StateFlow可以取代<code class="fe mn mo mp mq b">LiveData</code>，至少不是马上。StateFlow的核心理念(状态不能被破坏，即重新初始化时发出最后一个状态)与我们在大多数情况下在Android组件中使用<code class="fe mn mo mp mq b">LiveData</code>的主要原因完全相反。</p><p id="ae7b" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">但是，在一些用例中，我们需要在整个应用程序会话中管理状态，我认为这是StateFlow可以帮助我们实现的地方。</p><p id="48a5" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">这是我对Android中StateFlow的初步看法。如果您对StateFlow有任何建议或不同的观点，请发表评论，以便我们共同学习。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="56f1" class="pw-post-body-paragraph lr ls it lt b lu nm ju lw lx nn jx lz ma no mc md me np mg mh mi nq mk ml mm im bi translated">就这些了，希望你能学到一些有用的东西，感谢阅读。</p></div></div>    
</body>
</html>