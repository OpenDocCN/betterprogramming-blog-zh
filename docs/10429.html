<html>
<head>
<title>Architecting Distributed Systems: Increasing Availability Using Client Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建分布式系统:使用客户端库提高可用性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/architecting-distributed-systems-increasing-availability-using-client-libraries-b4763d4d74c9?source=collection_archive---------6-----------------------#2022-01-06">https://betterprogramming.pub/architecting-distributed-systems-increasing-availability-using-client-libraries-b4763d4d74c9?source=collection_archive---------6-----------------------#2022-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6704" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过在客户端应用程序中拥有一个库，我们可以一致地处理故障，增加系统的可用性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b98701fb544574fd5ee3c531e51c54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ymGPxRyNLto1-So_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="adf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开发我们公司内部或外部使用的API时，除了记录和公开端点之外，我们还可以选择交付客户端库。这种方法对用户来说有多种优势:更容易实现(有时甚至只有一行代码)，更容易迁移(通常只是添加一个依赖版本)，可能更容易设置安全性。</p><p id="b9d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然开发和维护这样的客户端库需要花费精力，但是它们也可以给API开发人员带来一个重要的好处，其中之一就是系统增加的可感知的正常运行时间/可用性<strong class="lb iu">。当出现瞬时故障时，重试操作通常可以解决问题。这种逻辑可以构建到客户端库中，并且有很大的效果。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/6266477454eb119ee65934bb419b60fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yw0L6BIGlNghlyvaN_t87w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">我们可以改善我们所能影响的。通过在客户端应用程序中拥有我们的一部分代码，我们可以用一致的方式处理错误，增加集成的可感知可用性。如果你想了解为什么会发生瞬时故障，这篇来自Azure docs的文章是一个瑰宝。</p></figure><p id="6dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文的目的是了解在什么情况下，在普通API定义上添加一个客户端库可以显著提高正常运行时间。首先，我们将回顾分布式系统架构中的一些最佳实践，这些实践是受益于借助客户端库实现的正常运行时间的必要前提。然后，我们将详细讨论如何开发一个客户端库来增加我们系统的正常运行时间，同时又不会花费太多的维护成本。在文章的结尾，我将提到客户端库如何让API开发人员的生活变得更好的一些其他方法。</p><p id="6b4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开始之前，让我们在本文的上下文中定义可用性/正常运行时间。它是“<em class="lw">从客户端的角度来看成功操作的百分比</em>”，这意味着，在普通HTTP实现的情况下，它是没有超时或返回5xx响应代码的请求的百分比。在库实现的情况下，它是没有导致异常或返回服务器错误的成功方法调用的百分比。</p><p id="10d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，我们试图通过重试来减少客户端感知到的错误<strong class="lb iu">的数量，而不是失败的网络请求或服务重启的数量。让我们首先了解一些最重要的先决条件。</strong></p><h1 id="8761" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">🌎先决条件1:高可用性和DNS</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/4d7a1d4ceb749425bf4ce0a46c83ae0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7dWqCzsMzTmn-I7MfA0HQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">客户端需要能够通过不同的基础架构重试失败的操作</p></figure><p id="feb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了获得高重试成功率，我们需要没有单点故障的基础架构。如果其中一个物理位置的应用程序停止响应，并且我们有理由相信该位置存在问题，那么高可用性设置将允许客户端开始将请求路由到另一个物理位置的负载平衡器。</p><p id="4796" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果应用程序完全托管在单个物理位置上，则在出现临时网络故障时，客户端重试仍然有所帮助，但是在物理位置出现故障时，整个应用程序将变得不可用。</p><p id="2609" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用高可用性设置，请确保您的DNS解析为多个IP地址供客户端选择(例如，每个负载平衡器一个)。有趣的事实:大多数浏览器实际上都有内置的机制来尝试不同于DNS响应的IP地址，以防他们一直使用的那个没有响应。</p><h1 id="5e12" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">🗺先决条件2:负载平衡器配置</h1><p id="768d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">负载平衡器通过将请求路由到集群中的可用实例，在提高软件系统的可靠性方面起着至关重要的作用。它们通过运行状况检查来确定哪些实例可用，并维护一个运行状况良好且能够满足请求的实例的活动列表。</p><p id="26e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果负载平衡器没有从被认为健康的实例接收到预期的响应(或任何响应),它应该将该实例标记为不健康，并确保在健康检查成功之前没有进一步的请求被路由到该实例。负载平衡器检测失败实例的速度越快，失败的请求就越少，后续重试被路由到另一个健康实例的机会就越大。</p><p id="ad70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然负载平衡器经常可以检测到故障(L4和L7负载平衡器在这里的工作方式略有不同，如果您不熟悉，我强烈推荐Hussein Nasser 的<a class="ae ky" href="https://youtu.be/ylkAc9wmKhc" rel="noopener ugc nofollow" target="_blank">解释)，但它不会为我们对不同的实例重试相同的请求——这是客户端应用程序的职责。</a></p><h1 id="f261" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">⌛️先决条件3:超时</h1><p id="2aca" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">当向我们的客户机公开一个API时，我们指定最大服务响应时间，这是我们的客户机超时。这就是为什么在设计系统时让后端的总最大超时少于客户端超时是很重要的。</p><p id="f256" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住:我们使用客户端库通过重试失败的操作来提高系统的可用性。理想情况下，为了让客户端库能够在放弃并通知客户端应用程序失败之前“在幕后”重试一次，差值应该至少是2倍，这意味着后端超时必须小于“公布的”客户端超时的一半。换句话说，在承诺某些最大响应时间时，我们需要考虑至少一次重试的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/a730a24d3e8849172dccf4e7b142f79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hgZfjuUwJ8bWC142kkmPKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">实际超时至少比官方客户端超时少两倍</p></figure><p id="7b6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个简单的用例中，请求只是在组件之间传播，每个级别的超时可能大致相同。然而，当一个组件有多个远程依赖时，这就变得更加棘手了。扩展上面的例子，如果我们需要在与数据库交互之前调用第三方API，我们就不能在组件之间保持相同的超时值，因为总和不能超过客户端超时的一半，即15秒。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/569d3f1bfe83f3dca04f0675653e778d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jag9eMp4EeiTpZleEhHt2A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">链的每个部分的超时必须保持在15秒以下，因此如果引入另一个对第三方API的调用，我们不能保持相同的数据库超时</p></figure><p id="e5b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，用例中涉及的顺序操作越多，每个单独的超时应该越短。我在我的关于API失败的<a class="ae ky" href="https://medium.com/geekculture/bulletproof-distributed-systems-how-to-fail-at-http-calls-e7f0b3240d19" rel="noopener">文章</a>中从不同的角度提到了超时，并解释了为什么你应该在我的关于随机数的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/architecting-distributed-systems-random-code-8db0cd9b87d1">文章</a>中给超时增加一些抖动。</p><h1 id="cfe9" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">🔁先决条件4:等幂</h1><p id="6f0a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">最后但同样重要的是，如果我们第一次没有得到预期的结果，我们希望能够在客户端安全地重试相同的操作。请求可能已超时，但操作可能实际上已经成功，在这种情况下，重试必须返回初始操作的结果，而不是再次执行它。换句话说，如果我们不知道我们的第一次尝试是否成功，我们希望能够安全地重试操作。</p><p id="8e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果这个概念仍然令人困惑，查看我的关于幂等性的重要性的文章来回答任何剩余的问题。</p><h1 id="6a3e" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">📚客户端库实现</h1><p id="8241" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">当谈到客户端库的实现时，首先理解需求是很重要的。我通常会问两个问题:</p><ol class=""><li id="c090" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">我们的集成侧重于读还是写？</li><li id="ed07" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">在发送之前，我们能可靠地在客户端持久化记录吗？</li></ol><p id="7e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果客户端应用程序主要是向我们的系统写入数据，并且这些客户端可以访问非易失性存储器，我鼓励使用这些存储器来缓冲服务器还没有成功接收的数据。这是物联网用例中的一种常见模式，如果服务器暂时无法接收设备发送的数据，我们不希望丢失任何遥测数据。一旦服务器确认本地存储的记录被成功接收，就可以删除这些记录。</p><p id="590a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我问第三个问题:<em class="lw">客户端需要先下线吗</em>？由于这不是一个常见的要求，而且众所周知很难做到，我假设我们的客户大部分时间都可以访问互联网。</p><p id="d07a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为，大多数时候，客户端工作是<strong class="lb iu">而不是</strong>写繁重的，它们<strong class="lb iu">不</strong>需要离线优先的支持，并且是<strong class="lb iu">无状态的</strong>，我将在进一步的解释中重点关注这个场景。</p><p id="1d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据最新的行业标准，API要么作为<strong class="lb iu"> HTTP </strong>端点公开，要么使用<strong class="lb iu"> gRPC </strong>框架公开。在HTTP APIs的情况下，事实的来源是一个<strong class="lb iu"> OpenAPI </strong>规范文件，而如果您正在公开一个gRPC API，那将是<strong class="lb iu">。带有服务和消息定义的proto </strong>文件。OpenAPI和gRPC都带有代码生成器生态系统，这是我们客户端库的完美起点。事实上，我们可能想做的是使用OpenAPI和gRPC附带的久经考验的生成器，并用额外的重试逻辑编写我们自己的插件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/21f72b83f8cdb793283a1ae89a43c539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nb6dz8zmrBs7MBddYJDsKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">为了添加我们自己的重试逻辑，我们可以为现有的代码生成器开发一个插件。请记住，HTTP和gRPC工具通常是不可互换的，所以从这两种技术中的一种开始通常更实用，只有在绝对必要时才实现这两种技术。</p></figure><p id="6523" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，我们采用这样的东西，它将由默认编译器(伪代码)生成:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4f5a" class="nq ly it nm b gy nr ns l nt nu">function getWeather(city) {<br/>  return transport.callGetWeather(city); // throws Error<br/>}</span></pre><p id="22c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并将其包装在我们自己的错误处理逻辑中，例如:</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="5a2d" class="nq ly it nm b gy nr ns l nt nu">function getWeather(city) {<br/>  try {<br/>    return transport.callGetWeather(city);<br/>  } catch (error) {<br/>    if error.code in (500, 502, 503, 504)<br/>      // perhaps try a different load balancer<br/>      return transport.callGetWeather(city, retry = true);<br/>    else<br/>      throw error;<br/>  }<br/>}</span></pre><p id="72f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在幕后，客户端可以决定使用与之前执行的DNS解析不同的IP地址，以避免重试对同一物理位置的请求。</p><p id="7c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，我们需要在插件中为客户端使用的每种受支持的编程语言复制这种代码生成逻辑。幸运的是，如果操作得当，只需要为所有服务执行一次。Google倾向于用与结果库相同的语言编写这些插件，即Java生成器插件是用Java编写的，允许语言社区为项目做出贡献。<a class="ae ky" href="https://youtu.be/Gqkh-eaQT-s" rel="noopener ugc nofollow" target="_blank">来源</a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/3b79df8e8b8176140f71801e7fdfc2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxtXwPjqZJa6LGCnNCjzCQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">当您需要以可伸缩的方式为多种服务提供多种语言的客户端库时，请使用生成器</p></figure><p id="2317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果某些操作不能自动重试，例如，因为它们不是等幂的，它们可以在API规范文件中标记为等幂。然后，代码生成器插件可以考虑这些信息，并有条件地将代码包装在附加的重试逻辑中。因为我们可以控制规范文件和代码生成器，所以我们可以根据特定的用例获得期望的灵活性。</p><h1 id="17e2" class="lx ly it bd lz ma mb mc md me mf mg mh jz mi ka mj kc mk kd ml kf mm kg mn mo bi translated">🎁奖金</h1><p id="8682" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">除了屏蔽故障使应用程序感觉更可用之外，客户端库还有其他优点，我想在这里列出其中一些。如果你想让我在另一篇文章中详细阐述这些观点，请告诉我。</p><ol class=""><li id="dc58" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated"><strong class="lb iu">产品质量</strong>。您可以提供有史以来最快、最可靠的服务，但是如果客户犯了一个集成错误，并且没有获得他们所宣传的99.95%的可用性，从客户的角度来看，整体质量仍然会下降。用一个库代替普通的API文档减少了集成错误的机会，并使整个产品看起来更好。此外，代码执行的次数越多(想象一下成百上千的客户端在运行它)，就能越快地找到并修复错误。</li><li id="a27c" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">故障排除</strong>。如果客户接受数据共享，可以将错误日志从客户端库直接发送到您的系统，这样您就可以随时掌握客户端和服务器日志，全面了解发生的情况。</li><li id="98ee" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">安全&amp;移民</strong>。我将这两者归为一类，因为它们对客户来说意味着同样的事情:简单。安全性的实现并不简单，一个库可以隐藏这种复杂性的很大一部分。当涉及到迁移时，对依赖关系的简单更新通常就足够了，并且在发生重大变更的情况下，不同的方法签名通常比文档更容易理解。</li><li id="6dce" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated"><strong class="lb iu">升级</strong>。零停机升级或重启可能很难正确进行，开发人员往往倾向于在额外的复杂性上做出有利于小停机的权衡。通过在客户端屏蔽错误，您可能能够使升级感觉像零停机，而不需要实际的工程支持。</li></ol></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="8a1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读这些想法。你可能有兴趣看看我这个系列的其他部分，关于<a class="ae ky" href="https://medium.com/geekculture/bulletproof-distributed-systems-how-to-fail-at-http-calls-e7f0b3240d19" rel="noopener"> API失败</a>、<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/architecting-distributed-systems-the-importance-of-idempotence-138722a6b88e">幂等</a>和<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/architecting-distributed-systems-random-code-8db0cd9b87d1">随机数</a>。</p><pre class="kj kk kl km gt nl nm nn no aw np bi"><span id="4228" class="nq ly it nm b gy nr ns l nt nu"><strong class="nm iu">Want to Connect With the Author?</strong></span><span id="47e7" class="nq ly it nm b gy od ns l nt nu">Check out <a class="ae ky" href="https://konarskis.com/" rel="noopener ugc nofollow" target="_blank">konarskis.com</a>.</span></pre></div></div>    
</body>
</html>