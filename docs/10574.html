<html>
<head>
<title>6 Tips to Make Your React Components More Reusable</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高React组件可重用性的6个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-your-react-components-more-reusable-1a86d53494f8?source=collection_archive---------4-----------------------#2022-01-16">https://betterprogramming.pub/how-to-make-your-react-components-more-reusable-1a86d53494f8?source=collection_archive---------4-----------------------#2022-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee40" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从使用容器组件模式开始</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/40979ba0bb156e64bf0b4a9214e80854.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTkg0BDHl420SN4TPd1EKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8d9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这篇博文将讨论使React组件更具可重用性的策略。</p><p id="d283" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通过在构建React组件时牢记可重用性，您将更容易维护您的代码库并向您的应用程序添加新功能。</p><h1 id="e511" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">使用容器组件模式</h1><p id="8e69" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">提高React组件可重用性的一个方法是使用容器组件模式。容器组件通常有一个您希望在应用程序的不同位置重用的功能。</p><p id="2517" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">他们有一个<code class="fe mr ms mt mu b">children</code>道具，可以让你传递任意内容。容器组件不关心<code class="fe mr ms mt mu b">children</code>的内容，这使得它们非常灵活和通用。</p><p id="df73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">容器组件的一个例子是侧栏。它通常有一些共同的功能，如显示导航链接或搜索输入。然后，您可以向其中传递任何想要的内容，比如文章链接或产品列表。</p><p id="e11c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在几乎每个应用程序中使用的容器组件是gate组件，它在呈现其子组件之前检查用户的身份验证状态:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/50a198d1e3374c6b93890b5ef27140f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dX1nRsHQRMUNivN5uuSjAA.png"/></div></div></figure><p id="0cac" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你感兴趣，我写了一篇关于使用门控组件在React 中处理角色和权限的详细文章。</p><h1 id="ed4d" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">通用组件与专用组件</h1><p id="5ec6" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">使React组件更具可重用性的另一种方法是使用通用/专用模式。这种模式非常简单:您创建一个高度可重用的通用组件，然后在它的基础上构建更专门化的组件。</p><p id="d6d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们创建了一个可以呈现任何表单输入的通用表单组件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/be4c8651994fa54ded0a401caf9388f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xNr3BBR-P1La5NiOoxidsQ.png"/></div></div></figure><p id="94d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们可以构建一个更加专门化的<code class="fe mr ms mt mu b">NewsLetterForm</code>组件，它使用通用版本作为基础:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/29b71ebe2755017f764e2d3b71765711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnAZueFhd1BNiLq9BWFxdg.png"/></div></div></figure><p id="a638" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们创建了一个专门的<code class="fe mr ms mt mu b">NewsLetterForm</code>组件，您可以使用它，而不必为它提供大量的配置。</p><p id="3742" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">同时，我们现在有了一个通用的<code class="fe mr ms mt mu b">Form</code>组件，您可以使用它来创建其他专门的表单。</p><h1 id="59af" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">注意你的组件要决定什么</h1><p id="40f9" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当您创建一个React组件时，请批判性地思考您的组件正在做出哪些决策。</p><p id="77c8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在代码库中经常看到的一个问题是给组件太多的上下文，让它们决定是否应该呈现自己。</p><p id="b9df" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，让我们看看<code class="fe mr ms mt mu b">UserList</code>和<code class="fe mr ms mt mu b">ListItem</code>组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/d4c8970a18a9ce2f5769f42d70c12ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6BTdF2nN2f2ShA4_THotA.png"/></div></div></figure><p id="c46b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，由<code class="fe mr ms mt mu b">ListItem</code>来决定是否渲染自己。这样做会降低它的可重用性。如果我们想在不同的列表中使用这个<code class="fe mr ms mt mu b">ListItem</code>来显示用户，而不管他们的帐户是否已经过期，该怎么办？我们需要操作用户属性的内容来获得我们想要的结果。不理想。</p><p id="edd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有一个更好的方法:我们可以让列表组件决定是否呈现它的项目:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/24bc468095e94fc69ff5b9ae25ad3019.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ey2bBAUyUXASlIT4kNDAhA.png"/></div></div></figure><p id="e7b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，列表组件控制是否呈现其项目。这使得我们的<code class="fe mr ms mt mu b">ListItem</code>组件更加可重用，因为现在它纯粹是表示性的，不包含条件渲染逻辑。</p><h1 id="1880" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">展平你的道具</h1><p id="032b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">如果你打算在应用程序的其他地方重用你的组件，你应该尽可能地展平你的道具。</p><p id="c0c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样，组件需要什么数据来操作就更清楚了。</p><p id="ab2a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当我们使用嵌套object prop时，我们不确定对对象的更改是否会在组件树中引起意想不到的副作用。</p><p id="c8eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，当组件期望一个对象属性具有某种结构时，就很难将这个组件与其他数据结构互换使用。</p><p id="c15c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个显示用户配置文件的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/215f41aca31863373ae2af2223d2bde7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3s9BI6w4-pepYnEkEETsjw.png"/></div></div></figure><p id="ce33" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，<code class="fe mr ms mt mu b">media</code>字段被隐藏在用户对象的几层深处。如果我们改变了我们的<code class="fe mr ms mt mu b">User</code>数据结构，我们可能会不知不觉地破坏这个<code class="fe mr ms mt mu b">Profile</code>组件。</p><p id="f3c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，现在我们只能使用这个组件来显示用户配置文件页面。如果我们想重用这个组件来显示公司的数据，而公司对象的结构与用户对象不同，该怎么办？</p><p id="269c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们的profile组件避免依赖嵌套的object props，那么重用它来显示公司简介页面将会简单得多:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/72142b48ee4d50cd261c4f0d41190ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90f786KlWWJ7zORgYEv77Q.png"/></div></div></figure><p id="9d90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们简化了我们的<code class="fe mr ms mt mu b">Profile</code>组件，简化了它的道具要求，并使它需要哪个道具来显示图像变得更加明显。</p><h1 id="3015" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">为组件提供后备支持</h1><p id="9117" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">让React组件更加可重用的一个简单方法是提供后备支持。如果未能提供这些属性会导致异常，那么这样做尤其重要。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/364c2c1939459387af180620ccd54edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*83L0KtSPKuOfkLsmmY8paA.png"/></div></div></figure><p id="b984" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，如果客户端忘记提供<code class="fe mr ms mt mu b">items</code>属性，应用程序将崩溃，因为组件将试图访问<code class="fe mr ms mt mu b">items</code>属性的<code class="fe mr ms mt mu b">map</code>方法，即<code class="fe mr ms mt mu b">undefined</code>。</p><p id="422b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了避免这种情况，我们可以提供一个空数组作为后备。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/30226ac1030ab8226def58f6bfca3b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0o-vJ4YK6KsiYY-zlTaLA.png"/></div></div></figure><p id="b6b0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样做至少可以防止我们的应用程序崩溃。</p><h1 id="9d5a" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">避免使用spread运算符传递道具</h1><p id="372b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当您想要将属性从父组件向下传递到其子组件时，使用spread操作符可能很有吸引力，如下所示:</p><pre class="kj kk kl km gt nb mu nc nd aw ne bi"><span id="131a" class="nf lv it mu b gy ng nh l ni nj">&lt;ChildComponent {...props} /&gt;</span></pre><p id="4a86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是通常不建议这样做，这样会使bug更难跟踪！</p><p id="7fb6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">过一会儿，就很难确定你使用spread操作符传递的哪些属性实际上被组件的子组件使用，哪些属性可以安全地删除或修改。</p><h1 id="ba8c" class="lu lv it bd lw lx ly lz ma mb mc md me jz mf ka mg kc mh kd mi kf mj kg mk ml bi translated">结论</h1><p id="c99b" class="pw-post-body-paragraph ky kz it la b lb mm ju ld le mn jx lg lh mo lj lk ll mp ln lo lp mq lr ls lt im bi translated">当使用React构建软件应用程序时，在组件级别而不仅仅是应用程序级别考虑可重用性是很重要的。</p><p id="cf98" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这篇文章中，我们回顾了一些可以用来提高React组件可重用性的实践。我希望这篇文章对你有用！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="67f2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="nr">最初发表于</em>【https://isamatov.com】<em class="nr"/></p></div></div>    
</body>
</html>