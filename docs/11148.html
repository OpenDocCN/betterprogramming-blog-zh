<html>
<head>
<title>Why Do We Need RabbitMQ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们为什么需要RabbitMQ？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/why-do-we-need-rabbitmq-f9f1d99c074c?source=collection_archive---------3-----------------------#2022-02-22">https://betterprogramming.pub/why-do-we-need-rabbitmq-f9f1d99c074c?source=collection_archive---------3-----------------------#2022-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a704" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解RabbitMQ的主要特性以及如何使用它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/89d748f62771f15c056a426548df0e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PaXObf5R8brUXFOE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@smpicturez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Satyabrata sm </a>拍摄的照片</p></figure><p id="9a68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在人类历史上，有许多不同的信息传递者，可能是烟雾信号，信鸽，甚至是信使。人们需要交流。软件系统也需要通信。然而，尽管技术进步，通信总是运行相同的hab。有发送者、接收者和消息。</p><p id="9f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，可以对通信提出各种要求，例如，保证消息的传递，或者有时对人群的简单广播就足够了。由于这些不同的需求，已经开发了不同的系统。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6cff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是消息队列？</h1><blockquote class="mu"><p id="2489" class="mv mw it bd mx my mz na nb nc nd lu dk translated">“消息代理是所有消息发送的中介。因此，我们实现了发射机和接收机之间的额外去耦。发送者向消息代理发送消息，消息代理将消息传递给接收者。这里的一个关键优势是消息代理不需要知道消费者在网络中的位置<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/why-do-we-need-message-broker-7382ce0e46c6">【1】</a>。”</p></blockquote></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="6348" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下文中，我们将从查看请求-响应消息交换模式开始，然后，我们将更深入地研究RabbitMQ。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fcbd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">请求-响应消息交换模式</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/09468165ac2f8acc829080057fdc8f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DrPddXK38_aEXxqQ1QQoiA.png"/></div></div></figure><p id="3243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了请求-响应的交流方式，还有很多，但它是最常见的一种。在这种模式中，一个系统充当客户机，远程系统充当服务器。如上图所示，客户端向服务器请求数据。</p><p id="65b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当客户需要直接回应或任务需要立即完成时，这种类型的沟通非常有用。您必须记住，由于实现的原因，这种类型的通信是同步的。</p><p id="7781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于开发人员来说，这种模式很容易实现，但是它也确保了系统的严格耦合。通常，系统之间的刚性耦合是不可取的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5e7b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">消息队列交换模式</h1><p id="ffe3" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在消息队列交换模式中，两个系统异步操作。整个事情通过所谓的信息进行。一个系统在消息队列中发布消息，接收者从队列中接收该消息。通过这种交流，消息的发布者不会等待直接的回答。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/143f52d1cf2386e20e2ce30e173474f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U_ucCHj03KHypmH5dT0aMA.png"/></div></div></figure><p id="4205" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与请求-响应模式不同，在这个系统中，两个系统都充当发布者和消费者。</p><p id="137d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个图中可以看出，我们由此实现了一个松散耦合的架构。这是使用消息队列的最大好处之一。因此，系统不再需要知道彼此的位置。系统的这种分离允许它们被独立开发，因为消息传输被移交给标记器。要了解更多信息，请看我关于消息代理的另一篇文章。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bd3e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RabbitMQ的主要特点</h1><p id="e516" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">使用Rabbit MQ可以获得许多不同的好处；在下文中，我们将深入探讨最重要的几个问题:</p><p id="ba73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">开源:</strong></p><ul class=""><li id="d96c" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">RabbitMQ是一个用Erlang编写的开源项目。Pivotal软件公司拥有它。该公司现在是VMware的一部分。</li></ul><p id="20d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">支持不同的协议</strong></p><ul class=""><li id="7f40" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">有了RabbitMQ，您的系统可以使用不同消息协议的组合，如AMQP、MQTT等。</li></ul><p id="7924" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">轻量级</strong></p><ul class=""><li id="4c0b" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">在使用中，RabbitMQ需要最少的ram。</li></ul><p id="5196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">大多数现代语言的客户端库</strong></p><ul class=""><li id="b1a2" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">RabbitMQ不限制他们使用特定的供应商或语言。针对Java、Ruby、Python、C#等最常见语言的不同库。</li></ul><p id="7e1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">人性化</strong></p><ul class=""><li id="495c" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">有很多使用RabbitMQ的文档和最佳实践，这使得它非常用户友好。</li></ul><p id="1724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">多家公司使用</strong></p><ul class=""><li id="9b53" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">许多公司发誓将RabbitMQ作为其微服务架构的一部分。</li></ul><p id="5676" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">可扩展且灵活</strong></p><ul class=""><li id="e80a" class="nl nm it lb b lc ld lf lg li nn lm no lq np lu nq nr ns nt bi translated">既然开发者只需要维护消费者和发布者。RabbitMQ承担通讯部分。此外，还有很多第三方插件可以根据你的需求调整RabbitMQ。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="80a9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">兔子和AMQP</h1><p id="7e0d" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">RabbitMQ是最早实现AMQP的消息代理之一。该协议是一个开放的标准协议，定义了系统如何交换消息。它代表了系统之间相互通信的一组规则。除了描述消费者/生产者和代理之间的交互之外，它还定义了消息和命令。</p><p id="975e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该协议被分配给应用层，主要用于IP网络中的进程间通信。AMQP被认为是一种二进制协议，因为所有数据都是以二进制格式发送的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/31d165fcb7c1539b1d1116ee8f735185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*EWF-o8qZ43xQZkob1W05tA.png"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8c74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">AMQP元素</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/12dfc57440b64b43c7f667c922776ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azKfnxbEJrLnh6Up1yQjNw.png"/></div></div></figure><p id="d4bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">经纪人</strong></p><p id="9c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代理是接收和传递消息的软件。</p><p id="8d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">队列</strong></p><p id="bee2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">队列存在于代理中，包含一系列消息。</p><p id="f784" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">装订</strong></p><blockquote class="nw nx ny"><p id="959e" class="kz la nz lb b lc ld ju le lf lg jx lh oa lj lk ll ob ln lo lp oc lr ls lt lu im bi translated">“队列和交易所之间的联系”<a class="ae ky" href="https://jstobigdata.com/rabbitmq/elements-of-amqp/" rel="noopener ugc nofollow" target="_blank">【2】</a></p></blockquote><p id="a428" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">连接</strong></p><p id="033d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">客户端应用程序和RabbitMQ之间使用TCP连接。如果客户端断开连接或发生系统故障，连接将被关闭。</p><p id="c6d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">虚拟主机</strong></p><p id="8e42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虚拟主机允许我们在代理中分离不同的工作环境。例如，划分开发和试运行环境。</p><p id="13da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">交换</strong></p><p id="31f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以将交换想象成一个路由器，它根据绑定将消息从生产者路由到正确的队列。</p><p id="769d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">频道</strong></p><p id="c72c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通道是连接内部的虚拟连接。消息的发布和消费是通过通道完成的。它重用已经打开的连接，而不需要打开新的TCP流。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4dbb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">RabbitMQ经纪人</h1><p id="67b5" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">如上所述，RabbitMQ是一个在Erlang中实现的AMQP代理。Erlang被认为是非常可靠的语言，非常适合分布式应用程序。此外，Erlang可以在任何操作系统上运行。</p><p id="e5c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RabbitMQ基于Mnesia，一个用Erlang编写的数据库系统。这用于数据持久性。例如，Mnesia存储用户信息、队列等等。</p><p id="fce7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RabbitMQ的优点是它可以作为单个实例运行，也可以在集群中运行。对于集群使用，主要使用Erlang中的集群功能。</p><p id="a1eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个RabbitMQ代理可以使用不同的技术连接起来。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ffee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">C# —示例实现</h1><p id="d783" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在本例中，我假设您已经有了一个正在运行的RabbitMQ实例。如果不是这样，那么在这个框架中研究一下Docker环境将是一个好主意。您可以使用这些快速设置一个RabbitMQ实例。</p><p id="6d35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如需了解更多信息，您可以点击查看<a class="ae ky" href="https://codeburst.io/get-started-with-rabbitmq-on-docker-4428d7f6e46b" rel="noopener" target="_blank">。</a></p><p id="7c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您的实例正在运行，那么在使用guest登录后，您应该能够指向<a class="ae ky" href="http://localhost:15672" rel="noopener ugc nofollow" target="_blank"> http://localhost:15672 </a>并看到下面的仪表板。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/07d988c20c46ba99200b0cad0442d757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHRpA1n_slAl-gLoMzg5Hg.png"/></div></div></figure><p id="0c69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本例中，我们将创建一个简单的控制台应用程序来使用消息。</p><p id="478d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先创建控制台应用程序，并根据自己的意愿命名。</p><p id="b1c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1.添加Nuget包:<code class="fe oe of og oh b">RabbitMQ.Client</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/140f303d6b77fc0230159672b408d6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D0XDgl7JuKWgk6KsPhrZbA.png"/></div></div></figure><p id="116f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.创建一个名为<code class="fe oe of og oh b">MessageReceiver.cs</code>的类，它实现了<code class="fe oe of og oh b">DefaultBasicConsumer</code>。</p><p id="e4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.通过依赖注入，我们传递了<code class="fe oe of og oh b">IModel</code>接口。</p><p id="d63e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.然后我们覆盖<code class="fe oe of og oh b">HandleBasicDeliver</code>方法，使用<code class="fe oe of og oh b">Console.WriteLine</code>来显示传入的消息。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="7f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.下一步是将我们的客户端连接到消息队列。因此我们必须打开<code class="fe oe of og oh b">program.cs</code>并编辑它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="0861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nz">(详见</em><a class="ae ky" href="https://www.tutlane.com/tutorial/rabbitmq/csharp-read-messages-from-rabbitmq-queue" rel="noopener ugc nofollow" target="_blank"><em class="nz">https://www . tutlane . com/tutorial/rabbit MQ/cs harp-read-messages-from-rabbit MQ-queue</em></a><em class="nz">)</em></p><p id="0e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们开始使用消息之前，我们需要事先通过RabbitMQ仪表板创建一个队列。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/4afeedd7400bf8828f1c1e684b57aee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqXOqYkOf0xGvlrHwFE5yQ.png"/></div></div></figure><p id="089d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">6.因此，通过仪表板添加一个名为demoqueue的队列。</p><p id="b459" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">7.启动控制台应用程序，并通过仪表板发布消息。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/9804c1937122ba332309948fd7779ff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4rlQboyxqDFWaCKJAZolQ.png"/></div></div></figure><p id="012d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该能够在正在运行的控制台应用程序中看到该消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3ccd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">TL；DR；</h1><ul class=""><li id="c2dd" class="nl nm it lb b lc nf lf ng li on lm oo lq op lu nq nr ns nt bi translated">RabbitMQ是一个用Erlang编写的AMQP消息代理。</li><li id="673d" class="nl nm it lb b lc oq lf or li os lm ot lq ou lu nq nr ns nt bi translated">它是开源的，易于在许多不同的语言中使用。</li><li id="c4cc" class="nl nm it lb b lc oq lf or li os lm ot lq ou lu nq nr ns nt bi translated">消息队列是传统的请求-响应模式的替代方案。</li><li id="9cf6" class="nl nm it lb b lc oq lf or li os lm ot lq ou lu nq nr ns nt bi translated">一个系统(客户机)以请求-响应模式从另一个系统(服务器)请求数据。服务器返回一个响应。</li><li id="74a8" class="nl nm it lb b lc oq lf or li os lm ot lq ou lu nq nr ns nt bi translated">在消息队列交换模式中，通信是通过消息队列异步进行的。</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ov oh ow ox aw oy bi"><span id="af2b" class="oz md it oh b gy pa pb l pc pd"><strong class="oh iu">Want to Connect?</strong></span><span id="f345" class="oz md it oh b gy pe pb l pc pd">You can contact me via my social media channels (<a class="ae ky" href="https://twitter.com/muench_justin" rel="noopener ugc nofollow" target="_blank">Twitter</a>,L<a class="ae ky" href="https://www.linkedin.com/in/justin-m%C3%BCnch-0b1087133/" rel="noopener ugc nofollow" target="_blank">inkedIn</a>).</span><span id="0a38" class="oz md it oh b gy pe pb l pc pd">All drawings were created with Draw.IO.</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4dce" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">来源</h1><div class="pf pg gp gr ph pi"><a href="https://www.amazon.com/-/de/dp/B089ZWKT3W/ref=sr_1_1?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;crid=1ETX26HO1GIHM&amp;keywords=RabbitMQ+Essentials&amp;qid=1644824620&amp;sprefix=rabbitmq+essentials%2Caps%2C117&amp;sr=8-1" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">RabbitMQ Essentials:使用消息队列构建分布式和可伸缩的应用程序</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">RabbitMQ基础知识:使用RabbitMQ构建带有消息队列的分布式和可伸缩的应用程序，第2版…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.amazon.com</p></div></div><div class="pr l"><div class="ps l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://www.amazon.com/-/de/dp/1617291005/ref=sr_1_2?__mk_de_DE=%C3%85M%C3%85%C5%BD%C3%95%C3%91&amp;keywords=gavin+roy&amp;qid=1645166699&amp;sr=8-2" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">RabbitMQ深度</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">亚马逊网站:RabbitMQ in Depth: 9781617291005:罗伊、加文m:书籍</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.amazon.com</p></div></div><div class="pr l"><div class="px l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://www.cloudamqp.com/blog/why-use-rabbitmq-in-a-microservice-architecture.html" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">微服务——为什么要用RabbitMQ？- CloudAMQP</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">当今的单片系统正被微服务架构快速取代。要理解这是为什么…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.cloudamqp.com</p></div></div><div class="pr l"><div class="py l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://www.cloudamqp.com/blog/what-is-amqp-and-why-is-it-used-in-rabbitmq.html" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">什么是AMQP，为什么在RabbitMQ中使用它？- CloudAMQP</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">AMQP包括一套标准，控制AMQP消息代理(如RabbitMQ)中的整个消息传递过程。它…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.cloudamqp.com</p></div></div><div class="pr l"><div class="pz l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://www.rabbitmq.com/features.html" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">RabbitMQ能为你做什么？</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">消息传递使软件应用程序能够连接和扩展。应用程序可以相互连接，作为…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.rabbitmq.com</p></div></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://jstobigdata.com/rabbitmq/elements-of-amqp/" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">AMQP元素-高级消息队列协议</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">在本教程中，我们将学习AMQP的不同元素来使用RabbitMQ。我已经谈过了…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">jstobigdata.com</p></div></div><div class="pr l"><div class="qa l pt pu pv pr pw ks pi"/></div></div></a></div><div class="pf pg gp gr ph pi"><a href="https://www.tutlane.com/tutorial/rabbitmq/csharp-read-messages-from-rabbitmq-queue" rel="noopener  ugc nofollow" target="_blank"><div class="pj ab fo"><div class="pk ab pl cl cj pm"><h2 class="bd iu gy z fp pn fr fs po fu fw is bi translated">C#从RabbitMQ队列中读取(消费)消息- Tutlane</h2><div class="pp l"><h3 class="bd b gy z fp pn fr fs po fu fw dk translated">在c#中，我们可以通过使用rabbitmq来读取或消费来自RabbitMQ的消息。客户端nuget包。在这里，我们将学习如何…</h3></div><div class="pq l"><p class="bd b dl z fp pn fr fs po fu fw dk translated">www.tutlane.com</p></div></div><div class="pr l"><div class="qb l pt pu pv pr pw ks pi"/></div></div></a></div></div></div>    
</body>
</html>