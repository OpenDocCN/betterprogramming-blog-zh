<html>
<head>
<title>Create Generic Protocols With Associated Types in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中创建具有相关类型的通用协议</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/associated-types-in-swift-d79a7e243d71?source=collection_archive---------1-----------------------#2019-09-29">https://betterprogramming.pub/associated-types-in-swift-d79a7e243d71?source=collection_archive---------1-----------------------#2019-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2f5f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使协议通用化以及这样做的好处</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3799519e15704e1183924c61ba63bbbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYQ7K4IbzUaMOoEqhYYDWg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">达莉亚·内布里亚希娜</p></figure><p id="90db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在讨论Swift 中的<a class="ae ky" href="https://medium.com/@navdeepsingh_2336/generics-in-swift-13e792249cad" rel="noopener">泛型时，我们学习了如何使结构、枚举和类成为泛型。</a></p><p id="d04c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们发现了如何在编译时传递抽象的类型信息，让编译器将这些信息从编译时传递到运行时。我们使用协议来声明这些类型的能力。</p><p id="9c50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是协议呢？我们如何使协议通用，这样做的好处是什么？</p><p id="0e69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论通用协议或相关类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ac84" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">定义通用协议</h1><p id="7d06" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">协议可能给你的印象是某种已经通用的东西，因为任何类型都可以符合协议，但是协议的内部是什么呢？</p><p id="7786" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们能想出一个内部通用的协议吗？</p><p id="4776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个问题的简短回答是，这是可能的，但是实现与我们讨论的其他泛型类型有点不同。第一步是使用协议定义一个接口，如下面的代码所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="09ad" class="ne md it na b gy nf ng l nh ni">protocol Stack {</span><span id="bedd" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="a745" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，<code class="fe nk nl nm na b">Stack</code>只是一个功能有限的数组。一般来说，<code class="fe nk nl nm na b">Stack</code>可以对它持有的元素执行以下功能:</p><ul class=""><li id="190d" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe nk nl nm na b">Push</code>一个元素到了<code class="fe nk nl nm na b">Stack</code>的顶端。</li><li id="1da4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe nk nl nm na b">Pop</code>除去顶端的元素。</li><li id="2d5a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe nk nl nm na b">Peek</code>在顶部元件上，不从<code class="fe nk nl nm na b">Stack</code>上移除。</li></ul><p id="dca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">Stack</code>通常在我们希望保持后进先出(LIFO)顺序时使用，即当从<code class="fe nk nl nm na b">Stack</code>弹出时，我们将最后一个元素推送到<code class="fe nk nl nm na b">Stack</code>。</p><p id="b3cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经了解了这些函数，让我们用代码来定义接口:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="f3c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Swift更倾向于值类型，假设我们使用数组创建具体的<code class="fe nk nl nm na b">Stack</code>类型作为结构，我们需要在协议中标记方法变异，正如你在上面的代码中看到的。</p><p id="2be9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能已经注意到在我们的<code class="fe nk nl nm na b">protocol</code>中使用了一个特殊的参数<code class="fe nk nl nm na b">Element</code>。这是因为我们希望该协议的任何具体类型实现都能够符合该协议并工作，尽管它包含<code class="fe nk nl nm na b">String</code>、<code class="fe nk nl nm na b">Int</code>、<code class="fe nk nl nm na b">Float</code>等。</p><p id="2364" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终目标是确保<code class="fe nk nl nm na b">Stack</code>的每个具体实现只有一种类型。</p><p id="d475" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的协议中声明<code class="fe nk nl nm na b">Element</code>类型时，您可能也注意到了关键字<code class="fe nk nl nm na b">associatedtype</code>。</p><p id="03e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关联类型的工作方式类似于类型参数，并提供一个占位符名称，作为协议的一部分。</p><p id="a3ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们遵照协议创建具体的实现之前，不需要实际的类型。</p><h2 id="2616" class="ne md it bd me od oe dn mi of og dp mm li oh oi mo lm oj ok mq lq ol om ms on bi translated">关联类型</h2><p id="c545" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过使用一种叫做<em class="oo">关联类型</em>的特殊类型，协议可以变得通用。</p><p id="37ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关联的类型可以在带有关键字<code class="fe nk nl nm na b">associatedtype</code> <strong class="lb iu"> <em class="oo"> </em> </strong>约束的协议中声明，然后在泛型类型中使用<code class="fe nk nl nm na b">typealias</code>来替换这个<code class="fe nk nl nm na b">associatedtype</code>、<strong class="lb iu"> <em class="oo"> </em> </strong>或者我们可以让编译器推断类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="13e1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">实现通用协议</h1><p id="4658" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在上一节中，我们讨论了如何使用<code class="fe nk nl nm na b">associatedtype</code>定义通用协议。在本节中，我们将遵循协议并创建一个具体的类型。</p><p id="f115" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以做到这一点。第一种方法是明确说明<code class="fe nk nl nm na b">Element</code>类型。让我们从创建一个具体类型<code class="fe nk nl nm na b">StringStack</code>开始，如下所示:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="6037" class="ne md it na b gy nf ng l nh ni">struct StringStack: Stack {</span><span id="cbc4" class="ne md it na b gy nj ng l nh ni">    typealias <strong class="na iu">Element</strong> = <strong class="na iu">String</strong></span><span id="b845" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="c091" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们通过使用<code class="fe nk nl nm na b">typealias</code>关键字将<code class="fe nk nl nm na b">Element</code>显式定义为具体类型(在本例中为<code class="fe nk nl nm na b">String</code>)来满足<code class="fe nk nl nm na b">associatedtype</code>需求。</p><p id="b350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这告诉编译器在通用协议中定义的所有方法现在将使用<code class="fe nk nl nm na b">String</code>而不是通用<code class="fe nk nl nm na b">Element</code>类型。</p><p id="be3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nk nl nm na b">StringStack</code>的进一步实施现在可以如下:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="55ec" class="ne md it na b gy nf ng l nh ni"><strong class="na iu">struct</strong> StringStack: <strong class="na iu">Stack</strong> {</span><span id="a290" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">    typealias</strong> Element = <strong class="na iu">String</strong></span><span id="de56" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">    private</strong> <strong class="na iu">var</strong> stringArray: <strong class="na iu">Array</strong>&lt;<strong class="na iu">String</strong>&gt;</span><span id="afcf" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">    mutating</strong> <strong class="na iu">func</strong> push(<strong class="na iu">_</strong> element: <strong class="na iu">String</strong>) {</span><span id="c35d" class="ne md it na b gy nj ng l nh ni">        stringArray.append(element)</span><span id="6a97" class="ne md it na b gy nj ng l nh ni">    }</span><span id="5587" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">    mutating</strong> <strong class="na iu">func</strong> pop() -&gt; <strong class="na iu">String</strong>? {</span><span id="2187" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">        return</strong> stringArray.popLast()</span><span id="c283" class="ne md it na b gy nj ng l nh ni">    }</span><span id="b28e" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">    var</strong> peek: <strong class="na iu">String</strong>? {</span><span id="8a5d" class="ne md it na b gy nj ng l nh ni"><strong class="na iu">        return</strong> stringArray.last</span><span id="e2bb" class="ne md it na b gy nj ng l nh ni">    }</span><span id="7226" class="ne md it na b gy nj ng l nh ni">}</span></pre><p id="6b95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法是让编译器推断出<code class="fe nk nl nm na b">associatedtype</code>需求的类型。</p><p id="72d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们已经在上面的代码中为两个函数和computed属性明确指定了类型参数，这应该足以让编译器推断出类型，因此，我们不再需要<code class="fe nk nl nm na b">typealias</code>关键字。</p><p id="f6a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，即使我们删除了<code class="fe nk nl nm na b">typealias</code>声明，一切都应该像预期的那样工作，代码将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="df4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是我们如何给出协议的一般要求。它非常简单，但可以在许多用例中使用。</p><p id="4c72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于我们现在知道了通用协议以及如何使用它，我们现在可以将我们的知识扩展到更复杂的概念，比如通用协议的类型约束。我们将在接下来的文章中讨论所有这些以及更多内容。</p><p id="40f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>