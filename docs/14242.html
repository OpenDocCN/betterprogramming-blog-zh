<html>
<head>
<title>How I Created a Script Engine With Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用Go创建脚本引擎</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bash-argument-parsing-e4bf28b39956?source=collection_archive---------8-----------------------#2022-11-21">https://betterprogramming.pub/bash-argument-parsing-e4bf28b39956?source=collection_archive---------8-----------------------#2022-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0350" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">认识Bashy——我的打包Bash脚本的开源工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f9cf044bf528e4b0bee6d6212c07b0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sLhJRFrlStePNrh_"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@kasparseglitis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡斯帕尔斯·埃格里蒂斯</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="d99e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个项目都是从一个需求或者一个想法开始的。就我而言，解析bash脚本中的参数和共享脚本本身的复杂性让我感动。大多数编写bash脚本的开发人员将它们保存在本地PC上，需要时，在运行之前复制/粘贴文件并更改内容。为什么？</p><p id="fb43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一个每种语言都有自己的包管理器，每个工具都有描述参数的<code class="fe lv lw lx ly b">help</code>命令的世界里，这种行为似乎已经非常过时了。无论如何，如果你看到机会，你会同意我的观点，没有太多的选择。Bash脚本没有任何包管理器，也没有任何用于参数解析的标准库(您可以找到许多脚本，但是没有包管理器，很难使用它们)。</p><p id="6d72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我写了这篇简短的介绍来解释为什么我创建了Bashy，这个开源工具克服了这个问题。本文将关注我创建的应用程序中最重要的部分。我认为有许多有趣的想法可以在您的Go应用程序中重用。</p><h1 id="b548" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Bashy有什么好处？</h1><p id="bf65" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">您可以编写一个包含脚本元数据和脚本本身(可以嵌入或保存在外部)的YAML文件，如以下代码片段所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/4ee2977ad665546d037af7f7270d2028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LThUUV6Q_cfkeqRy"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">拙劣的剧本</p></figure><p id="5827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在YAML清单中，您需要解释命令名、描述和参数。如您所见，这些参数可以作为常规变量直接在脚本中使用。</p><p id="9a8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，您可以如下运行脚本:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/9c683249b8aa9c275aaa31a5d29a3ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cjRnoaNvlvxbGrxD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行bashy脚本</p></figure><p id="79a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，解析参数的复杂性被移除了，您现在拥有了可以与其他人共享的自包含文件(包)。不错，不是吗？在下一章中，我们将在深入研究技术细节之前看到<a class="ae ky" href="https://github.com/zeppaman/bashy" rel="noopener ugc nofollow" target="_blank"> Bashy </a>的架构。</p><h1 id="bc0d" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Bashy一般是如何工作的</h1><p id="a6ec" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">下一张图展示了Bashy的工作原理:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/c245067a70439bc21f0ff645031f8256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aIQG6HTPDn49_MV77EfL7g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">巴什的建筑。作者用❤️做的</p></figure><p id="351f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上图中，我们可以看到三个主要流程:</p><ul class=""><li id="414b" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">Add repo(红色流):用户将脚本库添加到本地数据库(您可以从互联网下载脚本或从您的PC添加文件)。在这一步之后，您的数据库包含脚本的所有数据，并且可以运行它们。</li><li id="a66a" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">帮助(蓝色流):用户可以与Bashy脚本交互，列出从存储库中注册的所有命令。</li><li id="4a8b" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">执行(绿色流程):现在内部数据库包含了关于要运行的脚本的所有信息，Bashy可以解析参数并将其传递给脚本。这个步骤对用户来说是完全透明的。</li></ul><p id="166a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们了解了Bashy的主要流程。我们可以进入这个案例研究中更相关、更有趣的部分。在我看来，这些部分是:</p><ol class=""><li id="7cd6" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu nn nf ng nh bi translated">解析参数引擎</li><li id="5cfd" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">解释器引擎</li><li id="8f66" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">全局注册命令</li></ol><p id="3206" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">直接跳到下一节！</p><h1 id="6dd6" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">解析参数引擎</h1><p id="3450" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">解析参数是Bash脚本管理中最关键的一点，也是这个应用程序的核心，因此它值得最大的关注。反正原理很简单。我使用了<a class="ae ky" href="https://github.com/urfave/cli" rel="noopener ugc nofollow" target="_blank"> urfave/cli </a>，这是一个控制台解析库，它允许我通过解释命令结构来解析参数。每个命令都有一个相关的函数，它接受解析后的输入并执行一些操作。该库的示例用法在以下代码片段中:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/9c14994c09b47c6c598fbd71dc7f2c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ACjTmAglcAr3Ba1rvKkvoA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">urfave/cli的一个例子</p></figure><p id="ccfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，有一个名为<code class="fe lv lw lx ly b">lang</code>的标志，默认值为<code class="fe lv lw lx ly b">english</code>，可以通过键入<code class="fe lv lw lx ly b">cCtx.String("lang").</code>在函数内部使用。Bashy做了同样的事情，但是从内部数据库读取命令和参数列表。实现如下面的代码片段所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ec1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">处理所有请求的操作由以下代码段实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="46eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，所有的脚本行都连接在一起。Bashy将嵌入到YAML文件中的命令附加到一个最终的外部脚本中，然后用params创建一个键/值映射，并调用<code class="fe lv lw lx ly b">ExecuteCommand</code>实用程序方法，该方法在脚本上添加变量定义并运行脚本本身。</p><h1 id="e855" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">解释器引擎</h1><p id="e23b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在运行Bashy之后，我意识到它可以运行任何脚本，而不仅仅是bash脚本。因此，下一步是添加定义任何其他脚本解释器的机会，以允许任何用户使用bashy管理他们的脚本，而不管他使用的是什么编程语言。解释器的定义是一个简单的YAML文件。在下一个代码片段中，您可以看到Nodejs引擎的定义:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/bbaa584a49c6ed01c4c2d164a4c0d2b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSZABIPEG_ySxYrDpSGIRQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">解释器定义</p></figure><p id="f568" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">YAML文件包含两个由<code class="fe lv lw lx ly b">---</code>符号分开的解释器。你可以看到它们非常相似:两者都是Nodejs解释器的定义，但是一个用于windows，一个用于Linux。这是因为根据操作系统或可用性，您可以有不同的安装步骤(例如，您不能在windows中使用纯bash或在Linux中使用windows控制台)。</p><p id="d9cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">口译员的剖析很容易。您有以下内容:</p><ul class=""><li id="5d72" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">name</code>:翻译人员的姓名。在你的YAML脚本中，你可以解释什么解释器使用它</li><li id="d252" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">variabletemplate</code>:变量是如何定义的。例如，在bash中，您有<code class="fe lv lw lx ly b">VARIABLE=VALUE</code>，但是在JavaScript中<code class="fe lv lw lx ly b">var variable=VALUE;</code> <code class="fe lv lw lx ly b">$name</code>和<code class="fe lv lw lx ly b">$variable</code>是占位符，代表从脚本定义中获取的参数名和执行时的实际值。</li><li id="2d77" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><code class="fe lv lw lx ly b">installscript</code>:这些是用于安装解释器的脚本行。比如对于Ubuntu，我们有<code class="fe lv lw lx ly b">apt install nodejs -y</code>。为了支持所有的Linux发行版，我使用了添加多行代码的技巧，每一行代码对应一个包管理器，它是由包管理器本身激活的。这转化为复制这种模式<code class="fe lv lw lx ly b">[[$command -v packagemanagername ]] || {packcagemanager args}</code>。</li></ul><p id="ed07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经看到了如何创建和注册一个解释器。剩下的只是向您展示我是如何定义命令别名的，以使全局注册您的命令成为可能。</p><h1 id="22d8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">全局注册命令</h1><p id="d315" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">任何现代的包管理器都有一个带有“global”选项的命令，用于全局注册可执行文件。巴什也一样。您可以通过键入<code class="fe lv lw lx ly b">bashy your_script args</code>或直接键入<code class="fe lv lw lx ly b">your_script args</code>来调用您的脚本。但是怎么可能呢？我使用了以下技巧:</p><ol class=""><li id="33cb" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu nn nf ng nh bi translated">在安装过程中，我在<code class="fe lv lw lx ly b">BASHY_HOME</code>(通常是<code class="fe lv lw lx ly b">/home/username/.bashy/bin</code>)中给<code class="fe lv lw lx ly b">$PATH</code>变量添加了一个bin文件夹。</li><li id="db06" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">每当您将脚本导入Bashy时，我都会在bin文件夹中创建一个与命令同名的文件。因此，这个文件对于shell是可见的，并且可以由用户运行</li><li id="e569" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu nn nf ng nh bi translated">该脚本的内容是一个常规的sh脚本(或windows上的cmd脚本),它用类似如下的内容包装了一个bashy调用:</li></ol><pre class="kj kk kl km gt nr ly ns bn nt nu bi"><span id="aa77" class="nv ma it ly b be nw nx l ny nz">bashy {script name} "@$@".</span></pre><h1 id="3dec" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="297b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在本文中，我们深入探究了Bashy的核心特性，并发现了它们是如何实现的。这些元素在你的下一个Go应用中会很有用。此外，我们已经看到了如何用几行代码实现一个复杂的应用程序。</p><p id="9f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，本文有一些参考资料:</p><ul class=""><li id="007b" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">Bashy的所有源代码都是开放的，你可以在GitHub<a class="ae ky" href="https://github.com/zeppaman/bashy" rel="noopener ugc nofollow" target="_blank">https://github.com/zeppaman/bashy</a>上找到</li><li id="e439" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我用于参数解析的库可以在<a class="ae ky" href="https://github.com/urfave/cli" rel="noopener ugc nofollow" target="_blank">https://github.com/urfave/cli</a>获得</li></ul></div></div>    
</body>
</html>