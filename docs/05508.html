<html>
<head>
<title>2 Ways to Make Protocol Methods Optional in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使协议方法可选的2种方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/2-ways-to-make-protocol-methods-optional-in-swift-f032836a343b?source=collection_archive---------10-----------------------#2020-07-14">https://betterprogramming.pub/2-ways-to-make-protocol-methods-optional-in-swift-f032836a343b?source=collection_archive---------10-----------------------#2020-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="36ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解每种方法的优缺点</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/62528de864a93200bd6e8cbf8338ffbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sxR72AX-E53kV3PtvbKfnA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1031224" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/photos/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1031224" rel="noopener ugc nofollow" target="_blank">自由照片</a>提供</p></figure><p id="3e6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将了解两种使协议方法可选的方法。我们将探讨每种方法的优缺点。</p><p id="ad45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事不宜迟，我们开始吧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="504a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">默认实现</h1><p id="5b61" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第一种方法是创建协议的扩展，并包含该协议的空方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="4ee8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们使<code class="fe nb nc nd ne b">didDismiss()</code>方法成为可选的。让我们看看当我们遵守<code class="fe nb nc nd ne b">PickerViewDelegate</code>协议时会发生什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器不要求我们实现<code class="fe nb nc nd ne b">didDismiss()</code>方法。</p><h2 id="d59b" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">优势</h2><ul class=""><li id="bdcb" class="nr ns it lb b lc mu lf mv li nt lm nu lq nv lu nw nx ny nz bi translated">我们也可以使结构符合协议</li><li id="64b2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">当我们不在一致性类型中实现方法时，扩展中的默认实现被自动使用</li></ul><h2 id="a5b7" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">不足之处</h2><ul class=""><li id="2e27" class="nr ns it lb b lc mu lf mv li nt lm nu lq nv lu nw nx ny nz bi translated">在可选方法返回非<code class="fe nb nc nd ne b">Void</code>值的情况下，我们需要在默认实现中提出并返回一些值</li></ul></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9645" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Objective-C '可选'关键字</h1><p id="61c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以用<code class="fe nb nc nd ne b">@objc</code>关键字标记协议，用<code class="fe nb nc nd ne b">@objc optional</code>标记可选方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f2a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们不需要创建一个扩展—我们所需要做的就是使一个类符合协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="e185" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">优势</h2><ul class=""><li id="b18b" class="nr ns it lb b lc mu lf mv li nt lm nu lq nv lu nw nx ny nz bi translated">不需要创建扩展</li></ul><h2 id="61e7" class="nf md it bd me ng nh dn mi ni nj dp mm li nk nl mo lm nm nn mq lq no np ms nq bi translated">不足之处</h2><ul class=""><li id="c784" class="nr ns it lb b lc mu lf mv li nt lm nu lq nv lu nw nx ny nz bi translated">只有<code class="fe nb nc nd ne b">NSObject</code>子类可以继承<code class="fe nb nc nd ne b">@objc</code>协议。这意味着我们<em class="of">不能</em>使结构或枚举符合协议。</li><li id="5e5c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated">如果我们突然需要调用一个可选的方法，就必须在方法名后面加上<code class="fe nb nc nd ne b">?</code>或者<code class="fe nb nc nd ne b">!</code>符号(如果我们使用强制解包，方法没有实现，app就会崩溃):</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="a457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然第二种方法乍一看似乎很好，但还是推荐使用第一种，因为它有更大的灵活性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3eab" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">包扎</h1><p id="2b28" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">对Swift更多鲜为人知的功能感兴趣？请随意查看我的其他相关文章:</p><ul class=""><li id="1411" class="nr ns it lb b lc ld lf lg li og lm oh lq oi lu nw nx ny nz bi translated"><a class="ae ky" href="https://medium.com/better-programming/what-is-the-operator-in-swift-7f6bc7623023" rel="noopener">“Swift中的~=运算符是什么？</a></li><li id="f83c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/better-programming/what-is-the-value-binding-pattern-in-swift-a644be3e0597" rel="noopener ugc nofollow" target="_blank">“Swift的价值绑定模式是什么？</a></li><li id="3da2" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/better-programming/what-is-the-difference-between-class-and-static-in-swift-3493848ed831" rel="noopener ugc nofollow" target="_blank">“Swift中的类和静态有什么区别？</a></li><li id="8147" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://levelup.gitconnected.com/better-programming/what-is-the-vdsp-framework-in-swift-fe2539693e9a" rel="noopener ugc nofollow" target="_blank">“Swift中的vDSP框架是什么？</a></li></ul><p id="499b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>