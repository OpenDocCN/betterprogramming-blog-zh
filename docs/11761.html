<html>
<head>
<title>Dockerize Your Django Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将你的Django应用归档</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dockerize-your-django-apps-428189407c69?source=collection_archive---------0-----------------------#2022-04-14">https://betterprogramming.pub/dockerize-your-django-apps-428189407c69?source=collection_archive---------0-----------------------#2022-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6ffa" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从本地开发到生产</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ebd003ddf7ff95b4cbe4de05846aaa1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3Pm3phWXHpZpaVDDc7_GA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在<a class="ae kv" href="https://unsplash.com/s/photos/guide?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kv" href="https://unsplash.com/@jlcruz_photography" rel="noopener ugc nofollow" target="_blank"> Fern M. Lomibao </a>拍摄的照片</p></figure><p id="aebe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将你的Django应用程序归档不仅有助于环境的标准化，还会使云中的扩展变得非常容易。</p><h1 id="c00a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">为什么是码头集装箱？</strong></h1><p id="0136" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在开发和生产过程中使用Docker有几个好处:</p><h2 id="ae45" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">开发中</strong></h2><ul class=""><li id="016c" class="nb nc iq ky b kz mk lc ml lf nd lj ne ln nf lr ng nh ni nj bi translated">跨多个平台的环境标准化:您只需定义一次开发环境，并与您的团队共享。那么每个人都可以使用相同的环境，不管他们的本地设置如何。例如，有人可能使用macOS，另一个是Ubuntu，其他人甚至可能在他们的开发工作站上使用Windows。只要他们能够运行Docker，他们就能够启动并运行相同的开发环境。</li><li id="3b22" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">新开发人员的最短设置时间:只需几个命令，新开发人员就可以在几分钟内建立并运行一个完整的环境，包括数据库、队列或任何其他所需的服务。</li><li id="dfd4" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">保持本地工作站的整洁:由于您的环境是作为一组隔离的容器运行的，所以除了Docker或docker-compose之外，不会在本地安装任何东西。另外，您可以在工作站上安装不同的环境，并轻松管理它们。例如，假设您正在使用Python 3.8、Django 3.3和PostgreSQL 12处理一个项目，然后您开始使用Python 3.10、Django 4.0和PostgreSQL 13处理一个新项目。没问题，您可以在需要时启动一个或另一个环境。</li></ul><h2 id="429d" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">生产中</strong></h2><ul class=""><li id="3457" class="nb nc iq ky b kz mk lc ml lf nd lj ne ln nf lr ng nh ni nj bi translated">隔离:由于你的应用程序运行在一个隔离的容器中，没有什么可以破坏它的环境。如果您的应用程序在服务器或虚拟机上运行，意外破坏环境并不需要太多的努力(例如，安装或更新一些可能破坏某些依赖关系的包，编辑或删除一些配置文件等)。).</li><li id="8170" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">可再现性:一旦环境被定义，它可以在任何时候被重新创建。</li><li id="d462" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">弹性:Docker使添加或删除系统组件或服务的实例变得非常容易。如果出于某种原因，您的容器进入了不健康的状态(例如，它不再响应请求)，可以很容易地停止它，并启动一个新的实例来替换它。</li><li id="2def" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">可伸缩性:如果您需要支持更大的工作负载，您可以添加更多的实例。一旦工作量减少，您可以删除一些实例。</li><li id="fffb" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">性能:Docker容器的启动和停止速度比普通服务器或虚拟机快得多。它需要几秒或几分钟，而不是几分钟或几小时。</li><li id="a035" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">资源优化:容器比虚拟机更轻，因此它们需要更少的CPU和/或RAM来运行。</li></ul><h2 id="ee64" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> Docker vs Virtualenv </strong></h2><p id="7322" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可能想知道，如果您已经有了一个使用virtualenv的隔离Python虚拟环境，为什么还需要Docker。virtualenv隔离了您的Python依赖项，Docker则更进一步，还隔离了您的操作系统和操作系统级包。一个典型的例子是在Django中使用PostgreSQL数据库。</p><p id="63a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以在virtualenv上安装psycopg2(一个Python适配器),但是还需要在主机环境中安装OS级的包，比如PostgreSQL客户机。Docker允许你把你的应用和操作系统以及所有需要的包打包在一起。实际上，在使用Docker时不再需要使用virtualenv，即使它可能有一些用例。</p><h2 id="b35a" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">码头工人基础知识</strong></h2><ul class=""><li id="4c72" class="nb nc iq ky b kz mk lc ml lf nd lj ne ln nf lr ng nh ni nj bi translated">Dockerfile:它是一个文本文件，包含一个构建应用程序映像的方法。在这里，您将添加所有的依赖项，从操作系统和操作系统级包到Python包，还有应用程序源代码和运行它所需的任何东西。</li><li id="2c72" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">image:docker file用于构建一个映像，其中包含所有需要的东西。图像大小从几兆字节到几千兆字节不等，建议保持较小的大小，只添加需要的内容。图像也可以从其他基础图像开始，所以你不需要从零开始。</li><li id="3af4" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">注册表:它是docker图像的存储库。DockerHub是一个公共注册中心，在这里你可以找到大多数操作系统和编程语言的<a class="ae kv" href="https://docs.docker.com/docker-hub/official_images/" rel="noopener ugc nofollow" target="_blank">官方图片</a>。</li><li id="f809" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">layers:docker文件中的指令从上到下执行，每一行向图像添加一层。层被缓存，因此如果没有被修改，它们将在下一次构建中被重用。但是指令顺序很重要。如果您修改了docker文件中的一行，该层及其下的所有层都将被重建。因此，您应该首先添加您希望更改频率较低的层，然后添加可以更改频率较高的层，以优化构建时间。</li><li id="9a8c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">阶段:使用多阶段构建，可以从一个docker文件中构建多个工件。此外，一个阶段的代码和/或任何生成的工件可以在另一个阶段重用，从而减少重复并使docker文件更易于维护。</li><li id="a8a5" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">容器:它是一个图像的运行实例。您可以从同一个图像或不同的图像旋转多个容器。</li><li id="3277" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">绑定挂载:它们允许在容器中挂载部分主机文件系统来共享文件。您可以将它们视为共享文件夹。它们在开发过程中和某些用例中是有用的，但是您应该在生产中避免它们，因为它们打破了容器隔离。</li><li id="aefe" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">卷:它们就像容器的虚拟硬盘。它们使用主机文件系统中的某个目录来保存数据，但是这些数据只能从docker容器中访问。</li></ul><h1 id="a18d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">动手操作:将Django应用程序归档</strong></h1><h2 id="9850" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">先决条件</strong></h2><p id="e661" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">安装docker和docker-compose:</p><p id="d590" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank">查看如何在公文中安装docker。</a></p><p id="72e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">查看如何在正式文档中安装docker-compose</a>。</p><h2 id="08cb" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">代码</h2><p id="aef6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">您可以在<a class="ae kv" href="https://github.com/marianobrc/scalable-django-apps" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到这个示例项目的完整代码。</p><h2 id="d37d" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">定义系统组件</strong></h2><p id="fa93" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">开始将系统装箱的第一步是确定要装箱的系统组件或服务。开发中的Django应用程序的典型架构如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/9b5cc4c571c71e4b3009bde12912ea67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*dtmq6Ohq2GLnFqOzLvdVtA.png"/></div></figure><p id="bff1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们可以确定图表中的两个主要组件:</p><ul class=""><li id="167b" class="nb nc iq ky b kz la lc ld lf nq lj nr ln ns lr ng nh ni nj bi translated">Django app:通常由<a class="ae kv" href="https://docs.djangoproject.com/en/4.0/ref/django-admin/#django-admin-runserver" rel="noopener ugc nofollow" target="_blank"> runserver </a>提供服务，它是与Django打包在一起的开发服务器。</li><li id="685c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">数据库:Django支持多种数据库，例如PostgreSQL、MySQL和SQLite。</li></ul><h2 id="26d8" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">Docker作曲作为您的本地管弦乐队</h2><p id="1e34" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Docker compose是一个用于定义和运行多容器Docker应用程序的工具，我们将在本地使用它来定义和运行我们的开发环境。</p><h2 id="ccb8" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">项目结构</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/667dacf4defd1e9bfeaf9ea030c2184a.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*PaKXCyXvk6YPHZUdEvFzDw.png"/></div></div></figure><p id="47eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个例子中的Django项目叫做<code class="fe nu nv nw nx b">app</code>。我们将在根级别为所有docker相关文件创建一个<code class="fe nu nv nw nx b">docker/ </code>目录。我们将放入的第一个文件是名为<code class="fe nu nv nw nx b">docker-compose.yml</code>的YAML文件。在docker-compose文件中，我们将定义两个服务。每个服务都需要一些引导和配置文件，所以让我们通过在<code class="fe nu nv nw nx b">docker/ </code>目录中创建子目录<code class="fe nu nv nw nx b">app/</code>和<code class="fe nu nv nw nx b">db/</code>来命名这些文件。</p><p id="f644" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker-compose.yml</code></p><p id="2d2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们将定义我们的两个服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8e2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">db</code>:包含PostgreSQL数据库服务器。</p><ul class=""><li id="67a4" class="nb nc iq ky b kz la lc ld lf nq lj nr ln ns lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">image</code>:在这种情况下，我们设置image来告诉docker-compose使用docker-hub 中预先构建的<a class="ae kv" href="https://hub.docker.com/_/postgres" rel="noopener ugc nofollow" target="_blank">映像，该映像包含PostgreSQL server版本13。Postgres维护着随时可用的官方映像，因此在这种情况下，不需要定义docker文件，也不需要手动构建。</a></li><li id="6d4b" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">restart</code>:每当容器停止时(例如，如果容器内存不足并退出)，它将自动重新启动</li><li id="91da" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">ports</code>:我们将数据库端口暴露给主机，以防我们稍后想要通过一些本地psql客户端应用程序连接到数据库。这是可选的，我们这样做只是为了开发，因为它可以用于检查数据库。</li><li id="74f3" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">environment</code>:这里，我们将环境变量(又名env vars)传递给数据库容器。因为我们不想在repo中提交敏感数据，如数据库凭证，所以我们还从主机环境变量中获取值。我们需要在旋转容器之前在本地设置这些env变量，我们将在后面看到。</li><li id="c1ee" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">volumes</code>:第一行添加了一个bind mount，用于将脚本db.sql复制到容器中的特定文件路径，当容器启动时，数据库服务器会检查该路径。这是Postgres映像的一个特性，如果它不存在，我们就用它来创建数据库。数据库名称、用户名和密码取自env变量。第二行添加了一个持久卷，用于在主机文件系统中保存数据库数据。</li></ul><p id="7e77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">app</code>:包含我们的Django应用。</p><ul class=""><li id="8eaf" class="nb nc iq ky b kz la lc ld lf nq lj nr ln ns lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">build</code>:在这种情况下，我们告诉docker-compose从我们的自定义docker文件构建图像。由于我们使用多阶段构建，我们还需要设置目标来告诉docker compose构建什么样的映像。我们将选择dev在这里构建我们的开发映像。</li><li id="9708" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">restart</code>:容器停止后会自动重启。例如，如果应用程序中有一个未处理的异常，容器将会停止，并由docker-compose再次启动。</li><li id="23cd" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">depends_on</code>:Django应用需要数据库运行，所以这里我们告诉docker-compose，在启动这个容器之前，需要先启动<code class="fe nu nv nw nx b">db</code>容器。</li><li id="a80f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">environment</code>:我们在本地开发期间设置Django应用程序所需的env变量。</li><li id="b8df" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">我们使用绑定挂载在主机和容器之间共享源代码。这样，每次我们编辑一些源代码时，它都会被复制到容器中。这也将触发runserver自动重载，这样我们就不需要在开发过程中每次代码改变后都重新构建容器。</li><li id="046f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">ports</code>:我们将应用程序运行的端口暴露给主机，这样我们就可以使用浏览器或主机上的其他应用程序与我们的web应用程序进行交互。</li><li id="1b8b" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">volumes</code>:注意在YAML文件的根层有第二个卷部分，引用名为<code class="fe nu nv nw nx b">postgres_data</code>的卷。卷声明可确保数据库容器的数据在容器停止时仍保存在主机的文件系统中。</li></ul><h2 id="5bcb" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> db文件说明:</strong></h2><p id="5600" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker/db/psql-init/db.sql</code></p><p id="b6b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个文件为Django应用程序创建数据库和一个专用的Postgres用户帐户，用于数据库事务。它在<code class="fe nu nv nw nx b">db</code>容器初始化期间执行，但是只有当数据库不存在时才执行。从env变量中读取数据库名称、用户名和密码。稍后在Django应用程序设置中使用相同的env变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7396" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:在运行Django单元测试时，创建测试数据库需要创建其他数据库的权限。</p><h2 id="dddf" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak"> app文件说明</strong></h2><p id="b47e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker/app/Dockerfile</code></p><p id="c9a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是用于构建Django应用程序映像的docker文件。我们将为开发和生产构建两个略有不同的映像。两者将共享相同的基本操作系统和一些公共包，但正如我们将看到的那样，应用程序的服务方式和源代码复制到容器的方式会有所不同。由于它们共享一个公共库，我们使用docker多级构建和docker构建工具包来保存一个docker文件以避免重复。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="fb70" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">基础阶段</strong></h2><p id="62ee" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">FROM python:3.10 as base</code>:我们基于docker hub 上的<a class="ae kv" href="https://hub.docker.com/_/python" rel="noopener ugc nofollow" target="_blank">官方Python镜像，选择版本<code class="fe nu nv nw nx b">3.10</code>。该映像将在构建时从docker hub中提取，它基本上基于Debian，包括Python 3.10和其他常见的操作系统级包，如<code class="fe nu nv nw nx b">apt</code>，这将允许我们安装额外的包，如postgress客户端。我们将这个阶段命名为“base ”,以便以后重用。</a></p><p id="7869" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">ENV PYTHONDONTWRITEBYTECODE</code>/<code class="fe nu nv nw nx b">PYTHONUNBUFFERED</code>:<code class="fe nu nv nw nx b">ENV</code>指令用于在构建过程中设置环境变量。在本例中，我们禁用了字节码的生成，并确保stdout和stderr直接发送到容器日志中，这样我们就可以实时看到我们的应用程序日志。</p><p id="1b91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">RUN addgroup .. &amp;&amp; adduser ..</code>:默认情况下，大多数基本docker映像使用root用户，但是以root用户身份运行您的web应用程序存在一些安全风险。例如，如果有人利用某种漏洞入侵容器，他们将获得root访问权限。所以，使用非root用户是一个很好的做法。</p><p id="8ba6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">RUN apt-get update &amp;&amp; apt-get install</code>:RUN指令允许在shell中执行命令。在这里，我们使用debian软件包管理器<code class="fe nu nv nw nx b">apt</code>来安装其他需要的OS级软件包。我们安装了一些Python构建实用程序和Postgres数据库客户端，它是psycopg2的一个依赖项。</p><p id="528c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER web</code>:切换到我们的非root用户。我们将只在需要的时候使用根用户。</p><p id="2177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">WORKDIR /home/web/code/</code>:该指令设置工作路径，创建代码/子目录。在这个指令之后，我们可以在其他指令中使用相对路径，比如<code class="fe nu nv nw nx b">COPY</code>和<code class="fe nu nv nw nx b">RUN</code>。</p><p id="11e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">COPY --chown=web:web ./requirements/base.txt requirements/base.txt</code>:我们将需求文件从本地文件系统复制到工作目录中的<code class="fe nu nv nw nx b">requirements/</code>子目录中。我们有一个包含两个需求文件的<code class="fe nu nv nw nx b">requirements/</code>目录:<code class="fe nu nv nw nx b">base.txt</code>和<code class="fe nu nv nw nx b">prod.txt</code>。<code class="fe nu nv nw nx b">base.txt</code>文件列出了在开发或生产环境中运行我们的应用程序所需的常见Python包，例如Django和psycopg2，而<code class="fe nu nv nw nx b">prod.txt</code>列出了一些只在生产环境中需要的额外包。</p><p id="1a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们正在构建本地基础环境，所以我们只需要基础要求。<code class="fe nu nv nw nx b">--chown</code>选项将名为<code class="fe nu nv nw nx b">web</code>的非root用户设置为文件的所有者。如果没有添加，<code class="fe nu nv nw nx b">COPY</code>指令默认设置所有者为<code class="fe nu nv nw nx b">root</code>。</p><p id="088c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER root</code>:我们切换到root用户，在系统级安装Python包。</p><p id="52cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在安装了开发环境所需的所有Python包。注意，我们不需要使用virtualenv，因为整个操作系统和文件系统是隔离的，所以可以在操作系统级别安装软件包。</p><p id="1a0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">COPY --chown=web:web ./docker/app/entrypoint.sh /usr/local/bin/entrypoint.sh</code>:我们复制了一个entrypoint脚本，它将在容器中执行任何其他命令之前检查db是否准备好。我们将脚本复制到一个已知的路径中，该路径适合放置debian中的用户级可执行文件。</p><p id="e523" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">RUN chmod +x /usr/local/bin/entrypoint.sh</code>:授予执行权限。</p><p id="0aa2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER web</code>:切换回我们的非root用户。</p><p id="9ecd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">ENTRYPOINT [“entrypoint.sh”]</code>:我们声明这个脚本将在稍后定义的任何其他CMD之前首先执行。</p><p id="e3e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker/app/entrypoint.sh</code></p><p id="65cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们基本上尝试使用psycopg2打开一个连接。如果失败，我们每隔一秒就重试一次。如果成功，我们执行作为参数接收的命令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="3912" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">显影图像说明:</strong></h2><p id="995e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">FROM base as dev</code>:我们为开发定义了一个镜像，命名为<code class="fe nu nv nw nx b">dev</code>，它继承了<code class="fe nu nv nw nx b">base</code>阶段的基础OS和公共包。</p><p id="2ff0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">COPY --chown=web:web ./docker/app/start-dev-server.sh /usr/local/bin/start-dev-server.sh</code>:我们复制运行开发服务器的脚本。</p><p id="b69b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER root</code>:我们切换到root用户，授予对前面脚本的执行权限。</p><p id="66d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">RUN chmod +x /usr/local/bin/start-dev-server.sh</code>:我们授予执行权限。</p><p id="1aa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER web</code>:切换回我们的非root用户。</p><p id="2166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">CMD [“start-dev-server.sh”]</code>:容器启动时，开发服务器默认启动。请注意，这是作为非root用户运行的。</p><p id="769f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还要注意，这里没有将应用程序代码复制到容器中。我们使用之前在docker compose中添加的绑定挂载来同步主机和容器之间的代码。</p><p id="55d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker/app/start-dev-server.sh</code></p><p id="1262" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们确保应用了迁移，然后使用内置的Django命令<code class="fe nu nv nw nx b">runserver</code>启动开发服务器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="40fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">runserver支持在检测到源文件中的任何更改后自动重新加载。这与卷相结合，使我们可以看到在容器内运行的应用程序中反映的源代码的任何变化，而无需重建映像。我们将在开发中这样做，因为以这种方式使用卷也会打破容器隔离，我们不想在生产中这样做。</p><h2 id="4168" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">使用docker compose运行开发环境</strong></h2><p id="f3a9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，在一个<code class="fe nu nv nw nx b">.env</code>文件中设置您的env变量(docker compose将从那里获取它们)。您可以复制<a class="ae kv" href="https://github.com/marianobrc/scalable-django-apps/blob/master/app/docker/.env.template" rel="noopener ugc nofollow" target="_blank"> .env.template </a>并设置您的值。然后，所有的服务都可以通过一个简单的命令启动:<code class="fe nu nv nw nx b">docker-compose up</code>，如下所示:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="dde2" class="mp lt iq nx b gy oe of l og oh">$ COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1 docker-compose up<br/>Creating network "docker_default" with the default driver<br/>Creating volume "docker_postgres_data" with default driver<br/>Pulling db (postgres:13)...<br/>13: Pulling from library/postgres<br/>5eb5b503b376: Pull complete<br/>...<br/>Building app<br/>[+] Building 206.5s (17/17) FINISHED                                                                                      <br/> =&gt; [internal] load build definition from Dockerfile                                                                 ...<br/> =&gt; [base 1/9] FROM docker.io/library<br/>...<br/> =&gt; exporting to image                                                                                               ...<br/>Successfully built <br/>...<br/>Creating docker_db_1 ... done<br/>Creating docker_app_1 ... done<br/>Attaching to docker_db_1, docker_app_1<br/>db_1   | The files belonging to this database system will be owned by user "postgres".<br/>db_1   | This user must also own the server process.<br/>...<br/>db_1   | 2022-02-17 13:29:11.276 UTC [1] LOG:  database system is ready to accept connections<br/>app_1  | Trying to connect to database 'db_dev' on host 'db'..<br/>app_1  | Postgres is up - continuing...<br/>app_1  | Running migrations..<br/>app_1  | Operations to perform:<br/>app_1  |   Apply all migrations: admin, auth, contenttypes, sessions, users<br/>app_1  | Running migrations:<br/>app_1  |   Applying contenttypes.0001_initial... OK<br/>...<br/>app_1  | Performing system checks...<br/>app_1  | <br/>app_1  | System check identified no issues (0 silenced).<br/>app_1  | February 17, 2022 - 13:29:16<br/>app_1  | Django version 4.0.2, using settings 'app.settings.local'<br/>app_1  | Starting development server at <a class="ae kv" href="http://0.0.0.0:8000/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000/</a><br/>app_1  | Quit the server with CONTROL-C.</span></pre><p id="f394" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们在运行中设置了一些环境变量<code class="fe nu nv nw nx b">COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1</code>。这允许使用docker <a class="ae kv" href="https://docs.docker.com/develop/develop-images/build_enhancements/" rel="noopener ugc nofollow" target="_blank"> BuildKit </a>(如果您使用的是最新的docker引擎版本，这可能是默认启用的)。这将使构建更快，并且它还允许构建特定的目标，例如构建<code class="fe nu nv nw nx b">dev</code>图像而不构建<code class="fe nu nv nw nx b">prod</code>图像。在这两种情况下都会自动构建<code class="fe nu nv nw nx b">base</code>图像，因为它是一个依赖项。</p><p id="e3e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一次需要花费更多的时间，因为需要构建映像，并且需要从注册表中提取基础映像。然后图像被缓存，这样下次会更快。</p><p id="e63e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">成功启动后，您将看到:</p><ul class=""><li id="3127" class="nb nc iq ky b kz la lc ld lf nq lj nr ln ns lr ng nh ni nj bi translated">后端在<code class="fe nu nv nw nx b">http://127.0.0.1:8000</code>可用(端口暴露在docker-compose)</li><li id="f593" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated">Django管理面板位于<code class="fe nu nv nw nx b"><a class="ae kv" href="http://127.0.0.1:8000/admin/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/admin/</a></code></li></ul><h2 id="b076" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">如何在构图过程中重建图像</h2><p id="6b44" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因为我们使用绑定挂载来与容器共享主机上的源代码，所以我们不需要在代码更改时重建应用程序映像。但是如果您添加了一些Python依赖项，或者在docker文件中做了任何更改，您将需要重新构建映像来查看容器中的更改。您可以告诉docker-compose添加<code class="fe nu nv nw nx b">--build</code>标志来重建图像。</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="f817" class="mp lt iq nx b gy oe of l og oh">$ COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1 docker-compose up --build<!-- --> </span></pre><p id="8e3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">已经是最新的图像不会被重建，所以你可以安全地添加这个标志。</p><h2 id="40c5" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">查看日志</h2><p id="4176" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker-compose up</code>命令聚集每个容器的输出。当命令退出时，所有容器都将停止。运行<code class="fe nu nv nw nx b">docker-compose up -d</code>在后台启动容器，并让它们继续运行。因此，要查看单个服务的日志，您可以运行:<code class="fe nu nv nw nx b">docker-compose logs [-f] &lt;service&gt;</code></p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="c446" class="mp lt iq nx b gy oe of l og oh">$ docker-compose logs -f app</span><span id="da47" class="mp lt iq nx b gy oi of l og oh">Attaching to docker_app_1<br/>app_1  | Trying to connect to database 'db_dev' on host 'db'..<br/>app_1  | could not connect to server: Connection refused<br/>app_1  |  Is the server running on host "db" (172.19.0.2) and accepting<br/>app_1  |  TCP/IP connections on port 5432?<br/>app_1  | <br/>app_1  | Postgres is unavailable - sleeping<br/>app_1  | Trying to connect to database 'db_dev' on host 'db'..<br/>app_1  | Postgres is up - continuing...<br/>app_1  | Running migrations..<br/>app_1  | Operations to perform:<br/>app_1  |   Apply all migrations: admin, auth, contenttypes, sessions, users<br/>app_1  | Running migrations:<br/>app_1  |   Applying contenttypes.0001_initial... OK<br/>app_1  |   Applying contenttypes.0002_remove_content_type_name... OK<br/>...<br/>app_1  |   Applying sessions.0001_initial... OK<br/>app_1  | Starting server..<br/>app_1  | Watching for file changes with StatReloader<br/>app_1  | Watching for file changes with StatReloader<br/>app_1  | Performing system checks...<br/>app_1  | <br/>app_1  | System check identified no issues (0 silenced).<br/>app_1  | February 17, 2022 - 18:02:46<br/>app_1  | Django version 4.0.2, using settings 'app.settings.local'<br/>app_1  | Starting development server at <a class="ae kv" href="http://0.0.0.0:8000/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:8000/</a><br/>app_1  | Quit the server with CONTROL-C.</span></pre><h2 id="1e07" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">如何在运行中的容器中运行命令</h2><p id="e6a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用docker-compose: <code class="fe nu nv nw nx b">docker-compose exec &lt;service&gt; &lt;command&gt;</code></p><p id="4d2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将在一个新的终端中运行已经运行的容器中的命令。</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="2521" class="mp lt iq nx b gy oe of l og oh"># Apply migrations<br/>$ <!-- -->docker-compose exec app python manage.py migrate</span><span id="e916" class="mp lt iq nx b gy oi of l og oh"># Open a bash shell inside the container<br/>$ <!-- -->docker-compose exec app bash</span><span id="6c69" class="mp lt iq nx b gy oi of l og oh"># Create an admin user<br/>$ docker-compose exec app python manage.py createsuperuser<br/>Username: admin<br/>Email address: <a class="ae kv" href="mailto:admin@testapp.com" rel="noopener ugc nofollow" target="_blank">admin@myapp.com</a><br/>Password: <br/>Password (again): <br/>Superuser created successfully.<br/>$</span></pre><h2 id="c51b" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">如何在容器中运行需要文件写权限的命令:</strong></h2><p id="a11c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当您在容器中执行一个命令时，它将在我们之前定义的非根用户网站上运行。但是因为我们使用绑定挂载将源代码放入容器，所以这些文件实际上是由主机上的用户拥有的。如果你试图运行任何试图写文件的命令，比如<code class="fe nu nv nw nx b">startapp </code>或<code class="fe nu nv nw nx b">makemigrations </code>，你会得到一个权限错误:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="7377" class="mp lt iq nx b gy oe of l og oh">$ docker-compose exec app python manage.py startapp books<br/>CommandError: [Errno 13] Permission denied: ‘/home/web/code/books’</span></pre><p id="a55a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们需要告诉docker compose使用拥有文件和目录的主机用户来运行这些命令。我们通过传递用户id和组id来做到这一点，这可以使用id命令获得。</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="18cd" class="mp lt iq nx b gy oe of l og oh"># Open a bash shell inside the container<br/>$ <!-- -->docker-compose exec -u $(id -u):$(id -g) app python manage.py startapp books</span></pre><h2 id="3956" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">一些其他有用的命令</h2><p id="c978" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">检查每个服务的状态:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="bdab" class="mp lt iq nx b gy oe of l og oh">$ docker-compose ps<!-- --> <br/>Name                  Command                State             Ports         <br/>---------------------------------------------------------------------------------<br/>docker_app_1   /entrypoint.sh /start-dev- ...   Exit 137                         <br/>docker_db_1    docker-entrypoint.sh postgres    Up 0.0.0.0:5432-&gt;5432/tcp</span></pre><p id="d08e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">停止所有服务:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="5f65" class="mp lt iq nx b gy oe of l og oh">$ docker-compose down<br/>Stopping docker_app_1 ... done<br/>Stopping docker_db_1  ... done<br/>Removing docker_app_1 ... done<br/>Removing docker_db_1  ... done<br/>Removing network docker_default</span></pre><p id="9745" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">停止单个服务:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="349c" class="mp lt iq nx b gy oe of l og oh">$ docker-compose stop app<br/>Stopping docker_app_1 ... done</span></pre><p id="1174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重置数据库:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="8c91" class="mp lt iq nx b gy oe of l og oh">$ docker-compose down --volumes<br/>Stopping docker_db_1 ... done<br/>Removing docker_app_1 ... done<br/>Removing docker_db_1  ... done<br/>Removing network docker_default<br/>Removing volume docker_postgres_data<br/>$ docker-compose up</span></pre><h2 id="4b85" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">生产图像解释</h2><p id="38a6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">FROM base as prod</code>:我们现在定义一个生产映像，命名为“prod”，它继承了来自<em class="oj">基础阶段</em>的基础操作系统和公共包。构建此映像时，将首先自动构建基础映像。</p><p id="2763" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">COPY --chown=web:web ./requirements/prod.txt requirements/prod.txt</code>:我们可能有额外的生产依赖项，所以我们将生产需求文件复制到容器中。</p><p id="56a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER root</code>:我们切换到root用户，在系统级安装Python包。</p><p id="12b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们安装生产依赖项。</p><p id="ed8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER web</code>:切换回我们的非root用户。</p><p id="222d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">COPY --chown=web:web ./docker/app/start-prod-server.sh /usr/local/bin/start-prod-server.sh</code>:我们复制脚本，该脚本将服务于我们的生产应用程序。</p><p id="7760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER root</code>:我们切换到root用户，授予对前面脚本的执行权限。</p><p id="acbd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">RUN chmod +x /usr/local/bin/start-prod-server.sh</code>:我们授予执行权限。</p><p id="e2d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">USER web</code>:切换回我们的非root用户。</p><p id="7c0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">COPY --chown=web:web . ./</code>:我们把主机上的源代码复制到镜像的工作目录下。我们再次使用— <code class="fe nu nv nw nx b"> chown</code>选项，让非root用户成为这些文件的所有者。请注意，我们在生产中不使用卷。我们希望保持生产环境的隔离和无状态。下一次您想要发布一个包含代码变更的新版本时，您将需要重新构建映像并重新部署它。我们将在下一章看到如何在不停机的情况下做到这一点。</p><p id="5f54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">CMD [“start-prod-server.sh”]</code>:容器启动时，生产应用服务器默认启动。请注意，这是作为非root用户运行的。</p><p id="ddf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用生产就绪的应用服务器:Gunicorn</p><p id="93d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然runserver非常适合本地开发和快速测试，但它不适合生产。为了在生产中服务我们的Django应用，我们将使用<a class="ae kv" href="https://gunicorn.org/" rel="noopener ugc nofollow" target="_blank"> gunicorn </a>。</p><p id="b7c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker/app/start-prod-server.sh</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e885" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">python manage.py migrate</code>:确保首先应用任何新的迁移。</p><p id="323a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">python manage.py collectstatic — noinput</code>:将静态文件复制到最终目的地，从那里开始生产。提供静态文件(如图像、css、js)会消耗处理时间和资源。因此，在生产中，建议从CDN或专用服务器为他们提供服务。</p><p id="d3ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">gunicorn app.wsgi — bind 0.0.0.0:8000 — timeout 60 — access-logfile — — error-logfile -</code> : Gunicorn是一个用于Python应用程序的生产就绪应用服务器。它使用一个fork前工作器模型来并行处理应用程序的几个实例，并且能够高效地处理大量并发请求。Gunicorn要求Python应用程序实现<a class="ae kv" href="https://wsgi.readthedocs.io/en/latest/learn.html" rel="noopener ugc nofollow" target="_blank"> WSGI接口</a>，这样它就可以接收HTTP请求。</p><p id="ee27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Django被设计成可以开箱即用地使用WSGI，因此当您创建一个项目时，Django会自动创建一个名为<code class="fe nu nv nw nx b">&lt;projectname&gt;.wsgi</code>的配置文件，其中包含最少的默认WSGI配置。我们需要将wsgi配置文件的路径作为第一个参数传递给gunicorn。然后我们还设置了<code class="fe nu nv nw nx b">--bind</code>告诉gunicorn在<code class="fe nu nv nw nx b">port 8000</code>上服务app。</p><p id="01be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们将应用程序部署到生产环境中，我们还将添加一个负载平衡器，它将接收HTTP/S请求，并将它们转发到端口8000上的应用程序实例，我们将在下一章中看到。我们还将<code class="fe nu nv nw nx b">--timeout</code>设置为60，这样，如果一个工作者没有响应或者某个请求花费的时间超过60，那么这个工作者将被杀死并重新启动，以便能够继续处理其他请求。</p><p id="762f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还将<code class="fe nu nv nw nx b">--access-logfile</code>和<code class="fe nu nv nw nx b">--error-logfile</code>设置为<code class="fe nu nv nw nx b">-</code>，告诉gunicorn将所有日志发送到stdout，而不是写入日志文件。因为我们不想使用卷，并且我们想让我们的容器保持无状态，所以我们不想写任何文件。但是我们稍后将能够在AWS中可视化日志，我们将在下一章中看到。</p><h2 id="24c5" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">测试生产图像</strong></h2><p id="4d12" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们不打算将<code class="fe nu nv nw nx b">docker-compose</code>用于生产，但是我们可以使用普通的docker命令来运行我们的生产映像的测试构建。</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="6052" class="mp lt iq nx b gy oe of l og oh">$ DOCKER_BUILDKIT=1 <!-- -->docker build -t app_prod:latest --target prod -f ./docker/app/Dockerfile  .</span></pre><p id="7f9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意，我们在这里再次使用docker BuildKit将目标设置为prod。这将告诉docker只构建生产映像，而开发映像将被跳过。</p><h1 id="b1ec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">添加队列和工作人员</h1><p id="47f4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果您使用队列和工人来运行异步任务，那么您可能希望在本地复制您的架构，以便在与生产环境尽可能相似的环境中进行集成测试或端到端测试。</p><p id="a178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个例子，我们将使用<a class="ae kv" href="https://docs.celeryq.dev/en/stable/" rel="noopener ugc nofollow" target="_blank">芹菜</a>和<a class="ae kv" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html" rel="noopener ugc nofollow" target="_blank">亚马逊SQS </a>作为<a class="ae kv" href="https://docs.celeryq.dev/en/stable/getting-started/backends-and-brokers/sqs.html" rel="noopener ugc nofollow" target="_blank">经纪人</a>。</p><p id="b353" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">先决条件</strong> : <a class="ae kv" href="https://docs.celeryq.dev/en/stable/django/first-steps-with-django.html" rel="noopener ugc nofollow" target="_blank">将芹菜添加到您的Django项目</a>中。</p><h2 id="6edb" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">更新项目结构</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/529b9f93989f031210562176a340cf7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*A03MUbvTRKB52b3J5EWHOA.png"/></div></figure><p id="bad0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们添加一个脚本来启动一个名为<code class="fe nu nv nw nx b">start-celery-worker.sh</code>的芹菜工人。我们将它放在<code class="fe nu nv nw nx b">app/</code>目录中，因为芹菜工人将与应用程序共享同一个docker映像。</p><p id="10ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，由于我们的代理容器需要一些配置文件，我们在<code class="fe nu nv nw nx b">docker/ </code>目录中创建了一个名为<code class="fe nu nv nw nx b">broker/</code>的新子目录。</p><h2 id="5b37" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">更新docker-compose配置</h2><p id="76c0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们添加了两个新服务，一个用于代理，一个用于工人。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e281" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">broker</code>:它是运行SQS实例的容器。</p><ul class=""><li id="dab8" class="nb nc iq ky b kz la lc ld lf nq lj nr ln ns lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">image</code>:我选择使用DockerHub的<a class="ae kv" href="https://hub.docker.com/r/softwaremill/elasticmq-native/" rel="noopener ugc nofollow" target="_blank">software mill/elastic MQ-native</a>镜像。还有其他图像，如<a class="ae kv" href="https://hub.docker.com/r/roribio16/alpine-sqs/" rel="noopener ugc nofollow" target="_blank"> roribio16/alpine-sqs </a>和<a class="ae kv" href="https://hub.docker.com/r/localstack/localstack" rel="noopener ugc nofollow" target="_blank">local stack/local stack</a>(local stack允许在本地运行sqs和其他aws服务)，但在撰写本文时，softwaremill的图像是唯一一个对我来说没有问题的图像。它有很好的性能，GitHub上有一个<a class="ae kv" href="https://github.com/softwaremill/elasticmq" rel="noopener ugc nofollow" target="_blank"> descent文档</a>，一个简单但很好的用户界面用于监控，并且它正在被积极地维护。</li><li id="220c" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">ports</code>:出于测试/调试的目的，我们公开了端口<code class="fe nu nv nw nx b">9324</code>和<code class="fe nu nv nw nx b">9325</code>，但这是可选的。我们在端口<code class="fe nu nv nw nx b">9324</code>上公开了SQS API，以防我们想要从我们的主机连接。我们在端口<code class="fe nu nv nw nx b">9325</code>中公开UI，以便能够监控队列和消息。</li><li id="daa7" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">volumes</code>:我们使用绑定挂载将配置文件复制到容器中。</li></ul><h2 id="5126" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">工人-默认</strong></h2><ul class=""><li id="3e07" class="nb nc iq ky b kz mk lc ml lf nd lj ne ln nf lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">build</code>:工作者将使用与Django应用相同的图像。</li><li id="d98f" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">image</code>:对于此服务，我们只是将图像重命名为worker-default</li><li id="abaa" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">command</code>:我们重写了启动celery worker的命令，它将处理<code class="fe nu nv nw nx b">default</code>队列中的消息。</li><li id="d308" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">depends_on</code>:在启动worker之前，我们需要运行代理，以便worker可以从队列中读取消息。此外，我们需要数据库运行，以防我们想要进行任何查询来检索上下文数据或保存结果。</li><li id="9043" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">environment</code>:worker容器将与应用程序具有相同的env变量，因为它使用相同的图像。</li><li id="e2eb" class="nb nc iq ky b kz nk lc nl lf nm lj nn ln no lr ng nh ni nj bi translated"><code class="fe nu nv nw nx b">volumes</code>:我们还使用与应用程序相同的绑定挂载将应用程序代码复制到容器中。</li></ul><h2 id="b03b" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated">工人</h2><p id="f67a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker/app/start-celery-worker.sh</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b2d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个脚本启动一个celery worker来处理队列中的消息。队列名作为第一个参数传递，<code class="fe nu nv nw nx b">-A</code>选项设置包含celery应用程序对象的模块名，<code class="fe nu nv nw nx b">-l</code>选项设置日志级别。</p><h2 id="b996" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">更新Dockerfile </strong></h2><p id="3475" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们只需要在基本映像中添加两个likes来复制将运行celery worker的脚本，并授予执行权限:</p><pre class="kg kh ki kj gt oa nx ob oc aw od bi"><span id="2e0a" class="mp lt iq nx b gy oe of l og oh">COPY --chown=web:web ./docker/app/start-celery-worker.sh /usr/local/bin/start-celery-worker.sh                             <br/>RUN chmod +x /usr/local/bin/start-celery-worker.sh</span></pre><h2 id="48e3" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">更新后的Dockerfile </strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="c7dd" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">经纪人配置</strong></h2><p id="e833" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">SQS映像需要一个配置文件，因此我们将在之前创建的<code class="fe nu nv nw nx b">broker/</code>目录中添加一个<code class="fe nu nv nw nx b">custom.conf</code>文件。</p><p id="24c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">docker/broker/custom.conf</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8e93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">node-address</code>部分的第一组设置定义了SQS端点URL和端口。这需要与Django应用程序中定义的<a class="ae kv" href="https://docs.celeryq.dev/en/stable/userguide/configuration.html#broker-settings" rel="noopener ugc nofollow" target="_blank">芹菜设置</a>相匹配。例如，如果端口是<code class="fe nu nv nw nx b">9324</code>，服务在docker网络中被命名为<code class="fe nu nv nw nx b">broker</code>(在docker-compose设置中定义)，那么<code class="fe nu nv nw nx b">CELERY_BROKER_URL</code>应该是<code class="fe nu nv nw nx b"><a class="ae kv" href="http://broker:9324/000000000000/defaul" rel="noopener ugc nofollow" target="_blank">sqs://broker:9324/</a></code></p><p id="0f20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在<code class="fe nu nv nw nx b">queues</code>部分，我们创建一个名为<code class="fe nu nv nw nx b">default</code>的队列，它将被用作<a class="ae kv" href="https://docs.celeryq.dev/en/stable/userguide/configuration.html#std-setting-task_default_queue" rel="noopener ugc nofollow" target="_blank">芹菜默认队列</a>(在Django应用程序设置中定义)。正确设置<code class="fe nu nv nw nx b">defaultVisibilityTimeout</code>以避免芹菜任务ETAs 的<a class="ae kv" href="https://docs.celeryq.dev/en/stable/getting-started/backends-and-brokers/sqs.html#caveats" rel="noopener ugc nofollow" target="_blank">问题也很重要。</a></p><p id="b21a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nu nv nw nx b">aws</code>部分中的其他设置不需要真实，但它们用于构建一些URL。例如，队列URL中使用了<code class="fe nu nv nw nx b">accountId</code>，因此使用此设置的<code class="fe nu nv nw nx b">default </code>队列的最终URL将是:<code class="fe nu nv nw nx b"><a class="ae kv" href="http://broker:9324/000000000000/default." rel="noopener ugc nofollow" target="_blank">http://broker:9324/000000000000/default</a></code></p><p id="e7ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于这些设置的更多细节，请查阅<a class="ae kv" href="https://github.com/softwaremill/elasticmq#installation-stand-alone" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><h2 id="07ad" class="mp lt iq bd lu mq mr dn ly ms mt dp mc lf mu mv me lj mw mx mg ln my mz mi na bi translated"><strong class="ak">监控</strong></h2><p id="e9b1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">只需打开浏览器并导航至<code class="fe nu nv nw nx b"><a class="ae kv" href="http://broker:9324/000000000000/default." rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:9325</a></code></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/229c2955ebcd777e017b6cad569ed468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzKcpi2DOy0FH55EcFsdcg.png"/></div></div></figure><h1 id="accd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">下一步是什么？</h1><p id="4d68" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">是时候规模化了！查看如何<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/design-an-auto-scalable-architecture-for-your-django-apps-in-aws-850ca5ec63a1">在AWS </a>中为您的Django应用程序设计一个可自动扩展的架构。</p><p id="e059" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>