<html>
<head>
<title>Using the Diesel ORM for a Web App With Rocket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Diesel ORM用于Rocket应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-the-diesel-orm-for-a-web-app-with-rocket-90e610f6a6cf?source=collection_archive---------7-----------------------#2022-05-11">https://betterprogramming.pub/using-the-diesel-orm-for-a-web-app-with-rocket-90e610f6a6cf?source=collection_archive---------7-----------------------#2022-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fbdb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">向Rust powered框架添加数据库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/63397820e3b0a9b13700a6fefb298ed1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fttqmqpq6DKNX7nJlAGgPw.png"/></div></div></figure><p id="4879" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我之前的一个故事中(见这里的<a class="ae lq" href="https://applied-math-coding.medium.com/implementing-a-web-app-with-rocket-5e56c7e484a0" rel="noopener"/>)，我们看到了一个使用<a class="ae lq" href="https://rocket.rs/" rel="noopener ugc nofollow" target="_blank"> Rocket framework </a>实现小型web应用的例子。</p><p id="423f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个web应用程序托管了客户端应用程序的资产，并提供了一个小的API。现在，我们将通过添加一个数据库(<a class="ae lq" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>)和名为<a class="ae lq" href="https://diesel.rs/" rel="noopener ugc nofollow" target="_blank"> Diesel </a>的ORM来扩展它。此外，我们将研究如何通过docker-compose将所有这些捆绑在一起，作为一个可共享的web应用程序。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="c3db" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">总体目标:</h2><p id="3ae0" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们在这里总结一下我们计划添加应用程序的哪些部分。请记住，到目前为止，我们的应用程序提供了一个端点，允许计算一组给定点的凸包。</p><p id="9cb5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们补充以下内容:</p><ol class=""><li id="495e" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">允许保存来自上述端点的结果</li><li id="cef9" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">允许<code class="fe nk nl nm nn b">GET</code>所有结果，以便在用户界面上列出它们</li><li id="72e8" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">允许到<code class="fe nk nl nm nn b">DELETE</code>结果</li><li id="369d" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">允许给<code class="fe nk nl nm nn b">UPDATE</code>一个结果的显示名称</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="db03" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">设置</h1><p id="0c7f" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">当然，在开发这个时，一个有用的东西是在后台运行一个PostgreSQL DB。您不需要在系统上本地安装任何软件，只需使用一个已配置的docker映像:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="effa" class="ly lz it nn b gy od oe l of og">docker pull postgres:14.2</span><span id="79b9" class="ly lz it nn b gy oh oe l of og">docker run --name postgres -e POSTGRES_PASSWORD=mysecretpassword POSTGRES_USER=convexhull -p 5432:5432 -d postgres:14.2</span></pre><p id="e18f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用14.2以外的任何版本，甚至可以将这个术语保留为默认的<code class="fe nk nl nm nn b">:latest</code>。</p><p id="6c1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面用用户<code class="fe nk nl nm nn b">convexhull</code>和密码<code class="fe nk nl nm nn b">mysecretpassword</code>创建了一个名为<code class="fe nk nl nm nn b">convexhull</code>的PostgreSQL数据库。它在端口<code class="fe nk nl nm nn b">5432</code>运行，该端口被映射到某个本地端口。</p><p id="287b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Diesel ORM附带了一个CLI，我建议将其安装在本地。为此，您可能首先需要在您的系统上安装以下PostgreSQL客户端:<code class="fe nk nl nm nn b">libpq-dev</code></p><p id="cf08" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，您可以使用<code class="fe nk nl nm nn b">cargo</code>安装CLI:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="9ca9" class="ly lz it nn b gy od oe l of og">cargo install diesel_cli --no-default-features --features postgres</span></pre><p id="2d9e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有了所有这些，从项目文件夹中您可以运行</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="1ea9" class="ly lz it nn b gy od oe l of og">diesel setup</span></pre><p id="0cae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将一个文件<code class="fe nk nl nm nn b">diesel.toml</code>和一个迁移文件夹放到我们的项目中。迁移文件夹包含两个文件，<code class="fe nk nl nm nn b">up.sql</code>和<code class="fe nk nl nm nn b">down.sql</code>。这些文件用于将数据库从一个版本迁移到另一个版本，或者反向迁移。所以，总的约定是，所有产生<code class="fe nk nl nm nn b">up.sql</code>的东西都要还原到<code class="fe nk nl nm nn b">down.sql</code>里。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="3c8e" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">SQL模式</h1><p id="6fb5" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">每个在大型项目中管理过数据库的人都知道，这一切都是为了创建好的SQL模式，尽可能少地使用必要的索引。我们的模式将保持较小，以讲授Diesel背后的原理。首先，我们将告诉Diesel为我们的模式生成迁移文件:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="7cdb" class="ly lz it nn b gy od oe l of og">diesel migrate generate convex_hulls</span></pre><p id="8480" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在文件夹<code class="fe nk nl nm nn b">migrations/XXX_convex_hulls</code>中生成相应的预定<code class="fe nk nl nm nn b">up/down.sql</code>文件。我们将向<code class="fe nk nl nm nn b">up.sql</code>添加以下数据定义:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="4cfe" class="ly lz it nn b gy od oe l of og">CREATE TABLE convex_hulls (<br/>    "id" INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,<br/>    "name" TEXT,<br/>    "created" TIMESTAMP NOT NULL    <br/>);</span><span id="d2e8" class="ly lz it nn b gy oh oe l of og">CREATE TABLE points(<br/>    "id" INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,<br/>    "input" JSON NOT NULL, <br/>    "output" JSON NOT NULL,<br/>    "convex_hull_id" INTEGER NOT NULL REFERENCES convex_hulls ON DELETE CASCADE<br/>);</span></pre><p id="40c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并且到<code class="fe nk nl nm nn b">down.sql</code>:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="2ea4" class="ly lz it nn b gy od oe l of og">DROP TABLE IF EXISTS points;<br/>DROP TABLE IF EXISTS convex_hulls;</span></pre><p id="13dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，一个<code class="fe nk nl nm nn b">ConvexHull</code>可能有一个<code class="fe nk nl nm nn b">Point</code>与之相关联。</p><p id="0eed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以通过键入以下命令来指示Diesel运行迁移:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="4459" class="ly lz it nn b gy od oe l of og">diesel migration run</span></pre><p id="1b1e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并通过以下方式重做(以防万一):</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="5973" class="ly lz it nn b gy od oe l of og">diesel migration redo</span></pre><p id="6720" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在开发过程中，您会发现每次更改数据模型时都在使用后一种注释。与此同时，一个名为<code class="fe nk nl nm nn b">schema.rs</code>的文件保持最新状态。正在被创造出来。值得看一看这个文件，以了解迁移脚本是否会产生预期的映射。这里定义的资源旨在从代码中提供对表名、列等的引用。因此，这样的名字永远不会被硬编码，并且被编译器保护起来防止输入错误！</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="7013" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">在应用程序中使用Diesel</h1><p id="1d8f" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">为了使用Diesel，我们首先必须将以下依赖项添加到我们的<code class="fe nk nl nm nn b">Cargo.toml</code>中:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="402a" class="ly lz it nn b gy od oe l of og">[dependencies]<br/>serde = { version = "1.0.136", features = ["derive"] }<br/>rocket = { version = "0.5.0-rc.1", features= ["json"] }<br/><strong class="nn iu">diesel = { version = "1.4.4", features = ["postgres", "serde_json"] }<br/>serde_json = { version = "1.0.48", features = ["preserve_order"]}<br/>dotenv = "0.15.0"<br/>diesel_migrations = "1.4.0"</strong></span></pre><p id="71b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们需要创建一个包含以下内容的<code class="fe nk nl nm nn b">.env</code>文件:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="da76" class="ly lz it nn b gy od oe l of og">DB_HOST=localhost</span><span id="6428" class="ly lz it nn b gy oh oe l of og">POSTGRES_PASSWORD=mysecretpassword</span><span id="a3f6" class="ly lz it nn b gy oh oe l of og">POSTGRES_USER=convexhull</span><span id="0da4" class="ly lz it nn b gy oh oe l of og">DATABASE_URL=postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${DB_HOST}/convexhull</span></pre><p id="eb7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Diesel在启动应用程序时加载这些值，并使用上面的特定条目连接到我们的数据库。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e70d" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">添加CRUD端点</h1><p id="4e2d" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们将要添加到Rocket服务器的端点将如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="f1af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">鉴于我们在之前的相关<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/implementing-a-web-app-with-rocket-5e56c7e484a0">文章</a>中提供的解释，这并不新鲜。</p><p id="7328" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通常，所有这些端点都必须注册为路由:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="e000" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，端点利用了文件<code class="fe nk nl nm nn b">models.rs</code>中声明的资源类型，并委托给<code class="fe nk nl nm nn b">convex_hull_service</code>提供的方法。这两个问题都将在接下来解决。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="e2ba" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">添加数据库实体</h1><p id="27f1" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">数据库实体在<code class="fe nk nl nm nn b">models.rs</code>中定义，内容如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="9cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再来一点。</p><p id="7935" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，对于<code class="fe nk nl nm nn b">ConvexHull</code>和<code class="fe nk nl nm nn b">Point</code>都存在一个对应的<code class="fe nk nl nm nn b">NewConvexHull</code> resp。<code class="fe nk nl nm nn b">NewPoint</code>结构。这些在类型定义中略有延迟，用于存储新的实例。而且，前者衍生出<code class="fe nk nl nm nn b">Queryable</code>，后者衍生出<code class="fe nk nl nm nn b">Insertable</code>。这允许使用这些实体分别检索数据。插入数据。除此之外，我们通过使用<code class="fe nk nl nm nn b">#[table_name = ...]</code>宏将相应的表名映射到实体。</p><p id="ee86" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其次，结构中使用的类型必须与我们在迁移文件<code class="fe nk nl nm nn b">up.sql</code>中使用的类型相匹配。从SQL到Rust的类型映射列表以及Diesel执行的反向映射可以在<a class="ae lq" href="https://docs.rs/diesel/latest/diesel/sql_types/index.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="9d18" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">记住，表<code class="fe nk nl nm nn b">points</code>有一个到表<code class="fe nk nl nm nn b">convex_hulls</code>的外键，它是一对一的对应关系。我们必须用合适的关联映射来反映这一点。为此，Diesel提供了两个特性，即<code class="fe nk nl nm nn b">Associations</code>和<code class="fe nk nl nm nn b">Identifiable</code>。第一个总是位于持有外键的一侧。后者位于外键指向的站点上。</p><p id="9a14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们将在端点中直接使用这些实体，所以我们从<code class="fe nk nl nm nn b">serde</code>中派生出了<code class="fe nk nl nm nn b">Serialize</code>和<code class="fe nk nl nm nn b">Deserialize</code>特征。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="99bc" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">添加业务层</h1><p id="3fff" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">CRUD端点委托的所有方法将在<code class="fe nk nl nm nn b">convex_hull_service.rs</code>中定义。</p><p id="3ed8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些方法需要建立到数据库的连接。为此，以下方法已写入文件<code class="fe nk nl nm nn b">db.rs</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="429c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">显然，这是使用在<code class="fe nk nl nm nn b">.env</code>中提供的<code class="fe nk nl nm nn b">DATABASE_URL</code>的值来连接数据库。</p><p id="dac5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b">convex_hull_service.rs</code>的内容是这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oi oj l"/></div></figure><p id="a11d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们先从简单的开始。</p><p id="e9b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b"><strong class="kw iu">get_convex_hulls</strong></code>:这只是从<code class="fe nk nl nm nn b">convex_hull</code>的<code class="fe nk nl nm nn b">table</code>结构中调用方法<code class="fe nk nl nm nn b">load</code>，并提供对一个连接<code class="fe nk nl nm nn b">convex_hulls::table.load(&amp;connection)</code>的引用。</p><p id="a4c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b"><strong class="kw iu">delete_convex_hull</strong></code>:这里我们通过传递对应的数据库实体来调用方法<code class="fe nk nl nm nn b">diese::delete</code>。后者通过在<code class="fe nk nl nm nn b">convex_hulls</code>的<code class="fe nk nl nm nn b">table</code> : <code class="fe nk nl nm nn b">diesel::delete(convex_hulls::table.find(...)</code>上使用<code class="fe nk nl nm nn b">find</code>的方法获得。</p><p id="8295" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b"><strong class="kw iu">get_points</strong></code>:首先我们通过<code class="fe nk nl nm nn b">id</code>即<code class="fe nk nl nm nn b">convex_hulls::table.find(...)</code>获取<code class="fe nk nl nm nn b">ConvexHull</code>实体，然后我们利用这些表之间的父子关系获取相关的<code class="fe nk nl nm nn b">Point</code>实体:<code class="fe nk nl nm nn b">Point::belonging_to(&amp;convex_hull).first(&amp;connection)</code>。</p><p id="b75c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b"><strong class="kw iu">update_convex_hull</strong></code>:我们使用<code class="fe nk nl nm nn b">diesel::update</code>的方法获得<code class="fe nk nl nm nn b">ConvexHull</code>提供的实体，并通过<code class="fe nk nl nm nn b">.set(convex_hulls::columns::name.eq(convex_hull.name))</code>更新相应的字段。值得注意的是，Diesel对每一列(这里是<code class="fe nk nl nm nn b">name</code>)都有一个描述符，可以从<code class="fe nk nl nm nn b">convex_hulls</code>的<code class="fe nk nl nm nn b">columns</code>结构中获得。</p><p id="bf03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nk nl nm nn b">create_convex_hull</code>:这个要求我们把操作放在一个事务中。原因是亲子关系。为了给一个<code class="fe nk nl nm nn b">ConvexHull</code>创建<code class="fe nk nl nm nn b">Point</code>，后者必须首先被插入到数据库中，因为前者需要它的<code class="fe nk nl nm nn b">id</code>。该交易是通过以下方式从<code class="fe nk nl nm nn b">connection</code>获得的</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="d6f4" class="ly lz it nn b gy od oe l of og">connection.transaction::&lt;(ConvexHull, Point), Error, _&gt;(|| { … })</span></pre><p id="bc81" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">并确保在任何插入失败的情况下，所有的更改都得到回滚。在<code class="fe nk nl nm nn b">transaction</code>内部我们使用以下方法插入相应的实体:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="4546" class="ly lz it nn b gy od oe l of og">diesel::insert_into(convex_hulls::table).values(&amp;new_convex_hull)</span></pre><p id="2c6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，<code class="fe nk nl nm nn b">insert_into</code>期望目标表(此处为<code class="fe nk nl nm nn b">convex_hulls::table</code>)作为参数，并进一步插入实体(此处为<code class="fe nk nl nm nn b">new_convex_hull</code>)。注意，后者是类型<code class="fe nk nl nm nn b">NewConvexHull</code>，它派生了<code class="fe nk nl nm nn b">Insertable</code>特征。</p><p id="b90d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于如何从父子层次结构中获取实体的更多信息，你可以在这里找到<a class="ae lq" href="https://docs.diesel.rs/diesel/associations/index.html" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="857f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">需要注意的一点是，Diesel是分开处理相关的表，而不是有一个所谓的反向关系的概念。例如，我们在表<code class="fe nk nl nm nn b">convex_hulls</code>和<code class="fe nk nl nm nn b">points</code>之间的1-1对应关系仅仅通过在结构<code class="fe nk nl nm nn b">Point</code>上有一个<code class="fe nk nl nm nn b">convex_hulls_id</code>来反映。在Diesel中，反映这种关系的类型是元组<code class="fe nk nl nm nn b">(ConvexHull, Point)</code>。尽管这是一个非常符合逻辑的概念，但在某些情况下，这可能会导致代码变得繁琐。</p><p id="6fb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能会注意到对<code class="fe nk nl nm nn b">db::create_connection()</code>的重复调用。对于介绍来说，这已经足够了，但是在生产代码中，您应该从托管池中获取连接。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6c13" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">扩展前端</h1><p id="0cdf" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">由于这篇文章不是关于前端的，所以我不会在这里给出很多细节。请记住，Rocket服务器是托管前端资产的，是用Vite构建的Vue应用程序的产品。静态资产的路径注册已在之前的<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/implementing-a-web-app-with-rocket-5e56c7e484a0">文章</a>中描述。本质上，客户端现在将适应利用所有提供的CRUD端点，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/caf9addb9e0060527a3f517d80f8610f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E1p8_TXc7iL7MesI-PaQgg.png"/></div></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="64e2" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">创建docker合成文件</h1><p id="8e6c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">到目前为止，我们有一个服务器，它提供了几个端点并托管前端资产。此外，我们有一个数据库支持持久化我们的一些实体。Docker有一个名为<code class="fe nk nl nm nn b">docker-compose</code>的神奇工具，可以将所有这些捆绑在一起，并使其可共享，尽管涉及到多个服务器，即多个docker映像。</p><p id="9487" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Docker-compose是Docker引擎的附加物，你必须单独安装它(见<a class="ae lq" href="https://docs.docker.com/compose/install/" rel="noopener ugc nofollow" target="_blank">此处</a>)。我们在项目中添加了一个名为<code class="fe nk nl nm nn b">docker-compose.yml</code>的文件，用来描述应用程序的所有组件(服务器)。其内容是这样的:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="1432" class="ly lz it nn b gy od oe l of og">version: "3"<br/>services:<br/>  <strong class="nn iu">web:</strong><br/>    build: .<br/>    ports:<br/>      - "8000:8000"<br/>    environment:<br/>      - DB_HOST=db<br/>    depends_on:<br/>      - "db"<br/>    command: ["./wait-for-it.sh", "db:5432", "--", "./target/release/convex-hull"]<br/>  <strong class="nn iu">db:</strong><br/>    image: postgres:14.2<br/>    environment:<br/>      - POSTGRES_PASSWORD=mysecretpassword<br/>      - POSTGRES_USER=convexhull</span></pre><p id="9381" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们有两个服务，一个叫做<code class="fe nk nl nm nn b">web</code>，它的构建在本地<code class="fe nk nl nm nn b">Dockerfile</code>中描述，另一个叫做<code class="fe nk nl nm nn b">db</code>。后者不是一个<code class="fe nk nl nm nn b">build</code>而是指一个<code class="fe nk nl nm nn b">image</code>。每个服务将在它自己的进程中运行，我们可以给它附加<code class="fe nk nl nm nn b">environment</code>变量。此外，这对我们来说非常重要，服务<code class="fe nk nl nm nn b">web</code>(火箭服务器)，依赖于数据库准备好接受请求。为此，我们做了两件事:</p><ol class=""><li id="0e04" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">我们使用<code class="fe nk nl nm nn b">depends_on</code>来告诉服务<code class="fe nk nl nm nn b">web</code>在构建级别上依赖于服务<code class="fe nk nl nm nn b">db</code>。也就是前者在后者准备好之前还没入门。</li><li id="8227" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">服务<code class="fe nk nl nm nn b">web</code>有一个<code class="fe nk nl nm nn b">command</code>，它在<code class="fe nk nl nm nn b">CMD</code>内覆盖<code class="fe nk nl nm nn b">Dockerfile</code>中的所有内容。这个<code class="fe nk nl nm nn b">command</code>在构建完成后执行。<code class="fe nk nl nm nn b">wait-fot-it</code>是一个实用函数，它等待主机<code class="fe nk nl nm nn b">db</code>在端口<code class="fe nk nl nm nn b">5432</code>接受请求。只有这样，它才继续执行第二部分，即启动Rocker实例。</li></ol><p id="b613" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过键入以下命令来构建和启动docker-compose实例:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="d9e2" class="ly lz it nn b gy od oe l of og">docker-compose up</span></pre><p id="8c4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将在当前终端中运行容器，您可以像往常一样停止它。</p><p id="4f41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">关于数据库迁移，我要说的最后一点是。数据库启动。这不会包含所有必要的表定义。因此，有必要告诉Diesel在服务器启动时进行所有必要的迁移。</p><p id="a40e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在原始代码中，您会发现启动Rocket的实际调用包装如下:</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="ee52" class="ly lz it nn b gy od oe l of og">match <strong class="nn iu">embedded_migrations::run</strong>(&amp;db::create_connection()) {<br/>        Ok(_) =&gt; rocket::build()...<br/>    ...<br/>}</span></pre><p id="9fa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此<code class="fe nk nl nm nn b">embedded_migrations</code>是从机箱<code class="fe nk nl nm nn b">diesel_migrations</code>执行宏<code class="fe nk nl nm nn b">embed_migrations!();</code>后变为可用的模块。它确保数据库相对于文件夹<code class="fe nk nl nm nn b">migration</code>中定义的所有迁移保持最新。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8367" class="no lz it bd ma np nq nr md ns nt nu mg jz nv ka mj kc nw kd mm kf nx kg mp ny bi translated">运行代码</h1><p id="db7b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">要获得完整的代码，你可以做如下(需要:git，docker，docker-compose):</p><pre class="kj kk kl km gt nz nn oa ob aw oc bi"><span id="f1b1" class="ly lz it nn b gy od oe l of og">git clone <a class="ae lq" href="https://github.com/applied-math-coding/convex-hull.git" rel="noopener ugc nofollow" target="_blank">https://github.com/applied-math-coding/convex-hull.git</a></span><span id="354c" class="ly lz it nn b gy oh oe l of og">git checkout v2.0     // brings you to the correct version</span><span id="879d" class="ly lz it nn b gy oh oe l of og">docker-compose up     // builds and runs the app</span><span id="8e2c" class="ly lz it nn b gy oh oe l of og">// then you can got to http://localhost:8000</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><p id="1ecb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不得不承认这是非常多的。但这与Diesel或Rocket无关，而是与我们已经构建了一个完整的web应用程序的情况有关。</p><p id="2e3c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后要注意的是。虽然，以上所有内容读起来很容易，但并不像看起来那么简单。特别是在处理关联的时候，有很多东西要保证契合在一起。同样，这不是Diesel特有的情况，而是所有ORM都会遇到的情况。</p><p id="d490" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然在Rocket上使用Diesel会产生一个非常高性能和安全的应用程序，但是对于更大的应用程序来说，遵守类型系统可能会很麻烦。因此，在我的下一篇文章中，我们将最后再看一种方法。</p><p id="2a05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读！</p></div></div>    
</body>
</html>