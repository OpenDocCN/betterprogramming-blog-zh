<html>
<head>
<title>Convert Your Class Component to a Functional One With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩将您的类组件转换为功能性组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/convert-your-class-component-to-a-functional-one-with-react-hooks-ab5f4d11f9bc?source=collection_archive---------7-----------------------#2019-12-18">https://betterprogramming.pub/convert-your-class-component-to-a-functional-one-with-react-hooks-ab5f4d11f9bc?source=collection_archive---------7-----------------------#2019-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ecb6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建精益、平均的组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/092eb7b1ab2dd775c48eab00dc5a4c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*htAZPYyhEjkTJ1pmag13IQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://cdn-media-1.freecodecamp.org/images/1*0MgGEfZfLO91g1Oa2h3ebQ@2x.png" rel="noopener ugc nofollow" target="_blank">免费代码营</a></p></figure><p id="8f56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>是React 16.8中一个有效的附加功能，允许你在功能组件中使用状态。这有助于保持组件的精简和更好的性能，同时仍然允许本地状态实现的灵活性。</p><p id="62dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这篇文章中，我将带您经历一个无痛的过程，将我的一个类组件转换成一个功能组件，而不影响我的状态需求。</p><p id="3208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将转换我的<code class="fe lv lw lx ly b">View</code>组件，它是我更大的React编辑器应用程序的一部分。如果你看过我的上一篇帖子，<a class="ae ky" href="https://medium.com/better-programming/how-to-implement-dark-mode-in-your-react-app-63c1a0c5e337" rel="noopener"> <em class="lz">如何在你的React App </em> </a>中实现黑暗模式，你就知道我指的是什么了。</p><p id="f3e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您还没有(您应该这样做)，我的React编辑器是一个在线文本编辑器，它允许用户输入HTML、CSS和JavaScript，然后编译所有代码并在<code class="fe lv lw lx ly b">View</code>中生成渲染结果。</p><p id="2d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">渲染结果如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/169d3cbc8b1618f5f0bcfe2a406cdc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tI0C2-1nq9sh40dxal_83A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">视图组件是带有红色和蓝色文本的底部部分。</p></figure><p id="a446" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我的应用程序样式不会干扰<code class="fe lv lw lx ly b">View</code>中的样式。</p><p id="dc54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为我使用React的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://www.npmjs.com/package/react-iframe" rel="noopener ugc nofollow" target="_blank">Iframe</a></code>组件将用户提供的所有代码与我用于应用程序其余部分的代码隔离开来。下面是我的类组件，在切换到钩子之前。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5f1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我有一个状态值，<code class="fe lv lw lx ly b">compiled</code>，它是编译后的HTML、CSS和JavaScript，将被插入到一个<code class="fe lv lw lx ly b">Iframe</code>组件中。</p><p id="78f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我需要使用<code class="fe lv lw lx ly b">componentDidUpdate</code>,因为每当<code class="fe lv lw lx ly b">this.props.compiled</code>更新时，我都需要调用它:</p><pre class="kj kk kl km gt md ly me mf aw mg bi"><span id="9822" class="mh mi it ly b gy mj mk l ml mm">x.contentDocument.open()         <br/>x.contentDocument.close()<br/>x.contentDocument.write(this.state.compiled)</span></pre><p id="b1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以便<code class="fe lv lw lx ly b">Iframe</code>反映最新的编译数据。我不一定需要将<code class="fe lv lw lx ly b">compiled</code>添加到state中，但是出于演示的目的，我决定将它包含在内。</p><p id="0908" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们清理代码，将组件转换成使用钩子。</p><p id="1e14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们来关注一下国家。</p><pre class="kj kk kl km gt md ly me mf aw mg bi"><span id="5178" class="mh mi it ly b gy mj mk l ml mm">state = {        <br/>   compiled: ''<br/>}</span></pre><p id="2fd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码可以被重写来使用我们的第一个钩子，叫做<code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">useState</a></code>。</p><h2 id="102a" class="mh mi it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">使用状态</h2><p id="8714" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated">我们可以用<code class="fe lv lw lx ly b">useState</code>重写上面的代码。见下文。</p><pre class="kj kk kl km gt md ly me mf aw mg bi"><span id="bf11" class="mh mi it ly b gy mj mk l ml mm">const [compiled, setCompiled] = useState('');</span></pre><p id="6680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们来分析一下。</p><p id="69b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到我们有自己的状态值，<code class="fe lv lw lx ly b">compiled</code>。然后，你可以在数组中看到额外的<code class="fe lv lw lx ly b">setCompiled</code>。这将是用于更新<code class="fe lv lw lx ly b">compiled</code>的函数。</p><p id="2e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想设置<code class="fe lv lw lx ly b">compiled</code>为<code class="fe lv lw lx ly b">'&lt;h1&gt;hello&lt;/h1&gt;'</code>，你可以写<code class="fe lv lw lx ly b">setCompiled('&lt;h1&gt;hello&lt;/h1&gt;')</code>而不是调用<code class="fe lv lw lx ly b">this.setState({compiled:'&lt;h1&gt;hello&lt;/h1&gt;'})</code>。</p><p id="79d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们传递给<code class="fe lv lw lx ly b">useState</code>的参数表示我们希望我们的值具有的初始值。<code class="fe lv lw lx ly b">compiled</code>应该是空字符串。</p><p id="7b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们将重点关注替换生命周期方法，<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentDidUpdate</code>。这些对于类组件来说是有用的方法，但是对于函数组件来说是不可用的…直到现在(某种程度上)。</p><h2 id="c75c" class="mh mi it bd mn mo mp dn mq mr ms dp mt li mu mv mw lm mx my mz lq na nb nc nd bi translated">使用效果</h2><p id="2333" class="pw-post-body-paragraph kz la it lb b lc ne ju le lf nf jx lh li ng lk ll lm nh lo lp lq ni ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>挂钩允许您在功能组件中执行副作用。</p><p id="4fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些副作用是由组件响应某种变化(如状态变化、API请求等)而重新呈现所造成的影响。</p><p id="9223" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您有一个名为<code class="fe lv lw lx ly b">time</code>的状态值，一个时钟组件的指针移动以反映该值的副作用，<code class="fe lv lw lx ly b">this.state.time</code>可能是一个记录/发送时间数据的函数的执行。</p><p id="0cb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这与我们的类组件有什么关系？</p><p id="595e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您查看我们以前的组件生命周期方法，您可能已经注意到代码有点多余。我们正在尝试执行<code class="fe lv lw lx ly b">contentDocument</code>方法，以便在<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentDidUpdate</code>中将<code class="fe lv lw lx ly b">Iframe</code>内容设置为等于<code class="fe lv lw lx ly b">this.props.compiled</code>或<code class="fe lv lw lx ly b">this.state.compiled</code>。</p><p id="4022" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以抽象出<code class="fe lv lw lx ly b">contentDocument</code>功能，然后在需要的时候在<code class="fe lv lw lx ly b">componentDidMount</code>和<code class="fe lv lw lx ly b">componentDidUpdate</code>中调用这个助手函数。</p><p id="2671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以减少代码的味道，但关键是我们仍然必须在两种生命周期方法中使用相同的功能。虽然我们希望这样做是有道理的，但是<code class="fe lv lw lx ly b">useEffect</code>可以帮助我们用一个钩子完成这两项任务。</p><blockquote class="nj"><p id="a16a" class="nk nl it bd nm nn no np nq nr ns lu dk translated">"如果你熟悉React类生命周期方法，你可以把<code class="fe lv lw lx ly b">useEffect</code>钩子看作是<code class="fe lv lw lx ly b">componentDidMount</code>、<code class="fe lv lw lx ly b">componentDidUpdate</code>和<code class="fe lv lw lx ly b">componentWillUnmount</code>的组合."— <a class="ae ky" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">反应文件</a></p></blockquote><p id="3b45" class="pw-post-body-paragraph kz la it lb b lc nt ju le lf nu jx lh li nv lk ll lm nw lo lp lq nx ls lt lu im bi translated"><code class="fe lv lw lx ly b">useEffect</code>的工作方式是在组件第一次挂载和重新渲染时执行功能。</p><p id="2b37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，从render设置状态是不明智的，可能会导致错误。</p><p id="0d20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">useEffect</code>，当组件挂载/重新渲染时，我们可以执行更新状态值所需的功能，而不会产生任何问题。见下文。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9154" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们运行<code class="fe lv lw lx ly b">setCompiled</code>并传递它<code class="fe lv lw lx ly b">props.compiled</code>，因为我们想将<code class="fe lv lw lx ly b">compiled</code>的状态值设置为等于传递的<code class="fe lv lw lx ly b">compiled</code>属性。然后，我们运行我们的<code class="fe lv lw lx ly b">contentDocument</code>方法来重写<code class="fe lv lw lx ly b">Iframe</code>内容，以反映新的<code class="fe lv lw lx ly b">compiled</code>值。</p><p id="7ecf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想知道如何控制<code class="fe lv lw lx ly b">useEffect</code>何时执行，只需看看最后的参数<code class="fe lv lw lx ly b">[props.compiled, compiled]</code>即可。通过传递这些参数，<code class="fe lv lw lx ly b">useEffect</code>将把<code class="fe lv lw lx ly b">props.compiled</code>的当前值与最近一次重新渲染前<code class="fe lv lw lx ly b">compiled</code>的状态值进行比较。</p><p id="a688" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果相同，无需重新渲染。否则，重新渲染，然后再次比较这些值。你可以把它想成类似于<code class="fe lv lw lx ly b">componentDidUpdate</code>里有的<code class="fe lv lw lx ly b">prevProps</code>和<code class="fe lv lw lx ly b">this.props</code>。</p><p id="1a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们的类到功能组件转换的最终结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="bed3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过实现React钩子，我们能够将我们的类组件转换成一个函数组件，这导致了更多可读的代码，更少的冗余，并且潜在地从我们的组件中获得更多的<a class="ae ky" href="https://medium.com/better-programming/rundown-of-the-most-important-react-hooks-5c9ec4cac5a2" rel="noopener">最佳性能</a>。</p></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="d108" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在此  <em class="lz">将您的免费媒体会员升级为付费会员，每月只需5美元，您就可以收到来自各种出版物上数千名作家的无限量无广告故事。这是一个附属链接，你的会员资格的一部分帮助我为我创造的内容获得奖励。谢谢大家！</em></p><h1 id="14fe" class="of mi it bd mn og oh oi mq oj ok ol mt jz om ka mw kc on kd mz kf oo kg nc op bi translated">参考</h1><div class="oq or gp gr os ot"><a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">介绍钩子-反应</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。这个…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">reactjs.org</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/how-to-implement-dark-mode-in-your-react-app-63c1a0c5e337" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">如何在你的React应用中实现黑暗模式</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">让用户的眼睛休息一下</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://www.npmjs.com/package/react-iframe" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">react-iframe</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">包含iframed页面的简单React组件。该组件完全受typescript支持。所有其他属性…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">www.npmjs.com</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://reactjs.org/docs/hooks-state.html" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">使用状态钩子-反应</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">reactjs.org</p></div></div><div class="pc l"><div class="pk l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://reactjs.org/docs/hooks-effect.html" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">使用效果钩-反应</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">reactjs.org</p></div></div><div class="pc l"><div class="pl l pe pf pg pc ph ks ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/rundown-of-the-most-important-react-hooks-5c9ec4cac5a2" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">最重要的反应挂钩的概述</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">比较功能组件和基于类的组件的速度和性能</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pm l pe pf pg pc ph ks ot"/></div></div></a></div></div></div>    
</body>
</html>