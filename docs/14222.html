<html>
<head>
<title>How to Build a Game for the Playdate Console Using the Playdate SDK and Lua</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Playdate SDK和Lua为Playdate主机构建游戏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-build-a-game-for-the-playdate-console-using-the-playdate-sdk-and-lua-cc8fd2079433?source=collection_archive---------2-----------------------#2022-11-18">https://betterprogramming.pub/how-to-build-a-game-for-the-playdate-console-using-the-playdate-sdk-and-lua-cc8fd2079433?source=collection_archive---------2-----------------------#2022-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c3ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">建立一个守门员游戏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/460284782beebf2617ce4700169ba471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTeq1-VFYbZ5tmgSHaf_mA.png"/></div></div></figure><p id="cedc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不久前，Panic和青少年工程公司发布了他们的新独立游戏机:Playdate。</p><p id="9bf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个可爱有趣的小设备，有一个1位屏幕，经典的设计和…一个曲柄。是的，一个怪人。</p><p id="561f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不用说，这个随机但可爱的设备真的激起了我的兴趣。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="99b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，当我最终收到邮寄过来的游戏机时，我决定试着为它制作一个游戏。我喜欢足球(对你们来说是隔着池塘的足球)——所以我心目中的比赛是一场守门员必须挽救射门的比赛。</p><p id="1c62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">经过大约三个周末的修补和一些抓到你的时刻，我终于发布了我的游戏。如果你想尝试一下，你可以在这里免费下载。</p><p id="e023" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我开发这个游戏的时候，有几次我想“我真希望有人制作了关于如何做这个的教程”。所以这就是我在这一系列文章中要尝试做的事情。我将解释我是如何制作我的游戏的，希望它也能帮助其他人理解如何为游戏日制作他们的游戏。</p><blockquote class="lt lu lv"><p id="8a2f" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated"><em class="it">大声喊出来:当我试图理解PlayDate开发过程的不同部分时，SquidGodDev的视频给了我很大的帮助，如果没有他们，我可能不会这么快做出这个游戏。我想链接到他们的</em> <a class="ae ls" href="https://www.youtube.com/c/SquidGodDev" rel="noopener ugc nofollow" target="_blank"> <em class="it"> YouTube </em> </a> <em class="it">和</em><a class="ae ls" href="https://www.patreon.com/squidgoddev" rel="noopener ugc nofollow" target="_blank"><em class="it">Patreon</em></a><em class="it">作为一点感谢！</em></p></blockquote><p id="6785" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始之前，我想设定一些关于本教程的期望。它将:</p><ul class=""><li id="345a" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">向你展示如何为游戏日制作游戏，</li><li id="3924" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">链接到一些有用的资源，在设计和开发过程中为您提供帮助，</li><li id="9abf" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">给出Playdate SDK的实际例子。</li></ul><p id="22c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，本文不打算:</p><ul class=""><li id="1cde" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">教你如何编码，假设你有基本的编程知识(不过我会链接到其他人的有用教程)，或者</li><li id="043f" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">教你如何设计(但我会链接到创建这个游戏所需的有用的设计资源，加上我现有的图形和教程创建自己的图形的Figma模板)</li></ul><p id="b046" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将讨论游戏开发的不同领域。以下是对预期结果的分析:</p><ul class=""><li id="a6fd" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">帮助你使用Lua和Playdate SDK的最佳资源</li><li id="e503" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">计划建造什么</li><li id="3bb9" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">文件结构</li><li id="e1ae" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">设计游戏</li><li id="c89f" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">为什么我们要使用面向对象编程(OOP)</li><li id="63d6" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">创建游戏场景</li><li id="33c9" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">在场景中前进</li><li id="7a27" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">开发可以在屏幕上移动的播放器</li><li id="9338" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">发展你必须防守的球</li><li id="ee01" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">发展你作为守门员必须保护的目标</li><li id="ec83" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">冲突检出</li><li id="04e6" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">应对碰撞</li><li id="0ffc" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">记录玩家的分数</li><li id="721f" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">从游戏日期的存储器中保存、存储和加载高分</li><li id="73a9" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">在屏幕上显示分数和高分</li><li id="8984" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">为游戏开发电源</li><li id="d471" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">不同事件发生时播放音频</li><li id="ba21" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">基于游戏性改变音频的速率(速度)</li><li id="f723" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">让你的游戏准备好发布</li><li id="b075" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">与世界分享你的游戏</li></ul><h1 id="a189" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">开始时的最佳资源</h1><p id="773f" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">要为游戏日开发游戏，你需要学习Lua或c。Lua是两者中比较简单的，这也是我们在本教程中要用到的。以下是我精选的一些资源，用于学习Lua的基础知识，设置Playdate SDK，以及Playdate的基本编程:</p><ul class=""><li id="2da5" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated"><a class="ae ls" href="https://www.youtube.com/watch?v=jUuqBZwwkQw" rel="noopener ugc nofollow" target="_blank">100秒内Lua</a></li><li id="4a3e" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><a class="ae ls" href="https://www.youtube.com/watch?v=7Oxh7MJAd5k" rel="noopener ugc nofollow" target="_blank">【LUA】Ep。5 —表格</a></li><li id="45ae" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><a class="ae ls" href="https://www.youtube.com/watch?v=C4o7n0LNQhA" rel="noopener ugc nofollow" target="_blank">学会为Playdate游戏开发编程！第一部分</a></li><li id="30c9" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><a class="ae ls" href="https://www.youtube.com/watch?v=x_Wi2EjjKz8" rel="noopener ugc nofollow" target="_blank">学会为Playdate游戏开发编程！第二部分</a></li></ul><p id="a6ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你还需要一个代码编辑器来为你的游戏编写代码。我推荐Visual Studio代码(VS代码)，<a class="ae ls" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">你可以在这里下载</a>。</p><h1 id="bce1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">计划建造什么</h1><p id="d121" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">构建任何软件的一个常见问题是不知道在哪里停止，让更多的功能和需求慢慢建立，直到它变得势不可挡。在行业中，这通常被称为“范围蔓延”，即项目的范围逐渐扩大。</p><p id="9952" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我的建议(以及我们将如何构建这款游戏)是，在你构建它之前，定义你想要从你的游戏中得到的确切功能。这不仅有助于你思考如何去做和设计什么，也意味着你知道你的最终目标是什么。</p><p id="42be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我鼓励你跟着教程走，但是对游戏做你自己的改变，让它对你来说是独一无二的。核心功能将是:</p><ol class=""><li id="8622" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp nl mg mh mi bi translated">让一个球员可以四处走动，并避免射门击中球门</li><li id="1deb" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp nl mg mh mi bi translated">记录他们救了多少次球</li><li id="a009" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp nl mg mh mi bi translated">为游戏引入一些能量</li><li id="aa1d" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp nl mg mh mi bi translated">创建有趣的音频互动</li></ol><h1 id="2236" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">文件结构</h1><p id="0f77" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在开始之前，你应该安装Playdate SDK，并确保它在你的机器上工作。这里有一个关于如何做的非常清晰的教程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="3ba6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，您应该用您的游戏名称创建一个新文件夹，然后在该文件夹中，您应该有以下两个文件夹:</p><ul class=""><li id="bb1e" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated"><code class="fe nm nn no np b">.vscode</code> —包含关于您正在构建什么以及它使用什么编程语言的信息</li><li id="f555" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><code class="fe nm nn no np b">source</code> —你所有的源代码都在那里</li></ul><p id="8fd9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还建议在Playdate SDK中设置一个构建游戏和运行游戏的快捷方式。如果你点击<em class="lw"> CMD+Shift+P </em>，你会看到一个菜单打开，里面有可用的操作。其中一个应该是‘在Playdate模拟器中运行app’。该命令旁边应该有一个cog图标，您可以选择一个快捷方式来运行该命令。就我个人而言，我喜欢CMD+Shift+0 ，因为我已经没有绑定任何东西了。</p><p id="79e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你的源文件夹中，你需要添加一个<code class="fe nm nn no np b">pdxinfo</code>文件，它包含了关于你的游戏的所有信息。如果没有这个文件，当你把它下载到游戏日期时，你的游戏可能无法构建或运行。在<code class="fe nm nn no np b">pdxinfo</code>文件中，您应该添加如下内容:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="f067" class="nu mp it np b be nv nw l nx ny">name=Your game's name<br/>author=Your name<br/>description=Description of your game<br/>bundleID=com.yourname.yourgame<br/>version=0.1<br/>buildNumber=0001<br/>imagePath=/images<br/>launchSoundPath=/sounds</span></pre><p id="51c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到我们指向图像和声音的文件夹。您需要在源文件夹中创建这些文件夹。它们将用于您为游戏创建的视频和音频资产。</p><p id="17b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在你已经完成了基本的工作，你应该创建一个名为<code class="fe nm nn no np b">main.lua</code>的新文件，这个文件将在每次游戏打开时运行。</p><p id="725c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nm nn no np b">main.lua</code>中，你应该有一些代码来导入所有这些文件，以便它们可以在游戏中使用。您还应该添加一些样板代码，如下所示，以便简化Playdate SDK，并允许计时器正常工作。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="4cf4" class="nu mp it np b be nv nw l nx ny">import "CoreLibs/object"<br/>import "CoreLibs/graphics"<br/>import "CoreLibs/sprites"<br/>import "CoreLibs/timer"<br/>local gfx &lt;const&gt; = playdate.graphics<br/><br/>function helloPlaydate()<br/>  print("beep boop beep")<br/>end<br/><br/>helloPlaydate()<br/><br/>function playdate.update()<br/>  -- Update the sprites and the timer<br/>  gfx.sprite.update()<br/>  playdate.timer.updateTimers()<br/>end</span></pre><p id="e5f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们第一次构建我们的游戏之前，我们需要添加最后一件事。在<code class="fe nm nn no np b">.vscode</code>文件夹中，你应该添加一个<code class="fe nm nn no np b">settings.json</code>文件，它告诉VS代码SDK在哪里:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="a1f3" class="nu mp it np b be nv nw l nx ny">{<br/>  "Lua.runtime.version": "Lua 5.4",<br/>  "Lua.diagnostics.disable": ["undefined-global", "lowercase-global"],<br/>  "Lua.diagnostics.globals": ["playdate", "import"],<br/>  "Lua.runtime.nonstandardSymbol": ["+=", "-=", "*=", "/="],<br/>  "Lua.workspace.library": [<br/>  "/Users/YOURNAME/Developer/PlaydateSDK/CoreLibs"<br/>  ],<br/>  "Lua.workspace.preloadFileSize": 1000,<br/>  "playdate.sdkPath": "/Users/YOURNAME/Developer/PlaydateSDK"<br/>}</span></pre><p id="407b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:你的SDK路径在你的机器上可能是不同的，特别是如果你在Windows上，因为上面显示的路径是用于Mac的。</p><p id="defa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦所有这些都完成了，你应该可以点击CMD+Shift+0(或者任何你创建的快捷方式),游戏日期模拟器应该打开，然后在控制台中，你应该会看到你的消息“哔哔哔”。</p><p id="b2a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果有些东西不起作用，我在GitHub上为这个教程创建了一个开放的repo，第一部分可以在那里下载。请随意将它克隆到您的计算机上，如果需要的话，从那里继续进行。</p><h1 id="93ae" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">设计游戏</h1><p id="67f7" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">现在是一些有趣的事情:设计你的游戏。</p><p id="2710" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要设计一个:</p><ul class=""><li id="d6d3" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">欢迎屏幕，</li><li id="67e4" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">我们游戏的背景，</li><li id="bd9f" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">游戏结束屏幕，</li><li id="4b50" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">玩家，</li><li id="4bf3" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">球，</li><li id="c3cd" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">目标，而且，</li><li id="d94d" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">一组电源。</li></ul><p id="2691" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们将使用Figma。Figma是一个非常直观的数字设计工具，免费提供。你可以在这里注册一个账户。</p><p id="261b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">以下是一些关于学习Figma基础知识的有用教程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="abc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦你理解了Figma的工作原理，你就可以开始创建自己的视觉效果了。为了有所帮助，<a class="ae ls" href="https://www.figma.com/file/uiBsXYVADaTVaibKSYkuvf/Playdate-Assets/duplicate" rel="noopener ugc nofollow" target="_blank">我创建了这个Figma文件，它为你的游戏日期卡(显示在你的游戏日期安装的游戏列表中)、玩家/精灵和游戏背景提供了正确大小的框架</a>。当你点击链接时，它会将文件复制到你的Figma帐户中，这样你就可以开始编辑了。</p><blockquote class="lt lu lv"><p id="6888" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated"><strong class="kw iu">抓住时机:</strong>play date有1位屏幕！也就是说它只支持黑白。Playdate不渲染彩色图像。</p><p id="9ffe" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated">我的建议是:在你的设计中只使用纯黑(#000000)和纯白(#FFFFFF)。如果你需要创建类似渐变的效果，你可以使用抖动工具。只要确保在抖动设置中你选择了黑白调色板。</p></blockquote><p id="2ded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你在Figma中设计图形时，我建议选择<em class="lw">视图&gt;像素网格</em>来打开编辑器的像素网格。这将向您显示一个模糊的网格轮廓，并允许您的形状捕捉到位。您可以逐个像素地设计您的作品，或者您可以绘制重叠像素的形状，Playdate会将它们呈现为稍微更方的版本。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/698b23fc8ddb3dbd1a93c39248b915d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ez5FxJrHi0fpHbus"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">Figma中的像素网格示例</p></figure><p id="e7ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Figma文件的第二页(<em class="lw">示例图形’</em>)你会看到我在我的游戏版本中使用的图形。请随意使用/编辑这些来匹配您的风格，或者如果您想要构建完全相同的游戏，请按原样导出它们。</p><p id="3ce8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当你对你的设计满意时，你可以选择所有的框架，在Figma编辑器的右下角，你会看到一个导出它们的选项。</p><p id="4074" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该注意到卡片图像是特殊的，应该被命名为“卡片”，因为Playdate SDK会寻找这个图像，并在主屏幕上自动将卡片图像作为游戏的封面。在我为您创建的Figma文件中，我已经将名称设置为“card ”,所以您需要做的就是将它作为PNG导出到项目中的/images文件夹中。</p><h1 id="33ca" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">为什么我们要使用面向对象编程(OOP)</h1><p id="af84" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我见过的很多Playdate的开源游戏都把所有的游戏逻辑放在一个<code class="fe nm nn no np b">main.lua</code>文件里。这很好，但随着时间的推移，阅读和维护会变得非常困难，更不用说添加新功能了。</p><p id="b742" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就我个人而言，我发现用面向对象的方式构建游戏更清晰。</p><p id="32b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可能想知道，“面向对象”到底是什么意思？</p><p id="5a63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本质上，它允许你为某样东西构建一个蓝图，然后使用这个蓝图创建某样东西的许多不同版本，而不必复制代码。</p><p id="49f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，一个球可以是一个物体。它可以有特定的风格、速度、方向等。如果没有OOP，你将不得不对每一个不同类型的球进行硬编码，但是有了OOP，你可以构建一个球类一次，然后想重用多少次就重用多少次。随着教程的深入，这一切会变得更加清晰，但是如果你有兴趣深入探究，那么来自SquidGodDev的这个教程会告诉你你需要知道的一切，甚至更多。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="d077" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在本教程中，我们将使用OOP风格。</p><h1 id="7810" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">创建游戏场景</h1><p id="6aeb" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">在我们的游戏中，我们将有三个游戏场景:</p><ul class=""><li id="9752" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated"><strong class="kw iu">开始场景</strong>在这里我们显示一些东西，比如游戏的欢迎信息，或者说明。</li><li id="caf7" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">实际游戏发生的游戏场景。</li><li id="63ba" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">游戏结束的场景，在玩家认输后，我们把他们也带走，这样他们可以反思自己做得有多好。</li></ul><p id="f35c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，在你的游戏中，你可能想根据游戏的复杂程度添加更多的场景。例如，您可能想要为游戏中的不同区域或房间创建额外的游戏场景。</p><p id="e86d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是现在，我们将坚持上面列出的三个。</p><p id="64c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在源文件夹中，添加两个新文件:</p><ul class=""><li id="8630" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated"><code class="fe nm nn no np b">globals.lua</code></li><li id="1de4" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated"><code class="fe nm nn no np b">sceneController.lua</code></li></ul><p id="82ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b">globals.lua</code>将是我们存储全局变量的地方，我们希望每个文件都能够访问这些变量，<code class="fe nm nn no np b">sceneController.lua</code>文件将是我们处理变化场景的地方。我们不想创建太多的全局变量，因为那会导致以后复杂的错误，但是一些全局变量会支持我们的游戏。</p><p id="96c8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nm nn no np b">globals.lua</code>文件中，添加以下内容:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="2210" class="nu mp it np b be nv nw l nx ny">- Global gamestate variable which indicates what stage the user is at (start, game, game over)<br/>gameState = 'start'</span></pre><p id="00bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个<code class="fe nm nn no np b">gameState</code>变量将用于跟踪用户的状态(例如，他们是在开始场景，玩游戏，还是在游戏结束场景？)</p><p id="0514" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nm nn no np b">sceneController.lua</code>文件中，我们需要添加这段代码:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="4131" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/> <br/>-- Removes all sprites from the screen<br/>function clearSprites()<br/>   local allSprites = gfx.sprite.getAllSprites()<br/>   for index, sprite in ipairs(allSprites) do<br/>       sprite:remove()<br/>   end<br/>end<br/> <br/>-- Sets the background image<br/>function setBackground(imageName)<br/>   -- Display a background image<br/>   local backgroundImage = gfx.image.new( "images/" .. imageName )<br/>   assert( backgroundImage )<br/> <br/>   gfx.sprite.setBackgroundDrawingCallback(<br/>       function( x, y, width, height )<br/>           backgroundImage:draw( 0, 0 )<br/>       end<br/>   )<br/>end<br/> <br/>-- Sets up the starting scene<br/>function setStartingScene()<br/>   gameState = 'start'<br/>   clearSprites()<br/> <br/>   setBackground('startingBackground')<br/>end<br/> <br/>-- Sets up the game scene<br/>function setGameScene()<br/>   gameState = 'game'<br/>   clearSprites()<br/> <br/>   setBackground('background')<br/>end<br/> <br/>-- Sets up the game over scene<br/>function setGameOverScene()<br/>   gameState = 'game over'<br/>   clearSprites()<br/>   setBackground('endingBackground')<br/>end</span></pre><p id="fec7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有几个需要消化的东西，我们就一个一个分解吧。</p><p id="d21d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b">clearSprites()</code>功能可以让我们摆脱屏幕上的一切。它遍历所有存在的精灵并删除它。当我们想从一个场景到另一个场景时，这很有用，因为这意味着我们有一个干净的石板。</p><p id="1aa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b">setBackground(name)</code>功能允许我们改变不同场景的背景。我们传入name参数(它只是图像的名称)，然后将图像绘制到背景，从0，0(屏幕的左上角)开始。</p><p id="8402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b">setStartingScene()</code>、<code class="fe nm nn no np b">setGameScene()</code>和<code class="fe nm nn no np b">setGameOverScene()</code>都做类似的事情:</p><ol class=""><li id="95e0" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp nl mg mh mi bi translated">更改<code class="fe nm nn no np b">gameState</code>，使其更新到最新的场景。</li><li id="f9b6" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp nl mg mh mi bi translated">清除所有精灵。</li><li id="ae2f" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp nl mg mh mi bi translated">通过调用setBackground函数并传入背景图像的名称来更改背景。</li></ol><p id="5d2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了将这一切联系起来，我们需要返回到<code class="fe nm nn no np b">main.lua</code>文件并导入我们新创建的文件:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="3845" class="nu mp it np b be nv nw l nx ny">import "globals"<br/>import "sceneController"</span></pre><p id="7a04" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您不将文件导入<code class="fe nm nn no np b">main.lua</code>，那么您将无法访问该文件或其他导入文件中的功能。</p><p id="c508" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导入后，我们需要调用一个函数来设置场景:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="e23c" class="nu mp it np b be nv nw l nx ny">setStartingScene()</span></pre><p id="3389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你再次运行游戏，你会看到你的开始场景出现。</p><p id="0bbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想看游戏场景或者游戏结束场景，你只需要把那个函数调用改成<code class="fe nm nn no np b">setGameScene()</code>或者<code class="fe nm nn no np b">setGameOverScene()</code>。</p><p id="ac9b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您的<code class="fe nm nn no np b">main.lua</code>应该是这样的:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="2477" class="nu mp it np b be nv nw l nx ny">import "CoreLibs/object"<br/>import "CoreLibs/graphics"<br/>import "CoreLibs/sprites"<br/>import "CoreLibs/timer"<br/>import "globals"<br/>import "sceneController"<br/> <br/>local gfx &lt;const&gt; = playdate.graphics<br/> <br/>setStartingScene()<br/> <br/>function playdate.update()<br/>   -- Update the sprites and the timer<br/>   gfx.sprite.update()<br/>   playdate.timer.updateTimers()<br/>end</span></pre><h1 id="e5c1" class="mo mp it bd mq mr ms mt mu mv mw mx my jz mz ka na kc nb kd nc kf nd kg ne nf bi translated">在场景中前进</h1><p id="5194" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们从起始场景开始，但是我们希望能够从那里进展到主游戏场景。</p><p id="1241" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们将创建一个组件，允许我们按下A按钮，然后这个按钮为我们调用<code class="fe nm nn no np b">setGameScene()</code>函数。</p><p id="7ab1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在源文件夹中创建一个名为<code class="fe nm nn no np b">playGameButton.lua</code>的新文件。在文件中，您应该使用以下代码:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="4725" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/> <br/>class('PlayGameButton').extends(gfx.sprite)<br/> <br/>function PlayGameButton:init(x, y)<br/>   local playGameButtonImage = gfx.image.new("images/playGameMessage")<br/>   assert( playGameButtonImage )<br/>   self:setImage(playGameButtonImage)<br/>   self:moveTo( x, y )<br/>   self:add()<br/>end<br/> <br/>-- When the A button is pressed and released, the game state changes and the user can play the game<br/>function playdate.AButtonUp()<br/>   if gameState == 'start' or gameState == 'game over' then<br/>       setGameScene()<br/>   end<br/>end</span></pre><p id="3584" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们消化一下这里发生的事情。</p><p id="1f36" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建一个扩展Sprite类的<code class="fe nm nn no np b">PlayGameButton</code>类。这意味着我们将来可以制作一个<code class="fe nm nn no np b">PlayGameButton</code>对象。</p><p id="03c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们有一个用于<code class="fe nm nn no np b">PlayGameButton</code>的init函数，它接受一个X和Y坐标，指示我们想把它放在屏幕上的什么地方。</p><p id="8fd4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在init函数中，我们还设置了想要用于按钮图像，以及一个将它添加到屏幕的函数调用。</p><blockquote class="lt lu lv"><p id="0caf" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>你会注意到在init函数中我们使用了<em class="it"> self </em>关键字。这基本上意味着我们指的是按钮的特定实例。如果你曾经用类似TypeScript的语言编程，这类似于使用<em class="it"> this </em>关键字。</p><p id="9750" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated">当游戏中同时存在多个对象实例时，这是最有用的。我们将只创建一个按钮，但是当我们开始创建多个足球时，你会看到拥有一个对象的多个实例的影响是非常方便的。</p></blockquote><p id="9de3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">文件中唯一的另一个函数是AButtonUp()回调函数，它在控制台上的A按钮被按下<em class="lw">和释放</em>时运行。</p><blockquote class="lt lu lv"><p id="f731" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated"><strong class="kw iu"> Gotcha moment: </strong>开发过程中很难诊断的一个问题是，当我按下A按钮时，控制台将其视为我在重复发送A按钮。</p><p id="19b5" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated">问题？我使用的是AButtonDown()函数，只要按钮被按下，该函数就会一直被触发(因此，如果您延长按钮的按下时间，事件就会一直被触发)。AButtonUp()解决了这个问题，因为它只在按下并释放A按钮时调用该功能一次。</p></blockquote><p id="3d4d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦按钮被按下，就有一些逻辑来检查玩家是在游戏的开始还是结束场景，如果是，就被发送到主游戏场景。</p><p id="cff0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是为了使用户可以从开始场景或游戏结束场景转到主游戏。</p><p id="1adb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来我们需要做的是确保PlayGameButton被添加到正确的场景中。在<code class="fe nm nn no np b">sceneController.lua</code>文件中，修改开始场景和游戏结束场景的函数，以便将<code class="fe nm nn no np b">PlayGameButton</code>添加到屏幕上:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="7df3" class="nu mp it np b be nv nw l nx ny">-- Sets up the starting scene<br/>function setStartingScene()<br/>   gameState = 'start'<br/>   clearSprites()<br/> <br/>   PlayGameButton(200, 200)<br/>   setBackground('startingBackground')<br/>end<br/> <br/>-- Sets up the game over scene<br/>function setGameOverScene()<br/>   gameState = 'game over'<br/>   clearSprites()<br/> <br/>   PlayGameButton(200, 200)<br/>   setBackground('endingBackground')<br/>end</span></pre><p id="c8b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们向<code class="fe nm nn no np b">PlayGameButton</code>传递‘200，200’来设置我们希望它在屏幕上呈现的坐标。</p><p id="aaed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们需要在我们的<code class="fe nm nn no np b">main.lua</code>文件中导入<code class="fe nm nn no np b">playGameButton.lua</code>文件:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="2117" class="nu mp it np b be nv nw l nx ny">import “playGameButton”</span></pre><p id="f8ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦完成并保存，你应该能够运行命令在Playdate模拟器中玩你的游戏，并看到你现在有一个开始场景和一个play game按钮。</p><p id="757f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你点击A按钮，你将进入主游戏场景。当然，还没有任何事情发生，因为我们还没有开发出任何可玩的游戏，但是我们很快就会了。</p><p id="fbb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最终，当游戏结束时，我们还会在游戏结束场景中看到“玩游戏”按钮。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/94cdf036945d7d21824092b1f4e6eea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rM9dwpJhOjJST7HdzjwE6Q.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">游戏的开始屏幕</p></figure><h2 id="424c" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">创建一个可移动的播放器</h2><p id="fa9d" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们想创造一个守门员，我们可以在屏幕上移动来保存射门。</p><p id="10ce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要添加一个名为<code class="fe nm nn no np b">player.lua</code>的新文件到我们的源文件夹中。在播放器文件中，添加以下代码:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="f0fb" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/> <br/>class('Player').extends(gfx.sprite)<br/> <br/>-- Instantiates the Player<br/>function Player:init(x, y)<br/>   local playerImage = gfx.image.new("images/playerImage")<br/>   assert( playerImage )<br/>   self:setImage(playerImage)<br/>   self:moveTo( x, y )<br/>   self:setCollideRect(0, 4, 32, 24)<br/>   self:add()<br/> <br/>   self.speed = 4<br/>end<br/> <br/>-- Runs every time the playdate refreshes, constantly checking if a button is being presssed (multiple can be pressed at once)<br/>function Player:update()<br/>   -- Allow player movement with the D-pad<br/>   if playdate.buttonIsPressed( playdate.kButtonUp ) then<br/>       if (self.y &gt; 8) then<br/>           self:moveBy( 0, -self.speed * keeperSpeedMultiplier )<br/>       end<br/>   end<br/>   if playdate.buttonIsPressed( playdate.kButtonRight ) then<br/>       if (self.x &lt; 384) then<br/>           self:moveBy( self.speed * keeperSpeedMultiplier, 0 )<br/>       end<br/>   end<br/>   if playdate.buttonIsPressed( playdate.kButtonDown ) then<br/>       if (self.y &lt; 210) then<br/>           self:moveBy( 0, self.speed * keeperSpeedMultiplier )<br/>       end<br/>   end<br/>   if playdate.buttonIsPressed( playdate.kButtonLeft ) then<br/>       if (self.x &gt; 16) then<br/>           self:moveBy( -self.speed * keeperSpeedMultiplier, 0 )<br/>       end<br/>   end<br/>end</span></pre><p id="600a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们导入一些核心的<code class="fe nm nn no np b">Playdate</code>包。接下来，我们创建一个新的Player类，它本质上扩展了默认sprite的功能。</p><p id="eb9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在<code class="fe nm nn no np b">Player:init</code>中，我们初始化<code class="fe nm nn no np b">Player</code>。我们传入X和Y值，它们将是玩家最初在屏幕上所处位置的坐标。</p><p id="d5f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将球员图像设置为我们之前准备的图像文件夹中的图像。</p><p id="c445" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到我们也第一次使用了<code class="fe nm nn no np b">setCollideRect</code>。这允许我们在精灵上定制碰撞框，以防我们的图像没有压到精灵的所有边界。我们传入0、4、32和24，这意味着:</p><ul class=""><li id="b90f" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">碰撞矩形起点的X坐标为0</li><li id="8071" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">碰撞矩形起点的Y坐标向下4个像素</li><li id="ee42" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">碰撞矩形的宽度是32像素</li><li id="2063" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">碰撞矩形的高度是24像素</li></ul><p id="1cd5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们定制了碰撞矩形以使游戏感觉更有逻辑性——我们不想在球似乎击中我们的守门员之前“保存”一次射门。</p><p id="5099" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在初始化函数中，你会看到我们将<code class="fe nm nn no np b">self:speed</code>设置为4。这是我们守门员的默认速度。你应该试试这个值，看看它是如何影响游戏性的。</p><p id="f97a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的下一个函数是<code class="fe nm nn no np b">Player:update</code>，它在每一帧变化时被触发(所以，非常有规律)。这里我们有四个单独的if语句，它们使用了<code class="fe nm nn no np b">buttonIsPressed</code>函数，然后传递一个按钮类型(例如，kButtonUp，表示向上按钮)。</p><p id="3eeb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一个方向按钮被按下，我们检查玩家是否在屏幕的范围内。例如，如果我们按下右方向键，我们会检查玩家的<code class="fe nm nn no np b">self.x</code>(他们的X坐标)是否小于384(记住Playdate屏幕是400像素宽)。我们检查了一个低于400的数字，这样玩家就可以留在屏幕上，而不是消失然后停止。</p><p id="c286" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果玩家在屏幕的边界内，那么我们允许他们移动。</p><p id="4708" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们调用<code class="fe nm nn no np b">moveBy</code>函数，传入X和Y值。如果我们向左或向右移动，我们保持Y值为0。如果我们向上或向下移动，我们保持X值为0。</p><p id="f14d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到我们移动玩家的距离是<code class="fe nm nn no np b">self.speed</code>乘以<code class="fe nm nn no np b">keeperSpeedMultiplier</code>。目前，这个乘数变量不存在，所以我们需要将它添加到<code class="fe nm nn no np b">globals.lua</code>文件中。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="87b6" class="nu mp it np b be nv nw l nx ny">keeperSpeedMultiplier = 1</span></pre><p id="18cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，在未来，如果我们想让游戏影响玩家的移动方式，我们可以改变全局。例如，如果我们希望球员在救球时加快速度，我们可以给乘数加上0.01。</p><p id="1a69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了，玩家已经准备好了。但是如果你现在运行这个游戏，你会发现什么都没有改变。为什么？</p><p id="4d39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要将玩家添加到游戏场景中。在<code class="fe nm nn no np b">sceneController</code>文件中，更新<code class="fe nm nn no np b">setGameScene</code>函数，将播放器添加到屏幕上:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="9912" class="nu mp it np b be nv nw l nx ny">-- Sets up the game scene<br/>function setGameScene()<br/>   gameState = 'game'<br/>   clearSprites()<br/> <br/>   Player(200, 180)<br/>   setBackground('background')<br/>end</span></pre><p id="5b38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们需要将<code class="fe nm nn no np b">player.lua</code>文件导入到我们的<code class="fe nm nn no np b">main.lua</code>文件中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="4712" class="nu mp it np b be nv nw l nx ny">import “player”</span></pre><p id="0224" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦你做了这些更改并保存了文件，你就可以运行游戏，按A键开始新的游戏，然后你会在屏幕上看到你的守门员，你可以用方向箭头移动他。</p><p id="0210" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，在游戏日期模拟器设置下，你可以启用“显示精灵碰撞矩形”，这将在你的精灵上显示一个指示碰撞框的粉红色轮廓。当你开发游戏以确保碰撞矩形设置正确并与你的图像匹配时，这是非常方便的。你也可以启用这个选项，因为当你构建游戏并把它加载到设备上时，碰撞指示器不会显示。</p><h2 id="59c0" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">创造一个你可以防守的移动球</h2><p id="95c7" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">现在我们有一个球员在屏幕上移动，我们应该添加他们可以互动的足球。</p><p id="fcfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的源文件夹中，添加一个名为<code class="fe nm nn no np b">ball.lua</code>的新文件。在该文件中，您应该有以下代码:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="cff2" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/> <br/>class('Ball').extends(gfx.sprite)<br/> <br/>function Ball:init(x, y, speed, direction)<br/>   local ballImage = gfx.image.new("images/ball")<br/>   assert( ballImage )<br/> <br/>   self:setImage(ballImage)<br/>   self:moveTo( x, y )<br/>   self:setCollideRect(8, 8, 16, 16)<br/>   self.speed = speed<br/>   self.direction = direction<br/>   self:add()<br/>end<br/> <br/>function Ball:update()<br/>   local actualX, actualY, collisions, length = self:moveWithCollisions(self.x + self.direction, self.y + (self.speed * ballSpeedMultiplier))<br/> <br/>   -- If there is a collision<br/>   if length &gt; 0 then<br/>       for index, collision in ipairs(collisions) do<br/>           local collidedObject = collision['other']<br/> <br/>           if collidedObject:isa(Player) then<br/>               self:remove()<br/>           end<br/>       end<br/>   end<br/> <br/>   -- If the ball has flown off screen, it is removed from the list of sprites for performance reasons<br/>   if (self.y &gt; 240) then<br/>       self:remove()<br/>   end<br/>end<br/> <br/>-- Ensures the Balls overlap each other rather than bumping into each other and sliding slowly<br/>function Ball:collisionResponse()<br/>   return 'overlap'<br/>end</span></pre><p id="bebf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">像<code class="fe nm nn no np b">player.lua</code>文件一样，我们创建了Ball类，它扩展了Sprite类。</p><p id="c52e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们初始化球时，我们给它:</p><ul class=""><li id="71e9" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">一个X坐标</li><li id="e4de" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">Y坐标</li><li id="8499" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">速度值</li><li id="1b01" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">方向值</li></ul><p id="7434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些值可以在以后被随机化，以创建一个更具挑战性和趣味性的游戏。</p><p id="675e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们做的下一件有趣的事情是检查更新函数中的冲突。如果有碰撞，我们可以检查球碰撞的是什么类型的东西。目前，我们只有一名球员——但在未来，我们将添加一个目标和一堵墙，因此我们将再次更新这一逻辑。</p><p id="ce09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到在逻辑中我们使用了一个新的全局变量，名为“ballSpeedMultiplier”。我们需要将此添加到<code class="fe nm nn no np b">globals.lua</code>文件中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="4263" class="nu mp it np b be nv nw l nx ny">gameState = ‘start’</span></pre><pre class="or nq np nr bn ns nt bi"><span id="6c21" class="nu mp it np b be nv nw l nx ny">keeperSpeedMultiplier = 1</span></pre><pre class="or nq np nr bn ns nt bi"><span id="95ff" class="nu mp it np b be nv nw l nx ny">ballSpeedMultiplier = 1</span></pre><p id="7f6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在以后使用这个变量来创造有趣的效果，当玩家在游戏中使用电源和进步。</p><p id="f6de" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果与球员发生碰撞，我们将球从屏幕上移除。</p><p id="6e02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还有一个额外的检查，检查球是否飞出了屏幕，如果飞出了屏幕，我们就把它移走。这是出于性能原因。如果我们不移动球，从技术上来说，它仍然存在于屏幕之外，仍然有计算能力专门跟踪它。一旦我们有大量的足球生成，这可能会成为系统处理的问题。</p><p id="7df6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后还有另一个函数处理球的碰撞响应。这个函数返回字符串‘overlap ’,这样如果球精灵在屏幕上发生碰撞，它们可以互相重叠。<a class="ae ls" href="https://sdk.play.date/1.12.3/Inside%20Playdate.html#c-graphics.sprite.collisionResponse" rel="noopener ugc nofollow" target="_blank">Playdate SDK进一步详细解释了</a>你可以利用哪些其他类型的碰撞响应。</p><p id="f6cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在都完成了足球，但现在我们应该实际实现一些东西来触发足球的产卵。</p><p id="8ebf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的源文件夹中创建另一个名为<code class="fe nm nn no np b">ballSpawner.lua</code>的新文件，并将以下代码添加到其中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="27dd" class="nu mp it np b be nv nw l nx ny">import "ball"<br/> <br/>local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/> <br/>local spawnTimer<br/> <br/>function startBallSpawner()<br/>   -- Makes the game randomly spawn balls<br/>   math.randomseed(pd.getSecondsSinceEpoch())<br/>   createBallTimer()<br/>end<br/> <br/>function createBallTimer()<br/>   -- Generates a random period between spawning the next ball<br/>   local spawnTime = math.random(700, 1200)<br/> <br/>   -- Waits for the random amount of time, then calls the callback functions to spawn the ball<br/>   spawnTimer = pd.timer.performAfterDelay(spawnTime, function()<br/>       createBallTimer()<br/>       spawnBall()<br/>   end)<br/>end<br/> <br/>-- Spawns a ball at a random location<br/>function spawnBall()<br/>   local spawnPosition = math.random(0, 240)<br/>   local spawnDirection = math.random(-3, 3)<br/>   local spawnSpeed = math.random(2, 5)<br/> <br/>   -- Spawns the ball at a random position and changes speed as the player progresses<br/>   Ball(spawnPosition, -20, spawnSpeed, spawnDirection)<br/>end<br/> <br/>-- Stops the ball spawner<br/>function stopBallSpawner()<br/>   if spawnTimer then<br/>       spawnTimer:remove()<br/>   end<br/>end<br/> <br/>-- Clears all the Balls from the display<br/>function clearBalls()<br/>   local allSprites = gfx.sprite.getAllSprites()<br/>   for index, sprite in ipairs(allSprites) do<br/>       if sprite:isa(Ball) then<br/>           sprite:remove()<br/>       end<br/>   end<br/>end</span></pre><p id="225f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个文件导入Ball类，然后操作它。</p><p id="2a27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有启动球生成器的函数，它随机等待一段时间(700毫秒到1200毫秒)来生成一个新球。这个函数是递归的，这意味着它一遍又一遍地调用自己，直到我们停止它。这意味着在我们玩的时候，足球将会继续繁殖。</p><p id="c60b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nm nn no np b">spawnBall</code>函数中，我们将X坐标的生成位置随机化，以便它来自某个意想不到的地方。这介于0和240之间，因为屏幕的宽度是240像素。</p><p id="72a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们随机选择球的方向，从-3到3。这意味着球可以向左(在X轴上为负)或向右(在X轴上为正)移动。</p><p id="e265" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们在2和5之间随机化球的速度。</p><p id="beb2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你应该使用所有这些最小值和最大值来玩游戏，以使游戏对你来说是独特和有趣的。</p><p id="594e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们使用<code class="fe nm nn no np b">Ball</code>类并输入我们刚刚创建的随机变量，Y坐标是一个明显的例外，我们每次都设置为-20，这样球就在屏幕外生成。如果你把它放在屏幕上，它看起来会有点奇怪，而在屏幕外，它会让人觉得有人拍了一个长镜头。</p><p id="5133" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的其他功能有<code class="fe nm nn no np b">stopBallSpawner</code>来…你猜对了…阻止球产卵，以及<code class="fe nm nn no np b">clearBalls</code>来…从屏幕上清除所有的球！</p><p id="13b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我们结束游戏和清除所有精灵的时候，这些对我们来说很方便。</p><p id="b070" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们将更新<code class="fe nm nn no np b">sceneController</code>文件来启动和停止球产卵器:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="8c86" class="nu mp it np b be nv nw l nx ny">-- Sets up the game scene<br/>function setGameScene()<br/>   gameState = 'game'<br/>   clearSprites()<br/> <br/>   Player(200, 180)<br/>   startBallSpawner()<br/>   setBackground('background')<br/>end<br/> <br/>-- Sets up the game over scene<br/>function setGameOverScene()<br/>   gameState = 'game over'<br/>   clearSprites()<br/> <br/>   stopBallSpawner()<br/>   PlayGameButton(200, 200)<br/>   setBackground('endingBackground')<br/>end</span></pre><p id="1bfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们将把<code class="fe nm nn no np b">ballSpawner</code>导入到<code class="fe nm nn no np b">main.lua</code>文件中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="1294" class="nu mp it np b be nv nw l nx ny">import “ballSpawner”</span></pre><p id="0dfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请注意，您不必导入球，因为我们已经将它导入到了<code class="fe nm nn no np b">ballSpawner</code>文件中。</p><p id="3800" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你现在运行你的游戏，你应该有球产卵到屏幕上，当你与它们碰撞时，它们应该消失。</p><h2 id="542e" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">创造一个你必须捍卫的目标</h2><p id="6480" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们游戏的基础部分现在正在整合，但是我们缺少一个关键元素:目标。</p><p id="76dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为守门员，这个游戏的目的是让你在面对迎面而来的射门时保护好你的球门，确保没有射门击中球网的背面。</p><p id="8568" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们来创造目标吧！</p><p id="4a58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的源文件夹中，创建一个名为<code class="fe nm nn no np b">goal.lua</code>的新文件，其中包含以下代码:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="f796" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/> <br/>class('Goal').extends(gfx.sprite)<br/> <br/>function Goal:init(x, y)<br/>   local goalImage = gfx.image.new("images/goal")<br/>   assert( goalImage )<br/> <br/>   self:setImage(goalImage)<br/>   self:moveTo( x, y )<br/>   self:setCollideRect(16, 8, 222, 16)<br/>   self:add()<br/>end<br/> <br/>function Goal:collisionResponse()<br/>   return 'overlap'<br/>end</span></pre><p id="67cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常简单的文件，与我们之前创建的其他文件非常相似。init函数中最值得注意的是，我们为碰撞矩形定义了一个非常奇怪的形状。我们正在对它进行偏移，并将其相对于图像稍微缩小(你可以在<a class="ae ls" href="https://www.figma.com/file/uiBsXYVADaTVaibKSYkuvf/Playdate-Assets/duplicate" rel="noopener ugc nofollow" target="_blank">我为这些教程创建的</a>fig ma文档中找到)。</p><p id="665f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">调整碰撞形状的原因是为了让足球看起来不会撞到门柱上，然后算作进球，这可能会让球员感到困惑。</p><p id="aae1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该文件中另一个值得注意的地方是，目标的碰撞响应被设置为“重叠”，这样足球就可以与目标重叠。</p><p id="899a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经完成了排序，进入您的<code class="fe nm nn no np b">ball.lua</code>文件，并添加这个条件语句来检查球是否击中了目标:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="5f6a" class="nu mp it np b be nv nw l nx ny">-- If we concede a goal, the game is over<br/>if collidedObject:isa(Goal) then<br/>    setGameOverScene()<br/>    self:remove()<br/>end</span></pre><p id="dc4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着，如果球与球门发生碰撞，游戏结束功能将被调用，球将从屏幕上移除。</p><p id="a602" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要在我们的<code class="fe nm nn no np b">sceneController.lua</code>文件中创建目标。在<code class="fe nm nn no np b">setGameScene</code>函数中，添加这行代码以将目标显示在屏幕上:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="b8e6" class="nu mp it np b be nv nw l nx ny">Goal(200, 235)</span></pre><p id="9020" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们需要将目标文件导入到我们的<code class="fe nm nn no np b">main.lua</code>文件中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="81cb" class="nu mp it np b be nv nw l nx ny">import “goal”</span></pre><p id="735c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在你保存了你的工作并再次启动游戏后，你应该有一个目标去捍卫！我们游戏的核心功能现在已经完成，因为你可以阻止足球飞入你的球网。</p><blockquote class="lt lu lv"><p id="2c80" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated">如果到目前为止你有任何问题或者有些事情不太正常，请随意复制我在这里提供的GitHub库。</p></blockquote><h2 id="98fa" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">跟踪并显示玩家的分数</h2><p id="adaa" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">为了让游戏变得有趣，我们应该朝着成就努力。在这场比赛中，我们将努力在每场比赛中获得最高分。</p><p id="364f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe nm nn no np b">globals.lua</code>文件中，我们应该添加一个<code class="fe nm nn no np b">score</code>变量:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="1899" class="nu mp it np b be nv nw l nx ny">score = 0</span></pre><p id="54b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们在整个游戏中用来追踪分数的变量。我们把它作为一个全局变量，所以我们可以用它来影响游戏的其他领域。</p><p id="d6f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在应该创建一个名为<code class="fe nm nn no np b">scoreDisplay.lua</code>的新文件:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="61cb" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/>local scoreSprite<br/><br/>function createScoreDisplay()<br/>    -- Current score sprite<br/>    scoreSprite = gfx.sprite.new()<br/>    score = 0<br/>    scoreSprite:setCenter(0, 0)<br/>    scoreSprite:moveTo(320, 4)<br/>    scoreSprite:add()<br/>end<br/><br/>function updateDisplay()<br/>    -- Current score<br/>    local scoreText = 'Score: ' .. score<br/>    local textWidth, textHeight = gfx.getTextSize(scoreText)<br/>    local scoreImage = gfx.image.new(textWidth, textHeight)<br/>    gfx.pushContext(scoreImage)<br/>        gfx.drawText(scoreText, 0, 0)<br/>    gfx.popContext()<br/>    scoreSprite:setImage(scoreImage)<br/>end<br/><br/>function incrementScore()<br/>    -- Updates the score<br/>    score += 1<br/>    updateDisplay()<br/>end<br/><br/>function resetScore()<br/>    score = 0<br/>    updateDisplay()<br/>end<br/><br/>function getScore()<br/>    return score<br/>end</span></pre><p id="ba35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从上到下分析这个文件。</p><p id="b02a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建一个本地<code class="fe nm nn no np b">scoreSprite</code>变量，它将用于显示<code class="fe nm nn no np b">createScoreDisplay</code>函数中的分数。在这个函数中，我们创建了精灵并把它放在屏幕的右上角。</p><p id="a82e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一个函数<code class="fe nm nn no np b">updateDisplay</code>中，我们生成希望出现在乐谱精灵中的文本，并将其绘制到屏幕上。在游戏开始时，它会简单地显示<code class="fe nm nn no np b">Score: 0</code>，因为我们还没有得到任何分数。</p><p id="547d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们有一个<code class="fe nm nn no np b">incrementScore</code>函数，它将分数增加1，并调用<code class="fe nm nn no np b">updateDisplay</code>函数来更新屏幕上显示的分数。</p><p id="df20" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们有两个简单的函数将分数重置为零并获得当前分数。</p><p id="5fa5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来我们要做的是更新我们的<code class="fe nm nn no np b">sceneController.lua</code>中的<code class="fe nm nn no np b">setGameScene</code>函数，这样我们就可以触发分数的显示:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="77fa" class="nu mp it np b be nv nw l nx ny">-- Sets up the game scene<br/>function setGameScene()<br/>    gameState = 'game'<br/>    clearSprites()<br/>    createScoreDisplay()<br/>    Player(200, 180)<br/>    Goal(200, 235)<br/>    setBackground('background')<br/>end</span></pre><p id="cb23" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nm nn no np b">main.lua</code>文件中，我们应该添加一个名为<code class="fe nm nn no np b">resetGame</code>的新函数，以便在新游戏需要启动时调用其他一些辅助函数:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="effb" class="nu mp it np b be nv nw l nx ny">function resetGame()<br/>    resetScore()<br/>    clearBalls()<br/>    stopBallSpawner()<br/>    startBallSpawner()<br/>end</span></pre><p id="1de5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要从<code class="fe nm nn no np b">playGameButton.lua</code>文件中调用<code class="fe nm nn no np b">resetGame</code>函数，在<code class="fe nm nn no np b">AButtonUp</code>回调函数中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="4a48" class="nu mp it np b be nv nw l nx ny">function playdate.AButtonUp()<br/>    if gameState == 'start' or gameState == 'game over' then<br/>        setGameScene()<br/>        resetGame()<br/>    end<br/>end</span></pre><p id="e39b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe nm nn no np b">ball.lua</code>文件中，我们应该更新当球和球员之间发生碰撞时会发生什么，以便增加分数:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="695b" class="nu mp it np b be nv nw l nx ny">if collidedObject:isa(Player) then<br/>    -- If we save a shot, the score is incremented by 1<br/>    incrementScore()<br/>    self:remove()<br/>end</span></pre><p id="c5fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们应该将我们的<code class="fe nm nn no np b">scoreDisplay</code>函数导入到我们的<code class="fe nm nn no np b">main.lua</code>文件中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="b2c0" class="nu mp it np b be nv nw l nx ny">import "scoreDisplay"</span></pre><p id="8c43" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您现在保存并运行游戏，当您开始新游戏时，您将能够看到分数，分数将随着您的保存而上升，当您结束游戏并想再次玩游戏时，分数将重置。</p><h2 id="7898" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">从游戏日期的存储器中保存、存储和加载高分</h2><p id="bc8f" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">我们希望能够存储玩家在游戏日期的最高分，这样我们就知道历史最高分是多少，这样我们就可以在退出游戏时从哪里开始。</p><p id="a4a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为此，我们需要与Playdate的内部存储系统进行通信，以存储我们的高分。</p><p id="7117" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">目前，我们还没有显示最高分。让我们改变这一点。</p><p id="3aad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在我们的<code class="fe nm nn no np b">scoreDisplay.lua</code>文件中添加一些新功能:</p><ul class=""><li id="50bc" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">在屏幕上显示高分</li><li id="4088" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">将高分存储在游戏日期的存储器中</li></ul><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="5d80" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/>local scoreSprite<br/>local highscoreSprite<br/>local highscore<br/>local scoreTable<br/><br/>-- If there is a highscore stored, it loads it to the game, otherwise it initialises it to zero<br/>function loadHighscore()<br/>    scoreTable = playdate.datastore.read('scoreInfo')<br/>    if scoreTable ~= nil then<br/>        highscore = scoreTable[1]<br/>    else<br/>        scoreTable = {}<br/>        scoreTable[1] = 0<br/>        highscore = 0<br/>    end<br/>end<br/><br/>-- Saves the score to the device if it's higher than the highscore<br/>function saveScore(newScore)<br/>    if scoreTable ~= nil then<br/>        if newScore &gt; scoreTable[1] then<br/>            scoreTable[1] = newScore<br/>            playdate.datastore.write(scoreTable, 'scoreInfo')<br/>        end<br/>    end<br/>end<br/><br/>function createScoreDisplay()<br/>    -- Current score sprite<br/>    scoreSprite = gfx.sprite.new()<br/>    score = 0<br/>    scoreSprite:setCenter(0, 0)<br/>    scoreSprite:moveTo(320, 4)<br/>    scoreSprite:add()<br/>-- Highscore sprite<br/>    highscoreSprite = gfx.sprite.new()<br/>    highscoreSprite:setCenter(0, 0)<br/>    highscoreSprite:moveTo(8, 4)<br/>    highscoreSprite:add()<br/>end<br/><br/>function updateDisplay()<br/>    -- Current score<br/>    local scoreText = 'Score: ' .. score<br/>    local textWidth, textHeight = gfx.getTextSize(scoreText)<br/>    local scoreImage = gfx.image.new(textWidth, textHeight)<br/>    gfx.pushContext(scoreImage)<br/>        gfx.drawText(scoreText, 0, 0)<br/>    gfx.popContext()<br/>    scoreSprite:setImage(scoreImage)<br/>-- Highscore<br/>    local highscoreText = 'Highscore: ' .. highscore<br/>    local highscoreTextWidth, highscoreTextHeight = gfx.getTextSize(highscoreText)<br/>    local highscoreImage = gfx.image.new(highscoreTextWidth, highscoreTextHeight)<br/>    gfx.pushContext(highscoreImage)<br/>        gfx.drawText(highscoreText, 0, 0)<br/>    gfx.popContext()<br/>    highscoreSprite:setImage(highscoreImage)<br/>end<br/><br/>function incrementScore()<br/>    -- Updates the score<br/>    score += 1<br/>    updateDisplay()<br/>end<br/><br/>function resetScore()<br/>    score = 0<br/>    updateDisplay()<br/>end<br/><br/>function getScore()<br/>    return score<br/>end</span></pre><p id="d3e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从上到下，我们在这里讨论一下变化。</p><p id="978b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们为高分精灵、高分值和分数表创建一些新的局部变量，这些变量将存储在Playdate的内存中。</p><p id="e15f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您以前使用过另一种编程语言，那么表本质上就像一个数组，但还是有一些不同之处:</p><ul class=""><li id="e113" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">索引从1开始，而不是0</li><li id="8817" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">你可以给你的指数命名</li></ul><p id="d9b4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过给变量分配空的花括号让Lua知道变量是一个表:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="905b" class="nu mp it np b be nv nw l nx ny">local myFirstTable = {}</span></pre><p id="4699" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在表的实例化过程中赋值，也可以在以后赋值。这里有一个两者都做的例子:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="fac8" class="nu mp it np b be nv nw l nx ny">-- During instantiation<br/>local myFirstTable = {'hello', 'world'}<br/><br/>-- After instantiation<br/>myFirstTable[1] = 'hello'<br/>myFirstTable[2] = 'world'</span></pre><p id="2434" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你也可以给一个字符串索引赋值，如果我们想清楚我们存储的值是什么，这很方便。例如:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="ab23" class="nu mp it np b be nv nw l nx ny">local myFirstTable = {}<br/>myFirstTable['greeting'] = 'hello world'</span></pre><p id="feaa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们可以非常容易地读取这些值，例如，如果您想将这些值打印到屏幕上，您可以这样做:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="bda6" class="nu mp it np b be nv nw l nx ny">local myFirstTable = {}<br/>myFirstTable['greeting'] = 'hello there'<br/>myFirstTable['name'] = 'Michael'<br/>print(myFirstTable['greeting'] + " " + myFirstTable['name'])</span></pre><p id="5569" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会注意到在我们的<code class="fe nm nn no np b">scoreDisplay.lua</code>文件中，我们现在有了这个函数:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="ced7" class="nu mp it np b be nv nw l nx ny">-- If there is a highscore stored, it loads it to the game, otherwise it initialises it to zero<br/>function loadHighscore()<br/>    scoreTable = playdate.datastore.read('scoreInfo')<br/>    if scoreTable ~= nil then<br/>        highscore = scoreTable[1]<br/>    else<br/>        scoreTable = {}<br/>        scoreTable[1] = 0<br/>        highscore = 0<br/>    end<br/>end</span></pre><p id="8816" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它试图从内存中检索一个分数。但是，如果用户是第一次玩，内存中已经没有分数了。因此，我们有一个条件语句来检查<code class="fe nm nn no np b">scoreTable</code>的值是否为零(如果你用JavaScript等其他语言编程，请考虑<em class="lw">未定义的</em>)。</p><p id="89e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe nm nn no np b">scoreTable</code>不为零(~=)，那么我们将最高分设置为等于我们刚刚从内存中获取的值。</p><p id="65a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe nm nn no np b">scoreTable</code>为零，那么我们告诉Lua<code class="fe nm nn no np b">scoreTable</code>是一个表，我们将它里面的第一个值(代表我们的最高分)设置为零，并将本地最高分设置为零。</p><p id="d774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们更新的代码中的其他地方，你会看到我们现在已经实现了一些代码来在屏幕的左上角显示高分。我不会详细分析它，因为它与我们之前讨论过的其他代码非常相似。</p><p id="4870" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们尝试新的高分功能之前，我们需要从<code class="fe nm nn no np b">main.lua</code>文件中的<code class="fe nm nn no np b">resetGame</code>函数调用我们的<code class="fe nm nn no np b">loadHighscore</code>函数:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="3557" class="nu mp it np b be nv nw l nx ny">function resetGame()<br/>    loadHighscore()<br/>    resetScore()<br/>    clearBalls()<br/>    stopBallSpawner()<br/>    startBallSpawner()<br/>end</span></pre><p id="546b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，为了将分数保存到内部存储器，我们需要添加一行调用<code class="fe nm nn no np b">saveScore</code>的代码到我们的<code class="fe nm nn no np b">ball.lua</code>文件中:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="b55f" class="nu mp it np b be nv nw l nx ny">-- If we concede a goal, the game is over<br/>if collidedObject:isa(Goal) then<br/>    saveScore(getScore())<br/>    setGameOverScene()<br/>    self:remove()<br/>end</span></pre><p id="a447" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你现在保存并运行你的游戏，你会在左上角看到一个高分。即使您关闭并重新打开游戏，该分数也将持续存在。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/b18aa2a3c87d030952f604f2a89b1828.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eWm5-E3fVeePSed2EQTglQ.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">我们现在在左上角有一个高分！P.S. 104是我有史以来的最高分…</p></figure><h2 id="27d1" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">为游戏开发电源</h2><p id="8050" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">一个没有能量的游戏是什么，对吗？</p><p id="baa9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是一个非常有趣的游戏，让游戏变得更加疯狂和随机。</p><p id="dc01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将在游戏中加入四种不同的能量:</p><ul class=""><li id="69f1" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">超快速守门员运动</li><li id="4574" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">减慢所有足球的速度</li><li id="0ff2" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">每次保存，您的积分翻倍</li><li id="982a" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">一次使能所有电源</li></ul><p id="8581" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要创建一个名为<code class="fe nm nn no np b">powerUp.lua</code>的新文件:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="0ae2" class="nu mp it np b be nv nw l nx ny">local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/>class('PowerUp').extends(gfx.sprite)<br/><br/>function PowerUp:init(x, y, type, imageName)<br/>    local powerUpImage = gfx.image.new("images/" .. imageName)<br/>    assert( powerUpImage )<br/>self:setImage(powerUpImage)<br/>    self:moveTo( x, y )<br/>    self:setCollideRect(4, 4, 24, 24)<br/>    self.type = type<br/>    self:add()<br/>end<br/><br/>function PowerUp:update()<br/>    local actualX, actualY, collisions, length = self:moveWithCollisions(self.x, self.y)<br/>-- If there is a collision<br/>    if length &gt; 0 then<br/>        for index, collision in ipairs(collisions) do<br/>            local collidedObject = collision['other']<br/>            <br/>            if collidedObject:isa(Player) then<br/>                -- If the player hits the powerup, change the game somehow<br/>                activatePowerUp(self.type)<br/>                self:remove()<br/>            end<br/>if collidedObject:isa(Ball) then<br/>                -- If the ball hits the powerup, remove the powerup<br/>                self:remove()<br/>            end<br/>        end<br/>    end<br/>end<br/><br/>-- Changes a global powerup to impact the gameplay<br/>function activatePowerUp(type)<br/>    if (type == 'all') then<br/>        -- Activate all powerups<br/>        keeperSpeedMultiplier = 2<br/>        ballSpeedMultiplier = 0.5<br/>        pointsMultiplier = 2<br/>    elseif (type == 'slow ball') then<br/>        -- Makes the balls slower<br/>        ballSpeedMultiplier = 0.5<br/>    elseif (type == 'fast keeper') then<br/>        -- Makes the keeper faster<br/>        keeperSpeedMultiplier = 2<br/>    elseif (type == 'double points') then<br/>        pointsMultiplier = 2<br/>    end<br/>end<br/><br/>-- Resets all the global powerups back to their defaults<br/>function resetPowerUps()<br/>    keeperSpeedMultiplier = 1<br/>    ballSpeedMultiplier = 1<br/>    pointsMultiplier = 1<br/>end<br/><br/>-- Ensures the sprites overlap each other rather<br/>function PowerUp:collisionResponse()<br/>    return 'overlap'<br/>end</span></pre><p id="2c4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们创建了一个新的<code class="fe nm nn no np b">PowerUp</code>类，它扩展了Sprite类。</p><p id="c6e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用以下内容初始化<code class="fe nm nn no np b">PowerUp</code>:</p><ul class=""><li id="fcf3" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">一个x坐标，</li><li id="6676" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">一个y坐标，</li><li id="1318" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">一种类型(例如“慢速球”)，</li><li id="e0e1" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">图像名称。</li></ul><p id="abf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将这个精灵设置为像我们之前创建的其他精灵一样显示，并根据我们使用的图像给它一个合适的碰撞矩形。</p><blockquote class="lt lu lv"><p id="e4d8" class="ku kv lw kw b kx ky ju kz la lb jx lc lx le lf lg ly li lj lk lz lm ln lo lp im bi translated">注意:我在加电时使用的图像可以在<a class="ae ls" href="https://www.figma.com/file/uiBsXYVADaTVaibKSYkuvf/Playdate-Assets/duplicate" rel="noopener ugc nofollow" target="_blank">我为本教程创建的Figma文档</a>中找到。</p></blockquote><p id="229a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nm nn no np b">PowerUp:update()</code>函数中，我们检查在<code class="fe nm nn no np b">Player</code>或<code class="fe nm nn no np b">Ball</code>之间是否有碰撞。</p><p id="97a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果与<code class="fe nm nn no np b">Player</code>发生冲突，我们调用该函数来激活一个<code class="fe nm nn no np b">PowerUp</code>，传入与我们冲突的电源类型。</p><p id="8439" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后<code class="fe nm nn no np b">activatePowerUp</code>功能根据碰撞的电源类型决定对游戏进行哪些更改。</p><p id="0a29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们确实需要向我们的<code class="fe nm nn no np b">globals.lua</code>文件添加一个全局变量:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="da32" class="nu mp it np b be nv nw l nx ny">pointsMultiplier = 1</span></pre><p id="949f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这使得我们可以控制玩家在玩游戏时应该获得多少分数。</p><p id="11fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在<code class="fe nm nn no np b">powerUp.lua</code>文件中，我们有一些函数来重置电源，并确保碰撞精灵相互重叠。</p><p id="c3b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很好，但是我们实际上还没有创建任何特定的电源。为此，我们需要一个<code class="fe nm nn no np b">PowerUp</code>spanger(有点像我们有一个<code class="fe nm nn no np b">Ball</code>和一个<code class="fe nm nn no np b">BallSpawner</code>)。</p><p id="cad5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建一个名为<code class="fe nm nn no np b">powerUpSpawner.lua</code>的新文件:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="d89e" class="nu mp it np b be nv nw l nx ny">import "powerUp"<br/>local pd &lt;const&gt; = playdate<br/>local gfx &lt;const&gt; = pd.graphics<br/>local spawnTimer<br/><br/>function startPowerUpSpawner()<br/>    -- Makes the game randomly spawn powerups<br/>    math.randomseed(pd.getSecondsSinceEpoch())<br/>    createPowerUpTimer()<br/>end<br/><br/>function createPowerUpTimer()<br/>    -- Generates a random period between spawning the next powerup<br/>    local spawnTime = math.random(8000, 20000)<br/>-- Waits for the random amount of time, then calls the callback functions to spawn the powerup<br/>    spawnTimer = pd.timer.performAfterDelay(spawnTime, function()<br/>        createPowerUpTimer()<br/>        spawnPowerUp()<br/>    end)<br/>end<br/><br/>-- Spawns a powerup at a random location<br/>function spawnPowerUp()<br/>    local spawnX = math.random(20, 380)<br/>    local spawnY = math.random(30, 140)<br/>    local spawnType = math.random(1, 4)<br/>-- Resets and removes any powerups currently impacting gameplay to incentivise the player getting the new one<br/>    clearPowerUps()<br/>    resetPowerUps()<br/>-- Spawns a random powerup at a random position on screen<br/>    if (spawnType == 1) then<br/>        PowerUp(spawnX, spawnY, 'all', 'allPowerUp')<br/>    elseif (spawnType == 2) then<br/>        PowerUp(spawnX, spawnY, 'slow ball', 'slowBallPowerUp')<br/>    elseif (spawnType == 3) then<br/>        PowerUp(spawnX, spawnY, 'fast keeper', 'fastKeeperPowerUp')<br/>    elseif (spawnType == 4) then<br/>        PowerUp(spawnX, spawnY, 'double points', 'doublePointPowerUp')<br/>    end<br/>end<br/><br/>-- Stops the powerup spawner<br/>function stopPowerUpSpawner()<br/>    if spawnTimer then<br/>        spawnTimer:remove()<br/>    end<br/>end<br/><br/>-- Clears all the powerups from the display<br/>function clearPowerUps()<br/>    local allSprites = gfx.sprite.getAllSprites()<br/>    for index, sprite in ipairs(allSprites) do<br/>        if sprite:isa(PowerUp) then<br/>            sprite:remove()<br/>        end<br/>    end<br/>end</span></pre><p id="fa63" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从上到下分析这个文件。</p><p id="1bdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们导入我们创建的<code class="fe nm nn no np b">powerUp</code>文件，这样我们就可以使用<code class="fe nm nn no np b">PowerUp</code>类。</p><p id="f216" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们创建一个本地<code class="fe nm nn no np b">spawnTimer</code>变量，并启动加电生成器。这调用了<code class="fe nm nn no np b">createPowerUpTimer</code>函数，该函数在定时器启动后的8到20秒之间随机产生一个新的<code class="fe nm nn no np b">PowerUp</code>。</p><p id="2c2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nm nn no np b">spawnPowerUp</code>函数在随机的X和Y坐标上产生<code class="fe nm nn no np b">PowerUp</code>(但是，我们设置了最小和最大限制，以确保<code class="fe nm nn no np b">PowerUp</code>不会离玩家太近)。</p><p id="16c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们生成一个介于1和4(包括1和4)之间的随机数来决定我们应该随机产生哪个<code class="fe nm nn no np b">PowerUp</code>。</p><p id="ca71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从显示器上移除旧的<code class="fe nm nn no np b">PowerUps</code>并将游戏重置为默认设置是合理的。</p><p id="841a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有一个条件语句来检查生成了哪个数字，并基于该值生成一个<code class="fe nm nn no np b">PowerUp</code>。例如，如果spawnType为2，将创建慢速球加电。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="6294" class="nu mp it np b be nv nw l nx ny">-- Spawns a random powerup at a random position on screen<br/>    if (spawnType == 1) then<br/>        PowerUp(spawnX, spawnY, 'all', 'allPowerUp')<br/>    elseif (spawnType == 2) then<br/>        PowerUp(spawnX, spawnY, 'slow ball', 'slowBallPowerUp')<br/>    elseif (spawnType == 3) then<br/>        PowerUp(spawnX, spawnY, 'fast keeper', 'fastKeeperPowerUp')<br/>    elseif (spawnType == 4) then<br/>        PowerUp(spawnX, spawnY, 'double points', 'doublePointPowerUp')<br/>    end</span></pre><p id="0e59" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们有函数来停止spawner并从显示中清除所有的<code class="fe nm nn no np b">PowerUps</code>。</p><p id="c433" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始玩<code class="fe nm nn no np b">PowerUps</code>之前，我们需要修改一些代码来支持<code class="fe nm nn no np b">PowerUps</code>。在<code class="fe nm nn no np b">scoreDisplay</code>文件中，更新<code class="fe nm nn no np b">incrementScore</code>函数，将分数增加1，乘以我们创建的<code class="fe nm nn no np b">pointsMultiplier</code>全局变量:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="c2af" class="nu mp it np b be nv nw l nx ny">function incrementScore()<br/>    -- Updates the score<br/>    score += 1  * pointsMultiplier<br/>    updateDisplay()<br/>end</span></pre><p id="2696" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要在我们的<code class="fe nm nn no np b">main.lua</code>文件中导入<code class="fe nm nn no np b">powerUpSpawner</code>，并在<code class="fe nm nn no np b">resetGame</code>函数中调用函数来操作<code class="fe nm nn no np b">PowerUp</code>spanger:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="018c" class="nu mp it np b be nv nw l nx ny">import "CoreLibs/object"<br/>import "CoreLibs/graphics"<br/>import "CoreLibs/sprites"<br/>import "CoreLibs/timer"<br/>import "globals"<br/>import "sceneController"<br/>import "playGameButton"<br/>import "player"<br/>import "ballSpawner"<br/>import "goal"<br/>import "scoreDisplay"<br/>import "powerUpSpawner"<br/>local gfx &lt;const&gt; = playdate.graphics<br/><br/>function resetGame()<br/>    loadHighscore()<br/>    resetScore()<br/>    clearBalls()<br/>    clearPowerUps()<br/>    stopBallSpawner()<br/>    stopPowerUpSpawner()<br/>    startBallSpawner()<br/>    startPowerUpSpawner()<br/>end<br/><br/>setStartingScene()<br/><br/>function playdate.update()<br/>    -- Update the sprites and the timer<br/>    gfx.sprite.update()<br/>    playdate.timer.updateTimers()<br/>end</span></pre><p id="b760" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你现在保存并运行你的游戏，你将会在游戏中看到随机的能量出现在屏幕上，如果你遇到它们，你将会感受到它们对游戏的影响。</p><p id="66f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你还会注意到，一个球可能会与一个电源发生碰撞，如果它发生了碰撞，就会消除电源。我加了这个，这样在加电的时候会有一点困难。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/43d754c75e16ae6c519107de3f9f1186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xem7N4IJYYxb3atbwhPTg.png"/></div></div><p class="oa ob gj gh gi oc od bd b be z dk translated">在你玩的时候会出现电源！</p></figure><h2 id="39a9" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">在游戏结束的场景中显示你的最终分数</h2><p id="e573" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">如果到目前为止你一直跟随教程，你可能会注意到当你完成游戏时，游戏结束画面上没有显示分数。</p><p id="7927" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在要改变这种状况。</p><p id="2280" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的<code class="fe nm nn no np b">scoreDisplay.lua</code>文件中，您应该添加一个本地最终分数sprite变量:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="b202" class="nu mp it np b be nv nw l nx ny">local finalScoreSprite</span></pre><p id="a312" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们将在同一个文件中添加一个函数来显示最终得分:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="34a1" class="nu mp it np b be nv nw l nx ny">function showFinalScore()<br/>    -- Final score sprite<br/>    finalScoreSprite = gfx.sprite.new()<br/>    finalScoreSprite:setCenter(0, 0)<br/>    finalScoreSprite:moveTo(190, 110)<br/>    finalScoreSprite:add()<br/>    local finalScoreText = score<br/>    local finalScoreTextWidth, finalScoreTextHeight = gfx.getTextSize(finalScoreText)<br/>    local finalScoreImage = gfx.image.new(finalScoreTextWidth, finalScoreTextHeight)<br/>    gfx.pushContext(finalScoreImage)<br/>        -- Wrapping the text with asterisks makes the text bold<br/>        gfx.drawText('*' .. finalScoreText .. '*', 0, 0)<br/>    gfx.popContext()<br/>    finalScoreSprite:setImage(finalScoreImage)<br/>end</span></pre><p id="a0e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这里，我们将最终得分放在显示的中间。我们还用星号将文本包裹起来，使其加粗。</p><p id="b188" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们需要从<code class="fe nm nn no np b">sceneController.lua</code>文件中的<code class="fe nm nn no np b">setGameOverScene</code>函数调用<code class="fe nm nn no np b">showFinalScore</code>函数:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="6628" class="nu mp it np b be nv nw l nx ny">-- Sets up the game over scene<br/>function setGameOverScene()<br/>    gameState = 'game over'<br/>    clearSprites()<br/>    stopBallSpawner()<br/>    PlayGameButton(200, 200)<br/>    showFinalScore()</span></pre><pre class="or nq np nr bn ns nt bi"><span id="14b9" class="nu mp it np b be nv nw l nx ny">setBackground('endingBackground')<br/>end</span></pre><p id="e621" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你现在保存并运行游戏，你应该会在游戏结束时看到你的最终分数！</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><h2 id="7811" class="of mp it bd mq og oh dn mu oi oj dp my ld ok ol na lh om on nc ll oo op ne oq bi translated">在游戏中播放背景音乐并改变其速度</h2><p id="2bce" class="pw-post-body-paragraph ku kv it kw b kx ng ju kz la nh jx lc ld ni lf lg lh nj lj lk ll nk ln lo lp im bi translated">背景音乐为你的游戏体验增加了另一层深度，可以让整个游戏更加身临其境，更加有趣。</p><p id="e767" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们需要创建一个名为<code class="fe nm nn no np b">soundController.lua</code>的新文件:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="f9bb" class="nu mp it np b be nv nw l nx ny">local sound &lt;const&gt; = playdate.sound.sampleplayer<br/>local backgroundMusic = sound.new('./sounds/background-music.wav')<br/>local rate = 1;<br/><br/>-- Plays the background music on a loop at the a specific rate<br/>function playBackgroundMusic()<br/>    backgroundMusic:play(0, rate)<br/>end<br/><br/>-- Increases the rate of the music by the value which is passed in<br/>function increaseMusicRate(newRate)<br/>    rate += newRate<br/>    backgroundMusic:setRate(rate)<br/>end<br/><br/>-- Halves the rate of the music (slows it down)<br/>function halveMusicRate()<br/>    rate = rate / 2<br/>    backgroundMusic:setRate(rate)<br/>end<br/><br/>-- Resets the music rate back to before any mutations by powerups were applied<br/>function resetMusicRate()<br/>    rate = 1 + (score * 0.01)<br/>    backgroundMusic:setRate(rate)<br/>end<br/><br/>-- Resets the music rate to the original default at the start of the game<br/>function resetDefaultMusicRate()<br/>    rate = 1<br/>    backgroundMusic:setRate(rate)<br/>end<br/><br/>-- Stops the background music<br/>function stopMusic()<br/>    backgroundMusic:stop()<br/>end</span></pre><p id="c365" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们讨论一下这里发生了什么。</p><p id="b389" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一开始，我们为<a class="ae ls" href="https://sdk.play.date/1.12.3/Inside%20Playdate.html#C-sound.sampleplayer" rel="noopener ugc nofollow" target="_blank"> Playdate SDK的声音工具</a>创建了一个简写。接下来，我们将名为<code class="fe nm nn no np b">backgroundMusic</code>的变量设置为背景轨迹的路径。对于这个游戏和教程，我创建了一个简单的WAV音频文件，一个可以轻松循环播放的节拍。最后，我们将速率设置为1。速率将影响音乐播放的速度。</p><p id="d17e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们拥有的第一个函数是<code class="fe nm nn no np b">playBackgroundMusic</code>,它使用<a class="ae ls" href="https://sdk.play.date/1.12.3/Inside%20Playdate.html#m-sound.sampleplayer.play" rel="noopener ugc nofollow" target="_blank">: play SDK函数</a>来播放音频。它需要两个参数:循环和速率。我们希望我们的音频连续循环，所以我们将其设置为零。例如，如果您希望它只循环两次，您可以将其设置为2。我们将利率作为本地利率变量传入。</p><p id="9d6c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一个函数是<code class="fe nm nn no np b">increaseMusicRate</code>，它有一个参数<code class="fe nm nn no np b">newRate</code>。我们将使用这个功能来加快音乐的速度。我们使用+=将汇率设置为当前汇率加上新汇率的值。然后我们使用<code class="fe nm nn no np b">setRate</code> SDK函数来更新音乐的速率。</p><p id="7a50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们有了<code class="fe nm nn no np b">halveMusicRate</code>函数，它完全按照它所说的去做。</p><p id="8ab0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们有一个功能来重置音乐速率。这会将音乐的速率设置为默认值，加上当前的分数乘以0.01，因为我们希望随着玩家累积更多的分数而稍微提高音乐的速度。</p><p id="50bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在那之后，我们有一个相似但不同的函数，它将速率重置为你在游戏开始时期望的默认值。如果我们想开始一个新游戏，我们将需要这个功能。</p><p id="e0b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们有一个功能可以完全停止播放音乐。当游戏结束，我们不想再听到游戏中的音乐时，这很有用。</p><p id="7058" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是声音控制器的全部内容。现在我们需要从某个地方触发这些功能。</p><p id="8216" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的<code class="fe nm nn no np b">sceneController.lua</code>文件中，更新<code class="fe nm nn no np b">setGameScene</code>函数，以便它调用<code class="fe nm nn no np b">soundController</code>来播放背景音乐:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="23a6" class="nu mp it np b be nv nw l nx ny">-- Sets up the game scene<br/>function setGameScene()<br/>    gameState = 'game'<br/>    clearSprites()<br/>    createScoreDisplay()<br/>    Player(200, 180)<br/>    Goal(200, 235)<br/>    playBackgroundMusic()<br/>    setBackground('background')<br/>end</span></pre><p id="5743" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这意味着任何时候游戏开始，背景音乐应该开始播放。</p><p id="727a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，在<code class="fe nm nn no np b">setGameOverScene</code>功能中，我们应该停止音乐播放:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="aecf" class="nu mp it np b be nv nw l nx ny">-- Sets up the game over scene<br/>function setGameOverScene()<br/>    gameState = 'game over'<br/>    stopMusic()<br/>    clearSprites()<br/>    stopBallSpawner()<br/>    PlayGameButton(200, 200)<br/>    showFinalScore()<br/>    setBackground('endingBackground')<br/>end</span></pre><p id="8df3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您将<code class="fe nm nn no np b">soundController</code>文件导入到您的<code class="fe nm nn no np b">main.lua</code>文件中，您现在应该可以在玩游戏时听到背景音乐。</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="7cd8" class="nu mp it np b be nv nw l nx ny">import "soundController"</span></pre><p id="24ae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这很好，但更有趣的是当你开始根据游戏中的动作改变音乐的速度，如得分和获得动力。</p><p id="19d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在您的<code class="fe nm nn no np b">scoreDisplay.lua</code>文件中，您可以更新<code class="fe nm nn no np b">incrementScore</code>函数，这样每当分数增加时，我们就会更新音乐的速率，使其稍微高一点:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="34b1" class="nu mp it np b be nv nw l nx ny">function incrementScore()<br/>    -- Updates the score<br/>    score += 1 * pointsMultiplier<br/>    updateDisplay()<br/>    -- Increases the speed of the music<br/>    increaseMusicRate(0.005)<br/>end</span></pre><p id="f589" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以更新<code class="fe nm nn no np b">activatePowerUp</code>功能<code class="fe nm nn no np b">powerUp.lua</code>文件，以便不同的加电对音频产生不同的影响:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="6cb6" class="nu mp it np b be nv nw l nx ny">-- Changes a global powerup to impact the gameplay<br/>function activatePowerUp(type)<br/>    if (type == 'all') then<br/>        -- Increase the music rate<br/>        increaseMusicRate(0.8)<br/>        -- Activate all powerups<br/>        keeperSpeedMultiplier = 2<br/>        ballSpeedMultiplier = 0.5<br/>        pointsMultiplier = 2<br/>    elseif (type == 'slow ball') then<br/>        -- Decreases the music rate<br/>        halveMusicRate()<br/>        -- Makes the balls slower<br/>        ballSpeedMultiplier = 0.5<br/>    elseif (type == 'fast keeper') then<br/>        -- Increases the music rate<br/>        increaseMusicRate(0.8)<br/>        -- Makes the keeper faster<br/>        keeperSpeedMultiplier = 2<br/>    elseif (type == 'double points') then<br/>        pointsMultiplier = 2<br/>    end<br/>end</span></pre><p id="138d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里，我们有几个不同的场景:</p><ul class=""><li id="84e2" class="ma mb it kw b kx ky la lb ld mc lh md ll me lp mf mg mh mi bi translated">当所有电源都激活时，我们将音乐的速率提高0.8</li><li id="45bf" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">当慢速球启动时，我们将音乐的速率减半</li><li id="4d19" class="ma mb it kw b kx mj la mk ld ml lh mm ll mn lp mf mg mh mi bi translated">当快速保持器启动时，我们将音乐的速率提高0.8</li></ul><p id="3968" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，我们应该更新<code class="fe nm nn no np b">powerUpSpawner.lua</code>文件中的<code class="fe nm nn no np b">spawnPowerUp</code>函数，以便当电源再次变为非活动状态时，音乐重置回其正常速率:</p><pre class="kj kk kl km gt nq np nr bn ns nt bi"><span id="44b4" class="nu mp it np b be nv nw l nx ny">-- Spawns a powerup at a random location<br/>function spawnPowerUp()<br/>    local spawnX = math.random(20, 380)<br/>    local spawnY = math.random(30, 140)<br/>    local spawnType = math.random(1, 4)<br/>    -- Resets and removes any powerups currently impacting gameplay to incentivise the player getting the new one<br/>    clearPowerUps()<br/>    resetPowerUps()<br/>    resetMusicRate()<br/>    -- Spawns a random powerup at a random position on screen<br/>    if (spawnType == 1) then<br/>        PowerUp(spawnX, spawnY, 'all', 'allPowerUp')<br/>    elseif (spawnType == 2) then<br/>        PowerUp(spawnX, spawnY, 'slow ball', 'slowBallPowerUp')<br/>    elseif (spawnType == 3) then<br/>        PowerUp(spawnX, spawnY, 'fast keeper', 'fastKeeperPowerUp')<br/>    elseif (spawnType == 4) then<br/>        PowerUp(spawnX, spawnY, 'double points', 'doublePointPowerUp')<br/>    end<br/>end</span></pre><p id="9b24" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你现在保存并再次玩你的游戏，你会感觉到音乐的速度随着你的进步而增加，并且你会注意到当你使用电源时有很大的变化。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><p id="8340" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！你已经完成了你的第一个游戏！恭喜你。</p><p id="914b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我鼓励你把我们一起打造的游戏改编成更独特的东西。也许有不同的音乐？可能守门员只能往某个方向移动？也许有陷阱和能量？</p><p id="e3e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我很乐意玩你创造的任何版本的游戏，所以如果你发布了一个，请评论一个链接！</p><p id="9dc7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你真的打算发布你的游戏，我推荐<a class="ae ls" href="https://itch.io/games/tag-playdate" rel="noopener ugc nofollow" target="_blank"> Itch </a>，它已经有了相当不错的游戏选择。据我所知，这是人们购买独立游戏的首选之地。</p><p id="a907" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当我试图通过侧载更新我的游戏时，有一件事让我很困惑，那就是我必须在每次侧载时更新<code class="fe nm nn no np b">pdxinfo</code>文件。你只需要更新版本号，但是如果你忘记了，侧面装载机就不会识别你对你的游戏做了任何更新。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><p id="ae05" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望你喜欢这篇向你介绍Lua和Playdate SDK的教程。如果你喜欢跟随，如果你能分享这篇文章或给它一些掌声，以帮助其他人在将来找到它，那就太好了！</p><p id="cd6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您一直在跟进，但只是想看到整个代码库完成，您可以在GitHub 上的这个开放repo中克隆名为<a class="ae ls" href="https://github.com/MichaelJFordham/playdate-game-demo/tree/part-4" rel="noopener ugc nofollow" target="_blank">‘part-4’的分支。</a></p><div class="pb pc gp gr pd pe"><a href="https://github.com/MichaelJFordham/playdate-game-demo/tree/part-4" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">GitHub—MichaelJFordham/play date-game-demo第4部分</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">这个回购将用于遵循迈克尔j福特汉姆的游戏指南。此回购有多个…</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">github.com</p></div></div><div class="pn l"><div class="po l pp pq pr pn ps ks pe"/></div></div></a></div><p id="ec62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想玩完整游戏吗？您现在可以在Itch上免费下载它:</p><div class="pb pc gp gr pd pe"><a href="https://mj4d.itch.io/keeper" rel="noopener  ugc nofollow" target="_blank"><div class="pf ab fo"><div class="pg ab ph cl cj pi"><h2 class="bd iu gy z fp pj fr fs pk fu fw is bi translated">守门员:游戏日的守门员游戏</h2><div class="pl l"><h3 class="bd b gy z fp pj fr fs pk fu fw dk translated">守门员是一个简单但具有挑战性的守门员游戏，由恐慌和青少年工程公司开发</h3></div><div class="pm l"><p class="bd b dl z fp pj fr fs pk fu fw dk translated">mj4d.itch.io</p></div></div><div class="pn l"><div class="pt l pp pq pr pn ps ks pe"/></div></div></a></div></div></div>    
</body>
</html>