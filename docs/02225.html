<html>
<head>
<title>4 Ruby Methods You Didn’t Know You Needed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你不知道你需要的4个Ruby方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-ruby-methods-you-didnt-know-you-needed-1b223ec1963c?source=collection_archive---------9-----------------------#2019-11-14">https://betterprogramming.pub/4-ruby-methods-you-didnt-know-you-needed-1b223ec1963c?source=collection_archive---------9-----------------------#2019-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5624" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">隐藏在Ruby发电站中的有趣方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7d22ac1337af81becfd0857a5530d730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8_PLKFRmuoNW0trFCR_0Iw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/discover?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@enka80?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">九科普夫</a>拍摄</p></figure><p id="7961" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我对Ruby编程语言有着特殊的热情，因为这是我学习的第一门语言。Ruby实用、简洁，但高度可扩展。语法和结构看起来很令人愉快，而且这种语言也有广泛的支持基础。</p><p id="02e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想整理一个有趣的列表，列出我在用Ruby开发时遇到的一些有趣的方法。</p><p id="f96b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Ruby有很多内置的方法。一些方法更有用，更常用，而另一些方法更短暂，或者最初不清楚它们的用途。下面我们将讨论一系列介于这两个极端之间的方法。</p><p id="6b82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>每个部分的标题都包含一个到相关<a class="ae ky" href="https://apidock.com/" rel="noopener ugc nofollow" target="_blank"> APIdock </a>页面的链接。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="3d86" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">1.<a class="ae ky" href="https://apidock.com/ruby/Object/tap" rel="noopener ugc nofollow" target="_blank">点击</a></h2><p id="3737" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">首先，我们有一个最有用的Ruby方法。这种方法对于复杂代码的故障排除和调试非常有帮助。允许你直接点击方法链的中间，并重定向一些输出。</p><p id="8188" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就像在Bash中使用管道一样。您可以将左侧的输出通过管道传输到右侧，并对其进行重定向。</p><p id="4fb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的链接有关于如何使用tap方法的更多详细信息，但下面是其功能的一个简单示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="0183" class="mc md it nd b gy ni nj l nk nl">[1] pry(main)&gt; var = "string".reverse.tap { |x| puts x }.upcase<br/>gnirts<br/>=&gt; "GNIRTS"<br/>[2] pry(main)&gt; var<br/>=&gt; "GNIRTS"<br/>[3] pry(main)&gt;</span></pre><p id="3d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们假设我们的目标是带着我们的小线和<code class="fe na nb nc nd b">reverse</code>然后<code class="fe na nb nc nd b">upcase</code>它。然后，我们希望将这个结果存储在一个名为<code class="fe na nb nc nd b">var</code>的变量中。让我们也假设我们想看看在反转阶段和上升阶段之间发生了什么。这就是tap的用武之地。</p><p id="a193" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以看到我们的最终输出被整齐地存储在<code class="fe na nb nc nd b">var</code>变量中，tap没有干预。但是我们也可以看到在<code class="fe na nb nc nd b">upcase</code>阶段之前的字符串状态。</p><p id="d697" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有几个方法链接在一起做一些繁重的工作，这对于在它们中间做一些调试是很棒的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="693e" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">2.<a class="ae ky" href="https://apidock.com/ruby/Enumerable/each_with_index" rel="noopener ugc nofollow" target="_blank"> each_with_index </a></h2><p id="c824" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这种方法肯定比前一种更常见，但有时在开发的狂热中很容易被遗忘。这就像经典的<code class="fe na nb nc nd b">each</code>方法，但是它给了你一个重要的好处:一个索引。</p><p id="de44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">each_with_index</code>不仅可以让你访问一个可枚举元素中的每一个单独的元素，还可以给你正在查看的元素的当前索引号。如果您可能需要根据可枚举的索引来跳转或跳过其中的元素，这可能会很有用。</p><p id="9a02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设您有一个数据数组，其中第二个和第三个元素是您想要丢弃的某种不重要的头值。您希望保留其余的数据，但在迭代数组时只需跳过这些值。你可以这样做:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="0f8e" class="mc md it nd b gy ni nj l nk nl">[1] pry(main)&gt; arr = ["one", "two", "three", "four", "five"]<br/>[1] pry(main)&gt; arr.each_with_index do |val, index|<br/>[1] pry(main)*   next if index.between?(1,2)<br/>[1] pry(main)*   &lt;do_something_with_val&gt;<br/>[1] pry(main)* end</span></pre><p id="a1c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是处理这种情况的一种非常迭代的方法，但是它概述了这种方法的功能以及您可以利用它的所有独特方式。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="5439" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">3.<a class="ae ky" href="https://apidock.com/ruby/Object/respond_to%3F" rel="noopener ugc nofollow" target="_blank"> respond_to？</a></h2><p id="312e" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">如果你曾经尝试过用<a class="ae ky" href="https://medium.com/tech-and-the-city/looks-like-a-duck-quacks-like-a-duck-db1283502acc" rel="noopener">鸭子打字</a>(超级文章的道具<a class="nm nn ep" href="https://medium.com/u/135df4e82305?source=post_page-----1b223ec1963c--------------------------------" rel="noopener" target="_blank"> Malina Tran </a>)或者读过任何Sandi Metz的书，那么你很可能接触过<code class="fe na nb nc nd b">respond_to?</code>方法。</p><p id="e53a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果对象响应传递的方法名，此方法返回true。这可以是一串符号，它是一个方法的名称。看看下面这个关于字符串的快速示例:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="1b22" class="mc md it nd b gy ni nj l nk nl">[1] pry(main)&gt; "string".respond_to?(:chomp)<br/>=&gt; true</span></pre><p id="1b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法不一定能洞察你正在使用的<em class="no">是什么，</em>却能洞察<em class="no">对</em>或<em class="no">类似于</em>的嘎嘎声的反应。</p><p id="2217" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，你是在物体之间传递信息——你不需要知道你与之交谈的物体的所有错综复杂的细节。事实上，你真的不应该。维护抽象是敏捷、可扩展接口的关键，这种方法允许您维护更多的抽象。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="47ea" class="mc md it bd me mf mg dn mh mi mj dp mk li ml mm mn lm mo mp mq lq mr ms mt mu bi translated">4.<a class="ae ky" href="https://apidock.com/ruby/String/squeeze" rel="noopener ugc nofollow" target="_blank">挤压</a></h2><p id="741b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这是一个非常简单的方法，它对字符串进行操作，并从本质上删除重复的字符。如果您简单地对包含多个相同字符的字符串调用<code class="fe na nb nc nd b">squeeze</code>方法，您将得到一个删除了重复字符的字符串:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="4af0" class="mc md it nd b gy ni nj l nk nl">[1] pry(main)&gt; "aabbccdd".squeeze<br/>=&gt; "abcd"</span></pre><p id="1679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以在一个参数上传递<code class="fe na nb nc nd b">squeeze </code>——应该被操作的字符串形式的一系列字符。如果您只想删除某些字符的重复项，这很有用。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d0b5" class="np md it bd me nq nr ns mh nt nu nv mk jz nw ka mn kc nx kd mq kf ny kg mt nz bi translated">结论</h1><p id="3f0b" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我希望您喜欢学习这些方法，并在您自己的项目中尝试它们——或者甚至只是在<code class="fe na nb nc nd b">irb</code>或<code class="fe na nb nc nd b">pry</code>中使用它们来了解它们是如何工作的。</p></div></div>    
</body>
</html>