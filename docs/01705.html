<html>
<head>
<title>Javascript: How Backticks Work (``)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript:反斜线如何工作(``)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-how-backticks-work-de269e0fb8ba?source=collection_archive---------4-----------------------#2019-10-07">https://betterprogramming.pub/javascript-how-backticks-work-de269e0fb8ba?source=collection_archive---------4-----------------------#2019-10-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e6f4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索JavaScript中反斜线的主要用途</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82beb378decbb6fbb890e1bb4bf462d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YBo7lgicrJqe1Owt"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@nguyendqnhu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Nhu Nguyen </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="c9ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">众所周知，在JavaScript中有两种主要的方法来声明字符串:</p><ul class=""><li id="154e" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">使用单引号<code class="fe me mf mg mh b">''</code>。</li><li id="11d7" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">使用双引号<code class="fe me mf mg mh b">""</code>。</li></ul><p id="a6f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，使用ES2015规范，可以创建所谓的<em class="mn">模板文字</em>或<em class="mn">模板字符串</em>，这足以将文本封装在反斜杠中:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="ed2b" class="ms mt it mh b gy mu mv l mw mx">`some text`</span></pre><p id="d50c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我将在本文中描述的两种主要方法相比，这将给我们带来许多优势。让我们看看他们。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="b7d7" class="nf mt it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">连接和插入字符串</h1><p id="f7ee" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这可能是反斜线最广泛和最流行的用法之一，因为它允许我们连接和插入字符串，所以我们的代码更干净。</p><p id="0e47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将看几个例子，比较旧的语法和反斜线提供的语法。</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="9ff2" class="ms mt it mh b gy mu mv l mw mx">const name = 'Gerardo';<br/>const surname = 'Fernández';<br/>const telephone = '123 123 123';</span><span id="a951" class="ms mt it mh b gy ob mv l mw mx">// "Old syntax"</span><span id="0898" class="ms mt it mh b gy ob mv l mw mx">const userInfo = 'User info: ' + name + ' ' + surname + ' ' + telephone;</span><span id="4061" class="ms mt it mh b gy ob mv l mw mx">// "New syntax"</span><span id="f454" class="ms mt it mh b gy ob mv l mw mx"><strong class="mh iu">const userInfo = `User info: ${name} ${surname} ${telephone}`;</strong></span></pre><p id="9fb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你所看到的，感谢模板文字，我们获得了一个更容易阅读的代码，通过<code class="fe me mf mg mh b">+</code>操作符节省了多个字符串的连接。</p><p id="3109" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们也可以在模板字符串中执行代码:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="fa98" class="ms mt it mh b gy mu mv l mw mx">const user = getUserFromApi();</span><span id="a5a5" class="ms mt it mh b gy ob mv l mw mx">// "Old syntax"</span><span id="f3a3" class="ms mt it mh b gy ob mv l mw mx">const userInfo = 'User info: ' + user.getName() + ' ' + user.getEmail();</span><span id="11c0" class="ms mt it mh b gy ob mv l mw mx">// "New syntax"</span><span id="c07a" class="ms mt it mh b gy ob mv l mw mx"><strong class="mh iu">const userInfo = `User info: ${user.getName()} ${user.getEmail()}`;</strong></span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="ae78" class="nf mt it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">没有必要转义字符“和Using \</h1><p id="3cba" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">使用反斜线(<code class="fe me mf mg mh b">``</code>)的另一个好处是，不再需要对双引号(<code class="fe me mf mg mh b">""</code>)或单引号(<code class="fe me mf mg mh b">''</code>)进行转义，当我们使用英语等语言时，通常会被迫这样做:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="08a1" class="ms mt it mh b gy mu mv l mw mx">const foo = 'Can\'t connect to the server';</span><span id="ade7" class="ms mt it mh b gy ob mv l mw mx"><strong class="mh iu">const bar = `Can't connect to the server`;</strong></span></pre><p id="3349" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者例如:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="1d38" class="ms mt it mh b gy mu mv l mw mx">const foo = "Error: \"Introduce a valid email\"";</span><span id="3c46" class="ms mt it mh b gy ob mv l mw mx">const bar = `Error: "Introduce a valid email"`;</span></pre><p id="2ba5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，再一次，我们得到了更多可读的代码。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="7a78" class="nf mt it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">多行字符串</h1><p id="5351" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">在JavaScript中，不可能在几行中声明字符串。例如，如果我们尝试以下方法:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="f6d6" class="ms mt it mh b gy mu mv l mw mx">const html = "&lt;article&gt;<br/>&lt;h1&gt;Article title&lt;/h1&gt;<br/>&lt;/article&gt;";</span></pre><p id="e561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到以下错误:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="bba0" class="ms mt it mh b gy mu mv l mw mx">SyntaxError: "" string literal contains an unescaped line break</span></pre><p id="8711" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这很尴尬，尤其是当我们创建HTML的时候。在ECMA2015之前，我们的替代方案是使用新的行字符(<code class="fe me mf mg mh b">\n</code>):</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="fb2a" class="ms mt it mh b gy mu mv l mw mx">const html = "&lt;article&gt; \<br/>&lt;h1&gt;Article title&lt;/h1&gt; \<br/>&lt;/article&gt;";</span></pre><p id="8b85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这仍然会在编译时带来问题:</p><blockquote class="oc od oe"><p id="ac85" class="kz la mn lb b lc ld ju le lf lg jx lh of lj lk ll og ln lo lp oh lr ls lt lu im bi translated">每行开头的空白在编译时不能被安全地去除；斜杠后的空格会导致棘手的错误；虽然大多数脚本引擎支持这一点，但它不是ECMAScript的一部分。— <a class="ae ky" href="https://stackoverflow.com/questions/805107/creating-multiline-strings-in-javascript/6247331#6247331" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a></p></blockquote><p id="a87d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个选择是使用<code class="fe me mf mg mh b">+</code>操作符:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="bd5b" class="ms mt it mh b gy mu mv l mw mx">const html = '&lt;article&gt;' +<br/>'&lt;h1&gt;Article title&lt;/h1&gt;' +<br/>'&lt;/article&gt;';</span></pre><p id="57e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，使用反勾号，我们可以编写以下内容:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="8b87" class="ms mt it mh b gy mu mv l mw mx">const html = `&lt;article&gt;<br/>&lt;h1&gt;Article title&lt;/h1&gt;<br/>&lt;/article&gt;`;</span></pre><p id="47d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们得到的代码非常干净。</p><p id="8d2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，重要的是要记住空格没有被删除，所以如果我们创建一个字符串如下…</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="81db" class="ms mt it mh b gy mu mv l mw mx">const string = `First line<br/>                Second line`</span></pre><p id="1a67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们将得到以下内容:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="77a3" class="ms mt it mh b gy mu mv l mw mx">First<br/>                Second</span></pre><p id="1849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们将不得不求助于<code class="fe me mf mg mh b">trim</code>方法来避免额外的空间。</p></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="3aeb" class="nf mt it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">标记模板</h1><p id="18aa" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">backticks提供的另一个特性是创建所谓的<em class="mn">标记模板</em>(也称为<em class="mn">标记函数</em>)的可能性，这是像Apollo或<a class="ae ky" href="https://flaviocopes.com/styled-components/" rel="noopener ugc nofollow" target="_blank">风格组件</a>一样流行的库所使用的东西:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="66e6" class="ms mt it mh b gy mu mv l mw mx">// Apollo query</span><span id="a949" class="ms mt it mh b gy ob mv l mw mx">const query = <strong class="mh iu">gql</strong>`<br/>  query {<br/>    ...<br/>  }</span><span id="0246" class="ms mt it mh b gy ob mv l mw mx">// Styled components</span><span id="52da" class="ms mt it mh b gy ob mv l mw mx">const Container = <strong class="mh iu">styled.div</strong>`<br/>  width: 1000px;<br/>  background: red;<br/>`;</span></pre><p id="d125" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe me mf mg mh b">styled.div</code>和<code class="fe me mf mg mh b">gql</code>实际上都是从文本模板中提取参数的函数(标记函数)(也就是说，用反斜线将文本括起来)。</p><p id="9506" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在样式化组件<code class="fe me mf mg mh b">Container</code>的情况下，我们得到的是一个React组件，它表示一个具有以下方面的<code class="fe me mf mg mh b">div</code>:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="b3b0" class="ms mt it mh b gy mu mv l mw mx">&lt;div style="width: 1000px; background:red"&gt;<br/>...<br/>&lt;/div&gt;</span></pre><p id="4ebb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这些类型的函数如何工作，假设我们有如下声明的<code class="fe me mf mg mh b">sayHello</code>函数:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="dc50" class="ms mt it mh b gy mu mv l mw mx">function foo() {<br/>  console.log(arguments[0]);<br/>  console.log(arguments[1]);<br/>  console.log(arguments[2]);<br/>}</span></pre><p id="fc0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们现在像调用一个函数标签一样调用它:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="8ba7" class="ms mt it mh b gy mu mv l mw mx">const varOne = 'bar';<br/>const varTwo = 'zeta';</span><span id="e896" class="ms mt it mh b gy ob mv l mw mx">foo`This is bar: ${varOne} and zeta: ${varTwo}`;</span></pre><p id="3a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将在控制台上看到:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="2c59" class="ms mt it mh b gy mu mv l mw mx">["This is bar: ", " and zeta: ", ""] (array)<br/>bar (string)<br/>zeta (string)</span></pre><p id="5220" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是说，函数标签接收三个参数:</p><ul class=""><li id="cccd" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">第一个是一个数组，其中文字匹配出现在几个字符串中，使用表达式<code class="fe me mf mg mh b">${...}</code>作为断点</li><li id="9e42" class="lv lw it lb b lc mi lf mj li mk lm ml lq mm lu ma mb mc md bi translated">其余的参数(<code class="fe me mf mg mh b">arguments[1]</code>和<code class="fe me mf mg mh b">arguments[2]</code>)是已经插值的变量的结果(<code class="fe me mf mg mh b">bar</code> y <code class="fe me mf mg mh b">zeta</code>)</li></ul><p id="725f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">利用扩展操作符，我们可以将<code class="fe me mf mg mh b">foo</code>函数重写如下:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="3df2" class="ms mt it mh b gy mu mv l mw mx">function foo(literals, ...expressions) {<br/>  console.log(literals);<br/>  console.log(expressions[0]);<br/>  console.log(expressions[1]);<br/>}</span></pre><p id="4c80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，<code class="fe me mf mg mh b">literals</code>数组的长度将始终是<code class="fe me mf mg mh b">expressions</code>数组的长度加1。</p><p id="5c0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这一刻起，标签函数提供的可能性是非常多样的，正如Apollo和Styled Components库所展示的，或者，例如，下面的例子，我们可以看到这些类型的函数如何用于翻译我们的应用程序中的文本:</p><pre class="kj kk kl km gt mo mh mp mq aw mr bi"><span id="2ccc" class="ms mt it mh b gy mu mv l mw mx">const name = 'Gerardo';<br/>const email = 'info@mail.com';</span><span id="681b" class="ms mt it mh b gy ob mv l mw mx">console.log(i18n`Hi ${name}, your email is ${email}`);</span><span id="8c55" class="ms mt it mh b gy ob mv l mw mx">// Hola Gerardo, tu email es info@mail.com</span></pre></div><div class="ab cl my mz hx na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="im in io ip iq"><h1 id="e0ca" class="nf mt it bd ng nh ni nj nk nl nm nn no jz np ka nq kc nr kd ns kf nt kg nu nv bi translated">最后的想法</h1><p id="7197" class="pw-post-body-paragraph kz la it lb b lc nw ju le lf nx jx lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">正如您所看到的，虽然最初它可能是一个不被注意的JavaScript特性，但标记模板文字在编写代码时给了我们很多灵活性，并且由于诸如Apollo和Styled Components之类的库而变得越来越流行。</p><p id="1639" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章能够帮助你对它们有一个初步的了解，或者巩固一些概念，比如标签函数。</p></div></div>    
</body>
</html>