<html>
<head>
<title>7 New ES2022 JavaScript Features You Might Have Missed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能错过的7个ES2022 JavaScript新特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/new-features-in-javascript-2022-b3ffadd1b261?source=collection_archive---------1-----------------------#2022-09-16">https://betterprogramming.pub/new-features-in-javascript-2022-b3ffadd1b261?source=collection_archive---------1-----------------------#2022-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="272a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">旧JavaScript与新JavaScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3ac722e70537bc4948398d1d0eab1cee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zynlkFHQpuqYmLrD"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Gabriel Heinzer 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9589" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些功能已经发布了一段时间。让我们检查一下！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9682" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">1.私有字段</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/acf689260fd7138c3419657d3a094842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MgsBKTurzPU0RFFYekKRag.png"/></div></div></figure><p id="c1fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以前，所有类字段都必须在构造函数中定义。而且没有私有领域。所有字段都可以从外部访问。当然，有一些技巧可以让一些变量变得不可访问。但是我们不要谈论他们。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="5786" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">class</strong> Counter {<br/>  <strong class="mt ir">constructor</strong>() {<br/>    <strong class="mt ir">this</strong>.name = 'Counter';<br/>    <strong class="mt ir">this</strong>.count = 0;<br/>  }<br/>  <br/>  inc() {<br/>    <strong class="mt ir">this</strong>.count++;<br/>  }<br/>}</span></pre><p id="c759" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以简单地写:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="5e85" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">class</strong> Counter {<br/>  name = 'Counter';<br/>  #count = 0;  <em class="nc">// private field!</em></span><span id="d345" class="mx ma iq mt b gy nd mz l na nb">  inc() {<br/>    <strong class="mt ir">this</strong>.#count++;<br/>  }<br/>}</span></pre><h1 id="3c01" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">2.检查使用关键字中的<em class="nj">访问私有字段</em></h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/b528a4b5366fcd6391262c44e9e82394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcwrPxRm-9Ixo5FaZv2i3w.png"/></div></div></figure><p id="541c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">私有字段会带来一些问题。当在没有私有字段的对象上访问私有字段时，将会引发错误。但是如何检查一个对象有没有呢？用<code class="fe nk nl nm mt b">try</code> / <code class="fe nk nl nm mt b">catch</code>！</p><p id="fe03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在有一个更好的方法:<code class="fe nk nl nm mt b">in</code>关键词。</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="b53c" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">class</strong> Counter {<br/>  name = 'Counter';<br/>  #count = 0;</span><span id="13a5" class="mx ma iq mt b gy nd mz l na nb"><strong class="mt ir">static</strong> isCounter(obj) {<br/>    <strong class="mt ir">return</strong> #count <strong class="mt ir">in</strong> obj;<br/>  }<br/>}</span><span id="a51c" class="mx ma iq mt b gy nd mz l na nb"><strong class="mt ir">const</strong> counter = <strong class="mt ir">new</strong> Counter();<br/>Counter.isCounter(counter);   // true</span></pre><h1 id="3923" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">3.<em class="nj"> at() </em>数组和字符串的方法</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/61425c61e3e2d0d24a6068a3f713fd62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-b1Em46FOn_o7pAGAal9Wg.png"/></div></div></figure><p id="bc58" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过写<code class="fe nk nl nm mt b">A[i]</code>来访问数组中位置<code class="fe nk nl nm mt b">i</code>的一个项。但是如果<code class="fe nk nl nm mt b">i</code>是负的，我们想从数组的末尾获取元素呢？我们可以写<code class="fe nk nl nm mt b">A[A.length + i]</code>。但是不太方便。另一种方法是使用<code class="fe nk nl nm mt b">A.slice(i)[0]</code>。但是效率不是很高。</p><p id="72db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此有<code class="fe nk nl nm mt b">at()</code>方法:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="5376" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">const</strong> A = [2, 4, 6, 8, 10]<br/>A.at(-1)    <em class="nc">// 10</em></span><span id="e803" class="mx ma iq mt b gy nd mz l na nb"><strong class="mt ir">const</strong> S = "Hello World"<br/>S.at(-1)    <em class="nc">// 'd'</em></span></pre><h1 id="fc83" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">4.用findLast()从末尾开始查找数组中的一项</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/b9d961b8f122d20a4575fe71ee1672ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lrg0nXRx4ooFK8zBTv9BOw.png"/></div></div></figure><p id="f9f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何在数组中查找一个项？使用<code class="fe nk nl nm mt b">find()</code>方法。以及如何从末端找到？使用<code class="fe nk nl nm mt b">reverse()</code>和<code class="fe nk nl nm mt b">find()</code>。或者编写自己的函数:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3fa5" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">const</strong> A = [1, 20, 3, 40, 5];</span><span id="1f8a" class="mx ma iq mt b gy nd mz l na nb"><strong class="mt ir">function</strong> findBackward(A, predicate) {<br/>  <strong class="mt ir">for</strong> (<strong class="mt ir">let</strong> i = A.length-1; i&gt;=0; i--) {<br/>    <strong class="mt ir">if</strong> (predicate(A[i])) {<br/>      <strong class="mt ir">return</strong> A[i];<br/>    }<br/>  }<br/>  <strong class="mt ir">return</strong> -1;<br/>}</span><span id="0058" class="mx ma iq mt b gy nd mz l na nb">findBackward(A, x =&gt; x % 10 == 0);    <em class="nc">// 40</em></span><span id="8dbc" class="mx ma iq mt b gy nd mz l na nb"><em class="nc">// be careful with this method!</em><br/>A.reverse().find(x =&gt; x % 10 == 0);   <em class="nc">// 40</em></span></pre><p id="cc15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以使用<code class="fe nk nl nm mt b">findLast()</code>和<code class="fe nk nl nm mt b">findLastIndex()</code>方法:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="c06b" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">const</strong> A = [1, 20, 3, 40, 5];</span><span id="ed6b" class="mx ma iq mt b gy nd mz l na nb">A.find(v =&gt; v%10 == 0)     // 20<br/>A.findLast(v =&gt; v%10 == 0) // 40</span><span id="e81b" class="mx ma iq mt b gy nd mz l na nb">A.findIndex(v =&gt; v%10 == 0)     // 1<br/>A.findLastIndex(v =&gt; v%10 == 0) // 3<br/>A.findLastIndex(v =&gt; v == 0)    // -1</span></pre><h1 id="562f" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">5.让我们使用hasOwn()而不是hasOwnProperty()</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/1a8369112a22227724c91c7f3627910c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wMHodOUXotOF-_GwlSESQ.png"/></div></div></figure><p id="0b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有<code class="fe nk nl nm mt b">Object.prototype.hasOwnProperty()</code>方法检查对象是否有属性作为其直接属性。但是使用起来相当麻烦:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="ef2a" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">let</strong> hasOwnProperty = Object.prototype.hasOwnProperty;</span><span id="b554" class="mx ma iq mt b gy nd mz l na nb"><strong class="mt ir">if</strong> (hasOwnProperty.call(object, 'foo')) {<br/>  console.log('has property foo');<br/>}</span></pre><p id="eb23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么不直接写:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="3a51" class="mx ma iq mt b gy my mz l na nb">object.hasOwnProperty('foo')</span></pre><p id="059a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请记住，JavaScript是一种动态语言。我们可以给任何对象添加属性。所以<code class="fe nk nl nm mt b">hasOwnProperty()</code>可以被同名对象的属性所遮蔽。为了避免这种情况，我们可以使用<code class="fe nk nl nm mt b">hasOwn()</code>方法:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="9d59" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">if</strong> (Object.hasOwn(object, 'foo')) {<br/>  console.log('has property foo');<br/>}</span></pre><h1 id="89da" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">6.原因是错误的一个新属性</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/6bacc71bcb5d0033917f588e1e823ff6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUZDMdDTrtffJcbcqXIGrQ.png"/></div></div></figure><p id="8988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">常见的错误处理代码如下:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="35f8" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">await</strong> fetch('<a class="ae kv" href="https://example.com/data.csv'" rel="noopener ugc nofollow" target="_blank">https://example.com/data.csv'</a>)<br/>  .catch((err) =&gt; {<br/>     <strong class="mt ir">throw</strong> <strong class="mt ir">new</strong> Error('failed to get: ' + err.message);<br/>  })</span></pre><p id="2d3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它所做的是用一个新的错误包装原来的错误。但是原来的误差丢失了。现在我们可以使用<code class="fe nk nl nm mt b">cause</code>属性来存储原始错误并在以后检索它:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="2703" class="mx ma iq mt b gy my mz l na nb"><strong class="mt ir">await</strong> fetch('<a class="ae kv" href="https://example.com/data.csv'" rel="noopener ugc nofollow" target="_blank">https://example.com/data.csv'</a>)<br/>  .catch((err) =&gt; {<br/>     <strong class="mt ir">throw</strong> <strong class="mt ir">new</strong> Error('failed to get', { cause: err })<br/>  })<br/>  .catch((err) =&gt; {<br/>     console.log('cause', err.cause)<br/>  })</span></pre><h1 id="31dc" class="lz ma iq bd mb mc ne me mf mg nf mi mj jw ng jx ml jz nh ka mn kc ni kd mp mq bi translated">7.<code class="fe nk nl nm mt b">#!</code>现在支持Hashbang</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/7459c297beb5af1d88b4ebcfa7581d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7WeXAADh63BapLNviUsqA.png"/></div></div></figure><p id="fb94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在支持Hashbang。我们可以在终端中直接运行NodeJS脚本:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="bead" class="mx ma iq mt b gy my mz l na nb"><em class="nc">#!/usr/bin/env node</em></span><span id="579d" class="mx ma iq mt b gy nd mz l na nb">'use strict';<br/>console.log(1);</span></pre><p id="5d69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者:</p><pre class="kg kh ki kj gt ms mt mu mv aw mw bi"><span id="534d" class="mx ma iq mt b gy my mz l na nb"><em class="nc">#!/usr/bin/env node</em></span><span id="c970" class="mx ma iq mt b gy nd mz l na nb">export {};<br/>console.log(1);</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="402d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nc">我是Oliver Nguyen，一名全栈开发人员。我分享一下编程，JavaScript，围棋。我创建了</em><a class="ae kv" href="https://onesidebar.com" rel="noopener ugc nofollow" target="_blank"><em class="nc">one sidebar</em></a><em class="nc">—一个用于导航GitHub的浏览器扩展。关注我了解更多内容。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure></div></div>    
</body>
</html>