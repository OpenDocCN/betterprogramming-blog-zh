<html>
<head>
<title>JavaScript Best Practices: More Things to Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践:更多需要避免的事情</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-best-practice-more-things-to-avoid-93206b1ee5ef?source=collection_archive---------12-----------------------#2020-02-17">https://betterprogramming.pub/javascript-best-practice-more-things-to-avoid-93206b1ee5ef?source=collection_archive---------12-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d7b4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们来看看for…in循环、==操作符、arguments对象和“this”的误用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6315caef2a86e06fadb8a2860d1309b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P1LtKeoRzsXC_OqJoUuvCw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@franckinjapan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Franck V. </a>在<a class="ae ky" href="https://unsplash.com/s/photos/avoid?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="076f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript有很多棘手的部分，所以有很多东西要避免。</p><p id="5846" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以遵循一些最佳实践来使我们的JavaScript代码易于阅读。</p><p id="3a98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看到更多我们应该避免的构造，包括对<code class="fe lv lw lx ly b">for...in</code>循环、<code class="fe lv lw lx ly b">==</code>操作符、<code class="fe lv lw lx ly b">arguments</code>对象和<code class="fe lv lw lx ly b">this</code>的误用。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="5bd3" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">误用For…in循环</h1><p id="4f38" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">for...in</code>循环不应该用于遍历数组和类似数组的对象。例如，如果我们有:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="fbf4" class="nh mh it ly b gy ni nj l nk nl">const arr = ['a', 'b', 'c', 'd', 'e'];<br/>for (let i in arr) {<br/>  console.log(i)<br/>}</span></pre><p id="5561" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们回来了:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8fd5" class="nh mh it ly b gy ni nj l nk nl">0<br/>1<br/>2<br/>3<br/>4</span></pre><p id="1d1a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这是对<code class="fe lv lw lx ly b">for...in</code>循环的误用，因为它应该遍历对象及其原型的可枚举属性，而不是遍历数组的索引。</p><p id="066a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举的顺序没有保证，所以我们可能不会按顺序遍历数组，这是不好的。</p><p id="750b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">for...in</code>循环还遍历可枚举的继承属性，这是另一个问题。</p><p id="b735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="2b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用带有<code class="fe lv lw lx ly b">foo</code>属性的原型对象创建一个对象。<code class="fe lv lw lx ly b">for...in</code>循环将遍历<code class="fe lv lw lx ly b">obj</code>原型和<code class="fe lv lw lx ly b">obj</code>的可枚举属性。</p><p id="3d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免遍历其原型的属性，我们可以使用<code class="fe lv lw lx ly b">Object.keys</code>来代替:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e731" class="nh mh it ly b gy ni nj l nk nl">for (let prop of Object.keys(obj)) {<br/>  console.log(prop);<br/>}</span></pre><p id="af59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以循环遍历<code class="fe lv lw lx ly b">obj</code>的键-值对，不需要任何来自其原型的东西，我们可以使用<code class="fe lv lw lx ly b">Object.entries</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="19d1" class="nh mh it ly b gy ni nj l nk nl">for (let entry of Object.entries(obj)) {<br/>  console.log(entry);<br/>}</span></pre><p id="fa83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于遍历数组和类似数组的对象，我们应该使用<code class="fe lv lw lx ly b">for...of</code>循环:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b72d" class="nh mh it ly b gy ni nj l nk nl">const arr = ['a', 'b', 'c', 'd', 'e'];<br/>for (let a of arr) {<br/>  console.log(a)<br/>}</span></pre><p id="7af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们得到数组的条目。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9f6e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">搞乱这个</h1><p id="a63d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对象一直是JavaScript中的一个问题。这是因为它根据范围而变化。</p><p id="feab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，在ES6中，我们有箭头函数，如果我们在内部引用它，它不会改变<code class="fe lv lw lx ly b">this</code>的值。这也意味着我们不能用<code class="fe lv lw lx ly b">call</code>、<code class="fe lv lw lx ly b">bind</code>或<code class="fe lv lw lx ly b">apply</code>来改变<code class="fe lv lw lx ly b">this</code>的值。</p><p id="3a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，下面的代码将记录<code class="fe lv lw lx ly b">window</code>对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5ef8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使我们试图用<code class="fe lv lw lx ly b">bind</code>改变<code class="fe lv lw lx ly b">this</code>的值，它也不会改变。</p><p id="2027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，ES6有创建构造函数的类语法，所以很明显，只要我们使用类方法和箭头函数，<code class="fe lv lw lx ly b">this</code>就应该在类中。</p><p id="091f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类方法将类作为<code class="fe lv lw lx ly b">this</code>的值，类中的箭头函数将具有与<code class="fe lv lw lx ly b">this</code>相同的值。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2819fd9151ceee6466631275c4344ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nQrKY-jv3ocT9AWl"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@westbeach013?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯西·艾伦</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9be2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">==运算符</h1><p id="27ad" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在比较操作数是否相等之前，<code class="fe lv lw lx ly b">==</code>运算符会自动进行类型转换。这造成了不同类型的数据被视为相同的问题。</p><p id="ec17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如<code class="fe lv lw lx ly b">null == undefined</code>返回<code class="fe lv lw lx ly b">true</code>，我们很可能不想要。</p><p id="cc23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">null == undefined</code>返回<code class="fe lv lw lx ly b">true</code>，因为它们都是假的。</p><p id="effb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免这类问题，我们应该使用<code class="fe lv lw lx ly b">===</code>操作符，这样可以避免比较返回<code class="fe lv lw lx ly b">true</code>的这类操作数。这是因为<code class="fe lv lw lx ly b">===</code>除了检查操作数的内容外，还检查每个操作数的类型。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9712" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">参数对象</h1><p id="e29b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">随着rest操作符的引入，我们最终可以避免使用<code class="fe lv lw lx ly b">arguments</code>对象来获取传递给函数的参数。</p><p id="9832" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几个原因不应该使用<code class="fe lv lw lx ly b">arguments</code>对象。一个是它是一个类似数组的对象，这意味着像<code class="fe lv lw lx ly b">length</code>这样的属性在其中，它可以用一个<code class="fe lv lw lx ly b">for</code>循环来循环，但是像<code class="fe lv lw lx ly b">map</code>和<code class="fe lv lw lx ly b">forEach</code>这样的数组方法不在其中。</p><p id="c30c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以用它的索引来访问它的条目，这具有欺骗性，因为它实际上不是一个数组。</p><p id="655d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">arguments</code>还会阻止浏览器引擎的任何代码优化，这意味着性能会更慢。另外，<code class="fe lv lw lx ly b">arguments</code>对象在箭头函数中不可用。</p><p id="b316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，要访问所列参数之外的额外参数，我们应该使用rest操作符。</p><p id="7bbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，不要写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以写:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3466" class="nh mh it ly b gy ni nj l nk nl">const add = (...args) =&gt; args.reduce((a, b) =&gt; a + b, 0);<br/>console.log(add(1, 2, 3, 4, 5));</span></pre><p id="9b96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，使用rest操作符要短得多，它是函数签名的<code class="fe lv lw lx ly b">...args</code>部分。<code class="fe lv lw lx ly b">args</code>已经是一个数组，所以我们有所有可用的数组方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7181" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="e848" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在现代JavaScript中，我们可以抛弃许多旧的结构，使我们的代码更容易阅读和维护。</p><p id="b25e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用rest操作符来代替<code class="fe lv lw lx ly b">arguments</code>对象。这是因为rest操作符给了我们一个参数数组，而不是类似数组的<code class="fe lv lw lx ly b">arguments</code>对象。</p><p id="eddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们应该避免使用<code class="fe lv lw lx ly b">==</code>操作符进行相等比较，因为它会在比较之前自动进行类型转换，这可能是我们不希望的。</p><p id="4482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还应该通过使用箭头函数和构造函数的类语法来避免弄乱<code class="fe lv lw lx ly b">this</code>。这两个构造使得<code class="fe lv lw lx ly b">this</code>的值更加清晰。我们只对类使用类方法，对不是类方法的函数使用箭头函数。</p><p id="ad61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe lv lw lx ly b">for...in</code>循环不应该用于遍历数组和类似数组的对象，因为枚举的顺序不能保证是有序的，这会导致意想不到的结果。</p></div></div>    
</body>
</html>