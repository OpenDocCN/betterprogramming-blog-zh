<html>
<head>
<title>How to Make JSON and Python Talk to Each Other</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何让JSON和Python互相对话</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-make-json-and-python-talk-to-each-other-41531d58e59d?source=collection_archive---------3-----------------------#2022-03-30">https://betterprogramming.pub/how-to-make-json-and-python-talk-to-each-other-41531d58e59d?source=collection_archive---------3-----------------------#2022-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9015" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用Python处理和创建JSON数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/385ca3b55d8239472d552f2a5608f26e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LrpP3F2TpqvDvtR1"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@lordarcadius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">维普·贾</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1785" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript Object Notation (JSON)是一种流行的数据格式，常用于不同系统之间的数据交换。例如，许多API以JSON数据的格式返回结果。鉴于JSON出色的可读性和类似对象的结构，了解Python如何处理JSON数据是很有用的。在本文中，我们将了解JSON是什么，以及如何用Python中内置的<code class="fe lv lw lx ly b">json</code>模块来处理它。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="417e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">JSON的数据结构</h1><p id="81a3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">JSON数据的结构是JSON对象，它以键值对的形式保存数据，就像Python字典一样。下面的代码片段向您展示了典型的JSON对象的样子。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="23fa" class="nh mh it ly b gy ni nj l nk nl">{</span><span id="bda2" class="nh mh it ly b gy nm nj l nk nl">  "firstName": "John",</span><span id="6e15" class="nh mh it ly b gy nm nj l nk nl">  "lastName": "Smith",</span><span id="c670" class="nh mh it ly b gy nm nj l nk nl">  "age": <strong class="ly iu">35</strong>,</span><span id="ba98" class="nh mh it ly b gy nm nj l nk nl">  "city": "San Francisco"</span><span id="a858" class="nh mh it ly b gy nm nj l nk nl">}</span></pre><p id="1f2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本质上，JSON对象由一对花括号限定范围，其中存储了键值对。JSON对象要求它们的键只能是字符串，这个要求允许不同系统之间的标准通信。显示的值包括字符串和整数，但是JSON支持其他数据类型，包括布尔值、数组和对象。</p><ul class=""><li id="b2fe" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">字符串:用双引号括起来的字符串</li><li id="e91c" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">数字:数字文字，包括整数和小数</li><li id="2f04" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">Boolean:布尔值，真或假</li><li id="ffb5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">数组:支持的数据类型列表</li><li id="ec62" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">对象:用花括号括起来的键值对</li><li id="4c59" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">Null:任何有效数据类型的空值(null)</li></ul><p id="8d03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些类型中，需要特别注意的是，与可以使用单引号或双引号的Python字符串不同，JSON字符串只能用双引号括起来。不恰当地使用单引号会使JSON数据无效，普通的JSON解析器无法处理这些数据。</p><p id="22bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这些受支持的数据类型，知道JSON支持嵌套数据结构也很重要。例如，您可以将一个JSON对象嵌入到另一个对象中。对于另一个实例，数组可以由任何支持的数据类型组成，包括对象。下面是一些例子:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3bb4" class="nh mh it ly b gy ni nj l nk nl">an object resides in another object:<br/>{<br/>  "one": 1, <br/>  "two": {"one": 1}<br/>}</span><span id="4dd3" class="nh mh it ly b gy nm nj l nk nl">an array consists of multiple objects:<br/>[<br/>  {"one": 1},<br/>  {"two": 2},<br/>  {"three": 3}<br/>]</span></pre><p id="4420" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">混合不同数据类型的灵活性允许我们用清晰的结构信息构建非常复杂的数据，因为所有数据都以键值对的形式保存。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1ce5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">JSON和Python之间的数据类型匹配</h1><p id="6671" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">作为一种常见的数据交换格式，JSON数据类型有相应的原生Python数据结构。请注意，这是双向通信——JSON数据如何转换为Python数据，当您将Python数据转换为JSON数据时，同样的转换规则(除了少数例外)也适用。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="733c" class="nh mh it ly b gy ni nj l nk nl">+-----------+----------------+<br/>|   JSON    |     Python     |<br/>+-----------+----------------+<br/>| String    | str            |<br/>| Number    | int or float   |<br/>| Boolean   | bool           |<br/>| Array     | list           |<br/>| Object    | dict           |<br/>| Null      | NoneType       |<br/>+-----------+----------------+</span></pre><p id="34d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些转换应该非常简单，只是Python没有与JSON对象中的数字相匹配的原生数据类型。相反，当JSON数是整数或实数时，我们必须使用int和float来表示它们。您可能还注意到Python数据列的表缺少tuple和set。值得注意的是，元组被转换为数组，而集合本身不能转换为数组。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="57a7" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">读取JSON字符串</h1><p id="f583" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们读取JSON数据并将其解码为其他编程语言(如Python)的数据结构以进行进一步处理时，我们说我们<strong class="lb iu">反序列化了JSON数据</strong>。换句话说，读取和解码过程被称为<strong class="lb iu">去串行化</strong>。在Python的标准库中，我们有专门用于反序列化JSON数据的<code class="fe lv lw lx ly b">json</code>模块。</p><p id="0922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们知道web服务使用JSON对象作为API响应是很常见的。假设您收到以下响应。为了便于讨论，我们将其表示为Python字符串对象。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="28d6" class="nh mh it ly b gy ni nj l nk nl">employee_json_data = """{<br/>  "employee0": {<br/>    "firstName": "John",<br/>    "lastName": "Smith",<br/>    "age": 35,<br/>    "city": "San Francisco"<br/>  },<br/>  "employee1": {<br/>    "firstName": "Zoe",<br/>    "lastName": "Thompson",<br/>    "age": 32,<br/>    "city": "Los Angeles"<br/>  }<br/>}"""</span></pre><p id="af87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要读取这个JSON字符串，我们只需使用<code class="fe lv lw lx ly b">loads</code>方法。如下所示，在读取包含上述JSON对象的字符串后，我们能够获得一个<code class="fe lv lw lx ly b">dict</code>对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="407f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">loads</code>方法灵活。当您有一个表示JSON对象列表的字符串时，这个方法足够智能，知道如何相应地解析数据。考虑下面的例子。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e756" class="nh mh it ly b gy ni nj l nk nl">employee_json_array = '[{"employee2": "data"}, {"employee3": "data"}]'</span><span id="48cf" class="nh mh it ly b gy nm nj l nk nl">employee_list = json.loads(employee_json_array)<br/>print(employee_list)</span><span id="773b" class="nh mh it ly b gy nm nj l nk nl"><strong class="ly iu"><em class="od"># [{'employee2': 'data'}, {'employee3': 'data'}]</em></strong></span></pre><p id="250d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这些结构化的JSON对象，<code class="fe lv lw lx ly b">loads</code>方法还可以解析除对象以外的任何JSON数据类型。下面是一些例子。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3722" class="nh mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; json.loads("2.2")<br/><strong class="ly iu">2.2</strong></span><span id="eced" class="nh mh it ly b gy nm nj l nk nl">&gt;&gt;&gt; json.loads('"A string"')<br/>'A string'</span><span id="94d3" class="nh mh it ly b gy nm nj l nk nl">&gt;&gt;&gt; json.loads('false')<br/>False</span><span id="a078" class="nh mh it ly b gy nm nj l nk nl">&gt;&gt;&gt; json.loads('null') is None<br/>True</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="fef1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">读取JSON文件</h1><p id="c1a8" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">上一节讨论了JSON字符串反序列化的各个方面。但是，您并不总是直接处理字符串。有时，您会有机会使用JSON文件。假设您运行下面的代码来创建一个保存JSON字符串的文件。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2f00" class="nh mh it ly b gy ni nj l nk nl"># the JSON data to save<br/>json_to_write='{"name": "John", "age": 35}'</span><span id="9b7e" class="nh mh it ly b gy nm nj l nk nl"># write the JSON data to a file<br/>with open("json_test.txt", "w") as file:<br/>    file.write(json_to_write)</span></pre><p id="8517" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，您可以直接读取文件来创建字符串，该字符串可以发送给<code class="fe lv lw lx ly b">loads</code>方法。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="e34c" class="nh mh it ly b gy ni nj l nk nl">with open(“json_test.txt”) as file:<br/>    json_string = file.read()<br/>    parsed_json0 = json.loads(json_string)<br/>    print(parsed_json0)</span><span id="e812" class="nh mh it ly b gy nm nj l nk nl"># output: {'name': 'John', 'age': <strong class="ly iu">35</strong>}</span></pre><p id="aee9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值得注意的是，<code class="fe lv lw lx ly b">json</code>模块提供了<code class="fe lv lw lx ly b">load</code>方法，允许我们直接使用文件来解析JSON数据:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2671" class="nh mh it ly b gy ni nj l nk nl">with open(“json_test.txt”) as file:<br/>    parsed_json1 = json.load(file)<br/>    print(parsed_json1)</span><span id="8ae6" class="nh mh it ly b gy nm nj l nk nl"># output: {‘name’: ‘John’, ‘age’: 35}</span></pre><p id="79fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过省去创建中间字符串对象的需要，它肯定比前面的实现更清晰。</p><p id="d671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们了解了<code class="fe lv lw lx ly b">load</code>和<code class="fe lv lw lx ly b">loads</code>方法的最基本场景。应该注意的是，解析JSON数据是通过<code class="fe lv lw lx ly b">JSONDecoder</code>类进行的。虽然这个基类足够强大，可以处理大多数情况，但是可以通过创建<code class="fe lv lw lx ly b">JSONDecoder</code>类的子类来定义更多定制的行为。但是，如果您不想创建子类，<code class="fe lv lw lx ly b">load</code>和<code class="fe lv lw lx ly b">loads</code>方法提供了其他参数，通过这些参数您可以定义定制的解析行为。好奇的读者可以参考<a class="ae ky" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>获得进一步说明。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f21b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">将Python数据写入JSON格式</h1><p id="9ba4" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">与读取JSON数据一样，将Python数据写入JSON格式涉及两个对应的方法，即<code class="fe lv lw lx ly b">dump</code>和<code class="fe lv lw lx ly b">dumps</code>。与反序列化JSON数据相反，创建JSON数据被称为序列化。因此，当我们将Python数据转换为JSON数据时，我们说我们将Python对象序列化为JSON数据。</p><p id="9a49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像<code class="fe lv lw lx ly b">load</code>和<code class="fe lv lw lx ly b">loads</code>方法一样，<code class="fe lv lw lx ly b">dump</code>和<code class="fe lv lw lx ly b">dumps</code>方法具有几乎相同的调用签名。最重要的区别是<code class="fe lv lw lx ly b">dump</code>方法将数据写入JSON文件，而<code class="fe lv lw lx ly b">dumps</code>方法写入JSON格式的字符串。为简单起见，我们将只关注<code class="fe lv lw lx ly b">dumps</code>方法。考虑下面的例子。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="14c6" class="nh mh it ly b gy ni nj l nk nl">import json</span><span id="161f" class="nh mh it ly b gy nm nj l nk nl">different_data = ['text', False, {"0": None, <strong class="ly iu">1</strong>: [<strong class="ly iu">1.0</strong>, <strong class="ly iu">2.0</strong>]}]</span><span id="c33c" class="nh mh it ly b gy nm nj l nk nl">json.dumps(different_data)<br/># output: '["text", false, {"0": null, "1": [1.0, 2.0]}]'</span></pre><p id="3767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们注意到<code class="fe lv lw lx ly b">dumps</code>方法创建了一个保存不同种类JSON数据的JSON数组。最有意义的观察是，尽管原始的<code class="fe lv lw lx ly b">list</code>对象使用原生Python数据结构，但是生成的JSON字符串具有转换后的JSON数据结构。与之前显示的转换表一致，请注意以下转换。</p><ul class=""><li id="128d" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">用单引号括起来的字符串“text”现在使用了双引号“text”。</li><li id="22e7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">Python bool对象<code class="fe lv lw lx ly b">False</code>变为false。</li><li id="63c4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">对象<code class="fe lv lw lx ly b">None</code>变为空。</li><li id="ea19" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">因为只有字符串可以是JSON键，所以数字1被自动转换成它的对应字符串“1”。</li></ul><p id="81e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了这些自动转换，还有两个我们经常使用的显著特性。第一个是通过使用适当的缩进，以更易读的格式创建JSON对象。为此，我们需要在<code class="fe lv lw lx ly b">dumps</code>方法中设置缩进参数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="2bad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所示，每一级都很好地缩进，以表示JSON对象及其键值对的相对结构。</p><p id="1d9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个有用的特性是<code class="fe lv lw lx ly b">sort_keys</code>参数的规范。通过将其设置为<code class="fe lv lw lx ly b">True</code>，创建的JSON字符串的键按字母顺序排序，这使得我们更容易查找信息，尤其是当有多个条目时。观察下面的功能。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="5519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经了解到<code class="fe lv lw lx ly b">load</code>和<code class="fe lv lw lx ly b">loads</code>方法用于反序列化，而<code class="fe lv lw lx ly b">dump</code>和<code class="fe lv lw lx ly b">dumps</code>方法用于序列化。这些方法名称对一些人来说可能听起来很混乱。这里有一些提示可以帮助你区分它们。</p><ul class=""><li id="b681" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">JSON数据是Python外部的，当你需要访问它们的数据时，我们需要“加载”到Python中。所以加载是指读取JSON数据。</li><li id="545e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">相比之下，为了将Python数据导出到JSON数据，我们“转储”数据。所以转储指的是写JSON数据。</li><li id="b697" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">如果输入或输出JSON数据是字符串，那么可以把“s”看作字符串，这样我们就可以把字母“s”附加到load方法上。类似地，如果我们想要JSON字符串，我们将字母“s”附加到dump方法。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0c74" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">将定制实例写入JSON数据</h1><p id="df5b" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">我们一直关注内置Python数据结构，在许多应用程序中，当需要将这些自定义实例对象序列化为JSON数据时，您将定义自己的自定义类。让我们考虑下面的类，我们从它创建一个实例:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="bee1" class="nh mh it ly b gy ni nj l nk nl"><strong class="ly iu">class</strong> <strong class="ly iu">Employee</strong>:<br/>    <strong class="ly iu">def</strong> __init__(self, name, employee_id):<br/>        self.name = name<br/>        self.employee_id = employee_id</span><span id="a45c" class="nh mh it ly b gy nm nj l nk nl">employee = Employee("John Smith", <strong class="ly iu">40</strong>)</span></pre><p id="13c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们尝试在<code class="fe lv lw lx ly b">employee</code>上调用<code class="fe lv lw lx ly b">dumps</code>，您预计会发生什么？能成功吗？让我们看看:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="da0a" class="nh mh it ly b gy ni nj l nk nl">json.dumps(employee)<br/># TypeError: Object of type Employee is not JSON serializable</span></pre><p id="a2e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不，它不起作用。失败的原因是<code class="fe lv lw lx ly b">dumps</code>方法试图创建一个有效的JSON字符串。然而，对于自定义类的实例，它不知道应该对什么数据进行编码。尽管您可以创建自己的JSONEncoder类，但一个快速的解决方案是通过设置<code class="fe lv lw lx ly b">default</code>参数为<code class="fe lv lw lx ly b">dumps</code>方法提供编码指令。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3d96" class="nh mh it ly b gy ni nj l nk nl">&gt;&gt;&gt; json.dumps(employee, default=lambda x: x.__dict__)<br/>'{"name": "John Smith", "employee_id": 40}'</span></pre><p id="1dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们指定了一个lambda函数，它通过访问<code class="fe lv lw lx ly b">__dict__</code>特殊属性来检索实例的dict表示。我们知道内置的<code class="fe lv lw lx ly b">dict</code>对象是JSON可序列化的，因此<code class="fe lv lw lx ly b">dumps</code>知道要“转储】对象。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="f346" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="781e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在本文中，我们回顾了用Python处理JSON数据的关键技术。以下是关键要点:</p><ol class=""><li id="f7a1" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu oe nt nu nv bi translated">JSON数据是一种标准的交换数据格式。当您创建供他人使用的API时，可以考虑将JSON作为您的响应数据的一种可能格式。</li><li id="91b0" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oe nt nu nv bi translated">Python分离了处理JSON字符串和文件的方法。这些方法有相似的调用签名。</li><li id="df29" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oe nt nu nv bi translated">使用适当的缩进来提高JSON数据的可读性。如果您正在创建一个JSON字符串，这一点尤其重要。在序列化Python对象时，只需指定indent参数。</li><li id="85a3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oe nt nu nv bi translated">当JSON对象有多个键值对时，对键进行排序通常是个好主意，这样可以更容易地查找信息。</li><li id="f8ff" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oe nt nu nv bi translated">记住JSON键必须是字符串，并且需要双引号。</li><li id="552b" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu oe nt nu nv bi translated">要序列化自定义实例，您需要提供有关序列化的特定说明。</li></ol></div></div>    
</body>
</html>