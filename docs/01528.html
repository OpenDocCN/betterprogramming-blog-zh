<html>
<head>
<title>Firestore Read, Functions Write</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Firestore读取，函数写入</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/firestore-read-functions-write-a-sane-way-of-using-firebase-2b0c296b069c?source=collection_archive---------13-----------------------#2019-09-20">https://betterprogramming.pub/firestore-read-functions-write-a-sane-way-of-using-firebase-2b0c296b069c?source=collection_archive---------13-----------------------#2019-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="16dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Firebase的合理方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9498654fe9cc37bd83862ddb38ef61f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3DukQ8MaCU8uF6dN.png"/></div></div></figure><p id="9786" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我第一次尝试完全在Firebase上构建应用程序时，我无法理解这一点——后端开发人员需要应用复杂的安全规则，这些规则甚至会让JavaEE配置相形见绌。</p><p id="3d2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">常规的后端编程始于一个假设，即客户机不允许做任何事情。您逐渐添加允许用户执行的操作。</p><p id="1c0b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于Firebase，情况正好相反。如果一个用户可以阅读一个文档，他就可以阅读整个文档，如果他可以写文档，默认情况下，他可以对文档做任何事情。Firebase中的编程是一个为用户能做的事情慢慢添加异常的过程。</p><p id="a28c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本质上，Firebase是将用户<em class="lq">不能</em>做的事情列入黑名单，而服务器编程是将用户<em class="lq">能</em>做的事情列入白名单。</p><p id="273a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不喜欢这种模式，而且安全性也很差。</p><p id="d1e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是有一种明智的方法可以使用Firestore(或者Firebase的旧数据库),这种方法很少被提及，而且不会让你在每个角落都揪着自己的头发。</p><p id="41f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">直接从Firestore读取，用函数写入。</em></p><p id="e940" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决办法很简单——永远不要直接给Firestore写信。相反，使用函数以您想要的任意规则写入存储。保持你的安全规则只是关于阅读。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="fb2c" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">不直接写信给Firestore的缺点</h1><h2 id="02ff" class="mq lz it bd ma mr ms dn me mt mu dp mi ld mv mw mk lh mx my mm ll mz na mo nb bi translated"><strong class="ak">无离线写入</strong></h2><p id="d3d5" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">Firebase的最大优势之一是它可以帮你同步数据，并且可以离线工作。如果你不直接写数据库，Firebase SDK不能为你处理离线。</p><p id="928d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，这可能没那么重要，因为交易也不能离线完成，即使是简单的工作流，它们也可能成为大多数操作。</p><h2 id="cfc7" class="mq lz it bd ma mr ms dn me mt mu dp mi ld mv mw mk lh mx my mm ll mz na mo nb bi translated"><strong class="ak">没有立即更新</strong></h2><p id="b15a" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">如果使用Firebase SDKs直接写入数据存储，客户机不必等待服务器接收或确认请求，更改会立即发生。使用函数时，您必须等待数据从服务器传播回客户端。</p><p id="60a0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与脱机一样，这不适用于事务，而且在许多情况下，正确的行为应该是等待确认。</p><h2 id="04a6" class="mq lz it bd ma mr ms dn me mt mu dp mi ld mv mw mk lh mx my mm ll mz na mo nb bi translated"><strong class="ak">使用功能的额外费用</strong></h2><p id="14da" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">由于我们现在为我们想要做的每个写操作添加了一个函数API调用，Firebase将对函数访问以及数据库/Firestore访问收费。这种费用可能是写操作成本的两倍(如果每次调用函数时只写一个文档),也可能是不合理的(如果很少写，即使写也要读写多个文档)。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="f1b4" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">一些陷阱和食谱</h1><h2 id="2b0d" class="mq lz it bd ma mr ms dn me mt mu dp mi ld mv mw mk lh mx my mm ll mz na mo nb bi translated"><em class="nh">函数调用后显示更新</em></h2><p id="f0ee" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">当使用函数更新数据和使用快照侦听器时，函数调用可以在数据传播回客户端之前成功完成并返回。这可能会导致UI延迟，此时操作成功完成，但其对UI的影响需要一段时间才能显现。</p><p id="9eea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有两种方法可以解决这个问题:</p><ul class=""><li id="c802" class="ni nj it kw b kx ky la lb ld nk lh nl ll nm lp nn no np nq bi translated">在UI上显示成功之前，您可以等待数据传播到客户端，而不是等待函数调用成功完成。</li><li id="f0be" class="ni nj it kw b kx nr la ns ld nt lh nu ll nv lp nn no np nq bi translated">当一个函数完成时，它应该返回已更改的文档，然后这些更改可以手动应用到UI。当更改通过侦听器传播时，不会发生任何事情，因为数据是相同的。</li></ul><h2 id="9c95" class="mq lz it bd ma mr ms dn me mt mu dp mi ld mv mw mk lh mx my mm ll mz na mo nb bi translated">对权限使用自定义声明</h2><p id="da99" class="pw-post-body-paragraph ku kv it kw b kx nc ju kz la nd jx lc ld ne lf lg lh nf lj lk ll ng ln lo lp im bi translated">由于我们在所有的更新中使用函数，我们还可以向用户添加自定义声明(<a class="ae nw" href="https://firebase.google.com/docs/auth/admin/custom-claims" rel="noopener ugc nofollow" target="_blank">参见how here </a>)并在安全规则中使用这些声明。这对于向用户(如管理员)添加权限或加入一个组非常有用(注意，自定义声明被限制为1000字节)。</p></div></div>    
</body>
</html>