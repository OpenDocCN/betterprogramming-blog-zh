<html>
<head>
<title>9 Rules for Clean LINQ Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">清洁LINQ查询的9条规则</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/9-rules-for-clean-linq-queries-2a894724bb61?source=collection_archive---------2-----------------------#2022-02-22">https://betterprogramming.pub/9-rules-for-clean-linq-queries-2a894724bb61?source=collection_archive---------2-----------------------#2022-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1d8e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的LINQ查询像一本好书一样可读</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c70f23d70a16ecbc4e9e8348285409ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-itkpiP-gwoj0WRN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">亚伦·伯顿</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="4c83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近的一篇关于如何编写可读代码的文章中，我提到在大多数情况下，好的LINQ查询比任何类型的循环都更可读，也是一个好的替代。对于初学者来说，LINQ可能需要几天时间来学习，但我发现，在第一次学习LINQ查询六年后，我仍然在改进我如何编写它们。</p><p id="d6cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您介绍一些在编写LINQ查询时要遵守的规则。这些规则将使你的查询像一本书一样可读。</p><h1 id="d883" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.在每个语句后中断</h1><p id="054b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">打破你的代码可以改变你的代码的外观，从一堆垃圾变成一个美丽的艺术品。我发现，垂直阅读代码比水平阅读更快。因此，我至少中断了所有代码行，这将超出半个屏幕。对于LINQ查询，我甚至在每个点之前断开它们。这使得它们的可读性更好，逻辑也更清晰，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打破LINQ的质疑</p></figure><h1 id="f4d3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.缩进每个嵌套层</h1><p id="2a6b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">中断代码后，有时需要调整代码行的缩进级别，因为您的IDE可能不会为您这样做。我发现将每个嵌套层多缩进一级是可行的，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">缩进嵌套层</p></figure><p id="12eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">ReceivedMessage</code>的构造函数是一个新的逻辑层，它获得了一个新的缩进级别，你也可以随意地打断和缩进你的参数。</p><p id="a94d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要忘记断开您的右括号，并将它们移动到与左括号相同的缩进级别。这样，您可以很快地看到，一个语句在哪里结束，一个新的(具有相同的缩进级别)在哪里开始。</p><h1 id="5cc6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.提取更大的方法</h1><p id="301e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有时，在您的<code class="fe mu mv mw mx b">Select</code> / <code class="fe mu mv mw mx b">SelectMany</code>子句中可能有复杂的转换规则。你可能想把整个代码都写在Lambda函数中。然而，下一个开发者很可能不明白，那里发生了什么。所以为什么不把这部分代码提取到一个单独的方法中呢。您甚至可以省去大括号和lambda函数样板代码，因为您可以像这样编写简短的lambda:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提取方法</p></figure><h1 id="bbc8" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.提取复杂的Where子句</h1><p id="ac06" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与第三个<strong class="lb iu"> </strong>类似的情况发生在<code class="fe mu mv mw mx b">Where</code>从句中。如果你评估一个布尔值，一切都是好的。但是，如果有两个或两个以上，你的意图就会淡化。下一个开发者将很难理解，你想在这里过滤什么。要解决这个问题，只需将lambda提取到一个本地函数中，并给它一个好名字，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">提取谓词</p></figure><h1 id="7fdc" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.制作自己的扩展方法</h1><p id="02b7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">LINQ已经提供了非常有用的扩展方法。然而，仍然可能有一些函数非常有用，并且还没有包含在默认库中。例如，我在微软将扩展方法<code class="fe mu mv mw mx b">DistinctBy()</code>包含进来之前就创建了它。NET 6。</p><p id="f41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在LINQ特别怀念的是对任务和异步代码的更好处理。为了让生活变得简单一点，我实现了以下扩展方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">LINQ的异步扩展方法</p></figure><p id="a8b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们使异步LINQ方式更容易处理，正如您在这里看到的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">异步扩展的应用</p></figure><h1 id="9d41" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.Lambda变量使用单个字符</h1><p id="2499" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">几乎在每一个干净代码指南中，你都会读到你应该提供命名良好的变量和方法。但是，在这种情况下，我敢反驳。LINQ查询在水平方向上通常比您通常的代码长一点。当你现在试图给每个lambda变量起一个好名字时，你的代码行肯定会变得更长，你可能会重复使用你的变量，你可能会发现你的代码更难破解。</p><p id="ad3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我发现这是可行的，只使用类的第一个字母，你想传递给函数。无论如何，源可枚举变量的意图应该是清楚的。这就是为什么你应该特别注意这个可枚举的名字。看看这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用单字符命名</p></figure><p id="1fdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量的类型和意图从它的源可枚举中变得清晰，我们节省了一些字符，我们甚至可以直接看到哪个变量用于lambda函数。</p><h1 id="aa10" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">7.总是期望IEnumerable作为参数</h1><p id="14dc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">你的项目中的每一个期望某种<code class="fe mu mv mw mx b">IEnumerable</code>的方法应该总是声明它期望这样。当你真的不需要时，不要期待一个<code class="fe mu mv mw mx b">Array</code>或<code class="fe mu mv mw mx b">List</code>或其他什么(尽管你仍然可以把它传递给方法)。我在我的项目中发现的唯一例外是<code class="fe mu mv mw mx b">HashSets</code>和<code class="fe mu mv mw mx b">Dictionaries</code>。此外，当您明确想要一个已经枚举的<code class="fe mu mv mw mx b">IEnumerable</code>时，您可以根据自己的喜好期待一个特定的类型。</p><p id="2d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你应该建立一个规则，永远不要把<code class="fe mu mv mw mx b">null</code>当作<code class="fe mu mv mw mx b">IEnumerable</code>来传递。用<code class="fe mu mv mw mx b">Enumerable.Empty&lt;T&gt;()</code>就可以空着<code class="fe mu mv mw mx b">IEnumerable</code>过去了。这样，您将大大减少NullReferenceExceptions，并且您的代码不会中断。通常你甚至不需要担心空的可枚举数，因为你的LINQ查询也可以使用空的。</p><h1 id="3b9a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">8.总是转换不可变的</h1><p id="c56b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于干净编码来说，不变性是一个极其重要的概念。这基本上意味着你不能通过设计来改变任何对象的状态。有时候当然可以，但是一定不能！特别是在你的<code class="fe mu mv mw mx b">Select()</code>查询中，你必须注意不要改变你的源的任何状态。通过这种方式，您可以确保多次枚举查询，而不会改变结果。看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">非不可变转换示例</p></figure><p id="f849" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您第一次枚举它，流将被读取，然后被释放，从而改变源的状态！如果你试着再列举一次，你会得到一个<code class="fe mu mv mw mx b">ObjectDisposedException()</code>，它不是太明显，你做错了。</p><h1 id="daa1" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">(9.)注重执行力——业绩</h1><p id="8af8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">最后但同样重要的是，您应该记住LINQ查询是如何执行的。我承认，这一点为了性能可能会降低可读性，这也是我把它放在括号里的原因。</p><p id="9cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很容易发生这样的情况，你迭代整个<code class="fe mu mv mw mx b">IEnumerables</code>的次数比你真正需要的要多一些。许多Leetcode练习的特点是优化迭代，从而降低时间和空间的复杂性。如果您想优化查询，一个很好的问题是:</p><p id="4dca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我可以在这里使用哈希表或字典吗？</p><p id="459d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，您可以通过使用其中一个来降低时间复杂度，因为它们具有<code class="fe mu mv mw mx b">O(1)</code>时间复杂度。</p><p id="8fa6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，一个大大提高LINQ查询性能的好方法是使用<code class="fe mu mv mw mx b">.AsParallel()</code>。这将您的LINQ查询引入到一个<a class="ae ky" href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq" rel="noopener ugc nofollow" target="_blank"> PLINQ </a>查询中，其中所有的事情都在您的CPU上并行运行。在这里，您应该特别注意不变性，不要依赖于其他变化的状态，因为并行化只能有效地用于独立查询。</p><p id="78f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只有当您有非常长时间运行的查询时，您才应该使用PLINQ，因为它甚至会降低某些本来会更快的查询的速度。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="bf35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您花时间阅读这篇文章。我希望，你会觉得它有知识性、教育性和趣味性。非常感谢您的支持和参与。</p><p id="2403" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您有兴趣了解干净架构、干净编码和最新技术栈的最新趋势、技巧和诀窍，尤其是在C#环境中。净和有棱角——如果你考虑跟踪我，我会很感激。</p><p id="5f27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你有美好的一天！</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/429378e6a7aee01df92851fb0e90e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK4zVN8TtnIM37dhEhE54g.png"/></div></div></figure><p id="2357" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你还没有每天使用媒体来增长你的知识，现在是开始的最佳时机！借助Medium，您可以轻松获得更多关于高度专业的主题的知识，发布高质量的内容，并接触到更广泛的受众。要开始，只需使用以下链接创建一个中型帐户:</p><p id="28a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@tobias.streng/membership" rel="noopener"> <em class="my">现在加入中等</em> </a></p><p id="cb60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，你将获得一个强大的平台，可以帮助你联系新的作者和读者，每天学习新的东西。</p></div></div>    
</body>
</html>