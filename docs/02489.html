<html>
<head>
<title>Asynchronous Operations for Writing Concurrent Solutions in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中编写并发解决方案的异步操作</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-operations-for-writing-concurrent-solutions-in-swift-7358485b9505?source=collection_archive---------12-----------------------#2019-12-03">https://betterprogramming.pub/asynchronous-operations-for-writing-concurrent-solutions-in-swift-7358485b9505?source=collection_archive---------12-----------------------#2019-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ef2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在隔离的类中编写长期运行的任务，以分离关注点和易于测试的代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e7ff955a5c90fe8e44f234315635926c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQ2idRaWZ6y5GePuq0yA3A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com/s/photos/solution?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="5a26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步操作允许执行长时间运行的任务，而不必在执行完成之前阻塞调用线程。这是创建关注点分离的一个很好的方法，特别是结合在操作之间创建依赖关系。</p><p id="00b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是运营新手，我建议您首先阅读我的博客文章<a class="ae ky" href="https://www.avanderlee.com/swift/operations/" rel="noopener ugc nofollow" target="_blank"><em class="lv">Swift</em></a>中的运营和运营队列入门。这篇文章将带你开始并解释基础知识。</p><p id="73d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过首先查看异步操作和它们的同步对立面之间的差异来深入了解异步操作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="118d" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">异步与同步操作</h1><p id="0cb2" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">看似很小的差别，其实只是个A，实际差别要大得多。</p><p id="2af7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同步操作更容易设置和使用，但是在不阻塞调用线程的情况下，不能像异步操作那样长时间运行。</p><p id="33d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">异步操作可以充分利用Swift 中的操作。由于可以运行异步的、长时间运行的任务，因此可以将它们用于任何类型的任务。</p><p id="8bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这为更多的关注点分离打开了大门，或者甚至为使用操作作为应用基础背后的核心逻辑打开了大门。</p><p id="c4a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总而言之，异步操作允许您:</p><ul class=""><li id="fb77" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">运行长期运行的任务。</li><li id="2186" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">从操作中分派到另一个队列。</li><li id="d4b8" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">手动启动操作，没有风险。</li></ul><p id="da75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下一段中，我会对最后一点做更多的解释。</p><h2 id="ec27" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">手动启动操作</h2><p id="dcba" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">同步和异步操作都可以手动启动。手动启动基本上就是手动调用<code class="fe oa ob oc od b">start()</code>方法，而不是使用<code class="fe oa ob oc od b">OperationQueue</code>来管理执行。</p><p id="1726" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同步操作总是阻塞调用线程，直到操作完成。</p><p id="e236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，它们不太适合手动启动操作。当使用异步任务时，阻塞调用线程的风险不像它可能被分派到另一个线程那样大。</p><h2 id="3ecf" class="no me it bd mf np nq dn mj nr ns dp mn li nt nu mp lm nv nw mr lq nx ny mt nz bi translated">不鼓励手动启动</h2><p id="d491" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">尽管现在手动启动异步任务可能很诱人，但不建议这样做。</p><p id="de39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe oa ob oc od b">OperationQueue</code>，您不必考虑多个操作的执行顺序，并且您可以受益于更多的特性，比如对任务进行优先级排序。</p><p id="e795" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，建议总是通过将操作添加到<code class="fe oa ob oc od b">OperationQueue</code>来开始操作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="1fe7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">创建异步操作</h1><p id="da20" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">创建异步操作都是从创建自己的子类并覆盖<code class="fe oa ob oc od b">isAsynchronous</code>属性开始的。</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ac8f" class="no me it od b gy oi oj l ok ol">class AsyncOperation: Operation {<br/>    override var isAsynchronous: Bool {<br/>        return true<br/>    }</span><span id="3a45" class="no me it od b gy om oj l ok ol">    override func main() {<br/>        /// Use a dispatch after to mimic the scenario of a long-running task.<br/>        DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + DispatchTimeInterval.seconds(1), execute: {<br/>            print("Executing")<br/>        })<br/>    }<br/>}</span></pre><p id="52ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这还不足以使任务异步，因为在执行print语句之后，任务仍然直接进入完成状态。这可以通过执行以下代码来演示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="e704" class="no me it od b gy oi oj l ok ol">let operation = AsyncOperation()<br/>queue.addOperations([operation], waitUntilFinished: true)<br/>print("Operations finished")</span><span id="6257" class="no me it od b gy om oj l ok ol">// Prints:<br/>// Operations finished<br/>// Executing</span></pre><p id="c3aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，当异步任务仍在执行时，任务已经被标记为完成。这可能会导致意外的行为。我们需要自己开始管理状态，以便操作异步工作。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ce30" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">管理异步操作的状态</h1><p id="9904" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">为了正确管理状态，我们需要用多线程和KVO支持覆盖<code class="fe oa ob oc od b">isFinished</code>和<code class="fe oa ob oc od b">isExecuting</code>属性。对于<code class="fe oa ob oc od b">isExecuting</code>属性，如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4413" class="no me it od b gy oi oj l ok ol">private var _isExecuting: Bool = false<br/>override private(set) var isExecuting: Bool {<br/>    get {<br/>        return lockQueue.sync { () -&gt; Bool in<br/>            return _isExecuting<br/>        }<br/>    }<br/>    set {<br/>        willChangeValue(forKey: "isExecuting")<br/>        lockQueue.sync(flags: [.barrier]) {<br/>            _isExecuting = newValue<br/>        }<br/>        didChangeValue(forKey: "isExecuting")<br/>    }<br/>}</span></pre><p id="ec73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们跟踪私有属性中的执行状态，我们只同步访问私有属性。</p><p id="ab28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在博文<a class="ae ky" href="https://www.avanderlee.com/swift/concurrent-serial-dispatchqueue/" rel="noopener ugc nofollow" target="_blank"><em class="lv">Swift中的并发</em> </a> <em class="lv">，</em>中所了解的，我们需要利用锁队列来实现线程安全的读写访问。</p><p id="11e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们利用<code class="fe oa ob oc od b">willChangeValue(forKey:)</code>和<code class="fe oa ob oc od b">didChangeValue(forKey:)</code>来添加KVO支持，这将确保<code class="fe oa ob oc od b">OperationQueue</code>得到正确更新。</p><p id="15b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还需要覆盖实际更新状态的<code class="fe oa ob oc od b">start()</code>方法。重要的是要注意，你永远不要在这个方法中调用<code class="fe oa ob oc od b">super.start()</code>，因为我们现在正在自己处理状态。</p><p id="26d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们添加了一个<code class="fe oa ob oc od b">finish()</code>方法，允许我们在异步任务完成后将状态设置为finished。</p><p id="6b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将所有这些加在一起，我们得到一个子类，如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="7abf" class="no me it od b gy oi oj l ok ol">class AsyncOperation: Operation {<br/>    private let lockQueue = DispatchQueue(label: "com.swiftlee.asyncoperation", attributes: .concurrent)<br/><br/>    override var isAsynchronous: Bool {<br/>        return true<br/>    }<br/><br/>    private var _isExecuting: Bool = false<br/>    override private(set) var isExecuting: Bool {<br/>        get {<br/>            return lockQueue.sync { () -&gt; Bool in<br/>                return _isExecuting<br/>            }<br/>        }<br/>        set {<br/>            willChangeValue(forKey: "isExecuting")<br/>            lockQueue.sync(flags: [.barrier]) {<br/>                _isExecuting = newValue<br/>            }<br/>            didChangeValue(forKey: "isExecuting")<br/>        }<br/>    }<br/><br/>    private var _isFinished: Bool = false<br/>    override private(set) var isFinished: Bool {<br/>        get {<br/>            return lockQueue.sync { () -&gt; Bool in<br/>                return _isFinished<br/>            }<br/>        }<br/>        set {<br/>            willChangeValue(forKey: "isFinished")<br/>            lockQueue.sync(flags: [.barrier]) {<br/>                _isFinished = newValue<br/>            }<br/>            didChangeValue(forKey: "isFinished")<br/>        }<br/>    }<br/><br/>    override func start() {<br/>        print("Starting")<br/>        isFinished = false<br/>        isExecuting = true<br/>        main()<br/>    }<br/><br/>    override func main() {<br/>        /// Use a dispatch after to mimic the scenario of a long-running task.<br/>        DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + DispatchTimeInterval.seconds(1), execute: {<br/>            print("Executing")<br/>            self.finish()<br/>        })<br/>    }<br/><br/>    func finish() {<br/>        isExecuting = false<br/>        isFinished = true<br/>    }<br/>}</span></pre><p id="d0a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了确保我们的任务能够正常工作，我们将执行与之前相同的代码:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="dc63" class="no me it od b gy oi oj l ok ol">let operation = AsyncOperation()<br/>queue.addOperations([operation], waitUntilFinished: true)<br/>print("Operations finished")<br/><br/>// Prints:<br/>// Starting<br/>// Executing<br/>// Operations finished</span></pre><p id="09a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这太棒了，这正是我们想要的！唯一缺少的是取消。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="57d0" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">添加对取消的支持</h1><p id="510f" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">由于操作可以在任何时候被取消，我们需要在开始执行时考虑到这一点。有可能在任务开始之前就已经取消了某项操作。</p><p id="e94c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过简单地在<code class="fe oa ob oc od b">start()</code>方法中添加一个保护来做到这一点:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2676" class="no me it od b gy oi oj l ok ol">override func start() {<br/>    print("Starting")<br/>    guard !isCancelled else { return }<br/><br/>    isFinished = false<br/>    isExecuting = true<br/>    main()<br/>}</span></pre><p id="861e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管此时<code class="fe oa ob oc od b">isFinished</code>和<code class="fe oa ob oc od b">isExecuting</code>属性被设置为正确的值，我们仍然需要根据<a class="ae ky" href="https://developer.apple.com/documentation/foundation/nsoperation?language=swift#1661262" rel="noopener ugc nofollow" target="_blank">文档</a>更新它们:</p><blockquote class="on"><p id="789a" class="oo op it bd oq or os ot ou ov ow lu dk translated">“具体来说，你必须把<code class="fe oa ob oc od b">finished</code>返回的值改成<code class="fe oa ob oc od b">YES</code>，把<code class="fe oa ob oc od b">executing</code>返回的值改成<code class="fe oa ob oc od b">NO</code>。即使操作在开始执行前被取消，您也必须进行这些更改。</p></blockquote><p id="505d" class="pw-post-body-paragraph kz la it lb b lc ox ju le lf oy jx lh li oz lk ll lm pa lo lp lq pb ls lt lu im bi translated">因此，我们从防护中的<code class="fe oa ob oc od b">start()</code>方法调用<code class="fe oa ob oc od b">finish()</code>方法，使我们的最终方法如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="9624" class="no me it od b gy oi oj l ok ol">override func start() {<br/>    print("Starting")<br/>    guard !isCancelled else {<br/>        finish()<br/>        return<br/>    }<br/><br/>    isFinished = false<br/>    isExecuting = true<br/>    main()<br/>}</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ef67" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">利用异步任务</h1><p id="0a88" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">创建了可用于长时间运行任务的子类后，就该从中受益了。最终的异步操作类如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="9450" class="no me it od b gy oi oj l ok ol">class AsyncOperation: Operation {<br/>    private let lockQueue = DispatchQueue(label: "com.swiftlee.asyncoperation", attributes: .concurrent)<br/><br/>    override var isAsynchronous: Bool {<br/>        return true<br/>    }<br/><br/>    private var _isExecuting: Bool = false<br/>    override private(set) var isExecuting: Bool {<br/>        get {<br/>            return lockQueue.sync { () -&gt; Bool in<br/>                return _isExecuting<br/>            }<br/>        }<br/>        set {<br/>            willChangeValue(forKey: "isExecuting")<br/>            lockQueue.sync(flags: [.barrier]) {<br/>                _isExecuting = newValue<br/>            }<br/>            didChangeValue(forKey: "isExecuting")<br/>        }<br/>    }<br/><br/>    private var _isFinished: Bool = false<br/>    override private(set) var isFinished: Bool {<br/>        get {<br/>            return lockQueue.sync { () -&gt; Bool in<br/>                return _isFinished<br/>            }<br/>        }<br/>        set {<br/>            willChangeValue(forKey: "isFinished")<br/>            lockQueue.sync(flags: [.barrier]) {<br/>                _isFinished = newValue<br/>            }<br/>            didChangeValue(forKey: "isFinished")<br/>        }<br/>    }<br/><br/>    override func start() {<br/>        print("Starting")<br/>        guard !isCancelled else {<br/>            finish()<br/>            return<br/>        }<br/><br/>        isFinished = false<br/>        isExecuting = true<br/>        main()<br/>    }<br/><br/>    override func main() {<br/>        fatalError("Subclasses must implement `execute` without overriding super.")<br/>    }<br/><br/>    func finish() {<br/>        isExecuting = false<br/>        isFinished = true<br/>    }<br/>}</span></pre><p id="1a60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该类需要作为子类使用，因此，当使用main方法时，我们会触发一个致命错误。</p><p id="73cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您将上传一个带有<code class="fe oa ob oc od b">FileUploadOperation</code>的文件:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4e24" class="no me it od b gy oi oj l ok ol">final class FileUploadOperation: AsyncOperation {<br/><br/>    private let fileURL: URL<br/>    private let targetUploadURL: URL<br/>    private var uploadTask: URLSessionTask?<br/><br/>    init(fileURL: URL, targetUploadURL: URL) {<br/>        self.fileURL = fileURL<br/>        self.targetUploadURL = targetUploadURL<br/>    }<br/><br/>    override func main() {<br/>        uploadTask = URLSession.shared.uploadTask(with: URLRequest(url: targetUploadURL), fromFile: fileURL) { (data, response, error) in<br/>            // Handle the response<br/>            // ...<br/>            // Call finish<br/>            self.finish()<br/>        }<br/>    }<br/><br/>    override func cancel() {<br/>        uploadTask?.cancel()<br/>        super.cancel()<br/>    }<br/>}</span></pre><p id="5f6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，我们正在保存数据任务，以便在需要时可以取消它。</p><p id="48b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这只是一个很基本的例子。在<a class="ae ky" href="https://collect.bywetransfer.com" rel="noopener ugc nofollow" target="_blank"> <em class="lv">通过WeTransfer </em> </a>收集中，我们使用了很多操作，例如:</p><ul class=""><li id="5b2b" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">内容创作</li><li id="817c" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">内容接收</li><li id="3126" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">内容上传</li><li id="ed42" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">内容丰富</li></ul><p id="137d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有很多。最棒的是你可以将这些操作链接在一起，就像你在上一篇关于<a class="ae ky" href="https://www.avanderlee.com/swift/operations/" rel="noopener ugc nofollow" target="_blank">操作入门</a>的文章中所学到的那样。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="30f6" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">结论</h1><p id="8fb6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">就是这样！我们已经创建了异步操作，您可以直接在您的项目中使用。希望它能让您更好地分离关注点和高性能代码。</p><p id="a509" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谢谢！</p></div></div>    
</body>
</html>