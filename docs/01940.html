<html>
<head>
<title>Understanding MVC Services for Front End: TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解MVC前端服务:TypeScript</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-mvc-services-for-front-end-typescript-5606f9f1ad92?source=collection_archive---------9-----------------------#2019-10-24">https://betterprogramming.pub/understanding-mvc-services-for-front-end-typescript-5606f9f1ad92?source=collection_archive---------9-----------------------#2019-10-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5881" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步的打字教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/6de1a5886dc7b1b1575590749925c2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Iy1WkTSNE67YbBS6QWQj3g.png"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="3ae2" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">介绍</h1><p id="702a" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这篇文章是理解MVC架构如何创建前端应用程序的三篇文章中的第二篇。</p><p id="b8f2" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">目标是通过将JavaScript用作脚本语言的网页发展成JavaScript/TypeScript用作面向对象语言的应用程序来理解构建前端应用程序的方法。</p><p id="eb0d" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在第二篇文章中，将使用第一个版本中的TypeScript构建应用程序。因此，本文是应用程序将从VanillaJS迁移到TypeScript的地方。然而，理解应用程序的所有部分是如何关联的以及它是如何构造的是非常重要的。</p><p id="4aa7" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">最后，在最后一篇文章中，我们将转换我们的代码，使其与Angular框架相集成。</p><ul class=""><li id="e195" class="mq mr it lr b ls ml lv mm ly ms mc mt mg mu mk mv mw mx my bi translated"><a class="ae mz" href="https://medium.com/better-programming/understanding-mvc-services-for-the-front-end-vanillajs-2268255b36e6" rel="noopener">第一部分。了解前端的MVC服务:VanillaJS </a></li><li id="5e66" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><a class="ae mz" href="https://medium.com/@ccaballero/understanding-mvc-services-for-frontend-typescript-5606f9f1ad92" rel="noopener">第二部分。了解前端MVC服务:TypeScript </a></li><li id="9f59" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated">第三部分。了解前端的MVC服务:Angular</li></ul></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="4bc8" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">项目架构</h1><p id="acad" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">没有什么比图像更有价值来理解我们将要建造的东西了。下面有一个GIF图，其中展示了我们正在构建的应用程序。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/fa3a34496de1fcebb1cd169a33c43697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*AdRdnVeheeydi2vrXepO-Q.gif"/></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">用户应用程序</p></figure><p id="12b7" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这个应用程序可以使用单个TypeScript文件来构建，该文件修改文档的DOM并执行所有操作，但是这是一个强耦合的代码，不是我们在本文中打算应用的。</p><p id="304d" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">什么是MVC架构？MVC是一个具有三层/三部分的架构:</p><ul class=""><li id="8707" class="mq mr it lr b ls ml lv mm ly ms mc mt mg mu mk mv mw mx my bi translated"><strong class="lr iu">模型</strong> —管理应用程序的数据。模型将会缺乏活力(它们将缺乏功能)，因为它们将会被提交给服务。</li><li id="4ce0" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><strong class="lr iu">视图</strong> —模型的可视化表示</li><li id="6131" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><strong class="lr iu">控制器</strong> —服务和视图之间的链接</li></ul><p id="8b2f" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">下面，我们展示了问题域中的文件结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/44d798703bdf7f0e4e2195c2752037a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*JPVHkPvQjOHkwac2WgS_zw.png"/></div></figure><p id="274b" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated"><code class="fe nl nm nn no b">index.html</code>文件将充当画布，整个应用程序将使用<code class="fe nl nm nn no b">root</code>元素在其上动态构建。此外，这个文件将作为所有文件的加载器，因为它们将在HTML文件本身中链接。</p><p id="f962" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">最后，我们的文件体系结构由以下类型脚本文件组成:</p><ul class=""><li id="00aa" class="mq mr it lr b ls ml lv mm ly ms mc mt mg mu mk mv mw mx my bi translated"><strong class="lr iu"> user.model.ts </strong> —用户的属性(模型)</li><li id="14a7" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><strong class="lr iu"> user.controller.ts </strong> —负责加入服务和视图的人</li><li id="fef7" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><strong class="lr iu"> user.service.ts </strong> —管理用户的所有操作</li><li id="aa97" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><strong class="lr iu"> user.views.ts </strong> —负责刷新和改变显示屏</li></ul><p id="4976" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">HTML文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="39b4" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">可以看到只链接了一个名为<code class="fe nl nm nn no b">bundle.js</code>的文件，这个文件将在TypeScript transpilation到JavaScript并应用最小化任务后生成。</p><p id="ec75" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我们不会关注构建我们的应用程序的工具，因为我们将展示负责执行我们项目的所有转换任务的<code class="fe nl nm nn no b">gulpfile</code>文件。</p><p id="73b7" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在这种情况下，我们决定使用Gulp工具，因为它有多年的经验，可以给出非常好的结果。如果你想深入了解Gulp，我建议你在它的网站上寻找信息，因为你可以找到一长串插件。</p><p id="9a9a" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在任何情况下，如果你懂JavaScript，你将能够阅读代码，并且你将几乎完全理解我们执行的任务。在我们的例子中，我们使用了<code class="fe nl nm nn no b">browserify</code>插件来打包、创建模块系统，并执行从类型脚本到JavaScript的转换。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="8301" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">模型(贫血)</h1><p id="4301" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">本例中第一个构建的类是应用程序模型<code class="fe nl nm nn no b">user.model.ts</code>，它由类属性和一个生成随机id(这些id可能来自服务器中的数据库)的私有方法组成。</p><p id="7d54" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这些模型将具有以下字段:</p><ul class=""><li id="6b76" class="mq mr it lr b ls ml lv mm ly ms mc mt mg mu mk mv mw mx my bi translated"><code class="fe nl nm nn no b">id</code>:独特价值</li><li id="0673" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><code class="fe nl nm nn no b">name</code>:用户的姓名</li><li id="09fc" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><code class="fe nl nm nn no b">age</code>:用户的年龄</li><li id="1199" class="mq mr it lr b ls na lv nb ly nc mc nd mg ne mk mv mw mx my bi translated"><code class="fe nl nm nn no b">complete</code> : Boolean，让你知道我们是否可以把用户从列表中划掉</li></ul><p id="5a6d" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">已经使用TypeScript对<code class="fe nl nm nn no b">User</code>类进行了类型化。然而，<code class="fe nl nm nn no b">User</code>构造函数接收一个普通对象，该对象将由<code class="fe nl nm nn no b">LocalStorage</code>或通过表单输入的用户数据提供。该普通对象必须符合<code class="fe nl nm nn no b">UserDto</code>接口，这样任何普通对象都不能被实例化，但满足已定义接口的对象除外。</p><p id="708e" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated"><code class="fe nl nm nn no b">user.model.ts</code>如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="e8d7" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">服务</h1><p id="03da" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">对用户执行的操作在服务中执行。服务允许模型贫血，因为所有的逻辑负载都在其中。</p><p id="f922" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在这个特定的例子中，我们将使用一个数组来存储所有用户，并构建与读取、修改、创建和删除(CRUD)用户相关的四个方法。</p><p id="4ffe" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">您应该注意到服务利用了模型，实例化了从<code class="fe nl nm nn no b">LocalStorage</code>提取到<code class="fe nl nm nn no b">User</code>类的对象。这是因为<code class="fe nl nm nn no b">LocalStorage</code>只存储数据而不是存储数据的原型。从后端传输到前端的数据也是如此——它们没有实例化它们的类。</p><p id="cccf" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我们类的构造函数如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7772" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated"><strong class="lr iu">注意:</strong>我们已经定义了一个名为<code class="fe nl nm nn no b">users</code>的类变量，一旦用户从一个普通对象(<code class="fe nl nm nn no b">UserDto</code>)转换为一个<code class="fe nl nm nn no b">User</code>类的原型对象，这个变量就会存储所有用户。</p><p id="ccd5" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">我们必须在服务中定义的下一件事将是我们想要开发的每个操作。下面使用TypeScript显示了这些操作:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="32dc" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">仍然需要定义负责存储在我们的数据存储中执行的操作的<code class="fe nl nm nn no b">commit</code>方法(在我们的例子中是<code class="fe nl nm nn no b">LocalStorage</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8661" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这个方法调用一个在创建zervice时绑定的<code class="fe nl nm nn no b">callback</code>函数，正如在<code class="fe nl nm nn no b">bindUserListChanged</code>方法的定义中可以看到的。我可以告诉你这个回调函数来自视图，负责刷新屏幕上的用户列表。</p><p id="b2ab" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">文件<code class="fe nl nm nn no b">user.service.ts</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="74e6" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">视图</h1><p id="c2b0" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">视图是模型的可视化表示。我们决定动态地创建整个视图，而不是创建HTML内容并注入它(正如许多框架中所做的那样)。</p><p id="c453" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">首先要做的是通过DOM方法缓存视图的所有变量，如视图构造函数所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="28c3" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">视图的下一个最相关的点是视图与服务方法的联合(将通过控制器发送)。例如，<code class="fe nl nm nn no b">bindAddUser</code>方法接收一个驱动函数作为参数，这个函数将执行服务中描述的<code class="fe nl nm nn no b">addUser</code>操作。</p><p id="16bf" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在<code class="fe nl nm nn no b">bindXXX</code>方法中，每个视图控件的<code class="fe nl nm nn no b">EventListener</code>被定义。请注意，从视图中，我们可以访问用户从屏幕上提供的所有数据，这些数据通过<code class="fe nl nm nn no b">handler</code>功能连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="cd76" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">视图的其余代码处理文档的DOM。文件<code class="fe nl nm nn no b">user.view.ts</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="ef4a" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">控制器</h1><p id="bbc1" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">这个架构的最后一个文件是控制器。控制器通过依赖注入(DI)接收它拥有的两个依赖项(服务和视图)。</p><p id="2dd6" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">这些依赖关系存储在控制器的私有变量中。此外，构造函数在视图和服务之间建立显式连接，因为控制器是唯一可以访问双方的元素。</p><p id="f8eb" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">文件<code class="fe nl nm nn no b">user.controller.ts</code>如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="561a" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">应用程序</h1><p id="6e5d" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">我们应用程序的最后一点是应用程序启动器。在我们的例子中，我们称之为<code class="fe nl nm nn no b">app.ts</code>。</p><p id="048c" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">通过创建不同的元素来执行应用程序:<code class="fe nl nm nn no b">UserService</code>、<code class="fe nl nm nn no b">UserView</code>和<code class="fe nl nm nn no b">UserController</code>，如文件<code class="fe nl nm nn no b">app.ts</code>所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="05ed" class="kx ky it bd kz la lb lc ld le lf lg lh jz li ka lj kc lk kd ll kf lm kg ln lo bi translated">结论</h1><p id="e808" class="pw-post-body-paragraph lp lq it lr b ls lt ju lu lv lw jx lx ly lz ma mb mc md me mf mg mh mi mj mk im bi translated">在第二篇文章中，我们开发了一个web应用程序，在这个应用程序中，项目是按照MVC架构构建的，在这个架构中使用了贫血模型，逻辑的责任在于服务。</p><p id="6190" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">理解项目在不同责任的不同文件中的结构以及视图如何完全独立于模型/服务和控制器是非常重要的。</p><p id="1f0d" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">同样重要的是要注意，在这篇文章中，我们已经将应用程序从JavaScript迁移到TypeScript，使我们能够获得一个类型化的代码，帮助开发人员最大限度地减少错误，并了解它的每个部分是做什么的。</p><p id="01f2" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">在本系列的下一篇文章中，我们将把TypeScript代码迁移到Angular。这种向框架的迁移将意味着我们不必处理使用DOM的复杂性和重复性。</p><p id="0ed7" class="pw-post-body-paragraph lp lq it lr b ls ml ju lu lv mm jx lx ly mn ma mb mc mo me mf mg mp mi mj mk im bi translated">本帖的GitHub分支位于<a class="ae mz" href="https://github.com/Caballerog/TypeScript-MVC-Users" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>