<html>
<head>
<title>Decoding Jetpack Compose — LazyColumn, Navigation Architecture, Data Model, Grid, and TabBar View</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解码Jetpack组合— LazyColumn、导航架构、数据模型、网格和TabBar视图</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decoding-jetpack-compose-part-0-48d9139f65db?source=collection_archive---------2-----------------------#2022-02-13">https://betterprogramming.pub/decoding-jetpack-compose-part-0-48d9139f65db?source=collection_archive---------2-----------------------#2022-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e9d3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">第0部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9fc04da378c874d468010538778a4ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1RzA17-20IfLuUbtjwNNaA.png"/></div></div></figure><p id="8460" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">自从<strong class="kw iu"/><a class="ae lq" href="https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">jetpack-compose 1.0</strong></a>稳定发布后，我开始探索UI框架。</p><p id="0747" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">声明式用户界面是未来的趋势，所以我想我应该试一试——相信我，我很喜欢它。</p><p id="23aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你来自一个<a class="ae lq" href="http://flutter.dev/" rel="noopener ugc nofollow" target="_blank"> Flutter </a>背景或者任何声明式UI背景，那么理解Jetpack Compose声明式UI实现是非常容易的。</p><h1 id="1a09" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">你将建造什么</h1><p id="8554" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们跳到精彩的部分:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/7a974e8919309a0e31025f1177c40738.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*q3pNbnYH8eZ3FDuUb5oeYg.gif"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[项目演示]</p></figure><p id="9f2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你是jetpack-compose的新手，你可以通过阅读这篇文章开始你的<a class="ae lq" href="https://ashuflutterdev.medium.com/building-counter-app-like-flutter-using-jetpack-compose-1-0-67ac3b13a778" rel="noopener">旅程。</a></p><h1 id="0a98" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">项目结构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/702ce616f99221ca31c0b84c2324729f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*oqZFgsBQnaELf3avHb4Osw.png"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[项目结构]</p></figure><ul class=""><li id="2693" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">Model</code> —该文件夹包含数据类和伪数据。</li><li id="bd5f" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">Screens</code> —此文件夹包含应用程序的屏幕。</li><li id="1a3e" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">Navigation</code> —该文件夹包含导航结构。</li><li id="a68a" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">Widget</code> —该文件夹包含一些可重用撰写小部件</li></ul><p id="350e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们直接进入代码吧！</p><h1 id="81f0" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak"> 1。数据模型</strong></h1><p id="7671" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">开始创建数据类— <code class="fe nd ne nf ng b">InstaUserData</code>是一个只读类(没有setters)，所以我们需要使用如下所示的<code class="fe nd ne nf ng b">val</code>关键字:</p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="d9ab" class="nq ls it ng b gy nr ns l nt nu">data class InstaUserData<br/>    (<br/>    val id: String,<br/>    val username: String,<br/>    val name: String,<br/>    val isFollow: Boolean,<br/>    val bio: String,<br/>    val profilePic: String,<br/>    val post: Int,<br/>    val noOfFollowers: Int,<br/>    val noOfFollowing: Int,<br/>    val imagePost: <em class="nv">List</em>&lt;String&gt;,<br/><br/>    )</span></pre><p id="a3e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们用返回列表<code class="fe nd ne nf ng b">InstaUserData</code> <strong class="kw iu">的虚拟数据创建一个函数。</strong></p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="7670" class="nq ls it ng b gy nr ns l nt nu">fun getUsers(): <em class="nv">List</em>&lt;InstaUserData&gt; {<br/>    return <em class="nv">listOf</em>(<br/>        InstaUserData(<br/>            id = "1",<br/>            username = "ashu8", name = "Ashutosh",<br/>            isFollow = false,<br/>            post = 12,<br/>            noOfFollowers = 30,<br/>            noOfFollowing = 30,<br/>            imagePost = <em class="nv">listOf</em>(<br/>                "https://i.picsum.photos/id/1005/5760/3840.jpg?hmac=2acSJCOwz9q_dKtDZdSB-OIK1HUcwBeXco_RMMTUgfY",<br/>                "https://i.picsum.photos/id/1024/1920/1280.jpg?hmac=-PIpG7j_fRwN8Qtfnsc3M8-kC3yb0XYOBfVzlPSuVII",<br/>                "https://i.picsum.photos/id/1015/6000/4000.jpg?hmac=aHjb0fRa1t14DTIEBcoC12c5rAXOSwnVlaA5ujxPQ0I"<br/>            ),<br/>            bio = "Unapologetically Me.\\n\" +\n" +<br/>                    "                    \"An introvert soul stuck into an extrovert body. ",<br/>            profilePic = "https://i.picsum.photos/id/1005/5760/3840.jpg?hmac=2acSJCOwz9q_dKtDZdSB-OIK1HUcwBeXco_RMMTUgfY"<br/>        ),<br/>)<br/>}</span></pre><h1 id="7ddb" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">2.惰性柱</h1><p id="8a26" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">一个<code class="fe nd ne nf ng b"><a class="ae lq" href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#lazycolumn" rel="noopener ugc nofollow" target="_blank">LazyColumn</a></code>是一个垂直滚动的列表，它只组成和布局当前可见的项目。它类似于经典Android View系统中的一个<code class="fe nd ne nf ng b">RecyclerView</code>。</p><p id="be47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">listview.kt</code>的代码如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[列表视图文件]</p></figure><p id="3b14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，在widget文件夹中添加<code class="fe nd ne nf ng b">listwidget</code>文件。</p><p id="df5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在该文件中，编写"<code class="fe nd ne nf ng b">BuildList</code>"可组合函数，其参数采用一个<code class="fe nd ne nf ng b">InstaUserData</code>的<code class="fe nd ne nf ng b">list</code>和一个<code class="fe nd ne nf ng b">onClick</code>函数<code class="fe nd ne nf ng b">onItemClick</code>。</p><ol class=""><li id="fbf6" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp ny na nb nc bi translated"><code class="fe nd ne nf ng b">BuildList</code>可组合函数取<code class="fe nd ne nf ng b">LazyColumn</code>。在惰性列中有一个方法<code class="fe nd ne nf ng b">item</code>，它采用<code class="fe nd ne nf ng b">List&lt;T&gt;</code>，其中<code class="fe nd ne nf ng b">T</code>是<code class="fe nd ne nf ng b">Type</code>——在我们的例子中，item是<code class="fe nd ne nf ng b">List&lt;InstaUserData&gt;</code>。</li><li id="6891" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">正如你所看到的，UI列表有一个<code class="fe nd ne nf ng b">User</code>图像、<code class="fe nd ne nf ng b">name</code>、<code class="fe nd ne nf ng b">username</code>和一个<code class="fe nd ne nf ng b">button</code>在<code class="fe nd ne nf ng b">Row</code>中，所以在item方法中，我们传递了可组合为lambda的<code class="fe nd ne nf ng b">Row</code>。在<code class="fe nd ne nf ng b">Row</code>中，有一个修饰符<code class="fe nd ne nf ng b">clickable</code>使得每一行都是可点击的，它采用我们在<code class="fe nd ne nf ng b">BuildList</code>函数中定义为参数的函数<code class="fe nd ne nf ng b">onItemClick</code>，并借助于<code class="fe nd ne nf ng b">it</code>(在后面的<code class="fe nd ne nf ng b">lambda</code>函数中，参数将被隐式声明在名称<code class="fe nd ne nf ng b">it)</code>下，关键字我们可以得到列表的id。</li><li id="2feb" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">为了从互联网上获取用户图像，我们必须在依赖关系部分下的<code class="fe nd ne nf ng b">build.gradle</code>文件中添加<a class="ae lq" href="https://coil-kt.github.io/coil/compose/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">线圈</strong> </a>库:</li></ol><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="9958" class="nq ls it ng b gy nr ns l nt nu">dependencies {<br/>.....<br/>    implementation "io.coil-kt:coil-compose:&lt;latest-version&gt;"<br/>}</span></pre><p id="b65f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在使用<code class="fe nd ne nf ng b">rememberImagePainter</code>函数创建一个可以由<code class="fe nd ne nf ng b">Image</code>组件绘制的<code class="fe nd ne nf ng b">ImagePainter</code>。</p><p id="cddf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">4.可组合垫片用于填充剩余空间。</p><p id="9cfa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">5.制作一个带有参数的<code class="fe nd ne nf ng b">BuildButton Composable</code>,参数包括按钮的名称和颜色。在<code class="fe nd ne nf ng b">InstaUserData</code>类中有一个参数:<code class="fe nd ne nf ng b">isFollow</code>，它接受布尔值，因此在<code class="fe nd ne nf ng b">isFollow</code>的帮助下，我们可以在这里检查它是否为真，然后它返回下面的按钮else Follow。</p><p id="8e54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">6.在<code class="fe nd ne nf ng b">Image</code>的帮助下添加更多图标，可使用打印机资源功能从可绘制文件夹中获取图像。</p><p id="b9cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么我们完成了<code class="fe nd ne nf ng b">ListView</code>让我们开始导航编码，当用户点击任何用户列表时，它导航到用户详细信息屏幕。</p><h1 id="5592" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">3.导航建筑</h1><p id="8596" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">导航组件——一套现代工具和库，用于处理android中复杂的导航案例。</p><p id="be7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">导航组件有3个主要部分:</p><p id="047d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">NavigationGraph</code>I .)<br/>ii .)<code class="fe nd ne nf ng b">NavHost</code> <br/> iii。)<code class="fe nd ne nf ng b">NavController</code></p><p id="c904" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nd ne nf ng b">navigation</code>文件夹中添加<code class="fe nd ne nf ng b">kotlin</code>文件<code class="fe nd ne nf ng b">navigation.kt</code> <strong class="kw iu">。</strong>在这个文件中，我们将创建一个<code class="fe nd ne nf ng b">enum</code>并列出应用程序所有可能的屏幕。</p><p id="f6d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">Navigation_enum.kt</code>的代码是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[导航枚举文件]</p></figure><ol class=""><li id="760e" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp ny na nb nc bi translated">创建枚举类名<code class="fe nd ne nf ng b">NavigationScreen</code>并将所有屏幕定义为枚举<br/>，因为第一个屏幕是<code class="fe nd ne nf ng b">MainScreen</code>，下一个是<code class="fe nd ne nf ng b">DetailsScreen</code> <strong class="kw iu">。</strong></li><li id="030f" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">在enum类内部创建一个<code class="fe nd ne nf ng b">companion</code>对象(companion object就像一个<code class="fe nd ne nf ng b">static</code>关键字来声明类的成员并使用它们而不创建任何对象)在companion对象内部创建一个从<code class="fe nd ne nf ng b">NavigationScreen</code>继承而来的函数<code class="fe nd ne nf ng b">fromRoute</code>，然后我们使用<code class="fe nd ne nf ng b">when</code>关键字来检查路由。</li></ol><p id="3eaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成<code class="fe nd ne nf ng b">NavigationScreen</code>后，我们必须创建实际导航，只需转到导航文件夹创建一个新的<code class="fe nd ne nf ng b">kotlin</code>文件。<code class="fe nd ne nf ng b">main_navigation.kt</code></p><p id="2f53" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基本上，在这个文件中，我们将创建一个我在上面讨论过的结构，让我们开始吧。</p><h1 id="6f97" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建<strong class="ak">导航控制器</strong></h1><p id="fc31" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">但是首先，您必须向您的<code class="fe nd ne nf ng b">build.gradle</code>文件添加依赖项</p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="9353" class="nq ls it ng b gy nr ns l nt nu">dependencies {<br/> .....<br/>implementation("androidx.navigation:navigation-compose:&lt;latest-version&gt;")<br/>}</span></pre><p id="9d6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">NavController</code>是导航组件的核心API。它是有状态的，跟踪组成应用程序屏幕的组件的堆栈以及每个屏幕的状态。</p><p id="f81d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以通过使用您的可组合组件中的方法来创建一个<code class="fe nd ne nf ng b">NavController</code>:</p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="010b" class="nq ls it ng b gy nr ns l nt nu">val navController = rememberNavController()</span></pre><h1 id="658f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">创建NavHost</h1><p id="429c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">每个<code class="fe nd ne nf ng b">NavController</code>必须与一个单独的<code class="fe nd ne nf ng b">NavHost</code>组件相关联。</p><p id="aadd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建<code class="fe nd ne nf ng b">NavHost</code>需要之前通过<code class="fe nd ne nf ng b">rememberNavController()</code>创建的<code class="fe nd ne nf ng b">NavController</code>和您的图表的起始目的地的路线。</p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="c623" class="nq ls it ng b gy nr ns l nt nu">NavHost(navController = navController, startDestination = NavigaionScreen.<em class="nv">MainScreen</em>.name) <strong class="ng iu">{<br/><br/>//here we put actual graph builder( Nav Graph)<br/>    </strong><em class="nv">composable</em>(<br/>        NavigaionScreen.<em class="nv">MainScreen</em>.name<br/>    ) <strong class="ng iu">{<br/>        </strong>HomeScreen(navController = navController)<br/>    <strong class="ng iu">}<br/> </strong><em class="nv">composable</em>(<br/>        NavigaionScreen.<em class="nv">DetailScreen</em>.name<br/>    ) <strong class="ng iu">{<br/>        </strong>DetailScreen(navController = navController)<br/>    <strong class="ng iu">}</strong></span><span id="37a4" class="nq ls it ng b gy nz ns l nt nu"><strong class="ng iu">}</strong></span></pre><h2 id="e248" class="nq ls it bd lt oa ob dn lx oc od dp mb ld oe of md lh og oh mf ll oi oj mh ok bi translated"><strong class="ak">传递导航参数</strong></h2><p id="9301" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们假设当用户点击任何列表时，我们必须将用户id传递给下一个页面，并根据用户id获取用户数据。</p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="6be3" class="nq ls it ng b gy nr ns l nt nu"><em class="nv">composable</em>(NavigaionScreen.<em class="nv">DetailsScreen</em>.name +"/{userId}", <strong class="ng iu">//1</strong><br/>    arguments = <em class="nv">listOf</em>(<em class="nv">navArgument</em>(name = "userId") <strong class="ng iu">{<br/>        </strong>type =<br/>            NavType.StringType <br/>    <strong class="ng iu">}</strong>) <strong class="ng iu">//2</strong><br/>)<br/><br/><strong class="ng iu">{ </strong>backStackEntry <strong class="ng iu">-&gt;  //3<br/>    </strong>DetailsScreen(<br/>        navController = navController, backStackEntry.arguments?.getString("userId")<br/><br/>    )<br/><strong class="ng iu">}</strong></span></pre><ol class=""><li id="1781" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp ny na nb nc bi translated">在网络上，我们有像<code class="fe nd ne nf ng b">https://facebook.com/user/id=4</code>这样的链接，我们还必须在路线中添加变量。因此，追加保存信息的变量名。</li><li id="a8dd" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">在一个可组合函数中，有一个参数<code class="fe nd ne nf ng b">argument</code>接受一个参数列表，这里我们只传递一个参数<code class="fe nd ne nf ng b">navArgument</code> <strong class="kw iu"> </strong>，它接受的参数名称与传递的路径和参数类型相同，在本例中，它是一个字符串。</li><li id="6496" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated"><code class="fe nd ne nf ng b">backStackEntry</code> —从<code class="fe nd ne nf ng b">composable()</code>函数的λ中可用的<code class="fe nd ne nf ng b">NavBackStackEntry</code>中提取<code class="fe nd ne nf ng b">NavArguments</code>。</li></ol><p id="44d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是<code class="fe nd ne nf ng b">main_navigation.kt</code>文件的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[导航结构文件]</p></figure><p id="9728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经完成了导航和LazyColumn，所以让我们看看我们的主屏幕代码现在是什么样子的，它构建了用户UI列表。</p><p id="a2df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">homescreen.kt</code>的代码是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[主屏幕文件]</p></figure><ol class=""><li id="d0fb" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp ny na nb nc bi translated">在<code class="fe nd ne nf ng b">HomeScreen</code>中，我们通过<code class="fe nd ne nf ng b">NavController</code>进行导航操作</li><li id="e145" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">这里我们使用的是<code class="fe nd ne nf ng b">BuildList</code> composable，它接受在我们的数据类中定义的<code class="fe nd ne nf ng b">InstaUserData</code>的列表。</li><li id="c61b" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">如果你记得<code class="fe nd ne nf ng b">BuildList</code>可组合函数也有一个函数参数，它在这里接受字符串，当导航到<code class="fe nd ne nf ng b">DetailScreen</code> <strong class="kw iu">时，我们在<code class="fe nd ne nf ng b">DeatilScreen</code>中传递<code class="fe nd ne nf ng b">id</code>。</strong></li></ol><p id="d51e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">MainActivity.kt</code>文件的代码为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[主活动文件]</p></figure><p id="7d7b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们必须关注详细信息屏幕，在详细信息屏幕中有两个主要视图:</p><ul class=""><li id="ec5e" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">GridView</code></li><li id="f9ea" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">TabBarView</code></li></ul><h1 id="6b65" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">4.网格视图</h1><p id="397f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">可组合函数允许我们创建一个懒惰的网格布局。</p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="e9d7" class="nq ls it ng b gy nr ns l nt nu">@Composable<br/>fun BuildGridView(data: <em class="nv">List</em>&lt;String&gt;) {<br/>LazyVerticalGrid( <br/>       cells = GridCells.Fixed(3),<strong class="ng iu">//1 </strong>   <br/>    contentPadding = PaddingValues(8.dp)<br/> )<br/> { <br/>       items(data.size)<strong class="ng iu">//2</strong><br/> {         <br/>   Card(     <br/>           modifier = Modifier.padding(2.dp)                    .size(120.dp), backgroundColor = Color.Gray ) <strong class="ng iu">//3</strong><br/>{                <br/> Image(painter = rememberImagePainter(data = data[it]),                     contentDescription = null, contentScale = ContentScale.FillBounds,                 )           <br/> }      <br/> }  <br/>}<br/>}</span></pre><ol class=""><li id="fcc5" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp ny na nb nc bi translated">要构建一个有三列的网格，我们可以使用参数<code class="fe nd ne nf ng b">cells</code>的<code class="fe nd ne nf ng b">GridCells.Fixed(3)</code>值。</li><li id="780c" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">添加项目计数。</li><li id="1c50" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">定义<code class="fe nd ne nf ng b">Card</code>可组合单个项目显示的内容。</li></ol><p id="02c2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nd ne nf ng b">gridview.kt</code>的代码是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[网格视图可组合]</p></figure><h1 id="724a" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated"><strong class="ak"> 5。标签栏视图</strong></h1><p id="fd61" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">一个<code class="fe nd ne nf ng b">TabRow</code>包含一行选项卡，并在当前选择的选项卡下显示一个指示器。</p><pre class="kj kk kl km gt nm ng nn no aw np bi"><span id="7771" class="nq ls it ng b gy nr ns l nt nu">@OptIn(ExperimentalFoundationApi::class)<br/>@Composable<br/><br/><br/>fun PostTabView(data:<em class="nv">List</em>&lt;String&gt;) {<br/>    val tagData=<em class="nv">listOf</em>(<br/>        "https://picsum.photos/id/121/1600/1067",<br/>        "https://picsum.photos/id/123/4928/3264",<br/>        "https://picsum.photos/id/128/3823/2549"<br/>    );<br/><br/>    var selectedTabIndex by remember {<strong class="ng iu">  //1<br/>        </strong><em class="nv">mutableStateOf</em>(0)<br/>    }<strong class="ng iu"><br/>    </strong>val imageList =<br/>        <em class="nv">listOf</em>(painterResource(id = R.drawable.<em class="nv">layout</em>), painterResource(id = R.drawable.<em class="nv">tags</em>))  <strong class="ng iu">//2</strong><br/><br/>    <em class="nv">Column </em>{<strong class="ng iu"><br/>        </strong>TabRow(<br/>            selectedTabIndex = selectedTabIndex, <br/>            backgroundColor = Color.Transparent,<br/>            contentColor = Color.Black,<br/><br/>            )<strong class="ng iu"> </strong>{<strong class="ng iu"><br/>            </strong>imageList.<em class="nv">forEachIndexed </em>{ index, item <strong class="ng iu">-&gt;  //3<br/>                </strong><em class="nv">Tab</em>(<br/>                    selected = selectedTabIndex == index,<br/>                    selectedContentColor = Color.Black,<br/>                    unselectedContentColor = Color.Gray,<br/>                    onClick = { <strong class="ng iu">  //4<br/>                        </strong>selectedTabIndex = index  <br/><br/>                   <strong class="ng iu"> </strong>}<strong class="ng iu"><br/>                </strong>) {<strong class="ng iu"><br/>                    </strong><em class="nv">Icon</em>(<br/>                        painter = item,<br/>                        contentDescription = "post",<br/>                        tint = if (selectedTabIndex == index) Color.Black else Color.Gray,<br/>                        modifier = Modifier<br/>                            .<em class="nv">padding</em>(10.<em class="nv">dp</em>)<br/>                            .<em class="nv">size</em>(30.<em class="nv">dp</em>)<br/>                    )<br/>                }<strong class="ng iu"><br/>          </strong>  }<strong class="ng iu"><br/>       </strong> }<strong class="ng iu"><br/>        </strong>when (selectedTabIndex) { <br/>            0 -&gt; BuildGridView(data)<strong class="ng iu">// inflate the first tab</strong><br/>            1 -&gt; BuildGridView(tagData)<strong class="ng iu">// inflate the second tab</strong><br/>        }<br/>    }<strong class="ng iu"><br/><br/><br/></strong>}</span></pre><ol class=""><li id="da74" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp ny na nb nc bi translated">这里我们用<code class="fe nd ne nf ng b">mutableStateOf(0)</code>定义标签索引的状态。0将是初始值。</li><li id="5358" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">我们还定义了一个从drawable获取图像的列表<code class="fe nd ne nf ng b">painterResource</code>。</li><li id="e118" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp ny na nb nc bi translated">通过使用<em class="nv"> </em> <code class="fe nd ne nf ng b">forEachIndexed</code>循环我们绘制出<code class="fe nd ne nf ng b">Tab</code>可组合。</li></ol><p id="0679" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可组合的选项卡包括:</p><ul class=""><li id="ce3e" class="mu mv it kw b kx ky la lb ld mw lh mx ll my lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">selected</code> —该页签是否被选中</li><li id="a8ca" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">onClick</code> —选择该选项卡时调用的回调</li><li id="eda2" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">selectedContentColor</code> —该页签被选中时内容的颜色，以及波纹的颜色。</li><li id="0888" class="mu mv it kw b kx nh la ni ld nj lh nk ll nl lp mz na nb nc bi translated"><code class="fe nd ne nf ng b">unselectedContentColor</code> —未选中时该页签内容的颜色</li></ul><p id="08be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们完成了<code class="fe nd ne nf ng b">GridView</code>和<code class="fe nd ne nf ng b">TabBar View</code>的构建。</p><p id="fc2d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看<code class="fe nd ne nf ng b">profilescreen.kt</code>文件中的<code class="fe nd ne nf ng b">DetailsScreen</code>代码是什么样子的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[配置文件屏幕文件]</p></figure><h1 id="367e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">输出</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/6675b24d7fcf42c3fdb9818113982e44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*EhEOUTDyquyywzLU9FJYxQ.gif"/></div><p class="mp mq gj gh gi mr ms bd b be z dk translated">[最终项目演示][作者提供的gif</p></figure><p id="d5f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以在下面找到该项目的源代码:</p><div class="om on gp gr oo op"><a href="https://github.com/ashut08/decoding_jetpack_compose_series/tree/main/decoding_jetpack_compose_part-0" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">decoding _ jetpack _ compose _ series/decoding _ jetpack _ compose _ part-0 at main…</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">在GitHub上创建一个帐户，为ashut 08/decoding _ jetpack _ compose _ series开发做贡献。</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">github.com</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div><p id="abdb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读。</p></div></div>    
</body>
</html>