<html>
<head>
<title>6 JavaScript Techniques for Improved Code Readability and Maintainability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6提高代码可读性和可维护性的JavaScript技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-javascript-techniques-to-help-you-write-cleaner-code-a5f867a6c750?source=collection_archive---------4-----------------------#2021-12-15">https://betterprogramming.pub/6-javascript-techniques-to-help-you-write-cleaner-code-a5f867a6c750?source=collection_archive---------4-----------------------#2021-12-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="af97" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用这6种代码清理技术提升你的JavaScript技能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/17eac2324a01f496ebe7c8c51abb4f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTFvayWjKah7pL3kl1nN6A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@baher366?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">巴赫尔·凯里</a>在<a class="ae ky" href="https://unsplash.com/s/photos/six?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="9d4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript灵活而强大。然而，有时会很棘手。在JavaScript不断发展并带来新挑战的同时，我们在日常工作中也反复遇到类似的问题。</p><p id="35b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论6个技巧，它们可以帮助您编写干净且可维护的JavaScript代码。</p><p id="b382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">向前跳跃:</em></p><ul class=""><li id="8a7e" class="lw lx it lb b lc ld lf lg li ly lm lz lq ma lu mb mc md me bi translated"><a class="ae ky" href="#64d1" rel="noopener ugc nofollow">同时或顺序执行多个异步承诺</a></li><li id="8056" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#01e5" rel="noopener ugc nofollow">使用console.time解决性能问题</a></li><li id="b757" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#44d8" rel="noopener ugc nofollow">使用选项对象模式处理传递给函数的多个参数</a></li><li id="0231" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#8854" rel="noopener ugc nofollow">组合多种功能</a></li><li id="78cf" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#543e" rel="noopener ugc nofollow">使用析构提取数据</a></li><li id="8fdd" class="lw lx it lb b lc mf lf mg li mh lm mi lq mj lu mb mc md me bi translated"><a class="ae ky" href="#27ec" rel="noopener ugc nofollow">有效使用数组</a></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="64d1" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">1.同时或顺序执行多个异步承诺</h1><p id="53f2" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">默认情况下，JavaScript是同步的。为了处理异步代码，一种常见的方法是使用Promise。与可能导致<a class="ae ky" href="http://callbackhell.com/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>的回调相比，Promise提供了一种更好的方式来处理多个异步请求。</p><p id="2e5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理多个异步请求时，我们可能需要根据用例同时或顺序处理它们。</p><h2 id="b02c" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated"><strong class="ak">同时处理多个承诺</strong></h2><p id="150f" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">JavaScript提供了<code class="fe oa ob oc od b">Promise.all()</code>方法来处理并发请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><h2 id="6875" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated"><strong class="ak">依次处理多个承诺</strong></h2><p id="0884" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">当您需要一个接一个地执行多个异步请求时，这可能有点棘手。你的第一反应可能是使用<code class="fe oa ob oc od b">forEach </code>或<code class="fe oa ob oc od b">map</code>，但它们并不像预期的那样工作。承诺不会等到完成后才开始下一个。</p><p id="b01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不使用第三方库，最好的方法是使用<code class="fe oa ob oc od b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">reduce</a></code> <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> </a> metod。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cc0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的reduce方法中，我们在每次迭代中返回一个解析为另一个承诺的承诺。结果是一连串的承诺，使得异步操作一个接一个地执行。</p><p id="3240" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如输出中所示，虽然我将第一个承诺的超时设置为4秒，第二个承诺的默认值为2秒，但是第一个承诺在第二个承诺之前首先被解析。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/abf248dedeed69d62701aa191514c0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*S94fZoW2wsh1qM12RiuGXw.png"/></div></figure><p id="53ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然<code class="fe oa ob oc od b">reduce </code>本身是同步的，但是它允许我们将承诺返回给累加器的能力使得解决方案很好地工作。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="01e5" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">2.使用console.time解决性能问题</h1><p id="a587" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">有时候，我们需要调试JavaScript函数来分析性能。<code class="fe oa ob oc od b"> console.time</code>方法是现成的，可以帮助我们测量执行时间。</p><p id="e8cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">控制台对象提供了<code class="fe oa ob oc od b">time()</code>和<code class="fe oa ob oc od b">timeEnd()</code>方法。首先，我们用一个唯一的字符串标签调用<code class="fe oa ob oc od b">console.time()</code>方法，它启动一个计时器来跟踪代码执行的持续时间。然后我们运行要测量的函数。最后，我们用相同的标签调用<code class="fe oa ob oc od b">console.timeEnd()</code>，持续时间将在浏览器控制台中打印出来。</p><p id="e0a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果需要用多个步骤调试代码，可以启动多个计时器，用单独的计时器测量不同的步骤，以获得更清晰的画面。</p><p id="8641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个有两个定时器的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="4d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出是:</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="2174" class="no ms it od b gy ol om l on oo">Time taken accumlateNumbers: 9.656005859375 ms</span><span id="3164" class="no ms it od b gy op om l on oo">Time taken by callAccumlateFunction: 10.19677734375 ms</span></pre><p id="bb76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意<code class="fe oa ob oc od b">console.time</code>不适合需要高精度的时间测量。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="44d8" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">3.使用Options对象模式处理传递给函数的多个参数</h1><p id="7f19" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">options对象模式是为了解决向函数传递许多参数的问题。</p><p id="af0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在向函数传递参数列表的正常方式中，我们需要注意参数的顺序。不正确的顺序会产生难以检测的缺陷。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="7693" class="no ms it od b gy ol om l on oo">function createUser(lastName, firstName, jobTitle, role){};</span><span id="c48f" class="no ms it od b gy op om l on oo">// we try to create a admin user<br/>createUser(“John”,”Paul”,"admin", ”Manager”);</span></pre><p id="eba2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于options对象模式，我们只需要传递一个参数，它是一个包含所有参数选项的命名键的对象。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="cb4d" class="no ms it od b gy ol om l on oo">function createUser({lastName, firstName, jobTitle, role}){};</span><span id="c78e" class="no ms it od b gy op om l on oo">const user = {<br/>  firstName: 'John', <br/>  lastName: 'John', <br/>  jobTitle:'Manager', <br/>  role: 'Admin'<br/>};<br/>createUser(user);</span></pre><p id="5a33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上面的代码片段所示，不仅我们不需要担心参数的顺序，而且带有option对象模式的命名参数使代码更容易阅读。</p><p id="9cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">options对象模式通常用于四个或更多参数的情况。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="8854" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">4.组合多种功能</h1><p id="eeba" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">函数组合是将多个函数组合在一起，并将每个函数应用于前一个函数的结果的方法。当在正确的用例中使用时，函数组合可以使您的代码简洁而优雅。</p><p id="9ea0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8012" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的方法是可行的，但是当更多的函数组合在一起时，就很难理解了。更好的方法是使用下面的compose函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="de5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通用的<code class="fe oa ob oc od b">compose </code>函数可以接受多个函数作为输入，并逐个调用它们。因此我们称<code class="fe oa ob oc od b">compose </code>为<a class="ae ky" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">高阶函数</a>。高阶函数的优势在于它能够以一种极具表现力的方式组合多个运算。</p><p id="5877" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，它使用了<code class="fe oa ob oc od b">reduceRight </code>，这意味着功能是从右向左执行的。另一种方法是下面的<code class="fe oa ob oc od b">pipe </code>方法。它用的是<code class="fe oa ob oc od b">reduce</code>，所以顺序是从左到右。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="b187" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用功能组合鼓励开发人员将程序分解成更小的部分，并将动作或行为抽象成功能。它让你先考虑输入和输出，而不是关注实现细节。</p><p id="110b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果将是更具可读性、可测试性和可重用性的代码。</p><p id="bd46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在现实世界的项目中，函数组合的正确用例包括数据处理、复杂规则的计算、工作流操作等。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="543e" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">5.使用析构来提取数据</h1><p id="b5bb" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">析构是将值从对象属性或数组解包到多个变量的一种简单而简洁的方法。</p><p id="cde2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">析构的基本例子有:</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="000d" class="no ms it od b gy ol om l on oo">const user = {<br/>    name: 'John Paul',<br/>    age: 23<br/>};<br/>// from object properties<br/>const {name, age} = user;</span><span id="3b45" class="no ms it od b gy op om l on oo">const count= ['one', 'two', 'three'];<br/>// array destructuring<br/>const [first, second, third] = count;</span></pre><p id="3c48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提供了一些有用的析构特性，包括默认值、跳过数组元素、分配新的变量名等。你可以在这里找到完整的列表<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="0db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一些我经常使用的实际例子。</p><h2 id="62ef" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">从函数结果析构</h2><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="be90" class="no ms it od b gy ol om l on oo">function getUser() {<br/>  return {name: ‘John’, age: 24};<br/>}<br/>const {name, age} = getUser(); // name='John', age=24</span></pre><h2 id="8a05" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">分割数组</h2><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="e0f9" class="no ms it od b gy ol om l on oo">const<!-- --> <!-- -->[first,<!-- --> <!-- -->...rest]<!-- --> <!-- -->=<!-- --> <!-- -->['1',<!-- --> <!-- -->'2',<!-- --> <!-- -->'3', '4'];<br/>// output: first='1', rest=['2',<!-- --> <!-- -->'3', '4']</span></pre><h2 id="92a8" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">从数组中获取第一个元素</h2><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="fd2f" class="no ms it od b gy ol om l on oo">const fruits = [‘apple’, ‘orange’, ‘pear’];</span><span id="73dc" class="no ms it od b gy op om l on oo">[first] = fruits; // first= 'apple'</span></pre><h2 id="b4c8" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated">promise.all()的析构结果</h2><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="b473" class="no ms it od b gy ol om l on oo">Promise.all([ promise1, promise2, promise3])<br/>.then( results =&gt;{    <br/>    const [first, second, third] = results;<br/>})</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="27ec" class="mr ms it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">6.有效地使用阵列</h1><p id="1521" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">数组是我们大多数人日常处理的最常见的数据结构。以下是对阵列操作的一些提示:</p><h2 id="add8" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated"><strong class="ak">使用切片对数组进行不变排序</strong></h2><p id="d022" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们经常希望对数组进行排序，并得到一个不可变的副本。不幸的是，<code class="fe oa ob oc od b">.sort</code>会改变原来的数组。使用下面的<code class="fe oa ob oc od b">slice </code>,我们可以得到一个排序后的数组，而不会影响原来的数组。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="22da" class="no ms it od b gy ol om l on oo">const newArr = arr.slice().sort()</span></pre><p id="578d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，切片返回原始数组中元素的浅层副本。如果你需要做深度克隆，你可能喜欢使用<a class="ae ky" href="https://javascript.plainenglish.io/deep-clone-an-object-and-preserve-its-type-with-typescript-d488c35e5574?sk=34e6444aa1dfa44621a315c2f3ed936c" rel="noopener ugc nofollow" target="_blank">不同的方法</a>。</p><h2 id="b3eb" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated"><strong class="ak">从数组中删除重复项</strong></h2><p id="4fb7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">有多种方法可以从数组中删除重复项。最简单也是我最喜欢的方法是使用<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">设置</a>。</p><p id="d6cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Set是在ES6中引入的，它表示唯一值的列表。在下面的示例中，我们使用spread运算符将集合运算的结果作为数组返回。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="3b46" class="no ms it od b gy ol om l on oo">const arr = [1,2,3,2,3,4,5];<br/>console.log([...new Set(arr)]); // [1,2,3,4,5]</span></pre><p id="c1e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，Set方法只对原始值有效。</p><h2 id="83bd" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated"><strong class="ak">从数组中过滤出falsy值</strong></h2><p id="4593" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">在JavaScript中，falsy值可以是空字符串、false、0、null、NaN或undefined。下面是我最喜欢的从数组中过滤虚假值的方法。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="69dd" class="no ms it od b gy ol om l on oo">const arrToFilter = ["user", "", 0,  NaN, 9, true, undefined, "red", false];<br/>const result = mixedArr.filter(Boolean);<br/>console.log(result); // returns ["user", 9, true, "red"]</span></pre><p id="4979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你以前没有用过，你可能会想知道<code class="fe oa ob oc od b"> filter(Boolean)</code>是如何工作的？</p><p id="2405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">布尔是一个对象包装器。在<code class="fe oa ob oc od b">filter(Boolean)</code>方法中，数组中的每一项都被传入并按如下方式计算。结果不是true就是falsy，falsy值将被过滤掉。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="7bbf" class="no ms it od b gy ol om l on oo">.filter(x=&gt; Boolean(x));</span></pre><h2 id="a0d1" class="no ms it bd mt np nq dn mx nr ns dp nb li nt nu nd lm nv nw nf lq nx ny nh nz bi translated"><strong class="ak">使用Array.every和Array.some简化代码</strong></h2><p id="f7f3" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe oa ob oc od b">Array.every</code>和<code class="fe oa ob oc od b">Array.some</code>是简化代码的非常方便的方法。与其他方法如<code class="fe oa ob oc od b">forEach </code>或<code class="fe oa ob oc od b">reduce</code>相比，<code class="fe oa ob oc od b">Array.every</code>和<code class="fe oa ob oc od b">Array.some</code>使代码更具可读性和简洁。</p><pre class="kj kk kl km gt oh od oi oj aw ok bi"><span id="d0eb" class="no ms it od b gy ol om l on oo">const users = [<br/>    { name: 'john', role: 'admin' },<br/>    { name: 'peter', role: 'dev' },<br/>    { name: 'mary', role: 'dev' }<br/>  ];<br/>const isAllDeveloperRole = users.every(f =&gt; f.role === 'dev');</span><span id="6a47" class="no ms it od b gy op om l on oo">const hasDeveloperRole = users.some(f =&gt; f.role === 'dev');</span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="facb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">希望这篇文章对你有用。如果你有其他的JavaScript技巧可以分享，请添加到下面的评论中。</p><p id="6c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你也可以看看下面的文章。</p><div class="oq or gp gr os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/6-typescript-code-patterns-to-make-your-code-more-robust-bbe54354f39f"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd iu gy z fp oy fr fs oz fu fw is bi translated">6种类型脚本代码模式，使您的代码更加健壮</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">您可以在日常工作中应用的简单实用的解决方案</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">better编程. pub</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ks ot"/></div></div></a></div><p id="9207" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快乐编程</p></div></div>    
</body>
</html>