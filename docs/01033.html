<html>
<head>
<title>Functional JS From Α to Ω: Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从α到ω的泛函JS:映射</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3?source=collection_archive---------10-----------------------#2019-08-08">https://betterprogramming.pub/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3?source=collection_archive---------10-----------------------#2019-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3e57" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">B.地图功能——我们神圣的三位一体中的第一个</h2></div><blockquote class="ki"><p id="0940" class="kj kk it bd kl km kn ko kp kq kr ks dk translated">“Map”是一个重要的构造，不仅因为它捕获了一个公共模式，还因为它在处理列表时建立了一个更高层次的抽象。"</p><p id="c2ca" class="kj kk it bd kl km kt ku kv kw kx ks dk translated">— SICP，1979年</p></blockquote><figure class="kz la lb lc ld le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ky"><img src="../Images/0e7f5c313907a394762e5f383284d1d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lkWnbtOoqnAY7sqllBadrA.jpeg"/></div></div><p class="ll lm gj gh gi ln lo bd b be z dk translated">照片由<a class="ae lp" href="https://unsplash.com/@devindtx" rel="noopener ugc nofollow" target="_blank"> Devin Edwards </a>在<a class="ae lp" href="https://unsplash.com/photos/V7T7_A0FIIY" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="lq lr ls"><p id="0bb7" class="lt lu lv lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo ks im bi translated">我们JavaScript编码人员有机会实践一种支持函数式编程的多范例语言。</p><p id="807f" class="lt lu lv lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo ks im bi translated">你想学习那种力量吗？</p><p id="60c2" class="lt lu lv lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo ks im bi translated">让我们从24课开始，从α到ω，解决我们的日常问题。课程概述:<a class="ae lp" href="https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-8dc0cfe1f4e1" rel="noopener"> α。forEach </a>，<a class="ae lp" href="https://medium.com/better-programming/functional-js-from-%CE%B1-to-%CF%89-map-9173adf7ea3" rel="noopener"> β。地图</a>，γ.滤镜。</p></blockquote></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="099f" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">神圣地图</h1><p id="1e94" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">为什么历史上最伟大的编程语言之一被谦逊地命名为<a class="ae lp" href="https://lisp-lang.org/" rel="noopener ugc nofollow" target="_blank"> Lisp </a>，用于<em class="lv">列表处理</em>？</p><p id="9d1a" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">为什么函数式程序员会对一个名为<code class="fe nw nx ny nz b"><em class="lv">map</em></code>的函数大惊小怪？</p><p id="c134" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">这些问题的答案都是一样的，都与信息学的本质有关。</p><p id="90bf" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们整天做的就是<em class="lv">重新映射</em> <strong class="lw iu"> </strong> 0和1链，到其他的0和1链。它们最终代表了影响现实世界的新信号(给屏幕着色、移动机械臂、构建网站等)。).</p><p id="be89" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">总是相同的<em class="lv">图灵完成</em>过程，并且，现在，我们被那个卡住了。</p><p id="16d5" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">好消息是，它足以几乎做任何事情！就像原子创造了宇宙，自远古以来不断运动和重组。</p><p id="e614" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">即便如此，在你15年的编程历程中，你可以忽略<code class="fe nw nx ny nz b">map</code>的定义，因为它做的非常简单，非常核心。你只是每天不点名地做。</p><p id="38b5" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated"><code class="fe nw nx ny nz b">map</code> <em class="lv"> </em>函数转换列表中的每个元素，并保持其原来的顺序。我们的数据库包含单数形式的鸟类，但我们需要视图中的复数形式:</p><figure class="oa ob oc od gt le"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="df11" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们已经在规划过程中。很常见吧？这就是计算机所做的:存储数据(<code class="fe nw nx ny nz b">birds</code>数组)，运行程序(为每只鸟添加一个<code class="fe nw nx ny nz b">s</code>的函数)，然后触发动作(在控制台中记录结果)…并重复。</p><p id="1c8c" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">那么，为什么对列表的操作如此重要呢？</p><p id="d0d6" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">因为，在能够使用任何类型的数据之前，我们必须就数据的模型达成一致。</p><p id="0388" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">黑白图像文件可以是由<code class="fe nw nx ny nz b">true</code> <em class="lv"> </em>和<code class="fe nw nx ny nz b">false</code> <em class="lv"> </em>像素组成的矩阵。“人”可以包括姓名或年龄。我们很自然地转向那些新的模型，那些形象/人物应该是什么样的结构良好的抽象。</p><p id="d840" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">创建抽象的需要来自于在相同类型的几个对象上，用共同的“属性”一次又一次地重复同样的事情的想法…我们最终得到以相同方式格式化的对象列表，也就是所谓的<em class="lv">集合</em>。</p><p id="fa91" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">事实上，我们正在描述一个“领域”,在这个领域中，我们将定义存储数据和创建专用代数的方法。</p><p id="4a81" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">让我们把一个<code class="fe nw nx ny nz b">persons</code>的集合转换成别的东西:</p><figure class="oa ob oc od gt le"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="c73f" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">你能用<code class="fe nw nx ny nz b">setPlurals</code> <em class="lv"> </em>功能找出常见零件吗？</p><p id="a1bd" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">在<code class="fe nw nx ny nz b">persons</code>的例子中，我们需要一个全新的数组来存储<code class="fe nw nx ny nz b">ages</code>，因为我们不想删除程序剩余部分的<code class="fe nw nx ny nz b">persons</code><em class="lv"/>——通过网络获取原始的人员列表可能代价很高。</p><p id="7efb" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">为了在一个独特的、可重用的函数中重新分解列表的转换，让我们编写第一个<code class="fe nw nx ny nz b">map</code>:</p><figure class="oa ob oc od gt le"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="d327" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">如您所见，这里的小技巧是为<code class="fe nw nx ny nz b">map</code>函数本身提供一个函数——在循环过程中<code class="fe nw nx ny nz b">map</code>会注意在每个元素上运行它。</p><p id="f39d" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">的确，<code class="fe nw nx ny nz b">map</code>是一个<em class="lv">高阶函数；</em>将另一个函数(通常称为<em class="lv">回调</em>)作为参数的函数，然后在自己的主体中运行它。</p><p id="3c96" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们的<em class="lv">映射</em>签名是<code class="fe nw nx ny nz b">map::(Function, any[]) -&gt; any[]</code>，其中第一个参数<code class="fe nw nx ny nz b">Function</code>类型是我们的<em class="lv">回调</em>。第二个参数<code class="fe nw nx ny nz b">any[]</code>是任何类型元素的数组。并且<code class="fe nw nx ny nz b">map</code>当然会返回新的<code class="fe nw nx ny nz b">any[]</code>列表。</p><p id="3aa5" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们提供给<code class="fe nw nx ny nz b">map</code>的<em class="lv">回调</em>的签名应该类似于<code class="fe nw nx ny nz b">callback::any -&gt; any</code>，代表一个元素的自由转换，应用于每个元素。</p><p id="f4a7" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们的<code class="fe nw nx ny nz b">map</code>比<code class="fe nw nx ny nz b">setPlurals</code>好多了；我们不想修改原始列表，以防以后需要单数形式的鸟。</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="431c" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">神圣的数据</h1><p id="4020" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">函数式程序员就是这么想的:不变性。</p><p id="dd9b" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们不喜欢仅仅根据程序现在应该做什么来改变数据。我们保留原始数据。转换带来了新的数据，为安全调试、重构和未来的改进做好了准备。</p><p id="3e33" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">面向对象哲学和FP方法之间的主要对立是，对我们来说，数据是冻结的事实。我们想保护它们，我们想让它们保持原样。</p><p id="59d3" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">对我们来说，函数不应该作为唯一的方法绑定到对象上。你可以用椅子来坐，但你也可以用它来拿架子上的果酱罐。</p><p id="af42" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们假设<code class="fe nw nx ny nz b">chair.sit()</code>听起来还可以，但是<code class="fe nw nx ny nz b">chair.takeJarJamOfShelf()</code>呢？为什么不是<code class="fe nw nx ny nz b">person.sit()</code>，或者<code class="fe nw nx ny nz b">bird.sit()</code>？这听起来像是你将总是以一个“上帝物品”结束，伴随着产品所有者的新需求。</p><p id="1a41" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">此外，谁知道我们可以在年龄和姓名之间发现什么新的相关性，为我们未来的系谱部门服务？</p><p id="c465" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">FP保持对代码库的控制，分离数据(金矿)，计算(纯函数转换数据，提炼黄金)，和效果(影响现实世界的行为…利润！).</p><p id="350a" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">但是这种不变性还有第二个目的；我们的精神负担减轻了。</p><p id="ecb0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">如果我们从不共享变化的数据，我们总是能确定我们接受什么作为输入，我们也能确定我们传递什么作为输出。代码库的每一部分仍然是作用域良好的，没有需要记忆和回忆的变量历史。阅读代码的随机部分仍然相对容易。</p><p id="371a" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">如果我运行<code class="fe nw nx ny nz b">setPlurals</code>两次，我会得到<code class="fe nw nx ny nz b">["kestrelss", "kitess"]</code> <em class="lv"> </em>，我的应用程序现在有问题了。</p><p id="61bc" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">并且，在1000行代码中，它肯定会发生！</p><p id="6aef" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">但是如果我跑1000次，我会保证我的小鸟们的安全。</p><p id="e025" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">那么<code class="fe nw nx ny nz b">map</code>到底是什么？对一系列值的一般迭代，产生一系列新的转换值。</p><p id="d1fb" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">一旦你习惯了，每次看到一个列表+一个<code class="fe nw nx ny nz b">map</code> +一个函数的应用，你就会明白新列表的形式了。</p><figure class="oa ob oc od gt le"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="3fe2" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我们已经通过代码控制了列表转换，以一种非常雄辩和可重用的方式。</p><p id="216f" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">就像<code class="fe nw nx ny nz b">forEach</code>一样，JavaScript有自己内置的<code class="fe nw nx ny nz b">map</code>，作为array的原型方法。它的签名是<code class="fe nw nx ny nz b">map::Function -&gt; any[]</code>，列表是隐式的<code class="fe nw nx ny nz b">this</code>数组，调用<code class="fe nw nx ny nz b">map</code>。</p><p id="2e4f" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">回调签名是<code class="fe nw nx ny nz b">cb::(any, number?, any[]?) -&gt; any</code>，其中<code class="fe nw nx ny nz b">number?</code>是可选的索引，<code class="fe nw nx ny nz b">any[]?</code>是可选的完整数组——我们也将在上一版本中实现它，因为它可能有用。</p><p id="07b6" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">所以现在，你会完全理解它，并每天重复使用它。</p><p id="81a1" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">因为这个<code class="fe nw nx ny nz b">map</code>像我们的<code class="fe nw nx ny nz b">map</code>一样，返回一个新的数组，我们可以很容易地用其他不可变的数组方法一点一点地链接它，比如<code class="fe nw nx ny nz b">concat</code>、<code class="fe nw nx ny nz b">filter</code>和<code class="fe nw nx ny nz b">slice</code> …</p><p id="4b7d" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">直到我们找到一个不返回任何东西的方法，比如<code class="fe nw nx ny nz b">forEach</code>，它将通过一个动作打破转换链，这是控制台中的一个副作用。</p><figure class="oa ob oc od gt le"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0afe" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">我在最后提到这个原生的<code class="fe nw nx ny nz b">map</code>，因为我希望你开始以一种功能性的方式思考，超越内置的工具。</p><p id="1c34" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">从某种意义上来说，<code class="fe nw nx ny nz b">Array.prototype.map</code>表现出和<code class="fe nw nx ny nz b">Chair.prototype.takeJamJarOnShelf</code>一样的缺失。</p><p id="c2b0" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated"><code class="fe nw nx ny nz b"><em class="lv">map</em></code>不应该只绑定到数组，应该是可组合的。事实上，<code class="fe nw nx ny nz b">map</code>概念也与<code class="fe nw nx ny nz b">observables</code>、<code class="fe nw nx ny nz b">promises</code>、树和其他类型的容器一起被大量使用，这些容器也授权有序内容转换。</p><p id="9462" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">再深入一点，你可以在JavaScript引擎中想象下面的前奏<strong class="lw iu"> </strong>，在它运行你的代码之前(请不要重写任何内置的原型，我们在这里这么做只是为了科学)。</p><figure class="oa ob oc od gt le"><div class="bz fp l di"><div class="oe of l"/></div></figure></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="8e83" class="mw mx it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">皇冠蛋糕</h1><p id="b49e" class="pw-post-body-paragraph lt lu it lw b lx no ju lz ma np jx mc nq nr mf mg ns nt mj mk nu nv mn mo ks im bi translated">其实你会在FP里随处看到<code class="fe nw nx ny nz b">map</code>。</p><p id="5ab5" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">一个<em class="lv">可绘制地图的容器在这个世界上是很重要的。这就是为什么我们将会有第二篇文章从更高的角度专门讨论<code class="fe nw nx ny nz b">map</code>，但这是以后的事了。</em></p><p id="0fdd" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">现在，最后一步当然是curry过程，并为<code class="fe nw nx ny nz b">map</code>回调提供一个索引和完整的数组。</p><p id="dae2" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">但是，像往常一样，如果你没有得到它，它将在未来的课程中解释，所以不要担心。坚持读下去熟悉一下就好了。</p><figure class="oa ob oc od gt le"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6bf2" class="pw-post-body-paragraph lt lu it lw b lx ly ju lz ma mb jx mc nq me mf mg ns mi mj mk nu mm mn mo ks im bi translated">是的，编程很有趣。</p></div></div>    
</body>
</html>