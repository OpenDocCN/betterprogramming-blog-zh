<html>
<head>
<title>Combining Unrelated Git Repositories: When Projects Collide!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">组合不相关的Git库:当项目冲突时！</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/when-projects-collide-combining-two-unrelated-git-repositories-414fba42ff3d?source=collection_archive---------6-----------------------#2022-05-07">https://betterprogramming.pub/when-projects-collide-combining-two-unrelated-git-repositories-414fba42ff3d?source=collection_archive---------6-----------------------#2022-05-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1558" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">如何合并两个Git仓库？</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/baaf6cdb3d4c8b9fed3611257a19832b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gtubWMRPVyRVLZDQHqf8Kw.jpeg"/></div></div></figure><p id="1bcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最近开始了一个项目，为chrome构建一个AI支持的书签扩展，使用单独的git库来创建内容:一个用于Chrome扩展，一个用于React/TypeScript前端。</p><p id="baff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为从独立的存储库开始会更简单，一旦每个部分都有了基本的功能，再将它们组合起来会更简单。最终，我需要组合这些库，以便在chrome扩展中使用<a class="ae ln" href="https://developer.chrome.com/docs/extensions/mv3/user_interface/#popup" rel="noopener ugc nofollow" target="_blank">弹出菜单</a>和<a class="ae ln" href="https://developer.chrome.com/docs/extensions/mv3/override/" rel="noopener ugc nofollow" target="_blank">书签页面覆盖</a>的前端。</p><p id="e04f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在谷歌上搜索，找到了这个关于如何将一个存储库合并到另一个存储库的简洁且投票良好的答案:</p><div class="lo lp gp gr lq lr"><a href="https://stackoverflow.com/questions/1425892/how-do-you-merge-two-git-repositories" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">如何合并两个Git存储库？</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">基本上，我重写了我的插件库的历史，这样看起来所有的开发都发生在…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">stackoverflow.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf kp lr"/></div></div></a></div><p id="7e48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它绝对值得一读，而且从定义上来说，它是本文的TLDR。</p><p id="ffb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在仔细阅读了那里的评论后，我决定一行一行地阅读推荐的方法，并对照<a class="ae ln" href="https://git-scm.com/docs/" rel="noopener ugc nofollow" target="_blank"> git文档</a>进行检查，以便更好地理解在他们所说的“<a class="ae ln" href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain" rel="noopener ugc nofollow" target="_blank">瓷器</a>下发生了什么。你很幸运，我做了笔记。</p><p id="5b0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是投票最高且被接受的将<code class="fe mg mh mi mj b">project-a</code>合并到<code class="fe mg mh mi mj b">project-b,</code>的解决方案供参考，其行号链接到以下解释:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="0e01" class="mo mp iq mj b gy mq mr l ms mt"><a class="ae ln" href="#f4b5" rel="noopener ugc nofollow">1</a> cd path/to/project-b<br/><a class="ae ln" href="#5529" rel="noopener ugc nofollow">2</a> git remote add project-a /path/to/project-a<br/><a class="ae ln" href="#03be" rel="noopener ugc nofollow">3</a> git fetch project-a --tags<br/><a class="ae ln" href="#eea7" rel="noopener ugc nofollow">4</a> git merge --allow-unrelated-histories project-a/master # or whichever branch you want to merge<br/><a class="ae ln" href="#8a88" rel="noopener ugc nofollow">5</a> git remote remove project-a</span></pre><p id="b0a2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们很容易就开始了:</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="f4b5" class="mo mp iq mj b gy mq mr l ms mt"><a class="ae ln" href="#0e01" rel="noopener ugc nofollow">1</a> cd path/to/project-b</span></pre><p id="8bba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mg mh mi mj b">cd</code>命令将您的工作目录更改为<code class="fe mg mh mi mj b">project-b</code>，这样我们就可以将<code class="fe mg mh mi mj b">project-a</code>合并到其中。简单:)</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="5529" class="mo mp iq mj b gy mq mr l ms mt"><a class="ae ln" href="#0e01" rel="noopener ugc nofollow">2</a> git remote add project-a /path/to/project-a</span></pre><div class="lo lp gp gr lq lr"><a href="https://git-scm.com/docs/git-remote" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">Git - git远程文档</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">不带参数，显示现有遥控器的列表。有几个子命令可用于在…上执行操作</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">git-scm.com</p></div></div><div class="ma l"><div class="mu l mc md me ma mf kp lr"/></div></div></a></div><p id="98ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mg mh mi mj b">git remote</code>命令“管理其分支被跟踪的一组存储库(“远程”)，我们稍后也会再次使用它。<br/> <code class="fe mg mh mi mj b">git remote add</code>从指定的路径或url添加命名的远程存储库。因此，我们在这里将<code class="fe mg mh mi mj b">project-a</code>作为远程存储库从位置<code class="fe mg mh mi mj b">/path/to/project-a</code>添加到<code class="fe mg mh mi mj b">project-b</code>存储库中。</p><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="03be" class="mo mp iq mj b gy mq mr l ms mt"><a class="ae ln" href="#0e01" rel="noopener ugc nofollow">3</a> git fetch project-a --tags </span></pre><div class="lo lp gp gr lq lr"><a href="https://git-scm.com/docs/git-fetch" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">获取文档</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">获取所有遥控器。-a - append将提取的引用的引用名称和对象名称追加到…的现有内容中</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">git-scm.com</p></div></div><div class="ma l"><div class="mv l mc md me ma mf kp lr"/></div></div></a></div><p id="31c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mg mh mi mj b">git fetch </code>‘从另一个存储库中下载对象和引用’。<br/> <code class="fe mg mh mi mj b">fetch</code>从指定的存储库中下载分支和标记(统称为“refs”)以及完成它们的历史所需的对象。任何指向引用历史的标签也被获取。<br/>使用<code class="fe mg mh mi mj b">--tags</code>选项将所有标签从远程‘refs/tags/’目录提取到本地存储库的同名标签中。由于这些项目都很年轻，我还没有开始对它们进行版本化，所以我没有任何有价值的标签来组合，所以我不打算在我的命令中包含— tags标志。</p><blockquote class="mw mx my"><p id="c19a" class="kr ks mz kt b ku kv jr kw kx ky ju kz na lb lc ld nb lf lg lh nc lj lk ll lm ij bi translated">关于标签的更多深度，请参考我在下面的<a class="ae ln" href="#0682" rel="noopener ugc nofollow">转移。</a></p></blockquote><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="eea7" class="mo mp iq mj b gy mq mr l ms mt"><a class="ae ln" href="#0e01" rel="noopener ugc nofollow">4</a> git merge --allow-unrelated-histories project-a/master # or whichever branch you want to merge<!-- --> </span></pre><div class="lo lp gp gr lq lr"><a href="https://git-scm.com/docs/git-merge" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">git-git-合并文档</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">提交-不提交执行合并并提交结果。此选项可用于覆盖不提交。与……</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">git-scm.com</p></div></div><div class="ma l"><div class="nd l mc md me ma mf kp lr"/></div></div></a></div><p id="87b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们用<code class="fe mg mh mi mj b">git merge</code>得到了过程的实质，它将两个或更多的开发历史连接在一起。</p><p id="52b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mg mh mi mj b">merge</code>命令将来自指定提交的更改合并到当前分支中。它将“重放”在指定提交的分支上所做的提交更改，因为它与当前分支不同，并将结果连同两个父提交的名称和来自用户的日志消息一起记录在新提交中。您可能已经知道，这是一个常见的场景，在一个存储库中有多个分支，这是merge命令通常被设计和使用的方式。它通过将命名提交分支中文件的状态与当前分支中相同文件的状态进行比较，并使用差分算法来查找它们的分歧点。当重叠的改变或“冲突”被呈现给用户以选择使用哪一版本的线时，非重叠的改变被自动做出。</p><p id="bfaa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与其深挖底层机制，我只指出<a class="ae ln" href="https://stackoverflow.com/questions/14961255/how-does-git-merge-work-in-details" rel="noopener ugc nofollow" target="_blank">这个简单的答案</a>是对git默认的三路合并算法的很好介绍，对<a class="ae ln" href="https://git-scm.com/docs/merge-strategies" rel="noopener ugc nofollow" target="_blank">不同合并策略</a>的很好概述，以及<a class="ae ln" href="https://www.atlassian.com/git/tutorials/using-branches/git-merge" rel="noopener ugc nofollow" target="_blank"> Atlassian的有价值的教程</a>条目。</p><p id="0285" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，我们没有合并具有共享历史的分支，所以<code class="fe mg mh mi mj b">--allow-unrelated-histories</code>标志明确地让我们合并没有共同祖先的两个历史。如果这些是同一个项目的不同版本，这将是一个潜在的灾难性操作，可能会使我们的工作树丢失提交，没有办法恢复，这就是引入标志的原因。然而，将两个独立的项目结合起来，这些问题就不可能了。</p><p id="5477" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于真正喜欢冒险的人来说，这里是<code class="fe mg mh mi mj b">git merge</code>的实际实现<a class="ae ln" href="https://github.com/git/git/blob/74cc1aa55f30ed76424a0e7226ab519aa6265061/builtin/merge.c#L299" rel="noopener ugc nofollow" target="_blank">,其中带有字符串<em class="mz">‘allow _ needrable’</em>的页面中的快速查找将在代码中遍历到处理<code class="fe mg mh mi mj b">--allow-unrelated-histories</code>标志的位置。</a></p><blockquote class="mw mx my"><p id="0ed1" class="kr ks mz kt b ku kv jr kw kx ky ju kz na lb lc ld nb lf lg lh nc lj lk ll lm ij bi translated">从文档中得到的一个重要注意是，确保您的工作树对命名的和当前的分支(或者在我们的例子中是存储库)上的所有变更都是最新的，没有您可能关心的未完成的未分级的变更。如果不是这样，那些显著的变化就有可能丢失。</p></blockquote><pre class="kg kh ki kj gt mk mj ml mm aw mn bi"><span id="8a88" class="mo mp iq mj b gy mq mr l ms mt"><a class="ae ln" href="#0e01" rel="noopener ugc nofollow">5</a> git remote remove project-a</span></pre><p id="1990" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们返回到<code class="fe mg mh mi mj b">git remote</code>并使用<code class="fe mg mh mi mj b">git remote remove</code>从<code class="fe mg mh mi mj b">project-b</code>的远程跟踪中移除命名的<code class="fe mg mh mi mj b">project-a</code>。从<code class="fe mg mh mi mj b">project-b</code>中移除了<code class="fe mg mh mi mj b">project-a</code>的所有远程跟踪分支和配置设置，因此我们现在合并的项目不再引用仍然存在的<code class="fe mg mh mi mj b">project-a</code>。在我们成功地将<code class="fe mg mh mi mj b">project-a</code>的文件和历史记录合并到<code class="fe mg mh mi mj b">project-b</code>之后，通过解耦这两个存储库，我们的过程就完成了。</p><blockquote class="mw mx my"><p id="0841" class="kr ks mz kt b ku kv jr kw kx ky ju kz na lb lc ld nb lf lg lh nc lj lk ll lm ij bi translated">如果我们不想再保留原始<code class="fe mg mh mi mj b">project-a</code>的副本，我们可以包含类似<code class="fe mg mh mi mj b">rm -rf path/to/project-a</code>的行。</p></blockquote><p id="830f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我清理了两个项目的工作树，然后运行这些命令来合并我的两个项目。就像回答评论里宣传的那样顺利，只有我的一行冲突。gitignore文件很容易修复。如果你已经读到这里，我希望你有一些回复可以一起分享！祝你好运！</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="0682" class="nl mp iq bd nm nn no np nq nr ns nt nu jw nv jx nw jz nx ka ny kc nz kd oa ob bi translated">Git中标签的转移</h1><p id="4b89" class="pw-post-body-paragraph kr ks iq kt b ku oc jr kw kx od ju kz la oe lc ld le of lg lh li og lk ll lm ij bi translated">在这里，我觉得有必要更新一下git中的标签功能。再一次，优秀的git文档展示了它。</p><div class="lo lp gp gr lq lr"><a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab fo"><div class="lt ab lu cl cj lv"><h2 class="bd ir gy z fp lw fr fs lx fu fw ip bi translated">Git标签</h2><div class="ly l"><h3 class="bd b gy z fp lw fr fs lx fu fw dk translated">像大多数VCS一样，Git能够将存储库历史中的特定点标记为重要点。通常情况下…</h3></div><div class="lz l"><p class="bd b dl z fp lw fr fs lx fu fw dk translated">git-scm.com</p></div></div><div class="ma l"><div class="oh l mc md me ma mf kp lr"/></div></div></a></div><p id="08ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本质上，git中的标记可以用来为特定的提交创建标签，允许您以后引用它。它们允许一个指向特定提交的规范引用点，而不是从特定提交开始然后跟踪更改的分支。这特别考虑到了版本化符号，因此特定的提交可以被标记为例如<code class="fe mg mh mi mj b">v1.4</code>并在以后通过git命令引用。</p><p id="7abd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有两种类型的标签:“轻量级”和“带注释的”。</p><p id="485d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">轻量级仅存储标记名和对提交校验和的引用。它可以用于存储临时标签，作为对过渡状态的引用，或者通常存储不期望被维护/共享的标签。</p><p id="48bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">带注释的标记包括一条消息和一个标记名，并在git数据库中存储一个完整的校验和对象，包括标记者的信息和标记日期。这是大多数标签的推荐标签类型，因为它提供了完整的信息，并且如果需要，可以由GPG签名和验证。</p><p id="8eb9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个很好的特性是能够在事后标记提交，因此在版本控制的情况下，标记过程不必实时发生，而是可以单独管理。</p><p id="f8b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当使用例如<code class="fe mg mh mi mj b">git push</code>到远程时，标签是默认不共享的，所以就像我们的<code class="fe mg mh mi mj b">git fetch --tags</code>调用一样，如果需要，存在一个<code class="fe mg mh mi mj b">git push --tags</code>选项来将标签发送到远程存储库。</p></div></div>    
</body>
</html>