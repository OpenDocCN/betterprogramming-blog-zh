<html>
<head>
<title>Add Tests to Express Apps With Jest and SuperTest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jest和SuperTest向Express应用程序添加测试</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/adding-tests-to-express-apps-with-jest-and-supertest-d0e7aaac4c08?source=collection_archive---------2-----------------------#2020-02-27">https://betterprogramming.pub/adding-tests-to-express-apps-with-jest-and-supertest-d0e7aaac4c08?source=collection_archive---------2-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f3c9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过可靠的测试防止应用程序故障</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/fe478be2e4e3289708a17b8eecfac826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*eH_7aOX9rf5_SRNY_klHUg.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://unsplash.com/@zlg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">钟</a>在<a class="ae ku" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</p></figure><p id="f968" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">自动化测试对我们编写的应用程序至关重要，因为现代应用程序有如此多的活动部件。</p><p id="433e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在本文中，我们将看看如何编写应用程序来测试一个Express应用程序，该应用程序使用<a class="ae ku" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae ku" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> SuperTest </a>与数据库进行交互。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8abb" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">创建我们将测试的应用程序</h1><p id="398f" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">我们通过创建一个空文件夹来创建一个项目文件夹，并运行以下命令来创建一个带有默认答案的<code class="fe mv mw mx my b">package.json</code>文件:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="36ac" class="nd lz it my b gy ne nf l ng nh">npm init -y</span></pre><p id="bf1f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们运行以下程序来为我们的应用程序安装软件包:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="f34c" class="nd lz it my b gy ne nf l ng nh">npm i express sqlite3 body-parser</span></pre><p id="b225" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们为我们的应用程序创建<code class="fe mv mw mx my b">app.js</code>文件，并编写:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="13fd" class="nd lz it my b gy ne nf l ng nh">const express = require('express');<br/>const sqlite3 = require('sqlite3').verbose();<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>const port = process.env.NODE_ENV === 'test' ? 3001 : 3000;<br/>let db;<br/>if (process.env.NODE_ENV === 'test') {<br/>    db = new sqlite3.Database(':memory:');<br/>}<br/>else {<br/>    db = new sqlite3.Database('db.sqlite');<br/>}</span><span id="2947" class="nd lz it my b gy ni nf l ng nh">db.serialize(() =&gt; {<br/>    db.run('CREATE TABLE IF NOT EXISTS persons (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)');<br/>});</span><span id="f14c" class="nd lz it my b gy ni nf l ng nh">app.use(bodyParser.json());<br/>app.get('/', (req, res) =&gt; {<br/>    db.serialize(() =&gt; {<br/>        db.all('SELECT * FROM persons', [], (err, rows) =&gt; {<br/>            res.json(rows);<br/>        });<br/>    })<br/>})</span><span id="63b7" class="nd lz it my b gy ni nf l ng nh">app.post('/', (req, res) =&gt; {<br/>    const { name, age } = req.body;<br/>    db.serialize(() =&gt; {<br/>        const stmt = db.prepare('INSERT INTO persons (name, age) VALUES (?, ?)');<br/>        stmt.run(name, age);<br/>        stmt.finalize();<br/>        res.json(req.body);<br/>    })<br/>})</span><span id="d2de" class="nd lz it my b gy ni nf l ng nh">app.put('/:id', (req, res) =&gt; {<br/>    const { name, age } = req.body;<br/>    const { id } = req.params;<br/>    db.serialize(() =&gt; {<br/>        const stmt = db.prepare('UPDATE persons SET name = ?, age = ? WHERE id = ?');<br/>        stmt.run(name, age, id);<br/>        stmt.finalize();<br/>        res.json(req.body);<br/>    })<br/>})</span><span id="7f9c" class="nd lz it my b gy ni nf l ng nh">app.delete('/:id', (req, res) =&gt; {<br/>    const { id } = req.params;<br/>    db.serialize(() =&gt; {<br/>        const stmt = db.prepare('DELETE FROM persons WHERE id = ?');<br/>        stmt.run(id);<br/>        stmt.finalize();<br/>        res.json(req.body);<br/>    })<br/>})</span><span id="2d6c" class="nd lz it my b gy ni nf l ng nh">const server = app.listen(port);<br/>module.exports = { app, server };</span></pre><p id="2fa3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上面的代码包含了我们将要测试的应用程序。</p><p id="0b34" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了让我们的应用更容易测试，我们有:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3bb0" class="nd lz it my b gy ne nf l ng nh">const port = process.env.NODE_ENV === 'test' ? 3001 : 3000;<br/>let db;<br/>if (process.env.NODE_ENV === 'test') {<br/>    db = new sqlite3.Database(':memory:');<br/>}<br/>else {<br/>    db = new sqlite3.Database('db.sqlite');<br/>}</span></pre><p id="638f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">因此，我们可以将<code class="fe mv mw mx my b">process.env.NODE_ENV</code>设置为<code class="fe mv mw mx my b">'test'</code>，让我们的应用程序监听一个与它在非测试环境中运行时不同的端口。</p><p id="4698" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将使用<code class="fe mv mw mx my b">'test'</code>环境来运行我们的测试。</p><p id="fe81" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">同样，我们希望我们的应用程序在运行单元测试时使用与不运行时不同的数据库。</p><p id="6b96" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这就是为什么我们有:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="347d" class="nd lz it my b gy ne nf l ng nh">let db;<br/>if (process.env.NODE_ENV === 'test') {<br/>    db = new sqlite3.Database(':memory:');<br/>}<br/>else {<br/>    db = new sqlite3.Database('db.sqlite');<br/>}</span></pre><p id="62f7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们指定当应用程序在<code class="fe mv mw mx my b">'test'</code>环境中运行时，我们希望使用SQLite的内存数据库，而不是数据库文件。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="6b62" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">编写测试</h1><h2 id="2a56" class="nd lz it bd ma nj nk dn me nl nm dp mi le nn no mk li np nq mm lm nr ns mo nt bi translated">初始化代码</h2><p id="6589" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">有了可测试的应用程序，我们就可以向它添加测试。</p><p id="9fa4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将使用Jest test runner和SuperTest在测试中向我们的路线发出请求。为了添加Jest和SuperTest，我们运行:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="8e9d" class="nd lz it my b gy ne nf l ng nh">npm i jest supertest</span></pre><p id="86b9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们将<code class="fe mv mw mx my b">app.test.js</code>添加到与上面的<code class="fe mv mw mx my b">app.js</code>文件相同的文件夹中。</p><p id="581a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在<code class="fe mv mw mx my b">app.test.js</code>中，我们开始编写以下内容:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="e644" class="nd lz it my b gy ne nf l ng nh">const { app } = require('./app');<br/>const sqlite3 = require('sqlite3').verbose();<br/>const request = require('supertest');<br/>const db = new sqlite3.Database(':memory:');</span><span id="29aa" class="nd lz it my b gy ni nf l ng nh">beforeAll(() =&gt; {<br/>    process.env.NODE_ENV = 'test';<br/>})</span></pre><p id="fa89" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的代码中，我们包含了来自<code class="fe mv mw mx my b">app.js</code>的Express应用程序。然后我们还包括了SQLite3和SuperTest包。,</p><p id="75a9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们通过以下方式连接到内存数据库:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="6035" class="nd lz it my b gy ne nf l ng nh">const db = new sqlite3.Database(':memory:');</span></pre><p id="b7b3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们通过运行以下命令将所有测试设置为在<code class="fe mv mw mx my b">'test'</code>环境中运行:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="03bf" class="nd lz it my b gy ne nf l ng nh">beforeAll(() =&gt; {<br/>    process.env.NODE_ENV = 'test';<br/>})</span></pre><p id="7515" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将确保我们为每个测试使用端口<code class="fe mv mw mx my b">3001</code>和我们在<code class="fe mv mw mx my b">app.js</code>中指定的内存数据库。</p><p id="d998" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了使我们的测试独立运行并得到一致的结果，我们必须每次都清理数据库并插入新的数据。</p><p id="40ff" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为此，我们创建了一个在每次测试中调用的函数:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="5d0d" class="nd lz it my b gy ne nf l ng nh">const seedDb = db =&gt; {<br/>    db.run('CREATE TABLE IF NOT EXISTS persons (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)');<br/>    db.run('DELETE FROM persons');<br/>    const stmt = db.prepare('INSERT INTO persons (name, age) VALUES (?, ?)');<br/>    stmt.run('Jane', 1);<br/>    stmt.finalize();<br/>}</span></pre><p id="2a41" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">上面的代码创建了一个<code class="fe mv mw mx my b">persons</code>表(如果它不存在的话),然后删除其中的所有内容。</p><p id="ade7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们在那里插入一个新值，以获得一些起始数据。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="43e8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">添加测试</h1><p id="07b9" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">初始化代码完成后，我们就可以编写测试了。</p><h2 id="ddcd" class="nd lz it bd ma nj nk dn me nl nm dp mi le nn no mk li np nq mm lm nr ns mo nt bi translated"><strong class="ak">获取请求测试</strong></h2><p id="1239" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">首先，我们编写一个测试，用一个<code class="fe mv mw mx my b">GET</code>请求从数据库中获取现有的种子数据。</p><p id="bf58" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们通过编写以下内容来做到这一点:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="7afe" class="nd lz it my b gy ne nf l ng nh">test('get persons', () =&gt; {<br/>    db.serialize(async () =&gt; {<br/>        seedDb(db);<br/>        const res = await request(app).get('/');<br/>        const response = [<br/>            { name: 'Jane', id: 1, age: 1 }<br/>        ]<br/>        expect(res.status).toBe(200);<br/>        expect(res.body).toEqual(response);<br/>    })<br/>});</span></pre><p id="74d9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们把所有东西都放在了<code class="fe mv mw mx my b">db.serialize</code>的回调函数中，这样查询将会按顺序运行。</p><p id="1167" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们调用上面创建的<code class="fe mv mw mx my b">seedDb</code>，如果表不存在就创建它，清空数据库，并添加新数据。</p><p id="7747" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们写信给<code class="fe mv mw mx my b">GET</code>请求:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="de38" class="nd lz it my b gy ne nf l ng nh">await request(app).get('/');</span></pre><p id="5e53" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这使我们得到了从承诺解析出响应的<code class="fe mv mw mx my b">res</code>对象。</p><p id="064b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mv mw mx my b">request(app)</code>将启动Express应用程序，以便我们提出请求。</p><p id="c12b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">接下来，我们要检查<code class="fe mv mw mx my b">response</code>的正确性:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="03a1" class="nd lz it my b gy ne nf l ng nh">const response = [<br/>  { name: 'Jane', id: 1, age: 1 }<br/>]</span></pre><p id="a5de" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们检查回答，看看我们是否得到了我们期望的结果:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="951e" class="nd lz it my b gy ne nf l ng nh">expect(res.status).toBe(200);<br/>expect(res.body).toEqual(response);</span></pre><p id="6a02" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mv mw mx my b">toBe</code>方法检查浅相等，而<code class="fe mv mw mx my b">toEqual</code>检查深相等。所以我们用<code class="fe mv mw mx my b">toEqual</code>来检查整个对象结构是否相同。</p><p id="172a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mv mw mx my b">res.status</code>检查服务器返回的状态码，<code class="fe mv mw mx my b">res.body</code>有响应体。</p><h2 id="7b39" class="nd lz it bd ma nj nk dn me nl nm dp mi le nn no mk li np nq mm lm nr ns mo nt bi translated"><strong class="ak">岗位要求测试</strong></h2><p id="117f" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">接下来，我们为<code class="fe mv mw mx my b">POST</code>请求添加一个测试。这类似于<code class="fe mv mw mx my b">GET</code>请求测试。</p><p id="0d73" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们编写以下代码:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3e52" class="nd lz it my b gy ne nf l ng nh">test('add person', () =&gt; {<br/>    db.serialize(async () =&gt; {<br/>        seedDb(db);<br/>        await request(app)<br/>            .post('/')<br/>            .send({ name: 'Joe', age: 2 });</span><span id="6fb0" class="nd lz it my b gy ni nf l ng nh">        const res = await request(app).get('/');<br/>        const response = [<br/>            { name: 'Jane', id: 1, age: 1 },<br/>            { name: 'Joe', id: 2, age: 2 }<br/>        ]<br/>        expect(res.status).toBe(200);<br/>        expect(res.body).toEqual(response);<br/>    })<br/>});</span></pre><p id="1945" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们用以下内容重置数据库:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="e32e" class="nd lz it my b gy ne nf l ng nh">seedDb(db);</span></pre><p id="6ddf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们向以下人员提出了我们的<code class="fe mv mw mx my b">POST</code>请求:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="7256" class="nd lz it my b gy ne nf l ng nh">await request(app)<br/>  .post('/')<br/>  .send({ name: 'Joe', age: 2 });</span></pre><p id="11eb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这将在内存数据库中插入一个新条目。</p><p id="5267" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后，为了检查正确性，我们发出<code class="fe mv mw mx my b">GET</code>请求——就像我们的第一个测试一样——并检查是否返回了两个条目:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="4982" class="nd lz it my b gy ne nf l ng nh">const res = await request(app).get('/');<br/>const response = [<br/>  { name: 'Jane', id: 1, age: 1 },<br/>  { name: 'Joe', id: 2, age: 2 }<br/>]<br/>expect(res.status).toBe(200);<br/>expect(res.body).toEqual(response);</span></pre><h2 id="e1ce" class="nd lz it bd ma nj nk dn me nl nm dp mi le nn no mk li np nq mm lm nr ns mo nt bi translated"><strong class="ak">上传和删除测试</strong></h2><p id="8049" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated"><code class="fe mv mw mx my b">PUT</code>请求的测试类似于<code class="fe mv mw mx my b">POST</code>请求。我们重置数据库，使用我们的有效负载发出<code class="fe mv mw mx my b">PUT</code>请求，然后发出<code class="fe mv mw mx my b">GET</code>请求以获取返回的数据，如下所示:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="499c" class="nd lz it my b gy ne nf l ng nh">test('update person', () =&gt; {<br/>    db.serialize(async () =&gt; {<br/>        seedDb(db);<br/>        await request(app)<br/>            .put('/1')<br/>            .send({ name: 'Joe', age: 2 });</span><span id="d864" class="nd lz it my b gy ni nf l ng nh">        const res = await request(app).get('/');<br/>        const response = [<br/>            { name: 'Jane', id: 1, age: 1 }<br/>        ]<br/>        expect(res.status).toBe(200);<br/>        expect(res.body).toEqual(response);<br/>    })<br/>});</span></pre><p id="44e3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后我们可以用<code class="fe mv mw mx my b">DELETE</code>请求替换<code class="fe mv mw mx my b">PUT</code>请求，并测试<code class="fe mv mw mx my b">DELETE</code>请求:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="3c09" class="nd lz it my b gy ne nf l ng nh">test('delete person', () =&gt; {<br/>    db.serialize(async () =&gt; {<br/>        seedDb(db);<br/>        const res = await request(app).delete('/1');<br/>        const response = [];<br/>        expect(res.status).toBe(200);<br/>        expect(res.body).toEqual(response);<br/>    })<br/>});</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4f09" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">运行测试</h1><p id="c3ae" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">为了运行测试，我们将以下内容添加到<code class="fe mv mw mx my b">scripts</code>部分:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="4062" class="nd lz it my b gy ne nf l ng nh">"test": "jest --forceExit"</span></pre><p id="0e16" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们必须添加<code class="fe mv mw mx my b">--forceExit</code>选项，这样Jest将在测试运行后存在。使用SuperTest的Jest测试不能正确退出的问题还没有解决。</p><p id="3d4b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">然后，我们运行以下程序来运行测试:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="c6af" class="nd lz it my b gy ne nf l ng nh">npm test</span></pre><p id="4ebd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们应该得到:</p><pre class="kj kk kl km gt mz my na nb aw nc bi"><span id="8982" class="nd lz it my b gy ne nf l ng nh">PASS  ./app.test.js<br/>  √ get persons (11ms)<br/>  √ add person (2ms)<br/>  √ update person (2ms)<br/>  √ delete person (6ms)</span><span id="5af9" class="nd lz it my b gy ni nf l ng nh">Test Suites: 1 passed, 1 total<br/>Tests:       4 passed, 4 total<br/>Snapshots:   0 total<br/>Time:        2.559s<br/>Ran all test suites.<br/>Force exiting Jest: Have you considered using `--detectOpenHandles` to detect async operations that kept running after all tests finished?</span></pre><p id="21dc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">无论我们运行多少次测试，我们都应该得到相同的结果，因为我们重置了数据库，并使所有数据库查询按顺序运行。</p><p id="09d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">此外，我们在测试中使用了与其他环境不同的数据库和端口，所以数据应该是干净的。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="4539" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="9a44" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">我们可以用Jest测试运行器添加测试运行。为此，我们必须有不同的端口和数据库来运行测试。然后，如果这些表不存在，我们就创建它们，清除所有数据，并添加种子数据，这样我们就可以为每个测试提供相同的数据库结构和内容。</p><p id="1925" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">通过SuperTest，我们可以自动运行Express应用程序，并提出我们想要的请求。然后，我们可以检查输出。</p></div></div>    
</body>
</html>