<html>
<head>
<title>8 Advanced Git Commands Universities Won’t Teach You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大学不会教你的8个高级Git命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/8-advanced-git-commands-university-wont-teach-you-fe63b483d34b?source=collection_archive---------1-----------------------#2022-08-08">https://betterprogramming.pub/8-advanced-git-commands-university-wont-teach-you-fe63b483d34b?source=collection_archive---------1-----------------------#2022-08-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bc46" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">先进的提示和技巧，将节省您的时间和头痛。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a55af5dd56c5c34d3cd344cce7a1bc48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*29aj7mvRaVzqXvx0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@domlafou?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dom Fou </a>拍摄的照片</p></figure><p id="a767" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始我的DevOps之旅时，我幸福地意识到我面前的一切。然而，在与一些才华横溢的开发人员密切合作多年后，我开始大步前进。难以置信的是，坐在一位资深开发人员旁边，你可以学到很多东西，他会给你一天的时间，而且以前就在那里。日复一日，从该领域的专家那里获取<strong class="lb iu">知识会教会你在任何在线课程或大学里都找不到的东西。</strong></p><p id="bbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然是的，课程，辅导和学校教育会教你核心概念。今天，我想更深入一点，展示一下我多年来学到的一些有用的技巧和窍门。使用这些高级git命令，我们不仅可以每周节省宝贵的时间；但是要对这个工具有更深的理解。</p><p id="025e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些命令是我在我参与的每个项目中经常使用的，并且已经在我的笔记页面上存在多年了。所以，不多说了，我希望您喜欢我的八大高级git命令</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lv"><img src="../Images/786c12c5761a05e7f2ee27e2b99521ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fLG0WrzYU-ZuAkqAKqT__A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/s/photos/git?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@yancymin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Yancy Min </a>拍摄</p></figure><h1 id="5762" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">1.在Git中搜索</h1><p id="7adb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您正在您的存储库中寻找可能已经删除很久的代码，git有您的答案。使用下面的命令，我们可以在任何提交或分支中搜索任何短语。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7b03" class="my lx it mu b gy mz na l nb nc">$ <strong class="mu iu">git rev-list</strong> --all <strong class="mu iu">|</strong> <strong class="mu iu">xargs</strong> <strong class="mu iu">git grep</strong> -F ‘’</span></pre><p id="a126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您要搜索字符串“clapfor = joelbelton”在您的存储库中:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="78f1" class="my lx it mu b gy mz na l nb nc">$ <strong class="mu iu">git rev-list</strong> –all <strong class="mu iu">|</strong> <strong class="mu iu">xargs</strong> <strong class="mu iu">git grep</strong> -F ‘clapfor=joelbelton;’<br/>C2011:bestdev.py: clapfor=joelbelton;<br/>B9831:devops_technical_writter.json: clapfor=joelbelton;</span></pre><h1 id="bd13" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">2.清理你当地的分支机构</h1><p id="c2f5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们可以删除已经从远程存储库中删除的本地分支。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7bfd" class="my lx it mu b gy mz na l nb nc">git config --global fetch.prune true</span></pre><p id="eb7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以删除已经与我们的示例合并的任何本地分支:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cf73" class="my lx it mu b gy mz na l nb nc">git branch --merged master | grep -v "master" | xargs -n 1 git branch -d</span></pre><h1 id="9f04" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">3.提交计数</h1><p id="5d1d" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">无论您是准备好重新建立基础、收集进度指标，还是只想知道您已经做了多少更改，计算您的提交都是非常有用的。我们还可以使用这些信息来增加内部版本号。</p><p id="e86e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们如何统计这些提交:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="83d9" class="my lx it mu b gy mz na l nb nc">$ <strong class="mu iu">git rev-list</strong> –count master<br/>18<br/>$ <strong class="mu iu">git rev-list</strong> –count feature<br/>2</span></pre><h1 id="c0de" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">4.查看另一个分支的文件</h1><p id="dbca" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们经常想要查看存在于另一个分支上的文件的内容。我们实际上可以做到这一点，而不需要切换分支或浏览git存储库管理器。</p><p id="8c38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您在我们的<strong class="lb iu">主</strong>分支中有一个文件<em class="nd">‘new feature . py’</em>，但是我们正在我们的<strong class="lb iu">开发</strong>分支中工作，这已经落后了。我们可以使用以下命令查看这个新文件:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="cc13" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">$</strong> git show master:newfeature.py</span></pre><h1 id="c5d1" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">5.空白提交</h1><p id="9923" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您正在使用DevOps管道和CI/CD，那么您可能会自动集成git提交。我们实际上可以只使用空白提交，而不是对文档进行小的修改。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="4224" class="my lx it mu b gy mz na l nb nc"><strong class="mu iu">$</strong> <em class="nd">git commit --allow empty -m 'new empty commit'</em></span></pre><p id="657b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将触发我们的工作流，而不必对我们的代码进行细微的更改。</p><h1 id="e2a2" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">6.自动纠正拼写错误</h1><p id="8a76" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">每个人都会犯错误，每个人都在自己的终端上看到过这条消息…</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="aa6b" class="my lx it mu b gy mz na l nb nc">git: ‘stats’ is not a <strong class="mu iu">git</strong> command. See ‘<strong class="mu iu">git</strong> --help’.</span><span id="e750" class="my lx it mu b gy ne na l nb nc">The most similar <strong class="mu iu">command</strong> is<br/>status</span></pre><p id="f5df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能没有意识到，但是Git实际上提供了自动更正命令的配置。添加全局标记意味着它专门应用于您的用户。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9891" class="my lx it mu b gy mz na l nb nc">$ <strong class="mu iu">git config</strong> --global help.autocorrect 1</span></pre><h1 id="d0a3" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">7.自动修剪</h1><p id="8ed2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Git Prune是一个实用命令，它整理掉任何引用都无法到达的孤立Git对象。任何不能通过标记或分支访问的提交都被定义为不可访问。Git prune是一个Git命令，它将清除所有这些对象。</p><p id="440b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，知道你什么时候需要修剪被删除的对象是相当困难的，因为我们的库不会警告我们。幸运的是，通过启用这个git配置，我们可以让git在每次git获取和git拉取时执行一次修剪。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="fe09" class="my lx it mu b gy mz na l nb nc">git config --global fetch.prune true</span></pre><h1 id="3f56" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">8.备份未被跟踪的文件</h1><p id="7f29" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我不知道你怎么样，但是当被要求删除一些未被追踪的文件时，我总是很焦虑。虽然大多数情况下它是完全安全的，但为这些文件创建一个备份会很有帮助，以防你以后需要它们。</p><p id="e1d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用我们的git命令和一个聪明的xargs 的组合，我们可以创建这个整洁的小功能，将所有未跟踪的文件一起备份到一个zip文件中。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="9367" class="my lx it mu b gy mz na l nb nc">$ <strong class="mu iu">git ls-files</strong> --others --exclude-standard -z <strong class="mu iu">|</strong>\<br/><strong class="mu iu">xargs</strong> -0 <strong class="mu iu">tar</strong> rvf ~<strong class="mu iu">/</strong>backup-untracked.zip</span></pre></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="ff43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p><p id="4186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我定期在DevOps上发布文章。如果你想了解更多，我推荐你看看下面的故事:</p><p id="1b0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@joelbelton/modern-debugging-tools-and-tips-you-need-to-stay-ahead-bfe4340d3fa8" rel="noopener">现代调试——保持领先地位所需的工具和技巧</a></p><p id="b617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/@joelbelton/the-most-important-linux-commands-that-nobody-teaches-you-ce423ef2ae28" rel="noopener">没人教你的最重要的Linux命令</a></p></div></div>    
</body>
</html>