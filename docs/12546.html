<html>
<head>
<title>How to Avoid Race Conditions in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免Golang的比赛条件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-avoid-race-conditions-in-golang-5e343146ed61?source=collection_archive---------3-----------------------#2022-06-13">https://betterprogramming.pub/how-to-avoid-race-conditions-in-golang-5e343146ed61?source=collection_archive---------3-----------------------#2022-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f2bb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写安全的并发代码</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dcb6911537bfd7a1b4263f938d864617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D_-zyLgVCyVctAWYrIAHhg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="cad1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Golang中实现并发程序的一个可能的问题是数据竞争条件。本文将详细讨论这一主题，以及用于识别竞争条件可能发生的位置、防止它们的策略以及Golang如何处理不同并发上下文之间共享的数据的技术。</p><p id="e5c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们开始之前，如果您不熟悉Golang中的并发性，我强烈建议您先阅读以下文章:</p><ul class=""><li id="f0c0" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated"><a class="ae md" href="https://levelup.gitconnected.com/concurrency-in-golang-goroutines-and-channels-explained-55ddb5e1881" rel="noopener ugc nofollow" target="_blank">Golang、Goroutines和Channels中的并发性解释</a></li><li id="e0b8" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/file-processing-using-concurrency-with-golang-9e08920fab63">使用GoLang并发处理文件</a></li><li id="56ab" class="lu lv it la b lb me le mf lh mg ll mh lp mi lt lz ma mb mc bi translated"><a class="ae md" rel="noopener ugc nofollow" target="_blank" href="/concurrency-with-select-goroutines-and-channels-9786e0c6be3c">利用Select、Goroutines和Channels在Go中掌握并发性</a></li></ul><h1 id="346f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">什么是竞争条件？</h1><p id="1dd9" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">竞争条件是两个不同的并发上下文同时读写相同的共享数据的结果，导致意外的输出。</p><p id="3e01" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在Golang中，两个并发的goroutines同时访问同一个变量会在程序中产生数据竞争。</p><h2 id="ffd2" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">共享数据</h2><p id="3545" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">当运行多个goroutines时，通常需要在它们之间共享数据。如果没有安全的策略来访问和修改数据，这将导致数据竞争的情况。</p><p id="0638" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在编写并发程序时，确定所有将在goroutines之间共享的变量是至关重要的。</p><h2 id="1bc5" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">关键部分</h2><p id="4c22" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">临界区是一个代码块，其中一个goroutine试图写入一个共享变量。</p><p id="4c07" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">并发程序中的每个关键部分都必须实现一个策略来安全地访问和修改共享数据。</p><h2 id="f92a" class="ng mk it bd ml nh ni dn mp nj nk dp mt lh nl nm mv ll nn no mx lp np nq mz nr bi translated">原子操作</h2><p id="e126" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">当涉及到并发程序中的竞争条件、共享数据和关键部分时，原子性是一个关键概念。</p><p id="8014" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们已经讨论了什么是竞争条件，不同的goroutines如何共享数据，什么是临界区，以及我们需要一种策略来安全地访问和修改临界区内的数据。</p><p id="68a0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当访问和修改共享变量时，并发程序需要遵循的策略是确保临界区中发生的每个操作都是原子的。</p><p id="730c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">原子操作确保在当前进程完成读/写操作之前，没有其他进程/上下文可以读/写共享数据。这意味着共享变量在其被访问/写入的上下文中是原子的。通过在程序的关键部分拥有这种特性，我们可以知道共享数据是并发安全的。因此，竞争条件不会发生。</p><p id="5673" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Golang为内存访问同步提供了原语，因此操作可以是原子的。</p><h1 id="bb80" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">同步。互斥包</h1><p id="dc3b" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated"><code class="fe ns nt nu nv b">sync.Mutex</code>包提供了一种机制来保护代码块，使其成为并发安全的，这意味着在该代码块中的写操作将是安全的。sync包提供的原语允许您使用内存访问同步来编写并发代码，以避免数据竞争情况。</p><p id="968b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个机制由使用包中的<code class="fe ns nt nu nv b">Lock</code>和<code class="fe ns nt nu nv b">Unlock</code>方法组成。</p><p id="3971" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu nv b">Lock</code>方法将确定调用该方法的goroutine刚刚获得了锁，在锁被释放之前，其他go routine不能使用锁。</p><p id="7a26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu nv b">Unlock</code>方法释放锁，以便其他goroutines可以使用它。</p><p id="878b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当一个goroutine正在使用锁，而另一个goroutine也试图获取锁时，该goroutine将阻塞，直到另一个go routine释放锁。</p><p id="f79c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看一个竞争条件的例子，以及我们如何使用锁来解决它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="352c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的场景中，两个goroutines被附加到<code class="fe ns nt nu nv b">numbers</code>的片上。让我们确定共享数据、关键部分和竞争条件。</p><p id="d40c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，很明显<code class="fe ns nt nu nv b">numbers</code>变量的切片是两个go routine共享的数据，但是仍然值得指出来，因为在一个更复杂的程序中，识别几个go routine共享什么数据可能是一个挑战。</p><p id="c404" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本例中的关键部分是第17行和第22行中的两个追加操作，因为我们希望这些操作在它们运行的上下文中是原子的。</p><p id="3ba1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们运行该程序，会产生以下结果:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="9b26" class="ng mk it nv b gy oc od l oe of">// Expected<br/>numbers &amp;[]<br/>numbers &amp;[1 2]</span><span id="f477" class="ng mk it nv b gy og od l oe of">// Expected<br/>numbers &amp;[12]<br/>numbers &amp;[12 1 2]</span><span id="ebff" class="ng mk it nv b gy og od l oe of">// Race condition<br/>numbers &amp;[]<br/>numbers &amp;[1]</span><span id="5dac" class="ng mk it nv b gy og od l oe of">// Race condition<br/>numbers &amp;[]<br/>numbers &amp;[12 1 2]</span></pre><p id="f548" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，该程序不能保证输出是一致的，这是因为两个goroutines同时运行，并且修改了相同的数据。使得无法预测哪个操作将首先发生。从而导致竞态条件。</p><p id="f576" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，将数字附加到共享变量的操作需要是原子的，<code class="fe ns nt nu nv b">sync.Mutex</code>可以帮助我们做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="88b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行该程序现在将只产生两个预期的输出:</p><pre class="kj kk kl km gt ny nv nz oa aw ob bi"><span id="8989" class="ng mk it nv b gy oc od l oe of">// Expected<br/>numbers &amp;[]<br/>numbers &amp;[1 2]</span><span id="d2bd" class="ng mk it nv b gy og od l oe of">// Expected<br/>numbers &amp;[12]<br/>numbers &amp;[12 1 2]</span></pre><p id="a758" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常的做法是调用<code class="fe ns nt nu nv b">mu.Lock()</code>，然后在一个延迟函数中调用<code class="fe ns nt nu nv b">mu.UnLock()</code>方法，这是因为一个复杂的函数有几种可能的终止函数的方法，要么提前返回，要么返回一个错误，使用<code class="fe ns nt nu nv b">defer</code>函数将确保当函数终止时锁被释放，不管它采用哪条路径。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="787e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe ns nt nu nv b">sync</code>包还为只读操作提供了另一种类型的锁。<code class="fe ns nt nu nv b">sync.RWMutex</code>提供了<code class="fe ns nt nu nv b">mu.RLock()</code>和<code class="fe ns nt nu nv b">mu.RUnlock()</code>方法分别获取和释放锁。当您想要锁定一段代码，但该代码块中执行的操作是只读的时，这很有用。</p><h1 id="a20d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">结论</h1><p id="a953" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">Golang中的内存访问同步原语允许您的程序锁定和解锁操作，以便它们能够以并发安全的方式运行。这确保了在不同的goroutines之间共享数据的程序正确运行，并避免了数据竞争的情况。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="b149" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="oo">感谢您的阅读，敬请关注。</em></p></div></div>    
</body>
</html>