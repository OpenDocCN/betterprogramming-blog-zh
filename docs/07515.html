<html>
<head>
<title>Testing the Data Layer in Android Room With Rxjava, Live Data, and Kotlin Coroutines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rxjava、Live Data和Kotlin协同例程在Android Room中测试数据层</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-the-data-layer-in-android-room-with-rxjava-live-data-and-kotlin-coroutines-62d20a8f977a?source=collection_archive---------4-----------------------#2021-01-22">https://betterprogramming.pub/testing-the-data-layer-in-android-room-with-rxjava-live-data-and-kotlin-coroutines-62d20a8f977a?source=collection_archive---------4-----------------------#2021-01-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a7c7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">单元测试房间数据库以构建健壮的应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a9a358d0b548a63a6743a5ec9d1b55e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xw1v0v6tHSPsvEC0"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">斯蒂芬·弗兰克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h2 id="5669" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">内容</h2><ul class=""><li id="c031" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc md me mf mg bi translated">为什么要从数据库层开始测试？</li><li id="80ef" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">数据层概述</li><li id="2cf7" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">对数据库系统中的数据类型进行分类，并</li><li id="7546" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">使用流行的现有库(Jetpack、Rx和Coroutines)测试它们。</li></ul></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="9149" class="mt kx iq bd ky mu mv mw lb mx my mz le jw na jx li jz nb ka lm kc nc kd lq nd bi translated">首先，为什么从数据库层开始测试？</h1><p id="fc42" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">无论您选择哪种架构，无论是MVVM、MVP、MVC还是MVI，数据层都是变化最小的一层。在架构迁移期间，它几乎保持不变。</p><p id="cca1" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated">数据层具有最小的依赖性，这使得它非常容易测试。可以使用Robolectric对其进行单元测试(节省时间)</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="1daa" class="mt kx iq bd ky mu mv mw lb mx my mz le jw na jx li jz nb ka lm kc nc kd lq nd bi translated">什么是数据层？</h1><p id="e6ef" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">该层负责在网络请求和本地持久性(即房间数据库)的帮助下为应用程序提供数据。它构成了<strong class="lu ir">表示/业务- </strong>层的基础。</p><h2 id="fc3d" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">数据层中的数据类型？</h2><ul class=""><li id="2f39" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc md me mf mg bi translated">业务层可以通过两种方式请求数据:一次性数据和数据流。</li><li id="3e5a" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">一次性—您向数据库请求数据，它会返回一个值给您。</li><li id="30b4" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">流——这基本上是一种<em class="nw">发布-订阅模式。</em>您没有向数据库请求数据，而是订阅了数据。数据库将通知您(<em class="nw">观察者</em>)特定数据值的任何变化。</li></ul><p id="c36c" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated">我们将为RxJava/RxKotlin、Coroutine和LiveData添加测试用例。您可以直接跳到应用程序中正在使用的部分。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="d5a5" class="mt kx iq bd ky mu mv mw lb mx my mz le jw na jx li jz nb ka lm kc nc kd lq nd bi translated"><strong class="ak">演示</strong></h1><p id="7f6e" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">我们将考虑购物应用程序的一个部分，在这里您可以获得产品列表。您可以增加/减少购物车中产品的数量。实时<em class="nw">购物车数量</em>也被显示。</p><ul class=""><li id="2f11" class="ls lt iq lu b lv nr lx ns lf nx lj ny ln nz mc md me mf mg bi translated">产品列表→一键操作。</li><li id="820b" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc md me mf mg bi translated">实时购物车数量→数据流。当项目数量改变(增加/减少)时，它也会改变。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/61de0d0d4edb4d72161f0184378e2b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*yUb5o7w6vBT5xMhl34M4gQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">演示示例</p></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="7260" class="mt kx iq bd ky mu mv mw lb mx my mz le jw na jx li jz nb ka lm kc nc kd lq nd bi translated">使用Rxjava的房间数据库</h1><h2 id="63cb" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">正在创建DAO(数据访问对象):</h2><ol class=""><li id="d256" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc ob me mf mg bi translated">插入是一个<code class="fe oc od oe of b">Completable </code>操作。</li><li id="83e2" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc ob me mf mg bi translated">产品检索的一次性操作是一个<code class="fe oc od oe of b"> Single</code>操作。</li><li id="b54a" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc ob me mf mg bi translated">购物车金额的数据流是一个<code class="fe oc od oe of b">Observable</code></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="e586" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak"> 2。RxJava中的测试</strong></h2><p id="ea2d" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">RxJava test utils提供了一个<code class="fe oc od oe of b">.test()</code>方法。它在数据源上创建一个<code class="fe oc od oe of b">TestObserver</code>并订阅它。因此，在订阅时，您可以立即从数据源获取值，因此，您可以检查该值。下面的例子说明了这一点。</p><p id="a23f" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated"><strong class="lu ir"> 2.1测试提取产品列表的一次性操作</strong></p><p id="3481" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated">(请遵循代码中的注释)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="6286" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated"><strong class="lu ir"> 2.2测试实时车载系统的数据流</strong></p><p id="143e" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated">(请遵循代码中的注释)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="ee92" class="mt kx iq bd ky mu mv mw lb mx my mz le jw na jx li jz nb ka lm kc nc kd lq nd bi translated">使用协程的房间数据库</h1><p id="fd12" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated"><code class="fe oc od oe of b">Room</code>支持协同程序。查询在自定义调度程序上运行。协程以其顺序性而闻名。但是唯一的条件是函数必须是<code class="fe oc od oe of b">suspend</code>函数。</p><h2 id="a9e8" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">创建DAO(数据访问对象)</strong></h2><ol class=""><li id="13b5" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc ob me mf mg bi translated">取出产品的一次性操作是一种<code class="fe oc od oe of b">suspend function</code>。</li><li id="a470" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc ob me mf mg bi translated">作为数据流的购物车金额被声明为<code class="fe oc od oe of b">Double</code>的<code class="fe oc od oe of b">Flow</code>。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="950e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">2.室内测试-ktx</h2><p id="3f1f" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">运行一个新的协程并阻塞当前线程，直到它完成。因此，所有的测试都应该封装在这个块中，以确保测试运行完成。</p><h2 id="7eec" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">2.1测试单次操作</h2><p id="0683" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="987d" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">2.2测试数据流</h2><p id="f6bf" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="590e" class="mt kx iq bd ky mu mv mw lb mx my mz le jw na jx li jz nb ka lm kc nc kd lq nd bi translated">使用LiveData</h1><h2 id="6e85" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建DAO(数据访问对象)</h2><ol class=""><li id="4631" class="ls lt iq lu b lv lw lx ly lf lz lj ma ln mb mc ob me mf mg bi translated">插入和取出产品是正常的功能。确保在主线程上运行它。</li><li id="8ed0" class="ls lt iq lu b lv mh lx mi lf mj lj mk ln ml mc ob me mf mg bi translated">作为数据流的购物车金额被声明为<code class="fe oc od oe of b">LiveData</code></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><h2 id="003f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">2.测试LiveData</h2><p id="fdf4" class="pw-post-body-paragraph ne nf iq lu b lv lw jr ng lx ly ju nh lf ni nj nk lj nl nm nn ln no np nq mc ij bi translated">2.1对于一次性操作，进行正常调用，确保运行主线程。</p><p id="82ac" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated">2.2对于数据流，我们需要订阅实时数据。因为它不会发出值，除非它上面有活跃的观察者。我们在<code class="fe oc od oe of b">LiveData</code>上有一个名为<code class="fe oc od oe of b">getOrAwait()</code>的扩展函数，它可以即时给出LiveData的值。它是从<a class="ae kv" href="https://github.com/android/architecture-components-samples/blob/master/GithubBrowserSample/app/src/test-common/java/com/android/example/github/util/LiveDataTestUtil.kt" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>借来的。</p><p id="9f21" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated">代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="daa2" class="pw-post-body-paragraph ne nf iq lu b lv nr jr ng lx ns ju nh lf nt nj nk lj nu nm nn ln nv np nq mc ij bi translated">感谢您阅读我的文章。</p></div></div>    
</body>
</html>