<html>
<head>
<title>Docker Tips: Clean Up Your Local Machine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Docker提示:清理你的本地机器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/docker-tips-clean-up-your-local-machine-35f370a01a78?source=collection_archive---------0-----------------------#2019-12-16">https://betterprogramming.pub/docker-tips-clean-up-your-local-machine-35f370a01a78?source=collection_archive---------0-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f509" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解磁盘空间使用情况并回收未使用的部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f1776ea59a2a0b7a3aa3663f525a8844.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*kezht5Uf4U2dqQg-9AbMag.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">来源:<a class="ae ku" href="https://www.flickr.com/photos/xmodulo/14098888813" rel="noopener ugc nofollow" target="_blank">Flickr上的x modulo</a></p></figure><p id="2b07" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在这篇文章中，我们将回到基础。我们将了解Docker如何使用主机的磁盘空间，以及当它不再被使用时如何回收它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lr"><img src="../Images/ca7a323eeb168e34601edcb897b4c978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcVfC_0z0IB9YRLbtiRZ8w.png"/></div></div></figure></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ce29" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">总消费量</h1><p id="ea0f" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">Docker很棒，这一点毋庸置疑。几年前，它通过普及容器的使用和极大地简化其生命周期的管理，提供了一种构建、运送和运行任何工作负载的新方法。</p><p id="73d4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">它也给开发者带来了运行任何应用程序而不污染本地机器的能力。但是，当我们运行容器、提取映像、部署复杂的应用程序堆栈以及构建我们自己的映像时，主机文件系统上的内存占用可能会显著增加。</p><p id="c9d3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们有一段时间没有清理我们的本地机器，我们可能会对这个命令的结果感到惊讶:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4bff" class="nf me it nb b gy ng nh l ni nj">$ docker system df</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi lr"><img src="../Images/ca7a323eeb168e34601edcb897b4c978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VcVfC_0z0IB9YRLbtiRZ8w.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">Docker在主机文件系统上的足迹示例</p></figure><p id="4957" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该命令显示Docker的磁盘使用情况，分为几类:</p><ul class=""><li id="0727" class="nk nl it kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated"><strong class="kx iu">图像</strong>:从注册表中提取的图像和本地构建的图像的大小。</li><li id="e97d" class="nk nl it kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><strong class="kx iu">容器</strong>:系统上运行的容器所占用的磁盘空间，即每个容器读写层的空间。</li><li id="58a5" class="nk nl it kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><strong class="kx iu">本地卷</strong>:持久存储在主机上，但在容器的文件系统之外。</li><li id="ef3c" class="nk nl it kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><strong class="kx iu">构建缓存</strong>:镜像构建过程生成的缓存(仅当使用BuildKit时，可从Docker 18.09获得)。</li></ul><p id="0f35" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从上面的输出中，我们可以看到相当多的磁盘空间可以回收。换句话说，由于Docker没有使用它，所以可以将其交还给主机。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="7cbd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">容器磁盘使用</h1><p id="aa2e" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">每次创建一个容器，都会在主机上的<em class="ny"> /var/lib/docker </em>下创建几个文件夹和文件。其中包括:</p><ul class=""><li id="19b3" class="nk nl it kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated"><em class="ny">/var/lib/docker/containers/ID</em>文件夹(ID是容器的唯一标识符)。如果容器使用默认的日志记录驱动程序，那么它的所有日志都将保存在这个文件夹中的一个JSON文件中。在这种情况下，生成太多日志可能会影响主机的文件系统。</li><li id="43f1" class="nk nl it kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated"><em class="ny">/var/lib/docker/overlay2</em>中的一个文件夹，包含容器的读写层(overlay 2是大多数Linux发行版上首选的存储驱动程序)。如果容器将数据保存在自己的文件系统中，这些数据将被存储在主机上的<em class="ny">/var/lib/docker/overlay 2</em>下。</li></ul><p id="ffee" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们有一个全新的系统，刚刚安装了Docker。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e12d" class="nf me it nb b gy ng nh l ni nj">$ docker system df<br/>TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE<br/>Images         0          0          0B         0B<br/>Containers     0          0          0B         0B<br/>Local Volumes  0          0          0B         0B<br/>Build Cache    0          0          0B         0B</span></pre><p id="dc89" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">首先，我们启动一个NGINX容器:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="dc6c" class="nf me it nb b gy ng nh l ni nj">$ docker container run --name www -d -p 8000:80 nginx:1.16</span></pre><p id="dfa8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">再次运行<code class="fe nz oa ob nb b">df</code>命令，我们现在可以看到:</p><ul class=""><li id="57f3" class="nk nl it kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">一张大小为126MB的图像。这是我们投放集装箱时拉的NGINX <em class="ny"> :1.16 </em>一个。</li><li id="1d60" class="nk nl it kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">一个容器——从NGINX映像运行的<em class="ny"> www </em>容器。</li></ul><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="55ad" class="nf me it nb b gy ng nh l ni nj">$ docker system df<br/>TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE<br/>Images         1          1          126M       0B (0%)<br/>Containers     1          1          2B         0B (0%)<br/>Local Volumes  0          0          0B         0B<br/>Build Cache    0          0          0B         0B</span></pre><p id="7c06" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">由于容器正在运行且映像当前正在使用中，因此还没有可回收的空间。由于容器(2B)的大小可以忽略不计，因此不容易在文件系统上跟踪，让我们在容器的文件系统中创建一个100MB的空文件。为此，我们在<em class="ny"> www </em>容器中使用方便的<a class="ae ku" href="https://en.wikipedia.org/wiki/Dd_(Unix)" rel="noopener ugc nofollow" target="_blank"> dd </a>命令。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="dcfd" class="nf me it nb b gy ng nh l ni nj">$ docker exec -ti www \<br/>  dd if=/dev/zero of=test.img bs=1024 count=0 seek=$[1024*100]</span></pre><p id="710b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该文件是在与该容器相关联的读写层中创建的。如果我们再次检查<code class="fe nz oa ob nb b">df</code>命令的输出，我们现在可以看到容器现在占用了一些额外的磁盘空间。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="e8a1" class="nf me it nb b gy ng nh l ni nj">$ docker system df<br/>TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE<br/>Images         1          1          126M       0B (0%)<br/>Containers     1          1          104.9MB    0B (0%)<br/>Local Volumes  0          0          0B         0B<br/>Build Cache    0          0          0B         0B</span></pre><p id="2f2f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">该文件位于主机上的什么位置？让我们来看看:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c52a" class="nf me it nb b gy ng nh l ni nj">$ find /var/lib/docker -type f -name <strong class="nb iu">test.img</strong><br/>/var/lib/docker/overlay2/83f177...630078/merged/test.img<br/>/var/lib/docker/overlay2/83f177...630078/diff/test.img</span></pre><p id="c494" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">无需深入细节，这个文件是在由overlay2驱动程序管理的容器读写层中创建的。如果我们停止容器，容器使用的磁盘空间就可以回收。让我们来看看:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="7b60" class="nf me it nb b gy ng nh l ni nj"># Stopping the www container<br/>$ docker stop www</span><span id="b276" class="nf me it nb b gy oc nh l ni nj"># Visualizing the impact on the disk usage<br/>$ docker system df<br/>TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE<br/>Images         1          1          126M       0B (0%)<br/>Containers     1          0          104.9MB    104.9MB (100%)<br/>Local Volumes  0          0          0B         0B<br/>Build Cache    0          0          0B         0B</span></pre><p id="0f5e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这个空间怎么回收？通过删除容器，这将删除关联的读写容器的层。</p><p id="698a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下命令允许我们一次删除所有停止的容器，并回收它们正在使用的磁盘空间:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a953" class="nf me it nb b gy ng nh l ni nj">$ docker container prune<br/>WARNING! This will remove all stopped containers.<br/>Are you sure you want to continue? [y/N] y<br/>Deleted Containers:<br/>5e7f8e5097ace9ef5518ebf0c6fc2062ff024efb495f11ccc89df21ec9b4dcc2</span><span id="3838" class="nf me it nb b gy oc nh l ni nj">Total reclaimed space: 104.9MB</span></pre><p id="5f15" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">从输出中，我们可以看到容器不再使用空间，并且由于不再使用映像(没有容器在运行)，它在主机文件系统上使用的空间可以回收:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="4332" class="nf me it nb b gy ng nh l ni nj">$ docker system df<br/>TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE<br/>Images         1          0          126M       126M (100%)<br/>Containers     0          0          0B         0B<br/>Local Volumes  0          0          0B         0B<br/>Build Cache    0          0          0B         0B</span></pre><p id="c028" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:一旦一个映像被至少一个容器使用，它所使用的磁盘空间就无法回收。</p><p id="a0d1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们上面使用的<code class="fe nz oa ob nb b">prune</code>子命令删除停止的容器。如果我们需要删除所有容器，运行的和停止的，我们可以使用以下命令之一(两者是等效的):</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c457" class="nf me it nb b gy ng nh l ni nj"># Historical command<br/>$ docker rm -f $(docker ps -aq)</span><span id="1da3" class="nf me it nb b gy oc nh l ni nj"># More recent command<br/>$ docker container rm -f $(docker container ls -aq)</span></pre><p id="aeda" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:在运行一个容器时使用<code class="fe nz oa ob nb b">--rm</code>标志通常是有用的，这样当它的PID 1进程停止时它会被自动删除，从而立即释放未使用的磁盘。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="8c0a" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">图像磁盘使用</h1><p id="83ae" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">几年前，每个图像有几百MB是很常见的。微软的Ubuntu大约是600MB。网络图片重达数GB(真实故事)。此时，即使这些层在映像之间共享，仅拉取几个映像也会很快影响主机的磁盘空间。这在今天不太真实——基础图像要轻得多——但是经过一定时间后，如果我们不小心，堆积图像肯定会产生影响。</p><p id="f35b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">终端用户无法直接看到几种图像:</p><ul class=""><li id="acc5" class="nk nl it kx b ky kz lb lc le nm li nn lm no lq np nq nr ns bi translated">中间映像被其他映像(子映像)引用，无法删除</li><li id="7f5d" class="nk nl it kx b ky nt lb nu le nv li nw lm nx lq np nq nr ns bi translated">悬挂图像是不再被引用的图像。它们占用一些磁盘空间，因此可以被删除</li></ul><p id="9d2a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">以下命令列出了系统中现有的悬挂图像:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="2062" class="nf me it nb b gy ng nh l ni nj">$ docker image ls -f dangling=true<br/>REPOSITORY  TAG      IMAGE ID         CREATED             SIZE<br/>&lt;none&gt;      &lt;none&gt;   21e658fe5351     12 minutes ago      71.3MB</span></pre><p id="912a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">为了去除悬挂的图像，我们可以走长路:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="eba4" class="nf me it nb b gy ng nh l ni nj">$ docker image rm $(docker image ls -f dangling=true -q)</span></pre><p id="87c3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">或者我们可以使用<em class="ny"> prune </em>子命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="6163" class="nf me it nb b gy ng nh l ni nj">$ docker image prune<br/>WARNING! This will remove all dangling images.<br/>Are you sure you want to continue? [y/N] y<br/>Deleted Images:<br/>deleted: sha256:143407a3cb7efa6e95761b8cd6cea25e3f41455be6d5e7cda<br/>deleted: sha256:738010bda9dd34896bac9bbc77b2d60addd7738ad1a95e5cc<br/>deleted: sha256:fa4f0194a1eb829523ecf3bad04b4a7bdce089c8361e2c347<br/>deleted: sha256:c5041938bcb46f78bf2f2a7f0a0df0eea74c4555097cc9197<br/>deleted: sha256:5945bb6e12888cf320828e0fd00728947104da82e3eb4452f</span><span id="1173" class="nf me it nb b gy oc nh l ni nj">Total reclaimed space: 12.9kB</span></pre><p id="1e76" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们需要一次移除所有图像(不仅仅是悬挂的图像),我们可以运行下面的命令。这将无法删除容器当前使用的图像，尽管:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d783" class="nf me it nb b gy ng nh l ni nj">$ docker image rm $(docker image ls -q)</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="3d80" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">卷磁盘使用情况</h1><p id="0e37" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">卷用于存储容器文件系统之外的数据。例如，当一个容器运行一个有状态的应用程序时，我们希望数据在容器之外持久化，这样它们就与容器生命周期分离了。还使用卷，因为容器内繁重的文件系统操作对性能不利。</p><p id="e352" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">假设我们运行一个基于<a class="ae ku" href="https://hub.docker.com/_/mongo" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>的容器，然后用它来测试我们之前做的备份(在本地的<em class="ny"> bck.json </em>文件中可用):</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="3b2c" class="nf me it nb b gy ng nh l ni nj"># Running a mongo container<br/>$ docker run --name db -v $PWD:/tmp -p 27017:27017 -d mongo:4.0</span><span id="2721" class="nf me it nb b gy oc nh l ni nj"># Importing an existing backup (from a huge bck.json file)<br/>$ docker exec -ti db mongoimport \<br/>  --db 'test' \<br/>  --collection 'demo' \<br/>  --file /tmp/bck.json \<br/>  --jsonArray</span></pre><p id="1697" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">备份文件中的数据将存储在主机上的<em class="ny"> /var/lib/docker/volumes </em>文件夹中。为什么这些数据没有保存在容器的图层中？因为在mongo映像的Dockerfile中，位置<em class="ny">/data/db</em>(mongo默认存储数据的位置)被定义为一个卷。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="gh gi od"><img src="../Images/94982d7dd00933054e8f36016458c3cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SxTloIX4sppbC2wNudkCGw.png"/></div></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">用于构建MongoDB容器映像的Dockerfile文件的摘录</p></figure><p id="4bb8" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意:许多映像通常与有状态应用程序相关，它们定义卷来管理容器层之外的数据。</p><p id="3ce5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">完成备份测试后，我们停止或移除容器。但是卷并没有被删除——除非我们明确地删除它，否则它会留在那里消耗磁盘空间。要删除不再使用的卷，我们可以采用更长的方法:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f558" class="nf me it nb b gy ng nh l ni nj">$ docker volume rm $(docker volume ls -q)</span></pre><p id="5745" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">或者我们可以使用<code class="fe nz oa ob nb b">prune</code>子命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="a3bb" class="nf me it nb b gy ng nh l ni nj">$ docker volume prune<br/>WARNING! This will remove all local volumes not used by at least one container.<br/>Are you sure you want to continue? [y/N] y<br/>Deleted Volumes:<br/>d50b6402eb75d09ec17a5f57df4ed7b520c448429f70725fc5707334e5ded4d5<br/>8f7a16e1cf117cdfddb6a38d1f4f02b18d21a485b49037e2670753fa34d115fc<br/>599c3dd48d529b2e105eec38537cd16dac1ae6f899a123e2a62ffac6168b2f5f<br/>...<br/>732e610e435c24f6acae827cd340a60ce4132387cfc512452994bc0728dd66df<br/>9a3f39cc8bd0f9ce54dea3421193f752bda4b8846841b6d36f8ee24358a85bae<br/>045a9b534259ec6c0318cb162b7b4fca75b553d4e86fc93faafd0e7c77c79799<br/>c6283fe9f8d2ca105d30ecaad31868410e809aba0909b3e60d68a26e92a094da</span><span id="f5d3" class="nf me it nb b gy oc nh l ni nj">Total reclaimed space: 25.82GB<br/>luc@saturn:~$</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="becd" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">构建缓存磁盘使用</h1><p id="a3e5" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">Docker 18.09版本通过<a class="ae ku" href="https://github.com/moby/buildkit" rel="noopener ugc nofollow" target="_blank"> BuildKit </a>引入了对构建过程的增强。使用此工具可以提高性能、存储管理、特性功能和安全性。在本文中，我们不会详细介绍BuildKit，而只是看看如何启用它以及它如何影响磁盘使用。</p><p id="4a45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们考虑下面的虚拟节点。Js应用程序及其关联的Dockerfile文件:</p><p id="8ac4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="ny"> index.js </em>文件定义了一个简单的HTTP服务器，该服务器公开了“/”端点，并为收到的每个请求回复一个字符串:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="dff9" class="nf me it nb b gy ng nh l ni nj">var express = require('express');<br/>var util    = require('util');<br/>var app = express();<br/>app.get('/', function(req, res) {<br/>  res.setHeader('Content-Type', 'text/plain');<br/>  res.end(util.format("%s - %s", new Date(), 'Got Request'));<br/>});<br/>app.listen(process.env.PORT || 80);</span></pre><p id="e394" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="ny"> package.json </em>定义了依赖关系:这里只有expressjs，用来设置HTTP服务器:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ea0c" class="nf me it nb b gy ng nh l ni nj">{<br/>  "name": "testnode",<br/>  "version": "0.0.1",<br/>  "main": "index.js",<br/>  "scripts": {<br/>    "start": "node index.js"<br/>  },<br/>  "dependencies": {<br/>    "express": "^4.14.0"<br/>  }<br/>}</span></pre><p id="d8e4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><em class="ny"> Dockerfile </em>定义了如何从上面的代码构建图像:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="bea6" class="nf me it nb b gy ng nh l ni nj"><strong class="nb iu">FROM</strong> node:13-alpine<br/><strong class="nb iu">COPY</strong> package.json /app/package.json<br/><strong class="nb iu">RUN</strong> cd /app &amp;&amp; npm install<br/><strong class="nb iu">COPY</strong> . /app/<strong class="nb iu"><br/>WORKDIR</strong> /app<br/><strong class="nb iu">EXPOSE</strong> 80<br/><strong class="nb iu">CMD</strong> ["npm", "start"]</span></pre><p id="6b06" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们像往常一样构建一个映像，不启用BuildKit:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="00c8" class="nf me it nb b gy ng nh l ni nj">$ docker build -t app:1.0 .</span></pre><p id="4e05" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们检查磁盘使用情况，我们只看到基本映像(<em class="ny">节点:13-alpine </em>在构建开始时提取)和构建的最终映像(<em class="ny"> app:1.0 </em>):</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="c3c4" class="nf me it nb b gy ng nh l ni nj">$ docker system df<br/>TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE<br/>Images         2          0          109.3MB    109.3MB (100%)<br/>Containers     0          0          0B         0B<br/>Local Volumes  0          0          0B         0B<br/>Build Cache    0          0          0B         0B</span></pre><p id="e399" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们使用BuildKit构建映像的2.0版本。我们只需要将DOCKER_BUILDKIT设置为1:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="617f" class="nf me it nb b gy ng nh l ni nj">$ DOCKER_BUILDKIT=1 docker build -t app:2.0 .</span></pre><p id="e52e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果我们再次检查磁盘使用情况，我们可以看到build-cache已创建:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="d640" class="nf me it nb b gy ng nh l ni nj">$ docker system df<br/>TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE<br/>Images         2          0          109.3MB    109.3MB (100%)<br/>Containers     0          0          0B         0B<br/>Local Volumes  0          0          0B         0B<br/>Build Cache    11         0          8.949kB    8.949kB</span></pre><p id="aec1" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">要删除构建缓存，我们可以使用以下命令:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="df0e" class="nf me it nb b gy ng nh l ni nj">$ docker builder prune<br/>WARNING! This will remove all dangling build cache.<br/>Are you sure you want to continue? [y/N] y<br/>Deleted build cache objects:<br/>rffq7b06h9t09xe584rn4f91e<br/>ztexgsz949ci8mx8p5tzgdzhe<br/>3z9jeoqbbmj3eftltawvkiayi</span><span id="57ca" class="nf me it nb b gy oc nh l ni nj">Total reclaimed space: 8.949kB</span></pre></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6ad7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">一次清洗所有东西</h1><p id="1c76" class="pw-post-body-paragraph kv kw it kx b ky mv ju la lb mw jx ld le mx lg lh li my lk ll lm mz lo lp lq im bi translated">正如我们在上面的例子中看到的，每个容器、映像和卷命令都提供了<code class="fe nz oa ob nb b">prune</code>子命令来回收磁盘空间。<code class="fe nz oa ob nb b">prune</code>子命令在Docker的系统级可用，因此它可以一次回收所有未使用的磁盘空间:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="f0b4" class="nf me it nb b gy ng nh l ni nj">$ docker system prune<br/>WARNING! This will remove:<br/>  - all stopped containers<br/>  - all networks not used by at least one container<br/>  - all dangling images<br/>  - all dangling build cache</span><span id="57c8" class="nf me it nb b gy oc nh l ni nj">Are you sure you want to continue? [y/N]</span></pre><p id="7111" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">偶尔运行这个命令来清理磁盘是一个好习惯。</p></div></div>    
</body>
</html>