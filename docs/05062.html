<html>
<head>
<title>How to Harden Your Containers With Distroless Docker Images</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Distroless Docker镜像来加固你的容器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-harden-your-containers-with-distroless-docker-images-c2abd7c71fdb?source=collection_archive---------0-----------------------#2020-06-04">https://betterprogramming.pub/how-to-harden-your-containers-with-distroless-docker-images-c2abd7c71fdb?source=collection_archive---------0-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e9f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Kubernetes上使用distroless图像来保护您的容器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6aaebc8e489e9b4e912de5380c70baf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzI7kEVusRnhIQnS0TCecA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈克尔·泽兹奇</a>在<a class="ae ky" href="https://unsplash.com/s/photos/quantum?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="fa6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">容器改变了我们看待技术基础设施的方式。这是我们运行应用程序方式的一次巨大飞跃。容器编排和云一起，为我们提供了近乎无限规模的无缝扩展能力。</p><p id="ae0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据定义，容器应该包含应用程序及其运行时依赖项。然而，实际上，它们包含的远不止这些。一个标准的容器基础映像包含一个包管理器、shells和其他程序，您可以在标准的Linux发行版中找到它们。</p><p id="36ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然所有这些方面对于构建容器图像都是必要的，但它们不一定构成图像的一部分。例如，一旦你安装了包，你就不再需要容器中的<code class="fe lv lw lx ly b">apt</code>。</p><p id="ac57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不仅用不必要的包和程序来膨胀你的容器，而且也给网络罪犯提供了攻击特定程序漏洞的机会。</p><p id="f622" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您应该始终知道容器运行时内存在什么，并且应该精确地限制它只包含您的应用程序所必需的依赖项。</p><p id="6724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不应该安装任何不需要的东西。一些领先的科技巨头，如谷歌，已经在生产中运行容器多年，已经采用了这种方法。</p><p id="a1b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谷歌现在通过提供<a class="ae ky" href="https://github.com/GoogleContainerTools/distroless" rel="noopener ugc nofollow" target="_blank">发行版图片</a>向全世界开源了这一功能。他们构建这些映像只是为了包含您的应用程序及其依赖项，并且他们缺少常规Linux发行版的所有功能，包括shells。</p><p id="bbc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，虽然您可以按常规方式运行您的应用程序，但您不能在它运行时将其附加到容器。这是一个重大的安全改进，因为您现在已经关闭了黑客通过shell进入您的容器的大门。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9353" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">分发基础映像</h1><p id="5b2d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Google为大多数领先的编程语言和平台提供了发行版基础映像。</p><p id="41bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下基本映像是正式发布的版本:</p><ul class=""><li id="976b" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/base/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/static-debian10</a></li><li id="892b" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">【gcr.io/distroless/base-debian10 T4】</li><li id="99ea" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/java/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/java-debian10</a></li><li id="dd63" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/cc/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/cc-debian10</a></li></ul><p id="0e0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下基本映像是实验性的，尚未推荐用于生产:</p><ul class=""><li id="d553" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/experimental/python2.7/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/python2.7-debian10</a></li><li id="a72a" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/experimental/python3/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/python3-debian10</a></li><li id="f6dd" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/experimental/nodejs/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/nodejs</a></li><li id="6a33" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/java/jetty/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/java/jetty-debian10</a></li><li id="e3cd" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated"><a class="ae ky" href="https://github.com/GoogleContainerTools/distroless/blob/master/experimental/dotnet/README.md" rel="noopener ugc nofollow" target="_blank">gcr.io/distroless/dotnet</a></li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="e855" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">构建分布式图像</h1><p id="a6b3" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Google在内部使用Bazel构建容器图像，但是我们可以使用Docker做同样的事情。关于使用发行版映像的一个有争议的问题是:当我们有一个发行版映像时，如何使用Docker文件构建我们的应用程序？</p><p id="9ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，Docker文件从一个操作系统基础映像开始，随后需要执行多个步骤来创建适当的运行时版本。这包括包的安装，你需要像<code class="fe lv lw lx ly b">apt</code>或<code class="fe lv lw lx ly b">yum</code>这样的包管理器来完成这个任务。</p><p id="b196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种方法可以做到:</p><ol class=""><li id="c801" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu nr nj nk nl bi translated">在Docker之外构建您的应用程序，并使用Docker文件中的<code class="fe lv lw lx ly b">ADD</code>或<code class="fe lv lw lx ly b">COPY</code>指令将二进制包复制到容器中。</li><li id="b264" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu nr nj nk nl bi translated">使用多阶段Docker构件。这是Docker 17.05及以后版本的一个新特性，允许你将你的构建分成几个阶段。第一阶段可以从标准操作系统基础映像开始，帮助您构建应用程序；第二阶段可以简单地从第一阶段获取构建的文件，并使用发行版的基本映像。</li></ol><p id="8ae1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解它是如何工作的，让我们使用多阶段构建过程来做一个实践练习。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="645c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">先决条件</h1><p id="41a0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">您需要具备以下条件:</p><ul class=""><li id="bdd0" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">Docker版本≥17.05，用于构建容器映像</li><li id="466c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">可选的Kubernetes群集，用于实践练习的第二部分。如果想在docker中运行容器，可以使用等效的Docker命令。</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1066" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">GitHub知识库</h1><p id="bbe6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">对于动手练习，将这个库分支到你的GitHub账户中。克隆分叉的GitHub库并将<code class="fe lv lw lx ly b">cd</code>放入其中。</p><p id="fe14" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该存储库包含一个Python Flask应用程序，它以“Hello World！”当你调用API的时候。</p><p id="231d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">app.py</code>文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="6be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Dockerfile</code>包含两个阶段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a84e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建阶段:</p><ul class=""><li id="0d62" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">从基础图像开始<code class="fe lv lw lx ly b">python:2.7-slim</code></li><li id="844c" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将应用程序复制到<code class="fe lv lw lx ly b">/app</code>目录</li><li id="e34e" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">升级<code class="fe lv lw lx ly b">pip</code>并安装要求</li></ul><p id="6756" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无发行阶段:</p><ul class=""><li id="7d95" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">从<code class="fe lv lw lx ly b">gcr.io/distroless/python2.7</code>基础图像开始</li><li id="468f" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将应用程序从构建阶段的<code class="fe lv lw lx ly b">/app</code>目录复制到当前阶段的<code class="fe lv lw lx ly b">/app</code>目录</li><li id="b582" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将python <code class="fe lv lw lx ly b">site-packages</code>从构建阶段复制到当前阶段的<code class="fe lv lw lx ly b">site-packages</code>目录</li><li id="b225" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将工作目录设置为<code class="fe lv lw lx ly b">/app</code>，将python路径设置为<code class="fe lv lw lx ly b">site-packages</code>目录，并暴露<code class="fe lv lw lx ly b">5000</code>端口</li><li id="06f0" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">将<code class="fe lv lw lx ly b">app.py</code>作为<code class="fe lv lw lx ly b">CMD</code>步骤运行</li></ul><p id="3c79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为发行版映像不包含外壳，所以您应该总是在vectors中包含<code class="fe lv lw lx ly b">CMD</code>指令。如果你不这样做，Docker会假设它是一个shell <code class="fe lv lw lx ly b">CMD</code>并试图像那样执行它，这是行不通的。</p><p id="38f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">建立形象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="08d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">登录到您的Docker注册表，并将映像推送到其中:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="82e8" class="ny mh it ly b gy nz oa l ob oc">$ docker login<br/>$ docker push &lt;your_docker_repo&gt;/flask-hello-world-distroless:latest</span></pre><p id="c2cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">登录Docker Hub(或您的容器注册中心)，您应该看到容器映像是可用的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/b59d0d94dc264f02357d34ed2b94b321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eL9k6u5Tj1a64h8UdwS21A.png"/></div></div></figure><p id="c244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果看压缩后的大小，正好是23.36 MB。太好了。如果您使用如下所示的标准slim发行版，它的大小为56 MB。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/1973188c17cb7fb439b6870e80aba24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fH5T6oGg2QRp2yK25dNsSg.png"/></div></div></figure><p id="6458" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你已经减少了一半以上的集装箱占地面积。太神奇了！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d093" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">在Kubernetes中运行容器</h1><p id="793e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了测试构建是否有效，让我们在Kubernetes集群中运行容器。如果您没有Kubernetes，您可以运行等效的Docker命令来完成相同的活动，因为Kubectl和Docker命令是相似的。</p><p id="39e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在存储库中创建了一个<code class="fe lv lw lx ly b">kubernetes.yaml</code>文件，其中包含一个部署和一个负载平衡器服务，该服务使用我们构建的容器映像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="000a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简单的设置。负载平衡器监听端口<code class="fe lv lw lx ly b">80</code>并映射到目标端口<code class="fe lv lw lx ly b">5000</code>。pod监听flask应用程序的默认<code class="fe lv lw lx ly b">5000</code>端口。</p><p id="5b02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用yaml的时间:</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="6eee" class="ny mh it ly b gy nz oa l ob oc">$ kubectl apply -f kubernetes.yaml<br/>deployment.apps/flask-deployment created<br/>service/flask-service created</span></pre><p id="8c44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们利用所有资源来看看我们创造了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8e63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到有两个<code class="fe lv lw lx ly b">Pods</code>，一个<code class="fe lv lw lx ly b">Deployment</code>，一个<code class="fe lv lw lx ly b">LoadBalancer</code>，一个<code class="fe lv lw lx ly b">Service</code>，一个<code class="fe lv lw lx ly b">EXTERNAL-IP</code>，还有一个<code class="fe lv lw lx ly b">ReplicaSet</code>。</p><p id="ae3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们访问应用程序。</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="e36e" class="ny mh it ly b gy nz oa l ob oc">$ curl <a class="ae ky" href="http://35.184.113.120" rel="noopener ugc nofollow" target="_blank">http://35.184.113.120</a><br/>Hello World!</span></pre><p id="17d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们得到<code class="fe lv lw lx ly b">Hello World!</code>作为响应。这表明Flask应用程序工作正常。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1279" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">对应用程序的外壳访问</h1><p id="7c99" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">正如我在介绍中所描述的，distroless容器缺少外壳，因此不可能附加到容器上。然而，让我们试着在容器中执行来亲眼看看。</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="2aac" class="ny mh it ly b gy nz oa l ob oc">$ kubectl exec -it flask-deployment-576496558b-hnbxt /bin/bash<br/>OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused "exec: \"/bin/bash\": stat /bin/bash: no such file or directory": unknown<br/>command terminated with exit code 126</span></pre><p id="98e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们无法连接到容器上。</p><p id="dd9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">伐木怎么样？我们应该获取日志，因为这样我们就失去了调试应用程序的方法。</p><p id="8a57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着得到日志。</p><pre class="kj kk kl km gt nu ly nv nw aw nx bi"><span id="618c" class="ny mh it ly b gy nz oa l ob oc">$ kubectl logs flask-deployment-576496558b-hnbxt<br/> * Running on <a class="ae ky" href="http://0.0.0.0:5000/" rel="noopener ugc nofollow" target="_blank">http://0.0.0.0:5000/</a><br/> * Restarting with reloader<br/>10.128.0.4 - - [31/May/2020 13:40:27] "GET / HTTP/1.1" 200 -<br/>10.128.0.3 - - [31/May/2020 13:42:01] "GET / HTTP/1.1" 200 -</span></pre><p id="afca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且日志都有！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="7059" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="f844" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">无分布图像是保护容器的一种令人信服的方式。由于映像很小，并且只包含您的应用程序和依赖项，因此它为您的应用程序提供了最小的攻击面。它在更大程度上提高了您的安全性，并且是强化您的容器的一个好方法。</p><p id="4921" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！我希望你喜欢这篇文章。</p></div></div>    
</body>
</html>