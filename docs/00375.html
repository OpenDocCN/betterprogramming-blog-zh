<html>
<head>
<title>Loader Interceptors in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">装载机截击机在角度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/angular-loader-interceptor-f0b37e244ccb?source=collection_archive---------2-----------------------#2019-05-07">https://betterprogramming.pub/angular-loader-interceptor-f0b37e244ccb?source=collection_archive---------2-----------------------#2019-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c8cc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何通过拦截HTTP请求来显示加载状态</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4a5d9016ae166103f9abe19a1ec9ea5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eRYFqwyMEOuCuZzS7JVkQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">基思·约翰斯顿在<a class="ae ky" href="https://unsplash.com/search/photos/catch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="8e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建应用程序时，一个关键特性是显示HTTP请求的加载状态。</p><p id="1c4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将带您了解如何使用拦截器来拦截所有HTTP请求。</p><p id="0d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以显示加载程序，比如动态显示或者使用结构化指令。我将向你们展示如何使用NGXS store来检索加载状态。</p><h1 id="1931" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">存储和拦截方法</h1><h2 id="f18d" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">拦截机</h2><p id="0d99" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">创建一个包含拦截器的新文件。我给我的取名<code class="fe ne nf ng nh b">loader.interceptor.ts</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="776d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，我们在拦截器中调度了两个动作。在我们的请求之前，我们将调度<code class="fe ne nf ng nh b">ShowLoaderAction</code>，当请求完成时，我们将调度第二个动作<code class="fe ne nf ng nh b">HideLoaderAction</code>。别急，下面我给大家展示一下NGXS商店的实现。</p><h2 id="bc80" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">商店</h2><p id="525e" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">NGXS store非常简单(比NGRX简单，甚至包括最新的动作创建器等等)。).您需要创建两个文件:一个包含您的动作，<code class="fe ne nf ng nh b">loader.actions.ts</code>，另一个包含您的状态类定义，<code class="fe ne nf ng nh b">loader.state.ts</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="3801" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里没有什么不寻常的，这和我们在拦截器中执行的两个动作是一样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><ul class=""><li id="34ec" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated"><code class="fe ne nf ng nh b">@State</code>让您定义商店内的装载机状态</li><li id="0695" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ne nf ng nh b">@Selector</code>为你的商店创建一个选择器(在这个例子中是加载器状态)</li><li id="174a" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated"><code class="fe ne nf ng nh b">@Action</code>改变监听调度动作的方法，然后执行给定的方法</li></ul><p id="d896" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对此有任何问题，试着去读读https://ngxs.gitbook.io/ngxs/的作品</p><h2 id="97c0" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">测试一下</h2><p id="e5a8" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">为了测试我们的存储和拦截器，使用选择器选择您的存储，然后在<code class="fe ne nf ng nh b">app-loader</code>组件上使用<code class="fe ne nf ng nh b">*ngIf</code>(我将把<code class="fe ne nf ng nh b">LoaderComponent</code>实现留给您)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="f513" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">动态组件创建和拦截器</h1><h2 id="cd22" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">动态组件—对话框</h2><p id="22ed" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">我正在用<code class="fe ne nf ng nh b">@angular/material</code>打开我的加载器对话框。有多个选项可用，如<code class="fe ne nf ng nh b">primeng</code>或定制构建。</p><h2 id="f110" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">拦截机</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="33be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我们不需要存储或在我们的应用程序组件中做任何事情。在我看来，它看起来更好——代码更少，更简单，等等。</p><h1 id="8d85" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">expressionchangedafterithasbeencheckedererror</h1><p id="ede6" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">对于那些在Angular社区呆过一段时间的人来说，这是一个著名的错误。有一篇关于它的很棒的文章<a class="ae ky" href="https://blog.angularindepth.com/everything-you-need-to-know-about-the-expressionchangedafterithasbeencheckederror-error-e3fd9ce7dbb4" rel="noopener ugc nofollow" target="_blank">你应该看看</a>。</p><p id="dcf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我为什么要提它？因为每当您在一个生命周期挂钩(通常是<code class="fe ne nf ng nh b">ngOnInit</code>)中调用HTTP请求时，您都可能会收到这个错误。</p><p id="bf0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看如何摆脱它。</p><h2 id="8191" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">存储和拦截方法</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="5aad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不使用<code class="fe ne nf ng nh b">setTimeout</code>将<code class="fe ne nf ng nh b">ShowLoaderAction</code>分派到事件队列，一个更好的解决方案是使用<code class="fe ne nf ng nh b">Promise.resolve(null).then()</code>。这导致在对变更进行角度双重检查之后进行it分派。</p><h2 id="ae71" class="mn lw it bd lx mo mp dn mb mq mr dp mf li ms mt mh lm mu mv mj lq mw mx ml my bi translated">动态组件创建和拦截器</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与前面相同的解决方案—将您的动态组件创建推送到事件队列。</p><h1 id="d600" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="18c1" class="pw-post-body-paragraph kz la it lb b lc mz ju le lf na jx lh li nb lk ll lm nc lo lp lq nd ls lt lu im bi translated">有许多方法可以向用户显示HTTP请求的状态——全局解决方案似乎很适合这种情况。</p><p id="2edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有更喜欢的方法吗？请在评论中告诉我！</p></div></div>    
</body>
</html>