<html>
<head>
<title>Suspend Mediator — A Simple Way To Communicate Between Coroutines in Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">suspend Mediator——kot Lin中协同程序之间通信的一种简单方式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/suspend-mediator-a-simple-way-to-communicate-between-coroutines-in-kotlin-8d882eab0579?source=collection_archive---------0-----------------------#2022-10-23">https://betterprogramming.pub/suspend-mediator-a-simple-way-to-communicate-between-coroutines-in-kotlin-8d882eab0579?source=collection_archive---------0-----------------------#2022-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9294" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用挂起功能创建简单的WebSocket数据源</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2ed4a9f47eacb13c25df4fe83df8f472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CwzKkLYbGVEbTKjP"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">扎克·卢塞罗在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="68e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个故事中，我们将学习如何与不同的协程通信，并使用它们来实现一个具有看起来像本地函数的远程数据源。这些函数是一个请求，使用WebSocket返回响应。</p><h1 id="b7c8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">动机</h1><p id="65a7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我编写内部使用WebSocket连接的数据源时，我注意到发送/接收套接字模式增加了软件的复杂性和难以维护性。发送一个请求，在代码的另一部分接收响应，迫使程序员声明在响应代码中使用的临时变量。</p><p id="272f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，如果可以发送请求并暂停它，直到收到响应，然后恢复它。像下面的代码一样，数据源提供了一个很好的暂停登录函数，它返回登录的结果(最后是完整的代码):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="e220" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">SuspendMediator解决了这个问题</h2><p id="fb1e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">嗯，有了<code class="fe nd ne nf ng b">SuspendMediator</code>，有可能！我的实现只有两个方法:暂停和恢复。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1597" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，这两个函数接收一个密钥来专门标识请求和响应。假设请求有一个在响应中发回的消息标识符。该标识符可以是该消息的关键。键越“唯一”，并行请求就越多，因为重复的键需要在请求队列中等待。这个限制对于<code class="fe nd ne nf ng b">SuspendMediator</code>知道谁将发送的请求与接收的响应唯一匹配是必要的。</p><h2 id="d3ad" class="mr lt iq bd lu ms mt dn ly mu mv dp mc lf mw mx me lj my mz mg ln na nb mi nc bi translated">履行</h2><p id="7a9a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">SuspendMediator</code>可以有几种实现，有无请求队列、请求/队列超时等等。</p><p id="c1f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请求队列用于缓存具有相同关键字的请求或避免并行请求:</p><ul class=""><li id="88f3" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">无队列:不同键的执行可以并行进行，但是当<code class="fe nd ne nf ng b">SuspendMediator</code>检测到一个重复的键时，会在suspend方法上抛出一个错误。</li><li id="3cd4" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">相同键入队:不同键的执行可以并行，重复键入队。</li><li id="07be" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">确保顺序:避免并行执行。它一个接一个地发送它们，按顺序等待响应。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2084" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以有两种类型的超时:</p><ul class=""><li id="11d4" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">队列超时:当我们有重复的键，并且有必要在队列中等待请求时，使用超时。</li><li id="b646" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">请求超时:用于避免等待永远不会收到的响应的超时。</li></ul><p id="4002" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">废话说够了。给我看看代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h1 id="d9c2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用SuspendMediator的示例</h1><p id="9f7a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe nd ne nf ng b">SuspendMediator</code>的主要目的是在协程之间进行通信。假设三个协同程序的乒乓操作将一个数乘以2的倍数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1970" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt nv ng nw nx aw ny bi"><span id="e178" class="mr lt iq ng b gy nz oa l ob oc">Coroutine 1 - result1 Success(5)<br/>Coroutine 2 - result2 Success(10)<br/>Coroutine 3 - result3 Success(20)<br/>Coroutine 1 - result4 Success(40)</span></pre><p id="f3ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">协程1用键1挂起，直到协程2用值5恢复这个键。协程1继续接收该值，并用密钥2发送双倍的该值。关键字3的值在协程2中产生，并发送给协程3，依此类推。注意，<code class="fe nd ne nf ng b">SuspendMediator</code>不是生产者/消费者，而是协程之间双向通信的一种方式。</p><p id="3767" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更有趣的例子是使用挂起函数的动作回调。当调用该操作并返回true时，可以保证该键已准备好供另一个协程调用使用该键继续。</p></div><div class="ab cl od oe hu of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ij ik il im in"><p id="efdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到故事开始时的登录示例，想象一下这个简单的登录字符串协议:</p><pre class="kg kh ki kj gt nv ng nw nx aw ny bi"><span id="8a2f" class="mr lt iq ng b gy nz oa l ob oc">Request: 1|username|password<br/>Response: 1|loginResult</span></pre><p id="7942" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，第一个字段表示消息的类型(Login ),在本例中，它的值为1，我们可以将它用作消息的键。该协议可以使用如下密封类来实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="950a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看使用<code class="fe nd ne nf ng b">SuspendMediator</code>的<code class="fe nd ne nf ng b">DataSource</code>示例代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3b16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当登录函数被调用时，该函数挂起，直到<code class="fe nd ne nf ng b">queuedSuspendMediator</code>在队列中没有值为1的键，因为<code class="fe nd ne nf ng b">queueMode</code>等于<code class="fe nd ne nf ng b">ENQUEUE_SAME_KEY</code>。在简单的情况下，队列是空的或者没有键1，所以不需要挂起。</p><p id="485c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后用<code class="fe nd ne nf ng b">LoginRequest</code>的值调用WebSocket <code class="fe nd ne nf ng b">sendMessage</code>。当服务器响应时，监听器解析消息并用<code class="fe nd ne nf ng b">LoginResult</code>消息调用恢复函数。</p><h1 id="fc0d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="da66" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用<code class="fe nd ne nf ng b">SuspendMediator</code>，我们可以为请求和响应消息编写更简单的代码，降低临时变量的复杂性。WebSocket DataSource是<code class="fe nd ne nf ng b">SuspendMediator</code>的众多用例之一。</p><p id="9bcf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。敬请关注更多内容。</p></div></div>    
</body>
</html>