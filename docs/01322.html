<html>
<head>
<title>An Overview of Next-Generation JavaScript Features for React Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用的下一代JavaScript特性概述</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-overview-of-next-generation-javascript-features-for-react-apps-4b8957248fe7?source=collection_archive---------5-----------------------#2019-09-01">https://betterprogramming.pub/an-overview-of-next-generation-javascript-features-for-react-apps-4b8957248fe7?source=collection_archive---------5-----------------------#2019-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7bd7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">下一代JavaScript使用箭头函数、let、const、<strong class="ak"> </strong>和<strong class="ak"> </strong>等更新的语法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0a853b5cc6289bbe12c5151a7d935786.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5T6qv42SGLLK_pUhhDP6w.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@priscilladupreez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae kv" href="https://unsplash.com/search/photos/next-generation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e212" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一代JavaScript可以被视为ECMAScript的最新版本，ECMAScript是JavaScript的标准化规范。</p><p id="3276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个版本都努力改进这种日益流行的编程语言，并为其添加新的功能。JavaScript已经占领了软件开发的世界。</p><p id="af02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">据<a class="ae kv" href="https://codeburst.io/10-top-programming-languages-in-2019-for-developers-a2921798d652" rel="noopener" target="_blank"> Codeburst.io </a>介绍，JavaScript是开发者的顶级编程语言。它被公认为2019年Stack Overflow开发者调查中最受欢迎的编程语言，也是GitHub上最受欢迎的编程语言。</p><p id="36af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用说，JavaScript是软件开发人员需要了解的关键语言。</p><p id="8f8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://insights.stackoverflow.com/survey/2019#most-popular-technologies" rel="noopener ugc nofollow" target="_blank">2019年栈溢出开发者调查结果:</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/e009fefe0d2f2525c327129e9dadae88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xQyKZUyAsPn_CNAKgA_6lg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae kv" href="https://insights.stackoverflow.com/survey/2019#most-popular-technologies" rel="noopener ugc nofollow" target="_blank">https://insights . stack overflow . com/survey/2019 #最受欢迎的技术</a></p></figure><p id="4412" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一代JavaScript使用箭头函数，let，const，<strong class="ky ir"> </strong>和<strong class="ky ir"> </strong>其他更新的语法。现代React应用程序通常使用JavaScript语言的这些更新功能。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="16e2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak"> let和const </strong></h1><p id="6285" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在JavaScript的ES6版本ECMAScript 2015中，JavaScript中引入了两个新的关键字，<code class="fe mx my mz na b">let</code>和<code class="fe mx my mz na b">const</code>。</p><p id="1ee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些关键字取代了之前的<code class="fe mx my mz na b">var</code>关键字，后者定义了一个全局变量。<code class="fe mx my mz na b">var</code>变量的范围是整个封闭函数。</p><p id="e6b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由<code class="fe mx my mz na b">let</code>声明的变量在为其定义的块中以及任何包含的子块中都有它们的作用域。在下一代JavaScript中，<code class="fe mx my mz na b">let</code>和<code class="fe mx my mz na b">const</code>取代了<code class="fe mx my mz na b">var</code>。</p><p id="88ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您计划不重新分配这个“变量”，则使用<code class="fe mx my mz na b">const</code>。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="10e6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">箭头功能</strong></h1><p id="4847" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">箭头函数是JavaScript中创建函数的另一种方式。除了具有更短的语法之外，它们还在维护<code class="fe mx my mz na b">this</code>关键字的范围方面提供了优势。</p><p id="6f15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据Mozilla 的说法:</p><blockquote class="nb nc nd"><p id="a217" class="kw kx ne ky b kz la jr lb lc ld ju le nf lg lh li ng lk ll lm nh lo lp lq lr ij bi translated">“箭头功能没有自己的<code class="fe mx my mz na b">this</code>。使用封闭词法范围的<code class="fe mx my mz na b">this</code>值；箭头函数遵循正常的变量查找规则。因此，在搜索当前作用域中不存在的<code class="fe mx my mz na b">this</code>时，一个箭头函数最终从它的封闭作用域中找到了<code class="fe mx my mz na b">this</code></p></blockquote><p id="0bed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中，传递给<code class="fe mx my mz na b">setInterval</code>的函数中的<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this" rel="noopener ugc nofollow" target="_blank">this</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this" rel="noopener ugc nofollow" target="_blank">与词法封闭函数中的<code class="fe mx my mz na b">this</code>具有相同的值:</a></p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="1e54" class="nm mb iq na b gy nn no l np nq">function Person(){<br/>  this.age = 0;<br/><br/>  setInterval(() =&gt; {<br/>    this.age++; // |this| properly refers to the Person object<br/>  }, 1000);<br/>}<br/><br/>var p = new Person();</span><span id="8511" class="nm mb iq na b gy nr no l np nq">function callMe(name) {</span><span id="3bd7" class="nm mb iq na b gy nr no l np nq">    console.log(name);</span><span id="5f5e" class="nm mb iq na b gy nr no l np nq"> }</span><span id="f4d8" class="nm mb iq na b gy nr no l np nq">const callMe = function(name) {</span><span id="fb71" class="nm mb iq na b gy nr no l np nq">     console.log(name);</span><span id="1c20" class="nm mb iq na b gy nr no l np nq"> }</span><span id="dde5" class="nm mb iq na b gy nr no l np nq">becomes:</span><span id="c6bd" class="nm mb iq na b gy nr no l np nq"> const callMe = (name) =&gt; {</span><span id="b22b" class="nm mb iq na b gy nr no l np nq">     console.log(name);</span><span id="9821" class="nm mb iq na b gy nr no l np nq"> }</span><span id="45fd" class="nm mb iq na b gy nr no l np nq"><strong class="na ir">Important:</strong></span><span id="be24" class="nm mb iq na b gy nr no l np nq">When there are no arguments, use empty parentheses in the function declaration:</span><span id="f7cf" class="nm mb iq na b gy nr no l np nq"> const callMe = () =&gt; {</span><span id="f542" class="nm mb iq na b gy nr no l np nq">     console.log('Kevin!');</span><span id="e620" class="nm mb iq na b gy nr no l np nq"> }</span><span id="345a" class="nm mb iq na b gy nr no l np nq">When there is only one argument, you may omit the parentheses around the argument:</span><span id="154c" class="nm mb iq na b gy nr no l np nq"> const callMe = name =&gt; {</span><span id="9abe" class="nm mb iq na b gy nr no l np nq">     console.log(name);</span><span id="6c6b" class="nm mb iq na b gy nr no l np nq"> }</span><span id="9e0a" class="nm mb iq na b gy nr no l np nq">If there are two or more arguments, then you need to include the parentheses around the arguments: </span><span id="c020" class="nm mb iq na b gy nr no l np nq"> const callMe = (name, age) =&gt; {</span><span id="8728" class="nm mb iq na b gy nr no l np nq">    console.log(name, age);</span><span id="a762" class="nm mb iq na b gy nr no l np nq">}</span><span id="5cf1" class="nm mb iq na b gy nr no l np nq">When just returning a value, you can use this shortcut, which removes the curly braces and the return keyword: </span><span id="1f21" class="nm mb iq na b gy nr no l np nq"> const returnMe = name =&gt; name</span><span id="173c" class="nm mb iq na b gy nr no l np nq">The above is the same as:</span><span id="eea1" class="nm mb iq na b gy nr no l np nq"> const returnMe = name =&gt; {</span><span id="242f" class="nm mb iq na b gy nr no l np nq">     return name;</span><span id="560a" class="nm mb iq na b gy nr no l np nq"> }</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="391b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">进出口</strong></h1><p id="0c5f" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在React和所有遵循最佳实践的现代JavaScript项目中，惯例是将代码拆分到多个称为模块的JavaScript文件中。这样做是为了遵守<a class="ae kv" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>，同时保持每个文件和模块的可管理性。</p><p id="3588" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要访问另一个文件中的代码，必须使用<code class="fe mx my mz na b">export</code>关键字将其导出，并使用<code class="fe mx my mz na b">import</code>语句将其导入接收文件。</p><p id="9d26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为React只是一个JavaScript库，所以它的模式是相似的，其中组件是使用<code class="fe mx my mz na b">import</code>和<code class="fe mx my mz na b">export</code>语句来传输的。</p><p id="16e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组件让你将用户界面分割成独立的、可重用的部分，并孤立地考虑每一部分。有两种类型的导出，默认(未命名)和命名导出:</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="217d" class="nm mb iq na b gy nn no l np nq"><strong class="na ir">default</strong> =&gt; export default ...;</span><span id="7630" class="nm mb iq na b gy nr no l np nq"><strong class="na ir">named</strong> =&gt; export const someData = ...;</span><span id="05d5" class="nm mb iq na b gy nr no l np nq">Default exports can be imported this way: </span><span id="345b" class="nm mb iq na b gy nr no l np nq">import chosenName from './path/to/file.js';</span><span id="6c25" class="nm mb iq na b gy nr no l np nq">chosenName is something that you simply choose. </span><span id="73a0" class="nm mb iq na b gy nr no l np nq"><strong class="na ir">Named</strong> exports must be imported explicitly by their name:</span><span id="f913" class="nm mb iq na b gy nr no l np nq">import { someData } from './path/to/file.js';</span></pre><p id="b8d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然一个文件只能包含一个默认导出，但命名导出的数量是无限的。单个默认导出也可以与同一文件中任意数量的命名导出组合。</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="f585" class="nm mb iq na b gy nn no l np nq"><strong class="na ir">named</strong> exports can be imported cumulatively with the following syntax:</span><span id="f027" class="nm mb iq na b gy nr no l np nq">import * as nameYouPick from './path/to/file.js';</span><span id="b67a" class="nm mb iq na b gy nr no l np nq">nameYouPick is a name you come up with. It bundles all exported variables and functions into a simple JavaScript object. If you<br/>  <br/>export const someData = ... (/path/to/file.js )<br/> <br/>That import can be accessed using nameYouPick, much like you would access any other value on a JavaScript object: nameYouPick.someData </span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f0af" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">类</strong></h1><p id="4f25" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">类类似于构造函数。它们用于定义创建JavaScript对象的蓝图。React使用类来创建组件。</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="0482" class="nm mb iq na b gy nn no l np nq"> class Person {</span><span id="0223" class="nm mb iq na b gy nr no l np nq">     constructor () {</span><span id="df14" class="nm mb iq na b gy nr no l np nq">         this.name = 'Kevin';</span><span id="5459" class="nm mb iq na b gy nr no l np nq">     }</span><span id="6c1d" class="nm mb iq na b gy nr no l np nq">  }</span><span id="bbfd" class="nm mb iq na b gy nr no l np nq">//here we are instantiating the Person class</span><span id="a125" class="nm mb iq na b gy nr no l np nq"> const person = new Person();</span><span id="7a69" class="nm mb iq na b gy nr no l np nq"> console.log(person.name); // prints 'Kevin' to the console</span></pre><p id="ef08" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe mx my mz na b">class</code>和那个类的属性<code class="fe mx my mz na b">this.name</code>都被明确定义。这是较早的ECMAScript定义属性的方法。</p><p id="2ce2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在使用下一代特性的现代JavaScript项目中，定义类属性的更简单的方法如下，省略了引用<code class="fe mx my mz na b">this.name</code>的显式属性定义:</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="bfaa" class="nm mb iq na b gy nn no l np nq"> class Person {</span><span id="898b" class="nm mb iq na b gy nr no l np nq">     name = 'Kevin';</span><span id="d0c7" class="nm mb iq na b gy nr no l np nq"> }</span><span id="dd6c" class="nm mb iq na b gy nr no l np nq"> const person = new Person();</span><span id="af3b" class="nm mb iq na b gy nr no l np nq"> console.log(person.name); // prints 'Kevin'</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="cb2b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">类别和定义方法</strong></h1><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="e54d" class="nm mb iq na b gy nn no l np nq"><strong class="na ir">Option 1:</strong></span><span id="2a89" class="nm mb iq na b gy nr no l np nq"> class Person {</span><span id="b465" class="nm mb iq na b gy nr no l np nq">     name = 'Kevin';</span><span id="f7a4" class="nm mb iq na b gy nr no l np nq">     printMyName () {</span><span id="a7f2" class="nm mb iq na b gy nr no l np nq">         console.log(this.name); <br/>// '<strong class="na ir">this</strong>' is required to refer to the class</span><span id="eb6d" class="nm mb iq na b gy nr no l np nq">     }</span><span id="dcbe" class="nm mb iq na b gy nr no l np nq"> }</span><span id="abd7" class="nm mb iq na b gy nr no l np nq"> const person = new Person();</span><span id="d919" class="nm mb iq na b gy nr no l np nq"> person.printMyName();</span><span id="d983" class="nm mb iq na b gy nr no l np nq"><strong class="na ir"><br/>Option 2:</strong></span><span id="a8b2" class="nm mb iq na b gy nr no l np nq"> class Person {</span><span id="d06e" class="nm mb iq na b gy nr no l np nq">     name = 'Kevin';</span><span id="114b" class="nm mb iq na b gy nr no l np nq">     printMyName = () =&gt; {</span><span id="e503" class="nm mb iq na b gy nr no l np nq">         console.log(this.name);</span><span id="c408" class="nm mb iq na b gy nr no l np nq">     }</span><span id="709a" class="nm mb iq na b gy nr no l np nq"> }</span><span id="a5ac" class="nm mb iq na b gy nr no l np nq"> const person = new Person();</span><span id="9502" class="nm mb iq na b gy nr no l np nq"> person.printMyName();</span></pre><p id="b468" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:第二种方法，选项二，具有使用箭头函数和绑定带来的优势:<code class="fe mx my mz na b">|this|</code>关键字不改变它的引用。</p><p id="6944" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">箭头函数<em class="ne">不</em>绑定自己的<code class="fe mx my mz na b">this</code> <em class="ne">。</em>代替了<em class="ne">，</em>箭头功能<em class="ne">在词汇上</em>绑定了它们的上下文，所以<code class="fe mx my mz na b">this</code>实际上指的是源上下文。</p><p id="5351" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，<code class="fe mx my mz na b">this</code>指的是<code class="fe mx my mz na b">Person</code>类，因为<code class="fe mx my mz na b">Person</code>类是原始上下文。当你在一个箭头函数中使用<code class="fe mx my mz na b">this</code>时，它会保持它的上下文，不会在运行时突然改变它。</p><p id="de13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当不使用箭头函数时，必须使用<code class="fe mx my mz na b">bind()</code>方法将<code class="fe mx my mz na b">|this|</code>显式绑定到该类。</p><p id="3522" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener ugc nofollow" target="_blank">bind()</a></code> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener ugc nofollow" target="_blank">方法</a>创建一个新函数，当调用该函数时，它的<code class="fe mx my mz na b">this</code>关键字被设置为提供的值，当调用新函数时，在任何提供的参数之前有一个给定的参数序列:</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="975a" class="nm mb iq na b gy nn no l np nq">var module = {<br/>  x: 40,<br/>  getX: function() {<br/>    return this.x;<br/>  }<br/>}</span><span id="54f5" class="nm mb iq na b gy nr no l np nq">var unboundGetX = module.getX;<br/>console.log(unboundGetX()); // The function gets invoked at the <strong class="na ir">global</strong> scope<br/>// expected output: undefined</span><span id="a708" class="nm mb iq na b gy nr no l np nq">var boundGetX = unboundGetX.bind(module);<br/>console.log(boundGetX());<br/>// expected output: 40</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="41ae" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">类和继承</strong></h1><p id="95d7" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">JavaScript中的继承类似于<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">原型</a>，这是JavaScript对象相互继承特性的机制。</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="7f63" class="nm mb iq na b gy nn no l np nq"> class Human {</span><span id="6f2c" class="nm mb iq na b gy nr no l np nq">     species = 'human';</span><span id="d3b4" class="nm mb iq na b gy nr no l np nq"> }</span><span id="5a14" class="nm mb iq na b gy nr no l np nq">//The extends keyword is used to inherit from the above Human class, which is known as the Parent class.</span><span id="1b98" class="nm mb iq na b gy nr no l np nq"> class Person extends Human {</span><span id="8555" class="nm mb iq na b gy nr no l np nq">     name = 'Kevin';</span><span id="51de" class="nm mb iq na b gy nr no l np nq">     printMyName = () =&gt; {</span><span id="5d82" class="nm mb iq na b gy nr no l np nq">         console.log(this.name);</span><span id="ab48" class="nm mb iq na b gy nr no l np nq">     }</span><span id="a9fb" class="nm mb iq na b gy nr no l np nq"> }</span><span id="802d" class="nm mb iq na b gy nr no l np nq"> const person = new Person();</span><span id="2084" class="nm mb iq na b gy nr no l np nq">person.printMyName();<br/>console.log(person.species); // prints 'human'</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1f1f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">展开和停止操作者</strong></h1><p id="12f0" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">spread和rest运算符都使用相同的三倍周期语法:<code class="fe mx my mz na b">…</code></p><p id="28b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用程序决定您是将它用作spread还是rest操作符。rest操作符用于将一组函数参数合并到一个数组中。</p><p id="4bbf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，spread运算符允许您从数组中提取元素，或者从对象中提取属性。下面是演示扩展运算符的两个示例:</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="31d3" class="nm mb iq na b gy nn no l np nq">const oldArray = [1, 2, 3];</span><span id="dced" class="nm mb iq na b gy nr no l np nq">const newArray = [...oldArray, 4, 5]; // The newArray is now [1, 2,</span><span id="8441" class="nm mb iq na b gy nr no l np nq">3, 4, 5];</span><span id="ce9e" class="nm mb iq na b gy nr no l np nq">The spread operator used on an object:</span><span id="fb0f" class="nm mb iq na b gy nr no l np nq"> const oldObject = {</span><span id="a2f5" class="nm mb iq na b gy nr no l np nq">     name: 'Kevin'</span><span id="4030" class="nm mb iq na b gy nr no l np nq"> };</span><span id="4f2a" class="nm mb iq na b gy nr no l np nq"> const newObject = {</span><span id="09bb" class="nm mb iq na b gy nr no l np nq">     ...oldObject,</span><span id="f3b8" class="nm mb iq na b gy nr no l np nq">     gender: 'Male'</span><span id="03f9" class="nm mb iq na b gy nr no l np nq"> };</span><span id="7006" class="nm mb iq na b gy nr no l np nq">newObject would then be</span><span id="1874" class="nm mb iq na b gy nr no l np nq"> {<br/>    name: 'Kevin',</span><span id="f185" class="nm mb iq na b gy nr no l np nq">    gender: 'Male'<br/> }</span></pre><p id="1910" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">spread运算符对于克隆数组和对象都很有用。两者都是引用类型而不是原语。这意味着，如果它们被重新分配，指针而不是值被复制。</p><p id="a2c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想要真正地制作一个副本，那么创建一个新对象时应该只复制属性，而不是复制整个对象。安全地复制引用类型，同时消除副作用或对复制的原始内容的更改，可能会有问题。</p><p id="be7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">spread操作符通过提供一种简洁而简单的方法来创建对象或数组的浅层克隆，从而避免了这些潜在的副作用。</p><p id="44a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用rest运算符的示例:</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="947a" class="nm mb iq na b gy nn no l np nq">const filter = (...args) =&gt; args.filter(el =&gt; el === 1);</span><span id="cc4d" class="nm mb iq na b gy nr no l np nq">console.log(filter(1, 2, 3)); // [1]</span></pre><p id="3755" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，用作rest操作符的<code class="fe mx my mz na b">…</code>将参数合并到一个数组中。<code class="fe mx my mz na b">filter()</code>方法将对传入数组中的每个元素执行一个函数。</p><p id="5b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果元素等于1，<code class="fe mx my mz na b">filter()</code>方法将返回一个<code class="fe mx my mz na b">true</code>或<code class="fe mx my mz na b">false</code>布尔值。在JavaScript中<code class="fe mx my mz na b">===</code>(三个等号)检查类型和值是否相等，因此<code class="fe mx my mz na b">el</code>也必须是一个数字。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5d22" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">解构</strong></h1><p id="6348" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">析构允许轻松访问数组或对象的值，以便将它们赋给变量。</p><p id="e925" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spread取出所有元素或所有属性，并将它们分布在一个新的数组或对象中。析构允许你提取单个元素或属性，并把它们存储在数组和对象的变量中。</p><pre class="kg kh ki kj gt ni na nj nk aw nl bi"><span id="84a5" class="nm mb iq na b gy nn no l np nq">Array Destructuring:</span><span id="75bf" class="nm mb iq na b gy nr no l np nq"> const array = [1, 2, 3];</span><span id="a4ba" class="nm mb iq na b gy nr no l np nq"> const [a, b] = array;</span><span id="c25b" class="nm mb iq na b gy nr no l np nq"> console.log(a); // prints 1</span><span id="f841" class="nm mb iq na b gy nr no l np nq"> console.log(b); // prints 2</span><span id="39b6" class="nm mb iq na b gy nr no l np nq"> console.log(array); // prints [1, 2, 3]<br/></span><span id="7748" class="nm mb iq na b gy nr no l np nq">Object Destructuring:</span><span id="d1c0" class="nm mb iq na b gy nr no l np nq"> const myObj = {</span><span id="ab70" class="nm mb iq na b gy nr no l np nq">     name: 'Kevin',</span><span id="50ac" class="nm mb iq na b gy nr no l np nq">     gender: 'Male'</span><span id="ca1c" class="nm mb iq na b gy nr no l np nq"> }</span><span id="b1b2" class="nm mb iq na b gy nr no l np nq"> const {name} = myObj;</span><span id="0436" class="nm mb iq na b gy nr no l np nq"> console.log(name); // prints 'Kevin'</span><span id="d7ba" class="nm mb iq na b gy nr no l np nq"> console.log(gender); // prints undefined</span><span id="2b44" class="nm mb iq na b gy nr no l np nq">console.log(myObj); // prints {name: 'Kevin', gender: 'Male'}</span><span id="8c4d" class="nm mb iq na b gy nr no l np nq">Destructuring is very useful when working with function</span><span id="f5aa" class="nm mb iq na b gy nr no l np nq">arguments. Consider this example:</span><span id="9e4d" class="nm mb iq na b gy nr no l np nq"> const printName = (personObj) =&gt; {</span><span id="12a6" class="nm mb iq na b gy nr no l np nq">     console.log(personObj.name);</span><span id="3ac4" class="nm mb iq na b gy nr no l np nq"> }</span><span id="3fca" class="nm mb iq na b gy nr no l np nq">printName({name: 'Kevin', gender: 'Male'}); // prints 'Kevin'</span><span id="b8d1" class="nm mb iq na b gy nr no l np nq">Here, we only want to print the name in the function but we pass a complete person object to the function. This is not a problem, but it forces us to call personObj.name inside of our function. </span><span id="4489" class="nm mb iq na b gy nr no l np nq">We can condense this code with destructuring:</span><span id="dee0" class="nm mb iq na b gy nr no l np nq"> const printName = ({name}) =&gt; {</span><span id="99aa" class="nm mb iq na b gy nr no l np nq">     console.log(name);</span><span id="8139" class="nm mb iq na b gy nr no l np nq"> }</span><span id="ee71" class="nm mb iq na b gy nr no l np nq">printName({name: 'Kevin', gender: 'Male'}); // prints 'Kevin')</span></pre><p id="2b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在应用对象析构之后，我们得到了与上面例子相同的结果，同时减少了输入的代码量。</p><p id="32db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过析构，我们简单地取出name属性并将其存储在一个名为<code class="fe mx my mz na b">name</code>的变量/参数中，然后可以在函数体中使用它。</p><p id="05ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这些下一代JavaScript特性在创建普通JavaScript和单页面React应用程序时都有用。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a90d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">来源</h1><div class="ns nt gp gr nu nv"><a href="https://www.udemy.com/share/1000uMAkEedV1TQ3Q=/?xref=E0AZdFpRRHoJSUQvCz0GJVUWTx4dChQ%2BVFE=" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">React 16:完整课程(包括React路由器4和Redux)</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">本课程是React的最新版本，包括React挂钩！当然会保留…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">www.udemy.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">班级</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">ECMAScript 2015中引入的JavaScript类主要是JavaScript现有的语法糖…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">developer.mozilla.org</p></div></div><div class="oe l"><div class="ok l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">箭头功能</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">箭头函数表达式在语法上是正则函数表达式的紧凑替代，尽管没有…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">developer.mozilla.org</p></div></div><div class="oe l"><div class="ol l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">功能</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">一般来说，函数是一个“子程序”,可以被外部代码调用(或者在…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">developer.mozilla.org</p></div></div><div class="oe l"><div class="om l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">对象原型</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">原型是JavaScript对象相互继承特性的机制。在本文中，我们解释…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">developer.mozilla.org</p></div></div><div class="oe l"><div class="on l og oh oi oe oj kp nv"/></div></div></a></div><div class="ns nt gp gr nu nv"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener  ugc nofollow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd ir gy z fp oa fr fs ob fu fw ip bi translated">函数.原型.绑定()</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">bind()方法创建了一个新函数，当调用该函数时，它的this关键字被设置为提供的值，并带有一个…</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">developer.mozilla.org</p></div></div><div class="oe l"><div class="oo l og oh oi oe oj kp nv"/></div></div></a></div></div></div>    
</body>
</html>