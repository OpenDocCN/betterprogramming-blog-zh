<html>
<head>
<title>Java 15 Features: Sealed and Hidden Classes, Pattern Matching And Text Blocks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 15特性:密封和隐藏类、模式匹配和文本块</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/java-15-features-sealed-and-hidden-classes-pattern-matching-and-text-blocks-38f4efdc8adc?source=collection_archive---------3-----------------------#2020-08-19">https://betterprogramming.pub/java-15-features-sealed-and-hidden-classes-pattern-matching-and-text-blocks-38f4efdc8adc?source=collection_archive---------3-----------------------#2020-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0406f2d551aac87ca42fc07c3c6f113a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRMPny9g9mP9ADSvaYzung.jpeg"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@swimstaralex?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Alexander Sinn </a>在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="2318" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">自从疫情于3月中旬在美国和欧洲开始以来，时间似乎过得很快，就在Java 14发布的时候，现在，经过六个月的隔离，Java 15终于来了！</p><p id="4614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">15是另一个特性版本，16也是，下一个LTS(长期支持版本)计划是Java 17，将在一年后的2021年9月发布。</p><p id="437f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个版本给我们带来了新的预览功能，比如密封类，接下来我们有记录的第二次预览和instanceof的模式匹配。当然，我们已经准备好使用预览，文本块和隐藏类。</p><p id="7f87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大约一年前，我在我的<a class="ae kf" href="https://medium.com/better-programming/java-13-features-switch-enhancements-and-text-blocks-3be53a6d7ed3" rel="noopener"> Java 13博客</a>中写了关于文本块的文章，当时它们是新的预览功能，在过去的两个版本中它们经过了测试，Java团队从社区中收集了所有的反馈，现在它们终于可以投入生产了。</p><p id="a11a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们先来看看新的预览功能！</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="de4f" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">密封类</h1><p id="3b61" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这是一个巨大的变化，Java在25年前的1.0版本中遇到的一个问题现在终于得到了解决。</p><p id="63aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们创建新的类和接口时，一个常见的过程是决定我们应该使用哪个范围修饰符，它总是一种情况一种情况的，直到现在语言提供的选项还不够细粒度。</p><p id="4a0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你有一个官方风格指南不鼓励使用默认(包私有)范围修饰符的项目时，这个问题会更加普遍。我的项目目前就有这种情况，让类(需要在某个时候继承)成为公共的或受保护的有时太慷慨了。</p><p id="08da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了Java 15，这个问题就解决了，现在我们有了对类和接口使用<code class="fe mo mp mq mr b">sealed</code>范围修饰符的细粒度继承控制。</p><p id="108a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果你需要你的超类是可广泛访问的，但不是任意扩展的，那么sealed modifier就是你的朋友。</p><p id="3f9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">来自<a class="ae kf" href="https://openjdk.java.net/jeps/360" rel="noopener ugc nofollow" target="_blank"> JDK文档</a>的示例:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="05d7" class="na lm it mr b gy nb nc l nd ne">package com.example.geometry;<br/><br/>public <strong class="mr iu">sealed </strong>class Shape<br/>    <strong class="mr iu">permits </strong>Circle, Rectangle, Square {...}</span></pre><p id="ae58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在同一个源文件中有嵌套类或者不止一个类，那么可以省略这些类的<code class="fe mo mp mq mr b">permits</code>，只要它们在同一个文件中，Java编译器就会推断出允许的子类。</p><p id="e0f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着在上面的例子中，只要Shape、Circle、Rectangle和Square在同一个源文件中，你就可以省略<code class="fe mo mp mq mr b">permits</code>,你的代码可以是这样的:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="41c4" class="na lm it mr b gy nb nc l nd ne">package com.example.geometry;<br/><br/><strong class="mr iu">sealed </strong>class Shape {...}<br/>... class Circle    extends Shape {...}<br/>... class Rectangle extends Shape {...}<br/>... class Square    extends Shape {...}</span></pre><p id="6b8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能是后一种情况，但是如果你想通过不写上面例子中的<code class="fe mo mp mq mr b">permits</code>来节省几个字节，你可以这样做，编译器会知道该怎么做。</p><p id="2ac6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">允许的类别可以是<code class="fe mo mp mq mr b">final</code>、<code class="fe mo mp mq mr b">sealed</code>或<code class="fe mo mp mq mr b">non-sealed</code>。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="2649" class="na lm it mr b gy nb nc l nd ne">package com.example.geometry;<br/><br/>public <strong class="mr iu">sealed </strong>class Shape<br/>    <strong class="mr iu">permits </strong>Circle, Rectangle, Square {...}<br/><br/>public <strong class="mr iu">final </strong>class Circle extends Shape {...}<br/><br/>public <strong class="mr iu">sealed </strong>class Rectangle extends Shape <br/>    <strong class="mr iu">permits </strong>TransparentRectangle, FilledRectangle {...}<br/>public <strong class="mr iu">final </strong>class TransparentRectangle extends Rectangle {...}<br/>public <strong class="mr iu">final </strong>class FilledRectangle extends Rectangle {...}<br/><br/>public <strong class="mr iu">non-sealed</strong> class Square extends Shape {...}</span></pre><p id="e8c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Final将阻止它在类层次结构中的部分被进一步扩展。</p><p id="bed6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Sealed将允许它的层次结构部分比最初定义的超类进一步扩展，但只能由sealed subclass允许的类来扩展。</p><p id="2fbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后<code class="fe mo mp mq mr b">non-sealed</code>将把东西放回野外，并把类层次结构恢复为对未知子类的扩展开放，当然从子非密封类开始，超类仍然是密封的，所以它仍然是未知扩展的禁区。</p><p id="532c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于这一点，<code class="fe mo mp mq mr b">non-sealed</code>是(我相信)Java中第一个有连字符的关键字，我不知道他们为什么在语言中引入这种不一致，已经有两个单词的关键字，比如instanceof，他们不使用连字符，所以我认为他们应该保持一致，使用<code class="fe mo mp mq mr b">nonsealed</code></p><p id="8cf3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java的反射API也被扩展以增加对密封类的支持，有两个新的方法，它们都是不言自明的:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="39d8" class="na lm it mr b gy nb nc l nd ne">java.lang.constant.ClassDesc[] <strong class="mr iu">getPermittedSubclasses</strong>();</span><span id="cf5a" class="na lm it mr b gy nf nc l nd ne">boolean <strong class="mr iu">isSealed</strong>()</span></pre><p id="8e97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该密切关注密封类/接口特性，因为在未来的Java版本中，这将非常适合开关表达式中的模式匹配。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="9b40" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">隐藏类</h1><p id="cb1f" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">隐藏类是框架开发人员最感兴趣的特性。</p><p id="7cdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它允许它们创建不能被其他类的字节码直接使用的类，它们是供框架本身使用的，框架在运行时生成类并通过反射间接使用它们。</p><p id="a152" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于这个功能背后的全部动机，你可以阅读<a class="ae kf" href="https://openjdk.java.net/jeps/371" rel="noopener ugc nofollow" target="_blank">开放JDK文档</a>，但这里是它的要点。</p><p id="cd7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">定义类<code class="fe mo mp mq mr b">ClassLoader::<strong class="ki iu">defineClass</strong></code>和<code class="fe mo mp mq mr b">Lookup::<strong class="ki iu">defineClass</strong></code>的标准API不关心类的字节码是动态生成的(运行时)还是静态生成的(编译时)。这些API总是定义一个<em class="ng">可见的</em>类，每当同一个加载器层次结构中的另一个类试图链接一个名为的类时，<a class="ae kf" href="https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-5.html#jvms-5.3.2" rel="noopener ugc nofollow" target="_blank">将被使用。</a></p><p id="5016" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果一个标准的API可以定义<em class="ng">隐藏的</em>类，这些类是不可发现的，并且具有有限的生命周期，那么JDK内部和外部的动态生成类的框架可以定义隐藏的类，这些隐藏的类具有更低的可见性和开销，这将提高所有基于JVM的语言实现的效率。</p><p id="529c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">增加这个特性也允许弃用<a class="ae kf" href="https://blogs.oracle.com/jrose/anonymous-classes-in-the-vm" rel="noopener ugc nofollow" target="_blank">非标准API </a> <code class="fe mo mp mq mr b">sun.misc.Unsafe::<strong class="ki iu">defineAnonymousClass</strong></code>。隐藏类不会支持<code class="fe mo mp mq mr b">defineAnonymousClass</code>所做的每一项功能，这不是我们的目标，但我们的目标是弃用该API，并在即将发布的版本中完全移除它。</p><p id="5ab4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不会深入隐藏类，因为这主要适用于开发底层内部东西的框架开发人员，所有其他相关信息可以在<a class="ae kf" href="https://openjdk.java.net/jeps/371" rel="noopener ugc nofollow" target="_blank">官方JEP </a>找到。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="9aa3" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">实例的模式匹配(第二次预览)</h1><p id="5700" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这最初是作为Java 14中的预览特性引入的。Java 15中的第二个预览版没有任何新的变化，功能与Java 14中引入的一样。</p><p id="5861" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这次重新预览的主要目的是从社区获得更多的反馈。</p><p id="ffa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们都熟悉习语实例，它被广泛应用于所有更大的代码库:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="10fb" class="na lm it mr b gy nb nc l nd ne">if (obj instanceof String) {<br/>    String s = (String) obj;<br/>    s.contains("Java 13");<br/>} else {<br/>    ...<br/>}</span></pre><p id="c290" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">instanceof的模式匹配提供了一种更干净的方式来进行这种检查，<code class="fe mo mp mq mr b">instanceof</code>操作符现在被扩展来接受类型测试模式，而不仅仅是类型:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="8744" class="na lm it mr b gy nb nc l nd ne">if (obj instanceof String <strong class="mr iu">s</strong>) {<br/>    <strong class="mr iu">s</strong>.contains("Java 15 with Pattern Matching");<br/>} else {<br/>    ...<br/>}</span></pre><p id="24f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不需要在<code class="fe mo mp mq mr b">true</code>块中进行显式转换，它比以前的代码更少，可读性更好。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0fc2" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">记录(第二次预览)</h1><p id="72f9" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">记录是作为预览特性在Java 14中引入的。</p><p id="c47b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个重新预览版，包含了基于以前(Java 14)预览版的社区反馈的更改。</p><p id="0537" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">records的最终目标是使开发人员能够比以前更容易地用Java创建不可变的、数据驱动的结构。</p><p id="e9c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记录是一种新的类，它的声明由名称、标题和主体组成。标题列出了记录的组成部分，即构成其状态的变量。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="6fcb" class="na lm it mr b gy nb nc l nd ne"><strong class="mr iu">record</strong> Point(int x, int y) { }</span></pre><p id="3175" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有变量，在这种情况下是<code class="fe mo mp mq mr b">x</code>和<code class="fe mo mp mq mr b">y</code>，将自动拥有一个与该变量同名且返回类型相同的公共访问器。</p><p id="8b26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在记录体中，您可以添加任意方法来操作记录状态。</p><p id="b61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">反射API已更新，因此您可以操作记录类型类:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="eddb" class="na lm it mr b gy nb nc l nd ne">// return all variables from the header<br/>RecordComponent[] <strong class="mr iu">getRecordComponents</strong>();</span><span id="67fe" class="na lm it mr b gy nf nc l nd ne">// is given class declared as a record<br/>boolean <strong class="mr iu">isRecord</strong>();</span></pre><p id="8a26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记录是用少量代码在Java中创建数据类的一种简洁方式。所有记录都是最终的，他们不能玩继承游戏。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="b8a6" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">文本块</h1><p id="9574" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">在Java 12中作为预览开始的东西现在已经成为永久特性了！</p><p id="52e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文本块允许更好地编写，更重要的是读取Java代码中的多行文本。这是Java所渴望的，尤其是因为运行在Java虚拟机上的其他语言，如<a class="ae kf" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>和<a class="ae kf" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>，已经支持多行文本很长时间了。</p><p id="ab55" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文本块解决的主要问题是在Java代码中编写其他语言的代码。以前，您总是需要像<code class="fe mo mp mq mr b">/n</code>这样的样板文件，以便在每一行的末尾换行，这使得代码容易出错并且难以阅读。</p><p id="e75f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文本块为您提供了一种在Java中编写多行文本的更好方法。它们使用三重引号作为分隔符，可以用在常规字符串可以用的任何地方。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="848b" class="na lm it mr b gy nb nc l nd ne">// SQL example</span><span id="df39" class="na lm it mr b gy nf nc l nd ne">// Using "one-dimensional" string literals<br/>String query = <br/>    "SELECT \"EMP_ID\", \"LAST_NAME\" FROM \"EMPLOYEE_TB\"\n" +<br/>    "WHERE \"CITY\" = 'INDIANAPOLIS'\n" +<br/>    "ORDER BY \"EMP_ID\", \"LAST_NAME\";\n";</span><span id="4066" class="na lm it mr b gy nf nc l nd ne">// Using a "two-dimensional" block of text<br/>String query = """<br/>               SELECT "EMP_ID", "LAST_NAME" FROM "EMPLOYEE_TB"<br/>               WHERE "CITY" = 'INDIANAPOLIS'<br/>               ORDER BY "EMP_ID", "LAST_NAME";<br/>               """;</span></pre><p id="1755" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，文本块不能在一行中使用:左引号后面必须跟一个行结束符，否则代码将无法编译。</p><p id="8b9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java编译器会将文本块编译成常规的字符串，并且不会提示它原来是字符串还是文本块。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><p id="6576" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很棒的功能，对吧？</p><p id="7c5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java正全速进行这个六个月的发布时间表，15几乎还没有发布，我已经想讨论一下16和下一个LTS 17会带来什么。写Java代码的大好时机！</p><p id="0623" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在他们的官方网站<a class="ae kf" href="https://openjdk.java.net/projects/jdk/15/" rel="noopener ugc nofollow" target="_blank">上阅读完整的发行说明并亲自尝试JDK 15。</a></p></div></div>    
</body>
</html>