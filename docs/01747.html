<html>
<head>
<title>Understanding MVC Services for the Front End: VanillaJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解前端的MVC服务:VanillaJS</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-mvc-services-for-the-front-end-vanillajs-2268255b36e6?source=collection_archive---------4-----------------------#2019-10-10">https://betterprogramming.pub/understanding-mvc-services-for-the-front-end-vanillajs-2268255b36e6?source=collection_archive---------4-----------------------#2019-10-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4e4d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步的JavaScript教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/589a5caf01e996dc1f9481e2b84f0c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wnnb-E_-6iJ2gboBazwT0Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片由JComp / <a class="ae ky" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank"> Freepik </a>设计</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="04b9" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="a740" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">本文是了解MVC架构如何创建前端应用程序的三篇文章中的第一篇。本系列的目标是了解如何通过将JavaScript用作脚本语言的web页面发展成JavaScript用作面向对象语言的应用程序来构建前端应用程序。</p><p id="aa42" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在第一篇文章中，将使用VanillaJS构建应用程序。因此，本文是开发与DOM相关的最大量代码的地方。然而，理解应用程序的所有部分是如何关联的以及它是如何构造的是非常重要的。</p><p id="0806" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在第二部分中，我们将通过将JavaScript代码转换成其TypeScript版本来强化它。</p><p id="3318" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，在最后一部分，我们将转换我们的代码，使其与Angular框架相集成。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="6e28" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">项目架构</h1><p id="922d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">没有什么比一个图像更有价值来理解我们将要建立什么。下面有一个GIF，在这个GIF中，我们将要构建的应用程序被举例说明。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/fa3a34496de1fcebb1cd169a33c43697.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/1*AdRdnVeheeydi2vrXepO-Q.gif"/></div></figure><p id="46cb" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个应用程序可以使用单个JavaScript文件来构建，该文件修改文档的DOM并执行所有操作，但是这是一个强耦合的代码，不是我们打算在本文中应用的。</p><p id="6d91" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">什么是MVC架构？MVC是一个具有三层/三部分的架构:</p><ul class=""><li id="791a" class="na nb it ma b mb mu me mv mh nc ml nd mp ne mt nf ng nh ni bi translated"><strong class="ma iu">模型</strong> —管理应用程序的数据。模型将会缺乏活力(它们将缺乏功能)，因为它们将会被提交给服务。</li><li id="d789" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu">视图</strong> —模型的可视化表示</li><li id="73ce" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu">控制器</strong> —服务和视图之间的链接</li></ul><p id="edec" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下面，我们展示了问题域中的文件结构:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/d247aec8d126cb2119799a82b1838ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*r_ZmYdFN389lWHXhVv0Lfg.png"/></div></figure><p id="b193" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe np nq nr ns b">index.html</code>文件将充当画布，整个应用程序将使用<code class="fe np nq nr ns b">root</code>元素在其上动态构建。此外，这个文件将作为所有文件的加载器，因为它们将在html文件本身中链接。</p><p id="3567" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">最后，我们的文件架构由以下JavaScript文件组成:</p><ul class=""><li id="deb4" class="na nb it ma b mb mu me mv mh nc ml nd mp ne mt nf ng nh ni bi translated"><strong class="ma iu"> user.model.js </strong> —用户的属性(模型)</li><li id="2ede" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu"> user.controller.js </strong> —负责加入服务和视图的人</li><li id="036d" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu"> user.service.js </strong> —管理用户的所有操作</li><li id="75ca" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu"> user.views.js </strong> —负责刷新和改变显示屏</li></ul><p id="54d1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">HTML文件如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="036e" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">模型(贫血)</h1><p id="495f" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">本例中构建的第一个类是应用程序模型<code class="fe np nq nr ns b">user.model.js</code>，它由类属性和一个生成随机id(这些id可能来自服务器上的数据库)的私有方法组成。</p><p id="3d03" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这些模型将具有以下字段:</p><ul class=""><li id="949e" class="na nb it ma b mb mu me mv mh nc ml nd mp ne mt nf ng nh ni bi translated"><strong class="ma iu"> id </strong> —唯一值</li><li id="a383" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu">姓名</strong> —用户的姓名</li><li id="94a9" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu">年龄</strong> —用户的年龄</li><li id="f577" class="na nb it ma b mb nj me nk mh nl ml nm mp nn mt nf ng nh ni bi translated"><strong class="ma iu">完成</strong> —布尔值，让您知道我们是否可以将用户从列表中划掉</li></ul><p id="bf39" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated"><code class="fe np nq nr ns b">user.model.js</code>如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1925" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对用户执行的操作在服务中执行。因为所有的逻辑负载都在模型中，所以服务允许模型贫血。在这个特定的例子中，我们将使用一个数组来存储所有用户，并构建与读取、修改、创建和删除(CRUD)用户相关的四个方法。您应该注意到服务利用了模型，实例化了从<code class="fe np nq nr ns b">LocalStorage</code>提取到<code class="fe np nq nr ns b">User class</code>的对象。这是因为<code class="fe np nq nr ns b">LocalStorage</code>只存储数据而不是存储数据的原型。从后端传输到前端的数据也会发生同样的情况:它们没有实例化它们的类。</p><p id="8e3a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们类的构造函数如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8fc4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">请注意，我们已经定义了一个名为<code class="fe np nq nr ns b">users</code>的类变量，一旦用户从平面对象转换为<code class="fe np nq nr ns b">User</code>类的原型对象，该变量就会存储所有用户。</p><p id="a18d" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们必须在服务中定义的下一件事将是我们想要开发的每个操作。下面使用ECMAScript显示了这些操作，没有使用TypeScript中的任何一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cecd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">仍然需要定义负责存储在我们的数据存储中执行的操作的<code class="fe np nq nr ns b">commit</code>方法(在我们的例子中是<code class="fe np nq nr ns b">LocalStorage</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7e39" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个方法调用一个在创建服务时已经绑定的<code class="fe np nq nr ns b">callback</code>函数，这可以在<code class="fe np nq nr ns b">bindUserListChanged</code>方法的定义中看到。我已经可以告诉你，这个回调是来自视图的函数，负责刷新屏幕上的用户列表。</p><p id="485f" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">文件<code class="fe np nq nr ns b">user.service.js</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b50a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">视图是模型的可视化表示。我们决定动态地创建整个视图，而不是创建HTML内容并注入它(许多框架都是这样做的)。首先要做的是通过DOM方法缓存视图的所有变量，如视图构造函数所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a805" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">视图的下一个最相关的点是视图与服务方法的联合(将通过控制器发送)。例如，<code class="fe np nq nr ns b">bindAddUser</code>方法接收一个驱动函数作为参数，它将执行服务中描述的<code class="fe np nq nr ns b">addUser</code>操作。在<code class="fe np nq nr ns b">bindXXX</code>方法中，每个视图控件的<code class="fe np nq nr ns b">EventListener</code>被定义。注意，从视图中我们可以访问用户从屏幕上提供的所有数据，屏幕通过<code class="fe np nq nr ns b">handler</code>功能连接。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5be9" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">视图的其余代码处理文档的DOM。文件<code class="fe np nq nr ns b">user.view.js</code>如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="ff38" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个架构的最后一个文件是控制器。控制器通过依赖注入(DI)接收它拥有的两个依赖项(服务和视图)。这些依赖关系存储在控制器的私有变量中。此外，构造函数在视图和服务之间建立显式连接，因为控制器是唯一可以访问双方的元素。</p><p id="ab9a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">文件<code class="fe np nq nr ns b">user.controller.js</code>如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="658e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们应用程序的最后一点是应用程序启动器。在我们的例子中，我们称之为<code class="fe np nq nr ns b">app.js</code>。通过创建不同的元素来执行应用程序:<code class="fe np nq nr ns b">UserService</code>、<code class="fe np nq nr ns b">UserView</code>和<code class="fe np nq nr ns b">UserController</code>，如文件<code class="fe np nq nr ns b">app.js</code>所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="b628" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="93bf" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在第一篇文章中，我们开发了一个web应用程序，其中的项目是按照MVC架构构建的，使用了贫血的模型，逻辑的责任在于服务。</p><p id="d1d8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">非常重要的是要强调，这一部分的学习目标是理解项目在不同责任的不同文件中的结构，以及视图如何完全独立于模型/服务和控制器。</p><p id="9c22" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在接下来的文章中，我们将使用TypeScript来增强JavaScript，这将为我们提供一种更强大的语言来开发web应用程序。我们使用JavaScript的事实导致我们为DOM的管理编写了大量冗长且重复的代码(使用Angular框架可以最大限度地减少这种情况)。</p><p id="86ab" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这个岗位的GitHub分支是<a class="ae ky" href="https://github.com/Caballerog/VanillaJS-MVC-Users" rel="noopener ugc nofollow" target="_blank">https://github.com/Caballerog/VanillaJS-MVC-Users</a>。</p></div></div>    
</body>
</html>