<html>
<head>
<title>Solidity Smart Contract Security: 4 Ways to Prevent Reentrancy Attacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Solidity智能合约安全性:防止重入攻击的4种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-smart-contract-security-preventing-reentrancy-attacks-fc729339a3ff?source=collection_archive---------4-----------------------#2022-05-16">https://betterprogramming.pub/solidity-smart-contract-security-preventing-reentrancy-attacks-fc729339a3ff?source=collection_archive---------4-----------------------#2022-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5a0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">检查、效果和交互(CEI)、互斥、拉支付和Gas限制都是防止可重入攻击的有效技术。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dbd7db4ba05b59cf540b672956d88405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gQ9EycuUzI8NOyt4v4W_rQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄</p></figure><p id="8e60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可重入是一种编程技术，在这种技术中，函数执行被外部函数调用中断。在外部函数调用的逻辑中，存在允许它在原始函数执行能够完成之前递归调用自身的条件。在某些情况下，重复重新进入一个进程来执行外部逻辑可能是可取的，但不一定是一个错误。但是，对于智能协定，不推荐使用这种技术，因为它将控制流的执行释放给了可能试图利用资金的不受信任的协定。此外，在执行对外部契约的调用时，应该使用防重入模式和防护来防止这种类型的攻击。</p><p id="11b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三种主要的技术可以防止重入:</p><ul class=""><li id="879a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">检查、效果、交互(CEI)</li><li id="ce9c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">重入保护/互斥</li><li id="3b1b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">拉付款</li></ul><p id="6fa6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，最后一种方法可能有效，但不推荐使用:</p><ul class=""><li id="d5e5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">气体极限</li></ul></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="fd96" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">检查、效果、交互</h1><p id="1b6d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">CEI模式是防止重入的一种简单而有效的方法。检查是指条件的真实性。效应是指由相互作用引起的状态改变。最后，交互指的是功能或契约之间的事务。</p><p id="73a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个不要做的事情的例子(交互<em class="nk">先于</em>效果):</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="46ca" class="nq mo iq nm b gy nr ns l nt nu">// contract_A: holds user's funds</span><span id="1fc0" class="nq mo iq nm b gy nv ns l nt nu">function withdraw() external {<br/>​ ​ ​​uint userBalance = userBalances[msg.sender];</span><span id="3e85" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​require(userBalance &gt; 0);</span><span id="0a48" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​(bool success,) = msg.sender.call{ ​​value: ​userBalance ​​}("");<br/>​ ​ ​​require(success,);</span><span id="0707" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​userBalances[msg.sender] = 0;<br/>}</span></pre><p id="0ecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是攻击者的接收函数:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="672a" class="nq mo iq nm b gy nr ns l nt nu">// contract_B: reentrancy attack</span><span id="5261" class="nq mo iq nm b gy nv ns l nt nu">receive() external payable {<br/>​ ​ ​​if (address(contract_A).balance &gt;= msg.value) {<br/>​ ​ ​​​ ​ ​​contract_A.withdraw();<br/>​ ​ ​​}<br/>}</span></pre><p id="57fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">攻击者的receive函数接收提取的资金，应该只返回“<code class="fe nw nx ny nm b">success</code>”，但是检查<code class="fe nw nx ny nm b">contract_A</code>是否包含更多的资金。如果为真，<code class="fe nw nx ny nm b">contract_B</code>再次递归调用取款函数，直到所有资金用完。</p><p id="f660" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个使用CEI模式的取款功能示例:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="6190" class="nq mo iq nm b gy nr ns l nt nu">function withdraw() external {<br/>​ ​ ​​uint userBalance = userBalances[msg.sender];</span><span id="1cb4" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​require(userBalance &gt; 0);</span><span id="213d" class="nq mo iq nm b gy nv ns l nt nu">​​​ ​ ​​<strong class="nm ir">userBalances[msg.sender] = 0;</strong></span><span id="45ce" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​(bool success,) = msg.sender.call{ ​​value: ​userBalance ​​}("");<br/>​ ​ ​​require(success,);<br/>}</span></pre><p id="ca2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在将资金转移到<code class="fe nw nx ny nm b">contract_B</code>之前将用户在<code class="fe nw nx ny nm b">contract_A</code>中的账户余额清零，在<code class="fe nw nx ny nm b">contract_B</code>发起重入攻击时，取款功能中的条件将为假，执行将恢复。正如这个案例所强调的，一行代码的位置可能是具有重大漏洞和可重入安全性的区别。</p><h1 id="f558" class="mn mo iq bd mp mq nz ms mt mu oa mw mx jw ob jx mz jz oc ka nb kc od kd nd ne bi translated">重入保护/互斥</h1><p id="40fc" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">可重入保护或互斥(互斥标志)可以构造为函数或函数修饰符，但逻辑很简单:在易被重入的函数调用周围放置一个布尔锁。“locked”的初始状态为false(未锁定)，但在易受攻击的函数执行开始之前立即被设置为true(已锁定),然后在它终止后被设置回false(未锁定)。</p><p id="cee4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是一个使用上面的取款函数的例子:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="7fdd" class="nq mo iq nm b gy nr ns l nt nu">bool internal locked = false;</span><span id="5674" class="nq mo iq nm b gy nv ns l nt nu">function withdraw() external {<br/>​ ​ ​​require(!locked);<br/>​ ​ ​​locked = true;</span><span id="d3dc" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​uint userBalance = userBalances[msg.sender];<br/> ​ ​​require(userBalance &gt; 0);<br/>​ ​ ​​(bool success,) = msg.sender.call{ ​​value: ​userBalance ​​}("");<br/>​ ​ ​​require(success,);<br/>​ ​ ​​userBalances[msg.sender] = 0;</span><span id="39f1" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​locked = false;<br/>}</span></pre><p id="8fb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管这个撤销函数不遵循CEI模式，因此容易受到重入攻击，但是简单的布尔“锁定”变量可以防止重入，因为第一个require语句将等同于false并恢复事务。</p><h1 id="e1a1" class="mn mo iq bd mp mq nz ms mt mu oa mw mx jw ob jx mz jz oc ka nb kc od kd nd ne bi translated">拉付款</h1><p id="b5dc" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">这最后一项技术被<a class="ae kv" href="https://docs.openzeppelin.com/contracts/4.x/api/security" rel="noopener ugc nofollow" target="_blank"> Open Zeppelin </a>推荐为最佳实践。然而，在自动化方面有一点折衷。拉式支付通过中介托管发送资金并避免与潜在的恶意合同直接接触来实现安全性。</p><p id="5072" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，合约资金被发送给中介托管:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="132e" class="nq mo iq nm b gy nr ns l nt nu">function sendPayment(address user, address escrow) external {<br/>​ ​ ​​require(msg.sender == authorized);</span><span id="2ac1" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​uint userBalance = userBalances[user];</span><span id="026c" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​require(userBalance &gt; 0);</span><span id="56a7" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​userBalances[user] = 0;</span><span id="cf23" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​(bool success,) = escrow.call{ ​​value: ​userBalance ​​}("");<br/>​ ​ ​​require(success,);<br/>}</span></pre><p id="2c73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，托管资金可以由接收方提取:</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="e2ff" class="nq mo iq nm b gy nr ns l nt nu">function pullPayment() external {<br/>​ ​ ​​require(msg.sender == receiver);</span><span id="0b4e" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​uint payment = account(this).balance;</span><span id="c36f" class="nq mo iq nm b gy nv ns l nt nu">​ ​ ​​(bool success,) = msg.sender.call{ ​​value: payment​ ​​}("");<br/>​ ​ ​​require(success,);<br/>}</span></pre><p id="71ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过中介托管发送资金，合同资金可以防止重入攻击。如果托管为多个帐户持有资金，则托管可能会被重入，因此在适用的情况下，应该实现CEI模式和/或重入保护。</p><h1 id="2ea0" class="mn mo iq bd mp mq nz ms mt mu oa mw mx jw ob jx mz jz oc ka nb kc od kd nd ne bi translated">气体极限</h1><p id="6cc5" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">最后，气体限制可以防止重入攻击，但这不应该被认为是一种安全策略，因为气体成本取决于以太坊的操作码，这些操作码可能会发生变化。另一方面，智能合约代码是不可变的。无论如何，了解函数之间的区别是有价值的:<code class="fe nw nx ny nm b">send</code>、<code class="fe nw nx ny nm b">transfer</code>和<code class="fe nw nx ny nm b">call</code>。</p><p id="b1b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数send和transfer本质上是相同的，但是如果事务失败，transfer会恢复，而send不会。</p><pre class="kg kh ki kj gt nl nm nn no aw np bi"><span id="24c1" class="nq mo iq nm b gy nr ns l nt nu">// transfer will revert if the transaction fails</span><span id="0823" class="nq mo iq nm b gy nv ns l nt nu">address(receiver).transfer(amount);</span><span id="712d" class="nq mo iq nm b gy nv ns l nt nu">// send will not revert if the transaction fails</span><span id="5f2f" class="nq mo iq nm b gy nv ns l nt nu">address(receiver).send(amount);</span></pre><p id="bbb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于可重入性，send和transfer都有2300个单位的气体限制。使用这些函数应该可以防止重入攻击的发生，因为这不足以递归回调原始函数来利用资金。</p><p id="b70f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与发送和转移不同，调用没有gas限制，并将转发其gas以执行复杂的多合同事务。当然，后者也包括可重入攻击。</p><h1 id="9e32" class="mn mo iq bd mp mq nz ms mt mu oa mw mx jw ob jx mz jz oc ka nb kc od kd nd ne bi translated">结论</h1><p id="de9a" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">成功的可重入攻击可能是毁灭性的，并可能耗尽受害者合同中的所有资金，因此了解潜在的漏洞并实施有效的保护措施非常重要。</p><p id="ee5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论是否存在漏洞，都应该默认实现CEI模式；这是很好的实践。额外的安全性可以通过使用重入保护和/或拉式支付来实现。最后，气体限制可以防止再入，但不应该被认为是一种安全策略。</p></div></div>    
</body>
</html>