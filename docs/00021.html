<html>
<head>
<title>Barcode Image Segmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">条形码图像分割</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/barcode-image-segmentation-a36cdce69f03?source=collection_archive---------3-----------------------#2017-04-22">https://betterprogramming.pub/barcode-image-segmentation-a36cdce69f03?source=collection_archive---------3-----------------------#2017-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2ac1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解释从图像中分割条形码的简单技术</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1e0c2603dafc80b35665625f38d22d8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s62KZEDCyNg_ns1I7xsF4Q.png"/></div></div></figure><p id="1493" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我将介绍一种从图像中分割条形码的简单技术。</p><p id="2c09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于示例代码，我将采用其<a class="ae lq" href="https://anaconda.org/" rel="noopener ugc nofollow" target="_blank"> Anaconda </a> <strong class="kw iu"> </strong>化身中的<a class="ae lq" href="https://www.python.org/" rel="noopener ugc nofollow" target="_blank"> Python </a> 2.7 <strong class="kw iu"> </strong>和<a class="ae lq" href="http://opencv.org/" rel="noopener ugc nofollow" target="_blank"> OpenCV </a> <strong class="kw iu"> </strong>作为图像处理库。</p><p id="e718" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我选择Python是因为它是快速编写示例的非常实用的选择，但是这种技术可以在您选择的任何语言中采用。</p><p id="b622" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Anaconda是一个有趣的Python发行版，它捆绑了一系列用于科学编程的有用工具。</p><p id="26f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">分割是识别图像中一个或多个对象的位置的过程。</p><p id="6bc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我要展示的技术非常简单。它使用了形态学操作符<a class="ae lq" href="http://docs.opencv.org/2.4/doc/tutorials/imgproc/erosion_dilatation/erosion_dilatation.html" rel="noopener ugc nofollow" target="_blank">、膨胀和腐蚀</a>、以及诸如<a class="ae lq" href="http://docs.opencv.org/2.4/doc/tutorials/imgproc/opening_closing_hats/opening_closing_hats.html" rel="noopener ugc nofollow" target="_blank">开、闭和黑帽</a>、<strong class="kw iu">、</strong>操作符的组合。</p><p id="bdf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所利用的条形码特征是条形码条之间的近距离。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="20ac" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">入门指南</h1><p id="e0c0" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">一旦安装了Anaconda，让我们在Anaconda的提示符下使用以下命令来安装OpenCv:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="d29f" class="na lz it mw b gy nb nc l nd ne">conda install -c <a class="ae lq" href="https://conda.anaconda.org/menpo" rel="noopener ugc nofollow" target="_blank">https://conda.anaconda.org/menpo</a> opencv</span></pre><p id="1b35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们从Anaconda启动器中启动<a class="ae lq" href="https://www.spyder-ide.org/" rel="noopener ugc nofollow" target="_blank"> Spyder IDE </a> <strong class="kw iu"> </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/e1231b9463b137ab21f0b51c0fb4e6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQpBNP08LD4cAc72K3V1SQ.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">蟒蛇发射器</p></figure><p id="2902" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦Spyder运行，我建议您验证OpenCV安装是否成功。</p><p id="2501" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Python控制台的右下方，我们来测试一下:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="0c24" class="na lz it mw b gy nb nc l nd ne">import cv2</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="ddc7" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">代码和技术</h1><p id="f4a8" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">我已经创建了一个新的GitHub库。</p><p id="2826" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用以下命令克隆它:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="cb39" class="na lz it mw b gy nb nc l nd ne">git clone --branch step1 <a class="ae lq" href="https://github.com/lucapiccinelli/BarcodesTutorial.git" rel="noopener ugc nofollow" target="_blank">https://github.com/lucapiccinelli/BarcodesTutorial.git</a></span></pre><p id="bbdc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样，您将下载测试图像和读取并显示图像的启动代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2b5ddb1c7f22b6a1e7394872bc6acca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1u-fcdXJu7xOiksobsq40w.jpeg"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">测试图像</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bccb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从现在开始，它将开始真正的处理。</p><p id="7945" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们将对图像进行二值化，可能会增强最有趣的特征。使用blackhat操作符，我们可以增强最暗的图像元素。</p><p id="ca2a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以用一个简单的全局阈值安全地二值化图像。blackhat运算符允许我们使用非常低的阈值，而不会过多强调噪声。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9d8d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当应用blackhat时，我们使用一个给予垂直图像元素更多重要性的内核。</p><p id="e752" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">内核有一个固定的大小，所以图像是缩放的，这也实现了性能的提高(并且有利于某种类型的输入规范化)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/44884c2c3fbc0cc9fc46676cbf154a03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0FwFp8ZIEoIL5HmqVXwcaw.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">黑帽+阈值处理</p></figure><p id="f7be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在采用其他形态学操作符之后，依次组合它们以获得条形码位置中的连通分量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d608" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种膨胀和闭合的组合对测试图像非常有效，但是，它可能不会对其他图像产生相同的效果。</p><p id="8feb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这没有问题，您可以尝试改变参数和运算符的组合，直到您对结果满意为止。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/c45c3a4fcdb10f4b6ec8dbcd933e4c5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMvKjLtfPlV30y4seRRAaQ.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">扩张+关闭</p></figure><p id="95fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一个预处理步骤是应用一个具有非常大的核的开运算符来移除太小而不适合条形码形状的元素。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5255" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是你的最终结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/ca6c6792924bda3e0684836836aca5c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oU0Z7KnPEmUupyJO4tIyJg.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">以35x21内核开始</p></figure><p id="9035" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以运行连接组件的检测算法，并检索带有坐标和尺寸的条形码矩形。</p><p id="70a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您在前面的图像中看到的，一些噪声没有从最后的形态学步骤中过滤掉。然而，在这种情况下，通过对矩形区域值进行阈值处理，很容易将它们过滤掉。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f5ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，在上面的代码中，我使用提取的矩形来绘制它们，覆盖在原始图像上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/da79f1d1a5a42f82dcd1c157d1ee6d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jt9D1d-lW6fbFCCkSnZ5Cw.png"/></div></div><p class="ng nh gj gh gi ni nj bd b be z dk translated">条形码以绿色方框突出显示的最终结果。</p></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="2652" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="100e" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">所提出的技术非常简单和有效，但是它存在一些令人讨厌的缺点:</p><ul class=""><li id="fe8c" class="no np it kw b kx ky la lb ld nq lh nr ll ns lp nt nu nv nw bi translated">它对条形码偏斜度非常敏感；它工作得很好，直到大约45度，然后你必须执行第二遍，修改内核的方向。</li><li id="f456" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">它只能在固定的维度范围内找到条形码。</li><li id="c964" class="no np it kw b kx nx la ny ld nz lh oa ll ob lp nt nu nv nw bi translated">尽管对矩形区域进行了过滤，但一些非条形码可能没有被清除。</li></ul><p id="9ad9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个和第二个可能不是真正的问题，这取决于应用程序的上下文，但最后一个是一个相当烦人的问题。你可能会花费大量的CPU时间试图解码不是条形码的东西。</p><p id="daf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个好的解决方案是指导人工神经网络(或您喜欢的其他分类器)处理条形码特征(图像梯度、傅立叶变换)，并在第二时间过滤掉噪声。</p><p id="140d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也许下一篇文章会讨论这个话题。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="8a67" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">参考</h1><p id="106a" class="pw-post-body-paragraph ku kv it kw b kx mq ju kz la mr jx lc ld ms lf lg lh mt lj lk ll mu ln lo lp im bi translated">下面是完整的示例代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="28d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里是<a class="ae lq" href="https://github.com/lucapiccinelli/BarcodesTutorial/blob/master/barcodeTutorial.py" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。在<code class="fe oc od oe mw b">img</code>目录中，我已经放了所有中间步骤的图片。</p><p id="2175" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是所有的乡亲。我希望我已经成功地解释了这项技术；如果没有，请告诉我。</p><p id="b511" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>