<html>
<head>
<title>How to Organize Files and Folders Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Python组织文件和文件夹</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/organize-files-and-folders-using-python-660246ef9310?source=collection_archive---------5-----------------------#2022-06-23">https://betterprogramming.pub/organize-files-and-folders-using-python-660246ef9310?source=collection_archive---------5-----------------------#2022-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49e1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">3件主要的事情将帮助我们决定如何组织我们的文件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b5d816b8bdf007580f733cb2b5a9a376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hLM9Rw1SaonhRG_t"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@numericcitizen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JF·马丁</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4a24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3件主要的事情将帮助我们决定如何组织我们的文件。</p><ol class=""><li id="5e43" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">我们希望如何管理文件？</li><li id="8358" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们想要组织什么样的文件？</li><li id="dcb0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">我们要组织哪个目录？</li></ol><h2 id="f0a5" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">我们希望如何组织文件？</strong></h2><p id="7d4e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们可以根据名称、创建日期、修改日期和大小等各种因素来组织文件。我们还可以根据文件的类型/扩展名来管理文件。这就是下一个问题出现的地方。</p><h2 id="901d" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">我们想要整理什么样的文件？</h2><p id="b4cc" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们可以在下载文件夹中找到许多类型的文件。可以有音乐、视频、图像、压缩文件、可执行文件、文档等等。回答完前两个问题后，我们必须决定要组织哪个目录。</p><p id="b807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您也在组织子目录，这个问题很重要。例如，可以有一个包含多种文件的编码项目。根据文件类型来组织这个目录不是一个好主意，因为它会搞乱我们的整个项目。</p><p id="f26e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此对于本教程，我们将主要关注根目录。</p><h1 id="d0e7" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">如何获得Python中所有文件的列表</h1><p id="0b12" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">要组织任何目录，首先，我们需要一个文件列表。要获得给定目录中所有文件的列表，我们可以使用来自<code class="fe ns nt nu nv b">os</code>模块的<code class="fe ns nt nu nv b">listdir()</code>方法。</p><p id="24b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe ns nt nu nv b">os.listdir(path)</code></p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="5802" class="mj mk it nv b gy oa ob l oc od">import os</span><span id="a2eb" class="mj mk it nv b gy oe ob l oc od">total_list = os.listdir("Downloads")<br/>print(total_list)</span><span id="29c8" class="mj mk it nv b gy oe ob l oc od">""" OUTPUT:</span><span id="50bb" class="mj mk it nv b gy oe ob l oc od">['elements.svg', 'Export.zip', 'favicon_io', 'Frame 5.png',<br/>'Screenshot.png', 'Temp', 'Video-1.webm']</span><span id="97c2" class="mj mk it nv b gy oe ob l oc od">"""</span></pre><p id="af54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们得到一个包含文件和目录的列表。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/78be7169c055d51a43337402e058baac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lR8k6Z0-6JOv5JmxrscYCA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">下载文件夹的屏幕截图</p></figure><p id="f344" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想使用这个，那么我们必须自己使用<code class="fe ns nt nu nv b">os.path</code>来分离文件和目录。为了确定给定的路径是文件还是目录，我们可以使用下面的代码片段:</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="c99e" class="mj mk it nv b gy oa ob l oc od">from os import listdir, path</span><span id="862f" class="mj mk it nv b gy oe ob l oc od">total_list = listdir(".")</span><span id="4aa4" class="mj mk it nv b gy oe ob l oc od">file_list = []<br/>dir_list = []</span><span id="e581" class="mj mk it nv b gy oe ob l oc od">for file in total_list:<br/>    if path.isfile(file):<br/>        file_list.append(file)<br/>    else:<br/>        dir_list.append(file)</span><span id="f2de" class="mj mk it nv b gy oe ob l oc od">print(file_list)<br/>print("-"*15)<br/>print(dir_list)</span><span id="9714" class="mj mk it nv b gy oe ob l oc od">""" OUTPUT:<br/>['elements.svg', 'Export.zip', 'Frame 5.png', 'Screenshot.png', 'Video-1.webm']<br/>---------------<br/>['favicon_io', 'Temp']<br/>"""</span></pre><p id="7935" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我运行这段代码时，我在下载目录中。因此，如果我想要当前目录中的列表，我可以使用<code class="fe ns nt nu nv b">os.listdir("./")</code>或<code class="fe ns nt nu nv b">os.listdir(".")</code>或<code class="fe ns nt nu nv b">os.listdir()</code>。</p><p id="d027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能会说，光是获得一个文件名列表就要做很多工作。所以，让我给你介绍一个简单的方法。我也不知道这个方法。我在为这个教程做研究的时候发现的。我们可以使用<code class="fe ns nt nu nv b">os.walk()</code>方法来检索所有文件。你可以在这里查看我从哪里了解到这个的博客帖子<a class="ae ky" href="https://pynative.com/python-list-files-in-a-directory/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="7f04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe ns nt nu nv b">os.walk(path)</code></p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="f9f4" class="mj mk it nv b gy oa ob l oc od">from os import walk</span><span id="0f19" class="mj mk it nv b gy oe ob l oc od">files = []<br/>for (dirpath, dirnames, filenames) in walk("./"):<br/>    files.extend(filenames)<br/>    break</span><span id="3d46" class="mj mk it nv b gy oe ob l oc od">print(filenames)</span><span id="1c1d" class="mj mk it nv b gy oe ob l oc od">""" OUTPUT:<br/>['elements.svg', 'Export.zip', 'Frame 5.png',<br/>'Screenshot.png', 'temp.py', 'Video-1.webm']<br/>"""</span></pre><p id="853b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我来解释一下为什么在这里使用<code class="fe ns nt nu nv b">break</code>关键字。方法不仅列出了给定位置的目录和文件。但是，它也会尝试扫描所有子目录。让我展示给你看。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="ccab" class="mj mk it nv b gy oa ob l oc od">from os import walk</span><span id="5519" class="mj mk it nv b gy oe ob l oc od">files = []<br/>for (index, data) in enumerate(walk("./")):<br/>    if index == 2:<br/>        break<br/>    print(index)<br/>    print(data)<br/>    print("-"*15)</span><span id="b987" class="mj mk it nv b gy oe ob l oc od">""" OUTPUT:</span><span id="2fc3" class="mj mk it nv b gy oe ob l oc od">0<br/>('./', ['favicon_io', 'Temp'], ['elements.svg', 'Export.zip', 'Frame 5.png', 'Screenshot.png', 'temp.py', 'Video-1.webm'])<br/>---------------<br/>1<br/>('./favicon_io', ['2021', '2022'], ['android-chrome-192x192.png', 'android-chrome-512x512.png', 'apple-touch-icon.png', 'favicon-16x16.png', 'favicon-32x32.png', 'favicon.ico', 'site.webmanifest'])<br/>---------------</span><span id="09af" class="mj mk it nv b gy oe ob l oc od">"""</span></pre><p id="1aec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，第一次迭代<strong class="lb iu">产生了</strong>当前路径和两个列表**。**第一个列表包含所有目录，第二个列表包含所有文件名。现在，在第二次迭代中，<code class="fe ns nt nu nv b">walk()</code>方法开始扫描子目录，在我们的例子中是“favicon_io”和“Temp”。我们目前只关注“下载”目录。因此，我使用break关键字，这样在一次迭代之后，它就停止扫描子目录。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi og"><img src="../Images/07c466abff40914d2eee8ae7e07b1353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1158/format:webp/1*GNroV5kQcSKVriADD9_vyQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">favicon子目录的截图</p></figure><p id="1a4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们得到了所有文件的列表，我们需要根据文件类型将它们分开。为此，我们将使用每个文件的扩展名。</p><h1 id="a7e8" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">如何使用Python获得文件扩展名</h1><p id="727e" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">要获得文件扩展名，我们可以使用<code class="fe ns nt nu nv b">os</code>中的<code class="fe ns nt nu nv b">path</code>模块。<code class="fe ns nt nu nv b">path</code>模块有一个<code class="fe ns nt nu nv b">splitext()</code>方法，该方法将返回一个包含文件名及其扩展名的元组。</p><p id="64c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe ns nt nu nv b">os.path.splitext(path)</code></p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="7612" class="mj mk it nv b gy oa ob l oc od">from os import path</span><span id="ea91" class="mj mk it nv b gy oe ob l oc od">file_tuple = path.splitext('Screenshot.jpg')<br/>print(file_tuple)<br/>print(file_tuple[1])</span><span id="8efd" class="mj mk it nv b gy oe ob l oc od">""" OUTPUT:<br/>('Screenshot', '.jpg')<br/>.jpg<br/>"""</span></pre><p id="4ff0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有了所有的文件，并且知道如何获得扩展名。因此，下一步是根据文件类型移动文件。</p><h1 id="9ef2" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">如何使用Python移动文件</h1><p id="d5d5" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们可以用<code class="fe ns nt nu nv b">os</code>模块移动文件，但这次我们将使用<code class="fe ns nt nu nv b">shutil</code>，我认为它比操作系统更适合这个任务。我们将使用来自<strong class="lb iu"> shutil </strong>模块的<code class="fe ns nt nu nv b">move() </code>方法。</p><p id="8be8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe ns nt nu nv b">shutil.move(src, dst, copy_function=copy2)</code></p><p id="3f3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>第三个参数可选。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="f55b" class="mj mk it nv b gy oa ob l oc od">import shutil</span><span id="34b0" class="mj mk it nv b gy oe ob l oc od">shutil.move("Screenshot.png", "Temp/")<br/>shutil.move("elements.svg", "Temp")<br/>shutil.move("Frame 5.png", "Temp/Frame 5.png")</span></pre><p id="e398" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe ns nt nu nv b">shutil.move()</code>以三种方式移动<strong class="lb iu">文件</strong></p><p id="2b3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一步。我们需要创建一个新的文件夹，如果它不存在，以移动相同类型的所有文件。</p><h1 id="0bba" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">使用Python创建一个文件夹/目录</h1><p id="31ff" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">我们可以使用<code class="fe ns nt nu nv b">os.mkdir()</code>方法创建一个文件夹。</p><p id="e811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法:<code class="fe ns nt nu nv b">os.mkdir(path, mode=0o777, *, dir_fd=None)</code></p><p id="e551" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注:</strong><strong class="lb iu">模式</strong>和<strong class="lb iu"> dir_fd </strong>参数可选。</p><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="356f" class="mj mk it nv b gy oa ob l oc od">from os import mkdir, path</span><span id="0dcf" class="mj mk it nv b gy oe ob l oc od">if not path.exists("Temp"):<br/>    mkdir("Temp")</span></pre><p id="0a9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ns nt nu nv b">path.exists()</code>方法检查给定位置是否存在。我们需要验证目录是否存在，因为如果目录已经存在，<code class="fe ns nt nu nv b">mkdir()</code>将抛出一个错误。我们希望只创建一个不存在的目录。</p><p id="7cfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们已经走完了所有的步骤。是时候把它们放在一起了。</p><h1 id="54e0" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">使用Python基于文件类型组织文件</h1><p id="99d2" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">概括来说，我们需要采取以下步骤:</p><ol class=""><li id="46e8" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">获取文件列表</li><li id="0d7d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">提取每个文件的扩展名</li><li id="5a58" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">如果文件夹不存在，请创建一个</li><li id="44ec" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">将文件移动到各自的文件夹中</li></ol><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="531a" class="mj mk it nv b gy oa ob l oc od">from os import mkdir, path, walk<br/>from pathlib import Path as pathlib<br/>from shutil import move</span><span id="6f3f" class="mj mk it nv b gy oe ob l oc od">IMAGE_EXT = [".jpg", ".png", ".jpeg", ".gif", ".webp", ".eps"]<br/>DOWNLOAD_LOCATION = str(pathlib.home() / "Downloads")</span><span id="ccd2" class="mj mk it nv b gy oe ob l oc od">file_list = []<br/>for (dirpath, dirnames, filenames) in walk(DOWNLOAD_LOCATION):<br/>    file_list.extend(filenames)<br/>    break</span><span id="82b9" class="mj mk it nv b gy oe ob l oc od">def check_directory(dir_location):<br/>    """Check if directory exists or not. If not create one."""<br/>    if not path.exists(dir_location):<br/>        mkdir(dir_location)</span><span id="ffc4" class="mj mk it nv b gy oe ob l oc od">def file_mover(extention_list, new_location):<br/>    """move file based on extension list to new location."""<br/>    for file in file_list:<br/>        if (path.splitext(file)[1]).lower() in extention_list:<br/>            move(file, new_location)</span><span id="8cfb" class="mj mk it nv b gy oe ob l oc od">def organize_images():<br/>    """Organize images based IMAGE_EXT list"""<br/>    image_location = path.join(DOWNLOAD_LOCATION, "Organized Images")<br/>    check_directory(image_location)<br/>    file_mover(IMAGE_EXT, image_location)</span><span id="deb1" class="mj mk it nv b gy oe ob l oc od">organize_images()</span></pre><p id="d664" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，大部分代码来自更早或者非常常见。你可能看到的一个区别是我使用了<strong class="lb iu"> <em class="oh"> pathlib </em> </strong> <em class="oh">模块。为了制作一个可以在Linux、Windows和macOS上运行的通用代码，我使用了</em> <strong class="lb iu"> pathlib </strong> <em class="oh">模块。它可以给我每个操作系统的默认主目录的直接路径。我在Ubuntu、Windows和macOS上测试过。</em></p><p id="9d63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经尽可能保持简单。在这个例子中，我展示了如何组织图像文件。但是对于各种文件都可以这样做。这将很难阅读和理解，这就是为什么我在我的<a class="ae ky" href="https://github.com/SahilFruitwala/auto-file-organizer" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上推出了可以用于任何类型文件的代码。</p><div class="oi oj gp gr ok ol"><a href="https://github.com/SahilFruitwala/auto-file-organizer" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">GitHub-sahilfrutwala/自动文件管理器</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">github.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div><h1 id="6cd8" class="nh mk it bd ml ni nj nk mo nl nm nn mr jz no ka mu kc np kd mx kf nq kg na nr bi translated">结论</h1><p id="80dd" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">在Python中操作和使用文件和目录并不难。如果你知道你想做什么，你在寻找什么，你可以通过谷歌搜索找到几乎所有你需要的东西。我就是这样遇到了<strong class="lb iu"> walk() </strong>法。</p><p id="6e53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于Python的知识，可以看看我正在进行的<a class="ae ky" href="https://sahilfruitwala.com/series/python-101" rel="noopener ugc nofollow" target="_blank"> Python系列</a>。</p><p id="7b95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这样。感谢您的阅读。直到下一次👋</p><h2 id="6fc8" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">参考</h2><ol class=""><li id="e639" class="lv lw it lb b lc nc lf nd li pa lm pb lq pc lu ma mb mc md bi translated"><a class="ae ky" href="https://pynative.com/python-list-files-in-a-directory/" rel="noopener ugc nofollow" target="_blank">https://pynative.com/python-list-files-in-a-directory/</a></li><li id="7260" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://www.geeksforgeeks.org/how-to-move-files-and-directories-in-python" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/how-to-move-files-and-directory-in-python</a></li></ol><div class="oi oj gp gr ok ol"><a href="https://levelup.gitconnected.com/file-handling-in-python-6ffc23cc92c" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">Python中的文件处理</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">所以，只是为了刷新我们的记忆，到目前为止，我们已经看到了python的所有基础知识，包括变量、数据类型、函数…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ou l"><div class="pd l ow ox oy ou oz ks ol"/></div></div></a></div><pre class="kj kk kl km gt nw nv nx ny aw nz bi"><span id="a670" class="mj mk it nv b gy oa ob l oc od"><strong class="nv iu">Want to Connect?</strong></span><span id="a86e" class="mj mk it nv b gy oe ob l oc od">I know it is a lot, but, I hope, you were able to absorb some knowledge. Let me know if you need any help or want to discuss something. Reach out to me on <a class="ae ky" href="https://twitter.com/Sahil_Fruitwala" rel="noopener ugc nofollow" target="_blank">Twitter</a> or <a class="ae ky" href="https://www.linkedin.com/in/sahilfruitwala/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>. Make sure to share any thoughts, questions, or concerns. I would love to see them.</span></pre></div></div>    
</body>
</html>