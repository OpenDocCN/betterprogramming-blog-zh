<html>
<head>
<title>The Facade Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的外观设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-facade-design-pattern-in-javascript-d3843853b238?source=collection_archive---------14-----------------------#2022-06-15">https://betterprogramming.pub/the-facade-design-pattern-in-javascript-d3843853b238?source=collection_archive---------14-----------------------#2022-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="359b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">解开复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1333e006b812da7ee78c99244a5f5425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Zb4Isuw-cWQg164q.png"/></div></div></figure><p id="e490" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在用JavaScript开发应用程序时，经常会遇到冗余代码，这让我们质疑它对价值的积极影响。冗余是开发人员经常试图避免的一种常见做法，因为过多的冗余很容易导致不愉快的开发体验，如代码大小的增加以及代码可维护性的降低。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="f95f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">解决这个问题的一个好方法是外观设计模式。在本文中，我们将回顾<code class="fe lx ly lz ma b">Facade</code>以及它是如何有效解决类似问题的模式。</p><p id="bea2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了减少冗余之外，facade模式在定义更高级的接口方面也做得很好，该接口将几个接口统一成更优雅的接口，目的是进一步简化事情。它通常用于将不必要的复杂代码部分包装成一个简单的结构，这样客户就不用对他们不关心的步骤负责。</p><p id="e2dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们假设我们正在构建一个简单的游戏，我们的第一个实现将是一个<code class="fe lx ly lz ma b">Human</code>类的定义。我们代码的其他部分期望这个人类类包含几个身体部分作为属性:<code class="fe lx ly lz ma b">Eye</code>、<code class="fe lx ly lz ma b">Ear</code>、<code class="fe lx ly lz ma b">Arm</code>、<code class="fe lx ly lz ma b">Leg</code>、<code class="fe lx ly lz ma b">Feet</code>、<code class="fe lx ly lz ma b">Nose</code>、<code class="fe lx ly lz ma b">Mouth</code>、<code class="fe lx ly lz ma b">Neck</code>和<code class="fe lx ly lz ma b">Stomach</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="426e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们定义一个<code class="fe lx ly lz ma b">Profile</code>类，它有一个用于设置其配置文件字符的方法，名为<code class="fe lx ly lz ma b">setCharacter</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="1b50" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当然，在真实的场景中，它会比这个长几十倍，所以请记住，我们只关注模式和它通过只显示相关代码所解决的问题。</p><p id="f3ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在<code class="fe lx ly lz ma b">setCharacter</code>函数的开头包含了一个<code class="fe lx ly lz ma b">validateCharacter</code>,因为它是任何软件验证构建部分的必要组件，以确保错误不会在不知不觉中发生。这也恰好是展示<code class="fe lx ly lz ma b">Facade</code>有用性的一个很好的设置。</p><p id="6759" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是实现过程:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="df42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在我们的<code class="fe lx ly lz ma b">validateCharacter</code>调用中，它继续检查人体的每个部分，如果至少有一个身体部分缺失，就会抛出一个错误。</p><p id="629d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们试着像客户一样使用我们的代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="1678" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">运行代码将导致错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="78d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，客户端如何解决这个问题呢？轻松点。他们只需要构建每一个身体部分，并负责使它们存在于实例中。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="8a84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们的代码运行无误。然而，如果你亲自动手，你可能会注意到你只关心创建一个角色和个人资料，所以我们在这里遇到了一些不愉快的问题:</p><ol class=""><li id="198e" class="md me it kw b kx ky la lb ld mf lh mg ll mh lp mi mj mk ml bi translated">代码更长</li><li id="6743" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">代码更复杂</li><li id="3866" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">该代码对于客户端来说不是很容易使用(与最初的三行代码相比)</li><li id="b7d1" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">冗余—多个领域都有冗余。对冗余的一个沉重打击是在我们的代码中反复提到<code class="fe lx ly lz ma b">"bob"</code>。</li><li id="9718" class="md me it kw b kx mm la mn ld mo lh mp ll mq lp mi mj mk ml bi translated">我们把球交给了客户(换句话说，我们强迫代码的用户负责构造和传递每一个身体部分)。很多时候，这是一件好事——我们希望赋予客户端代码发号施令的能力，这种情况并不少见。但这种情况就大不一样了。如果他们选择直接创建概要文件，并且只处理概要文件的特性，那么让他们做这些工作是没有意义的。</li></ol><p id="e8af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们制作我们的<code class="fe lx ly lz ma b">Facade</code>，并定义它将如何为客户解决我们不愉快的问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="a14e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe lx ly lz ma b">Profile</code>变成了<code class="fe lx ly lz ma b">Facade</code>本身，并且有效地封装了身体部分的每一个实现作为后备，这样客户端代码只需要关注<code class="fe lx ly lz ma b">Profile</code>提供的接口。</p><p id="2b84" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不仅给他们选择跳过不必要的步骤来构建和设置每个身体部分，而且我们也给他们选择完全控制，如果他们想自己做的话。</p><p id="9558" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，请注意，我们代码的用户与<code class="fe lx ly lz ma b">Profile</code>公开的接口紧密耦合。</p><p id="58c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个来自实现facade的<a class="ae mr" href="https://gist.github.com/codejets/336fbed7e83a80e3c283" rel="noopener ugc nofollow" target="_blank">要点</a>的例子。本例中模式的目的是将多个操作封装到一个调用中。从业务逻辑的角度来看，这可以表示客户端代码执行在线电子书购买的接口，其中客户端并不真正关心书是如何购买的——它只需要一个API来负责向用户执行“保存”和“发送”行为。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="f1ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，客户机代码使用这个接口(facade ),不需要担心实现细节。代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure><h1 id="827e" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">现实世界的类比</h1><p id="14be" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">让我们以杂货店为例。当你购买食品杂货时，收银员会告诉你要支付的商品价格，你可以选择用现金或信用卡支付。虽然这两种支付方式不同，但最终都达到了相同的目的。</p><p id="c3b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如今，自新冠肺炎疫情以来，一种新的、流行的支付方式是<a class="ae mr" href="https://www.shopify.com/retail/tap-to-pay" rel="noopener ugc nofollow" target="_blank">点击支付</a>，这又是一种不同的方式，因为我们不再需要刷卡或兑换某种形式的货币。</p><p id="683d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是facade模式的等价物，它为做同样事情的用户提供了一种新的支付方式(一个新的接口)。</p><h1 id="f144" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">真实世界的代码示例</h1><h2 id="116c" class="np mt it bd mu nq nr dn my ns nt dp nc ld nu nv ne lh nw nx ng ll ny nz ni oa bi translated"><a class="ae mr" href="https://github.com/dsherret/ts-morph" rel="noopener ugc nofollow" target="_blank"> ts-morph </a></h2><p id="7e12" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">我最喜欢的开源项目之一是ts-morph。该库充当TypeScript编译器API的包装器，以提供“一种更简单的方式来以编程方式导航和操作TypeScript和JavaScript代码。”原始的TypeScript编译器API很容易变得复杂，因此ts-morph封装了这些复杂性，并公开了一个全新的易于使用的接口供客户端代码使用。我经常使用ts-morph，所以我可以在个人层面上保证，这使得使用TypeScript API进行开发变得更加容易。</p><h1 id="a616" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">适配器和飞锤模式之间的差异</h1><h2 id="d112" class="np mt it bd mu nq nr dn my ns nt dp nc ld nu nv ne lh nw nx ng ll ny nz ni oa bi translated">外观与适配器</h2><p id="f387" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">有时候facade设计模式会被误认为是<code class="fe lx ly lz ma b">Adapter</code>设计模式。但是不同之处在于，<code class="fe lx ly lz ma b">Facade</code>可能会公开一个全新的接口供客户端使用，而<code class="fe lx ly lz ma b">Adapter</code>的目的是在寻求扩展新的属性或行为时向后兼容以前的接口。</p><h2 id="340d" class="np mt it bd mu nq nr dn my ns nt dp nc ld nu nv ne lh nw nx ng ll ny nz ni oa bi translated">门面vs轻量级</h2><p id="514d" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">在facade中，为客户端代码提供了一个接口来处理整个对象系统(可以包含相同对象的新副本),而flyweight模式中的客户端提供了一个接口来生成相同时要共享的对象，这是一种有效的内存保存方法。</p><h1 id="ee71" class="ms mt it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">结论</h1><p id="313a" class="pw-post-body-paragraph ku kv it kw b kx nk ju kz la nl jx lc ld nm lf lg lh nn lj lk ll no ln lo lp im bi translated">我希望你发现这是有价值的。以后多多关照！</p></div></div>    
</body>
</html>