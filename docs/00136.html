<html>
<head>
<title>TypeScript and Mix-Ins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿和混音</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/typescript-and-mix-ins-96f97678da35?source=collection_archive---------1-----------------------#2018-05-22">https://betterprogramming.pub/typescript-and-mix-ins-96f97678da35?source=collection_archive---------1-----------------------#2018-05-22</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="9072" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在分离关注点时使用组合</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/ba4f87666d7399e7f97daa62da3b2b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-4Hy40yWRC_mlPzk"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/@mikepetrucci?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克·彼得鲁奇</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="a4dd" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">介绍</h1><p id="d5b6" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">我之前听过<em class="mv"> mixin </em>这个词，我承认我没听懂。然后我读了这本伟大的书中对mixins的精彩解释，史蒂夫·芬顿的《Pro Typescript》。</p><p id="3fe8" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">严格地说，mixins不是面向对象编程的官方支柱。然而，它们是将对象组合在一起的一种方式，可以帮助您“更喜欢组合而不是继承”它们有点像多重继承，因为它们允许您将不同实现的功能组合在一起。</p><p id="ef4d" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">这里有一个有趣的事实:显然mixin这个名字来自马萨诸塞州萨默维尔的一家冰淇淋店。这个叫史蒂夫·费雷尔的家伙过去常常在冰淇淋中“混入”像石南棒、其他糖果棒以及谁知道还有什么东西。你可以在维基百科中查找。这在今天是司空见惯的事(想想冷石奶精)，但我猜有人先这样做了。反正名字就是这么来的。</p><p id="917d" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">原来在TypeScript中我们可以考虑两种mixins。首先，我们将看看“简单的”混音，然后我们将看看“真正的”混音。</p><p id="e398" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">好吧，那我们开始吧。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h1 id="ec47" class="lh li iu bd lj lk ll lm ln lo lp lq lr ka ls kb lt kd lu ke lv kg lw kh lx ly bi translated">“简单”混音</h1><p id="585e" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">首先，我们将声明三个类，定义运动员可以做的三件事:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">运动员可以做的三件事</p></figure><p id="a5ff" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">这里没有什么特别的:它们只是向控制台输出运动员可以做的事情——跑、跳和扔。</p><p id="1179" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">现在，我们将声明mixin。它使用<code class="fe nd ne nf ng b">implements</code>关键字将三个独立的类“实现”成一个类。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">组成一个十项全能运动员</p></figure><p id="7d18" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">这看起来没什么意义。函数都是<code class="fe nd ne nf ng b">void</code>，这个类什么都不做。所以这里我们要用一点小魔法，以下面的函数的形式:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">函数来创建mixin</p></figure><p id="eca5" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">正如我所说，这个函数有点复杂。它基本上接受传递给它的类的方法，并将这些方法重新分配给你传递给它的mixin类。所以我们打这个电话:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">使用applyMixins函数</p></figure><p id="e35d" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">它将这三个类的方法重新映射到<code class="fe nd ne nf ng b">Decathlete</code>类。不是很漂亮，但你知道了。您必须确保方法名称完全相同。然后你可以打电话:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div></figure><p id="2178" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">还有……对我没用。我从编译器(和linter)那里得到:</p><pre class="kk kl km kn gu nh ng ni nj aw nk bi"><span id="ef58" class="nl li iu ng b gz nm nn l no np"><strong class="ng iv">mixins.ts(29,3): error TS2564: Property 'runsFast' has no initializer and is not definitely assigned in the constructor. mixins.ts(30,3): error TS2564: Property 'jumpsHigh' has no initializer and is not definitely assigned in the constructor. mixins.ts(31,3): error TS2564: Property 'throwsFar' has no initializer and is not definitely assigned in the constructor.</strong></span></pre><p id="dad2" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">真扫兴。</p><p id="79b2" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">所以，我当然要打开谷歌，我发现编译器在这里“保护”你。<code class="fe nd ne nf ng b">Decathlete</code>类的方法实际上并没有被设置为任何实值(这就是这里的要点)。编译器不会，当<code class="fe nd ne nf ng b">strict</code>开启时(你确实开启了<code class="fe nd ne nf ng b">strict</code>，对吗？)，<a class="ae kz" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#null--and-undefined-aware-types" rel="noopener ugc nofollow" target="_blank">允许你把</a> <code class="fe nd ne nf ng b"><a class="ae kz" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#null--and-undefined-aware-types" rel="noopener ugc nofollow" target="_blank">null</a></code> <a class="ae kz" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#null--and-undefined-aware-types" rel="noopener ugc nofollow" target="_blank">或者</a> <code class="fe nd ne nf ng b"><a class="ae kz" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#null--and-undefined-aware-types" rel="noopener ugc nofollow" target="_blank">undefined</a></code> <a class="ae kz" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#null--and-undefined-aware-types" rel="noopener ugc nofollow" target="_blank">赋给你的变量</a>。</p><p id="032d" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">在这里我们可以做两件事。首先，我们可以在编译器设置中关闭<code class="fe nd ne nf ng b">--strictNullCheck</code>。这样做将使代码编译和运行。但是当然，我们不想那样做，不是吗？</p><p id="996b" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">相反，我们可以使用<a class="ae kz" href="https://github.com/Microsoft/TypeScript/wiki/What's-new-in-TypeScript#non-null-assertion-operator" rel="noopener ugc nofollow" target="_blank">非空断言操作符，</a>也称为感叹号。我们把它放在mixin类的方法名之后，然后编译器就高兴了:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">注意每个方法名后面的感叹号。</p></figure><p id="daa0" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">感叹号基本上是<a class="ae kz" href="https://stackoverflow.com/a/43891263/2044" rel="noopener ugc nofollow" target="_blank">“告诉编译器暂时放松它可能会要求的‘非空’约束。它对编译器说:‘作为开发人员，我比你更清楚，这个变量现在不能为空’”</a>。</p><p id="df4d" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">这就是混合蛋白。它们很酷，因为你可以把不同的功能组合成一个单一的实体。您可以创建一个十项全能运动员，他可以从多个类别中做许多事情，而这些类别都做一件事情。它们有点像实现多个接口，只是实现是在每个单独的类中完成的，而不是在复合类中。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><h2 id="2773" class="nl li iu bd lj nq nr dn ln ns nt dp lr mi nu nv lt mm nw nx lv mq ny nz lx oa bi translated">“真正的”混音</h2><p id="7f97" class="pw-post-body-paragraph lz ma iu mb b mc md jv me mf mg jy mh mi mj mk ml mm mn mo mp mq mr ms mt mu in bi translated">我在上面讨论了什么是mixins:简而言之，它们是一种分离然后组合功能的方式。Mixins是分离关注点的好方法，同时将事情集合在一起以完成一组相关的事情。</p><p id="bebd" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">为了“真正”做到这一点，我们将首先声明一个泛型类型，该类型在其构造函数中可以接受任意数量的参数:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">具有多个参数的泛型构造函数</p></figure><p id="8d5d" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">现在我们有了这种类型，我们可以用奔跑、跳跃和投掷功能来扩展它:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">用构造函数分解动作</p></figure><p id="a2e3" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">这三个函数返回定义特定功能类型的类——运行、跳跃和投掷。</p><p id="a42d" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">一旦定义了它们，您就可以创建类型并通过将功能菊花链在一起来调用功能:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nb nc l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">把东西混合在一起就成了十项全能运动员</p></figure><p id="b431" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">运行这段代码，您会得到以下结果:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/c4e486f33235d48b2a727c2929d89359.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*qHr-p0KBHAqGrQyp"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">执行十项全能课程的结果</p></figure><p id="7cee" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">这种“真正的”方法比“简单的”方法稍微复杂一点，但是它的优点是不依赖于单独的“神奇”函数。</p></div><div class="ab cl la lb hy lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="in io ip iq ir"><p id="8a68" class="pw-post-body-paragraph lz ma iu mb b mc mw jv me mf mx jy mh mi my mk ml mm mz mo mp mq na ms mt mu in bi translated">最后，这两种方法都是分离功能的好机制，同时允许功能的组合。</p></div></div>    
</body>
</html>