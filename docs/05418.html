<html>
<head>
<title>Dynamic Programming Interview Questions: Maximum Profit in Job Scheduling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划面试问题:作业调度中的最大利润</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dynamic-programming-interview-questions-maximum-profit-in-job-scheduling-6c5ec15c4cc5?source=collection_archive---------4-----------------------#2020-07-07">https://betterprogramming.pub/dynamic-programming-interview-questions-maximum-profit-in-job-scheduling-6c5ec15c4cc5?source=collection_archive---------4-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aec9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从给定的工作清单中找出你能获得的最大利润</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/68a485c9866530e94267bb583c2fcb8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yHazNhmDU8_LPYDGnpcoVQ.jpeg"/></div></div></figure><p id="8f62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天的问题很有挑战性——这是一个你可能在算法课程中见过的经典问题。对于那些已经看过的人来说，这将是一个很好的全面回顾。如果对你来说是新的，花点时间消化它。</p><p id="f0a1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看这个问题。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="b680" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有<code class="fe lx ly lz ma b">n</code>项工作，其中每项工作都计划从<code class="fe lx ly lz ma b">startTime[i]</code>到<code class="fe lx ly lz ma b">endTime[i]</code>完成，获得利润<code class="fe lx ly lz ma b">profit[i]</code>。</p><p id="4aff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你得到了<code class="fe lx ly lz ma b">startTime</code>、<code class="fe lx ly lz ma b">endTime</code>和<code class="fe lx ly lz ma b">profit</code>数组。您需要输出您可以获得的最大利润，这样子集中就不会有两个时间范围重叠的作业。</p><p id="3341" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您选择在x时间结束的作业，您将能够开始另一个在x时间开始的作业。</p><h2 id="7bf7" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">示例1</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/6124a96e16bf7a08640110ff9d874eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/0*2rqVufuEn_iMfZHH"/></div></figure><ul class=""><li id="d28c" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">输入:<code class="fe lx ly lz ma b">startTime</code> = [1，2，3，3]，<code class="fe lx ly lz ma b">endTime</code> = [3，4，5，6]，<code class="fe lx ly lz ma b">profit</code> = [50，10，40，70]</li><li id="d27e" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">产量:120</li><li id="1bb3" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">说明:选择的子集是第一个和第四个作业。</li><li id="ce88" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">时间范围[1–3]+[3–6]，我们得到利润120 = 50 + 70。</li></ul><h2 id="6db6" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">示例2</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/3d8bcda000e4b6802303fdc69349d63c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MJR4LWFYzhL-HkcV"/></div></div></figure><ul class=""><li id="24c6" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">输入:<code class="fe lx ly lz ma b">startTime</code> = [1，2，3，4，6]，<code class="fe lx ly lz ma b">endTime</code> = [3，5，10，6，9]，<code class="fe lx ly lz ma b">profit</code> = [20，20，100，70，60]</li><li id="09ec" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">产量:150</li><li id="fa65" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">说明:选择的子集是第一个、第四个和第五个工单。</li><li id="36ea" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">获得的利润150 = 20 + 70 + 60。</li></ul><h2 id="092f" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">示例3</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/663d668094ad6739550faef43bc18d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/0*nkPMs6RUZkbnftLG"/></div></figure><p id="8d0f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输入:<code class="fe lx ly lz ma b">startTime</code> = [1，1，1]，<code class="fe lx ly lz ma b">endTime</code> = [2，3，4]，<code class="fe lx ly lz ma b">profit</code> = [5，6，4]</p><p id="8de0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">产出:6</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="9ff3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们开始解决这个问题之前，让我们考虑一个更简单的版本。</p><p id="ffe2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设所有工作的利润相等。本质上，这意味着完成尽可能多的工作将是我们的最优解(只要是工作，你接什么工作真的不重要)。这听起来熟悉吗？答对了——这听起来像是一个贪婪算法类型的问题！</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="9bd7" class="nl mc it bd md nm nn no mg np nq nr mj jz ns ka mm kc nt kd mp kf nu kg ms nv bi translated">我们的贪婪算法模板</h1><ul class=""><li id="70bd" class="mv mw it kw b kx nw la nx ld ny lh nz ll oa lp na nb nc nd bi translated">按特定顺序考虑作业。</li><li id="4997" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">接受每一份工作，如果它与已经接受的工作不冲突的话。</li></ul><p id="de4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的关键是确定考虑作业的顺序。我们有多种选择:</p><ul class=""><li id="1056" class="mv mw it kw b kx ky la lb ld mx lh my ll mz lp na nb nc nd bi translated">最短间隔:按(完成到开始)次数的升序排列</li><li id="1c94" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">冲突最少:Ci的升序，其中Ci是与作业I冲突的剩余作业的数量。</li><li id="e37a" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">最早开始时间(est):开始时间的升序。</li><li id="b9b6" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">最早结束时间(EFT):结束时间的升序。</li></ul><p id="9da1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们考虑每一种顺序，并尝试为它们想一些反例(即，为什么顺序不起作用)。</p><h2 id="a8df" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">最短间隔</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/497fc92a3e3766d309608996825a1050.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*88v1K-dWPaVqAojN"/></div></div></figure><h2 id="2f4c" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">冲突最少</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/f8175317e701a52bc0778933a63c26da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ywl2q-SBm0MjUHjj"/></div></div></figure><h2 id="4128" class="mb mc it bd md me mf dn mg mh mi dp mj ld mk ml mm lh mn mo mp ll mq mr ms mt bi translated">最早开始时间</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/f960d7cfe70f7ae49ddaaae0bb8b5154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rkcLKank9A05sxnT"/></div></div></figure><p id="9c07" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">蓝色条表示贪婪算法将选择的作业。对于这三种情况，解决方案都不是最佳的。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><h1 id="1d00" class="nl mc it bd md nm nn no mg np nq nr mj jz ns ka mm kc nt kd mp kf nu kg ms nv bi translated">用EFT完成我们的贪婪算法</h1><ul class=""><li id="5ddd" class="mv mw it kw b kx nw la nx ld ny lh nz ll oa lp na nb nc nd bi translated">按完成时间的升序排列作业。</li><li id="432f" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">在决定是否应包括作业I时，通过检查作业I的开始时间是否&gt; =作业i-1的完成时间来检查它是否与所有以前添加的作业冲突。</li><li id="295d" class="mv mw it kw b kx ne la nf ld ng lh nh ll ni lp na nb nc nd bi translated">如果不冲突，那我们可以加。</li></ul><p id="3416" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们尝试将这种贪婪算法应用到我们的作业调度中的利润最大化问题，当每个作业的利润不相同时。你会意识到它悲惨地失败了。这是因为现在，不仅工作的数量很重要，而且你从工作中获得多少利润也很重要。所以这是一个<em class="oe">加权</em>区间调度问题——利润高的作业比利润低的作业权重高。</p><p id="1ec8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们从简单的未加权区间调度问题中学到了什么？一些很好的见解，但最重要的是，对我们很重要的<em class="oe">订购</em>。</p><p id="a471" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当任务未被加权时，我们可以简单地按照完成时间的升序对任务进行排序，如果它与先前添加的任务不冲突，就添加该任务。但在加权版本中，只有在不与之前增加的工作岗位<em class="oe">和</em>冲突的情况下，我们才应该增加它，因为它增加了我们当前的利润。换句话说，我们想取(当前利润+作业I的利润，当前利润)的最大值。利用这个思路，我们试着用Python实现一下。</p><p id="97ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们创建一个作业类，这样作业的每个实例都有开始时间、结束时间和利润。</p><pre class="kj kk kl km gt of ma og oh aw oi bi"><span id="5ac4" class="mb mc it ma b gy oj ok l ol om">class Job:<br/>    def __init__(self, start, finish, profit):<br/>        self.start = start<br/>        self.finish = finish<br/>        self.profit = profit</span></pre><p id="961c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们从输入数组中创建作业实例，并根据它们的结束时间对它们进行排序，如下所示:</p><pre class="kj kk kl km gt of ma og oh aw oi bi"><span id="61d3" class="mb mc it ma b gy oj ok l ol om">def solution(startTime, endTime, profit) -&gt; int:<br/>    jobs = []<br/>    for i in range(len(profit)):<br/>        jobs.append(Job(startTime[i], endTime[i], profit[i]))</span><span id="cccc" class="mb mc it ma b gy on ok l ol om">    # sort jobs in increasing order of their finish times<br/>    jobs.sort(key=lambda x: x.finish)</span></pre><p id="be4b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，我们采用通常的自下而上的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="10b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了得到最后一个不冲突的作业，我们可以做一个简单的线性搜索。</p><pre class="kj kk kl km gt of ma og oh aw oi bi"><span id="e8fd" class="mb mc it ma b gy oj ok l ol om">def get_last_non_conflicting_job(jobs, n):<br/>    for i in reversed(range(n)):<br/>        if jobs[i].finish &lt;= jobs[n].start:<br/>            return i<br/>    return -1  # if no non-conflicting job is found</span></pre><p id="067b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用二分搜索法可以进一步优化我们的线性搜索:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="7316" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们完了！</p><p id="261f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我认为这个问题最难的部分是认识到排序的重要性，并确定我们应该迭代作业的顺序。除此之外，这真的只是另一个动态规划问题。</p><p id="f611" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">祝你面试好运！</p></div></div>    
</body>
</html>