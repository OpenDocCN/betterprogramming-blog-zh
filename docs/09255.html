<html>
<head>
<title>How TensorFlow.js Became a Performance Bottleneck for My App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TensorFlow.js如何成为我的应用程序的性能瓶颈</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/web-performance-and-tensorflow-js-3db05b1de958?source=collection_archive---------7-----------------------#2021-08-03">https://betterprogramming.pub/web-performance-and-tensorflow-js-3db05b1de958?source=collection_archive---------7-----------------------#2021-08-03</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="8b81" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网页表现</a></h2><div class=""/><div class=""><h2 id="90ba" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">当你的应用程序变成一个CPU吸盘和性能猪</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/9972f666e1fc2fb44acdd5e7e2e38560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MWiAixuib_AYV2lm"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">亚历山大·安德鲁斯在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="81bf" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">第一天:找一个案例研究</h1><p id="8dee" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">凌晨时分，我开始了第一天的准备工作，准备一份关于识别和修复内存泄漏的报告。网上有许多博客和视频展示如何实现这样一个目标，但开发人员已经实现了一些应用程序，他们有意做到了以下几点:</p><ul class=""><li id="1ec7" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated">添加了事件侦听器，但从未删除它们</li><li id="5419" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">将对象设置为DOM元素上的数据</li><li id="bb7e" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">故意不从全局缓存中清除失效的项目</li><li id="5eb2" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">让开发工具通过<code class="fe nn no np nq b">console.log</code>对象来保存对它的引用。</li></ul><p id="f39d" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">但我的计划不同。我不想在演示中实现一个虚拟的应用程序来显式地泄漏内存，我想使用一个真实的案例研究，这样这个挑战将尽可能地接近我们作为软件开发人员在日常工作中所面临的挑战。</p><p id="8d3e" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我已经开始分析像der-sack.de和wetter.de这样的网站，然后回到我在过去几个月中实现的一个应用程序，并用它来展示:</p><ul class=""><li id="25a6" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated">如何建立一个<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-library-dynamic-stepper-2ba05ab40228">动态步进器</a>作为角度库</li><li id="54cd" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">如何实现带有搜索功能的<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/angular-custom-autocomplete-7ffb479477e7">自动完成</a></li><li id="8fc0" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">如何利用机器学习，用<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/build-a-hand-pose-detector-web-app-powered-by-machine-learning-62131ec43db5">手势而不是鼠标点击</a>在订单创建步骤之间导航</li><li id="153e" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">如何记录真实用户<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/web-vitals-guide-b56e28798e7f">网络重要指标</a>绩效指标</li></ul><p id="0cc1" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">当我试图创建一个新订单并编辑现有订单时，令我惊讶的是，我发现这个应用程序运行缓慢，用户体验非常缓慢和糟糕。虽然这可能是一个好消息，因为这个应用程序是我的演讲的一个很好的候选对象，但我很困惑，因为我在实现中使用了Angular良好实践，并取消了所有事件侦听器的订阅。</p><p id="3fe1" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">作为研究内存使用的起点，我检查了性能时间线记录:</p><ol class=""><li id="5a49" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw nu nf ng nh bi translated">打开Chrome DevTools上的性能面板</li><li id="a276" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">启用内存复选框</li><li id="1a37" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">录制一段录音</li></ol><p id="f711" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated"><strong class="md je">注意:</strong>最好在记录开始和结束时点击<strong class="md je">收集垃圾</strong>按钮。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj nv"><img src="../Images/b323361385146f831a8bf561b1895cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:36/0*ROsmg8K020R86SOO"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">垃圾收集按钮</p></figure><p id="c202" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">结果如下:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj nw"><img src="../Images/f0aeb1a04f22256e056f88f2d0c7b255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R80dFPi9yqPwSr8ivDcDHA.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">Chrome DevTools中我的应用程序的性能时间线记录(图片由作者提供)</p></figure><ul class=""><li id="33cb" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated">代表每秒帧数(FPS)的线条几乎完全是红色的。</li><li id="97e8" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">CPU消耗大约为100%(黄色矩形)。</li><li id="a680" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">脚本量非常大——浏览器在脚本任务上忙碌了47秒(从48秒的记录开始)。</li><li id="937b" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">总阻塞时间(TBT)超过18秒(18745.66毫秒)。</li></ul><p id="8a6f" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">在我的职业生涯中，我目睹过一些web性能很差的应用程序，但我从未见过如此糟糕的性能时间线。</p><p id="50e5" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">为了直观地显示内存是如何在应用程序的JavaScript(对象、原语、字符串、函数、DOM节点等)之间分配的，我生成了两个堆快照:第一个是在启动应用程序之后，第二个是在执行一个简短的场景之后。以下是创建快照的方法:</p><ol class=""><li id="dc4d" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw nu nf ng nh bi translated">打开内存面板。</li><li id="6e11" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">启用堆快照复选框。</li><li id="0551" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">点击“拍摄快照”按钮。</li></ol><p id="d12c" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">第一个堆快照的大小是9.5MB，但是令我惊讶的是，第二个堆快照的大小是110 MB——增加了超过<strong class="md je"> 100 MB </strong>！</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj nx"><img src="../Images/eba433d3c7d84c923b43e754dba174dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*JLg4V-svsEbm3jN6HYDNuA.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">执行简单场景后，堆快照增加了100MB(图片由作者提供)</p></figure><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ny nz l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">使用Chrome DevTools内存分析器拍摄并比较两个堆快照</p></figure><p id="67ae" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">在那之后，当我试图记录“分配时间线”时，应用程序崩溃了不止一次。</p><p id="fa2a" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">这是我第一天的成果。目前，我不知道是哪个问题导致了这个问题，所以我将在第二天看到您的结果。</p><h1 id="9512" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">第二天:罪犯</h1><p id="0e73" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">您可能已经注意到，在显示110MB堆快照统计信息的图表中，有超过90MB的类型化数组。</p><p id="73a9" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">如果你很想知道它们是什么，它们来自哪里，下面是答案:</p><p id="51e0" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">JavaScript的类型化数组允许我们在内存缓冲区中读写原始的二进制数据。它们是类似阵列的物体，可以be⁸:</p><ul class=""><li id="b7cc" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated"><em class="oa"> Int8Array </em>，<em class="oa"> Int16Array </em>，<em class="oa"> Int32Array </em></li><li id="b55a" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><em class="oa"> Uint8Array </em>，<em class="oa"> Uint8ClampedArray </em></li><li id="610d" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><em class="oa">浮动t32阵列</em>，<em class="oa">浮动64阵列</em></li><li id="197d" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><em class="oa">数组缓冲器</em></li><li id="2954" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><em class="oa">数据视图</em></li><li id="077f" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">以及其他等等</li></ul><p id="9332" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">它们由以下人员使用:</p><ul class=""><li id="9c77" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated">WebSockets</li><li id="cba3" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">网络工作者</li><li id="2395" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">XMLHttpRequests</li><li id="61c5" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">获取API</li><li id="ed48" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">文件API</li><li id="6fb7" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">网络音频API</li><li id="f960" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">WebGL</li><li id="6d96" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">帆布</li><li id="bc96" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">媒体源API</li></ul><p id="a1d3" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">在我的应用程序中，我没有WebSockets、Web Workers和XMLHttpRequests，也没有使用Fetch API、File APIs或Web Audio API。但是我确实有一个<code class="fe nn no np nq b">canvas</code>和一个DOM元素在<code class="fe nn no np nq b">dynamic-stepper.component.html</code>中，用来显示用户给应用程序在步骤之间导航的实时视频:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ob nz l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">HTML5画布和视频标签</p></figure><p id="a368" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我不知道WebGL是什么，但是稍微搜索了一下，了解到它是一个利用电脑的显卡(GPU)的浏览器API。它于2011年推出，具有革命性，因为它允许在没有插件的情况下在网络上发布3D内容，并且具有高水平的安全⁰.</p><p id="5158" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">我继续对110 MB堆快照进行分析，发现张量——这让我想起了我为实现手势功能而添加到应用程序中的<code class="fe nn no np nq b">tensor.js</code>库——是拥有较大“浅尺寸”和较大“保留尺寸”的元素之一，如下所示:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj oc"><img src="../Images/de0de449ab0fa699fe2a365f95165d57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5dhWYmkN6KF_3cUx4ZodvQ.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">堆快照中的张量流(图片由作者提供)</p></figure><h2 id="7db0" class="od lk iu bd ll oe of dn lp og oh dp lt mk oi oj lv mo ok ol lx ms om on lz ja bi translated">浅尺寸</h2><p id="1162" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">对象本身拥有的内存大小被称为“浅大小”通常，只有数组和字符串具有有效的浅size⁸.</p><p id="f77b" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">但是由于一个对象可以通过保存对其他对象的引用来间接保存内存，所以即使是小对象也可以通过防止被引用的对象被垃圾收集器(GC)自动释放来保留大量内存。</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oo"><img src="../Images/e8f7aa9cfe473ea775d0cc9710440efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/0*Hh70KIuWfqeZb4ig"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">浏览器的<code class="fe nn no np nq b">window</code>对象或者Node.js模块的<code class="fe nn no np nq b">Global</code>对象代表内存图的根。所有不能从根到达的对象都被GC。(图片source⁸)</p></figure><h2 id="5b77" class="od lk iu bd ll oe of dn lp og oh dp lt mk oi oj lv mo ok ol lx ms om on lz ja bi translated">保留尺寸</h2><p id="13a1" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">一旦对象本身及其相关对象被删除，所释放的内存大小就代表“保留的大小”</p><h2 id="c4bf" class="od lk iu bd ll oe of dn lp og oh dp lt mk oi oj lv mo ok ol lx ms om on lz ja bi translated">距离</h2><p id="0733" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">在上面的内存分析器的distance列中，有一些数字表示到GC根的距离。</p></div><div class="ab cl op oq hy or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="in io ip iq ir"><p id="b7a9" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">因此，考虑到这一点，让我们继续我们的调查。堆分析器显示了更多的洞察力:</p><ul class=""><li id="7501" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated"><strong class="md je"> ArrayBuffer </strong>(类型化数组):shallow大小50.096B，retained大小90.229.828B(距离3) → retained memory是shallow大小的1801倍，它代表总retained memory大小的82%。</li><li id="cb73" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><strong class="md je"> Float32Array </strong>(类型化数组):浅大小51.120B，保留大小27.607.600B(距离8) →保留内存是浅大小的540倍，它代表总保留内存大小的25%。</li><li id="c163" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><strong class="md je"> Int32Array </strong>(类型化数组):浅层大小4.320B，保留大小9.320B(距离8)。</li><li id="4ee3" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><strong class="md je">EncodeMatrixPackedProgram:</strong><em class="oa">T5】浅尺寸896B，保留尺寸77.200B(距离6) →保留内存是浅尺寸的86倍。</em></li></ul><p id="47ee" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">原来EncodeMatrixPackedProgram是来自WebGL和TensorFlow.js，我在GitHub里发现了一个与之相关的<a class="ae li" href="https://github.com/tensorflow/tfjs/issues/3551" rel="noopener ugc nofollow" target="_blank">问题</a>。根据DevTools的说法，WebGL也使用710个Float32Array对象和60个Int32Array对象。下面的图片展示了它们的用法:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ow"><img src="../Images/7a1dc8e11d15b4552375bcede35ecc43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rCgkhrJaUSTOuUJ7pKOSow.png"/></div></div><p class="le lf gk gi gj lg lh bd b be z dk translated">DevTools中的堆分析器分析(图片由作者提供)</p></figure><p id="65dc" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">有了这个结果，我回到我的应用程序，删除了我使用过<code class="fe nn no np nq b">TensorFlow.js</code>库的代码行。</p><p id="9096" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">你能猜出结果吗？</p><p id="9840" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">性能得到了显著提高，在执行相同的场景后，堆快照几乎没有增加，而在TensorFlow.js存在时，堆快照增加了100 MB以上。该视频展示了性能的提升:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ny nz l"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">使用和不使用TensorFlow.js时我的应用程序性能</p></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj ox"><img src="../Images/f72db580580310736bc66b40d7e7cbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1298/format:webp/1*AzymW9PFs3is73v5D8_n1Q.png"/></div><p class="le lf gk gi gj lg lh bd b be z dk translated">使用tensor.js删除后堆快照没有增加(图片由作者提供)</p></figure><p id="d0f1" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">这是一个经验证据，证明导致性能灾难的罪魁祸首是<code class="fe nn no np nq b">TensorFlow.js</code>。</p><p id="a65d" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">但是，我很好奇，为什么？为什么这个库会造成这么可怕的性能？我想知道我的情况是否是个例外？</p><h1 id="4452" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">第三天:为什么TensorFlow.js扼杀了我的表现</h1><p id="ee05" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">第三天，我看了一系列教程，了解了图书馆的工作原理。这是我的发现。</p><blockquote class="oy oz pa"><p id="e0ad" class="mb mc oa md b me mz ke mg mh na kh mj pb nr mm mn pc ns mq mr pd nt mu mv mw in bi translated">“TensorFlow.js是Google创建的一个开源框架，用于在浏览器中训练和使用机器学习模型。它帮助JavaScript开发人员在客户端应用程序中构建和部署ML模型，而无需设置服务器甚至数据库。</p><p id="3dad" class="mb mc oa md b me mz ke mg mh na kh mj pb nr mm mn pc ns mq mr pd nt mu mv mw in bi translated">该库也是与其同名的TensorFlow(与Python一起使用的ML库)的伴侣，这意味着你可以使用TensorFlow.js转换任何TensorFlow机器学习模型以在浏览器中运行。”</p></blockquote><p id="ce8d" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">由于浏览器是一个交互式空间，提供了对不同传感器的访问——如网络摄像头和麦克风——它可以提供视觉和声音作为任何机器学习模型的输入。这为企业和开发者打开了一系列令人兴奋的可能性。</p><p id="1670" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">许多开发人员正在从在后端服务器上使用ML转向前端应用程序。</p></div><div class="ab cl op oq hy or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="in io ip iq ir"><h2 id="6627" class="od lk iu bd ll oe of dn lp og oh dp lt mk oi oj lv mo ok ol lx ms om on lz ja bi translated">TensorFlow.js和WebGL</h2><p id="8404" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">与TensorFlow仅支持NVIDIA GPUs不同，TensorFlow.js通过使用WebGL浏览器API，可以与任何显卡(GPU)配合工作。这是TensorFlow.js相对TensorFlow的一个优势。</p><p id="6730" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">因此，您会损失一些性能，因为只能通过一些技巧让WebGL执行TensorFlow.js所需的矩阵乘法。</p><p id="10dc" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">以下是WebGL应用程序的剖析:</p><ol class=""><li id="dbf5" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw nu nf ng nh bi translated">创建一个<code class="fe nn no np nq b">&lt;canvas&gt;</code>元素</li><li id="893f" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">获取绘图上下文</li><li id="451f" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">初始化视口</li><li id="2469" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">创建一个或多个缓冲区</li><li id="f708" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">创建一个或多个矩阵</li><li id="46ad" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">创建一个或多个着色器，这些着色器是在屏幕上绘制东西并在图形处理单元(GPU)上运行的函数。</li><li id="cb77" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">初始化着色器</li><li id="43f0" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw nu nf ng nh bi translated">绘制一个或多个图元</li></ol><p id="b323" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">下面是来自<a class="pe pf ep" href="https://medium.com/u/c58181bd823e?source=post_page-----3db05b1de958--------------------------------" rel="noopener" target="_blank"> Tony Parisi </a>的一些见解，解释了为什么将TensorFlow.js与WebGL一起使用可以呈现性能challenge⁶:</p><ul class=""><li id="fbfe" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated">WebGL通过在类型化数组中加载JSON或JSON+二进制数据开创了类型化数组的先河。</li><li id="7f7a" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">WebGL没有DOM，没有CSS，也没有布局影响。要在屏幕上看到任何东西，API需要大量的脚本代码——很多！</li><li id="6051" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">WebGL使用着色器，这会导致额外的请求和客户端加载/ <a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/compiler-vs-interpreter-d0a12ca1c1b6">编译</a>时间。</li><li id="8c80" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">WebGL会通过管道传输更多的内容。</li><li id="cf7d" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated">由于大量的计算，WebGL应用程序可能会成为CPU吸血虫。</li></ul><p id="4b0e" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">因此，与TensorFlow相比，当使用TensorFlow.js时，我们必须在性能方面做出一些权衡。当这变得至关重要时，建议改用Python。</p><h1 id="8754" class="lj lk iu bd ll lm ln lo lp lq lr ls lt kj lu kk lv km lw kn lx kp ly kq lz ma bi translated">最后的想法</h1><p id="df57" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated">我在应用中实现的最后一个功能需要添加两个库:</p><ul class=""><li id="183b" class="mx my iu md b me mz mh na mk nb mo nc ms nd mw ne nf ng nh bi translated"><code class="fe nn no np nq b">web-vital</code>收集关于用户体验的现场数据</li><li id="3a4d" class="mx my iu md b me ni mh nj mk nk mo nl ms nm mw ne nf ng nh bi translated"><code class="fe nn no np nq b">tensor.js</code>通过结合<a class="ae li" href="https://medium.com/geekculture/how-to-get-started-with-chatbots-9f7769b7c786" rel="noopener">机器学习</a>和前端开发来使用手势。</li></ul><p id="f215" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">但是，除了确保正确记录性能指标以及成功检测和执行我用手给出的指令之外，我还没有检查我的应用程序对执行旧场景的响应性。</p><p id="3753" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">如果您有一个应用程序在生产中，这是一个错误，因为性能监控是一个过程，而不是一个事件。持续的测试和从中收集的信息是应用程序整体成功的关键因素。</p><p id="d0d6" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">感谢阅读！如果你更喜欢看这里的<a class="ae li" href="https://www.youtube.com/watch?v=4ja6OQYbEaI" rel="noopener ugc nofollow" target="_blank">一段视频</a>。我如何解决这个问题的下一部分在本文中:<a class="ae li" href="https://levelup.gitconnected.com/how-to-use-tensorflow-js-without-memory-leaks-273ad16196be" rel="noopener ugc nofollow" target="_blank">我如何在使用TensorFlow.js而不泄漏内存的战斗中获胜</a>。</p></div><div class="ab cl op oq hy or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="in io ip iq ir"><p id="efdf" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="md je">加入我的免费电子邮件简讯独家访问</strong> </a> <strong class="md je"> </strong>或在此注册媒体<a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener"/>。</p></div><div class="ab cl op oq hy or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="in io ip iq ir"><h1 id="5ba3" class="lj lk iu bd ll lm pg lo lp lq ph ls lt kj pi kk lv km pj kn lx kp pk kq lz ma bi translated">参考</h1><p id="e96d" class="pw-post-body-paragraph mb mc iu md b me mf ke mg mh mi kh mj mk ml mm mn mo mp mq mr ms mt mu mv mw in bi translated"><a class="ae li" href="https://developer.chrome.com/docs/devtools/memory-problems/" rel="noopener ugc nofollow" target="_blank">修复内存问题</a></p><p id="444c" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated"><a class="ae li" href="https://dlabs.ai/blog/performance-comparison-javascript-vs-python-for-machine-learning/" rel="noopener ugc nofollow" target="_blank">性能比较:JavaScript与Python用于机器学习</a></p><p id="9667" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated"><a class="ae li" href="https://dlabs.ai/blog/the-pros-and-cons-of-using-javascript-for-machine-learning/" rel="noopener ugc nofollow" target="_blank">使用JavaScript进行机器学习的利弊</a></p><p id="c215" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">⁴ <a class="ae li" href="https://docs.google.com/presentation/d/1QsaLOsl82tQUDxkqbuVg3jS_NhFUkHnuagi8NpR66mM" rel="noopener ugc nofollow" target="_blank"> TensorFlow开发者峰会</a></p><p id="9c3c" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">⁵ <a class="ae li" href="https://www.slideshare.net/auradeluxe/webgl-and-web-site-performance" rel="noopener ugc nofollow" target="_blank"> WebGL和网站性能</a></p><p id="8484" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">⁶ <a class="ae li" href="https://www.slideshare.net/auradeluxe/webgl-the-next-generation" rel="noopener ugc nofollow" target="_blank"> WebGL:下一代</a></p><p id="7e96" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">⁷ <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" rel="noopener ugc nofollow" target="_blank"> JavaScript类型化数组</a></p><p id="3d10" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">⁸<a class="ae li" href="https://www.youtube.com/watch?v=UYkJaW3pmj0" rel="noopener ugc nofollow" target="_blank">JavaScript中的类型化数组简介</a></p><p id="25a2" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">⁹ <a class="ae li" href="https://developer.chrome.com/docs/devtools/memory-problems/memory-101/" rel="noopener ugc nofollow" target="_blank">记忆术语</a></p><p id="6fc5" class="pw-post-body-paragraph mb mc iu md b me mz ke mg mh na kh mj mk nr mm mn mo ns mq mr ms nt mu mv mw in bi translated">⁰ <a class="ae li" href="https://viscircle.de/why-webgl-2-0-is-the-way-to-even-better-3d-web-graphics/?lang=en" rel="noopener ugc nofollow" target="_blank">为什么WebGL 2.0是更好的3D网络图形之路</a></p></div></div>    
</body>
</html>