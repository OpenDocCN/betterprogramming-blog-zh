<html>
<head>
<title>Using withUnretained in RxSwift 6.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxSwift 6.0中的withUnretained</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-withunretained-in-rxswift-6-0-8e3e221b37ee?source=collection_archive---------2-----------------------#2021-01-02">https://betterprogramming.pub/using-withunretained-in-rxswift-6-0-8e3e221b37ee?source=collection_archive---------2-----------------------#2021-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f4c0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">新功能导致新扩展的故事</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/118c58801bde651b50ab0e0102524acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2z2gkJrUWAG5-fymMN9KQA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">通过RxSwift GitHub项目推出新的RxSwift 6.0徽标</p></figure><p id="0b95" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">(终于)新的一年到了，伴随着它，我们有了RxSwift的新版本。</p><p id="de30" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">6.0版本带来了相当多的新功能和变化，但我今天想讨论的是<code class="fe lu lv lw lx b">withUnretained</code>以及它如何解决——以及未能解决——我们RxSwift代码中最常见的问题之一。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="8dad" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">虚弱的自我和保持循环</h1><p id="91e8" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">考虑以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7241" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">订阅一个可观察对象并将结果交给一个类方法在RxSwift中是非常常见的事情。不幸的是，当在类实例内部使用时，它很容易保留循环，这就是为什么我们不断地在闭包中添加<code class="fe lu lv lw lx b">[weak self]</code>并经常添加<code class="fe lu lv lw lx b">guard</code>语句以确保我们的实例没有被释放。</p><p id="eac9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">就其本身而言，代码还不算太差。但是如果你添加了足够多的订阅处理程序，所有的<code class="fe lu lv lw lx b">[weak self]</code>样板文件开始增加，它会模糊我们的意图，弄乱我们的代码。</p><p id="3770" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">社区RxSwift库，<a class="ae ne" href="https://github.com/RxSwiftComunity/RxSwiftExt" rel="noopener ugc nofollow" target="_blank"> RxSwiftExt </a>，有一个名为<code class="fe lu lv lw lx b">withUnretained</code>的操作员负责这个案例。更重要的是，RxSwift 6.0中现已提供该运算符。</p><p id="6fc2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们看看它是如何解决我们的一个问题的。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="f9b9" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使用withUnretained</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5eef" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们将<code class="fe lu lv lw lx b">.withUnretained(self)</code>添加到我们的事件流中。这将我们的事件流从原始的单个值更改为一个元组，除了原始值之外，该元组还包含对self的有效引用。</p><p id="4b4e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，我说过我们正在获取一个有效的引用。事实上，传递的引用是<em class="nf">保证</em>有效。如果不是，并且引用已经超出范围，那么整个序列将会完成，我们的<code class="fe lu lv lw lx b">onNext</code>处理程序将不会被调用。</p><p id="e414" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仅此而已。现在所有的<code class="fe lu lv lw lx b">[weak self]</code>样板文件都已经从我们的代码中移除，一切都变得更加清晰。</p><p id="d00e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是有一个条件——很明显，否则这篇文章就不算什么了！</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="2c30" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">错误处理</h1><p id="964e" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">如果除了数据值之外，我们还需要处理错误或完成事件，那该怎么办？好吧，这样的话，我们又回到起点了。观察:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="23fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的<code class="fe lu lv lw lx b">onNext</code>处理程序中有一个对我们所有者的有效引用，但是我们的<code class="fe lu lv lw lx b">onError</code>和<code class="fe lu lv lw lx b">onCompleted</code>处理程序又回到了使用<code class="fe lu lv lw lx b">[weak self]</code>的状态。为什么？</p><p id="d218" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">嗯，由于RxSwift中的<code class="fe lu lv lw lx b">Event</code>枚举类型的性质，我们可以随意更改我们的<code class="fe lu lv lw lx b">next</code>元素类型(<code class="fe lu lv lw lx b">map</code>、<code class="fe lu lv lw lx b">flatMap</code>等)。)，但<code class="fe lu lv lw lx b">error</code>和<code class="fe lu lv lw lx b">completed</code>事件有严格的现有定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4b22" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，当事件发生时，根本没有办法使用事件将对我们所有者的引用传递到我们的订阅链。</p><p id="278d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此<code class="fe lu lv lw lx b">withUnretained</code>在这方面似乎没有什么价值，我们回到在错误和完成处理程序中使用<code class="fe lu lv lw lx b">[weak self]</code>。</p><p id="e57f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还是我们？</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="5fed" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">使用Subscribe(带:)</h1><p id="9e0a" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">让我们重申一下我们的问题:我们不能在我们的<code class="fe lu lv lw lx b">error</code>和<code class="fe lu lv lw lx b">completed</code>处理程序中使用我们的所有者，因为我们不能将对我们的所有者的引用传递给我们的订阅。</p><p id="f602" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好...但是如果我们根本不用<code class="fe lu lv lw lx b">withUnretained</code>呢？如果我们没有向下传递任何引用怎么办？如果我们抓住并维护我们在订阅本身中的弱引用会怎么样？</p><p id="2a1c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后它将对我们所有的订阅关闭可用！</p><p id="d81c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">瞧吧。我给你<code class="fe lu lv lw lx b">subscribe(with:)</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="54a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们基本上将<code class="fe lu lv lw lx b">withUnretained</code>功能直接嵌入到我们的订阅处理程序中。这让我们可以将对<code class="fe lu lv lw lx b">self</code>的引用提供给我们的<code class="fe lu lv lw lx b">onNext</code>、<code class="fe lu lv lw lx b">onError</code>和<code class="fe lu lv lw lx b">onCompleted</code>处理程序。</p><p id="39e5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我认为去掉了<code class="fe lu lv lw lx b">[weak self]</code>样板文件后，这段代码更加简洁。事实上，如果我们想使用未命名的参数，我们可以把它归结为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5d1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<code class="fe lu lv lw lx b">$0</code>是我们对自我的引用，而<code class="fe lu lv lw lx b">$1</code>分别是我们的值或误差。我认为你不能做得比那更好了。</p><p id="1119" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，就像<code class="fe lu lv lw lx b">withUnretained</code>一样，如果我们的弱引用超出范围，我们的完成处理程序都不会被调用。当你认真对待它的时候，那是有意义的。我是说，如果我们的集装箱不见了，我们该找谁谈？</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="4cf4" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Subscribe(带:)分机</h1><p id="e200" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">不幸的是，<code class="fe lu lv lw lx b">subscribe(with:)</code>不是RxSwift 6.0的一部分。幸运的是，作为我们自己的扩展之一，编写和添加到项目中是非常容易的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a0d3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这几乎就是你从我们之前的描述中所期待的。我们捕获对对象的弱引用，然后在将给定事件传递给任何处理程序之前检查它。如果引用是错误的，我们根本不调用处理程序。</p><p id="6756" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于那些仍在使用RxSwift 5.1的人来说，还要注意这个扩展是向后兼容的。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="dd36" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">带未保留和平面图</h1><p id="38de" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">您还可以将<code class="fe lu lv lw lx b">withUnretained</code>与其他RxSwift运算符一起使用，以避免弱自保持循环问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="664a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这里，<code class="fe lu lv lw lx b">withUnretained</code>再次捕获self并确保后面的<code class="fe lu lv lw lx b">flatMap</code>对其模型有一个有效的引用。</p><p id="9dfb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，请注意，如果您想要将<code class="fe lu lv lw lx b">flatMaps</code>链接在一起，那么您将需要一个针对每一个的<code class="fe lu lv lw lx b">withUnretained</code>语句。每个<code class="fe lu lv lw lx b">flatMap</code>都直接返回它的可观察值，反过来，从流中删除模型元组。</p><p id="5dc7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一句话:虽然你可以这样做，但我不确定我会推荐你这样做。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="65dd" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">奖励回合:属性绑定</h1><p id="a464" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">RxSwift 6.0中另一个很酷的特性是使用<code class="fe lu lv lw lx b">@dynamicMemberLookup</code>自动合成属性绑定。</p><p id="3696" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这意味着RxSwift 6将自动为其<code class="fe lu lv lw lx b">.rx</code>类扩展之外的任何属性创建一个可绑定的引用。考虑一下这个:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7678" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们将来自我们的<code class="fe lu lv lw lx b">viewModel</code>的一个可观察对象直接绑定到我们的<code class="fe lu lv lw lx b">myString</code>属性。这种形式的<code class="fe lu lv lw lx b">bind</code>堪比Combine的<code class="fe lu lv lw lx b">assign</code>语句。</p><p id="5bb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，这只适用于基于对象的类，如<code class="fe lu lv lw lx b">UIViewControllers</code>、<code class="fe lu lv lw lx b">UIViews</code>等。</p></div><div class="ab cl ly lz hx ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="im in io ip iq"><h1 id="d8a0" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">完成块</h1><p id="bc1c" class="pw-post-body-paragraph ky kz it la b lb mx ju ld le my jx lg lh mz lj lk ll na ln lo lp nb lr ls lt im bi translated">今天就到这里吧。问题陈述并解决。</p><p id="ad2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我要感谢来自RxSwift Slack频道的丹尼尔·塔尔塔利亚(danielt1263)。我提出了上述问题的<code class="fe lu lv lw lx b">subscribe(with:)</code>解决方案，两分钟后，他带着一个潜在的实现回来了。我的有点不同，因为我也经常需要访问<code class="fe lu lv lw lx b">onDisposed</code>处理程序，但功能上它们是相同的。</p><p id="5be4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，RxSwift 6.0增加了许多其他很酷的新功能，你绝对应该看看<a class="ae ne" href="https://github.com/ReactiveX/RxSwift/releases/tag/6.0.0" rel="noopener ugc nofollow" target="_blank">发布说明</a>。毫无疑问，我将在以后的文章中介绍更多的新功能。</p><p id="7f9b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，一个缺点是，它是RxSwift 5的一个突破性变化——主要是在方法签名变化方面。像<code class="fe lu lv lw lx b">.observeOn(...)</code>这样的事情现在变成了<code class="fe lu lv lw lx b">observe(on: ...)</code>。</p><p id="8817" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">据我所知，没有重大的行为变化，所以请注意，如果您升级，您将需要花一点时间在您的项目中做一些全局搜索和替换工作。</p><p id="a823" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下次见。</p></div></div>    
</body>
</html>