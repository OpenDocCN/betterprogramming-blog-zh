<html>
<head>
<title>Beginning Python Programming—Part 7</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python编程入门—第7部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/beginning-python-programming-part-7-2f7df98b7c68?source=collection_archive---------4-----------------------#2019-05-31">https://betterprogramming.pub/beginning-python-programming-part-7-2f7df98b7c68?source=collection_archive---------4-----------------------#2019-05-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0377" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类是如何创建的，它们来自哪里等等</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/b8fac9ff10013135ece8dea181734111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UluA26VGbpSdz75C"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@hungnp92?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">nguyễn</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="979d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我们讨论了类、方法和属性。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/beginning-python-programming-part-6-f128360f44ab" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第6部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">为您的代码创建可重用的蓝图</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="c4b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些是在我们的代码中创建新的、可重用的对象的基本构件，也是保持代码整洁的另一个工具。我们经常在Python中使用类，所以你需要很好地理解这个工具才能有效。在这篇文章中，我们将看看类是如何创建的。</p><h1 id="67e5" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">初始化</h1><p id="dc0a" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">从最基本的意义上来说，一个类的初始化就是为它提供一个值。有时我们希望一个类在创建时有默认值，有时我们希望告诉这个类它的默认值是什么。</p><p id="b297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类有一个默认的初始化器，当你没有包含自己的初始化器时，这个初始化器就会被调用。所有的类都是如此，因为它们都是从对象类型派生的。</p><p id="d26e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之前我说<code class="fe nl nm nn no b">class MyClass(object)</code>和<code class="fe nl nm nn no b">class MyClass()</code>是一样的。当你创建一个类时，它从一个基类派生或者被子类化<em class="nk">。</em>当您对一个对象进行子类化时，您的子类继承了它所派生的类的所有功能。</p><p id="131a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有这些都很重要的原因是，当你不创建自己的初始化器时，初始化依赖于超类<em class="nk">、</em>也称为父类、<em class="nk">、</em>。</p><p id="4d89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了说明这一点，我们需要简要介绍一下<em class="nk"> builtins.py </em>中的基本<code class="fe nl nm nn no b">object</code>类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><blockquote class="nr ns nt"><p id="86c0" class="kz la nk lb b lc ld ju le lf lg jx lh nu lj lk ll nv ln lo lp nw lr ls lt lu im bi translated">注意:这不是<code class="fe nl nm nn no b">object</code>类的所有方法，只是最常见的方法。我已经减肥了，这样你就不会感到不知所措了。</p></blockquote><p id="0713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">按顺序:</p><ul class=""><li id="166e" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated"><code class="fe nl nm nn no b">__eq__</code>提供了执行比较的功能。这个类等于另一个类吗？使用<code class="fe nl nm nn no b">==</code>操作器时执行。你也有其他的，像<code class="fe nl nm nn no b">__ne__</code>、<code class="fe nl nm nn no b">__lt__</code>、<code class="fe nl nm nn no b">__le__</code>、<code class="fe nl nm nn no b">__gt__</code>和<code class="fe nl nm nn no b">__ge__,</code>为其他的比较操作符工作。</li><li id="6b48" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">提供初始化代码，每当你创建一个类的新实例时运行。当实例化对象时，它根据需要设置属性的值并调用类的方法。在大多数语言中，这被认为是一个构造函数方法，但是Python确实没有构造函数方法。然而，它有一些接近…</li><li id="ba0e" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nl nm nn no b">__new__</code>是Python中最接近构造函数的方法。<code class="fe nl nm nn no b">__new__</code>负责如何创建新对象。虽然简单的例子不能展示这种功能，但是当您有多个子类化级别，并且需要引导一个特定的对象从特定的对象子类化时，这变得更加常见。<code class="fe nl nm nn no b">__new__</code>总是在<code class="fe nl nm nn no b">__init__</code>之前被调用，并且不应该包含实例的默认值。</li><li id="839d" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nl nm nn no b">__repr__</code>提供了对类的明确的“官方”字符串引用，默认情况下是<code class="fe nl nm nn no b">&lt;__main__.MyClass object at 0x100915278&gt;</code>。<code class="fe nl nm nn no b">__main__</code>是这个类所在的文件，<code class="fe nl nm nn no b">MyClass</code>是这个对象派生的类，<code class="fe nl nm nn no b">object at 0x100915278</code>是这个对象在内存中的位置，数字是这个对象以十六进制格式开始的块的地址。如果您想在数据库中使用对象的主键，或者甚至使用一个<em class="nk"> guid </em>，全局唯一标识符，来惟一地描述这个对象，那么这可以被覆盖。</li><li id="b042" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nl nm nn no b">__sizeof__</code>很简洁，因为它向我们展示了这个对象的字节大小。默认情况下，它是32字节，但根据该对象保存的数据，它可能会变得很大。用<code class="fe nl nm nn no b">my_object.__sizeof__()</code>找到一个对象的大小，但是要记住——任何带有<code class="fe nl nm nn no b">__</code>的对象都不应该被直接调用，所以用代码顶部的<code class="fe nl nm nn no b">import sys</code>来代替，用<code class="fe nl nm nn no b">sys.getsizeof(my_object)</code>来代替。这实际上为您调用了<code class="fe nl nm nn no b">__sizeof__()</code>，但这是推荐的方法。</li><li id="2e53" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated"><code class="fe nl nm nn no b">__str__</code>提供对此类的“非正式”字符串引用。如果您不覆盖该实现，它将提供与<code class="fe nl nm nn no b">__repr__</code>相同的信息。如果你需要一个友好的类名——当你使用<code class="fe nl nm nn no b">str(my_object)</code>时在字符串中使用——这里就是你需要的地方。如果您不覆盖<code class="fe nl nm nn no b">__str__</code>，它将提供来自<code class="fe nl nm nn no b">__repr__</code>的字符串描述。</li></ul><p id="5b8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果其中任何一个对您来说还没有意义，请不要担心——我们将很快介绍它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8e2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些知识，我们现在就可以理解类是如何被创建的，以及所有这些默认的功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/cdb635a3ca6d479396565b5145d9758d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ABQoeOwk5g_FT3Lx"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马修·汉密尔顿在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="d135" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">子类化和覆盖</h1><p id="5961" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">当您更改类的默认实现时，会发生重写。</p><p id="188f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于上面的人员类别，如果我们做一些稍微不同的事情会怎么样…</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生以下输出…</p><pre class="kj kk kl km gt om no on oo aw op bi"><span id="087b" class="oq mo it no b gy or os l ot ou">daniel jackson<br/>daniel jackson<br/>daniel jackson<br/>--------------<br/>jack<br/>jack<br/>jack o'neill</span></pre><p id="0411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们使用<code class="fe nl nm nn no b">Person2(Person1)</code>子类化<code class="fe nl nm nn no b">Person1</code>。细节对于<code class="fe nl nm nn no b">Person1</code>是一样的，但是在<code class="fe nl nm nn no b">Person2</code>中我们不需要调用初始化器。请记住，<code class="fe nl nm nn no b">Person1</code>会覆盖<code class="fe nl nm nn no b">__repr__</code>方法，而<code class="fe nl nm nn no b">Person2</code>只会覆盖<code class="fe nl nm nn no b">__str__</code>方法。</p><p id="0f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们打印<code class="fe nl nm nn no b">daniel</code>时，我们可以看到，无论我们调用哪个字符串表示，我们总是得到<em class="nk">丹尼尔杰克逊</em>。这里没什么新鲜的。</p><p id="9807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当我们调用<code class="fe nl nm nn no b">jack</code>时，我们得到了不同的结果和关于<code class="fe nl nm nn no b">print()</code>如何工作的线索。让我们先看看实现，然后跳回到结果。</p><p id="d7ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的<code class="fe nl nm nn no b">__init__</code>方法缺失。通过忽略它，Python自动在下一个父类中寻找一个<code class="fe nl nm nn no b">__init__</code>方法。由于<code class="fe nl nm nn no b">Person1</code>包含一个<code class="fe nl nm nn no b">__init__</code>方法，我们使用它并提供<code class="fe nl nm nn no b">first_name</code>和<code class="fe nl nm nn no b">last_name</code>参数来创建我们的<code class="fe nl nm nn no b">Person2</code>类。如果我们有一个没有初始化器的<code class="fe nl nm nn no b">Person3(Person2)</code>类，它会一直回到<code class="fe nl nm nn no b">Person1</code>寻找默认的初始化器。</p><p id="3bbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义了<code class="fe nl nm nn no b">__str__(self)</code>，但是它只返回了<code class="fe nl nm nn no b">self.first_name</code>，而不是这个人的全名。因为这个小小的变化，我们可以看看我们的结果来比较差异。</p><p id="22c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">print(jack)</code>和<code class="fe nl nm nn no b">print(str(jack)</code>都在终端显示<em class="nk">插孔</em>。这意味着如果我们在打印语句中不包含<code class="fe nl nm nn no b">str</code>，函数<code class="fe nl nm nn no b">print</code>会自动调用我们类的这个函数。</p><p id="fe6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这里有一些有趣的事情，当我们使用<code class="fe nl nm nn no b">print(repr(jack))</code>时，我们得到的是全名，而不是像以前一样在内存中的地址。这意味着当我们调用<code class="fe nl nm nn no b">__repr__</code>上的<code class="fe nl nm nn no b">print</code>函数时，我们调用了<code class="fe nl nm nn no b">Person1</code>类的实现。</p><p id="0a1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重写只在一个方向起作用，如果你改变了一个子类的实现，它只影响那个子类和那个子类的其他子类。</p></div><div class="ab cl ov ow hx ox" role="separator"><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa pb"/><span class="oy bw bk oz pa"/></div><div class="im in io ip iq"><p id="7126" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我把<code class="fe nl nm nn no b">Person1</code>中的<code class="fe nl nm nn no b">__repr__</code>换成<code class="fe nl nm nn no b">__str__</code>会怎么样？</p><p id="e5ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">Person1</code>将不再显示该类的每个实例的友好名称，取而代之的是，您将看到该实例驻留在内存中的地址。然而，打印<code class="fe nl nm nn no b">str(daniel)</code>会打印<em class="nk">丹尼尔·杰克森。</em></p><p id="cd28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nl nm nn no b">Person2</code>会受到什么影响？</p><p id="a893" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在打印<code class="fe nl nm nn no b">repr(jack)</code>时<code class="fe nl nm nn no b">Person2</code>也会打印内存中的地址，但是，我们现在从<code class="fe nl nm nn no b">Person1</code>而不是<code class="fe nl nm nn no b">object</code>中覆盖<code class="fe nl nm nn no b">__str__</code>，所以我们会看到<em class="nk">杰克</em>在屏幕上打印出来，而不是<em class="nk">杰克奥尼尔。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d61b955f81fae7f94b05cc26300bfa3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pk9HMx92W18isTnX"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gary_at_unsplash?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gary Chan </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><h1 id="7416" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">去初始化</h1><p id="90eb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在大多数情况下，取消初始化是自动发生的。稍后会有更多内容。取消初始化是销毁对象的过程，与初始化相反。</p><p id="6ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从表面上看，这是一个简单的过程。我们所做的就是<code class="fe nl nm nn no b">del charlie</code>或<code class="fe nl nm nn no b">del daniel</code>，调用从<code class="fe nl nm nn no b">object</code>继承的类的<code class="fe nl nm nn no b">__del__</code>方法。这将移除指向内存中对象位置的指针。随后，一个名为<em class="nk">垃圾收集</em>的进程出现，就像迪士尼<em class="nk"> Wall-E上的清理机器人一样。</em>垃圾收集总是在后台运行，并在内存中寻找缺少引用的对象，然后将这些块设置为<em class="nk">空闲</em>状态，这意味着其他程序可以使用该内存块来满足自己的需求。</p><p id="cf40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时这需要更多的思考，所以当我们深入了解去初始化时，我们需要了解一些其他的东西…</p><h1 id="d3f6" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">引用计数</h1><p id="9979" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">每当在Python中创建一个类时，都会创建一个对对象的引用。当创建这个引用时，系统会创建一个计数器，这个计数器直接引用指向它的对象(包括变量)的数量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/51dc026330067d5b5a582b0570df99ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*P6Z8bwNVVnM2awNQDe67Ug.png"/></div></figure><p id="ad8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们有两个引用，A和B都指向数据，所以我们更新计数器说有两个引用。如果A被去初始化，那么我们只有一个对数据的引用。</p><p id="41a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果A和B都不再引用数据会怎么样？根据记忆法则，数据会无限期地留在那里，或者至少会一直留到电脑关机。</p><p id="4c3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多亏了操作系统，我们不必对这种情况过于恐慌。在Python中，我们有一个称为垃圾收集的工具，它可以检测Python对象之间的循环，并对我们创建的对象的引用进行计数。如果它遇到内存中引用计数器设置为0的块，它会为我们释放这个内存。</p><p id="797e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7511" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们称之为循环引用。<code class="fe nl nm nn no b">book</code>知道它属于一个图书馆，而<code class="fe nl nm nn no b">city_library</code>知道它拥有一本<code class="fe nl nm nn no b">books</code>的字典</p><p id="33e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然像这样的例子在编程中并不常见，但它们可能会发生，您需要小心如何编码。</p><p id="6809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设<code class="fe nl nm nn no b">my_book</code>是第一版，第二版刚刚出来。第一版已经不相关了，图书馆想折腾一下。</p><p id="6fdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果<code class="fe nl nm nn no b">city_library</code>试图删除<code class="fe nl nm nn no b">my_book</code>，他们也做不到，因为我们手中仍有它，并且有对它的引用。如果我们试图丢弃<code class="fe nl nm nn no b">my_book</code>，我们将不能这样做，因为库仍然会为了另一个引用计数而跟踪它。我们陷入了僵局。</p><p id="f83a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe nl nm nn no b">my_book</code>也知道它属于<code class="fe nl nm nn no b">city_library</code>，<code class="fe nl nm nn no b">my_book</code>持有对库的引用。所以我们有两个关于<code class="fe nl nm nn no b">my_book</code>的引用，一个来自我们，一个来自图书馆，还有一个关于<code class="fe nl nm nn no b">city_library</code>的引用，这是因为书里面有<code class="fe nl nm nn no b">city_library</code>的印记。</p><p id="7b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们扔掉这本书，图书馆永远不会知道，并认为它还在我们手中。如果图书馆将它从收藏中删除，我们仍然拥有它，其他人可能会认为我们偷了它，因为这本书仍然引用了图书馆。</p><p id="63c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们如何澄清这一点？</p><p id="0e6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一次删除一个引用。首先，我们需要和图书馆谈一谈，制定一个计划。只要这本书还在我们手里，图书馆愿意和我们一起在柜台工作。</p><p id="6d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图书管理员首先删除这本书属于图书馆的参考文献或有效参考文献<code class="fe nl nm nn no b">del my_book.library</code>，留下2个参考文献。</p><p id="0601" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要删除对这本书的引用，我们使用<code class="fe nl nm nn no b">del my_book</code>将这本书上交，留下1个引用</p><p id="49e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，图书馆使用<code class="fe nl nm nn no b">del city_library["my_book"]</code>从他们的图书字典中删除该条目，删除最后的引用。</p><p id="c8e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">垃圾收集开始了，图书管理员把书扔进了垃圾桶。</p><p id="5a82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们也可以在书上使用一种叫做弱引用的东西，用<code class="fe nl nm nn no b">weakref</code>来定义，表示这个标记没有任何意义，然而，这个标记仍然可以用来追溯到一个特定的库。</p><p id="7f38" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是它的样子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7e96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当我们调用<code class="fe nl nm nn no b">del my_book</code>时，对库的引用被自动删除，对于<code class="fe nl nm nn no b">Book</code>的这个实例，<code class="fe nl nm nn no b">city_library</code>和<code class="fe nl nm nn no b">my_book</code>引用也被删除。所有<code class="fe nl nm nn no b">city_library</code>要做的就是从他们的收藏中移除这本书。</p><p id="b28d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用弱引用有助于确保您不会费力找到像这样令人讨厌的错误，即所谓的<em class="nk">内存泄漏</em>。当您从未从内存中释放对象，并且您的内存被填满时，就会发生内存泄漏。</p><p id="84de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如今，计算机配备了大量内存，内存泄漏已经不那么常见了，但仍然会发生。</p><p id="9a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始混音时，我使用了一个程序来扫描歌曲，找到歌曲的关键字，然后将关键字放在音轨的元数据中。这对于小型收藏来说效果很好，但是我有超过50，000首歌曲——大约40 GB的音乐，远远超过了我电脑的内存容量。该程序将通过大约15000首歌曲，然后它会变得缓慢或崩溃。这是因为它打开了音乐文件并拥有对它们的强引用。</p><p id="a992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该程序内置了一个故障保险，当内存不足时，会触发一个功能，清除对一些先前扫描的文件的引用——足以在再次触发前处理100多首歌曲。不用说，花了大约两天半的时间来扫描所有的歌曲，而这本来可以在大约8个小时内完成。</p><p id="3c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想要更多的例子和对强引用周期更好的解释，请查看Artyer 发布的这个堆栈溢出。</p><h1 id="51fc" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">摘要</h1><p id="d245" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">今天，我们学习了更多关于类是如何创建的，它们来自哪里，我们如何覆盖它们的功能，我们如何摆脱它们，引用周期和内存泄漏。那是一些学问——坚持下去干得好！</p><h2 id="14b7" class="oq mo it bd mp pe pf dn mt pg ph dp mx li pi pj mz lm pk pl nb lq pm pn nd po bi translated">推荐阅读</h2><p id="6f85" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">Python教程9.5 - 9.8(迭代器并不难，只是另一个类方法)</p><div class="lv lw gp gr lx ly"><a href="https://docs.python.org/3/tutorial/classes.html#inheritance" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">9.类- Python 3.7.3文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">与其他编程语言相比，Python的类机制用最少的新语法和…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.python.org</p></div></div></div></a></div><p id="0a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另外，阅读11.6章中的弱引用。</p><div class="lv lw gp gr lx ly"><a href="https://docs.python.org/3/tutorial/stdlib2.html#weak-references" rel="noopener  ugc nofollow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">11.标准库简介——第二部分——Python 3 . 7 . 3文档</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">编辑描述</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">docs.python.org</p></div></div></div></a></div><h1 id="0ec9" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">下一步是什么</h1><p id="79a4" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">接下来是格式化、lambdas和列表理解。格式化可能很久以前就出现了，但是我认为它很容易掌握。列表理解稍微难一点，但只是在语法和使用它们的不同方式上。</p><p id="2ef1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">兰姆达斯将是主要的焦点，因为他们可能是最令人困惑的。</p><p id="98ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，我们将学习制作一行程序的新方法。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/@broebling/beginning-python-programming-part-8-966f1189c1fe" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">Python编程入门—第8部分</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">在上一篇文章中，我们深入挖掘了类，发现了它们是如何被创建和销毁的。我们还看了我们如何…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="pp l mj mk ml mh mm ks ly"/></div></div></a></div></div></div>    
</body>
</html>