<html>
<head>
<title>A Guide to Low-level Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">低级编程指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/e1-one-bite-of-assemblers-at-a-time-58682e7dc2aa?source=collection_archive---------7-----------------------#2022-11-29">https://betterprogramming.pub/e1-one-bite-of-assemblers-at-a-time-58682e7dc2aa?source=collection_archive---------7-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fa98" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">E1 :(一次)咬一口汇编程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/59774919d22d730be5d2992ddb5774cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_X64gnppC1XyRJbx"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@labunsky?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Artem Labunsky </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="abe6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ASM在编程界的份额几乎是3%。这是一个比较大的数字，打败了Rust和Go之类的语言。但是当你在网上搜索教程的时候，几乎什么都不会出现。</p><p id="9071" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这似乎是一个未知的领域，你只能靠自己。我无论如何都在学习它，试图填补这个空白，希望我的思想结构对你有益。</p><p id="43e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这一部分是低级编程相关概念的松散集合。让我们开始吧。</p><h1 id="da08" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">语言</h1><p id="402e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">汇编</strong>你可能知道，是一种低级编程语言，与中央处理器(CPU)的实际工作方式有很强的对应性。</p><p id="a67d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通常情况下，与<em class="mt">操作数</em>(参数)一起被称为<code class="fe mp mq mr ms b"><em class="mt">mnemonic</em></code>的每个语句都是处理器执行特定任务的指令。这些就像在寄存器(处理器中的特殊缓冲区)之间移动变量、从内存加载、算法、位逻辑等等。</p><p id="2c14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于不同的处理器有不同的<em class="mt">指令集</em>(可用操作)，每个汇编程序都是针对特定的CPU。除了将<em class="mt">机器码</em>翻译成人类可读的格式之外，汇编器通常还包括一些额外的特性，使编程更加容易，比如:</p><ul class=""><li id="bc36" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">评论</li><li id="6e3b" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">常数</li><li id="0844" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">编译器指令</li><li id="2c52" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">寄存器和存储单元的符号标记</li></ul><p id="a005" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有多种编译器，如Gnu Assembler、Nasm、Masm，但它们共享两种方言中的任何一种:美国电话电报公司(较旧)和英特尔(较新)。</p><p id="d06f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">差异如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0f3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">机器码</strong>由一系列控制CPU操作的数字组成，是汇编编译器的结果。处理器直接从程序所在的内存中加载这些命令，并处理它们，无需任何进一步的人工干预。</p><p id="5804" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">微操作</strong>是处理器在运行程序时可能完成的最小原子工作单位。单机代码可以翻译成多个微操作。当CPU解码机器指令时，它查找硬编码到芯片上特殊ROM存储器中的相应微操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/acb61a2688aea3b7e228dd69f6ab3bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzUrHjYrBQb64i87Lq2QYA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">任何语言的编译阶段</p></figure><h1 id="2ba7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">处理器架构</h1><p id="e981" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">通常处理器由两个主要部件组成:<em class="mt">前端</em>和<em class="mt">执行核心</em>。</p><p id="bf76" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">前端确保处理器以稳定的速率不断获得指令，没有空闲周期(不做任何事情的周期)。部分程序被加载到<code class="fe mp mq mr ms b">L2</code>缓存中，在那里它们被分成指令和数据。如果指令还没有被缓冲以便更快地检索，则从存储器中加载指令。然后解码就是借助芯片上的查找表将机器代码翻译成微操作。今天的处理器有<em class="mt">流水线</em>设计，我不会解释，直到下一节。现在，假设它们并行执行多条指令。</p><p id="cb91" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行核心执行解码后的微操作。它由几个并行工作的单元组成，例如:</p><ul class=""><li id="d4f8" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">算术与逻辑部件</li><li id="b664" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">上交所、MMX、AVX单位</li><li id="7eac" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">从存储器中加载和存储的单元</li></ul><p id="d56e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为调度器必须并行执行操作，所以它可以提前执行指令。例如，如果有分支语句，就会发生这种情况。称之为<em class="mt">无序执行</em>或<em class="mt">投机</em>。当指令完成时，它被发送到<em class="mt">退休单元</em>进行清除。</p><p id="6c16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时，推测是错误的，我们必须逆转特定执行的效果。这就是<em class="mt">重新排序缓冲区</em>的用途，它只包含预测失误。你可以把它想象成Saga模式中的<em class="mt">补偿事务</em>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/15a3411f58012275ffc179e73987a89a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lanG9noWgVBsQq96VWO6Lg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">典型现代处理器体系结构</p></figure><h1 id="4b04" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">流水线设计</strong></h1><p id="36d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">它也被称为<em class="mt">超标量设计，</em>最好用一个例子来说明。想象一下，处理器是一个流水线，分三个阶段完成一系列指令:加载、解码和执行。</p><p id="59dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在标量设计中，每条指令将经历所有阶段，直到下一条指令开始。</p><pre class="kg kh ki kj gt nm ms nn bn no np bi"><span id="aa05" class="nq lt iq ms b be nr ns l nt nu">| Load | Decode | Execute |<br/>|I1    | -      | -       |<br/>|-     | I1     | -       |<br/>|-     | -      | I1      |<br/>|I2    | -      | -       |<br/>|-     | I2     | -       |<br/>|-     | -      | I2      |<br/>|I3    | -      | -       |<br/>|-     | I3     | -       |<br/>|-     | -      | I3      |</span></pre><p id="c7c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在超标量设计中，流水线中的阶段可以像这样同时执行:</p><pre class="kg kh ki kj gt nm ms nn bn no np bi"><span id="9da4" class="nq lt iq ms b be nr ns l nt nu">| Load | Decode | Execute |<br/>|I1    | -      | -       |<br/>|I2    | I1     | -       |<br/>|I3    | I2     | I1      |<br/>|-     | I3     | I2      |<br/>|-     |-       | I3      |<br/></span></pre><p id="469b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，对于大量的n条指令，加速将是3倍。但这不是玫瑰。由于这种并发性，在流水线的不同阶段，不同指令之间可能会发生数据竞争。</p><p id="ea8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这通常通过在特殊电路缓冲器中保存级之间的临时值来解决，称为<em class="mt">混叠。</em></p><h1 id="dcd5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进程内存(linux)</h1><p id="d553" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当内核启动一个程序时，它将自己的<em class="mt"> ELF文件</em>读入内存，并为其建立虚拟地址空间。</p><p id="2778" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虚拟意味着地址是逻辑的，并以称为<em class="mt">页</em>的单位转换成物理内存。</p><p id="b174" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后从二进制指定的指令开始执行。每次不同的进程被打开(多任务)，它的虚拟地址空间被加载。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/d940ada6f9000209132357c08388f654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Sr9PAPD4z99I0fHW58SeQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Linux进程的内存布局</p></figure><ul class=""><li id="6104" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated">顶部空间由内核占据，并为操作系统中运行的所有程序所共有。但是，它受到保护，不会被用户空间写入和执行</li><li id="16cd" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">为了减少攻击，每个程序都有一个不同长度的堆栈偏移量</li><li id="706c" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">堆栈向下增长，直到达到其极限(著名的堆栈溢出异常)</li><li id="5be7" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">内存映射用于将程序所需的任何文件直接加载到内存中(例如动态链接)</li><li id="17d1" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">堆是一种内存，它比方法调用存在的时间更长，向上增长，并且也有随机长度的偏移量</li><li id="b044" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">Bss是初始化为默认值的变量的一部分</li><li id="3bbd" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">数据是由程序员在整个程序中初始化为静态值的变量的一部分</li><li id="cd9c" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated">文本包含要运行的指令</li></ul><h1 id="2011" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">极低频</h1><p id="f947" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="mt">可执行和可链接格式</em>是Linux可执行文件、共享库和目标文件的通用文件格式。它支持不同的处理器架构和字节序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/e24562e57de683f17a834c0a42969e56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5LwJ5eEK8amnEpVSkY_wQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">ELF文件布局</p></figure><p id="7354" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个文件由标题中列出的部分组成。有些部分很特别，最值得注意的是:</p><ul class=""><li id="6ef3" class="mu mv iq ky b kz la lc ld lf mw lj mx ln my lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.bss</code></li><li id="096e" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.dynamic</code> —共享库的链接信息</li><li id="a4cc" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.init </code> —程序初始化</li><li id="d350" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.interp</code> —解释器的路径，例如，解释器可以是控制整个程序的动态链接器</li><li id="f7b3" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.symtab</code> —符号表</li><li id="5ae5" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.rodata</code> —只读数据</li><li id="7543" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.text</code> —可执行指令</li><li id="4942" class="mu mv iq ky b kz nd lc ne lf nf lj ng ln nh lr mz na nb nc bi translated"><code class="fe mp mq mr ms b">.got </code> —全局偏移表，该技术允许在多个可执行文件中重用共享库</li></ul><h1 id="435d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">动态与静态链接</strong></h1><p id="1cb5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当一个程序被编译为静态时，所有的指令都是一个ELF文件的一部分，并且在程序运行之前符号的位置是已知的。因此，整个ELF文件可以在init上原样复制。但是，如果两个二进制文件共享一个公共代码，这个代码会出现两次，这是不节省空间的。这就产生了动态链接技术。</p><p id="344f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在动态链接中，编译器将引用外部共享库文件的外部符号留空。当程序启动时，动态链接器按需重载共享库，并用适当的内存地址填充这些空白。这就是所谓的<em class="mt">重新定位。</em></p><p id="7c0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你生成的代码无论放在内存的什么地方都可以执行时，这就是所谓的<em class="mt">位置无关代码</em>或简称PIC(这是库的情况，因为你不知道你的代码将被加载到哪里)。所有地址都相对于某个<em class="mt">基址</em>进行解析，基址是最常见的可执行起始地址。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><p id="8461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是很多材料，但希望你会觉得有用。直到下一次，</p><p id="bf50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>