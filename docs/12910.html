<html>
<head>
<title>Optimizations Beyond the Big O — Performance Tricks I Learned at Google</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越大O的优化——我在谷歌学到的性能技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optimisations-beyond-the-big-o-that-i-learned-at-google-5014d5c9d28a?source=collection_archive---------7-----------------------#2022-07-11">https://betterprogramming.pub/optimisations-beyond-the-big-o-that-i-learned-at-google-5014d5c9d28a?source=collection_archive---------7-----------------------#2022-07-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9b88" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我确实在大学里学过很多，但是要么没有完全理解，要么因为缺乏实践而忘记了。在工作中使用它改变了游戏规则！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/466bab8413cf58c80dde8f648898d462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2yD5NdXGbqIVWpsz"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/@pixabay/" rel="noopener ugc nofollow" target="_blank">皮克斯贝</a>在<a class="ae ky" href="https://www.pexels.com/photo/close-up-of-electric-lamp-against-black-background-248747/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片。</p></figure><p id="9120" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们很多计算机领域的人来说，这方面的早期教育都是从大O或者大ω(ω)这个概念开始的。</p><blockquote class="lv lw lx"><p id="7859" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">大O在计算机科学中用于描述算法的性能或复杂度。大O用来描述算法最坏情况的复杂度，而大ω用来描述最好情况的复杂度。</p></blockquote><p id="6a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对我们许多人来说，这可能也是我们最大的噩梦。软件工程面试通常涉及技术问题，要求受访者在严格的时间范围内提出优化的算法。</p><p id="1d37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个单一的编程问题可以用几种方法来解决，所以关键的方面通常是减少时间和空间的复杂性。</p><p id="cbc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个简单的例子就是在一个排序的数组中搜索一个元素。</p><ul class=""><li id="4b0c" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">强力算法具有O(N)复杂度。</li><li id="2e00" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">奥托，二分搜索法的复杂度是O(logN)。</li></ul><p id="4190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着，如果在排序后的输入数组中有大约10⁶元素</p><ul class=""><li id="0851" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">使用强力方法，在最坏的情况下需要10⁶迭代。</li><li id="85e2" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">而对于二分搜索法(优化)，你将需要大约<code class="fe mq mr ms mt b">log2(10^6) ~ 20</code>次迭代。</li></ul><p id="3b96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不常做面试准备，但每次我都做——我发现这是一次有趣的旅程。一般来说，在工作中，我也喜欢获取一段代码，并想办法让它在其他方面更快或更有效(优化)。如果我完全诚实的话，它对我来说是多巴胺的来源:)。</p><p id="da7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，我在谷歌的工作让我在这方面花了很多时间。我在谷歌开发一款名为<a class="ae ky" href="https://developers.google.com/camera" rel="noopener ugc nofollow" target="_blank">相机的产品。这是一款面向低端Android设备的Android相机应用程序。因此，我的工作包括研究和实现可以在低端移动硬件上可行运行的高质量计算摄影算法。</a></p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="5ddf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与我在微软围绕分布式系统的工作相反，这帮助我了解了超越标准方法的优化。我在另一篇文章中介绍了在这两个领域中工作的一些关键区别:</p><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/why-working-on-cloud-vs-mobile-edge-is-so-different-e32930f1c801"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">我在微软云和谷歌移动工作了3年——这是生态系统的不同之处</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">为什么云与移动(边缘)的工作如此不同？</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">better编程. pub</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><p id="0f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">超越big O的优化包括利用现代硬件设计在最少的时间内执行您的算法。这不仅仅是减少迭代次数，还包括减少将数据从主内存传送到CPU寄存器所花费的时间、利用不同类型的并行性、减少CPU空闲时间、减少可避免的分支等等。</p><p id="c36f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文将通过证据介绍一些这种优化的例子。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="fb09" class="nt nu it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">序</h1><p id="4858" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">在本文中，我将使用Halide代码示例。我在系列文章中对卤化物做了深入的<a class="ae ky" href="https://minhazav.medium.com/list/e5245103a438" rel="noopener">。</a></p><p id="23b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">TL；DR；</strong> Halide是一种特定于领域的语言，使得在现代机器上编写高性能图像和阵列处理代码变得更加容易。</p><p id="0604" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文中给出的所有数字都是使用Halide/C++编写的代码测量的，是在启用编译器优化的情况下构建的，并且是使用微基准框架测量的。</p><p id="9f2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基准测试在某个中端八核arm64 Android设备上运行。所有提到的方法都在CPU上运行。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="a8d4" class="nt nu it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">矢量化</h1><p id="e9bc" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">传统上，我们认为CPU是一个标量机器。让我们举一个生成这样的渐变图像的问题的例子</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/a3c4a1e5ddc1aca6cf01fa4df7a4dde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/0*HNE6kEji-VhzW0n2.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用matplotlib (cmap=vidris)生成的渐变图像。图片作者。</p></figure><p id="2e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它可以表示为<code class="fe mq mr ms mt b">f(x, y) = x + y</code>或者对于2D阵列来说表示为<code class="fe mq mr ms mt b">a[y][x] = x + y</code>。</p><p id="c48c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的标量思维中，我们想象它对每个像素执行一次<code class="fe mq mr ms mt b">WIDTH * HEIGHT</code>次，从而给出一个<code class="fe mq mr ms mt b">O(WIDTH * HEIGHT)</code>时间复杂度。</p><p id="6fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这在过去是正确的。早期的CPU过去只有SISD功能。SISD代表单指令单数据。</p><p id="eba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，现代CPU具有SIMD功能。SIMD代表单指令多数据。</p><p id="708a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据数据类型和CPU寄存器大小，现代CPU可以在单个执行周期内一次对一个数据向量(多个数据)执行单个指令。</p><p id="dde9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比方说，你正在做一个类似<code class="fe mq mr ms mt b">a[i] = a[i] + b[i]</code>的加法运算。现代CPU可以将它作为向量来执行，而不是按索引单独运行:</p><pre class="kj kk kl km gt or mt os ot aw ou bi"><span id="0792" class="ov nu it mt b gy ow ox l oy oz">a[i + 0] = a[i + 0] + b[i + 0];<br/>a[i + 1] = a[i + 1] + b[i + 1];<br/>a[i + 2] = a[i + 2] + b[i + 2];<br/>a[i + 3] = a[i + 3] + b[i + 3];</span></pre><p id="ccac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一气呵成。</p><p id="010d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它也不仅限于将4个数字相加—根据数据类型(例如<code class="fe mq mr ms mt b">uint8</code> = 1字节，<code class="fe mq mr ms mt b">int32</code> = 4字节)和处理器&amp;支持的指令集上的寄存器大小，单个CPU周期内可以处理的最大数据元素数量可能会有所不同。</p><p id="a6ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近你可能已经看到越来越多的DSP(数字信号处理器)出现在画面中(比如高通的Hexagon)。除此之外，它们倾向于使用非常宽寄存器来支持宽SIMD算法。这使他们能够支持更高效的数据并行操作。</p><h2 id="2edf" class="ov nu it bd nv pa pb dn nz pc pd dp od li pe pf of lm pg ph oh lq pi pj oj pk bi translated">(英)可视化(= visualization)</h2><p id="a501" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">如果事情仍然不清楚，请允许我展示一些图表。这是你的渐变标量执行看起来像一个<code class="fe mq mr ms mt b">4x4</code>图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/4da5b7ac225f99bc4a300fb5f38ad66c.png" data-original-src="https://miro.medium.com/v2/resize:fit:384/0*r5KuN-dWZdMrh6y3.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">渐变示例的执行顺序-默认。来源:<a class="ae ky" href="https://halide-lang.org/tutorials/tutorial_lesson_05_scheduling_1.html" rel="noopener ugc nofollow" target="_blank">halide-lang.org</a>，阿帕奇执照。</p></figure><p id="2323" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是SIMD的样子(T1图片)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/bc5e5a5ee1107a1464a8424a0b490984.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/0*wmFpBfoA_Jo2DfME.gif"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图:梯度示例的执行顺序——矢量化。来源:<a class="ae ky" href="https://halide-lang.org/tutorials/figures/lesson_05_vectors.gif" rel="noopener ugc nofollow" target="_blank">halide-lang.org</a>，阿帕奇执照。</p></figure><h2 id="58a1" class="ov nu it bd nv pa pb dn nz pc pd dp od li pe pf of lm pg ph oh lq pi pj oj pk bi translated">基准测试结果</h2><blockquote class="lv lw lx"><p id="88ea" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">我很清楚你们这些饥饿的人们，除非我给你们看一些数字，否则你们不会买的！</p></blockquote><p id="23f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">代码</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pn po l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">写入u8图像和两个时间表的梯度卤化物算法。第一个是没有矢量化，另一个是有矢量化。</p></figure><p id="a4e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">结果</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/412e4278c621ccd7852f6ef385681956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y8_znA10dn9J6BeS50jrCw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">以矢量化和非矢量化方式运行f(x，y) = u8((x + y) % 255)的延迟基准比较。作者图片，使用Google Sheets生成。</p></figure><p id="ba2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，矢量化代码比非矢量化代码平均速度快<code class="fe mq mr ms mt b">~3 times</code>。</p><p id="1eee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据算法和数据类型，这些数字可能会有所不同。例如，对于像<code class="fe mq mr ms mt b">f(x, y) = g(x, y) + b</code>这样的简单增亮算法，我发现在相同的环境下，对于<code class="fe mq mr ms mt b">u8</code>数据类型，矢量化代码比非矢量化代码更快<code class="fe mq mr ms mt b">~5.3 times</code>。</p><h2 id="14d4" class="ov nu it bd nv pa pb dn nz pc pd dp od li pe pf of lm pg ph oh lq pi pj oj pk bi translated">怎么用？</h2><p id="8ad9" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">有时编译器会自动对你的代码进行矢量化。这取决于使用的编译器和循环的设计方式。有时它不能，例如，如果它不能确定你的循环是数据独立的。</p><p id="988a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<code class="fe mq mr ms mt b">a[i] = a[i-1] — 1</code>这样的循环很难矢量化，因为每个索引的结果都取决于前一个索引的结果。</p><p id="8f37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在代码中使用矢量化，您可以</p><ul class=""><li id="ec90" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">让编译器自动决定您是否满意当前的性能。</li><li id="054f" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/guide-the-compiler-to-speed-up-your-code-655c1902b262">指导编译器你的循环可以矢量化</a>。</li><li id="6e2e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">通过使用适用于不同处理器家族的内部函数，对代码进行显式矢量化(例如<a class="ae ky" href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(Neon)" rel="noopener ugc nofollow" target="_blank"> ARM Neon </a></li><li id="925e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">利用像<a class="ae ky" href="https://halide-lang.org/" rel="noopener ugc nofollow" target="_blank"> Halide Language </a>这样的解决方案，轻松地跨不同平台向量化代码</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="334b" class="nt nu it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">缓存和内存局部性</h1><p id="32d6" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">你读过— <a class="ae ky" href="https://gist.github.com/jboner/2841832" rel="noopener ugc nofollow" target="_blank">每个工程师都应该知道的延迟数字吗？</a>如果没有，读一读吧！</p><p id="985a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从主内存(DRAM)向CPU寄存器加载数据可能比从L1高速缓存读取数据慢<code class="fe mq mr ms mt b">~200 times</code>。</p><p id="2ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我的云时代，主存上的任何操作都被认为是神速的，IO被认为是邪恶的。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="f18b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">快速提示:作为开发人员，在评估设备性能时，CPU时钟速度和总RAM大小并不是唯一重要的指标。人们还应该寻找设备上RAM芯片的类型。如果需要处理大数据，主存储器的读写带宽是算法在给定设备上执行速度的关键因素。查看LPDDR3与LPDDR4的区别，了解更多信息。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="e4ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再来稍微刷新一下我们大学时代上的CPU架构课。L1高速缓存是内置在微处理器中的高速缓冲存储器。它是每个CPU内核私有的。</p><p id="c2ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简单地说，CPU缓存应该保存CPU接下来最有可能需要的信息。从而用从高速缓存的超快速数据加载来代替从主存储器的相当慢的数据加载。当CPU所需的数据在缓存中找到时—这被称为<strong class="lb iu">缓存命中</strong>。</p><p id="415c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果找不到，就需要从主内存中提取数据(最坏的情况),这称为缓存未命中。此外，它通常在本质上是分等级的。如果在L1缓存中找不到数据，而设备有L2缓存，则尝试在L2缓存中查找。L3缓存(如果可用)也是如此。如果信息在任何缓存中都找不到，就从主存中取出。</p><p id="cf99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如每个工程师都应该知道的延迟数字中提到的那样，假设L1缓存查找需要<code class="fe mq mr ms mt b">~0.5ns to 1ns</code>而主内存查找需要<code class="fe mq mr ms mt b">~100ns</code>——应该很容易找出缓存未命中对算法性能的不利影响。</p><p id="1ddc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">别担心，作为开发人员，就我们所知的缓存行为而言，我们可以帮助确保我们算法的高缓存命中率。</p><h2 id="8d1b" class="ov nu it bd nv pa pb dn nz pc pd dp od li pe pf of lm pg ph oh lq pi pj oj pk bi translated">时空局部性</h2><p id="dcfc" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">缓存通常遵循两个原则来估计CPU在不久的将来需要的数据。</p><ul class=""><li id="a758" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">时间引用局部性</strong>的原理表明，正在处理的当前数据或指令可能很快就需要——因此我们应该将它们分别存储在数据或指令缓存中，以避免再次从主存储器中加载它们。</li><li id="7723" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><strong class="lb iu">空间局部性</strong>的原理表明，顺序的两条指令将引用连续的存储器位置。例如，如果数组在<code class="fe mq mr ms mt b">a[i]</code>被处理，按照这个原则<code class="fe mq mr ms mt b">a[i + 1]</code>可能很快就会被使用。</li></ul><blockquote class="lv lw lx"><p id="73d5" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">你能告诉我们为什么现在应该把大图片存储为数组而不是链表吗？</p></blockquote><p id="1cec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在实践中看到这一点的一个简单方法是尝试不同的循环顺序。在C++中，数组以行优先的方式存储。因此，为了利用引用的空间局部性，您应该理想地以行主格式编写循环。</p><pre class="kj kk kl km gt or mt os ot aw ou bi"><span id="7bbf" class="ov nu it mt b gy ow ox l oy oz"># Loop 1<br/>for (int y = 0; y &lt; height; ++y) {<br/>  for (int x = 0; x &lt; width; ++x) {<br/>    output(x, y) = input(x, y) + b;<br/>  }<br/>}</span><span id="52bc" class="ov nu it mt b gy pq ox l oy oz"># Loop 2<br/>for (int x= 0; x &lt; width; ++x) {<br/>  for (int y= 0; y &lt; height; ++y) {<br/>    output(x, y) = input(x, y) + b;<br/>  }<br/>}</span></pre><p id="a297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对环路1和环路2之间的性能差异有什么猜测吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/1bbe4db940297c44dd322c5a37d401df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6f97r9fFtgeqX6f1QREMPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">行主与列主方式运行f(x，y) = g(x，y) + b的延迟基准比较。作者图片，使用Google Sheets生成。</p></figure><p id="6827" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个设备上，行主循环比列主循环更快，这就是高速缓存未命中的代价。</p><blockquote class="ps"><p id="5562" class="pt pu it bd pv pw px py pz qa qb lu dk translated">设计利用缓存行为的算法可以显著提高算法的性能。</p></blockquote></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="b1f2" class="nt nu it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">CPU级并行性</h1><p id="5708" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">这是一个更广为人知的领域。</p><p id="3630" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们都知道现代SoC(片上系统)有不止一个通用CPU内核可用于处理。因此，我们可以利用多个可用的内核，在不同的内核中运行部分算法，而不是在单个内核上运行我们的算法。</p><p id="3482" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法的有效性取决于算法的数据独立性。最好的情况是数据的不同部分可以同时独立处理。这适用于输入和输出数据。</p><p id="b11a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果算法对数据的依赖性较低，那么利用多线程线程池中的多线程应该有助于提高性能。</p><p id="36c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于一个简单的亮度程序<code class="fe mq mr ms mt b">f(x, y) = g(x, y) + b</code>，在<code class="fe mq mr ms mt b">y-axis</code>上并行的循环大致给出了<code class="fe mq mr ms mt b">~2.5 times</code>的加速。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/59f39f9e660b3a6c57bad8ce06c11291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PO32DFV2E_xA_rsncRVepQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行f(x，y) = g(x，y) + b .图片由作者提供，使用Google Sheets生成。</p></figure><p id="bdfd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于八核设备，我们为什么没有通过多线程获得8倍的性能，这是另一个时间的讨论！</p><p id="a3eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">结果是为线程池大小为8的非矢量化代码生成的。启用了并行性的多核设备上的算法性能还取决于线程池的大小。对于这个算法，我观察到线程池大小与延迟基准的关系如下。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/8e5a34818fe9c0179380dd28bdc2bd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZHa7nYrbalSH0cZOTojaA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在不同大小的线程池上运行f(x，y) = f(x，y) + b的延迟基准比较。作者图片，使用Google Sheets生成。</p></figure><p id="4e34" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">线程数= 16时找到了最佳点。</p><h2 id="2497" class="ov nu it bd nv pa pb dn nz pc pd dp od li pe pf of lm pg ph oh lq pi pj oj pk bi translated">怎么用？</h2><p id="4277" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">算法并行化通常可以跨编程语言和框架使用。您通常可以轻松地创建线程池，并在其上调度您的任务。根据线程池的大小和空闲线程的数量，一个新任务会被直接执行或者等待一个线程释放。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="e374" class="nt nu it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">减少指令</h1><p id="8aef" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">在你给我一张扑克脸之前，先看看例子！</p><p id="9c8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我知道这没什么新鲜的！大O的整个游戏也是关于这个本身。但是这里我说的是减少指令以获得更真实的性能提升，而不是<code class="fe mq mr ms mt b">O(N) vs O(logN)</code>之间的疯狂差异。</p><blockquote class="lv lw lx"><p id="63f9" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">对于高达13，000，000像素的图像，任何使用<code class="fe mq mr ms mt b">O(N^2)</code>的算法都是不可行的！</p></blockquote><h2 id="bda4" class="ov nu it bd nv pa pb dn nz pc pd dp od li pe pf of lm pg ph oh lq pi pj oj pk bi translated">循环展开</h2><p id="3460" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">循环展开是一种循环优化技术，用于通过减少循环周围的条件来改善程序的执行时间。让我们以一个三维图像(如RBG)为例，说我们想通过固定值来增亮图像。</p><pre class="kj kk kl km gt or mt os ot aw ou bi"><span id="1d53" class="ov nu it mt b gy ow ox l oy oz">f(x, y, c) = g(x, y, c) + b</span></pre><p id="97d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个问题，没有和有最后维度(通道)的循环展开的循环看起来像这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pn po l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">无循环展开(顶部)和有循环展开(底部)</p></figure><p id="109b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一种情况下，对于一个大图像(像1300万像素的1300万图像)，最里面的循环需要初始化变量<code class="fe mq mr ms mt b">c</code>，进行比较并增加1300万次。对于这个问题，我看到了下面的基准测试结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pr"><img src="../Images/e6dcca9189a4f8ed31656fdb07f8f9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldugmNb1P57lzdZyVE2DHg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">f(x，y，c) = g(x，y，c) + b示例中有无循环展开的运行时延迟比较。作者使用Google sheets的图片。</p></figure><p id="e02d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，循环展开的速度平均比<code class="fe mq mr ms mt b">~1.4 times</code>快。</p><p id="3b40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">这个怎么用？</strong></p><ul class=""><li id="2db5" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">优秀的编译器通常会自己进行这种优化。</li><li id="9c45" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">如果不能，你也可以<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/guide-the-compiler-to-speed-up-your-code-655c1902b262">指导编译器你的循环可以展开</a>。</li><li id="9a15" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">如果有助于提高性能，请显式展开循环。</li><li id="3ebc" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">使用<a class="ae ky" href="https://halide-lang.org/" rel="noopener ugc nofollow" target="_blank">卤化物语言</a>中的原语展开循环尺寸。</li></ul><h2 id="6b3e" class="ov nu it bd nv pa pb dn nz pc pd dp od li pe pf of lm pg ph oh lq pi pj oj pk bi translated">杂项示例</h2><p id="2d05" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">过去类似的提示还多着呢。使用现代编译器，开发人员通常不需要显式地这样做。一些例子包括</p><p id="d5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">除法vs乘法</strong></p><blockquote class="ps"><p id="b29d" class="pt pu it bd pv pw px py pz qa qb lu dk translated">浮点乘法比浮点除法需要更少的周期。</p></blockquote><p id="4f03" class="pw-post-body-paragraph kz la it lb b lc qc ju le lf qd jx lh li qe lk ll lm qf lo lp lq qg ls lt lu im bi translated">如果可能的话，现在大部分由编译器处理，但是如果不能，你可以尝试用乘法代替除法运算，看看是否有性能提升。当除法在可以用乘法代替的大范围内进行时，差异是真实的。</p><p id="035a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">减少分支</strong></p><blockquote class="lv lw lx"><p id="ae6e" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">这个主题需要很多预先解释，最好是另一篇文章的主题，让我知道你是否感兴趣！</p></blockquote><p id="6f5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">CPU执行任何指令都需要做一系列的准备工作。它包括— <code class="fe mq mr ms mt b">fetching</code>、<code class="fe mq mr ms mt b">decoding</code>、<code class="fe mq mr ms mt b">executing</code>和<code class="fe mq mr ms mt b">writing</code>。为了提高吞吐量，CPU流水线这些阶段。这样他们就可以在限定的时间内执行更多的指令。</p><p id="57e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在条件跳转的情况下</p><pre class="kj kk kl km gt or mt os ot aw ou bi"><span id="6746" class="ov nu it mt b gy ow ox l oy oz">if (some condition) {<br/>   // set of instructions<br/>} else {<br/>   // other conditions<br/>}</span></pre><p id="35d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于CPU来说，流水线指令变得很困难，因为可能有不止一组可能的指令要执行。现代CPU使用分支预测——它用一些试探法预测逻辑的结果，然后开始流水线化它们。如果预测确实是正确的，则稍后使用结果(节省了一点时间:)，否则丢弃结果并执行另一组指令。</p><p id="4c0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，分支预测失误是有代价的，作为一名程序员，如果你能用一些更简单的算法替换这些条件，有时可以提高性能(试一试:)</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="0c3b" class="nt nu it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">读者结束语</h1><p id="1eab" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">大多数开发人员希望编写优化的算法。对于不同的用例，所需的优化量是不同的，我们应该根据成本效益权衡来优先考虑我们的时间和工作。</p><blockquote class="ps"><p id="b93f" class="pt pu it bd pv pw px py pz qa qb lu dk translated">我喜欢我的代码运行缓慢——从来没有人说过！</p></blockquote><p id="b58a" class="pw-post-body-paragraph kz la it lb b lc qc ju le lf qd jx lh li qe lk ll lm qf lo lp lq qg ls lt lu im bi translated">如果您发现您的算法比要求的要慢，请遵循</p><ul class=""><li id="ada8" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">基准—对您的代码进行基准测试。没有这个就不要开始！</li><li id="ff08" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">分解——将基准分解成更小的组件，以隔离代码的高成本部分。剖析在这里真的很有帮助！</li><li id="5dce" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">优化——优化将导致有意义的增长的代码部分，从低挂的果实开始！</li></ul></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt or mt os ot aw ou bi"><span id="d64b" class="ov nu it mt b gy ow ox l oy oz"><strong class="mt iu">Want to Connect?</strong></span><span id="5008" class="ov nu it mt b gy pq ox l oy oz">Find me on <a class="ae ky" href="https://twitter.com/minhazav" rel="noopener ugc nofollow" target="_blank">Twitter</a> or <a class="ae ky" href="https://www.linkedin.com/in/minhazav/?originalSubdomain=sg" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>!</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="103c" class="nt nu it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">参考</h1><ul class=""><li id="c8d2" class="mc md it lb b lc ol lf om li qh lm qi lq qj lu mh mi mj mk bi translated"><a class="ae ky" href="https://minhazav.medium.com/list/e5245103a438" rel="noopener">卤化物系列文章</a></li><li id="9ea8" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" href="https://en.algorithmica.org/hpc/pipelining/" rel="noopener ugc nofollow" target="_blank">指令级并行</a></li></ul><p id="6645" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你觉得这很有趣，你可以阅读更多过去的相关文章:</p><ul class=""><li id="c5de" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/guide-the-compiler-to-speed-up-your-code-655c1902b262">如何引导编译器加速你的代码</a></li><li id="bc29" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/write-fast-and-maintainable-code-with-halide-part-1-6a5c3a519250">用Halide编写快速可维护的代码</a></li></ul></div></div>    
</body>
</html>