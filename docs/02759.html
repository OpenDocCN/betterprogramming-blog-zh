<html>
<head>
<title>Be the Master of the Event Loop in JavaScript (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">成为JavaScript中事件循环的主人(第2部分)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/be-the-master-of-the-event-loop-in-javascript-part-2-54637d49889f?source=collection_archive---------2-----------------------#2019-12-26">https://betterprogramming.pub/be-the-master-of-the-event-loop-in-javascript-part-2-54637d49889f?source=collection_archive---------2-----------------------#2019-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e05f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">事件冒泡、捕获和委托</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/976f983e925250a20c586b67ad5c1952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8mqbpNexvve-Oi1K"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">乔恩·弗洛布兰特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="19a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我之前的文章中，我谈到了JavaScript事件循环的基本概念、队列以及JavaScript引擎如何执行任务。如果你没有看过我之前的帖子，我建议你先看看，因为这是事件循环系列的第二部分。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/be-the-master-of-event-loop-in-javascript-1-6804cdf6608f" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">成为JavaScript中事件循环的主人(第1部分)</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">两个工人在餐馆工作。经理，左边的人，安排等候的队伍，让顾客…</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="0e4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">和上一篇文章一样，我将以一个小测验开始这篇文章。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7374" class="ms mt it mo b gy mu mv l mw mx">&lt;body&gt;<br/>  &lt;div id="myDiv"&gt;<br/>    &lt;button id="myBtn"&gt;Click me&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;</span></pre><p id="a094" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们有这样的DOM元素。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="6d46" class="ms mt it mo b gy mu mv l mw mx">const div = document.getElementById('myDiv');<br/>const btn = document.getElementById('myBtn');</span><span id="68cf" class="ms mt it mo b gy my mv l mw mx">const t = () =&gt; {<br/>  setTimeout(() =&gt; console.log('setTimeout in 10ms'), 10);<br/>  requestAnimationFrame(() =&gt; console.log('rAF'));<br/>  Promise.resolve().then(() =&gt; console.log('Promise'));<br/>}</span><span id="f37b" class="ms mt it mo b gy my mv l mw mx">div.addEventListener('click', () =&gt; { console.log(1); t(); });<br/>btn.addEventListener('click', () =&gt; { console.log(2); t(); });</span></pre><p id="29c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，猜猜答案。</p><p id="ae96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你不知道明确的答案，或者如果你觉得它相当令人困惑或棘手，足以让你头痛，你就在正确的位置上，以便更好地理解事件循环！</p><p id="1d69" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本帖中，我们将讨论:</p><ol class=""><li id="f463" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">DOM事件</li><li id="2ca2" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">事件冒泡和捕获</li><li id="83d1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">事件委托</li><li id="1fa1" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">事件传播</li><li id="a888" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">测验答案</li></ol></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="1ac0" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">DOM事件</h1><p id="caad" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">假设在<code class="fe oq or os mo b">body</code>标签中有一个元素。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5a6b" class="ms mt it mo b gy mu mv l mw mx">&lt;div id="myDiv"&gt;Hello&lt;/div&gt;</span></pre><p id="ef8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个DOM元素都可以有事件回调，比如单击或双击。<code class="fe oq or os mo b">#myDiv</code>元素没有任何连接到事件模块的回调。即使没有任何东西连接到它的click事件，一旦被点击，<code class="fe oq or os mo b">DOM</code>模块仍然会查看回调队列。</p><p id="5327" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有三种方法可以将回调函数作为事件回调添加到DOM元素中。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c602" class="ms mt it mo b gy mu mv l mw mx">&lt;div onclick="console.log('div')"&gt;Hello&lt;/div&gt;</span></pre><p id="398b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个内联事件回调。您可以将回调函数直接连接到DOM。与其他方法相比，此方法具有更高的执行优先级。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b626" class="ms mt it mo b gy mu mv l mw mx">div.onclick = () =&gt; console.log('div');</span></pre><p id="2f87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二种方法是将回调函数直接绑定到DOM的<code class="fe oq or os mo b">onclick</code>方法。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="61fb" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', () =&gt; console.log('div'));</span></pre><p id="d0d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后一种方法是使用DOM API，<code class="fe oq or os mo b">addEventListener</code>。它有两个参数——事件的名称，以及事件触发后的回调函数。有很多不同的事件(你可以在这里查看<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Events" rel="noopener ugc nofollow" target="_blank">)。确保写出事件类型的正确名称，因为它是区分大小写的字符串。</a></p><p id="0653" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于以下原因，这可能是绑定事件回调函数的最典型方式:</p><ol class=""><li id="4774" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><code class="fe oq or os mo b">addEventListener</code>有一个对应的功能——是<code class="fe oq or os mo b">removeEventListener</code>。</li></ol><p id="8c53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以将声明的函数传递给<code class="fe oq or os mo b">addEventListener</code>而不是匿名函数。一旦程序变得更大更复杂，你可能想要更微妙地控制你的事件。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="449d" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', callbackOne);<br/>div.addEventListener('click', callbackTwo);</span><span id="f94c" class="ms mt it mo b gy my mv l mw mx">-- Later --</span><span id="8482" class="ms mt it mo b gy my mv l mw mx">div.removeEventListener(callbackOne);</span></pre><p id="1661" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oq or os mo b">div</code>注销<code class="fe oq or os mo b">callbackOne</code>后，最终只有一次回调。</p><p id="5ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.与将回调函数绑定到DOM的方法不同，比如<code class="fe oq or os mo b">onclick</code>，您可以将多个回调函数注册到<code class="fe oq or os mo b">addEventListener</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7da2" class="ms mt it mo b gy mu mv l mw mx">// All of these callback functions<br/>// are executed in first-register-first-execute order<br/>// once the button is clicked<br/>div.addEventListener('click', () =&gt; console.log(1));<br/>div.addEventListener('click', () =&gt; console.log(2));<br/>div.addEventListener('click', () =&gt; console.log(3));</span></pre><p id="a7bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.只有<code class="fe oq or os mo b">addEventListener</code>支持事件冒泡和捕捉。我们稍后会更深入地讨论这些。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="cfae" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">事件冒泡和捕获</h1><p id="eb8a" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">在W3C(万维网联盟)文档中，事件冒泡描述如下:</p><blockquote class="ot ou ov"><p id="4003" class="kz la ow lb b lc ld ju le lf lg jx lh ox lj lk ll oy ln lo lp oz lr ls lt lu im bi translated">在被<a class="ae ky" href="https://www.w3.org/TR/uievents/#event-target" rel="noopener ugc nofollow" target="_blank">事件目标</a>处理之后，<a class="ae ky" href="https://www.w3.org/TR/uievents/#event" rel="noopener ugc nofollow" target="_blank">事件</a>可以被目标的一个祖先<em class="it">处理的过程。更多细节参见事件流中<a class="ae ky" href="https://www.w3.org/TR/uievents/#bubble-phase" rel="noopener ugc nofollow" target="_blank">气泡阶段</a>的描述。</em></p></blockquote><p id="7320" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像这个概念的名字一样，<em class="ow">冒泡</em>，你可以想象一个小水泡一直升到表面。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pa"><img src="../Images/a57991b5911c04cd9cfa3225aa39cac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hYJ7TVhmsOokm74Z"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">paweczerwi ski</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2d62" class="ms mt it mo b gy mu mv l mw mx">&lt;div onclick="console.log('div')"&gt;<br/>  &lt;p onclick="console.log('p')"&gt;<br/>    &lt;span onclick="console.log('span')"&gt;<br/>    &lt;/span&gt;<br/>  &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="fe8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦点击了span标签，就执行事件回调<code class="fe oq or os mo b">console.log('span')</code>。然后，JavaScript查找它的祖先。在这种情况下，p标记是span的父元素，因此执行其回调函数<code class="fe oq or os mo b">console.log('p')</code>。然后执行其父级的回调函数。因此，调用回调函数的顺序是:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="209c" class="ms mt it mo b gy mu mv l mw mx">span → p → div</span></pre><p id="0272" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，事件捕获的工作方式不同。JavaScript“捕获”最顶层的事件，并一直向下到达子元素，查看是否有回调。</p><p id="217b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要让JavaScript event捕获事件，应该使用<code class="fe oq or os mo b">addEventListener</code>。有两种方法可以将回调函数设置为捕获函数:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="f684" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', () =&gt; console.log('div'), true);<br/>div.addEventListener('click', () =&gt; console.log('div'), { capture: true });</span></pre><p id="cd26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两种方式都可以。但是如果你传递一个对象给<code class="fe oq or os mo b">addEventListener</code>，你可以设置更多的选项——在这里查看它们<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="708e" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', () =&gt; console.log('div'), true);<br/>p.addEventListener('click', () =&gt; console.log('p'), true);<br/>span.addEventListener('click', () =&gt; console.log('span'), true);</span></pre><p id="45d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<code class="fe oq or os mo b">span</code>后，打印顺序如下。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="1163" class="ms mt it mo b gy mu mv l mw mx">div → p → span</span></pre><ul class=""><li id="9a3f" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu pb nf ng nh bi translated">冒泡:最里面的元素→第二个最里面的元素→ … →最外面的元素</li><li id="733d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pb nf ng nh bi translated">捕获:最外面的元素→第二个最外面的元素→ … →最里面的元素</li></ul><p id="3b6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">猜猜这个点击事件的结果。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d705" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', () =&gt; console.log('div'));<br/>p.addEventListener('click', () =&gt; console.log('p'), { capture: true });<br/>span.addEventListener('click', () =&gt; console.log('span'));</span></pre><p id="eb20" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oq or os mo b">div</code>和<code class="fe oq or os mo b">span</code>使用冒泡，<code class="fe oq or os mo b">p</code>使用捕捉。所有这些元素都在同一个层次结构中。那时会发生什么？答案是:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="73a0" class="ms mt it mo b gy mu mv l mw mx">p → span → div</span></pre><p id="ed49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么？因为捕获比冒泡更早触发。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/d6654b65f0313c3ce245969400556dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onegobhmdOuULb5qoUsLkA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源于<a class="ae ky" href="https://www.w3.org/TR/uievents/#bubble-phase" rel="noopener ugc nofollow" target="_blank"> W3C </a></p></figure><p id="547a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，JavaScript从最顶层的元素开始触发事件，一直到事件被触发的元素(<code class="fe oq or os mo b">Target Phase(2)</code>)，然后再到最外层的元素。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="5e31" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">事件委托</h1><p id="66ac" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">这更关乎表演。假设有一百个列表元素。无论你点击哪个，你都想知道它的ID。你怎么能这样做？</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fb2c" class="ms mt it mo b gy mu mv l mw mx">const ul = document.getElementById('myUL');</span><span id="ad03" class="ms mt it mo b gy my mv l mw mx">for (let i = 0; i &lt; 100; i += 1) {<br/>  const li = document.createElement('li');<br/>  li.textContent = `li-${i}`;<br/>  li.id = `li-${i}`;<br/>  li.addEventListener('click', e =&gt; console.log(e.target.id));<br/>  ul.appendChild(li);<br/>}</span></pre><p id="d235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，事件<code class="fe oq or os mo b">click</code>已经被注册了一百次，到每个<code class="fe oq or os mo b">li</code>。但是如果你必须制造一千个元素呢？就性能而言，向每个元素注册相同的事件回调并不是最佳实践。</p><p id="3c8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以通过事件冒泡来解决这个问题。一旦点击了任何一个<code class="fe oq or os mo b">li</code>，JavaScript就会在<code class="fe oq or os mo b">li</code>的回调列表中寻找回调函数，然后转到外层元素，再次寻找回调函数。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="362a" class="ms mt it mo b gy mu mv l mw mx">li → ul</span></pre><p id="904d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后就可以注册回调函数到<code class="fe oq or os mo b">ul</code>标签了。即使<code class="fe oq or os mo b">li</code>没有任何事件回调函数，冒泡终究会到达<code class="fe oq or os mo b">ul</code>标签。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="04a7" class="ms mt it mo b gy mu mv l mw mx">const ul = document.getElementById('myUL');</span><span id="4c23" class="ms mt it mo b gy my mv l mw mx">for (let i = 0; i &lt; 100; i += 1) {<br/>  const li = document.createElement('li');<br/>  li.textContent = `li-${i}`;<br/>  li.id = `li-${i}`;<br/>  ul.appendChild(li);<br/>}</span><span id="67f6" class="ms mt it mo b gy my mv l mw mx"><strong class="mo iu">ul.addEventListener('click', e =&gt; console.log(e.target.id));</strong></span></pre><p id="2f16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在只有一个事件回调函数。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="4abc" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">事件传播</h1><p id="3a4b" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">上面，我解释了冒泡发生在捕获之后。但是，如果您不想触发冒泡或捕获，该怎么办呢？</p><p id="278e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个事件回调函数都有一个参数——事件对象。它有几个有用的方法。用于停止将事件传播到其他元素的是<code class="fe oq or os mo b">stopPropagation</code>。它停止冒泡和捕捉。让我们看一个例子。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="5da0" class="ms mt it mo b gy mu mv l mw mx">&lt;div&gt;<br/>  &lt;p&gt;<br/>    &lt;span&gt;Click me&lt;/span&gt;<br/>  &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/3d87183c6e89c2929d3a4bcc490022ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*6zv_DYfp_EpYPgDtfyX3qw.png"/></div></figure><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d451" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', () =&gt; console.log('div'));<br/>p.addEventListener('click', () =&gt; console.log('p'));<br/>span.addEventListener('click', () =&gt; console.log('span'));</span></pre><p id="d7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你点击<code class="fe oq or os mo b">p</code>，那么结果将会是<code class="fe oq or os mo b">p → div</code>冒泡。但是如果用<code class="fe oq or os mo b">stopPropagation</code>，结果就不一样了。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2233" class="ms mt it mo b gy mu mv l mw mx">p.addEventListener('click', e =&gt; {<br/>  e.stopPropagation();<br/>  console.log('p');<br/>})</span></pre><p id="c380" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果再次点击<code class="fe oq or os mo b">p</code>标签，结果将只是<code class="fe oq or os mo b">p</code>，因为<code class="fe oq or os mo b">stopPropagation</code>已经“停止”了正在冒泡的事件。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="be7b" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', () =&gt; console.log('div'), true);<br/>p.addEventListener('click', e =&gt; {<br/>  e.stopPropagation();<br/>  console.log('p');<br/>});<br/>span.addEventListener('click', () =&gt; console.log('span'), true);</span></pre><p id="7027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，冒泡和捕获混在一起了。点击<code class="fe oq or os mo b">span</code>标签。结果会是<code class="fe oq or os mo b">div → span → p</code>。记住，捕捉是第一位的。所以，<code class="fe oq or os mo b">div</code>是<code class="fe oq or os mo b">span</code>的祖先元素，首先执行它的回调。<code class="fe oq or os mo b">p</code>有回调函数，但不是用来抓图的。然后执行<code class="fe oq or os mo b">span</code>的回调函数作为最后的捕获步骤。现在冒泡被触发。<code class="fe oq or os mo b">span</code>没有为冒泡注册任何回调函数，所以什么都不会发生。另一方面，<code class="fe oq or os mo b">p</code>有一个用于冒泡的回调函数，它被执行。还有，<code class="fe oq or os mo b">div</code>的回调函数都不是用来冒泡的，所以什么都不会打印出来。</p><p id="a77f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oq or os mo b">addEventListener</code>可以添加多个回调函数。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2317" class="ms mt it mo b gy mu mv l mw mx">div.addEventListener('click', () =&gt; console.log('div'), true);<br/>p.addEventListener('click', () =&gt; console.log('p - capturing'), true);<br/>p.addEventListener('click', e =&gt; {<br/>  e.stopPropagation();<br/>  console.log('p - bubbling');<br/>});<br/>span.addEventListener('click', () =&gt; console.log('span'), true);</span></pre><p id="7842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果点击<code class="fe oq or os mo b">span</code>，打印顺序将为<code class="fe oq or os mo b">div → p-capturing → span → p-bubbling</code>。</p><p id="d8a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，不是每个事件都可以被冒泡。比如<code class="fe oq or os mo b">focus</code>和<code class="fe oq or os mo b">blur</code>事件不支持冒泡。因此，您应该提前检查要使用的事件是否支持冒泡。可以查看<a class="ae ky" href="https://www.w3.org/TR/uievents/#blur" rel="noopener ugc nofollow" target="_blank"> W3C文档</a>或者<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Events#Focus_events" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>。</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="1166" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">测验答案</h1><p id="25d0" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">现在，你可以猜出我在本文开头给你的这个测验的正确答案了:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3eb3" class="ms mt it mo b gy mu mv l mw mx">const div = document.getElementById('myDiv');<br/>const btn = document.getElementById('myBtn');</span><span id="2e99" class="ms mt it mo b gy my mv l mw mx">const t = () =&gt; {<br/>  setTimeout(() =&gt; console.log('setTimeout in 10ms'), 10);<br/>  requestAnimationFrame(() =&gt; console.log('rAF'));<br/>  Promise.resolve().then(() =&gt; console.log('Promise'));<br/>}</span><span id="e682" class="ms mt it mo b gy my mv l mw mx">div.addEventListener('click', () =&gt; { console.log(1); t(); });<br/>btn.addEventListener('click', () =&gt; { console.log(2); t(); });</span></pre><p id="c5b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe oq or os mo b">div</code>和<code class="fe oq or os mo b">btn</code>没有捕捉的回调函数。所以现在你知道一旦<code class="fe oq or os mo b">btn</code>被点击，事件的顺序将会是<code class="fe oq or os mo b">btn → div</code>。<code class="fe oq or os mo b">2</code>显然会先打印出来。并且在函数中有三个不同的任务，<code class="fe oq or os mo b">t</code>。</p><p id="1417" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我在上一篇文章中解释的那样，<em class="ow"> Promise </em>是一个微任务。只有当任务队列完全为空时，才执行微任务。在<code class="fe oq or os mo b">console.log(2)</code>被执行后，任务队列中什么都没有，所以<code class="fe oq or os mo b">console.log('Promise')</code>现在被执行。然而<em class="ow"> setTimeout </em>和<em class="ow"> rAF </em>都是宏任务。它们可以在所有任务和微任务被完全执行之后被执行。</p><p id="5054" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后事件冒泡到<code class="fe oq or os mo b">div</code>。并且<code class="fe oq or os mo b">console.log(1)</code>被执行。然后<em class="ow">承诺</em>以与<code class="fe oq or os mo b">btn</code>相同的理由执行。那么到目前为止，顺序是<code class="fe oq or os mo b">2 → Promise → 1 → Promise</code>。并且所有的任务和微任务出列。<em class="ow"> rAF </em>首先出列，因为它总是在渲染之前，不像<em class="ow"> setTimeout </em>。所以最后的答案如下。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="be2b" class="ms mt it mo b gy mu mv l mw mx">2 → Promise → 1 → Promise → rAF → rAF → setTimeout → setTimeout</span></pre><p id="b3db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果用JavaScript <code class="fe oq or os mo b">click</code>方法点击<code class="fe oq or os mo b">btn</code>，结果会有所不同。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="3b65" class="ms mt it mo b gy mu mv l mw mx">btn.click()</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/1bc9e908d779d4053cca7b8d1d11bb40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcZnDK5RJ2nIJDSVdXZe8g.png"/></div></div></figure><p id="6677" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左边的调用栈是你在浏览器上点击<code class="fe oq or os mo b">btn</code>的时候，右边的调用栈是你用JavaScript点击<code class="fe oq or os mo b">btn</code>的时候。由于JavaScript点击了按钮，<code class="fe oq or os mo b">script</code>在任务队列中。然后，影响结果。微任务只能在任务队列完全为空的情况下执行，但是因为<code class="fe oq or os mo b">script</code>，任务队列不会为空，直到每个任务都被首先执行。因此，单击JavaScript，结果将如下所示:</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b4ff" class="ms mt it mo b gy mu mv l mw mx">2 → 1 → Promise → Promise → rAF → rAF → setTimeout → setTimeout</span></pre></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="23ee" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">结论</h1><p id="c19a" class="pw-post-body-paragraph kz la it lb b lc ol ju le lf om jx lh li on lk ll lm oo lo lp lq op ls lt lu im bi translated">JavaScript事件非常神秘和有趣。但是一旦你理解了JavaScript事件是如何工作的，你就可以减少错误并摆脱恐惧。</p><p id="206f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有趣的一点是，DOM元素的事件因事件发生方式的不同而不同。当你用鼠标点击按钮时，JavaScript不会将“脚本”任务推入任务队列，然而，当你用JavaScript代码点击按钮时，它会，比如<code class="fe oq or os mo b">btn.click()</code>。我希望你对这个神秘的问题做你自己的实验！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="f9fd" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">本系列的更多内容</h1><ul class=""><li id="8a31" class="mz na it lb b lc ol lf om li pf lm pg lq ph lu pb nf ng nh bi translated"><a class="ae ky" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-1-6804cdf6608f" rel="noopener">阅读成为JavaScript中事件循环的主人(第1部分)</a></li><li id="175d" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pb nf ng nh bi translated"><a class="ae ky" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-3-df51ab655c94" rel="noopener">阅读成为JavaScript中事件循环的主人(第3部分)</a></li></ul></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="b791" class="nu mt it bd nv nw nx ny nz oa ob oc od jz oe ka of kc og kd oh kf oi kg oj ok bi translated">资源</h1><ul class=""><li id="6e23" class="mz na it lb b lc ol lf om li pf lm pg lq ph lu pb nf ng nh bi translated"><a class="ae ky" href="https://www.w3.org/TR/uievents/#bubble-phase" rel="noopener ugc nofollow" target="_blank">事件冒泡— W3C </a></li><li id="7907" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pb nf ng nh bi translated"><a class="ae ky" href="https://javascript.info/bubbling-and-capturing" rel="noopener ugc nofollow" target="_blank">事件冒泡和捕获— JavaScript.info </a></li><li id="6d93" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pb nf ng nh bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/Events" rel="noopener ugc nofollow" target="_blank">事件参考— MDN </a></li><li id="e732" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pb nf ng nh bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events" rel="noopener ugc nofollow" target="_blank">事件介绍— MDN </a></li><li id="9b88" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu pb nf ng nh bi translated"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" rel="noopener ugc nofollow" target="_blank"> addEventListener — MDN </a></li></ul></div></div>    
</body>
</html>