<html>
<head>
<title>Learn Solidity: Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习可靠性:功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/learn-solidity-functions-ddd8ea24c00d?source=collection_archive---------0-----------------------#2020-11-26">https://betterprogramming.pub/learn-solidity-functions-ddd8ea24c00d?source=collection_archive---------0-----------------------#2020-11-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bf5c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在Solidity中使用函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/63271b744e33d00130cddc3f539fd54a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0lEgRP5R-ahe3I6aH_uvQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@kellysikkema?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="bdcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">欢迎学习Solidity系列的另一篇文章，在之前的文章<a class="ae kv" href="https://medium.com/better-programming/learn-solidity-variables-part-3-3b02ca71cf06" rel="noopener">中，我们以变量结束，今天我将向您介绍函数和修饰符，这将在本文结束时为您提供构建多签名钱包的所有部分，我们将在练习部分看到。</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="caa8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Solidity中的函数具有以下形式:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0798" class="me mf iq ma b gy mg mh l mi mj">function function_name(&lt;param_type&gt; &lt;param_name&gt;) &lt;visibility&gt; &lt;state mutability&gt; [returns(&lt;return_type&gt;)]{ ... }</span></pre><p id="0f63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们可以写在契约之外(自由函数)，也可以写在契约之内。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0641" class="mk mf iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">返回变量</h1><p id="2fd7" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">函数可以返回任意数量的值作为输出。从函数返回变量有两种方法:</p><p id="f743" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 1。使用返回变量的名称:</strong></p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="e1ec" class="me mf iq ma b gy mg mh l mi mj">function arithmetic(uint _a, uint _b) public pure<br/>        returns (uint o_sum, uint o_product)<br/>    {<br/>        o_sum = _a + _b;<br/>        o_product = _a * _b;<br/>    }</span></pre><p id="e708" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> 2。直接用return语句提供返回值:</strong></p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="2cba" class="me mf iq ma b gy mg mh l mi mj">function arithmetic(uint _a, uint _b) public pure<br/>        returns (uint o_sum, uint o_product)<br/>    {<br/>        return (_a + _b, _a * _b);<br/>    }</span></pre><p id="0bc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于第二种方法，您可以省略返回变量的名称，只指定它们的类型。</p><h2 id="460c" class="me mf iq bd ml ng nh dn mp ni nj dp mt lf nk nl mv lj nm nn mx ln no np mz nq bi translated">支持的参数和返回类型</h2><p id="d2ba" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">为了调用智能合约函数，我们需要使用ABI(应用程序二进制接口)规范，以便指定要调用的函数并对参数进行编码，这些参数将包含在事务的数据字段中，并将其发送到以太网来执行。<br/> ABI编码也用于事件和返回类型，更多细节可以在<a class="ae kv" href="https://docs.soliditylang.org/en/v0.7.5/abi-spec.html#contract-abi-specification" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="79d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ABI编码器的第一个版本并不支持我们在以前的文章中看到的所有类型，例如，我们不能从函数中返回结构，如果你试图这样做，你会得到一个错误，这就是为什么我们需要使用ABI编码器的版本2，以便通过在文件中包含以下行来使错误消失:<code class="fe nr ns nt ma b">pragma abicoder v2;</code>如果你使用的是Solidity版本:0.7.5。对于0.7.5以下的版本，我们需要使用实验版:<code class="fe nr ns nt ma b">pragma experimental ABIEncoderV2;</code></p><p id="c29e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是版本0.7.5的Solidity文档中的一个例子。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="59df" class="me mf iq ma b gy mg mh l mi mj">// SPDX-License-Identifier: GPL-3.0<br/>pragma solidity &gt;0.7.4;<br/>pragma abicoder v2;<br/><br/>contract Test {<br/>    struct S { uint a; uint[] b; T[] c; }<br/>    struct T { uint x; uint y; }<br/>    function f(S memory, T memory, uint) public pure {}<br/>    function g() public pure returns (S memory, T memory, uint) {}<br/>}</span></pre><p id="82b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">支持的ABI类型的完整列表可在本部分文档中找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9efe" class="mk mf iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">能见度</h1><p id="d256" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">函数有四种可见性:</p><ul class=""><li id="3dc8" class="nu nv iq ky b kz la lc ld lf nw lj nx ln ny lr nz oa ob oc bi translated"><strong class="ky ir"> Private </strong>:限制性最强的一个，这个函数只能从定义它的智能合约中调用。</li><li id="6538" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir">内部</strong>:该函数可以从定义它的智能合约以及从它继承的所有智能合约中调用。</li><li id="b023" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir">外部</strong>:只能从智能合约外部调用。(如果要从智能合约中调用它，必须使用它。)</li><li id="4e90" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir"> Public </strong>:可以从任何地方调用。(最宽容的一个)</li></ul></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5400" class="mk mf iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">状态可变性</h1><ul class=""><li id="6a02" class="nu nv iq ky b kz nb lc nc lf oi lj oj ln ok lr nz oa ob oc bi translated"><strong class="ky ir">视图</strong>:用<code class="fe nr ns nt ma b">view</code>声明的函数只能读取状态，不能修改状态。</li><li id="e9f8" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir">纯</strong>:用<code class="fe nr ns nt ma b">pure</code>声明的函数既不能读取也不能修改状态。</li><li id="c32e" class="nu nv iq ky b kz od lc oe lf of lj og ln oh lr nz oa ob oc bi translated"><strong class="ky ir">应付款</strong>:用<code class="fe nr ns nt ma b">payable</code>声明的函数可以接受发送给契约的以太，如果没有指定，函数会自动拒绝所有发送给它的以太。</li></ul><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="be4b" class="me mf iq ma b gy mg mh l mi mj">contract SimpleStorage {<br/>     uint256 private data;</span><span id="60d9" class="me mf iq ma b gy ol mh l mi mj">     function getData() external view returns(uint256) {<br/>         return data;<br/>     }</span><span id="021a" class="me mf iq ma b gy ol mh l mi mj">     function setData(uint256 _data) external {<br/>        data = _data;<br/>    }<br/>}</span></pre><p id="61ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里可以找到什么是读状态的意思<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/contracts.html#pure-functions" rel="noopener ugc nofollow" target="_blank">，在这里</a>可以找到详细的写状态的意思<a class="ae kv" href="https://solidity.readthedocs.io/en/v0.7.4/contracts.html#view-functions" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="63f0" class="me mf iq bd ml ng nh dn mp ni nj dp mt lf nk nl mv lj nm nn mx ln no np mz nq bi translated">交易与呼叫</h2><p id="cca4" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">用<code class="fe nr ns nt ma b">view</code>和<code class="fe nr ns nt ma b">pure</code>关键字定义的函数不会改变以太坊区块链的状态，这意味着当您调用这些函数时，您不会向区块链发送任何事务，因为事务被定义为将区块链从一个状态转换到另一个状态的状态转换函数。取而代之的是，您所连接的节点通过检查自己的区块链版本在本地执行该函数的代码，并返回结果，而不向以太网广播任何事务。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="2e01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本节中，我们将看到一些您可以使用的特殊功能。</p><h1 id="d091" class="mk mf iq bd ml mm om mo mp mq on ms mt jw oo jx mv jz op ka mx kc oq kd mz na bi translated">吸气功能</h1><p id="cd20" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">定义为public的状态变量有一个由编译器自动创建的getter函数。该函数与变量同名，并且具有外部可见性。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="89b1" class="me mf iq ma b gy mg mh l mi mj">contract C {<br/>    uint public data;<br/>    function x() public returns (uint) {<br/>        data = 3; // internal access<br/>        return this.data(); // external access<br/>    }<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7ebd" class="mk mf iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">接收以太功能</h1><p id="c344" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">一个合同最多可以有一个<code class="fe nr ns nt ma b">receive</code>功能。这个函数不能有参数，不能返回任何东西，并且必须有<code class="fe nr ns nt ma b">external</code>可见性和<code class="fe nr ns nt ma b">payable</code>状态可变性。</p><p id="184f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它在对发送Ether且未指定任何函数的协定的调用中执行(空调用数据)。这是在普通以太网传输上执行的功能(例如通过<code class="fe nr ns nt ma b">.send()</code>或<code class="fe nr ns nt ma b">.transfer()</code>)。<br/>该功能声明如下:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="1e4c" class="me mf iq ma b gy mg mh l mi mj">receive() external payable {<br/>   ...<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="a2ca" class="mk mf iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">后退功能</h1><p id="55a9" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">一个合同最多可以有一个<code class="fe nr ns nt ma b">fallback</code>功能。这个函数不能有参数，不能返回任何东西，并且必须有<code class="fe nr ns nt ma b">external</code>可见性。如果<strong class="ky ir">没有其他函数与给定的函数签名</strong>匹配，或者如果<strong class="ky ir">没有提供任何数据</strong>并且<strong class="ky ir">没有接收以太函数</strong>，则在调用契约时执行。<br/>您可以如下声明这样一个函数:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0e58" class="me mf iq ma b gy mg mh l mi mj">fallback() external [payable]{<br/>     ...<br/>}</span></pre><blockquote class="or os ot"><p id="b489" class="kw kx ou ky b kz la jr lb lc ld ju le ov lg lh li ow lk ll lm ox lo lp lq lr ij bi translated">“没有通过<code class="fe nr ns nt ma b">send</code>或<code class="fe nr ns nt ma b">transfer</code>的函数调用直接接收以太网并且没有定义<code class="fe nr ns nt ma b">receive</code>函数或可支付回退函数的契约将抛出一个异常，将以太网发送回去。”— <a class="ae kv" href="https://docs.soliditylang.org/en/v0.7.5/abi-spec.html#contract-abi-specification" rel="noopener ugc nofollow" target="_blank">坚固性文件</a></p></blockquote><p id="cf3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Remix中自己尝试一下，创建一个没有<code class="fe nr ns nt ma b">receive</code>或<code class="fe nr ns nt ma b">payable fallback</code>的契约，然后给它发送一些以太。在点击<strong class="ky ir">交易</strong>后，您应该会看到类似这样的消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/6d6f50fc55441e47567f1c39e816dcdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*JD90_-QFq3Wmmq7nEj7GNQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">示例消息</p></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="da64" class="mk mf iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">功能修饰符</h1><p id="be96" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">当你想在函数执行前检查某个条件时，需要使用修饰符。例如，如果您想检查发送者是否是合同的所有者，您可以这样写:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="46c2" class="me mf iq ma b gy mg mh l mi mj">function selectWinner() external {<br/>    require(msg.sender == owner, "this function is restricted to the owner);<br/>    ...</span><span id="d530" class="me mf iq ma b gy ol mh l mi mj">}</span></pre><p id="215a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了修饰符，我们可以隔离这段代码，这样我们就可以在其他函数中重用它，我们只需要如下声明一个修饰符:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0ea2" class="me mf iq ma b gy mg mh l mi mj">modifier onlyOwner(){<br/>   require(msg.sender == owner, "this function is restricted to the owner);<br/>  _; // will be replaced by the code of the function<br/>}</span></pre><p id="8857" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将修饰符名称添加到函数中:</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="6e24" class="me mf iq ma b gy mg mh l mi mj">function selectWinner() external onlyOwner {<br/>   <br/>    ...</span><span id="6928" class="me mf iq ma b gy ol mh l mi mj">}</span></pre><p id="edf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在一个空格分隔的列表中指定多个修饰符，可以将它们应用于一个函数，并按照给出的顺序进行计算。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="453f" class="mk mf iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">练习:Multisig钱包</h1><p id="0a36" class="pw-post-body-paragraph kw kx iq ky b kz nb jr lb lc nc ju le lf nd lh li lj ne ll lm ln nf lp lq lr ij bi translated">在本练习中，我们将为多签名钱包构建一个智能合约:<br/>多签名钱包是一种需要多个密钥来授权交易的钱包。关于这种钱包及其使用案例的更多信息可以在<a class="ae kv" href="https://en.bitcoin.it/wiki/Multisignature" rel="noopener ugc nofollow" target="_blank">比特币文档</a>中找到。</p><p id="8dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先需要的是批准者列表和授权交易所需的法定人数(所需的最少用户数，如果我们有两个或三个multisig wallet，这意味着法定人数是两个)。<br/>您还需要创建一个结构来记录与转账相关的信息，包括要支付的金额、收款人、已经批准转账的批准人数量及其状态(是否已发送或仍在等待批准人的确认)。</p><p id="7c12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">流程如下:其中一个批准人将创建转移，转移将保存在智能合同的存储器中，等待其他批准人的确认，一旦达到所需的确认数量，乙醚将转移给接收人。</p><p id="7518" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方案可以在Github的找到。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="0639" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是Solidity中的函数，我希望这篇文章对你有用。<br/>在Solidity方面，我们还有很多需要发现的:智能合约之间的交互、继承、事件和异常处理、部署到公共测试网，等等。所以像往常一样，如果你想了解更多，请继续关注即将到来的文章。</p></div></div>    
</body>
</html>