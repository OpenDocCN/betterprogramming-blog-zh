<html>
<head>
<title>The Art of Swing Effect With Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用喷气背包作曲的摇摆效果艺术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-art-of-swing-effect-with-jetpack-compose-e6f4c8cb0d88?source=collection_archive---------10-----------------------#2022-02-16">https://betterprogramming.pub/the-art-of-swing-effect-with-jetpack-compose-e6f4c8cb0d88?source=collection_archive---------10-----------------------#2022-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0939" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习如何用锚点旋转物体</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7e01f5d040ffca91bc7e2b521ece885e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Io5JLdpugBYHBsas"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@remyloz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Remy_Loz </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e86a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Compose已经走过了一段挑战如何构建声明式UI的漫长道路。而动画对象也不差。该API提供了一个统一的工具包，让你润色你的效果。</p><p id="d05e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">话虽如此，重新发现一个新的API可能会令人沮丧。当你试图重现一个你知道如何用以前的动画API表现的效果时，你会遇到困难。这就是我试图像钟摆一样摆动一个物体时发生的事情。以下是我想要实现的目标:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/d2ded4e21666be659e38df0d501cff89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7CIwhuiwrx0hGZfiLsL-Ng.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">摇摆效应</p></figure><p id="9cdf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，动画看起来像从一个角度到另一个角度的无限来回旋转。没什么特别的，对吧？让我们看看进展如何！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6167" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">构建可组合的</h1><p id="3b72" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在实现上述效果之前，让我们构建我们想要摆动的可组合组件。为了举例，我将不再赘述箭头或旋转形状的内部。</p><p id="6bb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个组合，我们需要两样东西:我们要旋转的形状和固定它的钉子。鉴于其简单性，我们可以对两个组件都使用一个<code class="fe mx my mz na b">Surface</code>——使用一个<code class="fe mx my mz na b">Canvas</code>也是非常好的。我们可以将<code class="fe mx my mz na b">Panel</code>和<code class="fe mx my mz na b">Nail</code>组件封装在一个<code class="fe mx my mz na b">Box</code>中，用<code class="fe mx my mz na b">TopCenter</code>对齐来放置钉子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">摇摆可组合</p></figure><p id="c7d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/7b3614ba2bd9bead0267aa5829c964bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*zG-sIkZ72-hQqwcFtqmM6Q.png"/></div></figure><p id="8e7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了旋转我们的<code class="fe mx my mz na b">Panel</code>组件，我们必须提供一个动态角度。由于我们希望形状无限摆动，我们可以利用带有<code class="fe mx my mz na b">rememberInfiniteTransition</code>的转换API。然后，我们通过改变其从起点<code class="fe mx my mz na b">angleOffset</code>到最终目的地的值来更新角度——出于对称的目的，我使用了它的负对应物，但您可以选择其他方式。</p><p id="1f61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于动画部分本身，我使用了一个<code class="fe mx my mz na b">tween</code>插值。Compose附带了许多内置动画来实现所需的效果。我强烈建议你看一看他们的<a class="ae kv" href="https://developer.android.com/jetpack/compose/animation" rel="noopener ugc nofollow" target="_blank">全面覆盖的文档</a>。</p><p id="fc26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们使用<code class="fe mx my mz na b">rotate</code>方法将这个角度应用到<code class="fe mx my mz na b">Panel</code>的<code class="fe mx my mz na b">Modifier</code>上。以下是更新后的<code class="fe mx my mz na b">Panel</code>代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="3ff7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/4565985bdbeb89c8044968ee54d4e844.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/1*g0tl9f9_lvRh6xP_4d9_Zw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自身旋转的面板</p></figure><p id="6db9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不是我们所期待的，对吧？钉子看起来不像是在钉嵌板。这背后有一个简单的原因:旋转锚定在面板的<strong class="ky ir">中心</strong>。我们需要把它的原点转移到它的定位点:钉子。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7ee2" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">移动变换原点</h1><p id="5723" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在Compose之前，改变旋转变换的锚点没什么大不了的。例如，<code class="fe mx my mz na b"><a class="ae kv" href="https://developer.android.com/reference/android/view/animation/RotateAnimation" rel="noopener ugc nofollow" target="_blank">RotateAnimation</a></code>允许您直接在其构造函数中更改透视:</p><pre class="kg kh ki kj gt nf na ng nh aw ni bi"><span id="64c5" class="nj mb iq na b gy nk nl l nm nn">public RotateAnimation (<br/>    float fromDegrees, <br/>    float toDegrees, <br/>    float pivotX, <br/>    float pivotY<br/>)</span></pre><p id="5e64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Compose，<code class="fe mx my mz na b">rotate</code>方法不允许您更改它的轴心，也不允许您更改任何其他看似相关的修饰符。直到你找到它:<code class="fe mx my mz na b">transformOrigin</code>。</p><p id="e3fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先要理解的是，所有修饰符转换方法都将层操作包装在一个可组合对象上。<code class="fe mx my mz na b">rotate</code>方法对此并不陌生:</p><pre class="kg kh ki kj gt nf na ng nh aw ni bi"><span id="4e31" class="nj mb iq na b gy nk nl l nm nn">@Stable<br/>fun Modifier.rotate(degrees: Float) =<br/>    if (degrees != 0f) <em class="no">graphicsLayer</em>(rotationZ = degrees) else this</span></pre><p id="da3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它用给定的角度修改层的<code class="fe mx my mz na b">rotationZ</code>属性。这暗示我们，改变支点将来自于修改一个<code class="fe mx my mz na b">graphicLayer</code>属性。</p><p id="55ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mx my mz na b">graphicLayer</code>修改器有一个默认为<code class="fe mx my mz na b">TransformOrigin.Center</code>的<code class="fe mx my mz na b">transformOrigin</code>属性。如果仔细观察它的实现，就会发现它有两个属性:<code class="fe mx my mz na b">pivotFractionX</code>和<code class="fe mx my mz na b">pivotFractionY</code>。通过改变原点，我们可以将它定向到我们的钉子位置。</p><p id="84d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">给定钉子的位置，这意味着水平居中，几乎在y轴的顶部。然后我们将旋转直接应用到<code class="fe mx my mz na b">rotationZ</code>属性上。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="b746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它会产生以下效果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/27462306447ac43f7b916dc77f2943d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:496/1*zXv0_-enZeLRaoAIs93zBQ.gif"/></div></figure><p id="5458" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这正是我们想要做的！如果像我们在介绍性动画中看到的那样，元素已经旋转了呢？</p><p id="d72b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们首先需要旋转我们的<code class="fe mx my mz na b">Swing</code>组件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="7a2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意<code class="fe mx my mz na b">Box</code>的校准已经变为<code class="fe mx my mz na b">TopStart</code>。</p><p id="e0a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还调整了我们的变换原点，因为我们通过旋转<code class="fe mx my mz na b">Box</code>改变了我们的参照。</p><p id="d55d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它给出了以下动画:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/825317813494c1650588d0dab07786a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/1*u3BHuUB2-eHSjJf6sd0GJQ.gif"/></div></div></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1047" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">转变的艺术</h1><p id="d181" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">改变动画轴心并不仅仅包括旋转。所有的转换都可以从这个属性中受益。你应该意识到它的存在及其效用。这对你未来的动画可能会派上用场。</p><p id="d2f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">重新发现一个新的API有时会令人沮丧。不过，要有信心，作曲团队会帮你的。如果你觉得Compose遗漏了什么，我建议你加入Kotlin Slack频道。成员互相支持，使社区成长。有一个专门的房间用来讨论与写作相关的话题。这就是我来寻求帮助的地方——感谢<a class="nr ns ep" href="https://medium.com/u/c967b7e51f8b?source=post_page-----e6f4c8cb0d88--------------------------------" rel="noopener" target="_blank">罗曼·盖伊</a>指引我找到了解决方案。</p><p id="dd8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，以上所有内容都应该与Compose Multiplatform一起工作——在这段代码中没有任何特定于Android的内容。</p><p id="8358" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更多文章即将推出！编码快乐！</p></div></div>    
</body>
</html>