<html>
<head>
<title>iOS View Code: A Solution To Keep the Encapsulation of the Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">iOS视图代码:保持管道封装的解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/ios-view-code-a-solution-to-keep-the-encapsulation-f378dc8b1502?source=collection_archive---------3-----------------------#2022-12-08">https://betterprogramming.pub/ios-view-code-a-solution-to-keep-the-encapsulation-f378dc8b1502?source=collection_archive---------3-----------------------#2022-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5445" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在一些计算属性中声明数据</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1089be7d8e7b671a200e84cd8ee99bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QSEw1XDsEyjcJJyS.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://wall.alphacoders.com/by_sub_category.php?id=160357&amp;name=Lighthouse+Wallpapers" rel="noopener ugc nofollow" target="_blank"> alphacoders </a></p></figure><p id="cca0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上一个系列中，我介绍了第一个用三个步骤来组织管道的解决方案。同时，你也永远不会困惑到底应该先走哪一步。事实上，这是一个很好的编码实践。然而，关于封装有一个问题。因为如果协议来自不同的模块或者可能来自超类，那么视图编码的方法是内部的或者公共的，所以总是有机会从外部调用这些方法，这意味着缺少封装。考虑到SOLID，应该永远不会有一种方法在范围之外触发直接的UI更改。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">查看作为协议实现的代码</p></figure><p id="ffca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，有一个简单的转变，我们仍然依靠超类来定义一些可重写的行为。</p><h1 id="9432" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">为您的视图创建一个基类</h1><p id="f9f5" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">首先，让我们记录一下我们过去是如何创建管道的。我们有三种方法:一种用于构建层次结构，第二种用于约束，第三种用于附加配置。我们希望在不同的地方定义或查看数据，并在初始化视图后触发管道。让我们创建一个新的基类，在这个基类中，我们将把所有的任务集中在一个初始化器中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个<code class="fe mr ms mt mu b">setupView</code>函数来触发初始化器中的所有设置。但问题是，<code class="fe mr ms mt mu b">buildHierarchy</code>和<code class="fe mr ms mt mu b">setupConstraints</code>步骤是它的子类所特有的，超类怎么可能知道它们呢？我们应该在子类可能扩展的计算变量中保存关于层次和约束的数据。</p><p id="da40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">既然超类是由一系列<code class="fe mr ms mt mu b">addSubview</code>和<code class="fe mr ms mt mu b">addArrangedSubview</code>步骤定义的，我们应该如何保存关于超类中层次的数据呢？那么，我们将引入一个新的数据模型来描述哪个视图属于哪个视图。</p><h1 id="3f21" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">创建描述层次结构的数据模型</h1><p id="b0ad" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">为我们的层次模型创建一个新类:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1087" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此数据类型描述了哪些视图附加到特定的视图。它还提供了一种基于父视图和子视图建立层次结构的方法。如果是堆栈视图，它应该为每个子视图调用<code class="fe mr ms mt mu b">addArrangedSubview</code>。否则用<code class="fe mr ms mt mu b">addSubview</code>加。应该为在<code class="fe mr ms mt mu b">BaseView</code>的子类中的computed属性中描述的每个层次关系调用这个<code class="fe mr ms mt mu b">makeHierarchy</code>方法。话虽如此，我们还是声明如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="da85" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，一旦我们的视图被初始化，我们的层次结构就建立起来了。</p><h1 id="0342" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">限制</h1><p id="bfe4" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们知道我们的<code class="fe mr ms mt mu b">UIView</code>类为约束提供了一个计算属性，这是一个<code class="fe mr ms mt mu b">NSLayoutConstraint</code>的数组。让我们用我们的<code class="fe mr ms mt mu b">setupView</code>方法来激活它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="e69c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要为每个子类提供一个约束数组，以便被它的超级<code class="fe mr ms mt mu b">init</code>激活。</p><h1 id="7c3c" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">附加配置</h1><p id="5830" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">我们已经在每个视图的默认初始化器中放置了层次结构和自动布局的管道。现在，我们需要一种建立配置的方法。因为它非常抽象，所以我还不知道如何在计算属性中保存额外的配置。我们可以为每个视图创建一个私有方法，或者找到另一种方法来应用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="3740" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但重要的是，我们的管道是安全的，现在已经封装好了，因为它的触发器保存在我们的基本视图<code class="fe mr ms mt mu b">init</code>中，我们只能在计算出的属性中看到关于层次和约束的数据。</p><h1 id="4b76" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结论</h1><p id="70fe" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf mo lh li lj mp ll lm ln mq lp lq lr ij bi translated">在本文中，我们发现了在定制视图中暴露视图代码方法的问题的转机。我们不是在可以被同一个模块中的任何其他地方调用的一些内部方法中声明它，而是在一些计算的属性中声明数据，并且我们只从基类初始化器中触发管道。</p><p id="ffba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望您觉得这个解决方案有用并喜欢；).</p></div></div>    
</body>
</html>