<html>
<head>
<title>How To Iterate Correctly With Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Java正确迭代</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-iterate-with-java-56b0fd83bbfc?source=collection_archive---------7-----------------------#2021-02-22">https://betterprogramming.pub/how-to-iterate-with-java-56b0fd83bbfc?source=collection_archive---------7-----------------------#2021-02-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="eef5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不仅仅是“for”和“while”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/aa939f72d812c3943403f4a92b53105f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GcVOsJS_dKAwejQh"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="7e66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">迭代数据结构是您将遇到的最常见的任务之一。大家都知道经典，像<code class="fe lv lw lx ly b">for</code>或者<code class="fe lv lw lx ly b">while</code>。但是在Java中有更多的方法可以迭代，提供更多的功能。</p><p id="1933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lz">注意:假设使用Java 8，但是如果适当的话，使用Java 10特性</em> <a class="ae ky" href="https://developer.oracle.com/java/jdk-10-local-variable-type-inference.html" rel="noopener ugc nofollow" target="_blank"> <em class="lz">局部变量类型推断</em> </a> <em class="lz">来增加可读性。</em></p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="da42" class="me mf it ly b gy mg mh l mi mj"><strong class="ly iu">TABLE OF CONTENTS</strong></span><span id="0f0a" class="me mf it ly b gy mk mh l mi mj"><a class="ae ky" href="#8237" rel="noopener ugc nofollow">The Classics</a><br/><a class="ae ky" href="#0240" rel="noopener ugc nofollow">Iterator-based</a><br/><a class="ae ky" href="#b7e9" rel="noopener ugc nofollow">Lambda-based</a><br/><a class="ae ky" href="#9c69" rel="noopener ugc nofollow">Lambda vs. Traditional</a><br/><a class="ae ky" href="#5c78" rel="noopener ugc nofollow">Resources</a></span></pre></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="8237" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">经典作品</h1><p id="6e7d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">有三种经典的方法来迭代语言集成的关键字:</p><ul class=""><li id="3c65" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">for</code></li><li id="ab34" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">增强的<code class="fe lv lw lx ly b">for</code> (Java 5+)</li><li id="8c7c" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><code class="fe lv lw lx ly b">while</code> / <code class="fe lv lw lx ly b">do-while</code></li></ul><h2 id="98fc" class="me mf it bd mt oc od dn mx oe of dp nb li og oh nd lm oi oj nf lq ok ol nh om bi translated"><code class="fe lv lw lx ly b">for </code>循环</h2><p id="6779" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">for</code>回路是<a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.14.1" rel="noopener ugc nofollow" target="_blank">，在文档中定义为</a>:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="eb45" class="me mf it ly b gy mg mh l mi mj">for (&lt;initialization&gt;; &lt;termination&gt;; &lt;increment&gt;) {<br/>    ...<br/>}</span></pre><p id="9b0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">括号中的三个表达式具有不同的生命周期:</p><ul class=""><li id="c5bb" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">初始化—在循环开始时调用一次。</li><li id="f40e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">终止—如果计算结果为<code class="fe lv lw lx ly b">false</code>，则终止循环。</li><li id="5919" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">增量— <strong class="lb iu"> </strong>每次迭代后调用。</li></ul><p id="7d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，这三个表达式都会用到，但它们不是必需的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="f7fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使有可能编写这样的代码，我也不推荐这样做。<code class="fe lv lw lx ly b">for</code>循环是一个很好的工具，通过将三个表达式放在一对括号中，可以将迭代限制在一个地方。如果我们把表达式分开，我们的代码会变得难以理解。</p><p id="875c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有终止表达式，循环将无休止地运行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="04c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要在循环中使用<code class="fe lv lw lx ly b">break</code>来终止它。无限循环经常用于一种叫做<a class="ae ky" href="https://en.wikipedia.org/wiki/Busy_waiting" rel="noopener ugc nofollow" target="_blank">忙等待</a>的技术，这被认为是一种反模式。还有许多其他方法来处理并发性(例如，等待线程，等等。)，但这些都超出了本文的范围。</p><h2 id="a9ce" class="me mf it bd mt oc od dn mx oe of dp nb li og oh nd lm oi oj nf lq ok ol nh om bi translated">增强for循环</h2><p id="2ecd" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">传统的基于表达式的<code class="fe lv lw lx ly b">for</code>循环做得很好，但是它也是一个嘈杂而冗长的结构。大多数时候，我们的循环实际上是从相同的逻辑开始的:迭代所有的项并访问当前项。</p><p id="2b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java 5引入了增强的<code class="fe lv lw lx ly b">for</code>循环来简化这个常见任务。它适用于符合<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank">java.util.Iterable&lt;T&gt;</a></code>或者是数组的数据结构。</p><p id="238e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个数组都有<code class="fe lv lw lx ly b">Object</code>作为其基类，并实现<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html" rel="noopener ugc nofollow" target="_blank">Serializable</a></code>和<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html" rel="noopener ugc nofollow" target="_blank">Cloneable</a></code>，但没有<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank">Iterable</a></code>。一个主要的优点是能够存储原始类型(例如<code class="fe lv lw lx ly b">int</code>、<code class="fe lv lw lx ly b">long</code>)，而不仅仅是成熟的对象，所以我们不必依赖自动装箱。</p><p id="7c55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">语法很简单:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="9c12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们之前的例子变得更加合理:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="4318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，由于直接的上下文，实际类型是清楚的。所以使用<code class="fe lv lw lx ly b">var</code>将减少来自更长类型名称的任何额外噪音。</p><h2 id="d77a" class="me mf it bd mt oc od dn mx oe of dp nb li og oh nd lm oi oj nf lq ok ol nh om bi translated">while/do-while</h2><p id="2fc9" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated"><code class="fe lv lw lx ly b">while</code>循环可以看作是一个简化的<code class="fe lv lw lx ly b">for</code>循环，只有一个终止表达式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="573c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">for</code>一样，如果终止表达式的计算结果为<code class="fe lv lw lx ly b">false</code>，则终止表达式会中断循环。</p><p id="7b6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些情况下，需要在循环块之后评估可能的终止。这就是<code class="fe lv lw lx ly b">do-while</code>的作用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="406a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，不管终止表达式如何，循环块至少运行一次。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="0240" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">基于迭代器</h1><h2 id="8880" class="me mf it bd mt oc od dn mx oe of dp nb li og oh nd lm oi oj nf lq ok ol nh om bi translated">可迭代的</h2><p id="a8b7" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">接口<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank">java.util.Iterable&lt;E</a>&gt;</code>通过提供<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">java.util.Iterator&lt;E&gt;</a></code>使数据结构可用于增强的<code class="fe lv lw lx ly b">for</code>循环:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="8862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是一个简单的数据结构的抽象，通过知道是否有另一个元素以及如何获得它。实际迭代的周围框架通常由一个循环提供:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="2e9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与增强的<code class="fe lv lw lx ly b">for</code>环路相比，这种方法噪音很大，那么它有什么优势呢？</p><p id="b759" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove--" rel="noopener ugc nofollow" target="_blank">Iterator#remove</a>()</code>方法让一切变得不同。当迭代时，我们不能改变当前正在迭代的数据。这段代码会抛出一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/ConcurrentModificationException.html" rel="noopener ugc nofollow" target="_blank">java.util.ConcurrentModificationException</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="6df9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，在这种情况下，在调用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html#remove-java.lang.Object-" rel="noopener ugc nofollow" target="_blank">List#remove</a>(Object)</code>的过程中并没有抛出<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/ConcurrentModificationException.html" rel="noopener ugc nofollow" target="_blank">ConcurrentModificationException</a></code>。相反，访问<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#next--" rel="noopener ugc nofollow" target="_blank">next</a>()</code>的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">Iterator</a>&lt;Integer&gt;</code>将抛出异常。</p><p id="0f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过直接使用迭代器，我们可以在迭代时删除:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="342e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以使用一个<code class="fe lv lw lx ly b">for</code>循环，将初始化和终止合并成一行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="271a" class="me mf it bd mt oc od dn mx oe of dp nb li og oh nd lm oi oj nf lq ok ol nh om bi translated">列表迭代器</h2><p id="961d" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">作为本质上的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">Iterator</a>&lt;E&gt;</code>,<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html" rel="noopener ugc nofollow" target="_blank">ListIterator</a>&lt;E&gt;</code>提供了向后导航和修改的附加功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="691e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以将<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html" rel="noopener ugc nofollow" target="_blank">ListIterator</a></code>视为元素之间的<em class="lz">:</em></p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="2b90" class="me mf it ly b gy mg mh l mi mj">             E[0]   E[1]   ... E[n]<br/>Positions: ^      ^      ^          ^</span></pre><p id="8e56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">任何修改操作都将由<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html#next--" rel="noopener ugc nofollow" target="_blank">next</a>()</code>或<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html#previous--" rel="noopener ugc nofollow" target="_blank">previous</a>()</code>在最后返回的元素上执行。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="b7e9" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">基于λ的</h1><p id="74b6" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">Java 8中引入的<a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-an-introduction-daa783355731#78bc" rel="noopener"> lambdas </a>为迭代带来了新的可能性。多亏了<a class="ae ky" href="https://medium.com/@benweidig/java-8-interfaces-default-methods-for-backwards-compatibility-2767a6a70947" rel="noopener">默认方法</a>，每个实现<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank">Iterable</a>&lt;T&gt;</code>的类型都获得了将<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" rel="noopener ugc nofollow" target="_blank">Consumer</a>&lt;T&gt;</code>应用于每个元素的能力:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><p id="a11b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们可以从它的简单实现中看到的，与普通的增强型<code class="fe lv lw lx ly b">for</code>循环相比，我们不会获得太多。这就是为什么它最适合简单的用例，比如调用方法引用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure><h2 id="43cd" class="me mf it bd mt oc od dn mx oe of dp nb li og oh nd lm oi oj nf lq ok ol nh om bi translated">使用流的forEach</h2><p id="43a0" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">流是功能块的惰性顺序数据管道，这意味着它们将迭代数据，适当地应用功能块。</p><p id="edce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了使用流的中间操作本身进行迭代，我们还可以使用终端操作<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEach-java.util.function.Consumer-" rel="noopener ugc nofollow" target="_blank">Stream#forEach</a>(Consumer&lt;? super T&gt; action)</code>。但是就像使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank">Iterable</a></code>一样，更小更合理的代码块提高了代码的总体清晰度。</p><p id="3ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好将尽可能多的逻辑移到中间操作，并且尽可能高，这样操作的总数就尽可能少:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="on oo l"/></div></figure></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="9c69" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">Lambda与传统</h1><p id="9fbb" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">我们现在已经了解了迭代数据结构的不同方法。</p><p id="fec4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们如何选择使用哪一个呢？</p><p id="b411" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我很喜欢lambdas，但它们也有很多缺点——尤其是在迭代方面:</p><ul class=""><li id="6906" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">异常:用lambdas处理(被检查的)异常并不有趣。我写了一整篇文章,讲述如何用函数方式处理它们。</li><li id="41d0" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">没有中断:lambda中的<code class="fe lv lw lx ly b">return</code>将像传统循环中的<code class="fe lv lw lx ly b">continue</code>一样工作，但是没有对应的<code class="fe lv lw lx ly b">break</code>。</li><li id="17c2" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">JVM优化:没有<a class="ae ky" href="https://en.wikipedia.org/wiki/Loop_unrolling" rel="noopener ugc nofollow" target="_blank">循环展开</a>。这并不意味着lambdas没有优化，但与传统的循环相比，它们是不同的。</li><li id="b565" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">更深的调用堆栈:将为附加的方法调用创建一个堆栈框架。</li><li id="b244" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">调试:尽管ide在处理lambdas和streams方面做得更好了，但是遍历一个循环仍然更简单——特别是有了额外的堆栈框架。</li><li id="e50a" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">没有副作用:只有有效的<code class="fe lv lw lx ly b">final</code>变量可以在lambda中使用。</li></ul><p id="6313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这听起来可能很糟糕，但lambdas和streams也提供了许多优势:</p><ul class=""><li id="59df" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">并行执行:流可以并行化，不需要额外的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" rel="noopener ugc nofollow" target="_blank">ExecutorService</a></code>。</li><li id="8244" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">流畅:流畅的通话可以将操作分成更容易管理的模块。与循环块相比，整个调用更加简洁明了。</li><li id="6071" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated">无副作用:有效的<em class="lz"> </em> <code class="fe lv lw lx ly b">final</code>变量不会产生副作用。</li></ul></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt ma ly op bn oq or bi"><span id="0bbb" class="os mf it ly b be ot ou l mi mj"><strong class="ly iu">You like my ramblings about Java?<br/>Check out my upcoming book!</strong><br/><a class="ae ky" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="0afb" class="ms mf it bd mt mu ov mw mx my ow na nb jz ox ka nd kc oy kd nf kf oz kg nh ni bi translated">结论</h1><p id="7f8c" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">正如您所看到的，对于使用哪种类型的迭代没有简单的答案。这完全取决于上下文。代码的可读性和可维护性应该在决定哪种迭代最合适的过程中扮演重要角色。</p></div><div class="ab cl ml mm hx mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="im in io ip iq"><h1 id="5c78" class="ms mf it bd mt mu mv mw mx my mz na nb jz nc ka nd kc ne kd nf kf ng kg nh ni bi translated">资源</h1><ul class=""><li id="3ee0" class="no np it lb b lc nj lf nk li pa lm pb lq pc lu nt nu nv nw bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/foreach.html" rel="noopener ugc nofollow" target="_blank">For-Each循环</a> (Oracle)</li><li id="8e0e" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html#Iterator" rel="noopener ugc nofollow" target="_blank">列表界面</a> (Oracle)</li><li id="d5b7" class="no np it lb b lc nx lf ny li nz lm oa lq ob lu nt nu nv nw bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.14" rel="noopener ugc nofollow" target="_blank">for语句</a> (JLS)</li></ul><div class="pd pe gp gr pf pg"><a href="https://medium.com/better-programming/functional-programming-with-java-streams-f930e0e4d184" rel="noopener follow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">Java函数式编程:流</h2><div class="pn l"><h3 class="bd b gy z fp pl fr fs pm fu fw dk translated">最佳实践概述</h3></div><div class="po l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">medium.com</p></div></div><div class="pp l"><div class="pq l pr ps pt pp pu ks pg"/></div></div></a></div></div></div>    
</body>
</html>