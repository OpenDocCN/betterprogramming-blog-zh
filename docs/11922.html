<html>
<head>
<title>Kotlin/Native vs. C++ vs. Freepascal vs. Python: A Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">kot Lin/Native vs . c++ vs . free Pascal vs . Python:比较</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kotlin-native-vs-c-freepascal-python-c1dba39752cf?source=collection_archive---------5-----------------------#2022-04-27">https://betterprogramming.pub/kotlin-native-vs-c-freepascal-python-c1dba39752cf?source=collection_archive---------5-----------------------#2022-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9fdd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">测量构建时间、运行时间、跨代码库编译的可执行文件的大小</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a382113cb641e11b39c8f0cfcb44bfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nyi-ZvFEQNd_NNRQ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">克里斯·利维拉尼在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="93c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大家好！自从Google宣布Kotlin作为Android开发以及Google自己的名为Jetpack-family的库的主要编程语言以来，这种语言的采用正在飞速增长。</p><p id="d5c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是Kotlin不仅仅是针对Android的。它也适用于后端、多平台桌面应用、数据科学，甚至游戏、前端和机器学习。</p><p id="3166" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了科特林，你可以实现非常广泛的目标。只有一个小的美中不足:您需要用您的代码获取整个Java虚拟机来部署这个版本。但是Kotlin/Native配什么呢？它准备好构建不同的应用程序了吗？它的性能与其他语言如C++相当吗？</p><p id="7358" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一系列的博客文章中，我将试图找出真相，并将Kotlin/Native与C++、古代Freepascal和Python进行比较。</p><p id="8012" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是等等..为什么是Python？Python代码不会编译成原生应用，那为什么会在这里？嗯，可能只是为了好玩，或者因为我比较熟悉)。</p><h1 id="50e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">内容</h1><ol class=""><li id="a672" class="mk ml iq ky b kz mm lc mn lf mo lj mp ln mq lr mr ms mt mu bi translated">简单的数学与原生应用程序，或今晚谁这么聪明？<em class="mv"> —你在这里— </em></li><li id="b201" class="mk ml iq ky b kz mw lc mx lf my lj mz ln na lr mr ms mt mu bi translated"><a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/kotlin-native-vs-c-vs-freepascal-vs-python-a-comparison-part-2-1be9007ecf41">用SDL2进行图形测试，或者用Norton Commander进行跨宇宙测试。</a></li></ol></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h2 id="07da" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">科特林</h2><p id="7b78" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">维基说厄拉多塞筛是一种测试计算机性能的流行方法。这正是我们所需要的。Python先生，让我们开始一场不同编程语言的竞赛，这些语言可以产生本地代码，并与天生的数学计算者进行比较。</p><p id="3d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我用Kotlin编写了以下代码，作为其他人的模式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="70da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里使用了<code class="fe nz oa ob oc b">require</code>函数来定义一个前提条件。我们在Kotlin中还有<code class="fe nz oa ob oc b"><em class="mv">contracts</em></code>来指定函数的一些行为。当然，我们有<code class="fe nz oa ob oc b"><em class="mv">assertions</em></code>，但我认为它更适合在测试套件中使用。</p><p id="3936" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看，Kotlin扩展函数有多有用。我在这里使用了带有谓词的<code class="fe nz oa ob oc b">mapIndexedNotNull</code>作为<code class="fe nz oa ob oc b">takeIf</code>扩展。从字面上看，函数式风格的一行代码用列表构建和条件语句代替了循环。</p><p id="6e71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于速度和节省内存的目的，我在这里使用了<code class="fe nz oa ob oc b">Array</code>而不是<code class="fe nz oa ob oc b">mutableList</code>:数组的值在<em class="mv"> while </em>循环的每次迭代中都在变化，这就是为什么数组在这里更好，它不会在每一步分配一个新的内存段，而是非常快速地就地改变值。这个结构没有超出<em class="mv">函数作用域</em>，使用数组是完全安全的。</p><p id="66b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哦，别忘了上面的樱桃！盒子里的<code class="fe nz oa ob oc b">measuredTimeMills</code>功能。谢谢，科特林/土人。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h2 id="672e" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated">计算机编程语言</h2><p id="4763" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">到目前为止一切顺利。下一个让我们激动的是Python。让我们比较一下他们的语法糖:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="14f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，Python代码和Kotlin代码的逻辑和语法几乎相同。我使用了<code class="fe nz oa ob oc b"><strong class="ky ir">assert</strong></code> <strong class="ky ir"> </strong>作为前置条件，列出了构建初始布尔数组的理解，并返回了一个素数列表。Python没有开箱计时的功能，但是我们用奴婢<code class="fe nz oa ob oc b"><strong class="ky ir">decorator</strong></code>T5得到了更好的方法。</p><p id="68a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢哪种糖？一方面，Kotlin对任何类型都有强大的扩展，您可以随意组合它们，并在结果中获得漂亮的函数链。</p><p id="31b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，Python有最简洁的列表理解语法，但也有最繁琐的条件:我讨厌为if… else… if… else…if… else输入所有这些行。顺便说一下，Python 3.10中呈现的全新模式匹配甚至与Kotlin中的<code class="fe nz oa ob oc b">when</code>语法都不接近。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h2 id="0e00" class="ni lt iq bd lu nj nk dn ly nl nm dp mc lf nn no me lj np nq mg ln nr ns mi nt bi translated"><strong class="ak"> C++ </strong></h2><p id="51fd" class="pw-post-body-paragraph kw kx iq ky b kz mm jr lb lc mn ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">我不得不到达我思想殿堂的最底层，去回忆如何让同样的算法在最可怕的C++中工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="4bef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，算法本身仍然是相同的，甚至具有与任何其他类似C语言的编程语言相似的语法。</p><p id="536b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是你必须注意内存分配、内存释放以及所有这些指针、链接等等的所有细节。</p><p id="b5b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你仍然可以用C++模板和lambdas自己开发高阶函数，但是这非常痛苦，而且会破坏C++的所有性能。</p><p id="43ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，作为函数的结果，使用列表而不是指针作为值参数，每一百万个素数会增加一百毫秒。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="5495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很久以前…在遥远的银河系…全世界的每个学生都在学习帕斯卡。我觉得我们应该向帕斯卡致敬，他在目前拥有数百万维护Delphi的大胡子编码员(现在叫什么名字？)和拉撒路·伊德斯。记事本的业余爱好者，以及vim'ers，应该在没有任何现代自动完成或代码建议的情况下，欣赏Lazarus IDE的斯巴达式优势。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="a78d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pascal代码是最长的一个。它有泛型，但是，如你所见，他们设法把它复杂化了。(<em class="mv">为什么</em> <code class="fe nz oa ob oc b">specialize</code> <em class="mv">？这个单词是什么意思？)</em></p><p id="ccce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Pascal还是没有任何高阶函数和lambdas的机会。是的，它有一个用于参数的函数类型，但是…你应该自己通过这种方式。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="ce12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你认为这次比赛我们会取得什么样的结果？我测量了构建时间、运行时间和编译后的可执行文件的大小，得到了计算第一个100，000，000个素数的如下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi od"><img src="../Images/76c0e186205e4e11af725c24aae98bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1274/format:webp/1*a5ioZUcCiAFWMIk0ZOlwYQ.png"/></div></figure><p id="ec1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">с++无愧于运行速度最快、应用程序最小的称号。但是帕斯卡正紧紧盯着它！</p><p id="8aae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Kotlin/Native文件只有Pascal文件的一半大小，但也落后于Pascal文件的一半。Python会发生什么？为什么这么慢？因为它不使用预编译库，只解释每一行代码。</p><p id="9a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我给Kotlin code打5分，因为它加入了函数式编程能力俱乐部，拥有富有表现力的简洁代码。</p><p id="4235" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二名是Python。C++代码在我看来比Pascal漂亮，但别忘了，我用了很多年，非常愉快。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="3776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们比赛的第二部分，我将在图形测试中比较这些语言:我们将使用<code class="fe nz oa ob oc b">SDL2</code>库，并用诺顿指挥官的starfield制作一个旧的屏幕保护程序。这个测试的灵感来自维亚切斯拉夫·阿尔希波夫的这篇文章。</p><p id="ef1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别走开，我会回来的。</p></div></div>    
</body>
</html>