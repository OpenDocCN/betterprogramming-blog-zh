<html>
<head>
<title>10 Modern JavaScript Tricks Every Developer Should Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该使用的10个现代JavaScript技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-modern-javascript-tricks-every-developer-should-use-377857311d79?source=collection_archive---------0-----------------------#2021-06-15">https://betterprogramming.pub/10-modern-javascript-tricks-every-developer-should-use-377857311d79?source=collection_archive---------0-----------------------#2021-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4bf1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写简短、简洁、干净的JavaScript代码的技巧</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/07e08c3c1278315b859ec83fb156e79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M61bTO6MVJ_z1fkpcz3KDw.png"/></div></div></figure><p id="260a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你一定见过上图中的那个人<a class="ae lq" href="https://www.instagram.com/khaby00/?hl=en" rel="noopener ugc nofollow" target="_blank">。他简化了日常事务——这正是我们在本文中要用JavaScript做的事情。</a></p><p id="1b09" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript有很多初级和中级开发人员不知道的很酷的特性。我挑选了10个我在日常JavaScript项目中使用的技巧。</p><h1 id="6da7" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">1.有条件地向对象添加属性</h1><p id="2187" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">我们可以使用spread操作符<code class="fe mo mp mq mr b">...</code>，有条件地快速向JavaScript对象添加属性。</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="6916" class="mw ls it mr b gy mx my l mz na">const condition = true;</span><span id="84e4" class="mw ls it mr b gy nb my l mz na">const person = {<br/>  id: 1,<br/>  name: 'John Doe',<br/>  ...(condition &amp;&amp; { age: 16 }),<br/>};</span></pre><p id="a94d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果每个操作数的计算结果都是<code class="fe mo mp mq mr b">true</code>，那么<code class="fe mo mp mq mr b">&amp;&amp;</code>操作符将返回最后一个计算的表达式。所以一个对象<code class="fe mo mp mq mr b">{ age: 16 }</code>被返回，然后被扩展为<code class="fe mo mp mq mr b">person</code>对象的一部分。</p><p id="2ee5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果<code class="fe mo mp mq mr b">condtion</code>是<code class="fe mo mp mq mr b">false</code>，那么JavaScript会这样做:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="e312" class="mw ls it mr b gy mx my l mz na">const person = {<br/>  id: 1,<br/>  name: 'John Doe',<br/>  ...(false), // evaluates to false<br/>};</span><span id="26a3" class="mw ls it mr b gy nb my l mz na">// spreading false has no effect on the object<br/>console.log(person); // { id: 1, name: 'John Doe' }</span></pre><h1 id="2695" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">2.检查对象中是否存在属性</h1><p id="f64c" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">你知道我们可以使用<code class="fe mo mp mq mr b">in</code>关键字来检查JavaScript对象中是否存在一个属性吗？</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="fd5b" class="mw ls it mr b gy mx my l mz na">const person = { name: 'John Doe', salary: 1000 };</span><span id="0f70" class="mw ls it mr b gy nb my l mz na">console.log('salary' in person); // returns true<br/>console.log('age' in person); // returns false</span></pre><h1 id="6334" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">3.对象中的动态属性名</h1><p id="bd3f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">用动态键设置对象属性很简单。只需使用<code class="fe mo mp mq mr b">['key_name']</code>符号来添加属性:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="7110" class="mw ls it mr b gy mx my l mz na">const dynamic = 'flavour';</span><span id="cc09" class="mw ls it mr b gy nb my l mz na">var item = {<br/>  name: 'Biscuit',<br/>  [dynamic]: 'Chocolate'<br/>}</span><span id="ac8b" class="mw ls it mr b gy nb my l mz na">console.log(item); // { name: 'Biscuit', flavour: 'Chocolate' }</span></pre><p id="d47c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样的技巧也可以用来引用带有动态键的对象属性:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="a791" class="mw ls it mr b gy mx my l mz na">const keyName = 'name';</span><span id="664c" class="mw ls it mr b gy nb my l mz na">console.log(item[keyName]); // returns 'Biscuit'</span></pre><h1 id="a42c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">4.用动态键析构对象</h1><p id="4ac2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">所以你知道你可以析构一个变量，然后马上用<code class="fe mo mp mq mr b">:</code>符号重命名它。但是你知道吗，当你不知道键名或者键名是动态的时候，你也可以析构一个对象的属性。</p><p id="62ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，让我们看看如何在析构时重命名变量(用别名析构)。</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="f08d" class="mw ls it mr b gy mx my l mz na">const person = { id: 1, name: 'John Doe' };</span><span id="d96a" class="mw ls it mr b gy nb my l mz na">const { name: personName } = person;</span><span id="a288" class="mw ls it mr b gy nb my l mz na">console.log(personName); // returns 'John Doe'</span></pre><p id="ff14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们用一个动态键来析构属性:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="e155" class="mw ls it mr b gy mx my l mz na">const templates = {<br/>  'hello': 'Hello there',<br/>  'bye': 'Good bye'<br/>};</span><span id="65fd" class="mw ls it mr b gy nb my l mz na">const templateName = 'bye';</span><span id="f4f7" class="mw ls it mr b gy nb my l mz na">const { [templateName]: template } = templates;</span><span id="3b48" class="mw ls it mr b gy nb my l mz na">console.log(template) // returns 'Good bye'</span></pre><h1 id="7761" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">5.无效合并，<code class="fe mo mp mq mr b">??</code>运算符</h1><p id="1261" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">当您想要检查变量是<code class="fe mo mp mq mr b">null</code>还是<code class="fe mo mp mq mr b">undefined</code>时，<code class="fe mo mp mq mr b">??</code>操作符非常有用。当左侧操作数为<code class="fe mo mp mq mr b">null</code>或<code class="fe mo mp mq mr b">undefined</code>时，返回右侧操作数，否则返回左侧操作数。</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="b0cc" class="mw ls it mr b gy mx my l mz na">const foo = null ?? 'Hello';<br/>console.log(foo); // returns 'Hello'</span><span id="ad96" class="mw ls it mr b gy nb my l mz na">const bar = 'Not null' ?? 'Hello';<br/>console.log(bar); // returns 'Not null'</span><span id="9ae5" class="mw ls it mr b gy nb my l mz na">const baz = 0 ?? 'Hello';<br/>console.log(baz); // returns 0</span></pre><p id="1583" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在第三个例子中，<code class="fe mo mp mq mr b">0</code>被返回，因为即使<code class="fe mo mp mq mr b">0</code>在JavaScript中被认为是falsy，它也不是<code class="fe mo mp mq mr b">null</code>或<code class="fe mo mp mq mr b">undefined</code>。你可能认为我们可以在这里使用<code class="fe mo mp mq mr b">||</code>操作符，但是这两者是有区别的:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="1cbe" class="mw ls it mr b gy mx my l mz na">const cannotBeZero = 0 || 5;<br/>console.log(cannotBeZero); // returns 5</span><span id="e11f" class="mw ls it mr b gy nb my l mz na">const canBeZero = 0 ?? 5;<br/>console.log(canBeZero); // returns 0</span></pre><h1 id="8188" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">6.可选链接(<code class="fe mo mp mq mr b">?.</code>)</h1><p id="eb32" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">你是不是也很讨厌<code class="fe mo mp mq mr b">TypeError: Cannot read property ‘foo’ of null</code> <em class="nc">这样的错误。对于每一个JavaSript开发者来说，这都是一件令人头疼的事情。引入可选链接就是为了解决这个问题。让我们来看看:</em></p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="765a" class="mw ls it mr b gy mx my l mz na">const book = { id:1, title: 'Title', author: null };</span><span id="880c" class="mw ls it mr b gy nb my l mz na">// normally, you would do this<br/>console.log(book.author.age) // throws error<br/>console.log(book.author &amp;&amp; book.author.age); // returns null (no error)</span><span id="bb7e" class="mw ls it mr b gy nb my l mz na">// with optional chaining<br/>console.log(book.author?.age); // returns undefined</span><span id="d13b" class="mw ls it mr b gy nb my l mz na">// or deep optional chaining<br/>console.log(book.author?.address?.city); // returns undefined</span></pre><p id="959f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您还可以对函数使用可选链接，如下所示:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="6ef8" class="mw ls it mr b gy mx my l mz na">const person = {<br/>  firstName: 'Haseeb',<br/>  lastName: 'Anwar',<br/>  printName: function () {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  },<br/>};</span><span id="304a" class="mw ls it mr b gy nb my l mz na">console.log(person.printName()); // returns 'Haseeb Anwar'<br/>console.log(persone.doesNotExist?.()); // returns undefined</span></pre><h1 id="ad29" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">7.使用<code class="fe mo mp mq mr b">!!</code>运算符的布尔转换</h1><p id="982f" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><code class="fe mo mp mq mr b">!!</code>运算符可用于将表达式的结果快速转换为布尔运算<code class="fe mo mp mq mr b">true</code>或<code class="fe mo mp mq mr b">false</code>。方法如下:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="edbb" class="mw ls it mr b gy mx my l mz na">const greeting = 'Hello there!';<br/>console.log(!!greeting) // returns true</span><span id="fc2c" class="mw ls it mr b gy nb my l mz na">const noGreeting = '';<br/>console.log(!!noGreeting); // returns false</span></pre><h1 id="7dfa" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">8.字符串和整数转换</h1><p id="7f49" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">使用<code class="fe mo mp mq mr b">+</code>运算符快速将字符串转换为数字，如下所示:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="74be" class="mw ls it mr b gy mx my l mz na">const stringNumer = '123';</span><span id="be87" class="mw ls it mr b gy nb my l mz na">console.log(+stringNumer); // returns integer 123<br/>console.log(typeof +stringNumer); // returns 'number'</span></pre><p id="0c5f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要快速将数字转换为字符串，请使用<code class="fe mo mp mq mr b">+</code>运算符，后跟一个空字符串<code class="fe mo mp mq mr b">""</code>:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="741c" class="mw ls it mr b gy mx my l mz na">const myString = 25 + '';</span><span id="27fe" class="mw ls it mr b gy nb my l mz na">console.log(myString); // returns '25'<br/>console.log(typeof myString); // returns 'string'</span></pre><p id="a6fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这些类型转换非常方便，但是它们不够清晰，代码可读性差。因此，在生产中使用它们之前，您可能需要考虑一下。但是，不要犹豫在code golf中使用它们。</p><h1 id="590c" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">9.检查数组中的错误值</h1><p id="e599" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">您必须熟悉<code class="fe mo mp mq mr b">filter</code>、<code class="fe mo mp mq mr b">some</code>和<code class="fe mo mp mq mr b">every</code>数组方法。但是你也应该知道你可以用<code class="fe mo mp mq mr b">Boolean</code>方法来测试真值:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="f0b8" class="mw ls it mr b gy mx my l mz na">const myArray = [null, false, 'Hello', undefined, 0];</span><span id="0584" class="mw ls it mr b gy nb my l mz na"><em class="nc">// filter falsy values</em><br/>const filtered = myArray.filter(Boolean);<br/>console.log(filtered); // returns ['Hello']</span><span id="7320" class="mw ls it mr b gy nb my l mz na"><em class="nc">// check if at least one value is truthy</em><br/>const anyTruthy = myArray.some(Boolean);<br/>console.log(anyTruthy); // returns true</span><span id="a6ad" class="mw ls it mr b gy nb my l mz na"><em class="nc">// check if all values are truthy</em><br/>const allTruthy = myArray.every(Boolean);<br/>console.log(allTruthy); // returns false</span></pre><p id="1a10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它是这样工作的。因为我们知道这些数组方法采用回调函数，所以我们将<code class="fe mo mp mq mr b">Boolean</code>作为回调函数传递。Boolean本身接受一个参数，并根据参数的真实性返回<code class="fe mo mp mq mr b">true</code>或<code class="fe mo mp mq mr b">false</code>。所以我们可以这样说:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="2847" class="mw ls it mr b gy mx my l mz na">myArray.filter(val =&gt; Boolean(val));</span></pre><p id="73fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">和这个是一样的:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="4230" class="mw ls it mr b gy mx my l mz na">myArray.filter(Boolean);</span></pre><h1 id="3cca" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">10.展平数组的数组</h1><p id="26e9" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">原型<code class="fe mo mp mq mr b">Array</code>上有一个方法<code class="fe mo mp mq mr b">flat</code>，可以让你从数组的数组中生成一个数组:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="16d3" class="mw ls it mr b gy mx my l mz na">const myArray = [{ id: 1 }, [{ id: 2 }], [{ id: 3 }]];</span><span id="c918" class="mw ls it mr b gy nb my l mz na">const flattedArray = myArray.flat(); <br/>// returns [ { id: 1 }, { id: 2 }, { id: 3 } ]</span></pre><p id="d07e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还可以定义深度级别，指定嵌套数组结构应展平的深度。例如:</p><pre class="kj kk kl km gt ms mr mt mu aw mv bi"><span id="abcd" class="mw ls it mr b gy mx my l mz na">const arr = [0, 1, 2, [[[3, 4]]]];</span><span id="b0d9" class="mw ls it mr b gy nb my l mz na">console.log(arr.flat(2)); // returns [0, 1, 2, [3,4]]</span></pre></div><div class="ab cl nd ne hx nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="im in io ip iq"><p id="59cc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢阅读到最后。我希望这些技巧对你有用。为了我和其他人，请随意在评论中添加任何你自己的JavaScript技巧！</p><h1 id="647f" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">更多5个惊人的JavaScript技巧</h1><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/5-cool-modern-javascript-features-most-developers-dont-know-6baf19b532da"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">大多数开发人员不知道的5个很酷的现代JavaScript特性</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">用JavaScript写得更少，做得更多</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">better编程. pub</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ks nn"/></div></div></a></div><h1 id="eefe" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">多看我的文章</h1><div class="nk nl gp gr nm nn"><a href="https://haseeb-anwar.medium.com/react-router-6-features-upgradation-guide-886b9bc2fb71" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">React路由器6功能和升级指南</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">迄今为止最强大的React客户端路由器</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">haseeb-anwar.medium.com</p></div></div><div class="nw l"><div class="oc l ny nz oa nw ob ks nn"/></div></div></a></div><div class="nk nl gp gr nm nn"><a rel="noopener  ugc nofollow" target="_blank" href="/the-complete-guide-to-oauth-2-0-and-openid-connect-protocols-35ebc1cbc11a"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd iu gy z fp ns fr fs nt fu fw is bi translated">OAuth 2.0和OpenID连接协议完全指南</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">了解最广泛使用的身份验证和授权协议是如何工作的</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">better编程. pub</p></div></div><div class="nw l"><div class="od l ny nz oa nw ob ks nn"/></div></div></a></div></div></div>    
</body>
</html>