<html>
<head>
<title>The Strong, The Weak, and the Unowned Self in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯威夫特笔下的强者、弱者和无主的自我</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-strong-the-weak-and-the-unowned-self-in-swift-1795d8e7b990?source=collection_archive---------12-----------------------#2020-01-15">https://betterprogramming.pub/the-strong-the-weak-and-the-unowned-self-in-swift-1795d8e7b990?source=collection_archive---------12-----------------------#2020-01-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="3270" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">了解自我的三个层次，它们如何影响弧线，以及自我和自我之间的区别</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/7c21c139a695b1761d18648f22b1f3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kL15QEznTdkomlzC"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@aloragriffiths?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿洛拉·格里菲斯</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="d3ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">很久以前，在一个遥远的地方，Swift团队决定<code class="fe lw lx ly lz b">self</code>可以有三种形式——<code class="fe lw lx ly lz b">strong</code>、<code class="fe lw lx ly lz b">weak</code>或<code class="fe lw lx ly lz b">unowned</code>。这完全取决于用例以及您有多喜欢或讨厌内存泄漏！在接下来的几节中，我们将介绍这三个部分。但在此之前，让我们后退一步，从一个不同的角度来看<code class="fe lw lx ly lz b">self</code>。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="956e" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">什么是自我？</h1><p id="8cd5" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">拿起一面镜子，看着它。你看到了什么？这就是自我…不，不是反映，不完全是！<code class="fe lw lx ly lz b">self</code>是你所指的实例的等价形式。每个类和结构都有self作为指向自身的隐式属性。</p><p id="dad8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它类似于Java中的<code class="fe lw lx ly lz b">this</code>,但显著的区别是Swift的<code class="fe lw lx ly lz b">self</code>几乎可以在任何地方使用——Java的<code class="fe lw lx ly lz b">this</code>只在实例方法的范围内使用。</p><p id="888b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然self可以在任何地方应用来访问类和结构的属性和方法，但最佳实践是仅在必要时使用它，否则忽略它。</p><p id="707b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这里有两个需要使用<code class="fe lw lx ly lz b">self.</code>的场景</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="2738" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">1.区分初始化器中的属性名和参数名</h1><p id="e869" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated"><code class="fe lw lx ly lz b">self</code>对于区分方法参数和实例属性名称是至关重要的，以防止歧义。</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="b583" class="ni mi iu lz b gz nj nk l nl nm">class Author{<br/>  let name: String<br/><br/>  init(name: String) {<br/>    self.name = name<br/>  <br/>  }<br/>}</span></pre><p id="3429" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的例子中省略<code class="fe lw lx ly lz b">self</code>会给Swift编译器造成歧义——它会把两个变量都只当作参数。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="5c4f" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">2.内部封闭</h1><p id="2380" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">引用闭包内的属性需要显式使用<code class="fe lw lx ly lz b">self</code>属性来表明您正在捕获封闭类型的实例。作为一种类型安全语言，Swift有意引入了这种设计，以表明在闭包发生之前不会释放<code class="fe lw lx ly lz b">self</code>属性。</p><p id="ce6c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，在之前编写的<code class="fe lw lx ly lz b">Author</code>类中，我们添加了一个调用闭包的函数，如下所示:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="3a29" class="ni mi iu lz b gz nj nk l nl nm">class Author{<br/>  <br/>  func greetName(){</span><span id="b08b" class="ni mi iu lz b gz nn nk l nl nm">DispatchQueue.main.asyncAfter(deadline: .now() + 2) {<br/>          print(self.name)<br/>      }<br/>  }<br/>}</span></pre><p id="3306" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果在没有<code class="fe lw lx ly lz b">self</code>的情况下访问<code class="fe lw lx ly lz b">name</code>属性，Swift编译器会抱怨。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="c4f6" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">强引用</h1><p id="135c" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">默认情况下，我们到目前为止一直提到的<code class="fe lw lx ly lz b">self</code>是强的。任何属性都被隐式标记为强。自动引用计数(ARC)负责跟踪和处理应用程序的内存，为不再使用的实例释放空间。</p><p id="eabd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">只要实例持有活动引用，ARC就不会释放它。例如，如果两个类互相持有强引用，就会产生引用循环，导致内存泄漏。</p><p id="3697" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下图显示了实例未被释放的保留周期示例:</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj no"><img src="../Images/e8797315fc317714c439a996f5f46293.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4F-Byz3sSosQrgyrhfp3XA.png"/></div></div></figure><p id="143e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你在上面的类中，或者在协议和委托中处理父子关系时，你可以很容易地结束这样的保持周期。</p><p id="cb85" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我们看到闭包从封闭上下文中捕获了自我。当闭包的生存期超过封闭类的生存期时会发生什么？我们将在下一节处理<code class="fe lw lx ly lz b">weak</code>和<code class="fe lw lx ly lz b">unowned</code>引用时讨论这个问题。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="11d6" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">弱引用</h1><p id="5cdb" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">为了防止保持周期，我们可以将引用中的任何一个标记为<code class="fe lw lx ly lz b">weak</code>，这意味着这种关系并不牢固。ARC了解这一点，不会在其保留计数中考虑该引用，从而允许它在没有任何限制的情况下被解除分配。</p><p id="b29b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">除了<code class="fe lw lx ly lz b">self</code>，任何属性或变量都可以通过设置<code class="fe lw lx ly lz b">weak</code>关键字来设置为弱引用。在释放期间，属性被ARC标记为nil。这也表明弱引用不能是非可选的。</p><h2 id="28c7" class="ni mi iu bd mj np nq dn mn nr ns dp mr lj nt nu mt ln nv nw mv lr nx ny mx nz bi translated">用封闭处理脆弱的自我</h2><p id="ed97" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">闭包被设计成从封闭范围中捕获它所使用的属性，无论是<code class="fe lw lx ly lz b">self</code>还是任何其他类/结构引用。为了防止闭包超过封闭类的生存期时产生保留周期(从而保持对实例的强引用),我们将使用捕获列表来定义关系绑定的类型。</p><p id="6de7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">捕获列表会创建封闭属性的副本。在下面的代码片段中，我们将看到将自我捕获为弱者是如何避免内存泄漏的:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="b9e5" class="ni mi iu lz b gz nj nk l nl nm">class Writer {<br/>    var <strong class="lz iv">myClosure</strong>: (() -&gt; ())?<br/>    let name: String<br/>    init(name: String) {<br/>        self.name = name<br/>        self.myClosure = {<br/>            <strong class="lz iv">[weak self] in</strong><br/>            print("Writer is \(self<strong class="lz iv">?</strong>.name)") <br/>        }<br/>    }<br/>    <br/>    deinit { print("Writer \(name) is being deallocated") }<br/>}</span><span id="0cca" class="ni mi iu lz b gz nn nk l nl nm">var writer : Writer? = Writer(name: "Anupam")<br/>writer = nil //this gets deallocated</span></pre><p id="fe75" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在上面的代码中，没有将self捕获为弱不能允许实例<code class="fe lw lx ly lz b">writer</code>被释放，并且闭包中的两个print语句都不会被打印。理想情况下，为了避免在弱的时候到处使用<code class="fe lw lx ly lz b">self?</code>，我们可以使用一个guard语句，如下所示:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="7bfb" class="ni mi iu lz b gz nj nk l nl nm">self.myClosure = {<br/>            [weak self] in<strong class="lz iv"><br/>            </strong><strong class="lz iv">guard let self = self else { return }</strong><br/>            print("Writer is \(self.name)") <br/>}</span></pre><p id="f109" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，我们可以在方括号中捕获多个参数:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="d313" class="ni mi iu lz b gz nj nk l nl nm">[weak self, weak arg2, unowned arg3] </span></pre><p id="6093" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们进入最后一个项目<code class="fe lw lx ly lz b">unowned</code>。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="c29b" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">无主参考文献</h1><p id="42cb" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">无主引用只是弱引用，不能用弧<strong class="lc iv">标记为零。</strong>因此所有的无主引用都是<strong class="lc iv">非可选的</strong>，只有在你确定实例没有被释放时才应该使用。小心处理无主引用至关重要。当实例为零时访问它们会导致崩溃。</p><p id="16eb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您应该使用unowned而不是weak的一个常见用例是当您希望避免使用optional。</p></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="c610" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">自我对自我</h1><p id="7954" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">到目前为止，我们已经讨论了<code class="fe lw lx ly lz b">self</code>及其不同的形式。除了基本上是一个属性的<code class="fe lw lx ly lz b">self</code>之外，我们还有另一个关键字<code class="fe lw lx ly lz b">Self</code>，它表示一致性协议或协议扩展的类型。</p><p id="9c93" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">下面的代码演示了如何使用<code class="fe lw lx ly lz b">Self</code>和<code class="fe lw lx ly lz b">self</code>来展示它们之间的不同:</p><pre class="kk kl km kn gu ne lz nf ng aw nh bi"><span id="cec6" class="ni mi iu lz b gz nj nk l nl nm">extension String{<br/>    func greetMe() -&gt; <strong class="lz iv">Self</strong> {<br/>        return "Hello \(self)"<br/>    }<br/>}</span><span id="6120" class="ni mi iu lz b gz nn nk l nl nm">let str = String.greetMe("Anupam")<br/>str() //prints: Hello Anupam</span></pre></div><div class="ab cl ma mb hy mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="in io ip iq ir"><h1 id="b81d" class="mh mi iu bd mj mk ml mm mn mo mp mq mr ka ms kb mt kd mu ke mv kg mw kh mx my bi translated">结论</h1><p id="cf40" class="pw-post-body-paragraph la lb iu lc b ld mz jv lf lg na jy li lj nb ll lm ln nc lp lq lr nd lt lu lv in bi translated">与life不同，在Swift中使用强引用可能是有害的，并会导致保留周期。为了解决这个问题，我们可以用关键字<code class="fe lw lx ly lz b">weak</code>和<code class="fe lw lx ly lz b">unowned</code>来标记引用。任何引用类型都可以用这些关键字来标记。像结构这种属于值类型的东西不能被标记为<code class="fe lw lx ly lz b">weak</code>或<code class="fe lw lx ly lz b">unowned</code>。</p><p id="27c9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这一次到此为止。我希望你构建无内存泄漏的iOS和macOS应用程序。感谢阅读。</p></div></div>    
</body>
</html>