<html>
<head>
<title>JavaScript Internals: Execution Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript内部:执行上下文</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-internals-execution-context-bdeee6986b3b?source=collection_archive---------6-----------------------#2019-08-13">https://betterprogramming.pub/javascript-internals-execution-context-bdeee6986b3b?source=collection_archive---------6-----------------------#2019-08-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="853e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">调用堆栈中存储了什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c9695276dd15e7ea40f766988b5b55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ImUyFdFVnJPr8IM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伊瓦·拉乔维奇在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="2257" class="kz la it bd lb lc ld le lf lg lh li lj jz lk ka ll kc lm kd ln kf lo kg lp lq bi translated">介绍</h1><p id="5dcc" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在这篇文章中，我们将看看JavaScript最重要和最基本的部分之一，执行上下文。我们将定义一个上下文的结构，它的生命周期，以及执行栈(调用栈)是如何形成的。<br/>之后，我们将处理提升、范围和闭包等臭名昭著的概念。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c93e" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">执行上下文</h1><p id="5e2c" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">ECMAScript代码有三种类型:全局代码、函数代码和eval <em class="mz"> </em>代码(本文不涉及)。每个代码都在其自己的执行上下文<em class="mz"> t </em>中进行评估。</p><p id="82f1" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">执行上下文是一个描述代码执行环境的概念。简单地说，它只是一组由<a class="ae ky" href="https://medium.com/better-programming/javascript-internals-under-the-hood-of-a-browser-f357378cc922" rel="noopener"> JavaScript引擎在运行时</a>创建和使用的对象。</p><p id="572b" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在JavaScript引擎开始执行脚本文件之前，会创建全局执行上下文。不属于函数体的每一行代码都是全局代码。这样的代码在全局上下文中执行，每个程序只能有一个全局上下文。</p><p id="ffac" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在全局代码的执行期间，JavaScript引擎可以到达函数调用指令。当发生这种情况时，创建函数执行上下文并执行函数代码。</p><p id="cd4c" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">因此，可以说一个执行上下文可以创建另一个执行上下文，即一个函数调用另一个函数(或者全局上下文调用一个函数)，等等。这些创建的上下文一起形成了执行堆栈。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b913" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">执行堆栈</h1><p id="28cd" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">执行堆栈也称为调用堆栈，是一种后进先出(LIFO)的数据结构。它由JavaScript引擎创建和管理，用于在运行时存储执行上下文。</p><p id="ce77" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">创建(<em class="mz">调用</em>)另一个上下文的上下文称为<em class="mz">调用方</em>。正在创建的上下文被称为<em class="mz">被调用者</em>。</p><p id="5ae9" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">当调用方创建被调用方时，调用方暂停其执行，并将控制流传递给被调用方。被调用方被推送到堆栈上，并成为一个正在运行的(活动的)执行上下文。在被调用方的代码被完全执行后，它将控制权返回给调用方，调用方的上下文评估继续进行(它可能会激活其他上下文)直到结束，依此类推。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/00163de6904ca40eb4d49089b388165e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dUl6qPEaDJJTXWythQsEtQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行堆栈</p></figure><p id="0a86" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在上面的例子中，全局执行上下文被创建并放到堆栈上。然后在每次函数调用时，函数执行上下文被创建并放到堆栈上。在函数完全执行后，它的上下文将从堆栈中移除。</p><p id="bf38" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">JavaScript是一种单线程语言。引擎总是执行位于执行堆栈顶部的函数。</p><p id="b10d" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">现在我们知道在JavaScript中有两种主要的执行上下文类型——全局和<em class="mz"> </em>函数。它们由JavaScript引擎创建，并存储在执行堆栈(调用堆栈)中。他们的目标是描述代码执行的环境。</p><p id="82bc" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">你可能想知道<em class="mz">环境</em>到底是什么意思。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b257" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">执行上下文结构</h1><p id="b903" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">首先，我们需要定义执行上下文的结构。它可以表示为具有三个属性的对象:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/b2aa0711eecfd4f2f2f9cd3da2b4c3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eVEn_McEiRMdmpm_1IrGKg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行上下文结构</p></figure><p id="6c41" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">让我们弄清楚每个属性的含义，然后讨论上下文创建和执行步骤。</p><h2 id="3713" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">这个绑定</h2><p id="2396" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在全局执行上下文中，<code class="fe nt nu nv nw b">this</code>保存对全局对象的引用。在浏览器中，它是一个<code class="fe nt nu nv nw b">window</code>对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/818431d62b511b01478bd55d31f89cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ex53t60kYQsaWe7PBH17HA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe nt nu nv nw b">ThisBinding</code>在全球执行背景下</p></figure><p id="4d17" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在函数执行上下文中，<code class="fe nt nu nv nw b">this</code>的值取决于如何调用函数。如果它作为一个对象的方法被调用，<code class="fe nt nu nv nw b">this</code>的值被设置为该对象。否则，<code class="fe nt nu nv nw b">this</code>的值被设置为全局对象或<code class="fe nt nu nv nw b">undefined</code>(在严格模式下)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/8c879dcef12845ed1c3db23ca453222b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GF-L1ZC06m9Xtx82g-4UJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数执行上下文中的ThisBinding</p></figure><p id="f76e" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">使用箭头函数时，<code class="fe nt nu nv nw b">this</code>完全不绑定。它只是从父执行上下文(被调用方)继承而来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/8ee935ff6673a45e65c1f40331e6dca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbgKHGaOgbwkE7puQOmaQg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">箭头函数中的这种绑定</p></figure><h2 id="40a7" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">词汇环境</h2><p id="fee0" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">词汇环境由两个条目组成:</p><ul class=""><li id="6722" class="nx ny it lt b lu na lx nb ma nz me oa mi ob mm oc od oe of bi translated">环境记录——一种将标识符映射到其相关词汇环境范围内的值的结构。此类记录存储用<code class="fe nt nu nv nw b">let</code>或<code class="fe nt nu nv nw b">const</code>关键字声明的标识符的值。</li><li id="91f7" class="nx ny it lt b lu og lx oh ma oi me oj mi ok mm oc od oe of bi translated">外部引用—保存对父词法环境的引用。这意味着JavaScript引擎可以在外部环境中寻找变量，如果在当前的词法环境中找不到的话。</li></ul><p id="4f53" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在全局执行上下文中，<em class="mz"> </em> <code class="fe nt nu nv nw b">outer</code> <em class="mz"> </em>引用被设置为<code class="fe nt nu nv nw b">null</code>。在环境记录中，嵌入的语言实体(如对象、数组等)以及您定义的全局变量都是可用的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/d1a74d6b0d520bd57ba003267fbc021f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozBhx7CpDygt46tqMTX_2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">全局执行上下文(词汇环境)</p></figure><p id="1b7d" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在函数执行上下文中，<code class="fe nt nu nv nw b">outer</code>引用被设置为父词法环境。它可以是全局上下文，也可以是函数上下文，这取决于调用函数的位置。用户在函数中声明的变量存储在它的环境记录和类似于<code class="fe nt nu nv nw b">arguments</code>数组的对象中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/7d46010389314032c4af7eeaaca7f5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bAXtfP1As7SgirxmFlgsQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数执行上下文(词汇环境)</p></figure><h2 id="838e" class="nh la it bd lb ni nj dn lf nk nl dp lj ma nm nn ll me no np ln mi nq nr lp ns bi translated">可变环境</h2><p id="402e" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">ECMA-262规格<a class="ae ky" href="http://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts" rel="noopener ugc nofollow" target="_blank"> sais </a>:</p><blockquote class="om on oo"><p id="29b9" class="lr ls mz lt b lu na ju lw lx nb jx lz op nc mc md oq nd mg mh or ne mk ml mm im bi translated">执行上下文的词汇环境和变量环境组件始终是词汇环境。Variable Environment标识词法环境，其EnvironmentRecord保存由VariableStatements在此执行上下文中创建的绑定。</p></blockquote><p id="a39b" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">换句话说，变量环境在其执行上下文中存储用<code class="fe nt nu nv nw b">var</code>关键字声明的标识符-值映射。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="d468" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">上下文创建和执行</h1><p id="8742" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">在JavaScript中，每个执行上下文有两个独立的阶段:创建阶段<strong class="lt iu"> </strong>和执行阶段。</p><p id="79b0" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在创建阶段，<code class="fe nt nu nv nw b">window</code>和<code class="fe nt nu nv nw b">this</code>被创建(如果我们在全局上下文中)，环境记录中的变量声明被赋予默认值<code class="fe nt nu nv nw b">undefined</code>(或<code class="fe nt nu nv nw b">uninitialized</code>)，每个函数声明都被完全放入内存中。</p><p id="8de7" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">一旦我们进入执行阶段，JavaScript引擎就开始逐行执行代码，并将实际值赋给已经存在于内存中的变量。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/4016e5ec2f2fbd3786940dfa76254d2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SBP65hdVDW5j0LuVryTiXw.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">执行上下文阶段</p></figure><p id="056e" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">在创建阶段，用<code class="fe nt nu nv nw b">let</code>和<code class="fe nt nu nv nw b">const</code>关键字声明的变量被赋予默认值<code class="fe nt nu nv nw b">uninzialized</code>。这就是为什么，当你试图访问这样的变量时，你会得到<code class="fe nt nu nv nw b">ReferenceError</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ae8561741e630a3caccd6662c032f11b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3jSbbSV98gBCCB8qDwzyA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">参考误差</p></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="25ee" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">范围、提升和关闭</h1><p id="7c1f" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">知道了上下文的结构及其生命周期，我们就可以很容易地理解提升、范围和闭包的含义。</p><p id="f868" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated"><strong class="lt iu">提升</strong>就是在创建阶段给变量声明赋一个默认值，并将函数声明放入内存的过程。在你的代码中实际上什么也没有移动。</p><p id="72b9" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated"><strong class="lt iu">闭包</strong>是从堆栈中移除函数的执行上下文后，将函数的词法环境保存在内存中的一种方式。闭包让您可以从内部函数访问外部函数的词法环境。只需在另一个函数中定义一个函数，然后返回它或传递给另一个函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/b628611d53c88eb41f5143ebe8fb52a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*D6OGwvOh2qFqCWcYqiknZQ.gif"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">JavaScript闭包</p></figure><p id="90fe" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">范围只是谈论词汇环境的另一种方式。它就像一个边界，定义了在当前执行上下文中可以访问哪些变量。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="97da" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">结论</h1><p id="8189" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">现在，您应该对JavaScript引擎执行代码时发生的事情、执行上下文和执行堆栈中存储的数据、变量和函数的提升方式以及它们的值是如何确定的有了更好的理解。</p><p id="7c52" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">写JavaScript代码不需要这么深入的知识。但是它有助于理解像提升和闭包这样的概念，这些概念在开发中是常用的。</p><p id="790a" class="pw-post-body-paragraph lr ls it lt b lu na ju lw lx nb jx lz ma nc mc md me nd mg mh mi ne mk ml mm im bi translated">请点击拍手👏，如果上面的文章对你有帮助。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a294" class="kz la it bd lb lc mu le lf lg mv li lj jz mw ka ll kc mx kd ln kf my kg lp lq bi translated">参考</h1><p id="b78b" class="pw-post-body-paragraph lr ls it lt b lu lv ju lw lx ly jx lz ma mb mc md me mf mg mh mi mj mk ml mm im bi translated">http://www.ecma-international.org/ecma-262/10.0/index.html<a class="ae ky" href="http://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="os ot l"/></div></figure><div class="ou ov gp gr ow ox"><a href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">JavaScript。核心。</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">阅读这篇文章:日语，德语，俄语，法语，波兰语。注意:本文的第二版现已推出…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">dmitrysoshnikov.com</p></div></div></div></a></div><div class="ou ov gp gr ow ox"><a href="https://habr.com/ru/company/ruvds/blog/422089/" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">выполнения，вызовов</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">вы - JavaScript-разработчик、стать、это значит、что、нужно разбираться</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">habr.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>