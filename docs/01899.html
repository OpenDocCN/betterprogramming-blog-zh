<html>
<head>
<title>Using Signals to Handle Unix Commands in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Golang中使用信号处理Unix命令</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/using-signals-to-handle-unix-commands-in-golang-f09e9efb7769?source=collection_archive---------8-----------------------#2019-10-21">https://betterprogramming.pub/using-signals-to-handle-unix-commands-in-golang-f09e9efb7769?source=collection_archive---------8-----------------------#2019-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="baaf" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习使用内置的Go特性来处理Unix命令</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8ceecdd9ba74a7aa5303203b95caf32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzzqu2SUm-Ri7X0GsBXokA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@harshaldesai?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">哈沙尔·德赛</a>在<a class="ae ky" href="https://unsplash.com/s/photos/signal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="953f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接受和处理来自操作系统的信号对于应用程序中的各种用例都很重要。</p><p id="e708" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然许多服务器端语言有复杂或乏味的方法来处理来自操作系统的信号，但Golang应用程序非常直观。Golang的内置操作系统包提供了一种简单的方法来集成和响应来自Go应用程序的Unix信号。让我们看看怎么做。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1c74" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">前提</h1><p id="0897" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们想要构建一个Golang应用程序，当被请求关闭时，它会打印一条消息说，“感谢您使用Golang。”让我们设置<code class="fe mz na nb nc b">main</code>函数，它基本上一直做一些工作，直到向应用程序提供一个退出命令。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1cb4" class="nh md it nc b gy ni nj l nk nl">func main() {<br/>   for {<br/>      fmt.Println("Doing Work")<br/>      time.Sleep(1 * time.<em class="nm">Second</em>)<br/>   }<br/>}</span></pre><p id="7e4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您运行这个应用程序并通过从您的操作系统提供一个kill信号(大多数情况下是<code class="fe mz na nb nc b">Ctrl + C</code>或<code class="fe mz na nb nc b">Ctrl + Z</code>)来终止它时，您可能会看到类似下面的输出:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="a74d" class="nh md it nc b gy ni nj l nk nl">Doing Work<br/>Doing Work<br/>Doing Work</span><span id="e62c" class="nh md it nc b gy nn nj l nk nl">Process finished with exit code 2</span></pre><p id="892a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们将在Golang应用程序中解释这个kill信号，并处理它以打印出所需的退出消息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6b5d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">接收信号</h1><p id="a518" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将创建一个<code class="fe mz na nb nc b">channel</code>来接收来自操作系统的命令。操作系统包提供了处理信号的<code class="fe mz na nb nc b">Signal</code>接口，并有特定于操作系统的实现。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="fa20" class="nh md it nc b gy ni nj l nk nl">killSignal := make(chan os.Signal, 1)</span></pre><p id="909e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了通知<code class="fe mz na nb nc b">killSignal</code>，我们使用<code class="fe mz na nb nc b">signal</code>包提供的<code class="fe mz na nb nc b">Notify</code>函数。第一个参数接受一个<code class="fe mz na nb nc b">os.Signal</code>的通道，而接下来的参数接受一个我们想要通知通道的OS信号列表。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c40c" class="nh md it nc b gy ni nj l nk nl">signal.Notify(killSignal, os.Interrupt)</span></pre><p id="8735" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以使用<code class="fe mz na nb nc b">syscall</code>包用特定的命令通知我们的信号。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="5bf6" class="nh md it nc b gy ni nj l nk nl">signal.Notify(killSignal, syscall.<em class="nm">SIGINT</em>, syscall.<em class="nm">SIGTERM</em>)</span></pre><p id="d202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理信号，我们将使我们的<code class="fe mz na nb nc b">main</code>功能块使用<code class="fe mz na nb nc b">killSignal</code>通道等待<code class="fe mz na nb nc b">interrupt</code>信号。在收到来自操作系统的命令时，我们将打印退出消息并终止应用程序。</p><p id="f432" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了处理我们的工作循环，让我们使用匿名函数将它移到一个单独的<code class="fe mz na nb nc b">goroutine</code>中。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0b00" class="nh md it nc b gy ni nj l nk nl">go func() {<br/>   for {<br/>      fmt.Println("Doing Work")<br/>      time.Sleep(1 * time.<em class="nm">Second</em>)<br/>   }<br/>}()</span></pre><p id="6c57" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当工作功能在单独的程序中运行时，<code class="fe mz na nb nc b">main</code>功能将等待<code class="fe mz na nb nc b">killSignal</code>并在退出前打印退出信息。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8784" class="nh md it nc b gy ni nj l nk nl">&lt;-killSignal<br/>fmt.Println("Thanks for using Golang!")</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4577" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">代码</h1><p id="b730" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将所有组件放在一起，最终代码是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在运行时，它继续执行工作循环，并在收到来自操作系统的<code class="fe mz na nb nc b">interrupt</code>信号时，打印所需的消息，然后退出。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="0293" class="nh md it nc b gy ni nj l nk nl">Doing Work<br/>Doing Work<br/>Doing Work<br/>Thanks for using Golang!</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0b6d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="142d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个简单的例子可以推广到处理许多现实生活中的场景，比如优雅地关闭服务器和在命令行应用程序中接收命令。</p></div></div>    
</body>
</html>