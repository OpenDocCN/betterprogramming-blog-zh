<html>
<head>
<title>Making SwiftUI Previews Work For You</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让SwiftUI预览为您服务</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/making-swiftui-previews-work-for-you-6e54f46afbf?source=collection_archive---------4-----------------------#2021-11-03">https://betterprogramming.pub/making-swiftui-previews-work-for-you-6e54f46afbf?source=collection_archive---------4-----------------------#2021-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c565" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何充分利用SwiftUI预览——即使是依赖于数据库中保存的数据(如Realm或Core Data)的视图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bc4ea40312dcc3338eb0df0c8f90c2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tGJCxbpme32ZcmGT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><h1 id="09c3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="7e58" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">画布预览是SwiftUI的一项重要功能。当您创建一个新视图时，一半的样板代码是用于预览的。预览会占用您Xcode空间的三分之一。</p><p id="73b7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">尽管这个特性很突出，但许多开发人员只是从他们的视图中删除预览代码，并依赖模拟器。</p><p id="12ce" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在Xcode过去的版本中(包括Xcode 13测试版)，不愿意使用预览是可以理解的。它们会莫名其妙地失败，错误消息也难以理解。</p><p id="3017" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我从一开始就坚持预览，但有时，他们觉得比他们值得更多的努力。但是，对于Xcode 13，我认为我们应该在所有视图中使用它们。我特别注意到:</p><ul class=""><li id="0fce" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">他们更可靠。</li><li id="3bcf" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">错误消息终于有了意义。</li><li id="9195" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">支持横向模式。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/7e392334215072016b8ff0731b80be2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f245DJoYrOe18OgF.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="f573" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我认为预览有点像你的视图的UI单元测试。像单元测试一样，需要一些额外的前期工作，但是在生产率和质量方面你会得到很大的回报。</p><p id="af3b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我将介绍:</p><ul class=""><li id="5588" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">您可以在预览中检查的内容(考虑亮/暗模式、不同的设备、风景模式等。)以及如何去做。</li><li id="4f20" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">减少预览中需要的样板代码的数量。</li><li id="1858" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">为有状态应用程序编写预览。(我将使用<a class="ae kv" href="https://realm.io/" rel="noopener ugc nofollow" target="_blank">领域</a>，但是同样的方法也可以用于核心数据。)</li><li id="ad7f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">排除预览故障。</li></ul><p id="ad25" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我不会讨论的一个特性是使用预览作为编辑视图的图形化方式。SwiftUI最大的吸引力之一是用代码编写一切，而不需要故事板和XML文件。为SwiftUI使用拖放式视图构建器对我没有吸引力。</p><p id="5004" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我在本文中使用的95%的例子都是基于一个21点培训应用程序。你可以在<a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer" rel="noopener ugc nofollow" target="_blank">回购</a>中找到最终版本。</p><h1 id="e437" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">先决条件</h1><ul class=""><li id="3150" class="mp mq iq lq b lr ls lu lv lx ne mb nf mf ng mj mu mv mw mx bi translated">Xcode 13+</li><li id="aac9" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">iOS 15+版本</li><li id="f648" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">可可王国10.17.0以上</li></ul><p id="23c2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">注意:</p><ul class=""><li id="92ae" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">我使用过Xcode 13和iOS 15，但本文中的大多数示例都适用于旧版本。</li><li id="b0ee" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">在横向模式下预览是Xcode 13中的新功能。</li><li id="66fb" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><code class="fe nh ni nj nk b">buttonStyle</code>修改器只有iOS 15才有。</li><li id="03b2" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">我用的是Realm-Cocoa 10.17.0，但是更早的10。x版本很可能行得通。</li></ul><h1 id="9e82" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用预览</h1><p id="346d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">预览可让您查看视图的外观，而无需在模拟器或物理设备中运行。当您编辑视图的代码时，它的预览会实时更新。</p><p id="1ca2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">本节展示了您可以预览的方面，以及如何进行预览。</p><h2 id="3cd5" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">超级简单的预览</h2><p id="016c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当您创建新的Xcode项目或SwiftUI视图时，Xcode会自动添加预览代码。你只需要按下“继续”按钮(或CMD-Alt-P):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/bb8e4ee7e7cc6c22d3cc846656805a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*4IriXYbqQxwMXxsm.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">作者图片</p></figure><p id="1682" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">预览代码总是具有相同的结构，需要预览的<code class="fe nh ni nj nk b">View</code>(本例中为<code class="fe nh ni nj nk b">ContentView</code>)在<code class="fe nh ni nj nk b">previews</code> <code class="fe nh ni nj nk b">View</code>内:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="eef4" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">需要参数的视图</h2><p id="92e2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">大多数视图都需要封闭视图传入参数。您的预览也必须这样做——如果您忘记了，您将得到一个构建错误。</p><p id="b4b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我的<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/Decision%20Matrix/ResetButton.swift" rel="noopener ugc nofollow" target="_blank">ResetButton</a></code>视图要求调用者提供两个值- <code class="fe nh ni nj nk b">label</code>和<code class="fe nh ni nj nk b">resetType</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="327c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">预览代码需要传入这些值，就像任何嵌入视图一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="6896" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">需要<code class="fe nh ni nj nk b">Binding</code> s的视图</h2><p id="f5a4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在一个聊天应用程序中，我有一个<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/LiveTutorial2021/blob/main/iOS/LiveChat/LiveChat/Views/LoginView.swift" rel="noopener ugc nofollow" target="_blank">LoginView</a></code>，它从封闭视图中更新过去的<code class="fe nh ni nj nk b">username</code>绑定:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5be9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在预览中创建绑定的最简单方法是使用<code class="fe nh ni nj nk b">constant</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="e821" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">导航视图</h2><p id="e9e4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在您的视图层次结构中，您只在单个级别添加了一个<code class="fe nh ni nj nk b">NavigationView</code>。然后<code class="fe nh ni nj nk b">NavigationView</code>包装所有子视图。</p><p id="f3f7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当预览这些子视图时，您可能关心也可能不关心<code class="fe nh ni nj nk b">NavigationView</code>功能。例如，如果您的预览在<code class="fe nh ni nj nk b">NavigationView</code>中包裹视图，您将只能在顶部导航栏中看到标题和按钮。</p><p id="6e53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果我预览我的<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/PracticeView.swift" rel="noopener ugc nofollow" target="_blank">PracticeView</a></code>而没有添加一个<code class="fe nh ni nj nk b">NavigationView</code>，那么我看不到标题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/f2dbd25471031aae06312b68a0a89892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*M0X0Upt74G7acKbe.png"/></div></div></figure><p id="15e6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了预览标题，我的预览代码需要将<code class="fe nh ni nj nk b">PracticeView</code>包装在<code class="fe nh ni nj nk b">NavigationView</code>中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/2891a1c90973b962aa5a3e6f7dab8114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TgvSAyopo3haSvBo.png"/></div></div></figure><h2 id="0552" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">较小的视图</h2><p id="6a32" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有时，您不需要在整个设备屏幕的背景下预览视图。我的显示一张扑克牌。在整个设备屏幕上预览只会浪费桌面空间:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/98b0314c14e08ac01b4ae2824e9e2bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CGKh4vEHyIsdsW0M.png"/></div></div></figure><p id="8c7b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以添加<code class="fe nh ni nj nk b">previewLayout</code>修饰符来表示我们只想预览一个足够大的视图区域。添加一些<code class="fe nh ni nj nk b">padding</code>通常也是有意义的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/82c9d4ef47b9a7038b7bb0f01449f930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nUFu106Zsdokl-S7.png"/></div></div></figure><h2 id="63f2" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">亮暗模式</h2><p id="0df5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当你最终在黑暗模式下测试你的应用程序时，你可能会大吃一惊。如果在实现每个视图时没有考虑亮/暗模式，那么结果可能会很难看，甚至无法使用。</p><p id="d058" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">救援预演！</p><p id="f00a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">回到<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/CardView.swift" rel="noopener ugc nofollow" target="_blank">CardView</a></code>，我可以使用<code class="fe nh ni nj nk b">preferredColorScheme</code>视图修改器在黑暗模式下预览一张卡片:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9762de96438447fb2ba8e7cdd940a136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*umY5qzKFZGFRotPm.png"/></div></div></figure><p id="d76a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这看起来不错，但是如果我预览一把铁锹呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/f39d27f927bc92d38411e1dd4642b41c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6QYm4zfXN0oBHE0a.png"/></div></div></figure><p id="63ca" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这可能是个问题。</p><p id="c36f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在视图中添加白色背景可以解决这个问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/c3b3a5e61faf1e51fc6427e912ba4533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eb6pIM8phuPw1mcR.png"/></div></div></figure><h2 id="4ddb" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">预览多个视图实例</h2><p id="4988" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">有时，预览视图的单个实例并不能描绘全貌。看看我在卡片视图中启用黑暗模式时得到的惊喜吧。在黑暗和光明模式下同时预览红桃和黑桃不是更好吗？</p><p id="99e7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以使用<code class="fe nh ni nj nk b">Group</code>视图为同一个视图创建多个预览:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/eb1fd93e9ce95453e44dd6e400a54785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eIW80DLZnSM0EtyF.png"/></div></div></figure><h2 id="e2dd" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">在预览中合成视图</h2><p id="de80" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">孤立地预览单个视图可能看起来不错，但在更广泛的背景下会是什么样子呢？</p><p id="1bb6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">预览单个<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/Decision%20Matrix/DecisionCell.swift" rel="noopener ugc nofollow" target="_blank">DecisionCell</a></code>视图看起来很棒:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/c7665fa3cf22c14e58ef88fd84737c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fbUZ-FNbSAq0Lesh.png"/></div></div></figure><p id="4cee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是，应用程序永远不会显示一个<code class="fe nh ni nj nk b">DecisionCell</code>。他们会一直在一个格子里。此外，文本、背景颜色和边框因州而异。为了创建更真实的预览，我在视图中创建了一些样本数据，然后使用垂直和水平堆栈合成了多个<code class="fe nh ni nj nk b">DecisionCell</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6330" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">然后我可以看到黑色边框在黑暗模式下不太好用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9ce059337e052f82ddde79c74ce75131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_hcpprtJZP5wW3Br.png"/></div></div></figure><p id="8a6d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">将边框颜色从<code class="fe nh ni nj nk b">black</code>切换到<code class="fe nh ni nj nk b">primary</code>很快解决了这个问题:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/80ab243e967b2a2093cb5b0a9ffd959a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tEpU5ijZp9ci_ujC.png"/></div></div></figure><h2 id="31a7" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">横向模式</h2><p id="f34e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">预览默认为纵向模式。使用<code class="fe nh ni nj nk b">previewInterfaceOrientation</code>修改器以横向模式预览:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/d07f03c2b7c40e8199a89f07a6e162a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*db8PS2IGBShCIBBz.png"/></div></div></figure><h2 id="23cb" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">设备类型</h2><p id="2349" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">预览默认为您在Xcode中选择的模拟器设备。你可能希望你的应用能在多种设备上运行良好。通常，我发现要让我为iPhone设计的应用程序在iPad上运行良好，还需要做额外的工作。</p><p id="ed2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nh ni nj nk b">previewDevice</code>修饰符让我们指定在预览中使用的设备类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/4f59dd9c804efb14c01d4b73450101b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*56tgxZ-vSmYVk39w.png"/></div></div></figure><p id="444f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">您可以从Xcode的模拟器菜单中找到可用设备的名称，或者使用<code class="fe nh ni nj nk b">xcrun simctl list devices</code>从终端中找到。</p><h2 id="8a65" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">锁定视图</h2><p id="0e70" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在预览区域的左下角，有一个大头针按钮。按下此按钮会“锁定”当前预览，这样当您浏览其他视图的代码时，它仍会显示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/14e1768c4cd3e17d5238a29e1e0a9390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eeCa6kyCy-uEWvex.png"/></div></div></figure><p id="b14c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当您编辑子视图的代码时，这有助于观察父视图是如何变化的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/a6170c774bef6ff84d571c30ca506b70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*t6L_iVeMsq3o1Nfu.gif"/></div></figure><h2 id="6625" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">实时预览</h2><p id="2866" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本文的开始，我对预览和单元测试进行了比较。实时预览意味着你真的可以孤立地测试你的视图(准确地说，你测试的视图加上它嵌入或链接的所有视图)。</p><p id="5fa7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">按预览上方的播放按钮进入实时模式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/095ce39dc9a614f393ada1e9b28c1f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*40VKr0-69IsvKhtv.png"/></div></div></figure><p id="fb74" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在，您可以与您的视图进行交互:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/2624ad9db242e94c19fccc36a2f657da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*1jhm7-pMt_NQ0gL6.gif"/></div></figure><h1 id="7e9b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">去除多余的样板预览代码</h1><p id="2385" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你可能已经注意到了，我的一些预览现在比实际视图有更多的代码。这不一定是个问题，但是有很多重复的样板代码被多个视图使用。不仅如此，您还将在其他项目的预览中嵌入相同的样板代码。</p><p id="ac55" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了简化我的预览代码，我创建了几个视图生成器。它们都遵循相同的模式——接收一个<code class="fe nh ni nj nk b">View</code>，并返回一个从那个<code class="fe nh ni nj nk b">View</code>构建的新的<code class="fe nh ni nj nk b">View</code>。</p><p id="608f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我以<code class="fe nh ni nj nk b">_Preview</code>开始每个视图构建器的名称，以便于利用Xcode的代码完成特性。</p><h2 id="9fae" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">亮/暗模式</h2><p id="ac2c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Preview%20Content/Custom%20Previews/_PreviewColorScheme.swift" rel="noopener ugc nofollow" target="_blank">_PreviewColorScheme</a></code>返回视图副本的<code class="fe nh ni nj nk b">Group</code>。一个是亮模式，另一个是暗模式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="8b6b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在预览中使用这个视图生成器，只需传入您正在预览的<code class="fe nh ni nj nk b">View</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/5f9aa460789443c917041fe5b6a40507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LZBJYM_TGp-QbySw.png"/></div></div></figure><h1 id="797d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">方向</h1><p id="2335" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Preview%20Content/Custom%20Previews/_PreviewOrientation.swift" rel="noopener ugc nofollow" target="_blank">_PreviewOrientation</a></code>返回一个包含纵向和横向模式下原始<code class="fe nh ni nj nk b">View</code>的<code class="fe nh ni nj nk b">Group</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6c7f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在预览中使用这个视图生成器，只需传入您正在预览的<code class="fe nh ni nj nk b">View</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/fd7351a12282060f80bab405a895d368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*me7j8ssmETCgS28W.png"/></div></div></figure><h2 id="d7ed" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">没有设备</h2><p id="62ff" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Preview%20Content/Custom%20Previews/_PreviewNoDevice.swift" rel="noopener ugc nofollow" target="_blank">_PreviewNoDevice</a></code>返回通过添加<code class="fe nh ni nj nk b">previewLayout</code>修饰符和添加“填充”到输入视图构建的视图:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="63fb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在预览中使用这个视图构建器，只需传入您正在预览的<code class="fe nh ni nj nk b">View</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/0e8215b3317c1c09caf0e984154cc9d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pS7YbvZDZoHCZOiw.png"/></div></div></figure><h2 id="dea3" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">多个设备</h2><p id="b411" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Preview%20Content/Custom%20Previews/_PreviewDevices.swift" rel="noopener ugc nofollow" target="_blank">_PreviewDevices</a></code>返回一个<code class="fe nh ni nj nk b">Group</code>，包含每种设备类型的<code class="fe nh ni nj nk b">View</code>的副本。您可以修改代码中的<code class="fe nh ni nj nk b">devices</code>,以包含您想要查看预览的设备:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="52b1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我对添加太多设备持谨慎态度，因为这会使任何使用此视图生成器的预览变慢并消耗资源。</p><p id="64d3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要在预览中使用这个视图生成器，只需传入您正在预览的<code class="fe nh ni nj nk b">View</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/ea610d09e4e8f4e18bb827e512bb714a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*c3vnmB3KrUgJGZmq.png"/></div></div></figure><h2 id="d223" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">组合多个视图构建器</h2><p id="822e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">每个视图构建器接收一个视图并返回一个新视图。这意味着您可以通过将一个视图构建器的结果传递给另一个视图构建器来组合函数。在极端情况下，您可以在同一个视图预览中使用最多三个:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6a73" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这产生了12个视图，涵盖了方向、外观和设备的所有排列。</p><p id="6ba1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于每个视图，您应该考虑哪些修饰符增加了价值。对于<code class="fe nh ni nj nk b">CardView</code>，使用<code class="fe nh ni nj nk b">_PreviewNoDevice</code>和<code class="fe nh ni nj nk b">_PreviewColorSchem</code> e是有意义的，但是在不同的设备和方向上预览不会增加任何价值。</p><h1 id="ff4c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">预览状态视图(领域)</h1><p id="82d8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">通常，SwiftUI视图会从数据库中获取状态，比如领域或核心数据。要做到这一点，数据库中需要有数据。</p><p id="bd08" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">预览可以在嵌入式iOS模拟器上有效运行。这有助于解释为什么它们比“预览”功能更慢、更强大。这也意味着每个预览还包含一个领域数据库(假设您使用的是<a class="ae kv" href="https://github.com/realm/realm-cocoa" rel="noopener ugc nofollow" target="_blank"> Realm-Cocoa SDK </a>)。预览可以将数据存储在数据库中，而查看者可以访问该数据。</p><p id="ba0a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在BlackJack training应用程序中，每个玩家/庄家的手牌组合要采取的行动存储在Realm中。例如，<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/Decision%20Matrix/DefaultDecisionView.swift" rel="noopener ugc nofollow" target="_blank">DefaultDecisionView</a></code>使用<code class="fe nh ni nj nk b">@ObservedResults</code>从领域中访问数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="fcda" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了确保预览视图可以找到数据，预览会检查领域数据库是否已经包含数据(<code class="fe nh ni nj nk b">Decisions.areDecisionsPopulated</code>)。如果没有，则添加所需数据(<code class="fe nh ni nj nk b">Decisions.bootstrapDecisions()</code>):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="5f22" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nh ni nj nk b">DefaultDecisionView</code>嵌入在<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/Decision%20Matrix/DecisionMatrixView.swift" rel="noopener ugc nofollow" target="_blank">DecisionMatrixView</a></code>中，因此<code class="fe nh ni nj nk b">DecisionMatrixView</code>的预览也必须有条件地填充领域数据。反过来，<code class="fe nh ni nj nk b">DecisionMatrixView</code>被嵌入到<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/PracticeView.swift" rel="noopener ugc nofollow" target="_blank">PracticeView</a></code>中，而<code class="fe nh ni nj nk b">PracticeView</code>被嵌入到<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/ContentView.swift" rel="noopener ugc nofollow" target="_blank">ContentView</a></code>中——因此，他们也需要引导领域数据，以便它可以在视图层次结构中进一步使用。</p><p id="f5e5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是引导函数的实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="3590" class="nl kx iq bd ky nm nn dn lc no np dp lg lx nq nr li mb ns nt lk mf nu nv lm nw bi translated">分区、同步的领域</h2><p id="16e6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">21点训练应用程序使用独立的领域数据库。但是如果应用程序正在使用<a class="ae kv" href="https://docs.mongodb.com/realm/sync/" rel="noopener ugc nofollow" target="_blank">领域同步</a>会发生什么？</p><p id="3b2e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一种选择是让SwiftUI preview与您的后端领域服务同步数据。我认为这有点太复杂了，它打破了我将预览视为视图单元测试的范式。</p><p id="1839" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我发现最简单的解决方案是让视图知道它是由预览还是由正在运行的应用程序创建的。我将解释它是如何工作的。</p><p id="1dda" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Views/Chat%20Messages/AuthorView.swift" rel="noopener ugc nofollow" target="_blank">AuthorView</a></code>从<a class="ae kv" href="https://github.com/realm/RChat/" rel="noopener ugc nofollow" target="_blank"> RChat </a>应用程序从领域获取数据:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d917" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它的预览代码引导嵌入式领域:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="3d5a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">该应用程序添加了bootstrap作为Realm的扩展:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9ce0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">复杂的是，<code class="fe nh ni nj nk b">AuthorView</code>嵌入了<code class="fe nh ni nj nk b"><a class="ae kv" href="https://github.com/realm/RChat/tree/main/RChat-iOS/RChat/Views/Chat%20Messages" rel="noopener ugc nofollow" target="_blank">ChatBubbleView</a></code>。为了让应用程序工作，<code class="fe nh ni nj nk b">ChatBubbleView</code>必须将同步的领域配置传递给<code class="fe nh ni nj nk b">AuthorView</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="a9cf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">但是</strong>在预览<code class="fe nh ni nj nk b">ChatBubbleView</code>的时候，我们希望<code class="fe nh ni nj nk b">AuthorView</code>使用预览的本地、嵌入式领域(不依赖于一个领域后端app)。这意味着<code class="fe nh ni nj nk b">ChatBubbleView</code>必须检查它是否作为预览的一部分运行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="686a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">预览然后负责引导本地领域，并标记给<code class="fe nh ni nj nk b">ChatBubbleView</code>它是一个预览:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h1 id="6f0b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">预览疑难解答</h1><p id="b308" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如本文开头提到的，预览失败的错误信息在Xcode 13中实际上很有用。</p><p id="6baa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是好消息。</p><p id="d696" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">坏消息是你仍然不能使用断点或者打印到控制台。</p><p id="db6c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一个缓解是您预览中的<code class="fe nh ni nj nk b">previews</code>静态var是一个<code class="fe nh ni nj nk b">View</code>。这意味着您可以用您的<code class="fe nh ni nj nk b">previews</code>代码替换您的<code class="fe nh ni nj nk b">ContentView</code>的<code class="fe nh ni nj nk b">body</code>。然后，您可以在模拟器中运行应用程序，并添加断点或打印到控制台。使用这种方法感觉很奇怪，但我还没有找到更好的选择。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><h1 id="adfe" class="kw kx iq bd ky kz op lb lc ld oq lf lg jw or jx li jz os ka lk kc ot kd lm ln bi translated">结论</h1><p id="ed9a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我对SwiftUI预览有着复杂的关系。</p><p id="f78a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当它们工作时，它们是一个很好的工具，让你更快地写出你的观点。预览允许您对视图进行单元测试。预览可帮助您避免应用程序在黑暗或风景模式下运行或在不同设备上运行时出现的问题。</p><p id="4019" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是，它们需要努力构建。在Xcode 13之前，由于可靠性问题，很难证明这种努力是正确的。</p><p id="a28c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我相信Xcode 13是一个转折点，在那里效率和质量的提高远远超过了编写预览代码的努力。这就是我现在写这篇文章的原因。</p><p id="b49a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，您看到了许多让预览尽可能有用的技巧。我提供了四个视图构建器，您可以将其直接复制到SwiftUI项目中，让您用最少的代码构建最好的预览。最后，您看到了如何为视图编写预览，这些视图使用数据库中的数据，如Realm或Core数据。</p><p id="fcb1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">请在<a class="ae kv" href="https://www.mongodb.com/community/forums/c/realm-sdks/58" rel="noopener ugc nofollow" target="_blank">领域社区论坛</a>中提供反馈并提出任何问题。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="d486" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="ou">最初发表于</em><a class="ae kv" href="https://www.mongodb.com/developer/how-to/swiftui-previews" rel="noopener ugc nofollow" target="_blank">T5【https://www.mongodb.com】</a><em class="ou">。</em></p></div></div>    
</body>
</html>