<html>
<head>
<title>An API Project From an Android Developer’s Perspective</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从一个Android开发者的角度看一个API项目</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-api-project-from-an-android-developers-perspective-97ae5d9f110b?source=collection_archive---------14-----------------------#2022-09-07">https://betterprogramming.pub/an-api-project-from-an-android-developers-perspective-97ae5d9f110b?source=collection_archive---------14-----------------------#2022-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="33bf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">启动API的指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/861a54814e694942fe433c18ac94c683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PvvhMopw0X2x3IZE"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@nadineshaabana" rel="noopener ugc nofollow" target="_blank">纳丁·沙巴娜</a>——<a class="ae kv" href="https://unsplash.com/photos/UBvF7tGcLdg" rel="noopener ugc nofollow" target="_blank">Unsplash</a>拍摄</p></figure><p id="7106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">据我的后端开发朋友说，对我来说最简单的方法是使用<a class="ae kv" href="https://www.typescriptlang.org" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>在<a class="ae kv" href="https://nodejs.org" rel="noopener ugc nofollow" target="_blank"> NodeJS </a>中开始编写服务器应用程序。</p><p id="5b8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">奇怪的是，NodeJS没有运行类型脚本代码的方法，只有JavaScript，所以我们需要将类型脚本代码转换为JavaScript，这被称为“<a class="ae kv" href="https://stackoverflow.com/questions/44931479/compiling-vs-transpiling" rel="noopener ugc nofollow" target="_blank"> Transpiling </a>”</p><p id="4760" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于IDE，我试了两个工具:<a class="ae kv" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>和<a class="ae kv" href="https://www.jetbrains.com/webstorm" rel="noopener ugc nofollow" target="_blank"> WebStorm </a>。网络风暴是我的最爱。用起来方便很多，因为我习惯了Android Studio。两者都是JetBrains的产品，所以有相似的开发者体验。</p><h1 id="f1fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">项目结构</h1><p id="93c4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在服务器应用程序中有很多方法来组织你的文件，我将向你展示一种我发现更类似于Android项目的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/9785ee3c51dd4fc2f908b7afd1424700.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*gmxdpgM-jHyBivrC9DfI9g.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">项目结构图</p></figure><p id="0257" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在我们作为Android开发人员的知识和之前的图片之间建立联系:</p><ul class=""><li id="3eb8" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">从Android开发者的角度来看,<code class="fe mz na nb nc b">package.json</code>是<code class="fe mz na nb nc b">build.gradle</code>和<code class="fe mz na nb nc b">AndroidManifest.xml</code>的融合。我们需要在这个文件中定义:应用程序名称、应用程序版本、应用程序启动的主文件、一些脚本(如Gradle tasks)、依赖项、开发依赖项等。</li><li id="7e2a" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">__test__</code>是我们放置单元测试的目录。在服务器端，我使用Jest作为框架。这是Android开发者眼中的JUnit</li><li id="a4de" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><code class="fe mz na nb nc b">jest.config.js</code>是我们定义测试配置和运行方式的地方</li><li id="bd78" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">src是我们对代码进行分组的地方，类似于我们的主应用程序模块</li></ul><h1 id="0f1d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">体系结构</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/bce31614419550fd479b8c449fdf1976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*EdckjX_eviIOfWtP8XvBwQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">架构图</p></figure><h1 id="4004" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">入口点</h1><p id="9409" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在服务器端，我们有路由，而不是活动或片段作为入口点。我们没有用户可以触摸的UI，但是应用程序(在本例中是我们的用户)将调用路线。我们有不同的路径:GET、POST、PUT和其他。我将展示一个路线示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将Express与自定义路由器对象一起使用的基本配置。</p></figure><p id="b881" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> Express </a>是一个框架，允许我们简单地创建路线。如您所见，<code class="fe mz na nb nc b">app.ts</code>文件正在导入已经由<code class="fe mz na nb nc b">historic.routes.ts</code>文件定义的<code class="fe mz na nb nc b">historyRoutes</code>(下一个代码)。我们有一个委托给特定控制器的POST方法的例子，控制器将请求转发给特定的用例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">处理POST请求的特定控制器对象。</p></figure><h1 id="dba9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">依赖注入</h1><p id="72eb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你喜欢Android世界里的<a class="ae kv" href="https://insert-koin.io" rel="noopener ugc nofollow" target="_blank"> Koin </a>或者<a class="ae kv" href="https://github.com/kosi-libs/Kodein" rel="noopener ugc nofollow" target="_blank"> Kodein </a>，用<a class="ae kv" href="https://github.com/microsoft/tsyringe" rel="noopener ugc nofollow" target="_blank"> TSyringe </a>做依赖注入库会非常容易。</p><p id="fd2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的代码显示了一个<code class="fe mz na nb nc b">server.ts</code>文件，我们在其中为实现<code class="fe mz na nb nc b">ISisOrgRepository</code>接口的<code class="fe mz na nb nc b">FirestoreDataSource</code>注册了一个单例引用。这个文件就像我们的<code class="fe mz na nb nc b">Application</code>类。这个文件是我们应用程序的入口点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">添加应用程序存储库的实例(它将可用于整个应用程序)。</p></figure><p id="19fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">TSyringe</code>知道某人是否需要<code class="fe mz na nb nc b">ISisOrgRepository</code>的引用，应该提供<code class="fe mz na nb nc b">FirestoreDataSource</code>实例。在这种情况下，类<code class="fe mz na nb nc b">CreateNewHistoricEntryController</code>需要创建<code class="fe mz na nb nc b">CreateNewHistoricEntryUseCase</code>，但是为此，需要请求<code class="fe mz na nb nc b">TSyringe</code>来解析依赖关系(<code class="fe mz na nb nc b">ISisOrgRepository</code>构造函数参数)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有一些注释的UseCase有助于依赖注入库。</p></figure><p id="8dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的<code class="fe mz na nb nc b">CreateNewHistoricEntryController</code>中，我们可以请求依赖注入库来帮助创建我们的<code class="fe mz na nb nc b">CreateNewHistoricEntryUseCase</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">控制器要求使用容器用例引用。</p></figure><h1 id="d8ef" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">试验</h1><p id="4f83" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我试了两个库:<a class="ae kv" href="https://jasmine.github.io" rel="noopener ugc nofollow" target="_blank">茉莉</a>和<a class="ae kv" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank"> Jest </a>。他们非常相似。由于漂亮的输出报告，我最终使用了Jest。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/dfe6f1d57d1be51536f279129babcf0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*S98NCvNd1Ukb2tkmiT4KrQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">截图Jest execution的精彩报道。</p></figure><p id="5872" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语法与使用Kotlin的JUnit测试非常不同，但是如果您将“describe”作为测试套件名称，将“it”作为单元测试名称，这一点就很清楚了。断言部分是直观的，似乎我们在使用<a class="ae kv" href="https://truth.dev" rel="noopener ugc nofollow" target="_blank">真值</a>库。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nj nk l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在TypeScript中使用Jest的测试示例— TimeHelper类</p></figure><h1 id="86c2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终提示</h1><ul class=""><li id="9945" class="mq mr iq ky b kz mk lc ml lf nm lj nn ln no lr mv mw mx my bi translated">Heroku 是举办API的好地方。CLI很容易使用，如果您的<code class="fe mz na nb nc b">package.json</code>状态良好，CLI将在您每次推送代码时自动为您运行脚本(传输文件、安装依赖项、启动服务器)</li><li id="c8f6" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><a class="ae kv" href="https://insomnia.rest" rel="noopener ugc nofollow" target="_blank">失眠</a>是测试你路线的绝佳工具。您还可以创建不同的环境(开发、生产……)</li><li id="a4b8" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated">Swagger允许我们创建丰富的文档。您可以运行文档中的路线(此处的示例<a class="ae kv" href="https://petstore.swagger.io" rel="noopener ugc nofollow" target="_blank">为</a>)。</li></ul><h1 id="8876" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="469e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你开始使用新技术，与有经验的人进行技术讨论会很有帮助，因为热门技巧可以节省大量时间，缩短学习曲线🤗。</p></div></div>    
</body>
</html>