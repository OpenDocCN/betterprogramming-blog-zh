<html>
<head>
<title>6 Tips for Better Core Data Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高核心数据性能的6个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/6-tips-for-better-core-data-performance-d7ff8fc07f36?source=collection_archive---------7-----------------------#2020-06-02">https://betterprogramming.pub/6-tips-for-better-core-data-performance-d7ff8fc07f36?source=collection_archive---------7-----------------------#2020-06-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="aec2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我们从数百万人使用的应用程序中的核心数据中学到了什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/957167ac7db26fbea391f7b91b9dd146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uVdjMyUII07FXGfv"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@fabioha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比奥</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="da27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在编写核心数据代码时考虑性能有助于为您的应用做好未来准备。您的数据库在开始时可能很小，但它很容易增长，从而导致查询速度慢和用户体验差。</p><p id="950e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从2017年开始写WeTransfer  app的<a class="ae ky" href="https://collect.bywetransfer.com/" rel="noopener ugc nofollow" target="_blank"> Collect开始，我就一直在写很多核心数据相关的代码，几乎每天都要接触。随着数百万用户添加大量内容，执行核心数据相关代码已经成为我们团队的一项重要技能。</a></p><p id="4e27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">多年来，我们已经形成了许多见解，我很高兴分享你应该知道的六个技巧。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="865f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.利用后台管理的对象上下文</h1><p id="0437" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们从一开始就没有做的一件事是利用后台托管对象上下文。我们只使用视图上下文来执行任何与核心数据相关的任务:插入新内容、删除内容、获取内容等。</p><p id="06ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">刚开始的时候，我们的app比较小。仅仅利用视图上下文并不是一个真正的问题，也不会导致任何与核心数据相关的明显的性能损失。显然，一旦我们的应用程序开始增长，我们就意识到视图上下文与主队列相关联。缓慢的查询阻塞了我们的用户界面，我们的应用程序响应变得更慢。</p><p id="3a56" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，最佳实践是在后台队列上执行数据处理，因为这可能会占用大量CPU资源。像将JSON导入核心数据这样的例子可能会阻塞视图上下文，导致用户界面无响应。</p><p id="ba4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是利用后台管理的对象上下文。最新的API使得从持久容器创建新的上下文变得容易:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ff66" class="ne md it na b gy nf ng l nh ni">let backgroundContext = persistentContainer.newBackgroundContext()</span></pre><p id="f35b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我推荐这个方法而不是<code class="fe nj nk nl na b">NSManagedObjectContext(concurrenyType:)</code>初始化器，因为它将自动与<code class="fe nj nk nl na b">NSPersistentStoreCoordinator</code>相关联，并将被设置为消费<code class="fe nj nk nl na b">NSManagedObjectContextDidSave</code>广播。这使您的背景上下文与视图上下文保持同步。</p><p id="67d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以将这个后台上下文保存在一个自定义的持久容器子类中。这样，您可以重用您的后台上下文，并且只需管理两个上下文。这使您的核心数据结构易于理解，并防止出现多个不同步的上下文。</p><p id="87fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您只需要在少数地方使用背景上下文，那么您也可以决定使用<code class="fe nj nk nl na b">performBackgroundTask(_:)</code>方法来就地创建背景上下文:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="7ddd" class="ne md it na b gy nf ng l nh ni">persistentContainer.performBackgroundTask { (backgroundContext) in<br/>    // .. Core Data Code<br/>}</span></pre><p id="8131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这个方法每次被调用时都会创建一个新的<code class="fe nj nk nl na b">NSManagedObjectContext</code>。如果您更频繁地调度到后台上下文，您可能需要考虑使用共享的后台上下文。</p><h2 id="81dd" class="ne md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">不要在队列之间传递NSManagedObject实例</h2><p id="a520" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">编写多线程核心数据代码比使用单一视图上下文复杂得多。这是因为您不能简单地将从视图上下文实例化的<code class="fe nj nk nl na b">NSManagedObject</code>传递给后台上下文。这样做会导致崩溃和潜在的数据损坏。</p><p id="94a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当需要将一个托管对象从一个队列移动到另一个队列时，您可以使用<code class="fe nj nk nl na b">NSManagedObjectID</code>，它是线程安全的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="efd7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.仅在需要时保存托管对象上下文</h1><p id="c2da" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">保存托管对象上下文会将所有当前更改提交给上下文的父存储。可以想象，这不是一个廉价的操作，只有在需要确保核心数据的性能时才应该使用。</p><p id="2045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，重要的是检查是否有任何东西可以保存。如果没有要提交的更改，也没有理由执行保存。通过创建一个<code class="fe nj nk nl na b">saveIfNeeded</code>方法，您可以让自己轻松地检查这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><h2 id="fd80" class="ne md it bd me nm nn dn mi no np dp mm li nq nr mo lm ns nt mq lq nu nv ms nw bi translated">仔细考虑何时保存您的更改</h2><p id="d8e1" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">除了用<code class="fe nj nk nl na b">saveIfNeeded</code>代替<code class="fe nj nk nl na b">save()</code>，你还需要考虑一个保存是否有意义。尽管上下文可能已经更改，但直接提交这些更改并不总是必要的。</p><p id="b3fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果您要将多个项目导入到数据库中，您可能只想在后台上下文中导入所有项目后进行保存。保存之后通常是UI更新，一个接一个的多次保存很容易导致不必要的重新加载。除此之外，要考虑到在后台上下文中保存的更改被合并到视图上下文中，很快也会阻塞主队列。所以，一定要自觉！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fbd6" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.只取你需要的东西</h1><p id="6a2b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">获取数据是一项昂贵的任务，需要尽可能地提高性能，以使您的应用程序为大型数据集做好准备。以下代码是一个常见错误:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="72eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码会将所有插入的对象加载到内存中，同时过滤带有名称的内容。</p><p id="a95c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用谓词只获取需要的对象更有效。上面的过滤器可以用一个<code class="fe nj nk nl na b">NSPredicate</code>写成:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="b591" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这有两个优点:</p><ul class=""><li id="878d" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">只有需要的对象才会被加载到内存中。</li><li id="9575" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">你不需要迭代所有的对象。</li></ul><p id="f05c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谓词非常灵活，应该允许您在大多数情况下获取所需的数据集，同时保持核心数据的性能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d1ff" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.利用提取限制</h1><p id="565e" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">继续前面的例子，当您只打算显示数据集的一部分时，设置获取限制是很重要的。</p><p id="e920" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设您只需要所有内容项的前三个名称。在这种情况下，没有必要将所有具有名称的内容项加载到内存中。我们可以通过设置获取限制来防止这种情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="2ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码将只返回带有名称的前三个内容项。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fc60" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.使用NSBatchDeleteRequest一次删除多个对象</h1><p id="6a47" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与其遍历数据集逐个删除每个对象，不如使用运行速度更快的<code class="fe nj nk nl na b">NSBatchDeleteRequest</code>,因为它在持久存储本身的SQL级别运行。</p><p id="6407" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以在我以前写的一篇文章中了解更多关于批量删除请求的信息。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6c1f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">6.知道如何调试核心数据代码</h1><p id="78d0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">与您编写的所有代码一样，重要的是知道一旦代码的性能不如预期时如何优化和调试它。有许多调试的方法，在我的博客文章中有很好的解释。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9369" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4203" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">从一开始就编写高性能的核心数据代码有助于您为未来的大型数据集准备应用程序。尽管您的应用程序可能在开始时运行良好，但一旦您的数据库和模型增长，它很容易就会变慢。通过利用后台上下文、智能获取请求和批量删除请求，您已经使核心数据代码的性能更高了。</p><p id="4e78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>