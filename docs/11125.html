<html>
<head>
<title>Display Cryptocurrency Prices Using Paging 3 Library and Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Paging 3库和Jetpack Compose显示加密货币价格</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/list-of-cryptocurrencies-using-paging-3-library-with-jetpack-compose-bd502e18ba4?source=collection_archive---------5-----------------------#2022-02-20">https://betterprogramming.pub/list-of-cryptocurrencies-using-paging-3-library-with-jetpack-compose-bd502e18ba4?source=collection_archive---------5-----------------------#2022-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ead" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建基于干净架构的Android应用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ce3e06e1a57a5599601e3863b50aa16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NSbeaW-jWG3NbQkd"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@kanchanara?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Kanchanara </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个示例应用程序，演示了使用<a class="ae kv" href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview" rel="noopener ugc nofollow" target="_blank">分页3库</a>和<a class="ae kv" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank"> Jetpack编写</a>。该应用程序基于Bob叔叔的干净架构方法。还有，我用过科特林(当然)，流，MVVM，匕首刀柄。</p><p id="a5e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">GitHub上知识库的链接:<a class="ae kv" href="https://github.com/mrvictorr/cryptopagingapp" rel="noopener ugc nofollow" target="_blank">https://github.com/mrvictorr/cryptopagingapp</a></p><h2 id="6d18" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">关于什么应用</strong></h2><p id="d300" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我选择了目前最热门的话题之一。我的应用程序显示了加密货币的列表。作为一个加密价格提供商，我使用过<a class="ae kv" href="https://messari.io/api/docs" rel="noopener ugc nofollow" target="_blank"> Messari api </a>。这是它的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/5f8eb8e32586c1dbbff26ac65c3c7460.png" data-original-src="https://miro.medium.com/v2/resize:fit:648/format:webp/1*nP6cBNZVHNARun-DQid42A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">加密货币列表</p></figure><h1 id="1640" class="mr lt iq bd lu ms mt mu lx mv mw mx ma jw my jx md jz mz ka mg kc na kd mj nb bi translated"><strong class="ak">项目设置</strong></h1><p id="e35b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">向<code class="fe nc nd ne nf b">build.gradle</code>文件添加合成和分页所需的依赖关系。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="924d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">匕首柄的依赖(依赖注入):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1322" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过添加<em class="ni"> HiltAndroidApp </em>注释来设置刀柄的应用文件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="cfc0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">架构概述</h2><p id="b38f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">应用程序分为数据层、域层和表示层。干净架构的主要思想是通过保持业务规则对外部世界一无所知来分离关注点。如果你不熟悉这个概念，我强烈建议你深入研究一下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/996ebdadef4993161c153e512be2b223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*DoB41J8JZcekXvhE_nMhsg.png"/></div></figure><p id="bf09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一节中，我将解释这个应用程序的实现。<br/>让我们从<strong class="ky ir">数据</strong>层开始。我们从服务器上加载数据。下面是函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f5e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">再来看<code class="fe nc nd ne nf b">AssetsDataSource</code> <em class="ni">。这个类负责加载数据并缓存在变量中。在数据源中，我们只有一个函数加载下一页并保存在缓存中。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="7c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nc nd ne nf b">getAssets</code> <em class="ni"> </em>函数是从<code class="fe nc nd ne nf b">AssetsRepositoryImpl</code><em class="ni"/><em class="ni">类中调用的。</em>界面位于<code class="fe nc nd ne nf b">AssetsRepository</code> <em class="ni"> </em>域中。这是我们如何对领域层隐藏存储库实现的最重要的技巧。</p><p id="2244" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在域<strong class="ky ir"> </strong>层中，我们有<code class="fe nc nd ne nf b">GetAssetsSource</code> <em class="ni"> </em>类，它取代了我们架构中的交互器。<br/><strong class="ky ir"/>层基本上是MVVM模式。</p><p id="212d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我将详细解释表示层和领域层。</p><h2 id="2585" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">分页源</h2><p id="05f3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/paging/PagingSource" rel="noopener ugc nofollow" target="_blank">从某个来源提取可分页静态数据的基类，其中加载数据页通常是一项开销很大的操作。</a></p><p id="684a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该创建一个<code class="fe nc nd ne nf b">PagingSource</code>类的子类来传递数据给我们的列表。有两个函数必须被覆盖</p><pre class="kg kh ki kj gt nk nf nl nm aw nn bi"><span id="32e3" class="ls lt iq nf b gy no np l nq nr">fun load (params: PagingSource.LoadParams&lt;Int&gt;)</span></pre><p id="edc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和</p><pre class="kg kh ki kj gt nk nf nl nm aw nn bi"><span id="9171" class="ls lt iq nf b gy no np l nq nr">fun getRefreshKey(state: PagingState&lt;Int, AssetDomain&gt;)</span></pre><p id="3cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的神奇都发生在<code class="fe nc nd ne nf b">load</code> <em class="ni"> </em>函数中，在这里我们从<code class="fe nc nd ne nf b">AssetsRepository</code> <em class="ni"> </em>类中调用我们的<code class="fe nc nd ne nf b">getAssets</code>函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="7f65" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">在表示层设置分页</h2><p id="763e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">首先，我们转到<code class="fe nc nd ne nf b">AssetsListViewModel</code>。在<code class="fe nc nd ne nf b">getAssets()</code>函数中，我们从<code class="fe nc nd ne nf b">GetAssetsSource</code> <em class="ni"> </em>中创建一个页面对象，并将其转换成流。在<code class="fe nc nd ne nf b">init</code>中，函数将<code class="fe nc nd ne nf b">PagingData</code>对象流传递给状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="47cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在<code class="fe nc nd ne nf b">AssetsListScreen</code> <em class="ni"> </em>中，我们可以从ViewModel中收集状态作为<code class="fe nc nd ne nf b">PagingItems</code>，并在我们的列表中使用它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="2874" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用Jetpack撰写的用户界面</h2><p id="668f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们就从<code class="fe nc nd ne nf b">AssetListItem</code>开始吧<em class="ni">。在这里，我们可以找到绿色形状、名称和价格的符号。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="afe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nc nd ne nf b">AssetsListScreen</code> <em class="ni"> </em>中，我们仅使用<code class="fe nc nd ne nf b">LazyColumn</code>显示项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="f892" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望这个故事能帮到你。</p><p id="3f9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读，祝您有美好的一天:)</p></div></div>    
</body>
</html>