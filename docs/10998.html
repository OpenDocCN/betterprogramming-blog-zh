<html>
<head>
<title>From Code Source to Execution — Here’s How Programming Languages Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从代码源到执行——以下是编程语言的工作原理</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/from-code-source-to-execution-heres-how-programming-languages-work-ee7d114a2f1e?source=collection_archive---------13-----------------------#2022-02-09">https://betterprogramming.pub/from-code-source-to-execution-heres-how-programming-languages-work-ee7d114a2f1e?source=collection_archive---------13-----------------------#2022-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="49ac" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编程语言是如何工作的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/841de1cbdc34ecde070409de148ca9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hX4XCnkTZm5DGMuM"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">安吉尔·孟山都三世在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="baa1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你有没有想过在编程语言下它是如何工作的？编译器如何正确理解我们的代码？机器(计算机)是如何正确无误地执行我们的代码的？</p><p id="fc5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">“适当地，正确地，准确地”暗示没有错误，没有损失，没有修改。</p><p id="eb2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了回答这些问题，我们将尝试制作一个名为<code class="fe lv lw lx ly b">H#</code>的小型编程语言，并经历编译器通常会做的所有步骤。</p><p id="d6a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但在此之前，我们先从故事的结尾说起:机器(计算机)能理解什么样的代码？</p><h1 id="20f5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">机器说什么语言？</h1><p id="9c05" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">机器意味着硬件，硬件意味着电路。计算机内部的电路只有两种状态:开和关。</p><p id="8541" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么如何才能把软件和硬件联系起来呢？<br/>这很容易，因为有两个神奇的数字(位)‘1’和‘0’，这两个数字是计算机电路开关状态的同义词(<a class="ae ky" href="https://en.wikipedia.org/wiki/Boolean_algebra" rel="noopener ugc nofollow" target="_blank">布尔代数</a>)。</p><blockquote class="mw mx my"><p id="5037" class="kz la mz lb b lc ld ju le lf lg jx lh na lj lk ll nb ln lo lp nc lr ls lt lu im bi translated"><a class="ae ky" href="https://icarus.cs.weber.edu/~dab/cs1410/textbook/1.Basics/machine.html" rel="noopener ugc nofollow" target="_blank">机器码</a>由一系列简单的计算机指令组成，每条指令用一串二进制数字或比特表示(即1和0)。</p></blockquote><blockquote class="nd"><p id="e784" class="ne nf it bd ng nh ni nj nk nl nm lu dk translated">值得注意的是，该机器可以是您的计算机，也可以是在您的计算机上运行的虚拟机，如Java虚拟机，因为虚拟机使用主机的资源并在其中执行。</p></blockquote><p id="a540" class="pw-post-body-paragraph kz la it lb b lc nn ju le lf no jx lh li np lk ll lm nq lo lp lq nr ls lt lu im bi translated">然而，现在很少有人用数字机器代码编程，因为很难使用它。</p><p id="8875" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，为了使开发人员的工作更容易，在这个最低级别的表示之上，编程语言提供了不同的高级抽象层。</p><p id="6b9c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为第一级抽象，我们可以引用汇编代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/77f8f1170f323d75826480086e96d39a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-fFQ_qXY9FHfpRivy_z7uA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编程语言抽象层次(图片由作者提供)</p></figure><p id="133c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个层次上，我们理解了机器(计算机)所理解的东西，我认为编译器要做什么是很明显的，你不这样认为吗？</p><p id="04dd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器的作用是让人类世界和机器世界兼容。让机器理解人类的指令(愿望)。完美！</p><p id="6851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在进入编译器之前，让我们从定义和展示我们将要开发的编程语言开始！</p><h1 id="9da2" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">语言定义</h1><p id="85fe" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们将开发一种叫做<code class="fe lv lw lx ly b">H#</code>的小型编程语言:</p><ul class=""><li id="c48b" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">像人类语言一样，编程语言由一个<code class="fe lv lw lx ly b">dictionary</code>和一个<code class="fe lv lw lx ly b">grammar</code>组成。</li><li id="9399" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">dictionary</code>定义了组成语言的一组单词(记号)。</li><li id="5f5a" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><code class="fe lv lw lx ly b">grammar</code>检查单词的组合是否正确。</li></ul><p id="2948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我们当前的语言只允许:</p><ul class=""><li id="bb9a" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">定义类型化变量</li><li id="1d68" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">执行简单的算术运算</li><li id="2224" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">定义和使用函数</li><li id="96a9" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">在控制台中显示消息</li></ul><p id="5b3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他规格:</p><ul class=""><li id="514c" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">单词分隔符将是<code class="fe lv lw lx ly b">space</code></li><li id="6263" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">语句分隔符将是分号<code class="fe lv lw lx ly b">;</code></li><li id="5035" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">每条语句都应该另起一行</li><li id="2828" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">区分大小写</li><li id="b8ce" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">评论以<code class="fe lv lw lx ly b">//</code>开头</li><li id="c982" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">缩进并不重要</li></ul><p id="fbd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个用<code class="fe lv lw lx ly b">H#</code>编写的程序的例子:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="2ea3" class="ol ma it ly b gy om on l oo op"><strong class="ly iu">int</strong> value1 <strong class="ly iu">=</strong> 5<strong class="ly iu">;</strong><br/>int value2 = 2;</span><span id="e55f" class="ol ma it ly b gy oq on l oo op"><strong class="ly iu">// calculate the sum of two integers</strong><br/><strong class="ly iu">int function sum(x: int, y: int)</strong> {<br/>   <strong class="ly iu">return</strong> x + y;<br/>}</span><span id="1d02" class="ol ma it ly b gy oq on l oo op"><strong class="ly iu">int</strong> result = <strong class="ly iu">sum</strong>(value1, value2);<br/><strong class="ly iu">print</strong>('The result is : ', result);</span></pre><p id="157a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">H#</code>将在<code class="fe lv lw lx ly b">C</code>语言之上设计，最终输出将是一个汇编代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/90543e76b8b9e967382f5f2a9f2d632a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VM2VuFBoCEExNPU4BIYPZw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">H#黑匣子(图片由作者提供)</p></figure><h2 id="60e3" class="ol ma it bd mb os ot dn mf ou ov dp mj li ow ox ml lm oy oz mn lq pa pb mp pc bi translated">字典定义(标记)</h2><p id="8218" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">代币是我们公认的词汇词典。</p><p id="c424" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个实际的代表可以是<code class="fe lv lw lx ly b">a map or a dictionary</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pd pe l"/></div></figure><h2 id="988a" class="ol ma it bd mb os ot dn mf ou ov dp mj li ow ox ml lm oy oz mn lq pa pb mp pc bi translated">语法定义</h2><p id="de9b" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">规则1:变量声明</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/bce2b4cd02149756a9da087b64fa7ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0O8X-yEEPbhaMgcsXMRWUw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">变量声明语法(图片作者提供)</p></figure><p id="c8a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则2:函数声明</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/e1dcc15910d022bf9f4299f88c97fb62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Je6m_NYp3JonZBVCjqgxiQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数声明语法(图片由作者提供)</p></figure><p id="d7c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">规则3:函数调用</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ph"><img src="../Images/ef5e71006701a6f8fef1af4807118118.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbQaVH_6YSuJwEVUPBeHdA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">函数调用语法(图片由作者提供)</p></figure><h2 id="c65f" class="ol ma it bd mb os ot dn mf ou ov dp mj li ow ox ml lm oy oz mn lq pa pb mp pc bi translated">错误定义</h2><p id="f26a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">词汇错误:</p><p id="8986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误1:未知的标识符。</p><p id="ba50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误2:保留的关键字。</p><p id="d5f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">语法错误:</strong></p><p id="5fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误1:声明不匹配。</p><p id="fa76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">错误2:缺少左/右括号。</p><p id="a024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经准备好了解编译器内部发生了什么！</p><h1 id="4648" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是编译器？</h1><p id="ded9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">编译器是一种工具，它将以面向人类的语言编写的软件翻译成面向机器的语言。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/e09b4bf9f757c4857f181a5777dbddf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDNjRihczI45cFtzCaNVEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编译器黑盒(图片由作者提供)</p></figure><p id="c5c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">典型的“源”语言可能是C、C++、Fortran、Java或ML。“目标”语言通常是某个处理器的指令集。</p><p id="eebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器的基本特征:</p><ul class=""><li id="3f4f" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">它必须保持正在编译的程序的含义。</li><li id="8980" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">它必须改进输入(exp:删除死代码)。</li><li id="f7f8" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">它必须在可接受的性能阈值内完成工作:速度、能量、压缩和输出大小。</li></ul><p id="13b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在工作过程中，编译器会经历以下步骤:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/97e09937bbe86be339fdf448d2a76ddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMvc0YI6XkPLD2LDOlpNjQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编译器步骤(图片由作者提供)</p></figure><ul class=""><li id="1ba7" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">程序分析(前端):产生一个中间表示(IR)。</li><li id="9822" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">优化:将IR转换成运行效率更高的等价IR。</li><li id="d825" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">机器定位(后端):将IR转换成本机代码(机器代码)。</li></ul><p id="67cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们潜得更深！</p><h1 id="4929" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">程序分析阶段(前端)</h1><p id="9c5c" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在开始技术部分之前，我想请你把这句话翻译给你的法国朋友听:“编译器是一种魔法，是一种神奇的工具。”你打算如何进行？</p><p id="dae2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，有些人会建议采取以下步骤:</p><ul class=""><li id="2b8b" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">把这个句子分成单词。</li><li id="d918" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">断字符可以是任何一种标点符号。</li><li id="9b18" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">在字典中找到每个单词的对应词。</li><li id="ef26" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">把这些单词放在一起组成句子。</li><li id="4af6" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">检查语法和意思是否正确。</li><li id="6f3b" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">复习句子，必要时重新措辞。</li><li id="083a" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">读这个短语。</li></ul><p id="f149" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器将执行相同的步骤来理解输入语言:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pk"><img src="../Images/e801405fea091c1b22f8eaab991af73e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TtNAvgUrqcw0ycA11md3w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编译器前端步骤(图片由作者提供)</p></figure><p id="0c9d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">步骤看起来像我们如何翻译上面的句子，不是吗？</p><p id="70fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们一起深入了解每一步！</p><h2 id="6e54" class="ol ma it bd mb os ot dn mf ou ov dp mj li ow ox ml lm oy oz mn lq pa pb mp pc bi translated">扫描仪</h2><p id="8844" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">扫描仪将分析源程序的字符流，并将其转换为令牌流。就像在字典里一个字一个字地找单词。它还删除空白和注释。</p><p id="6ab3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扫描过程中可能出现的错误称为词汇错误:</p><ul class=""><li id="3aba" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">扫描仪将检测所有未知单词并抛出<code class="fe lv lw lx ly b">an unknown identifier error</code>。</li><li id="6c11" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">如果一个关键字被误用，扫描器将<code class="fe lv lw lx ly b">a reserved keywords error</code>。</li></ul><p id="42fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">扫描仪最简单的识别算法可以是逐字符分析器。</p><p id="1922" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，假设我们有这样的输入源代码:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="8734" class="ol ma it ly b gy om on l oo op"><strong class="ly iu">int</strong> value1 <strong class="ly iu">=</strong> 5<strong class="ly iu">;</strong><br/>int value2 = 2;<br/><br/><strong class="ly iu">// calculate the sum of two integers</strong><br/><strong class="ly iu">int function sum(x: int, y: int)</strong> {<br/>   <strong class="ly iu">return</strong> x + y;<br/>}</span></pre><p id="cb42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在扫描阶段之后，输出将是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pl"><img src="../Images/12400cb6ef42473b4cc18c41a2b62bfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wvmddotugVWexZiBeHGTPg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">分割输入的源代码标记(图片由作者提供)</p></figure><p id="02c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些情况会产生词汇错误:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="96a1" class="ol ma it ly b gy om on l oo op"><strong class="ly iu">integer</strong> value1 <strong class="ly iu">=</strong> 5<strong class="ly iu">; // unknown token integer <br/>int</strong> <strong class="ly iu">function</strong> <strong class="ly iu">=</strong> 5<strong class="ly iu">; // function is a reserved keyword<br/>INT </strong>value1 <strong class="ly iu">=</strong> 5<strong class="ly iu">; // unknown token INT, H# is case sensitive<br/>println() // unknown token println</strong></span></pre><p id="a3ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完美。在这个层次上，编译器知道我们在源代码中使用的所有单词，并且我们确信所有使用的单词都存在于令牌字典中！</p><p id="ca58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">💡<strong class="lb iu">提示</strong> : <a class="ae ky" href="https://en.wikipedia.org/wiki/Lex_(software)" rel="noopener ugc nofollow" target="_blank"> Lex </a>和<a class="ae ky" href="https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)" rel="noopener ugc nofollow" target="_blank"> Flex </a>是生成扫描仪的工具。</p><p id="2c5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，这还不够，我们需要确保令牌的组装是正确的。这就像确保一个句子的组合在语法上是正确的(例如:主语+动词)。这将是解析器的作用。我们来看看吧！</p><h2 id="2a20" class="ol ma it bd mb os ot dn mf ou ov dp mj li ow ox ml lm oy oz mn lq pa pb mp pc bi translated">句法分析程序</h2><p id="432a" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">扫描器检查词汇的正确性，分析器检查语法的正确性。</p><p id="ad6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也就是扫描器把符号组合成记号，解析器把记号组合成句子。</p><p id="5a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析器的主要职责是识别语法，确定正在编译的程序在编程语言的语法模型中是否是一个有效的句子。</p><p id="023e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是解析器是如何做到这一点的呢？为了理解这一点，我要问你，如果你在学校，我让你计算这个运算<code class="fe lv lw lx ly b">(17 + 19) * (8 + 96)</code>，你会怎么做？</p><p id="b248" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一种更简单的计算方法是这样做:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pm"><img src="../Images/47ccb5840c13c55297a34c84e619f40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guBdCfeZpLvvW3Z72G24YQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">计算树(图片作者提供)</p></figure><p id="f2fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您已经像编译器一样间接地解析了表达式:您已经确定了标记(操作数和运算符)及其关系！</p><p id="2521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析器将做同样的事情:它将我们的令牌转换成一棵表示代码实际结构的树。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pn"><img src="../Images/e8cd3f5834683444fcf9a5c947e31d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XD0UqAsXS68vTJh0.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在GCC的AST代表<a class="ae ky" href="http://icps.u-strasbg.fr/~pop/gcc-ast.html" rel="noopener ugc nofollow" target="_blank">http://icps.u-strasbg.fr/~pop/gcc-ast.html</a></p></figure><p id="ca2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，AST中的每个节点都存储为一个带有命名字段的对象，其中许多值本身就是树中的节点。</p><p id="1e06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析过程中可能出现的错误称为语法错误。</p><p id="458a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些情况会产生词汇错误:</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="b675" class="ol ma it ly b gy om on l oo op">int j = 4 * (6 − x; // missing a closing parenthesis<br/>int i = /5; // missing the first value<br/>int 42 = x * 3 // missing a semicolon, 42 can't be a variable name<br/>int value1 = 1, value2 = 1; // the language definition state that we must have a declaration per ligne</span></pre><p id="1558" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🔵注意:一些Javascript工具，如<a class="ae ky" href="https://babeljs.io/docs/en/babel-parser" rel="noopener ugc nofollow" target="_blank"> Babel </a>和<a class="ae ky" href="https://eslint.org/docs/developer-guide/working-with-custom-parsers" rel="noopener ugc nofollow" target="_blank"> ESLint </a>可以操纵AST。您还可以使用<a class="ae ky" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank"> AST Explorer </a>可视化任何Javascript代码的AST。</p><p id="2bb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">💡<strong class="lb iu">提示</strong> : <a class="ae ky" href="https://en.wikipedia.org/wiki/Yacc" rel="noopener ugc nofollow" target="_blank"> Yacc </a>和<a class="ae ky" href="https://perso.esiee.fr/~najmanl/compil/Bison/bison_7.html#SEC59" rel="noopener ugc nofollow" target="_blank"> Bison </a>是生成解析器的工具。</p><h2 id="91b0" class="ol ma it bd mb os ot dn mf ou ov dp mj li ow ox ml lm oy oz mn lq pa pb mp pc bi translated">语义分析程序</h2><p id="4060" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在语义解析期间，我们需要检查合法性规则，这样做时，我们链接语法树的各个部分(通过解析标识符引用、插入隐式强制转换操作等。)形成语义图。</p><p id="9841" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以在此阶段验证的规则:</p><ul class=""><li id="ec3e" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">一个范围内变量的多重声明。</li><li id="0c6f" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">在声明变量之前引用变量。</li><li id="7ba5" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">引用没有声明的标识符。</li><li id="b28a" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">方法调用中的参数太多。</li><li id="ec1f" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">方法调用中没有足够的参数。</li><li id="9533" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">类型不匹配。</li></ul><p id="27d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型检查器检查每个AST节点的静态语义:</p><ul class=""><li id="4c78" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">它验证构造是合法的和有意义的(所有涉及的标识符都已声明，类型是正确的，等等)。</li><li id="6f6f" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">如果构造在语义上是正确的，类型检查器就会“修饰”AST节点，向它添加类型或符号表信息。</li><li id="0f6d" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">如果发现语义错误，就会发出适当的错误消息。</li><li id="cb67" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">类型检查完全依赖于源语言的语义规则。它独立于编译器的目标机器。</li></ul><p id="5d82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个阶段发生的错误被称为静态语义错误。</p><p id="560d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大家总结一下！</p><p id="2bf0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">✅ <strong class="lb iu">扫描仪:</strong></p><ul class=""><li id="b431" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">输入:源代码。</li><li id="8fc2" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">输出:令牌。</li><li id="d819" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">目的:词汇验证。</li><li id="558c" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">词法错误:未知标记，保留关键字，…</li></ul><p id="d19a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">✅ <strong class="lb iu">解析器:</strong></p><ul class=""><li id="6ac7" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">输入:令牌。</li><li id="6214" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">输出:AST。</li><li id="1834" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">目的:语法验证(句子公式化)。</li><li id="e135" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">语法错误:缺少右括号，缺少分号，不正确的变量名，…</li></ul><p id="c2ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">✅ <strong class="lb iu">语义分析器:</strong></p><ul class=""><li id="c4b8" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated">输入:AST。</li><li id="52c0" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">输出:带注释的AST。</li><li id="e544" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">目的:语义验证(意思)。</li><li id="c58a" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated">语义错误:类型错误、声明错误、参数错误、引用错误等</li></ul><h2 id="f5c5" class="ol ma it bd mb os ot dn mf ou ov dp mj li ow ox ml lm oy oz mn lq pa pb mp pc bi translated">中间表示</h2><p id="3dc3" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">中间表示是原始源代码的独立于机器和语言的版本。</p><p id="c0db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">中间表示的使用在增加抽象性、前端和后端之间更清晰的分离方面提供了优势，并且增加了重定目标/交叉编译的可能性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi po"><img src="../Images/286177c00697e439f747cd1bb53c6068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_vjrJL58qhdfCLTc0Xpqw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">IR:独立于机器和语言(图片由作者提供)</p></figure><p id="95c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">中间表示也有助于支持高级编译器优化，大多数优化都是在这种形式的代码上执行的。</p><h1 id="a7c7" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">机器定位阶段(后端)</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pp"><img src="../Images/1cd0cf48b7a8dba9dad7ef68b26bdba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arjOHKN7K-3BB58FMbfIJg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编译器后端步骤(图片由作者提供)</p></figure><p id="34f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">后端阶段的目的是生成机器代码:</p><ul class=""><li id="f541" class="nt nu it lb b lc ld lf lg li nv lm nw lq nx lu ny nz oa ob bi translated"><strong class="lb iu">指令选择</strong>是一个编译器阶段，它将编译器的程序中间表示翻译成一系列目标相关的机器指令，这些指令针对各种编译器目标(例如，速度和空间)进行优化。</li><li id="93a9" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><strong class="lb iu">指令调度</strong>:为了产生快速运行的代码，代码生成器可能需要重新安排操作，以反映目标机器及其特定的性能约束。</li><li id="a5f0" class="nt nu it lb b lc oc lf od li oe lm of lq og lu ny nz oa ob bi translated"><strong class="lb iu">寄存器分配</strong>:选择指令时，编译器忽略了目标机器的寄存器集合有限的事实。编译可能会产生比“真实”硬件支持更多的“虚拟”寄存器需求。寄存器分配器必须将“虚拟”寄存器映射到目标机器的“真实”寄存器。它决定了在程序的每一点，哪些值将驻留在寄存器中，哪个寄存器将保存这些值。如果分配器不能在其整个生命周期内将一个值保留在寄存器中，那么该值必须在其部分或全部生命周期内存储在内存中。</li></ul><h1 id="1cb0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="6af9" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在本文中，我们概述了编程语言从语言定义到运行时是如何工作的。</p><p id="9ef3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编程语言由词汇、语法和语义决定。</p><p id="bcff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器的作用是确保机器将执行的代码尊重语言的定义和硬件特征。</p><p id="bea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编译器内部的代码经过几个阶段:词法分析、语法分析，然后是语义分析。正确性是编译器的强制性特征和行为。</p><p id="2e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了正确性之外，编译器必须保证性能并执行优化，以减少和提高运行时代码的执行。</p></div><div class="ab cl pq pr hx ps" role="separator"><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv"/></div><div class="im in io ip iq"><p id="9cdf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您阅读我的文章。</p><pre class="kj kk kl km gt oh ly oi oj aw ok bi"><span id="5008" class="ol ma it ly b gy om on l oo op"><strong class="ly iu">Want to Connect?</strong></span><span id="3cbd" class="ol ma it ly b gy oq on l oo op">You can find me at GitHub: <a class="ae ky" href="https://github.com/helabenkhalfallah" rel="noopener ugc nofollow" target="_blank">https://github.com/helabenkhalfallah</a></span></pre></div></div>    
</body>
</html>