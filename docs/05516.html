<html>
<head>
<title>Kubernetes Tips: Backup and Restore Etcd</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes提示:备份和恢复Etcd</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/kubernetes-tips-backup-and-restore-etcd-97fe12e56c57?source=collection_archive---------2-----------------------#2020-07-15">https://betterprogramming.pub/kubernetes-tips-backup-and-restore-etcd-97fe12e56c57?source=collection_archive---------2-----------------------#2020-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1937" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用牧场主RKE聚类的示例</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/005f947708f5c82913ab90d533e9714c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9lxYm_ntYFiwYm1uy5FFaw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·温克勒在<a class="ae ky" href="https://unsplash.com/s/photos/backup?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="5963" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上一篇文章中，我解释了etcd在Kubernetes集群中扮演的角色。</p><div class="lv lw gp gr lx ly"><a href="https://medium.com/better-programming/a-closer-look-at-etcd-the-brain-of-a-kubernetes-cluster-788c8ea759a5" rel="noopener follow" target="_blank"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd iu gy z fp md fr fs me fu fw is bi translated">近距离观察Etcd:Kubernetes星团的大脑</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">etcd包含什么以及它如何组织信息</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">medium.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm ks ly"/></div></div></a></div><p id="326f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到了etcd包含的信息示例、它的不同安装方式(集群内部或外部)，以及etcd节点如何通过Raft分布式共识算法交换信息。所有这些使得etcd成为Kubernetes集群的重要组成部分。</p><p id="b0a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我们将使用Rancher的RKE集群，看看如何从一个集群备份etcd，并在另一个集群中恢复它。这说明了一个集群出错(不幸的是，这种情况经常发生)并且我们需要在一个备用集群中恢复它的情况。</p><p id="f96a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将遵循以下步骤:</p><ul class=""><li id="c449" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">牧场主的RKE快速介绍</li><li id="7267" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">创建两个Kubernetes集群</li><li id="1d15" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">在第一个集群上备份etcd</li><li id="502f" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">在第二个集群上恢复etcd</li></ul></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="9cd1" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">关于牧场主RKE</h1><p id="5761" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated"><a class="ae ky" href="https://rancher.com/" rel="noopener ugc nofollow" target="_blank"> Rancher Labs </a>是一家主要以其主要产品<a class="ae ky" href="https://rancher.com/products/rancher/" rel="noopener ugc nofollow" target="_blank"> Rancher </a>而闻名的公司，该产品是Kubernetes的管理平台。<a class="ae ky" href="https://rancher.com/products/rancher/" rel="noopener ugc nofollow" target="_blank"> Rancher </a> <strong class="lb iu"> </strong>允许我们在同一个界面内管理多个集群。它涵盖了集群配置、用户访问控制、工作负载部署(通过集成的应用程序目录)等等</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/bcab5ef90960731e3565d3de2e63dc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqhbo9knZjO0Yt3-Qb-xtg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">牧场主中的应用程序目录</p></figure><p id="9f3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://rancher.com/" rel="noopener ugc nofollow" target="_blank"> Rancher Labs </a>在开源生态系统中也因其他伟大的项目而闻名:</p><ul class=""><li id="5b13" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated"><a class="ae ky" href="https://rancher.com/products/rke/" rel="noopener ugc nofollow" target="_blank">RKE</a>:CNCF认证的Kubernetes发行版，完全在Docker容器中运行(这就是我们将在本文中演示的)。</li><li id="0d5f" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated"><a class="ae ky" href="https://k3s.io/" rel="noopener ugc nofollow" target="_blank"> K3s </a>:一个轻量级的Kubernetes发行版(主要致力于在边缘和ARM设备上运行，但在标准x86上确实很棒)。</li><li id="a9d5" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated"><a class="ae ky" href="https://rancher.com/products/longhorn/" rel="noopener ugc nofollow" target="_blank">Longhorn</a>:Kubernetes的分布式块存储解决方案。它在几周前正式上市，但已经积极开发了两年多。Longhorn由<a class="ae ky" href="https://cncf.io" rel="noopener ugc nofollow" target="_blank"> CNCF </a>管理，目前在<a class="ae ky" href="https://www.cncf.io/sandbox-projects/" rel="noopener ugc nofollow" target="_blank">沙盒项目</a>中(可能很快会进入孵化阶段)</li></ul><p id="7e2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将重点讨论RKE，因为这是一个设置和管理Kubernetes集群的非常好的工具。</p><p id="bce4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">rke二进制文件可以很容易地安装在MacOS、Linux或Windows上(<a class="ae ky" href="https://rancher.com/docs/rke/latest/en/installation/" rel="noopener ugc nofollow" target="_blank">https://rancher.com/docs/rke/latest/en/installation/</a>)。安装后，我们可以列出所有可用的命令和选项。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/1040060d00a96a6a3f83557bfa0368fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IsEcfbG26Scl8rq8AwQ85g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">rke的可用命令和选项。</p></figure><p id="3c25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下文中，我们将演示用于创建集群的命令以及用于备份和恢复集群底层etcd的命令。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="09a9" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">建立Kubernetes集群</h1><p id="27dd" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">首先，我们将使用RKE创建两个集群。</p><h2 id="df97" class="oh nj it bd nk oi oj dn no ok ol dp ns li om on nu lm oo op nw lq oq or ny os bi translated">创建第一个集群</h2><ol class=""><li id="f122" class="mn mo it lb b lc oa lf ob li ot lm ou lq ov lu ow mt mu mv bi translated">在云提供商上启动虚拟机</li></ol><p id="0747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">外面有很多选择。我最喜欢的一些是<a class="ae ky" href="https://digitalocean.com" rel="noopener ugc nofollow" target="_blank">数字海洋</a>、<a class="ae ky" href="https://www.civo.com/" rel="noopener ugc nofollow" target="_blank"> Civo </a>和<a class="ae ky" href="https://www.scaleway.com" rel="noopener ugc nofollow" target="_blank"> Scaleway </a>。此外，我们需要使用ssh密钥设置对这台机器的ssh访问。</p><p id="f4c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.码头工人的安装</p><p id="075e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当RKE在Docker容器中创建Kubernetes集群时，Docker的安装是一个先决条件。使用以下命令可以很容易地做到这一点:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="14a9" class="oh nj it oy b gy pc pd l pe pf">$ curl -sSL <a class="ae ky" href="https://get.docker.com" rel="noopener ugc nofollow" target="_blank">https://get.docker.com</a> | sh </span></pre><p id="c979" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.创建RKE集群的配置文件</p><p id="28cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从名为<em class="pg"> kube1、</em>的专用文件夹中，我们运行<em class="pg"> RKE配置</em>命令，以便准备一个包含我们将要创建的集群配置的文件。该命令需要几个参数来配置在我们的单个虚拟机上设置集群的方式，其中包括:</p><ul class=""><li id="05b2" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">虚拟机的IP地址</li><li id="3ef4" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">应该在此虚拟机上运行的组件(控制平面等)</li><li id="f2f0" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">要安装的网络插件(法兰绒、印花布、编织、运河)</li><li id="4e48" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">一些网络相关参数(IP范围等)</li></ul><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="8180" class="oh nj it oy b gy pc pd l pe pf"><strong class="oy iu">$ rke config</strong><br/>[+] Cluster Level SSH Private Key Path [~/.ssh/id_rsa]:<br/>[+] Number of Hosts [1]:<br/>[+] SSH Address of host (1) [none]: 209.97.129.73<br/>[+] SSH Port of host (1) [22]:<br/>[+] SSH Private Key Path of host (209.97.129.73) [none]:<br/>[-] You have entered empty SSH key path, trying fetch from SSH key parameter<br/>[+] SSH Private Key of host (209.97.129.73) [none]:<br/>[-] You have entered empty SSH key, defaulting to cluster level SSH key: ~/.ssh/id_rsa<br/>[+] SSH User of host (209.97.129.73) [ubuntu]: root<br/>[+] Is host (209.97.129.73) a Control Plane host (y/n)? [y]:<br/>[+] Is host (209.97.129.73) a Worker host (y/n)? [n]: y<br/>[+] Is host (209.97.129.73) an etcd host (y/n)? [n]: y<br/>[+] Override Hostname of host (209.97.129.73) [none]:<br/>[+] Internal IP of host (209.97.129.73) [none]:<br/>[+] Docker socket path on host (209.97.129.73) [/var/run/docker.sock]:<br/>[+] Network Plugin Type (flannel, calico, weave, canal) [canal]:<br/>[+] Authentication Strategy [x509]:<br/>[+] Authorization Mode (rbac, none) [rbac]:<br/>[+] Kubernetes Docker image [rancher/hyperkube:v1.17.6-rancher2]:<br/>[+] Cluster domain [cluster.local]:<br/>[+] Service Cluster IP Range [10.43.0.0/16]:<br/>[+] Enable PodSecurityPolicy [n]:<br/>[+] Cluster Network CIDR [10.42.0.0/16]:<br/>[+] Cluster DNS Service IP [10.43.0.10]:<br/>[+] Add addon manifest URLs or YAML files [no]:</span></pre><p id="2c94" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:在本例中，我们只设置了一个单节点集群，但是RKE使创建高可用性集群变得非常容易。</p><p id="120f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.创建Kubernetes集群</p><p id="ed09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在可以使用<em class="pg"> RKE </em>二进制文件来安装Kubernetes，该文件会读取上一步中生成的<em class="pg"> cluster.yml </em>文件。</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="2d4b" class="oh nj it oy b gy pc pd l pe pf"><strong class="oy iu">$ rke up</strong><br/>INFO[0000] Running RKE version: v1.1.2<br/>INFO[0000] Initiating Kubernetes cluster<br/>...<br/>INFO[0135] Finished building Kubernetes cluster successfully</span></pre><p id="ac78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的单节点Kubernetes集群启动并运行大约需要一分钟。RKE创建了两个文件:</p><ul class=""><li id="ca81" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated"><code class="fe ph pi pj oy b">kube_config_cluster.yml</code>:一个kubeconfig文件，我们将通过kubectl使用它与集群的API服务器进行通信。</li><li id="9520" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated"><code class="fe ph pi pj oy b">cluster.rkestate</code>:包含集群所有配置选项的文件。</li></ul><p id="bd13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用kubeconfig文件并验证集群是否启动并运行:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="358c" class="oh nj it oy b gy pc pd l pe pf">~/kube1 $ export KUBECONFIG=$PWD/kube_config_cluster.yml</span><span id="191a" class="oh nj it oy b gy pk pd l pe pf">~/kube1 $ kubectl get nodes<br/>kubectl get nodes<br/>NAME            STATUS   ROLES                      AGE     VERSION<br/>209.97.129.73   Ready    controlplane,etcd,worker   4m26s   v1.17.6</span></pre><p id="7f01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该集群只包含一个节点，显然不是生产级别的集群，但是对于本文的目的来说已经足够了。</p><p id="8e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.部署工作负载</p><p id="6d96" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在在新创建的集群上启动一些pod。我们在这里使用一些命令性的命令(那些命令非常方便；避免使用yaml规范)。</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="b3bc" class="oh nj it oy b gy pc pd l pe pf"># Create a MongoDB Deployment and expose it with a ClusterIP service<br/>$ kubectl create deploy db --image=mongo:4.2<br/>$ kubectl expose deploy/db --port 27017 --target-port=27017</span><span id="8281" class="oh nj it oy b gy pk pd l pe pf"># Create 10 replicas of a simple nginx Pod<br/>$ kubectl create deploy/www --image=nginx:1.16-alpine<br/>$ kubectl scale deploy/www --replicas=10</span></pre><p id="a07a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们确保一切正常运行:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="481e" class="oh nj it oy b gy pc pd l pe pf"><strong class="oy iu">$ kubectl get deploy,svc<br/></strong>NAME                  READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/db    1/1     1            1           89s<br/>deployment.apps/www   10/10   10           10          13s</span><span id="8c90" class="oh nj it oy b gy pk pd l pe pf">NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE<br/>service/db           ClusterIP   10.43.248.161   &lt;none&gt;        27017/TCP   83s<br/>service/kubernetes   ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP     7m42s</span></pre><p id="65ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个集群运行良好。我们还能够在其中运行一些工作负载。那也行！</p><h2 id="300a" class="oh nj it bd nk oi oj dn no ok ol dp ns li om on nu lm oo op nw lq oq or ny os bi translated">创建第二个集群</h2><p id="bac1" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">要创建新的集群，我们将遵循与第一个集群相同的过程:</p><ul class=""><li id="05e0" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">在云提供商上运行一个虚拟机</li><li id="12bd" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">在上面安装Docker</li><li id="46c3" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">运行<em class="pg"> RKE配置</em>来创建一个集群配置文件(确保使用一个新的文件夹来覆盖用于第一个集群的文件夹:)</li><li id="cb36" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">运行<em class="pg"> RKE up </em>来设置集群</li></ul><p id="5eed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个过程的最后，我们得到一个新的kubeconfig文件。然后，我们可以验证我们的第二个集群已经启动并正在运行，并且没有工作负载正在其上运行(还没有)。</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="8f37" class="oh nj it oy b gy pc pd l pe pf">~/kube2 $ export KUBECONFIG=$PWD/kube_config_cluster.yml</span><span id="8999" class="oh nj it oy b gy pk pd l pe pf">~/kube2 $ kubectl get pod<br/>No resources found in default namespace.</span></pre><p id="18ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在有两个集群:</p><ul class=""><li id="0e1b" class="mn mo it lb b lc ld lf lg li mp lm mq lq mr lu ms mt mu mv bi translated">姑且称之为<strong class="lb iu"> kube1 </strong>和<strong class="lb iu"> kube2 </strong>。</li><li id="ac02" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">每个集群包含一个节点，该节点同时充当控制平面(etcd)和工作节点。</li><li id="74f4" class="mn mo it lb b lc mw lf mx li my lm mz lq na lu ms mt mu mv bi translated">我们在<strong class="lb iu"> kube1 </strong>上部署了一些虚拟工作负载，在<strong class="lb iu"> kube2 </strong>上没有部署任何虚拟工作负载。</li></ul><p id="204e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下一步，我们将从第一个集群备份etcd。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="e0a1" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">备份Etcd</h1><p id="72bb" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">RKE使得备份etcd变得非常容易。命令<em class="pg"> rke etcd snapshot-save </em>为我们处理整个过程，并在集群的每个etcd节点(本例中只有一个节点)上创建一个备份(作为zip文件)。</p><p id="ddc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从包含第一个集群的kubeconfig文件的文件夹中运行这个命令。</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="60df" class="oh nj it oy b gy pc pd l pe pf">$ rke etcd snapshot-save --name snapshot<br/>INFO[0000] Running RKE version: v1.1.2<br/>INFO[0000] Starting saving snapshot on etcd hosts<br/>INFO[0000] [dialer] Setup tunnel for host [209.97.129.73]<br/>INFO[0001] [etcd] Running snapshot save once on host [209.97.129.73]<br/>INFO[0001] Image [rancher/rke-tools:v0.1.56] exists on host [209.97.129.73]<br/>INFO[0001] Starting container [etcd-snapshot-once] on host [209.97.129.73], try #1<br/>INFO[0002] [etcd] Successfully started [etcd-snapshot-once] container on host [209.97.129.73]<br/>INFO[0002] Waiting for [etcd-snapshot-once] container to exit on host [209.97.129.73]<br/>INFO[0002] Container [etcd-snapshot-once] is still running on host [209.97.129.73]<br/>INFO[0003] Waiting for [etcd-snapshot-once] container to exit on host [209.97.129.73]<br/>INFO[0003] Removing container [etcd-snapshot-once] on host [209.97.129.73], try #1<br/>INFO[0003] Finished saving/uploading snapshot [snapshot] on all etcd hosts</span></pre><p id="2712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:我们给快照取了一个简单的名字；在生产环境中，我们会选择一个更有意义的环境。</p><p id="fa5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们确保快照存在于我们集群的节点上(RKE将它存储在<strong class="lb iu">/opt/rke/etcd-snapshot s</strong>):</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="0487" class="oh nj it oy b gy pc pd l pe pf">$ ssh root@<strong class="oy iu">kube1</strong> -- ls /opt/rke/etcd-snapshots<br/>snapshot.zip</span></pre><p id="7e58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们在本地计算机上复制备份(备份不应保存在节点上):</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="2079" class="oh nj it oy b gy pc pd l pe pf">$ scp root@<strong class="oy iu">kube1</strong>:/opt/rke/etcd-snapshots/snapshot.zip .</span></pre><p id="4917" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有第一个集群的备份，这很好。我们现在将了解如何在另一个集群上恢复该备份。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="2922" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">恢复Etcd</h1><p id="6068" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">首先，我们将备份文件复制到第二个集群的节点上(在/opt/rke/etcd-snapshots/文件夹中):</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="e02d" class="oh nj it oy b gy pc pd l pe pf">$ scp ./snapshot.zip root@<strong class="oy iu">kube2</strong>:/opt/rke/etcd-snapshots/</span></pre><p id="6f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们使用<em class="pg">RKE etcd snapshot-restore</em>命令来恢复<em class="pg"> snapshot.zip </em>。<em class="pg"> </em>从快照中恢复新集群大约需要一分钟的时间(这里恢复的时间不多，因为我们只创建了几个资源)。</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="3bea" class="oh nj it oy b gy pc pd l pe pf">$ rke etcd snapshot-restore --name snapshot<br/>INFO[0000] Running RKE version: v1.1.2<br/>INFO[0000] Restoring etcd snapshot snapshot<br/>...<br/>INFO[0095] Finished building Kubernetes cluster successfully<br/>INFO[0095] Restarting network, ingress, and metrics pods<br/>INFO[0097] Finished restoring snapshot [snapshot] on all etcd hosts</span></pre><p id="99a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以检查第二个集群上正在运行什么:</p><pre class="kj kk kl km gt ox oy oz pa aw pb bi"><span id="b960" class="oh nj it oy b gy pc pd l pe pf">$ kubectl get deploy,po,svc<br/>NAME                  READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/db    1/1     1            1           4h1m<br/>deployment.apps/www   10/10   10           10          3h59m</span><span id="113a" class="oh nj it oy b gy pk pd l pe pf">NAME                       READY   STATUS    RESTARTS   AGE<br/>pod/db-d76859d75-gstkf     1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-2zm5d   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-4f8hh   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-brjpn   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-c2wvw   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-j89tc   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-jxq6r   1/1     Running   0          2m33s<br/>pod/www-5fd6c8cc68-m8kk5   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-n4dbd   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-r5f55   1/1     Running   0          2m34s<br/>pod/www-5fd6c8cc68-tx49m   1/1     Running   0          2m34s</span><span id="9af6" class="oh nj it oy b gy pk pd l pe pf">NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE<br/>service/db           ClusterIP   10.43.248.161   &lt;none&gt;        27017/TCP   4h1m<br/>service/kubernetes   ClusterIP   10.43.0.1       &lt;none&gt;        443/TCP     4h7m</span></pre><p id="5045" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在第一个集群上运行的所有工作负载现在都在第二个集群上运行，在第二个集群上运行的是“<em class="pg">rke etcd snapshot-restore</em>”和“<em class="pg">rke etcd snapshot-restore</em>”，这是我们所需要的。</p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><h1 id="c542" class="ni nj it bd nk nl nm nn no np nq nr ns jz nt ka nu kc nv kd nw kf nx kg ny nz bi translated">摘要</h1><p id="1ba6" class="pw-post-body-paragraph kz la it lb b lc oa ju le lf ob jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">etcd是Kubernetes集群的大脑，因为它包含关于集群中现有资源的所有信息。为了备份Kubernetes，我们需要快照etcd，并将生成的文件移动到一个安全的地方(以防以后需要恢复，当然，我们希望永远不会发生…)。当然，这个过程应该定期进行，时间表取决于集群的使用情况。</p><p id="8b89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们必须小心，因为在etcd级别完成的备份没有考虑到在应用程序级别管理的所有数据。备份/恢复过程也应该在应用程序级别完成。<a class="ae ky" href="https://longhorn.io" rel="noopener ugc nofollow" target="_blank">Longhorn</a>(Rancher Labs的分布式块存储)是实现这一目的的绝佳选择。</p></div></div>    
</body>
</html>