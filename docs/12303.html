<html>
<head>
<title>The “Tick” Pattern — A Solution for Temporal Problems in State Machines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“滴答”模式——状态机中时间问题的解决方案</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-tick-pattern-a-solution-for-temporal-problems-in-state-machines-b78600772e8c?source=collection_archive---------5-----------------------#2022-05-26">https://betterprogramming.pub/the-tick-pattern-a-solution-for-temporal-problems-in-state-machines-b78600772e8c?source=collection_archive---------5-----------------------#2022-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d8f4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何自动执行等待外部和时间条件的工作流，而不增加复杂性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f03f3baf47b70edc6cc46ff01415ff9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wn5lkcZCm3rnYQiT"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@campaign_creators?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">活动发起人</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="992c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以你必须编写这样的程序:</p><ul class=""><li id="2987" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一天后发送提醒电子邮件</li><li id="b3aa" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在到达交货日期后处理订单</li><li id="e120" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">基于外部服务的状态将文档标记为已签名</li></ul><p id="e544" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些过程需要某种形式的组织，因为你不能仅仅用一个小时来继续一项工作。这就是滴答模式的由来。</p><h1 id="2ada" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">滴答模式</h1><p id="88c8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">你可能已经知道术语“滴答”<a class="ae kv" href="https://en.wikipedia.org/wiki/Netcode#Tickrate" rel="noopener ugc nofollow" target="_blank">维基百科描述得很好</a>:</p><blockquote class="nh ni nj"><p id="503f" class="kw kx nk ky b kz la jr lb lc ld ju le nl lg lh li nm lk ll lm nn lo lp lq lr ij bi translated">一个游戏模拟的单次更新被称为滴答[…]</p></blockquote><p id="7e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通常不在Symfony中编程游戏，但是我们仍然可以借用这个概念，使用这个吸引人的名字。</p><h1 id="b24a" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">计划是什么？</h1><p id="63d3" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我建议构建一个执行“滴答”的命令/任务/工作</p><p id="fb8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">“滴答”只是定期检查状态机转换是否可能。这允许您用简单的代码定义各种条件(日期、库存、用户确认),而不必在条件满足时寻找执行逻辑的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/c60559827f3419fd0e21f46167b8bab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4TUifsbFC4lfTyRdIjtsWg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">执行滴答的粗略过程</p></figure><p id="6fc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是您可能希望处理此类任务的原因列表:</p><ul class=""><li id="bf2b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一个入口点:与每个异步任务都需要一个cron作业相比，您只需要一个cron作业。</li><li id="b38a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">更简单的工具:您只需要围绕一个异步任务构建监控和日志记录</li><li id="a338" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">鲁棒性。如果失败了，它会在下一次运行。想想不可用的API或SMTP服务器。在这种模式下，它只会重试。</li><li id="96ed" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">可更改:直接在数据库中更改交付日期或在新版本中更改延迟。所有这些变化都会立即反映出来，无需迁移或特殊的代码路径</li></ul><p id="867b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，这种模式存在一些问题:</p><ul class=""><li id="2505" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">缩放:实体越多，分笔成交点花费的时间就越长。</li><li id="2367" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">浪费:某些州的每个实体都将在每个时钟周期被检查。</li></ul><h1 id="ef89" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">在元数据中定义刻度</h1><p id="18cb" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我现在将具体介绍一下<a class="ae kv" href="https://symfony.com/doc/5.4/components/workflow.html" rel="noopener ugc nofollow" target="_blank"> symfony工作流组件</a>，但是您也可以将其应用于其他状态机。</p><p id="af80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您希望能够轻松地阅读应用程序中的行为。状态机定义已经有所帮助，但是您知道您可以<a class="ae kv" href="https://symfony.com/doc/5.4/workflow.html#storing-metadata" rel="noopener ugc nofollow" target="_blank">向symfony工作流定义</a>添加任意元数据吗？</p><pre class="kg kh ki kj gt np mj nq nr aw ns bi"><span id="3647" class="nt ml iq mj b gy nu nv l nw nx">transitions:<br/>  deliver:<br/>    from: new<br/>    to: delivering<br/>    guard: subject.checkPreconditions()<br/>    metadata:<br/>      on_tick: true</span></pre><p id="0492" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它实际上只是任意的数据，但这意味着我们可以在以后描述新的使用行为。在这种情况下，我将定义<code class="fe mg mh mi mj b">on_tick</code>，它只是一个我们希望稍后检查的标志。</p><p id="2f14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还使用了<code class="fe mg mh mi mj b">guard</code>属性来定义状态何时被允许改变的条件。这可读性很好，但是相当有限，您应该使用<a class="ae kv" href="https://symfony.com/doc/current/workflow.html#guard-events" rel="noopener ugc nofollow" target="_blank">保护事件</a>来代替。</p><h1 id="e390" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">构建Tick服务</h1><p id="b901" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">您会想要轻松地执行tick，所以让我们构建一个小的<code class="fe mg mh mi mj b">Service</code>来完成它。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="7a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有了这个简单的服务，您可以运行<code class="fe mg mh mi mj b">$service-&gt;tick($order)</code>来运行挂起的转换。这对于在创建实体后立即启动流程非常有用。或者没有，如果有一个条件目前阻止它。</p><p id="8de0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这项服务中也有意义的事情:</p><ul class=""><li id="42ba" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">一个类似<code class="fe mg mh mi mj b">simulate</code>的试运行方法，这样你就可以不用实际去做就可以检查是否有什么事情在等待</li><li id="ae34" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">一种返回所有转换阻止程序的方法，这样您就可以解释订单停滞的原因</li></ul><h1 id="467a" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">构建Cron命令</h1><p id="fa7c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们现在需要一个命令来触发程序世界之外的ticks，通常是一个cron作业。但是您还希望能够手动触发单个分笔成交点，所以CLI应该有点花哨。</p><p id="a7bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该命令必须特定于底层数据库，因此我为我的示例<code class="fe mg mh mi mj b">Order</code>创建了tick命令，但是您可以根据自己的喜好调整它，甚至让它运行于多个实体类型。以下是更多代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="9f8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用这个命令，您现在可以运行<code class="fe mg mh mi mj b">order:tick</code>，所有标记为<code class="fe mg mh mi mj b">on_tick: true</code>的转换将被执行，如果它们没有被其他条件阻塞的话。</p><p id="a1b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在这里使用的一个小技巧是使用带参数<code class="fe mg mh mi mj b">$orderStateMachine</code>的命名自动连接直接注入状态机，以显式地注入名为<code class="fe mg mh mi mj b">order</code>的状态机。您通常从<code class="fe mg mh mi mj b">Registry</code>服务中获得状态机，但是如果没有对象，就无法访问状态机。在这里，我们希望状态机首先创建一个状态列表，它有一个<code class="fe mg mh mi mj b">on_tick</code>转换。</p><p id="3430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个命令也接受一个id列表作为参数。这样，您就可以对特定订单进行报价。这对测试真的很有用。</p><p id="b89f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能想要提高自己的事情:</p><ul class=""><li id="a78c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">特定实体的优先级排序(例如，首先处理旧订单)</li><li id="9958" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">批量加载实体/订单以提高吞吐量</li><li id="b4b5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">您可以尝试使用多个进程遍历id列表。要么自己生成进程，要么通过<code class="fe mg mh mi mj b">echo [id list] |xargs -P4 -n100 php bin/console order:tick</code>发送所有id。</li></ul><h1 id="6ee5" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">现在轮到你了</h1><p id="e8cc" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我错过什么了吗？我帮到你了吗？在评论里告诉我。</p></div></div>    
</body>
</html>