<html>
<head>
<title>RxJS forkJoin Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS forkJoin最佳实践</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjs-forkjoin-never-use-array-indexes-in-subscribe-1f4005582ae8?source=collection_archive---------0-----------------------#2019-07-31">https://betterprogramming.pub/rxjs-forkjoin-never-use-array-indexes-in-subscribe-1f4005582ae8?source=collection_archive---------0-----------------------#2019-07-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="09b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">永远不要在Subscribe中使用数组索引！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f2484ba78a6c67ff506fe3b5209d79cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xg5JHv7OO_AWafedTBsyzg.png"/></div></div></figure><p id="69e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们知道，当我们想并行订阅几个可观测量，等待全部完成，然后用结果做一些事情时，一个<code class="fe lq lr ls lt b">forkJoin</code> <strong class="kw iu"> </strong>运算符是最佳选择。但是如果你写错了订阅代码，它可能会成为你的应用程序中一个非常糟糕的部分…</p><p id="7cb1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我经常观察到在Angular应用程序中结合RxJS <code class="fe lq lr ls lt b">forkJoin</code> <strong class="kw iu"> </strong>操作符编写的代码非常难看。这里有一些帮助你避免混乱和正确使用<code class="fe lq lr ls lt b">forkJoin</code>的提示。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7f1f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">会有多糟？</h1><p id="5e15" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">您可能已经在您从事的项目中遇到过这种代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="801c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然这看起来很糟糕，但相信我，如果你不尽快开始重构，情况会变得更糟。</p><p id="d880" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这个<code class="fe lq lr ls lt b">forkJoin</code>中，我们一次订阅五个可观测量，我们以五元素数组的形式获得结果，然后在订阅处理程序中，我们使用数组索引访问数据。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="9bc5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated"><strong class="ak">切勿使用数组索引访问来自forkJoin的数据！</strong></h1><p id="bb44" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">通过索引访问是你能做的最糟糕的事情。原因如下:</p><ol class=""><li id="ece0" class="na nb it kw b kx ky la lb ld nc lh nd ll ne lp nf ng nh ni bi translated"><code class="fe lq lr ls lt b">subscribe</code>法的正文完全不可读；你不知道这个神秘的<code class="fe lq lr ls lt b">result[3]</code>或<code class="fe lq lr ls lt b">result[5]</code>背后隐藏着什么信息。您需要参考<code class="fe lq lr ls lt b">forkJoin</code>调用来找出它，但是这并不容易，因为您需要用手指数出可观察到的对象来找到正确的对象！</li><li id="b7c6" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">每当您从<code class="fe lq lr ls lt b">forkJoin</code>中添加或删除一个可观察对象时，索引都会改变。大多数情况下，您需要重新索引<code class="fe lq lr ls lt b">subscribe</code>方法中的所有内容。这样的重新索引很容易引入错误，而且，当你需要这样做的时候，真的很令人沮丧。</li><li id="df74" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated"><code class="fe lq lr ls lt b">subscribe</code>方法打破了单一责任原则。在订阅处理程序中，我们现在获取来自<code class="fe lq lr ls lt b">forkJoin</code>的所有数据，我们将它分配给一些私有字段，我们同步它，我们启动一些方法，最后，我们触发基于所有先前步骤和获取的数据的最终动作。大多数情况下，您不会被迫将所有内容都打包到subscribe方法中，但无论如何，您还是会这样做。如果不担心分离关注点，你很快就会用一个庞大、笨拙的方法完成所有的事情。</li></ol><p id="358f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在快来解一下。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="e956" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">我们如何避免forkJoin问题？</h1><p id="cc46" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">在<code class="fe lq lr ls lt b">forkJoin subscribe</code>方法中，你应该对来自可观测量的数据不那么感兴趣，而是关注所有可观测量都已经完成的事实。</p><p id="e409" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获取数据可能不是<code class="fe lq lr ls lt b">forkJoin subscribe</code>所关心的。更重要的是确保数据已经完全可用，并且可以安全使用。</p><p id="929f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">数据存储通常可以直接转移到作为参数传递给<code class="fe lq lr ls lt b">forkJoin</code>的可观测量中。我们可以使用RxJS <code class="fe lq lr ls lt b">tap</code>操作符来处理数据，就像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="6934" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看看通过应用这个简单的技巧，一切都变得简单了。我们现在有一个非常简单的<code class="fe lq lr ls lt b">subscribe</code>方法，大部分数据处理直接在传递给<code class="fe lq lr ls lt b">forkJoin</code>的可观测量中进行。</p><p id="c97c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们分开关注；日期范围由<code class="fe lq lr ls lt b">dateRange$</code> observable直接存储在私有字段中，<code class="fe lq lr ls lt b">setUsers</code>方法由<code class="fe lq lr ls lt b">users$</code> observable运行，最后，图表的配置在调用API后被获取和设置。</p><p id="650b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们仍然有一些数组索引出现在<code class="fe lq lr ls lt b">subscribe</code>方法中，我们已经知道这是不好的。我们不能将代码直接移动到可观测量中，因为该方法依赖于来自其中两个可观测量的数据，并且这两个可观测量都需要在运行之前完成。</p><p id="d97b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们如何帮助自己？嗯，我们可以引入另一个私有字段来存储数据和处理问题，就像例子中的其他可观测量的情况一样。我们也可以创建一个嵌套的<code class="fe lq lr ls lt b">forkJoin</code>来分别处理这两个可观测量。相反，让我们使用最简单的解决方案:析构数组。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b655" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如你所见，我们现在有了完全可读的<code class="fe lq lr ls lt b">forkJoin</code>代码，没有任何上述的缺点。我们已经命名了感兴趣的数组元素，并在代码中使用了这些名称。现在看起来好多了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="431d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe lq lr ls lt b">subscribe</code>方法中，数组索引不再访问任何数据。</p><p id="9e11" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是也许你已经注意到了，我们仍然需要计算去符号化符号中的逗号！我们能容易地修理它吗？实际上是的，因为我们现在只使用来自subscribe方法中两个可观测量的数据。让我们重新排列<code class="fe lq lr ls lt b">forkJoin</code>中的观察值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="bc1d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们如何最终得到整洁、自我解释、易于维护的<code class="fe lq lr ls lt b">forkJoin</code>代码！希望你注意到不同之处:)</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="d43a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">关键要点</h1><ol class=""><li id="86e7" class="na nb it kw b kx mt la mu ld no lh np ll nq lp nf ng nh ni bi translated">切勿使用<code class="fe lq lr ls lt b">forkJoin subscribe</code>中的数组索引访问数据。这导致了不可读的代码、维护噩梦和潜在的错误。</li><li id="0abc" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">在可能的情况下，通过将代码移动到专用的可观察对象来减少订阅逻辑。<br/>在subscribe中，当所有数据都可用时，只关注你需要做的事情，将所有其他内容移出一个<code class="fe lq lr ls lt b">forkJoin</code> subscribe。</li><li id="aefa" class="na nb it kw b kx nj la nk ld nl lh nm ll nn lp nf ng nh ni bi translated">爱RxJS！:)</li></ol><p id="afb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">P.S .有没有注意到结果数组里没有<code class="fe lq lr ls lt b">result[5]</code>？最后一个元素实际上是<code class="fe lq lr ls lt b">result[4]</code>。这在代码中从未使用过，而我们一直在访问总是未定义的<code class="fe lq lr ls lt b">result[5]</code>。<br/>这正是在<code class="fe lq lr ls lt b">forkJoin</code>:)中使用索引时发生的事情</p></div></div>    
</body>
</html>