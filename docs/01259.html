<html>
<head>
<title>RxJava 2 Chaining and Conventional Code: A Side by Side Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJava 2链接和传统代码:并排比较</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/rxjava-2-chaining-and-conventional-code-side-by-side-comparison-a04c50a97109?source=collection_archive---------12-----------------------#2019-08-27">https://betterprogramming.pub/rxjava-2-chaining-and-conventional-code-side-by-side-comparison-a04c50a97109?source=collection_archive---------12-----------------------#2019-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a9b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用和不使用RxJava创建循环动画</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/08dfded6ae8d25ffc35f39351226f61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hb3JUzS2TJNm9aZqKWZ6Sw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@petkovski?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">佩塔·佩特科夫斯基</a>在<a class="ae ky" href="https://unsplash.com/s/photos/side-by-side?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="45fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与做同样事情的传统代码相比，RxJava的新学习者看到它有时是有帮助的。</p><p id="ac39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我将展示两段操作几乎相同的代码——一段使用RxJava，另一段使用常规代码。</p><blockquote class="lv lw lx"><p id="953b" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">如果您不熟悉RxJava，请查看<a class="ae ky" href="https://medium.com/@elye.project/learning-rxjava-in-android-made-simple-in-kotlin-single-just-subscribe-581ff8835a64" rel="noopener">轻松学习rx Java</a></p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="a642" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">代码做什么</h1><p id="e29c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在进入细节之前，让我们看看代码是做什么的。基本上，它通过一组图像循环创建一个动画，如下图所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/ba2b9f0598e05d321dffbfb4bf95dbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UokX66i4PuiS2kcQCSs_Bw.png"/></div></div></figure><p id="dbd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码操作是这样的:</p><ul class=""><li id="d778" class="nh ni it lb b lc ld lf lg li nj lm nk lq nl lu nm nn no np bi translated">以100毫秒的间隔从0到6循环，然后等待300毫秒</li><li id="9c76" class="nh ni it lb b lc nq lf nr li ns lm nt lq nu lu nm nn no np bi translated">以100 ms的间隔从6循环回0，然后等待300 ms。</li></ul><p id="b8b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">动画看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/b568525cbacbcefdc3d964ce1abe580b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*tuOhAWd_pfFfFTqM.gif"/></div></figure><blockquote class="lv lw lx"><p id="c600" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注:如果你对制作那个图像动画的完整代码感兴趣，参考<a class="ae ky" href="https://medium.com/better-programming/practical-image-porterduff-mode-usage-in-android-3b4b5d2e8f5f" rel="noopener">https://medium . com/better-programming/practical-image-porter duff-mode-usage-in-Android-3 B4 b5 D2 E8 f 5 f</a></p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="1c8b" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">常规代码</h1><p id="aeca" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">我只使用RxJava将循环操作放在工作线程之后，这样可以避免暂停UI线程。除此之外，它只是while-loop和sleep (wait)的一个常规代码示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><blockquote class="lv lw lx"><p id="44ce" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">注意:<code class="fe ny nz oa ob b"><em class="it">RxJavaPlugins.setErrorHandler </em><strong class="lb iu"><em class="it">{ </em></strong><em class="it">/*Catch InterruptedException*/ </em><strong class="lb iu"><em class="it">}</em></strong></code><strong class="lb iu"><em class="it"/></strong><em class="it"/>主要是处理Rx中无法被onError捕捉到的睡眠中断。这里有一个解释:<a class="ae ky" href="https://stackoverflow.com/a/57658846/3286489" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/57658846/3286489</a></p></blockquote><h2 id="8cb2" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">赞成的意见</h2><p id="2bac" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">它很容易阅读和理解逻辑，你可以将代码映射到上面的图表中。使用简单的编码控制代码我们可以实现我们想要做的事情。</p><h2 id="40a8" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">骗局</h2><p id="ffed" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">使用<code class="fe ny nz oa ob b">Thread.sleep</code>对于等待来说并不理想，而且考虑到它想要实现的目标，它也相对冗长。需要更多的代码行和更深层次的代码。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="cc48" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">RxJava链接代码</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="6918" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">赞成的意见</h2><p id="93dc" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">代码看起来更加整洁和简洁。所需的代码层次不太深。不需要<code class="fe ny nz oa ob b">Thread.sleep</code>，因为它被<code class="fe ny nz oa ob b">internal</code>操作代替。</p><h2 id="de74" class="oc mk it bd ml od oe dn mp of og dp mt li oh oi mv lm oj ok mx lq ol om mz on bi translated">骗局</h2><p id="39cb" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">乍一看，代码更难理解。它不容易映射到上面所示的流程图。你得知道RxJava操作函数和副作用函数使用，才能做到简洁。它需要更多的精神能量。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="3fb9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就个人而言，为了更好的理解和清晰，我更喜欢传统的编码方法。然而，在这种情况下，由于在这种情况下需要<code class="fe ny nz oa ob b">Thread.sleep</code>，我将使用<code class="fe ny nz oa ob b">interval</code>操作进行RxJava链接。</p><p id="943b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">哪个更好没有对错之分。这只是一种偏好——需要根据具体情况评估其使用情况。有时介于两者之间的混合也同样有效。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="de40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想要上面动画的完整代码，并继续探索这两种编码方法，请从这里获得:</p><div class="oo op gp gr oq or"><a href="https://medium.com/better-programming/practical-image-porterduff-mode-usage-in-android-3b4b5d2e8f5f" rel="noopener follow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd iu gy z fp ow fr fs ox fu fw is bi translated">Android中实际图像端口缓冲模式的使用</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">使用PorterDuff混合两个图像以产生所需的图像输出</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">medium.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf ks or"/></div></div></a></div><p id="9369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望这篇文章对你有帮助。</p></div></div>    
</body>
</html>