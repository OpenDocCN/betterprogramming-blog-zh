<html>
<head>
<title>How One Conditional Can Entangle Your React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个条件如何让你的React应用纠结</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-one-conditional-can-entangle-your-react-app-b817aa47718a?source=collection_archive---------0-----------------------#2021-08-06">https://betterprogramming.pub/how-one-conditional-can-entangle-your-react-app-b817aa47718a?source=collection_archive---------0-----------------------#2021-08-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="b0bf" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated"><em class="kj">一个警示性的探索:缺乏有目的的写作会如何影响你的React项目</em></h2></div><figure class="kl km kn ko gu kp gi gj paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gi gj kk"><img src="../Images/22eb8f295de62f8b9513aa8416cc84fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*axUbED9-8bR86UMk"/></div></div><p class="kw kx gk gi gj ky kz bd b be z dk translated"><a class="ae la" href="https://unsplash.com/@rolls0ut?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jac Alexandru </a>在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="7970" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在软件工程中，甚至一个应用程序代码中的一个字符都可能改变解释计算机的语义，这一点也许是显而易见的。</p><p id="9046" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然而，随着时间的推移，一个简单的表达式，一个简单的条件，可能会影响React应用程序的设计模式和架构，这一点可能不太明显。</p><p id="92e0" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然而，我的团队已经直接经历了这样一个看似无关紧要的实现选择的痛苦后果。仔细想想，这一切都是可以避免的。</p><p id="f650" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">对于那些不熟悉我的文章的人，我喜欢指导新开发人员。我倾向于写一些关于我和我的团队或者我指导的新开发人员遇到的真实场景的文章。</p><p id="69ff" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这种情况下，一个简单的条件表达式导致UI逻辑的复杂纠缠，变得难以推理，更难以维护和扩展，并最终影响整个应用程序。</p><p id="d728" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">希望通过阅读这个特殊的经历，你可以在将来的项目中避免这种情况。</p><p id="99d0" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了充分理解这样一个复杂问题的简单起源，我们必须首先建立一个类似于<strong class="ld iv">清单1 </strong>的基本组件，其中我们创建一个简单的用户输入表单来满足在应用程序中创建“联系人”的任务。</p><p id="775a" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">在这个上下文中，联系人只是一个包含<code class="fe lx ly lz ma b">name</code>、<code class="fe lx ly lz ma b">email</code>和<code class="fe lx ly lz ma b">phoneNumber</code>属性的对象。以下是显示这些属性的一些代码:</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="mb mc l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">清单1 —简单用户输入表单的基本示例。</p></figure><p id="98ee" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如您所见，这段代码相当简单。从我的角度来看，这里没有危险信号或担忧。</p><p id="4e47" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">此外，没有理由怀疑我们应该基于这个看似无关紧要的用例进行全面的架构讨论。</p><p id="b868" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">因此，我们发布了这段代码，并获得了成功。使用它的客户很高兴，因为它最终改善了他们的生活。然后我们转移到其他优先的项目上。</p><p id="a890" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然而，好心没好报。</p><p id="24ec" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">此后不久，我们遇到了客户希望完成的另一个非常相似的用例。在这个新场景中，最终用户现在需要创建一个“潜在客户”</p><p id="2265" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">因为它太相似了，设计师回收了他以前的设计，并做了细微的改动。同样，知道我们之前已经构建了一个类似的组件，我们假设理论上的工作量应该是最小的。</p><p id="8118" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">所以，我们把它滑入了一个已经紧张的冲刺阶段，充满了故事点和迫在眉睫的最后期限。</p><p id="a88b" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">最终，我们重用了之前的组件。为什么要重做工作，对吗？让我们保持代码干燥(不要重复自己)，不要从头开始重新构建一个新的组件，当这个组件具有大部分相同的结构和风格时——特别是因为我们没有很多时间花在这个特定的任务上。</p><p id="6799" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">为了捕捉差异，我们添加了一个“上下文标志”，如清单2 中的<strong class="ld iv">所示，以区分该组件何时呈现在“前景”上下文中。代码如下所示:</strong></p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="mb mc l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">清单2 —更新了组件，在“prospect”页面上呈现时略有不同。</p></figure><p id="fd64" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如您所见，<code class="fe lx ly lz ma b">isProspect</code>的“上下文标志”在第20行实现，并在第31行引用，以便在“前景”上下文中呈现该组件时有条件地呈现新特性。</p><p id="4a1c" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">当我回顾这份公关的时候，我脑海中的某个角落一直萦绕着我。有些事情感觉不对劲，但我说不上来。我的潜意识漫游到一个关于组成的官方反应文件的记忆。</p><p id="2542" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">知道我们必须重构它的时间有多短，我批准了PR，但仍然留下了一些关于合成的评论。毕竟，它只是一个单一的条件表达式——这能有多糟糕呢？</p><div class="md me gq gs mf mg"><a href="https://reactjs.org/docs/composition-vs-inheritance.html#gatsby-focus-wrapper" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab fp"><div class="mi ab mj cl cj mk"><h2 class="bd iv gz z fq ml fs ft mm fv fx it bi translated">组合与继承—反应</h2><div class="mn l"><h3 class="bd b gz z fq ml fs ft mm fv fx dk translated">React有一个强大的组合模型，我们建议使用组合而不是继承来重用代码…</h3></div><div class="mo l"><p class="bd b dl z fq ml fs ft mm fv fx dk translated">reactjs.org</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu ku mg"/></div></div></a></div><p id="dfca" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">巧合的是，在新代码发布后不久，我发现了React播客的一个精彩片段，其中的<a class="mv mw ep" href="https://medium.com/u/a6994650d589?source=post_page-----b817aa47718a--------------------------------" rel="noopener" target="_blank"> Jenn Creighton </a>围绕着同样的主题。我记得和我的团队讨论过这个问题，作为我留下的关于构图的评论是合理的证据。这是一篇很棒的讨论文章，如果你有时间，我强烈推荐这一集。</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="mx mc l"/></div></figure><p id="6369" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如果你没有时间听，播客的主旨是React项目中有意的架构和组成。她描述了好的合成如何利用React的声明式API来执行“显示不告诉”策略。</p><p id="37b1" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然而，许多工程师所做的却是实现无数必要的道具，她亲切地称这种策略为“末日”，从长远来看，这可能会导致一些难以置信的痛苦。</p><p id="4af3" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">不幸的是，尽管围绕这个话题进行了很好的讨论，但“上下文标志”代码仍然存在于我们科技债务分类账的负债栏中。</p><p id="8abd" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">我们根本没有时间回头去看，我们的客户对此没有任何抱怨。此外，由于它是如此小的一段代码，我们不想过度设计任何东西。在这种情况下讨论构图时，许多人争论YAGNI(你不会需要它)原则。</p><p id="429c" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然而，许多工程包括复制已建立的模式(不管是好是坏)。</p><p id="dc46" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">一旦你在应用程序中建立了一个上下文标志，它就会像一个坏主意一样在整个代码库中不断扩散。电影《盗梦空间》提供了一个令人难以置信的观点:</p><blockquote class="my"><p id="bbce" class="mz na iu bd nb nc nd ne nf ng nh lw dk translated">“想法就像病毒。有弹性。传染性极强。甚至一个想法的最小的种子也能成长。它可以定义你，也可以毁灭你。”—盗梦空间</p></blockquote><p id="37db" class="pw-post-body-paragraph lb lc iu ld b le ni jv lg lh nj jy lj lk nk lm ln lo nl lq lr ls nm lu lv lw in bi translated">在这个特定的组件中建立了单独的条件之后，随着时间的推移，逻辑最终被其他开发人员扩展了(尤其是那些没有参与我们的合成讨论的开发人员)。这导致了类似于下面的清单3 中的场景:</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="mb mc l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">清单3——其他开发人员扩展了组件以处理更多用例。</p></figure><p id="220e" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">甚至这可能是最终蛛网化成的淡化版本。当我看到这一切的时候，我所能想到的就是，“呀！”我认为重用这个组件的方法有着诚实的意图。</p><p id="22e0" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">然而，如果没有一个可靠的组成或架构计划，最终的结果是一个可以在许多不同的上下文中使用的组件，但最终是非常脆弱的，而且肯定不灵活。</p><p id="8f3a" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">每当这个组件的公共元素需要在新的上下文中重新应用时，就必须添加额外的术语和条件语句。</p><p id="33a6" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated"><code class="fe lx ly lz ma b">handleSubmit</code>方法要求将业务逻辑添加到组件中，以根据不同上下文标志的值来确定应该应用什么功能。</p><p id="addf" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">此外，<code class="fe lx ly lz ma b">className</code>最终是基于这些上下文标志有条件地确定的，因此组件的风格可以在不同的上下文中改变。</p><figure class="kl km kn ko gu kp gi gj paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gi gj nn"><img src="../Images/e20a97713ec922f19e246de362a15d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9PydQEY7fZsGpz2f"/></div></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@thomascpark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托马斯·帕克</a>在<a class="ae la" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="df92" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">这个例子似乎很孤立于一个只需要重构的组件。然而，当这些上下文标志开始被引入业务逻辑时(如清单3 中<strong class="ld iv">的<code class="fe lx ly lz ma b">handleSubmit</code>函数的情况)，它们最终也会悄悄进入状态管理和服务。这最终会导致一个完全纠缠在一起的应用程序，很难解开。</strong></p><h1 id="7763" class="no np iu bd nq nr ns nt nu nv nw nx ny ka nz kb oa kd ob ke oc kg od kh oe of bi translated">回顾的</h1><p id="fd1d" class="pw-post-body-paragraph lb lc iu ld b le og jv lg lh oh jy lj lk oi lm ln lo oj lq lr ls ok lu lv lw in bi translated">在对这个特定场景进行了一次非常有成效的回顾之后，我的团队认识到可重用性并不意味着单个组件应该处理所有上下文中的所有事情。</p><p id="d7d4" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">相反，如果您看到的设计在组件之间有相似的风格和结构，那么它们的相似之处应该被抽象成一个公共组件，可以用来组成新的组件。</p><p id="a2bf" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">有几种不同的方法来抽象组件，但是我们倾向于坚持React文档中的主要建议并使用子组件。</p><p id="4d30" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated"><strong class="ld iv">清单4 </strong>展示了我们如何使用子元素重构前面清单中的代码，使其更具可组合性。代码如下:</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="mb mc l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">清单4 —一个新的、更加可组合的组件</p></figure><p id="693c" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">既然已经抽象出了这些不同上下文的公共元素，我们就可以组成新的组件，这些组件可以实现它们自己独特的风格、结构和逻辑。这可以防止应用程序的其余部分陷入混乱，并依赖于这些不同上下文之间的共同点。</p><p id="bd48" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated"><strong class="ld iv">清单5 </strong>展示了两个新组件，它们使用<code class="fe lx ly lz ma b">UserForm</code>组件来实现特定上下文的必要需求，而不必重新实现它们共有的样式和结构。代码如下:</p><figure class="kl km kn ko gu kp"><div class="bz fq l di"><div class="mb mc l"/></div><p class="kw kx gk gi gj ky kz bd b be z dk translated">清单5 —由用户表单组件组成的新组件</p></figure><p id="3077" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">如您所见，<code class="fe lx ly lz ma b">createProspect</code>上下文只需要关心新的<code class="fe lx ly lz ma b">referredBy</code>属性，而<code class="fe lx ly lz ma b">createTeamMember</code>上下文不关心这个。同时，<code class="fe lx ly lz ma b">createTeamMember</code>只需要担心它自己独特的同步和提交逻辑，以及它对<code class="fe lx ly lz ma b">role</code>属性的依赖。这种重构后的代码现在同样可重用，但是更加灵活和可扩展。</p><h1 id="661b" class="no np iu bd nq nr ns nt nu nv nw nx ny ka nz kb oa kd ob ke oc kg od kh oe of bi translated">结论</h1><p id="3b8b" class="pw-post-body-paragraph lb lc iu ld b le og jv lg lh oh jy lj lk oi lm ln lo oj lq lr ls ok lu lv lw in bi translated">我的团队现在认为“上下文标志”是一种<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/5-code-smells-react-beginners-should-avoid-480c97799162">代码气味</a>。如果我们碰巧在PR中看到上下文标志，我们一定要深入讨论，以确保上下文标志是合理的。</p><p id="c201" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">否则，我们作为一个团队后退一步，尝试思考如何更好地抽象和重新构建组件，以使我们的代码更具可组合性。</p><p id="e8b0" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">希望您现在能够明白为什么始终保持代码尽可能可组合是如此重要。就像我们从艰难的道路中学到的，一旦一个设计模式——像这个单一的、简单的条件——被引入代码库，它很可能在未来被复制。没有人愿意使用会导致混乱的代码的设计模式。</p><p id="87c0" class="pw-post-body-paragraph lb lc iu ld b le lf jv lg lh li jy lj lk ll lm ln lo lp lq lr ls lt lu lv lw in bi translated">React是一个很棒的框架，具有声明式API和强大的可组合性功能，如果充分利用，从长远来看，可以避免前端应用程序中的许多问题。</p></div></div>    
</body>
</html>