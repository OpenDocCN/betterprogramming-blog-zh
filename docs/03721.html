<html>
<head>
<title>Keeping Your Code DRY</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持代码干燥</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/keeping-your-code-dry-1105377c9c80?source=collection_archive---------3-----------------------#2020-02-29">https://betterprogramming.pub/keeping-your-code-dry-1105377c9c80?source=collection_archive---------3-----------------------#2020-02-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2cae" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重构要点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4d0544928e8cc2e1c231a9381cf0317a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymfK0uoddsfn7JX-Q5znEA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@franckinjapan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰克诉</a>在<a class="ae kv" href="https://unsplash.com/s/photos/repeat?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="a47f" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">背景</h1><p id="f183" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在过去的一周里，我的大部分时间都花在了一个编码挑战上。从理解用户故事到构建应用程序，再到实现代码，再到调试，这绝对是一项艰巨的任务。</p><p id="b9bd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我的组件之间有很多来回。我慢慢开始意识到，当我更改了代码的一部分时，我需要更改依赖于它的代码的所有其他部分。</p><p id="cef2" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">通过改变我的代码的一部分而产生手动改变的下游效应，这违反了DRY(不要重复自己)原则。</p><p id="09d5" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">当您最初写出代码时，这种情况可能比您想象的要多得多。保持代码干燥是重构过程的一部分，所以如果你没有马上发现它，那不是问题。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="d7ff" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">在组件中保持代码干燥</h1><p id="0621" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">我第一次意识到我没有保持代码干燥是在我必须制作一个登录表单的时候。下面的要点显示了我的登录表单的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">非干燥的登录表单</p></figure><p id="053f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这是一个通用的表格，你需要输入你的电子邮件和密码。<code class="fe my mz na nb b">handleChange</code>是使表单成为受控组件的回调函数。</p><p id="bf5e" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果您不熟悉一个受控组件，那么它本质上是React组件的值与DOM上显示的值相同，这符合单一来源的原则。</p><p id="31a8" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">能不能找到代码可能没干的地方？</p><p id="6ec3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">提示:看一下<code class="fe my mz na nb b">input</code>属性。</p><p id="8747" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果你看一下<code class="fe my mz na nb b">input</code>属性和switch/case语句，字符串“email”和“password”是重复的。</p><p id="1bd7" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果您不小心从这些字符串中删除了一个字母，代码仍然可以编译，但现在当您需要将电子邮件和密码值发送到后端时，这将使调试成为一场噩梦。</p><p id="5a11" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">另外，如果我决定更改我的登录表单，不再使用电子邮件作为凭证，而是使用用户名，该怎么办？</p><p id="dbcf" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在，我需要找到所有出现“email”的地方，把它改成“username”。您可能会想:“等等，我的文本编辑器可以找到“name”的所有实例，我可以将其全部替换为“username ”,然后就到此为止。”</p><p id="31dd" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我会说你是正确的，但它没有解决前一段中提到的任何意外错误的问题。</p><p id="71b4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">那么，这种登录表单怎么干呢？您可以将重复的字符串保存到常量中。</p><pre class="kg kh ki kj gt nc nb nd ne aw nf bi"><span id="1cc9" class="ng le iq nb b gy nh ni l nj nk">const EMAIL = "email"<br/>const PASSWORD = "password"</span></pre><p id="4e4d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这将这些字符串的所有实例汇集成一个<em class="nl">单一的真实来源</em>，一个常量。请注意，根据惯例，常量是大写的。</p><p id="e56b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">所以现在，如果您用它们各自的常量替换所有的“email”和“password”字符串，代码看起来会像下面的要点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">登录表单干燥</p></figure><p id="831b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这如何裁定偶然错误的问题？如果常量名称出错(例如，<code class="fe my mz na nb b">EMAIL</code>到<code class="fe my mz na nb b">EMAL</code>)，JavaScript将出现编译错误，因为没有定义不正确的常量名称。</p><p id="765d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果你在字符串或者常量的值上犯了一个错误，你可以准确的指出错误在哪里，因为只有一行声明了这个值。这样可以节省时间和精力，彻底检查您的代码，寻找潜在的小错误。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="784b" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">跨组件保持代码干燥</h1><p id="a0aa" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">到目前为止，我们讨论了在组件中保持干燥。但是如果在多个组件中使用相同的值会怎么样呢？</p><p id="be21" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">出于演示目的，让我们引入另一个组件。我们也将重复使用登录表单，因为我们在这一点上已经很熟悉了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有获取请求的登录表单</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">带有获取请求的朋友组件</p></figure><p id="9c95" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在登录表单中，我添加的唯一内容是包含URL的获取请求的前半部分。获取请求的其余部分不适用于本主题。</p><p id="9a05" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在<code class="fe my mz na nb b">Friends</code>组件中，当组件被挂载时，它向后端发出一个获取请求，以检索与ID为1的用户相关联的所有朋友。</p><p id="fa47" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">请注意，我一引入<code class="fe my mz na nb b">Friends</code>组件，我们的代码就不枯燥了。但是怎么做呢？</p><p id="ae9b" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果查看两个组件中的获取请求，URL使用相同的域:<code class="fe my mz na nb b">http://localhost:3001</code>。通常情况下，域名永远不会改变，这是一个完美的应用程序，提取URL的域部分，并将其保存为一个常数，就像我们以前所做的一样！</p><p id="1182" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">但是等等，这是跨组件的，不是同一个组件内的。将URL的域部分分配给一个变量并在同一个组件中使用一次是多余的。</p><p id="f299" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">那么，我们如何保存域URL并在多个组件中使用它呢？就像我们处理库一样，我们可以<code class="fe my mz na nb b">import</code>它们！但是，我们可以创建一个包含所有常量的文件，并根据需要导入它们，而不是拥有一个变量库。</p><p id="0800" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">因此，首先，让我们创建常量文件并将域URL放入其中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="7c10" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">接下来，我们在需要的文件中导入<code class="fe my mz na nb b">DOMAIN</code>常量，然后用<code class="fe my mz na nb b">DOMAIN</code>替换所有使用<code class="fe my mz na nb b">http://localhost:3001</code>的实例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实现了导入的域常量的登录表单</p></figure><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实现了导入的域常量的Friends组件</p></figure><p id="8c02" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">跨多个组件保持代码干燥就是这么简单！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="b0ad" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">利用Constants.js</h1><p id="7238" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在代码的这一点上，我们创建了一个单独的文件<code class="fe my mz na nb b">Constants.js</code>，用来存储跨多个组件使用的常量。</p><p id="93d9" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">下一个问题是这样的:“我们是否希望使用<code class="fe my mz na nb b">Constants.js</code>来存储在这个时间点上只属于组件(例如，登录表单组件)的常量？”</p><p id="d394" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">答案是…我不知道。我可以很容易地为这两种情况进行论证。</p><h2 id="0cb9" class="ng le iq bd lf nm nn dn lj no np dp ln me nq nr lp mi ns nt lr mm nu nv lt nw bi translated"><strong class="ak"> 1。将所有常量存储在Constants.js中</strong></h2><p id="c620" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">通过将所有常量存储在<code class="fe my mz na nb b">Constants.js</code>中，文件只有一个责任。这也使得调试更加容易，因为所有常量值的唯一来源都在该文件中。</p><p id="217e" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">可伸缩性也是一个重要因素，因为如果您要创建使用相同常量的新组件，我们可以直接导入它们，而不必担心在本地组件级别第一次使用常量时重构组件。</p><h2 id="07fc" class="ng le iq bd lf nm nn dn lj no np dp ln me nq nr lp mi ns nt lr mm nu nv lt nw bi translated">2.<strong class="ak">仅在Constants.js中存储跨多个组件使用的常数</strong></h2><p id="2c15" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">这意味着在本地组件级别使用的常量将<em class="nl">仅</em>用于该组件。这缩小了常数的使用范围。</p><p id="8d66" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果您在不同的组件中看到相同的常数，这可能表明该常数的使用不正确，或者该组件可能一开始就不需要该常数。</p><p id="f5e3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在这两种情况下，我认为在实现代码之前需要做出设计决策。</p><p id="10cf" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果您在实现过程中改变了主意，您将需要解析所有组件，并确定常量是应该在本地级别还是在常量文件中。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="3a34" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">结论</h1><p id="3d9b" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">保持代码干燥可以避免代码味道。当进行调试时，它用最少的努力维护干净简洁的代码，并最小化重复。</p><p id="b4a3" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">请记住，你不必像我一样应用干燥原则。我确信有其他方法可以保持代码干燥，只要你不重复自己，你就在正确的轨道上！</p></div></div>    
</body>
</html>