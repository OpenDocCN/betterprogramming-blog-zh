# 动态转换 MySQL 文件为 Postgres 格式

> 原文：<https://betterprogramming.pub/convert-mysql-files-to-postgres-format-on-the-fly-1a9bde5a186b>

## 编写一个自定义脚本，允许将 MySQL 文件加载到 Postgres 中

![](img/fee80d89e923bf869f7bae948624b08b.png)

扬·安东宁·科拉尔在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

有时候，生活会给你一个 SQL 文件来加载到你的数据库中，但它的格式不正确。这发生在我身上。

我为 MySQL 生成了一个文件，需要将它加载到我的 Postgres 数据库中。标准解决方案需要联系供应商，要求他们提供正确的文件，或者使用转换器软件。不幸的是，这两种方法都不合适。

因此，我将演示第三种方法——一个自定义脚本，它允许您将 MySQL 文件加载到 Postgres 中，同时动态转换它，而无需创建任何额外的文件和在驱动器上分配额外的空间。

该文件由两部分组成。首先是表创建部分，这基本上是一个大型语句，它在数据库中创建一个空表来装载数据。

第二部分，向表中插入行:

最难重写的部分是第一个，因为在声明表时，MySQL 和 Postgres 有很多不同，而 INSERT 语句非常相似。

# 表格部分的修改

计划是编写一个 Python 脚本，逐行读取 SQL 文件，并将 MySQL 语法更改为 Postgres。然后一旦检测到一个`;`符号，就向服务器提交查询。

我将使用一个标准的`psycorg`库来提交查询。首先，让我们编写一个处理查询的函数。我们可以调用它将数据写入数据库。

现在，计划如下:

*   将该行从原始文件读入变量`sql_line`。
*   检查是否包含方言矛盾。如果是这样，请修复它们。
*   将该行添加到包含整个语句的变量中。
*   如果该行包含`;`符号，则向数据库提交该语句。

首先，MySQL 在表和列名中使用反勾符号，而 Postgres 使用双引号。这个很容易操作，如下图所示:

```
sql_line = sql_lone.replace('`', '"')
```

另一个容易处理的方面是时间戳格式:

```
sql_lime = sql_line.replace("datetime", "timestamp(0)")
```

现在，Postgres 在为列指定`INT`类型时，括号中不需要任何数字，所以需要删除。

要实现自动递增的列，我们需要用`SERIAL`替换`AUTO_INCREMENT`关键字。该行还可能包含列名和自动递增关键字之间的内容，所以我们将忽略这一点，并在列名之后写入 serial 关键字。

我也把评论全删了。

现在，MySQL 有了关键字`collate`，我们也不需要了，可以把它和它后面的字删掉。

有些列具有`unsigned`属性。Postgres 中没有这样的属性，但是我们可以简单地检查列中的所有值是否都大于 0。

声明枚举最棘手的部分是 MySQL 枚举类型需要在 table 语句之前声明一个自定义类型。

```
CREATE TYPE enum_1 as ENUM ('value 1', 'value 2');
```

然后在 table 语句中，创建该类型的列:

```
”ENUM_column” enum_1 NOT NULL
```

所以，如果我们遇到这个关键字，我们需要解析行中可能的条目，在整个 table 语句的开头声明类型，然后，创建一个新声明类型的列。结果是下面的代码:

专栏部分到此为止。现在，我们需要处理表约束。

该文件包含三个基本约束:

*   `primary key`。在 Postgres 中，主键是通过向列添加相应的关键字来声明的，因此我们需要解析主键语句，找出主键的名称，并更改创建该列的行。
*   `Unique key`。这里使用了相同的方法。我们需要解析原始行中的唯一键约束，并将`unique`关键字添加到相应的列中。
*   `Foreign key`。创建外键的语法有很大的不同。在我的键中，外键语句中提到的两个表都不存在于我的数据库中，所以我忽略了它们。但在下面的例子中，有一段代码将代码改写成 Postgres 格式，只是为了通用性。

因此，结合所有三种方法，我们得到以下结果:

在所有这些转换之后，我们有了创建预期表的 Postgres 工作代码。剩下要做的就是向服务器提交查询，我们可以使用下面的代码来完成:

`execute_sql(table_statement)`

之后，我们只需要遍历所有剩余的行，并将数据插入新生成的表中。

# 调整 INSERT 语句

上面已经提到过，`INSERT`语法在 MySQL 和 Postgres 中非常相似，除了一点不同。

不同之处在于对转义字符的处理。在 MySQL 中，如果一个人需要在字符串中包含一个撇号，他所要做的就是在它前面加一个反斜杠。在 Postgres 中，除此之外，还需要一个大写字母`E`来表示该行可能包含转义字符。

```
'McDonald\'s' -> E'McDonald\'s'
```

因此，让我们编写一个函数来检测字符串中的反斜杠，并在撇号打开该字符串之前添加一个大写字母`E`。这里引人注意的是，这一行可能有多个撇号，因此，在放置字母`E`之前，我们需要检查这个撇号是否实际上是字符串的开头。

和以前一样，我们需要用引号替换任何反勾号。

原来如此。现在我们可以安全地执行该行了，它将像这样出现在您的表中:

```
execute_sql(sql_line)
```

这个差异列表并不详尽；我只介绍了我自己在加载文件时遇到的问题，如果您使用该脚本，您可能会遇到其他问题。

感谢阅读。

完整的代码可以在 [GitHub 库](https://github.com/Megachell/mysql-to-postgres)中找到。