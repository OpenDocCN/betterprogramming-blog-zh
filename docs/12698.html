<html>
<head>
<title>An Interesting Case for Using a Custom RxJs Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用定制RxJs操作符的有趣例子</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-interesting-case-for-using-a-custom-rxjs-operator-da8443a89c3a?source=collection_archive---------6-----------------------#2022-06-23">https://betterprogramming.pub/an-interesting-case-for-using-a-custom-rxjs-operator-da8443a89c3a?source=collection_archive---------6-----------------------#2022-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e23d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">RxJs库附带了一组丰富的操作符，这些操作符能够处理我们在处理可观察流时必须处理的大多数情况。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca293af0bf1e2c3a7463f62280e1a7f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hiI0uRTd8eEVewK1tz0Mtg.png"/></div></div></figure><p id="1095" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">尽管有些情况下构建新的自定义操作符可能会派上用场。让我们来看一个受stackoverflow 上发布的<a class="ae lq" href="https://stackoverflow.com/questions/70851715/rxjs-how-to-get-all-values-that-are-buffered-during-a-concatmap/70903577?noredirect=1#comment125435996_70903577" rel="noopener ugc nofollow" target="_blank">问题启发的特殊案例。</a></p><h1 id="7e66" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">问题:连接映射时的缓冲</h1><p id="66da" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">让我们考虑一个场景，我们有一个记录流，例如来自汽车的“黑匣子”，它流入接收系统，该系统必须尽快将它们存储到数据库中。</p><p id="c897" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接收系统有一个API<code class="fe mo mp mq mr b">saveRec</code>，它可以接受要存储的记录数组，并在所有记录都被写入时异步响应。不幸的是，我们还有一个约束:<code class="fe mo mp mq mr b">saveRec</code>不能被同时调用。换句话说，当我们可以调用API时，我们必须在再次调用它之前等待它的响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/774dd4c9897e389763e9a38061c66ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-n7BT1P-fBfoNKyKPohcg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">通过对saveRec API的连续调用来接收和保存记录流</p></figure><p id="1207" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当并发级别限制为1时，典型的RxJs方法是使用<code class="fe mo mp mq mr b">concatMap</code>操作符(只不过是<code class="fe mo mp mq mr b">concurrent</code>参数设置为<code class="fe mo mp mq mr b">1</code>的<code class="fe mo mp mq mr b">mergeMap</code>)。</p><p id="ef69" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下使用<code class="fe mo mp mq mr b">concatMap</code>可能不是最佳解决方案。例如，让我们想象一下，接收记录之间的时间间隔比<code class="fe mo mp mq mr b">saveRec</code>响应所需的时间短。在这种情况下，我们将累积等待存储的记录(这些记录保存在<code class="fe mo mp mq mr b">concatMap</code>操作符内部的缓冲区中，但我们稍后将回到这一点)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/870018880fb05189264486aad625e780.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvPxS9dIe13W52H1A0rTAA.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">concatMap在执行saveRec操作时缓冲一些记录</p></figure><p id="bbf4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">考虑到<code class="fe mo mp mq mr b">saveRec</code>可以接受一个记录数组，理想的情况是在执行前一个调用的过程中使用缓冲的所有记录来调用它。</p><p id="e467" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，如果我们在对<code class="fe mo mp mq mr b">rec_3</code>执行<code class="fe mo mp mq mr b">saveRec</code>操作时收到了<code class="fe mo mp mq mr b">rec_4</code>和<code class="fe mo mp mq mr b">rec_5</code>，那么在下一次调用中，我们将传递<code class="fe mo mp mq mr b">rec_4</code>和<code class="fe mo mp mq mr b">rec_5</code>以进行保存。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/0ec5967c5053737a5e3ca21fa7e9841a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoCAOhALC67W_j71-pZWJg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">bufferConcatMap调用saveRec，并将所有记录累积在其缓冲区中</p></figure><p id="1a74" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们将要用新的定制操作符<code class="fe mo mp mq mr b">bufferConcatMap</code>实现的。实际上<code class="fe mo mp mq mr b">bufferConcatMap</code>是一个<em class="mz">可管道化操作符工厂函数</em>，因为它是一个在被调用时返回一个<em class="mz">可管道化操作符</em>的函数，该操作符然后作为参数传递给<code class="fe mo mp mq mr b">Observable</code>的<code class="fe mo mp mq mr b">pipe</code>方法。</p><h1 id="0181" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是“可管道操作符”和“可管道操作符工厂函数”</h1><p id="265e" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在开始实现之前，可能有必要定义什么是RxJs <em class="mz">可管道操作符</em>，以及什么是<em class="mz">可管道操作符工厂函数</em>。</p><p id="0761" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mz">可管道操作符</em>是一个函数，它接受一个可观察值作为输入，并返回一个可观察值作为输出(RxJs代码代表一个<em class="mz">可管道操作符</em>类型，带有接口<code class="fe mo mp mq mr b">OperatorFunction&lt;T, R&gt;</code>或其扩展之一)。</p><p id="d7c4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="mz">可管道操作符工厂函数</em>是返回<em class="mz">可管道操作符</em>的函数。</p><p id="ab41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们新的自定义操作符<code class="fe mo mp mq mr b">bufferConcatMap</code>是一个函数，它返回一个期望一个可观察值作为输入并返回一个可观察值的函数。</p><p id="e4c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">准确地说，这是一个<em class="mz">可管道化的操作符工厂函数</em>，从现在开始，我们将简单地称它为<em class="mz">自定义操作符</em>，因为这是一种普遍接受的引用这类函数的方式。</p><h1 id="e8ab" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">简单的自定义运算符</h1><p id="ae51" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">一个简单的自定义操作符可以这样编码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/f418bdddacfe0d33e24cbb8ac82ce676.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxzNfdY20Z5vsDglTGHFCQ.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">一个定制操作符(更准确地说是一个“可管道化的操作符工厂函数”)，它镜像源可观察对象</p></figure><p id="b70d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个自定义操作符创建了一个新的可观察对象，它反映了源可观察对象。换句话说，它什么也不做，但仍然显示了该机制是如何工作的。</p><p id="539f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，假设我们想要转换由源可观察对象通知的每个值，然后将转换后的值及其索引传递给订阅者(换句话说，我们想要从头开始构建rxJs <code class="fe mo mp mq mr b">map</code>操作符)。</p><p id="e66d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是可以做到的</p><ul class=""><li id="d747" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">向<em class="mz">可管道化操作符工厂函数</em>传递用于转换从源接收的每个值的函数</li><li id="f539" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">利用Javascript“closure”概念定义一个变量(本例中的变量<code class="fe mo mp mq mr b">index</code>),该变量在可观察返回被订阅时初始化，在<code class="fe mo mp mq mr b">subscriber</code>上调用<code class="fe mo mp mq mr b">next</code>函数时递增</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/a497e4c7d2295ce0e80325d44ef0400c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kk9PffSnpZs-oq7WoBWzcg.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">“地图”操作符从零开始构建</p></figure><p id="499b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有趣的是，利用Javascript闭包，我们将一些“状态”(<code class="fe mo mp mq mr b">index</code>变量)附加到一个函数，由<code class="fe mo mp mq mr b">subscriber</code>定义的<code class="fe mo mp mq mr b">next</code>函数。向函数添加状态的能力将在<code class="fe mo mp mq mr b">bufferConcatMap</code>的实现中变得非常重要。</p><h1 id="c341" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">“bufferConcatMap”运算符</h1><p id="58ad" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">既然我们已经阐明了定制操作符的基础，让我们开始构建我们的<code class="fe mo mp mq mr b">bufferConcatMap</code>。</p><h2 id="94c3" class="nq ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">预期的行为</h2><p id="f094" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">使用上述示例，预期行为可以用大理石图来表示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/44ee0e33c64a7b629908958b4a163a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icrUBQEzwOF52MOefVDyPA.png"/></div></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">bufferConcatMap的大理石图</p></figure><p id="3369" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">用我们可以说的话来表达:</p><ul class=""><li id="52fc" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">如果上游通知并且没有即时处理，则通知的值会立即被处理</li><li id="c9c2" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">如果上游通知并且正在进行处理，那么通知的值将存储在缓冲区中</li><li id="f5a6" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">一旦处理完成，如果缓冲区中有内容，它会被立即处理，否则我们等待下一个元素开始新的处理</li></ul><p id="9274" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简单起见，我们没有在“需求的文字”中涵盖<code class="fe mo mp mq mr b">error</code>和<code class="fe mo mp mq mr b">complete</code>的情况(但是它们在代码中)。</p><h2 id="a802" class="nq ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">我们需要一些状态</h2><p id="615b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">是的，我们需要保存一些状态信息，以便操作员按预期工作:</p><ul class=""><li id="a00b" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">当我们还在处理请求时，我们需要一个缓冲区来保存来自上游的值；</li><li id="ac8f" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">“在我们处理请求时”？这意味着我们需要有一种方法来知道我们是否正在处理一个请求。</li></ul><p id="903c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们的状态由两个变量组成:</p><ul class=""><li id="bcbd" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated">一个<code class="fe mo mp mq mr b">buffer</code>(一个数组)来保存我们不能处理的项目；</li><li id="5d64" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated">一个<code class="fe mo mp mq mr b">processing</code>标志(一个布尔值),我们在其中存储是否有请求。</li></ul><h2 id="0685" class="nq ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">操作者的解剖</h2><p id="c67b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated"><code class="fe mo mp mq mr b">bufferConcatMap</code>操作符实际上是一个<em class="mz">可管道操作符工厂函数</em>，它期望一个<code class="fe mo mp mq mr b">project</code>函数作为输入参数，并返回一个<em class="mz">可管道操作符。</em></p><p id="be62" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">输入参数</strong></p><p id="41b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">project</code>函数是一个期望输入值数组并返回可观察值的函数。为什么要用一组值作为输入？因为<code class="fe mo mp mq mr b">bufferConcatMap</code>将接收到的值存储在一个缓冲区中，该缓冲区是一个数组，并且一旦没有动态处理，就将该缓冲区传递给<code class="fe mo mp mq mr b">project</code>函数。</p><p id="65c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为什么要返回一个可观测的？因为<code class="fe mo mp mq mr b">bufferConcatMap</code>的行为类似于<code class="fe mo mp mq mr b">concatMap</code>的变体，正如<code class="fe mo mp mq mr b">concatMap</code>所做的，它期望作为输入传递的函数是一个返回可观察值的函数。</p><p id="0659" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">返回的<em class="mz">可管操作员</em> </strong></p><p id="224d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为输出返回的<em class="mz">可管道化运算符</em>本身就是一个函数，它期望一个<code class="fe mo mp mq mr b">source</code>可观察值作为输入，并返回一个“新的转换后的可观察值”。</p><p id="3514" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果没有请求，那么“新转换的可观察对象”的行为类似于用<code class="fe mo mp mq mr b">concatMap</code>创建的可观察对象:它调用<code class="fe mo mp mq mr b">project</code>函数，并在进行下一次调用之前等待其响应，不同之处在于<code class="fe mo mp mq mr b">project</code>函数是用来自<code class="fe mo mp mq mr b">source</code>可观察对象(上游)的<code class="fe mo mp mq mr b">buffer</code>值调用的，而不是只有一个值。另一方面，如果有一个请求已经在运行中，它获取由<code class="fe mo mp mq mr b">source</code> Observable通知的值，并将其存储到其内部缓冲区中，而不调用<code class="fe mo mp mq mr b">project</code>函数(换句话说，对下游没有影响)。</p><h2 id="76d1" class="nq ls it bd lt nr ns dn lx nt nu dp mb ld nv nw md lh nx ny mf ll nz oa mh ob bi translated">操作员的代码</h2><p id="9677" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">最后，这里是我们自定义操作符的完整代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">bufferConcatMap自定义运算符</p></figure><p id="9a21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里有一个如何使用它的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">bufferConcatMap的使用示例</p></figure><p id="caca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们来看看这个逻辑基础上的一些关键概念。</p><p id="6381" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">最外部功能(</strong> <code class="fe mo mp mq mr b">bufferConcatMap</code> <strong class="kw iu"> ) </strong>。最外部的函数，一个<em class="mz">可管道化的操作符工厂函数</em>，作为<code class="fe mo mp mq mr b">pipe</code>调用的一部分被调用，它代表一个参数(换句话说，看上面的例子，当<code class="fe mo mp mq mr b">newTransformerObservable</code>被创建时)。</p><p id="ebee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"><em class="mz">管工</em> </strong>。真正的<em class="mz">可管道操作符</em>由<code class="fe mo mp mq mr b">bufferConcatMap</code>返回的函数只有在<code class="fe mo mp mq mr b">newTransformerObservable</code>被订阅时才会被调用。</p><p id="4124" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">操作员的内部状态</strong>。当<em class="mz">可管道操作符</em>被调用时(在订阅时)，保存操作符状态的变量(在我们的例子中是<code class="fe mo mp mq mr b">bufferedNotifications</code>和<code class="fe mo mp mq mr b">processing</code>)被初始化。这些变量是在<em class="mz">可管道化操作符</em>的主体中定义的任何函数的词法范围的一部分(例如，定义为参数的函数被传递给嵌入在<code class="fe mo mp mq mr b">bufferConcatMap</code>实现中的<code class="fe mo mp mq mr b">concatMap</code>操作符)，因此，每当源可观察对象(上游)通知一个新值时，这些函数的所有调用都会共享这些变量。</p><p id="3a0e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b"><strong class="kw iu">project</strong></code> <strong class="kw iu">和</strong> <code class="fe mo mp mq mr b"><strong class="kw iu">EMPTY</strong></code>。<code class="fe mo mp mq mr b">bufferConcatMap</code>的实现是围绕<code class="fe mo mp mq mr b">concatMap</code>的一个变化，它使用一些内部状态来实现期望的行为。<code class="fe mo mp mq mr b">concatMap</code>要求作为输入传递一个返回可观察值的函数。当上游通知新值时，如果某些处理正在进行中，<code class="fe mo mp mq mr b">bufferedConcatMap</code>只需缓冲该值，而<em class="mz">不做任何事情</em>。什么都不做的可观察对象是<code class="fe mo mp mq mr b">EMPTY</code>可观察对象。这是可以观察到的，只要它从上游接收到第一个通知。所以这就是为什么<code class="fe mo mp mq mr b">processing</code>是<code class="fe mo mp mq mr b">true</code>的时候<code class="fe mo mp mq mr b">bufferConcatMap</code>用<code class="fe mo mp mq mr b">EMPTY</code>。另一方面，如果没有正在进行的处理，只要缓冲区中有值，就用存储在缓冲区中的值调用<code class="fe mo mp mq mr b">project</code>函数。</p><h1 id="44ca" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">哦，还有一件事</h1><p id="aeb2" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">到目前为止一切都很好，至少看起来是这样。但是我们忽略了一些东西。</p><p id="cec9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们像这样使用<code class="fe mo mp mq mr b">bufferConcatMap</code>创建一个可观察对象，然后我们同时订阅它两次，像这样</p><pre class="kj kk kl km gt of mr og oh aw oi bi"><span id="8931" class="nq ls it mr b gy oj ok l ol om">const newObs = source.pipe(bufferConcatMap((val) =&gt; process(val)));</span><span id="6409" class="nq ls it mr b gy on ok l ol om">newObs.subscribe(values =&gt; {// do something});</span><span id="076f" class="nq ls it mr b gy on ok l ol om">newObs.subscribe(values =&gt; {// do something else});</span></pre><p id="cf5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，当<code class="fe mo mp mq mr b">bufferConcatMap</code>被调用时，即当<code class="fe mo mp mq mr b">newObs</code>被创建时，状态变量(<code class="fe mo mp mq mr b">bufferedNotifications</code>和<code class="fe mo mp mq mr b">processing</code>)被初始化。</p><p id="ef37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，相同的变量在两个订阅中共享，这是错误的，会产生非常细微的错误。我们需要确保每个订阅都有自己的状态变量副本，这些副本是在订阅时初始化的。</p><p id="0ca6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，在这种情况下，rxJs操作员<code class="fe mo mp mq mr b">defer</code>帮助了我们。因此，该运算符的最终正确版本如下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="od oe l"/></div><p class="mt mu gj gh gi mv mw bd b be z dk translated">bufferConcatMap代码的最终版本，也适用于并发订阅</p></figure><h1 id="fcae" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="7314" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在大多数情况下，RxJS库提供的操作符已经足够了，但是有时构建自定义操作符可能会很方便。如果是这种情况，我们必须记住<a class="ae lq" href="https://benlesh.com/posts/learning-observable-by-building-observable/" rel="noopener ugc nofollow" target="_blank">可观测量只是特殊的函数</a>。运算符只是处理这种特殊函数的函数。</p><p id="9733" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，构建自定义操作符是一项功能组合练习，必须遵循一组有限的规则。使用闭包，我们可以给操作符添加一个内部状态来增强它们的能力，同时保持外部行为有状态。</p><p id="7996" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">bufferConcatMap</code>背后的所有代码，包括测试，都可以在<a class="ae lq" href="https://github.com/EnricoPicci/bufferConcatMap" rel="noopener ugc nofollow" target="_blank">这个repo </a>中找到。</p></div></div>    
</body>
</html>