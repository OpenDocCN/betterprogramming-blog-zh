<html>
<head>
<title>What Goes Around Comes Around</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">恶有恶报</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-goes-around-comes-around-1aae51da0f29?source=collection_archive---------4-----------------------#2020-11-11">https://betterprogramming.pub/what-goes-around-comes-around-1aae51da0f29?source=collection_archive---------4-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d9ec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在Android应用程序中创建循环回收视图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/75d25e74c18ba3a926ea31ebb5462364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pJe1OaZWHX1AMXpLgBM_Uw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">Reuben Mcfeeters 在<a class="ae kv" href="https://unsplash.com/s/photos/circle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e1d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> </strong>圆形<code class="fe ls lt lu lv b">RecyclerView</code>是当滚动时到达列表的末尾时，第一个项目跟随最后一个项目的视图。这为用户在导航包含大量项目的组件时提供了一种连续性的感觉。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/0de900438aea7b33e4f6ac46fd4e6146.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*-qjO5O1RejZ6xdsiEdL7mw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">运行中的循环视图。</p></figure><p id="cea2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多应用都在最显眼的页面上实现了这种行为:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/d3e944f50da177f76a34ecd4d895fb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*jQgzgoRvDmzRmtJUaEgReA.jpeg"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/1e8081284298f6a385bd0edc0cb2e860.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*6ljKHEDRtQZmVVNz5P0Ftg.jpeg"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/d6b2508825fa61fbee92a1ad838db95a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*2ELKKsQR2uQlxbds4UsW-w.jpeg"/></div></figure><p id="610c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尝试使用两种策略来实现这一点:</p><ul class=""><li id="2f38" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">无限项目</li><li id="ebc2" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">自定义滚动监听器</li></ul><p id="7d32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些方法各有利弊。希望能帮助你解决这个问题，做出明智的决定，选择最适合自己情况的实现。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="2f33" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">建立基线</h1><p id="2bcc" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我将首先实现一个包含三个项目的普通<code class="fe ls lt lu lv b">RecyclerView</code>。每个项目都使用图像视图显示。这将有助于我们比较循环实现相对于基线的效率:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/07256cae1ff48854b61dfcebbe3ad426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gN-FEsCn93fH7sQiLJfyWQ.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">显示图像的简单水平循环视图</p></figure><p id="ca2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">滚动几次并让它稳定下来后的内存分配如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/01733cf2bf64982188fdb0a7c9ebae76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hPDEkj7txRl_8-n-bZ0bDQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">普通RecyclerView实现的内存分配</p></figure><p id="d8fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这与预期相符:三个<code class="fe ls lt lu lv b">ImageViews</code>和三个<code class="fe ls lt lu lv b">Bitmaps</code>基本上概括了正常的实现。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="9cb6" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">实施1-无限项目</h1><p id="8b3e" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe ls lt lu lv b">RecyclerView</code>被骗以为有非常多的项目要显示，但是当渲染发生时，使用了位置的模和项目的实际数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/c314e145e13796c62f3df7e668650231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J_qDKTg20Mw06g7vfhr96Q.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无限项来创建循环回收视图</p></figure><p id="5f04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个非常简单的实现，从<code class="fe ls lt lu lv b">RecycleViewAdapter</code>的<code class="fe ls lt lu lv b">getItemCount()</code> <em class="ns"> </em>方法返回<code class="fe ls lt lu lv b">Int.MAX_VALUE</code> <strong class="ky ir"> </strong>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">实现无限项适配器</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/6cd3790febacdb65f8c0c52faaae6014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VC-vkBbJRhWtc4taNI2vng.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">无限项实现的内存分配</p></figure><p id="c2ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与基线相比，除了<code class="fe ls lt lu lv b">BitmapDrawable</code>之外，大部分分配似乎都翻了一番。在这种情况下，在几个卷轴之后，它已经跳到了278个分配。在记忆是奢侈品的情况下，这可能是一个令人担忧的原因。</p><p id="2a6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种实现的优点是非常简单。</p><p id="aa82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果你希望<code class="fe ls lt lu lv b">RecyclerView</code>能够从开始向两个方向滚动，那么应该设置RecyclerView的初始位置。这将在第一个项目前后放置相同数量的项目。</p><pre class="kg kh ki kj gt nw lv nx ny aw nz bi"><span id="da9a" class="oa mt iq lv b gy ob oc l od oe">recycler.scrollToPosition((Int.MAX_VALUE/2)-(Int.MAX_VALUE/2)%noOfItems)</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="9b9f" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">实现2 —自定义滚动监听器</h1><p id="6e06" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated"><code class="fe ls lt lu lv b">RecyclerView</code>被骗以为要显示的项目数量是原来的两倍，并附加了一个定制的滚动监听器，每当到达末尾时，这个监听器就会悄悄地修改<code class="fe ls lt lu lv b">RecyclerView</code>的当前滚动位置:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/06cf6724073deb14fcbe5325a315c92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsDHpRYGxWdtfKtGLR9xjA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">创建循环RecyclerView的专用滚动侦听器</p></figure><p id="e562" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个实现中，从适配器的<code class="fe ls lt lu lv b">getItemCount()</code> <em class="ns"> </em>返回双倍数量的项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自定义滚动侦听器循环回收视图的适配器</p></figure><p id="d41d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除此之外，我们还需要给<code class="fe ls lt lu lv b">RecyclerView</code>添加一个自定义<code class="fe ls lt lu lv b">OnScrollListener</code> <em class="ns"> </em>。在这个滚动监听器中，每当我们意识到我们在<code class="fe ls lt lu lv b">RecyclerView</code>的末尾时，我们就悄悄地将它滚动到第一个位置。使用<code class="fe ls lt lu lv b">recyclerView.addOnScrollListener(CircularScrollListener())</code>将滚动监听器连接到<code class="fe ls lt lu lv b">RecyclerView</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">RecyclerView的自定义滚动侦听器</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/1f121d3569b358abdfaf0cf3636872a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fk_cF8unhZ2STkG3mTXoFg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">自定义滚动实现的内存分配</p></figure><p id="8591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<code class="fe ls lt lu lv b">ImageViews</code>之外，<code class="fe ls lt lu lv b">Bitmaps</code>的所有其他分配都相当于非循环实现——这是以复杂性为代价获得的优势。</p><p id="9765" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这种实现有一些注意事项，但是它们的处理非常简单:</p><ul class=""><li id="084a" class="lx ly iq ky b kz la lc ld lf lz lj ma ln mb lr mc md me mf bi translated">根据<code class="fe ls lt lu lv b">RecyclerView</code>中的项目数量和每个项目的大小，您可能需要欺骗<code class="fe ls lt lu lv b">RecyclerView</code>以为项目数量可能是实际数量的三到四倍。这是一种反复试验的方法，可以找到最适合您需要的计数。</li><li id="74aa" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">对于有大量项目的<code class="fe ls lt lu lv b">RecyclerView</code>,如果快速滚动，可能不会收到最后一个位置项目的回调，因此需要额外的处理，以便在滚动过度的情况下安静地向后滚动。</li><li id="796a" class="lx ly iq ky b kz mg lc mh lf mi lj mj ln mk lr mc md me mf bi translated">在滚动监听器中需要额外的处理来实现向后滚动。</li></ul><p id="c03f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理所有这些情况的高级滚动侦听器如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">处理警告的滚动侦听器的高级实现</p></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0ea4" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">结论</h1><p id="81dd" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我已经尝试解释了我们所做的详细分析，以选择实施循环<code class="fe ls lt lu lv b">RecyclerView</code>的最佳和最有效的方法，这样您就可以做出更明智的决定。请在评论中告诉我是否有其他方法可以实现这一点。</p></div></div>    
</body>
</html>