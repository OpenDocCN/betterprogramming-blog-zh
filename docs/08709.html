<html>
<head>
<title>Don’t Use Java For Loops — Consider Java Streams Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要使用Java For循环——考虑Java流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/dont-use-java-for-loops-consider-java-streams-instead-e439d09940b7?source=collection_archive---------1-----------------------#2021-06-03">https://betterprogramming.pub/dont-use-java-for-loops-consider-java-streams-instead-e439d09940b7?source=collection_archive---------1-----------------------#2021-06-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3868" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">永远不要再编写for循环</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bbe8464a3dc92267c23bf322d5bc1382.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GHjKBFxMRg0lJlBs"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹·弗里曼在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="fa4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流是Java 8最重要的特性之一。为了找出它们有用的原因，你需要理解Java中的流是什么。</p><p id="f781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">流</em>是一个数据序列，允许对所有或部分数据进行特殊类型的处理。我们可以创建流或将现有的结构转换成流。流可以代替循环，因为它们允许处理数据序列(类似于循环)。</p><p id="ecf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个例子。</p><p id="41e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们想创建一个随机数列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="5043" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们决定将所有大于<code class="fe ly lz ma mb b">5</code>的数字过滤到一个新列表中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2d0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="0cd2" class="mg mh it mb b gy mi mj l mk ml">[8, 6, 8, 6]</span></pre><p id="50a4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我总是觉得这种语法相当冗长。让我们试着用流来简化这个代码逻辑。</p><p id="0088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:请记住，因为数字是随机的，所以您的列表会有所不同。</em></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="bcfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="15c5" class="mg mh it mb b gy mi mj l mk ml">[7, 8, 6]</span></pre><p id="4991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，随机性会导致列表大小发生变化。</p><p id="1158" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看上面的代码，您可以看到我们能够编写更少的代码并获得更简单的结果。</p><p id="6a59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码首先使用<code class="fe ly lz ma mb b">Stream.generate</code> <em class="lv">生成一个随机数列表。</em>使用<em class="lv"> </em> <code class="fe ly lz ma mb b">limit(10)</code>这个流被限制为只有十个数字。输出是一个整数流(<code class="fe ly lz ma mb b">Stream&lt;Integer&gt;</code>)。</p><p id="5821" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们的流使用基于所有元素&gt; <code class="fe ly lz ma mb b">5</code>的<code class="fe ly lz ma mb b">filter</code>进行过滤。</p><p id="5431" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，这比使用<code class="fe ly lz ma mb b">for</code>循环要少得多的代码，也更符合逻辑。</p><p id="2ca0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这两个操作甚至可以合并:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3a60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注意:</em> <code class="fe ly lz ma mb b"><em class="lv">() -&gt;</em></code> <em class="lv">基本都是Java版本的匿名函数(Lambda表达式)。它们是在Java 8中与流一起引入的。如果只有一个参数，则不需要括号(类似于</em> <code class="fe ly lz ma mb b"><em class="lv">e -&gt; e &gt; 5</em></code> <em class="lv">)。它们的实现类似于JavaScript的箭头函数。</em></p><p id="f958" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您在编写更大的应用程序时，流会变得非常方便。</p><p id="33dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从基础开始看。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><h1 id="9e0a" class="mt mh it bd mu mv mw mx my mz na nb nc jz nd ka ne kc nf kd ng kf nh kg ni nj bi translated">基础知识</h1><p id="58ad" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如前所述，流是一个数据序列，允许对所有或部分数据进行特殊类型的处理。我们可以创建流或将现有的结构转换成流。</p><p id="0e97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流本质上是一个数据序列。我们可以用几种不同的方式在Java中创建流。</p><h2 id="daa4" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">产生</h2><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="73d6" class="mg mh it mb b gy mi mj l mk ml">Stream&lt;String&gt; streamGenerated =<br/>        Stream.<em class="lv">generate</em>(() -&gt; "value");</span></pre><p id="1cc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过引用<code class="fe ly lz ma mb b">Stream</code>类的<code class="fe ly lz ma mb b">.generate</code>方法，您可以生成由字符串<code class="fe ly lz ma mb b">“value”</code>组成的流。</p><p id="8818" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流是延迟加载的(你可以说流是一个延迟加载的集合)。这意味着直到需要它们时才进行计算。这导致了一个有趣的性质。即使<code class="fe ly lz ma mb b">Stream&lt;String&gt;</code>被声明，<em class="lv">也没有操作</em>发生。</p><p id="6e92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是必要的，因为<code class="fe ly lz ma mb b">Stream.generate</code>生成无限多的值。在这种情况下，<code class="fe ly lz ma mb b">“value”</code>被生成了无限次。但是，因为它是懒加载的，所以不进行计算。</p><p id="46bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们通过添加<code class="fe ly lz ma mb b">.limit</code>方法将这个流从无穷大限制到20个数字:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="0fc0" class="mg mh it mb b gy mi mj l mk ml">Stream&lt;String&gt; streamGenerated =<br/>        Stream.<em class="lv">generate</em>(() -&gt; "value")<strong class="mb iu">.limit(10)</strong>;</span></pre><p id="b7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">流遵循一种构建器模式——因此您可以将操作符相互链接起来。<code class="fe ly lz ma mb b">.limit</code>返回一个<code class="fe ly lz ma mb b">Stream</code>。其他返回流的运算符称为非终结符。他们本质上延续了这个链条。</p><p id="aaaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于要计算的流，需要添加一个终端运算符。它将流转换成我们的程序可以使用的实际类型(如int、float、double)或集合(数组、hashmaps)。</p><p id="de17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的就是把这个变成一个<code class="fe ly lz ma mb b">List</code>之类的集合。</p><p id="97f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把我们的流变成一个列表。这可以通过<code class="fe ly lz ma mb b">.collect</code>方法完成:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="0034" class="mg mh it mb b gy mi mj l mk ml">List&lt;String&gt; streamToList = streamGenerated.<strong class="mb iu">collect(Collectors.<em class="lv">toList</em>())</strong>;</span></pre><p id="37b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">.collect</code>方法采用一个<code class="fe ly lz ma mb b">Collector</code>。根据<code class="fe ly lz ma mb b">Collector</code>的类型，您可以控制如何将流缩减为什么。在这种情况下，流将被简化为一个列表。</p><p id="0edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他<code class="fe ly lz ma mb b">Collector</code>操作的简单示例包括:</p><ul class=""><li id="41eb" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated"><code class="fe ly lz ma mb b">.toSet()</code></li><li id="7b8f" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe ly lz ma mb b">.toMap()</code></li><li id="3b4b" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe ly lz ma mb b">.joining()</code></li></ul><p id="93f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">streamToList</code>的输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="c5ba" class="mg mh it mb b gy mi mj l mk ml">[value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value, value]</span></pre><p id="f1e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们有了名单。</p><h2 id="bdbb" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">重复</h2><p id="f1b7" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这类似于<code class="fe ly lz ma mb b">.generate</code>，但是它允许你创建一个类似于<code class="fe ly lz ma mb b">for</code>循环的迭代流。这也生成了一个无限流。</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="41e9" class="mg mh it mb b gy mi mj l mk ml">Stream&lt;Integer&gt; streamIterated = Stream.<em class="lv">iterate</em>(0, i -&gt; i + 2).limit(10);</span></pre><p id="dbce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个参数是起始数字，第二个参数是希望它“如何”迭代。</p><p id="cba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="4f79" class="mg mh it mb b gy mi mj l mk ml">[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span></pre><p id="e08f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">.iterate</code>的结构类似于下面的<code class="fe ly lz ma mb b">for</code>循环结构:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="539f" class="mg mh it mb b gy mi mj l mk ml">for (int i = 0; i &lt; 20; i = i + 2) {<br/>    // some code<br/>}</span></pre><h2 id="836d" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated"><strong class="ak">收藏</strong></h2><p id="5f30" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">Java中的集合允许你存储和操作数据。所有现有的集合都可以直接转换成流。集合下实际上有三种类型的接口。其中包括:</p><ul class=""><li id="c43e" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated">列表</li><li id="dba0" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">设置</li><li id="2de1" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated">行列</li></ul><p id="db93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能对<code class="fe ly lz ma mb b">List</code>界面最为熟悉。<code class="fe ly lz ma mb b">List</code>接口的不同实现包括<code class="fe ly lz ma mb b">ArrayList</code>、<code class="fe ly lz ma mb b">Vector</code>和<code class="fe ly lz ma mb b">Stack</code>。</p><p id="9608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个名为<code class="fe ly lz ma mb b">arrayToStream</code>的整数<code class="fe ly lz ma mb b">ArrayList</code>。这可以很容易地变成一条小溪。所有这些集合都支持使用<code class="fe ly lz ma mb b">.stream</code>方法转换成流:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="b434" class="mg mh it mb b gy mi mj l mk ml">Stream&lt;Integer&gt; stream = arrayToStream<strong class="mb iu">.stream()</strong>;</span></pre><p id="8552" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="adb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，有许多特殊的流程可以在流上完成。我们最近使用了<code class="fe ly lz ma mb b">.limit</code>操作来限制我们的流。这是一个<em class="lv">非终结符</em>符。非终结符总是返回另一个流。在本文的开始，我们使用了非终结符<code class="fe ly lz ma mb b">.filter</code></p><p id="7ee6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">streams的主要优势之一是它们提供了过多的非终端运营商。这些操作符提供了一种更简洁的循环方法。</p><ul class=""><li id="2a76" class="oa ob it lb b lc ld lf lg li oc lm od lq oe lu of og oh oi bi translated"><code class="fe ly lz ma mb b">map</code></li><li id="e662" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe ly lz ma mb b">filter</code></li><li id="d79e" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe ly lz ma mb b">distinct</code></li><li id="f7ca" class="oa ob it lb b lc oj lf ok li ol lm om lq on lu of og oh oi bi translated"><code class="fe ly lz ma mb b">limit</code></li></ul><p id="56a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一些操作符看起来类似于做同样事情的Python和JavaScript操作。实际上，流与Python和JavaScript中的生成器非常相似。</p><p id="21f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看其中的一些操作符。</p><h2 id="c66d" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">地图</h2><p id="2097" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这用于迭代修改列表中的每个元素。修改可以包括将元素转换成不同的类型或者使用某种逻辑(公式)来转换元素。</p><p id="9d52" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">比如你有一个从一到十的数字列表:<code class="fe ly lz ma mb b">[1,2,3,4,5,6,7,8,9,10]</code>。你要把这些数平方(数乘以自身)成<code class="fe ly lz ma mb b">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code>。这是一个何时使用<code class="fe ly lz ma mb b">map</code>的例子。</p><p id="6770" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java中的映射是通过流支持的。<code class="fe ly lz ma mb b">map</code>是非终结操作，所以会返回一个流。但是，如果我们想将其转换为实际类型，我们可以使用终端操作符，如<code class="fe ly lz ma mb b">.collect</code>。</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="b254" class="mg mh it mb b gy mi mj l mk ml">Stream&lt;Integer&gt; numbers1To10Stream = numbers1To10.stream()<strong class="mb iu">.map</strong>(num -&gt; num * num);</span></pre><p id="eaf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要终端操作符<code class="fe ly lz ma mb b">.collect</code>将它转换成一个列表。</p><p id="cc9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们在没有<code class="fe ly lz ma mb b">.collect</code>的情况下打印<code class="fe ly lz ma mb b"> numbers1To10Stream</code>，它会打印出类似于<code class="fe ly lz ma mb b">java.util.stream.ReferencePipeline$3@3feba861</code>的东西，因为它还不是我们可以使用的类型。</p><p id="1a37" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用<code class="fe ly lz ma mb b">.collect</code>输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="b210" class="mg mh it mb b gy mi mj l mk ml">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></pre><h2 id="9692" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">过滤器</h2><p id="1c40" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated"><code class="fe ly lz ma mb b">filter</code>顾名思义。您可以根据特定条件过滤列表。</p><p id="2d1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，使用与上面相同的数字列表并过滤所有偶数将产生<code class="fe ly lz ma mb b">[2, 4, 6, 8, 10]</code>。</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="3462" class="mg mh it mb b gy mi mj l mk ml">Stream&lt;Integer&gt; numbers1To10Stream = numbers1To10.stream()<strong class="mb iu">.filter</strong>(num -&gt; num % 2 == 0);</span></pre><p id="6c03" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ly lz ma mb b">filter</code>方法需要一个函数，该函数接受一个值并评估它是<code class="fe ly lz ma mb b">true</code>还是<code class="fe ly lz ma mb b">false</code>。如果选择<code class="fe ly lz ma mb b">true</code>，该号码将出现在列表中。无论输入什么数字，都会检查它是否能被<code class="fe ly lz ma mb b">2</code> : <code class="fe ly lz ma mb b">num -&gt; num % 2 == 0</code>整除。</p><p id="8471" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="3582" class="mg mh it mb b gy mi mj l mk ml">[2, 4, 6, 8, 10]</span></pre><h2 id="cf92" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">明显的</h2><p id="c31a" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这个非终结符从一个流中移除所有的重复项。</p><p id="b2e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个数字列表:<code class="fe ly lz ma mb b">[3, 3, 3, 3, 8, 8, 8, 8]</code>。删除所有重复项会使列表变成<code class="fe ly lz ma mb b">[3, 8]</code>。</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="2be2" class="mg mh it mb b gy mi mj l mk ml">Stream&lt;Integer&gt; distinct = duplicatedList.stream().distinct();</span></pre><p id="d3c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="12d7" class="mg mh it mb b gy mi mj l mk ml">[3, 8]</span></pre></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="5aff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在来覆盖一些码头运营商。我们已经通过了<code class="fe ly lz ma mb b">.collect</code>操作符。有时，我们想要在流上执行一些计算，但是我们想要一个奇异值，比如int或string，而不是list。</p><h2 id="dae8" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">任意匹配</h2><p id="4cb9" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果<em class="lv">流中的任何元素</em>匹配某个条件，则返回<code class="fe ly lz ma mb b">true</code>，否则返回<code class="fe ly lz ma mb b">false</code>。</p><p id="488e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用示例<code class="fe ly lz ma mb b">[3,4,7,9]</code>，让我们检查是否有偶数:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="b4b9" class="mg mh it mb b gy mi mj l mk ml">boolean anyMatchBool = anyMatchList.stream().<strong class="mb iu">anyMatch</strong>(num -&gt; num % 2 == 0);</span></pre><p id="36c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回想一下，终端操作符返回的是实际类型。在这种情况下，返回一个<strong class="lb iu"> <em class="lv">布尔</em> </strong>值。</p><p id="8f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="4ebd" class="mg mh it mb b gy mi mj l mk ml">true</span></pre><h1 id="24dd" class="mt mh it bd mu mv oo mx my mz op nb nc jz oq ka ne kc or kd ng kf os kg ni nj bi translated">allMatch</h1><p id="7e6b" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">如果流中的所有<em class="lv"/><em class="lv">元素</em>匹配某个条件，则返回<code class="fe ly lz ma mb b">true</code>，否则返回<code class="fe ly lz ma mb b">false</code>。</p><p id="c2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用示例<code class="fe ly lz ma mb b">[3,4,7,9]</code>:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="acac" class="mg mh it mb b gy mi mj l mk ml">boolean anyMatchBool = allMatchList.stream().<strong class="mb iu">allMatch</strong>(num -&gt; num % 2 == 0);</span></pre><p id="4182" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的例子会产生<code class="fe ly lz ma mb b">false</code>，因为所有的数字都是奇数。</p><p id="9a46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果列表是<code class="fe ly lz ma mb b">[2,4,6,8]</code>，结果将是<code class="fe ly lz ma mb b">true</code>，因为所有的数字都是偶数。</p><h2 id="9189" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">为每一个</h2><p id="ff7c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">这允许你遍历列表中的每个元素并对这些元素进行操作。操作运行不应该返回值，但确实有副作用。</p><p id="f77e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用示例<code class="fe ly lz ma mb b">[3,4,7,9]</code>:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="7c5a" class="mg mh it mb b gy mi mj l mk ml">list.stream().forEach(num -&gt; System.<em class="lv">out</em>.println(num));</span></pre><p id="3fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">输出:</p><pre class="kj kk kl km gt mc mb md me aw mf bi"><span id="3bb9" class="mg mh it mb b gy mi mj l mk ml">3<br/>4<br/>7<br/>9</span></pre><p id="deb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe ly lz ma mb b">map</code>不同，<code class="fe ly lz ma mb b">forEach</code>不修改已有的列表。</p></div><div class="ab cl mm mn hx mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="im in io ip iq"><p id="aa7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一些流的用例。</p><h2 id="1cbd" class="mg mh it bd mu np nq dn my nr ns dp nc li nt nu ne lm nv nw ng lq nx ny ni nz bi translated">锻炼</h2><p id="d88c" class="pw-post-body-paragraph kz la it lb b lc nk ju le lf nl jx lh li nm lk ll lm nn lo lp lq no ls lt lu im bi translated">获得一份有<code class="fe ly lz ma mb b">“Expired”</code>身份的图书清单，并检查这些图书中是否有任何一本书被乔丹借走；</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6032" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上图中，我们有一个图书馆知识库，它会给出一个图书列表。这些书是所有过期的书的<code class="fe ly lz ma mb b">filtered</code>，然后检查是否有属于<code class="fe ly lz ma mb b">Jordan</code>的书。如果其中任何一个属于他，它将返回<code class="fe ly lz ma mb b">true</code>，否则返回<code class="fe ly lz ma mb b">false</code>。</p></div></div>    
</body>
</html>