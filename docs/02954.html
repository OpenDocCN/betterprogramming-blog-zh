<html>
<head>
<title>Data Structures in JavaScript: Graphs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的数据结构:图形</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/basic-interview-data-structures-in-javascript-graphs-3f9118aeb078?source=collection_archive---------1-----------------------#2020-01-11">https://betterprogramming.pub/basic-interview-data-structures-in-javascript-graphs-3f9118aeb078?source=collection_archive---------1-----------------------#2020-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a19e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解你需要知道的关于图及其基本算法的知识，以便在下一次编码面试中胜出</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0d59f4b8419fa4e1a74a2e8d57013f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2LxEywSz-13Plz0xQtD8g.jpeg"/></div></div></figure><p id="fe51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">欢迎来到我的后续文章<a class="ae lq" href="https://medium.com/@baum.johannes/basic-interview-data-structures-in-javascript-509003c751fe" rel="noopener"><em class="lr">JavaScript中的基本面试数据结构</em> </a>。</p><p id="586d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文主要关注JavaScript中图形的实现及其最重要的算法。许多面试问题可以通过建立一个图并在其上运行特定的算法来解决。这使得图形成为编码面试中最重要的数据结构之一。</p><p id="dd51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">确保您熟悉big-O符号，以理解不同算法的渐近时间复杂性。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="cbad" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">什么是图？</h1><p id="b831" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">简单地说，图是节点的集合，节点之间有边。如果一个节点<em class="lr"> n1 </em>用一条边连接到另一个节点<em class="lr"> n2 </em>，我们说<em class="lr"> n1 </em>与到<em class="lr"> n2 </em>相邻<em class="lr">。</em></p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5098" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">定向还是非定向？</h1><p id="3573" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">有向图只有有向边。可以把它们想象成单行道。如果一个边沿从<em class="lr"> n1 </em>通向<em class="lr"> n2 </em>，它也不会从<em class="lr"> n2 </em>通向<em class="lr"> n1 </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/fa20c78dcdc13037aea60857044d4116.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*CuwY_TvHtxBm_hVh_LUCpg.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">有向图-边是单向的</p></figure><p id="cf98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在无向图中，边连接两个方向上的两个节点，就像双向街道一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ee5a9d8d93a4cc7ddbac61956a64c559.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*WdeekKiISJbAtHbDd1M0kw.png"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">无向图-边是多方向的</p></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="de9a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">正确的表示:列表与矩阵</h1><p id="5e4d" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">图有两种经典的程序表示:邻接表和邻接矩阵。</p><p id="47e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两者都允许应用相同的算法，但是它们的性能不同。我将使用下面的有向示例图来解释这两种表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/14402192c754d02b354920e32e3078fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*jNj01LUT5xMkZWU-KLRp8w.png"/></div></figure><h2 id="a5ef" class="nc ma it bd mb nd ne dn mf nf ng dp mj ld nh ni ml lh nj nk mn ll nl nm mp nn bi translated">邻接矩阵</h2><p id="a752" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">邻接矩阵是这样一种矩阵，其中两个维度等于图中的节点数，每个单元的值可以是0或1。</p><p id="0c49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果第<em class="lr"> i </em>行和第<em class="lr"> j </em>列的单元格的值为1，则意味着节点<em class="lr"> i </em>与节点<em class="lr"> j </em>相邻。下面是我们的示例图的邻接矩阵:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi no"><img src="../Images/52123790822b4e8621d6c7de969edc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*5-gpseQ73e-K0MMcHBXgHQ.png"/></div></figure><p id="18c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JavaScript中的邻接矩阵只是一个带有布尔值的二维数组:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5e75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种表示对性能有几个影响。设<em class="lr"> n </em>为节点数<em class="lr"> e </em>为图的边数。</p><ul class=""><li id="9065" class="nr ns it kw b kx ky la lb ld nt lh nu ll nv lp nw nx ny nz bi translated">它消耗<em class="lr"> O(n ) </em>空间。</li><li id="6f06" class="nr ns it kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated">您可以在<em class="lr"> O(1) </em>步骤中检查节点<em class="lr"> i </em>是否与节点<em class="lr"> j </em>相邻。</li><li id="6229" class="nr ns it kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated">得到节点<em class="lr"> i </em>的所有相邻节点需要<em class="lr"> O(n) </em>步。</li></ul><h2 id="0c10" class="nc ma it bd mb nd ne dn mf nf ng dp mj ld nh ni ml lh nj nk mn ll nl nm mp nn bi translated">邻接表</h2><p id="3529" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">邻接表以不同的方式表示图。每个节点都有一个相邻节点列表。我们的示例图的邻接表如下所示:</p><pre class="kj kk kl km gt of og oh oi aw oj bi"><span id="4255" class="nc ma it og b gy ok ol l om on">1 -&gt; [2, 3]<br/>2 -&gt; [3, 4]<br/>3 -&gt; []<br/>4 -&gt; [3]</span></pre><p id="293a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种邻接表最好使用散列集的散列图来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7538" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再次假设<em class="lr"> n </em>是节点的数量，而<em class="lr"> e </em>是图的边的数量。这种表示的性能可以描述如下:</p><ul class=""><li id="0503" class="nr ns it kw b kx ky la lb ld nt lh nu ll nv lp nw nx ny nz bi translated">它消耗<em class="lr"> O(n+e) </em>空间。</li><li id="3a57" class="nr ns it kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated">可以在<em class="lr"> O(n) </em>中检查节点<em class="lr"> i </em>是否与节点<em class="lr"> j </em>相邻(但根据实现方式不同在<em class="lr"> O(1) </em>中也有可能)。</li><li id="067f" class="nr ns it kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated">获取与节点<em class="lr"> i </em>相邻的所有节点需要<em class="lr"> O(1) </em>步。</li></ul><p id="042e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过使用散列集而不是列表，我们可以在<em class="lr"> O(1) </em>而不是<em class="lr"> O(n) </em>中检查条目的存在。</p><h2 id="f175" class="nc ma it bd mb nd ne dn mf nf ng dp mj ld nh ni ml lh nj nk mn ll nl nm mp nn bi translated">我应该在面试中使用哪种表述？</h2><p id="2e66" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我从来没有经历过我更喜欢矩阵而不是邻接表的情况。由于邻接表在大多数情况下表现更好，并且不会增加复杂性，我看不出使用矩阵的理由。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="8884" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">BFS还是DFS？</h1><p id="15e5" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">BFS ( <em class="lr">广度优先搜索</em>)和DFS <em class="lr"> </em> ( <em class="lr">深度优先搜索</em>)是两种简单的算法，它们构成了许多高级图算法的基础。它们可以用来完全探索一个图形。</p><p id="687c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然它们都只浏览图中的每个节点一次，但是它们的浏览顺序不同。对于一个编码面试，你一定要能够从头开始编码，并且知道它们之间的区别。</p><p id="cbb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们实现这些算法之前，让我快速解释一下它们是如何工作的。</p><p id="dc71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DFS从一个起始节点<em class="lr"> s </em>开始研究该图。从该节点开始，它将递归地探索每个邻居。这意味着将在邻居2之前探索邻居1的邻居。但是一张照片胜过千言万语:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/120ad457085168220694fc5c5db4dab1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*4A8pPi5ZH8yOXMrA9uNZgw.gif"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">深度优先搜索</p></figure><p id="d108" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">人们可以看到，该图首先是深入探讨，然后在广度上。这就是深度优先搜索这个名字的由来。</p><p id="a8f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">BFS也从开始节点<em class="lr"> s </em>开始探索该图。从该节点开始，它会先搜索每个邻居，然后再搜索邻居的邻居:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/efc9376015917e3b18e9f0c3050071b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8WdNxsYCeYYqTkoBQ3rJHA.gif"/></div><p class="mx my gj gh gi mz na bd b be z dk translated">BFS</p></figure><p id="73cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这一次，首先在广度上探索图形，然后在深度上探索图形，因此名称为<em class="lr">广度优先搜索</em>。</p><p id="13e9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你还是不明白其中的区别？没问题。从中心节点开始，经过20步DFS和BFS后，查看下面的网格状图形:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/7b7aad17347a636d0c45b4849981639b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSx5ANd7ytjOG042gXLmHg.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">从红色节点开始DSF 20步后探索节点(绿色)</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/184fe7ee8497a900164b37a7ba2ec33a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*66KJzjh08SlNgfzNXmuXng.png"/></div></div><p class="mx my gj gh gi mz na bd b be z dk translated">从红色节点开始BFS 20步后探索节点(绿色)</p></figure><p id="537f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如你所看到的，DFS首先深入研究了这个图表，而BFS在一定范围内进行了研究。这就是两种算法的巨大区别。</p><p id="415b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您只想浏览所有节点，并且顺序不起作用，那么您可以选择任何一种算法。然而，如果探索的顺序很重要，那么你应该明智地选择。</p><p id="dd10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将给你两个应用的例子。假设你有一个电脑游戏，其中你控制一个火星探测器，未知大小的地图被表示为一个网格状的图形，如上一个例子所示。</p><p id="16a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设您只有有限的燃料，如果您想了解更多关于您周围的情况，使用BFS探索地图将是很好的选择。使用DFS将更有助于在一个特定的方向上进一步探索。</p><p id="6883" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">BFS也可以稍加修改，以获得两个节点之间的最短距离，但我将把它留到另一篇关于<em class="lr">最短路径</em>算法的文章中。</p><h2 id="1e91" class="nc ma it bd mb nd ne dn mf nf ng dp mj ld nh ni ml lh nj nk mn ll nl nm mp nn bi translated">JavaScript中的DFS</h2><p id="a48d" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">让我们最后来看看JavaScript实现。这些实现是基于邻接表的，但是也可以很容易地采用邻接矩阵。</p><p id="fc90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DFS有两种常见的实现:一种使用显式堆栈，另一种使用递归，因此隐式使用调用堆栈。</p><p id="2876" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，探索的顺序不同于递归DFS和BFS。在本文中，我们将只讨论递归实现，因为它不太复杂，也更常见。</p><p id="7bdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在BFS和DFS中，我们将有一个<code class="fe oq or os og b">visit</code>函数，它可以填充您在访问节点时想要执行的任何逻辑。在我们的例子中，我们将只把节点记录到控制台:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3f31" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是递归DFS算法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="daf8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们有一个集合，用来保存我们已经访问过的所有节点，以确保在包含循环的图中算法的终止。</p><p id="711a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">访问完节点后，我们将它添加到<code class="fe oq or os og b">visited</code>集合，然后递归调用<code class="fe oq or os og b">dfs</code>来访问所有未访问的邻居。</p><p id="bc1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DFS的时间复杂度为<em class="lr"> O(n+e)。</em></p><h2 id="3fdb" class="nc ma it bd mb nd ne dn mf nf ng dp mj ld nh ni ml lh nj nk mn ll nl nm mp nn bi translated">JavaScript中的BFS</h2><p id="f87c" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">BFS通常通过利用队列来实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="16ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与DFS的主要区别是队列。其结果是，在邻居的邻居被访问之前，所有邻居都被访问。</p><p id="b01e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，队列上的<code class="fe oq or os og b">shift</code>操作实际上不是一个<em class="lr"> O(1) </em>操作<em class="lr">。</em></p><p id="daa4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是，可以在<em class="lr"> O(1) </em>中实现允许插入和移除的队列，如我的文章<a class="ae lq" href="https://medium.com/better-programming/basic-interview-data-structures-in-javascript-stacks-and-queues-b68b5a7c82a6" rel="noopener"><em class="lr">JavaScript中的基本面试数据结构:堆栈和队列</em> </a>中所述。也就是说，BFS的运行时复杂度也是O(n+e) 。</p><h2 id="d2fc" class="nc ma it bd mb nd ne dn mf nf ng dp mj ld nh ni ml lh nj nk mn ll nl nm mp nn bi translated">不连通图呢？</h2><p id="8402" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">如果任意一对节点之间有一条路径，则称该图为<em class="lr">连通</em>，否则称其为<em class="lr">不连通</em>。如果它是断开的，这意味着它包含某种孤立的节点。</p><p id="b402" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在面试中，在你开始编码之前，你应该弄清楚图形是否会被连接。如果图表是一个未知的输入，你应该问你的面试官你是否可以假设连通性。</p><p id="44aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这也显示了你对这个主题的理解，以及不连续图所带来的警告。</p><p id="7b6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们让我们的BFS和DFS算法在这种情况下防弹:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="49e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为算法的适应对于BFS和DFS是相同的，所以它们在代码中被称为<code class="fe oq or os og b">xfs</code>，并且可以被替换为<code class="fe oq or os og b">dfs</code>或<code class="fe oq or os og b">bfs</code>。</p><p id="587a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种修改背后的思想是，将<code class="fe oq or os og b">visited</code>散列集保留在函数之外，并为给定的开始节点启动BFS/DFS。</p><p id="d661" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之后，遍历所有节点，并为每个还没有访问过的节点启动一个额外的BFS/DFS。因此，您可以访问所有节点，即使它们是孤立的。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="fd67" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="db3a" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">图形是编码面试中大量使用的数据结构。许多面试问题将包括一个可以转化为图形的问题，然后可以用BFS和DFS的修改版本进行分析。</p><p id="a684" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对你来说，能够从头开始编写BFS和DFS代码并知道它们之间的区别是非常重要的。请确保您澄清了图形是否连通，并能够相应地修改BFS和DFS。</p><p id="e181" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我希望这能帮助你找到下一份工作。祝你面试好运！</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="2782" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">参考</h1><ul class=""><li id="e7cb" class="nr ns it kw b kx mr la ms ld ot lh ou ll ov lp nw nx ny nz bi translated"><a class="ae lq" href="https://medium.com/@baum.johannes/basic-interview-data-structures-in-javascript-509003c751fe" rel="noopener">JavaScript中的基本面试数据结构</a></li><li id="f4be" class="nr ns it kw b kx oa la ob ld oc lh od ll oe lp nw nx ny nz bi translated"><a class="ae lq" href="https://medium.com/better-programming/basic-interview-data-structures-in-javascript-stacks-and-queues-b68b5a7c82a6" rel="noopener">JavaScript中的基本访问数据结构:堆栈和队列</a></li></ul></div></div>    
</body>
</html>