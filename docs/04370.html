<html>
<head>
<title>Features From TypeScript 2.9 That You May Have Missed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能已经错过的TypeScript 2.9的特性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/features-from-typescript-2-9-that-you-may-have-missed-899faadccca?source=collection_archive---------16-----------------------#2020-04-08">https://betterprogramming.pub/features-from-typescript-2-9-that-you-may-have-missed-899faadccca?source=collection_archive---------16-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d2da" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">TypeScript已经超越了2.9版本。然而，在以前的版本中，有一些很棒的特性你可能已经错过了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a026f63217b072d4496361c68bfc88f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MPH9_YKbXqcSWKq5"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Christian Wiediger 在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="f15d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将看看TypeScript 2.9发布的一些您可能已经错过的有用特性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7e14" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">支持带有keyof和映射类型的数字和符号命名属性</h1><p id="71b9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在TypeScript 2.9之前，<code class="fe mz na nb nc b">keyof</code>和映射类型只支持字符串键。</p><p id="60d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在它支持JavaScript支持的键的所有数据类型和映射类型。</p><p id="7e2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用TypeScript 2.9，<code class="fe mz na nb nc b">for...in</code>循环可以将键解析为任何类型。</p><p id="3141" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">keyof T</code>对于某些类型来说<code class="fe mz na nb nc b">T</code>是<code class="fe mz na nb nc b">string | number | symbol</code>联合类型的一个子类型。</p><p id="b8ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">映射类型<code class="fe mz na nb nc b">{ [P in K]: XXX }</code>让我们将<code class="fe mz na nb nc b">K</code>分配给<code class="fe mz na nb nc b">string</code>、<code class="fe mz na nb nc b">number</code>或<code class="fe mz na nb nc b">symbol</code>。</p><p id="63ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定一个类型为<code class="fe mz na nb nc b">X</code>的对象，<code class="fe mz na nb nc b">keyof X</code>现在解析如下:</p><ul class=""><li id="5f4b" class="nd ne it lb b lc ld lf lg li nf lm ng lq nh lu ni nj nk nl bi translated">如果<code class="fe mz na nb nc b">X</code>包含字符串索引签名，<code class="fe mz na nb nc b">keyof X</code>的类型为<code class="fe mz na nb nc b">string</code>、<code class="fe mz na nb nc b">number</code>，文字类型表示类似符号的属性。</li><li id="a0e8" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">如果<code class="fe mz na nb nc b">X</code>包含数字索引签名，那么<code class="fe mz na nb nc b">keyof X</code>是<code class="fe mz na nb nc b">number</code>和表示类似字符串和类似符号属性的文字类型的并集。</li><li id="f778" class="nd ne it lb b lc nm lf nn li no lm np lq nq lu ni nj nk nl bi translated">否则，<code class="fe mz na nb nc b">keyof X</code>是表示类似字符串、类似数字和类似符号属性的文字类型的并集。</li></ul><p id="b54d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="269f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么<code class="fe mz na nb nc b">K1</code>将是所有键类型的联合，即:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="a1cf" class="nx md it nc b gy ny nz l oa ob">"foo" | typeof fooSymbol | Enum.A | "a" | 5 | 2</span></pre><p id="0c04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我们所有文字类型的联合。</p><p id="b94b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们使用<code class="fe mz na nb nc b">Extract</code>工具类型从所有文字类型的联合中提取字符串，就像我们使用<code class="fe mz na nb nc b">K2</code>一样，那么我们有:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="1e60" class="nx md it nc b gy ny nz l oa ob">"foo" | "a"</span></pre><p id="4d91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为<code class="fe mz na nb nc b">K2</code>的型号。</p><p id="85f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">K3</code>是从<code class="fe mz na nb nc b">keyof Foo</code>创建的文字类型中提取所有数字而创建的类型，这将使我们:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="12b5" class="nx md it nc b gy ny nz l oa ob">Enum.A | 5 | 2</span></pre><p id="c991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe mz na nb nc b">K4</code>的类型是<code class="fe mz na nb nc b">typeof fooSymbol</code>，这是一个符号，因为我们再次使用了<code class="fe mz na nb nc b">Extract</code>实用程序类型。</p><p id="f07f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为<code class="fe mz na nb nc b">keyof</code>现在正确地支持所有类型的键，所以像<code class="fe mz na nb nc b">Partial&lt;T&gt;</code>和<code class="fe mz na nb nc b">Readonly&lt;T&gt;</code>这样的映射类型在应用于带有数字索引签名的对象类型时可以正确地工作。</p><p id="636b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果我们有:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="6c78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们知道<code class="fe mz na nb nc b">x</code>是一个字符串而不是<code class="fe mz na nb nc b">any</code>，因为当我们定义<code class="fe mz na nb nc b">Arrayish</code>映射类型时，数字键被TypeScript识别。</p><p id="cc6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以用符号键访问值。例如，如果我们写:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ac7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.9之前的TypeScript版本会给我们一个错误，因为<code class="fe mz na nb nc b">keyof</code>不能识别符号。</p><p id="61ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有了TypeScript 2.9，我们不再有符号问题了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8ee8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">JSX元素中的泛型类型参数</h1><p id="6da8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">使用TypeScript 2.9，我们可以将泛型类型参数传入组件。</p><p id="9617" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以写:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="3059" class="nx md it nc b gy ny nz l oa ob">type Props = { a: number; b: number; };  <br/>const foo = &lt;GenericComponent&lt;Props&gt; a={10} b={20} /&gt;</span></pre><p id="2994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将<code class="fe mz na nb nc b">Props</code>类型传入我们的通用组件来验证我们传入的属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="770d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">导入类型</h1><p id="868f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe mz na nb nc b">import</code>类型让非模块全局脚本访问模块中声明的类型。</p><p id="7890" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以把:</p><pre class="kj kk kl km gt nt nc nu nv aw nw bi"><span id="e8f5" class="nx md it nc b gy ny nz l oa ob">import("./module")</span></pre><p id="78d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">来获取导入模块的类型。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9810" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">支持import.meta</h1><p id="1ffa" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript 2.9支持引用<code class="fe mz na nb nc b">import.meta</code>属性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5ba7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">resolveJsonModule模块</h1><p id="41cb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以在TypeScript中导入<code class="fe mz na nb nc b">.json</code>文件，将<code class="fe mz na nb nc b">tsconfig.json</code>中的<code class="fe mz na nb nc b">resolveJsonModule</code>选项设置为<code class="fe mz na nb nc b">true</code>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8fc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="4350" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">TypeScript 2.9的最大特点是支持带有各种运算符和实用程序类型的数字和符号键。</p><p id="9680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，还有一些新的选项可以让我们在TypeScript代码中引用导入类型和导入JSON。</p></div></div>    
</body>
</html>