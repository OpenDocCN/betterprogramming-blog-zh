<html>
<head>
<title>SwiftUI Lists Are Broken And Can’t Be Fixed</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI列表已损坏且无法修复</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-lists-are-broken-and-cant-be-fixed-a7114d0baaba?source=collection_archive---------0-----------------------#2022-09-22">https://betterprogramming.pub/swiftui-lists-are-broken-and-cant-be-fixed-a7114d0baaba?source=collection_archive---------0-----------------------#2022-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0cd7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个古老的问题是如何再次浮出水面的。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1c823d74e366e01422736d3f96b654a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ufQUvo5dkTola6p2"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯·劳顿在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="b410" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在周末，我在为<a class="ae ky" href="https://github.com/hmlongco/RequestBuilder" rel="noopener ugc nofollow" target="_blank"> RequestBuilder </a>开发SwiftUI演示应用程序时，遇到了一个问题。</p><p id="a235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">RequestBuilder，顾名思义，使用Builder设计模式为Combine和Async/Await构建和执行URLRequests。演示应用程序使用它从API获取用户列表，以及他们的缩略图，以便在SwiftUI列表中显示。</p><p id="10a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取用户列表看起来像这样…</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="db51" class="ma mb it lw b gy mc md l me mf">session.request()<br/>    .add(path: "/api")<br/>    .add(queryItems: ["results" : "50", "seed": "998", "nat": "us"])<br/>    .data(type: UserResultType.self, decoder: JSONDecoder())<br/>    .map(\.results)<br/>    .receive(on: DispatchQueue.main)<br/>    .eraseToAnyPublisher()</span></pre><p id="420d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在该应用程序中，缩略图是从另一个专门的服务获取的，该服务也缓存图像以供以后使用。到目前为止，一切顺利。</p><h1 id="9112" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">虫子！</h1><p id="4ad1" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">这个应用程序以前运行得很好，但是现在当我运行它并向下滚动时，我开始看到列表中的用户只显示占位符图像，而不是他们的实际缩略图。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/f749ac50d97217fb40ba3efaa8eb25b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*bB8H7pKOybMyxtKgMPEwKQ.png"/></div></figure><p id="8e44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不用说，我很不高兴，在接下来的几个小时里，我试图找出我的图书馆出了什么问题。</p><p id="2b6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">却发现那根本不是我的图书馆。</p><p id="1dc9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">罪魁祸首似乎是SwiftUI本身。</p><h1 id="e996" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Xcode 14.0.1</h1><p id="96da" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">你可能会从显示新“动态岛”的截图中推断出，我在iPhone 14模拟器上使用Xcode 14.0.1运行iOS 16，这是我刚刚安装的Xcode的新版本。</p><p id="61a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯。</p><p id="5887" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我只是在前一天运行了这个项目，但我是用Xcode 13.3.1和一个运行iOS 15.6…和SwiftUI 3的模拟器来运行的。</p><p id="b804" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码显示了列表中的卡片视图。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="db77" class="ma mb it lw b gy mc md l me mf">struct MainListCardView: View {</span><span id="8d60" class="ma mb it lw b gy nd md l me mf">  let user: User</span><span id="77b9" class="ma mb it lw b gy nd md l me mf">  @State private var photo: UIImage?</span><span id="eae7" class="ma mb it lw b gy nd md l me mf">  private let images = Container.userImageCache()</span><span id="dfae" class="ma mb it lw b gy nd md l me mf">  var body: some View {<br/>      let _ = Self._printChanges()<br/>      HStack(spacing: 12) {<br/>        ZStack {<br/>          if let image = photo {<br/>             Image(uiImage: image)<br/>                .resizable()<br/>                .aspectRatio(contentMode: .fit)<br/>          } else {<br/>             Image("User-Unknown")<br/>                .resizable()<br/>                .aspectRatio(contentMode: .fit)<br/>                .onReceive(images.thumbnail(forUser: user)) {<br/>                  photo = $0<br/>                }<br/>          }<br/>      }<br/>      .frame(width: 50, height: 50)<br/>      .clipShape(Circle())</span><span id="58f5" class="ma mb it lw b gy nd md l me mf">      ...</span></pre><p id="e45d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ne nf ng lw b">Container.userImageCache</code>是我的依赖注入库<a class="ae ky" href="https://github.com/hmlongco/Factory" rel="noopener ugc nofollow" target="_blank">工厂</a>提供的服务。可疑代码在<code class="fe ne nf ng lw b">onReceive</code>处理程序中，我们向服务请求一个缩略图，它要么返回一个缓存的图像，要么从API获取一个。</p><p id="1326" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当它从服务接收到一个图像时，它将它放入一个状态对象中，该对象改变状态并触发刷新，从而显示新的图像。简单明了……但这不再管用了。</p><h1 id="489f" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">让我们解决问题吧</h1><p id="e4ca" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我在处理程序中添加了一些调试代码。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2f8d" class="ma mb it lw b gy mc md l me mf">.onReceive(images.requestThumbnail(forUser: user)) {<br/>    print("onReceive \(user.picture?.thumbnail)")<br/>    photo = $0<br/>}</span></pre><p id="8af3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并向列表显示代码本身添加了一些信息，这样我就可以查看日志，了解哪些图像获取请求失败了</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/ae122a86d4dd0c0b376d21bf9f21f1f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X8gVtAdb1F1-9LPBS7MjTg.png"/></div></div></figure><p id="a6f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是日志的样本。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="2354" class="ma mb it lw b gy mc md l me mf">MainListCardView: _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>REQ: https://randomuser.me/api/portraits/thumb/men/6.jpg<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>200: https://randomuser.me/api/portraits/thumb/men/6.jpg<br/>onReceive "https://randomuser.me/api/portraits/thumb/men/6.jpg"<br/>MainListCardView: _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.<br/>MainListCardView: @self, @identity, _photo changed.</span></pre><p id="9a71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，过了一会儿，<code class="fe ne nf ng lw b">onReceive</code>处理程序本身就不再被调用了。</p><p id="8684" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我试着将<code class="fe ne nf ng lw b">onReceive</code>处理程序的位置移动到视图中的不同位置，看看会发生什么。同样的结果。</p><p id="a5ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我尝试修改代码，为每个子视图提供自己的视图模型，并切换到从<code class="fe ne nf ng lw b">onAppear</code>调用视图模型。还是没有欢乐。</p><h1 id="f6dd" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">Xcode 14.1测试版</h1><p id="61ce" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">我想了几分钟，然后切换到在Xcode 14.1 beta 2和iOS 16.1下运行该项目……并且成功了！大部分是。在更新界面时仍然有一些小故障，但总体来说已经好多了。</p><p id="d45f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我在iOS 16.0模拟器上运行14.1版本的代码，它再次失败，当我直接在我的14 Pro Max上运行它时也是如此。</p><p id="f0fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我尝试了另一个实验，从这样一个基本的<code class="fe ne nf ng lw b">List</code>循环开始…</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ebfa" class="ma mb it lw b gy mc md l me mf">var body: some View {<br/>    List {<br/>        ForEach(users) { user in<br/>            NavigationLink(destination: DetailsView(user: user)) {<br/>                MainListCardView(user: user)<br/>            }<br/>        }<br/>        .navigationTitle("RequestBuilder")<br/>    }<br/>}</span></pre><p id="490a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用一个<code class="fe ne nf ng lw b">LazyVStack</code>并模拟一个列表。</p><pre class="kj kk kl km gt lv lw lx ly aw lz bi"><span id="ce71" class="ma mb it lw b gy mc md l me mf">var body: some View {<br/>   ScrollView {<br/>     LazyVStack {<br/>         ForEach(users) { user in<br/>              NavigationLink(destination: DetailsView(user: user)) {<br/>                 HStack {<br/>                    MainListCardView(user: user)<br/>                        .accentColor(Color(UIColor.label))<br/>                    Spacer()<br/>                    Image(systemName: "chevron.right")<br/>                        .foregroundColor(.secondary)<br/>                 }<br/>                 .padding(.vertical, 4)<br/>             }<br/>         }<br/>    }<br/>    .padding(.horizontal, 16)<br/>    .padding(.vertical, 8)<br/>    .background(Color(.secondarySystemGroupedBackground))<br/>    .cornerRadius(16)<br/>    .padding(16)<br/>    .navigationTitle("RequestBuilder")<br/>  }<br/>  .background(Color(.systemGroupedBackground))<br/>}</span></pre><p id="78a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给出了以下结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/65c0385dc7c37bbe9a0f7a98884b25e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*aU0dUKz2sqPceBWYOw8aJA.png"/></div></figure><p id="a6af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe ne nf ng lw b">LazyVStack</code>中使用的完全相同的视图、视图模型和服务可以工作。然而，在一个<code class="fe ne nf ng lw b">List</code>内，他们没有。</p><h1 id="d1cf" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">列表</h1><p id="b3fb" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">从所有这些看来很明显的是，SwiftUI的iOS 16.0实现中有一个bug，列表元素的<code class="fe ne nf ng lw b">onReceive</code>和<code class="fe ne nf ng lw b">onAppear</code>处理程序并不总是被调用。</p><p id="6235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能与iOS 16下，<code class="fe ne nf ng lw b">List</code>视图不再由表视图支持，而是由<em class="ni">集合</em>视图支持有关。在改变实现的过程中，苹果的工程师们引入了一些错误，这些错误似乎已经在当前的iOS 16.1测试版中得到部分纠正。</p><p id="19b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论如何，最终的结果是，如果你的应用程序依赖于列表的正确运行，那么它将不再适用于iOS 16，你对此几乎无能为力(除了重新发布你的应用程序，用<code class="fe ne nf ng lw b">LazyVStacks</code>替换上述列表视图)。</p><p id="2ad6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是个问题。但这不是真正的问题。</p><h1 id="1d54" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">SwiftUI SDK</h1><p id="6495" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">在一个理想的世界里，你应该能够进入你的Xcode项目设置，将你的应用程序链接到一个已知版本的SwiftUI库，并且不受这种变化的影响，就像我们对CocoaPods或SPM所做的那样……但这不是它的工作方式。</p><p id="9d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我相信你很清楚，SwiftUI的每一个版本都明确绑定到iOS的特定版本。SwiftUI 1.0到iOS 13，SwiftUI 2.0到iOS 14等等。</p><p id="6d8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，苹果最终会发布iOS 16.1，这将<em class="ni">可能</em>解决问题——对于iOS 16.1用户来说。但是任何没有更新并且还在运行iOS 16.0的设备<em class="ni">都会坏掉。永远。</em></p><p id="fd1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用较早版本的Xcode和较早版本的SwiftUI构建了一个app，但是在iOS 16.0上运行，就会坏。</p><p id="1387" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用更高版本的Xcode和更高版本的SwiftUI构建一个app，但是在iOS 16.0上运行，就会坏。</p><p id="23e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经多次写了这个<a class="ae ky" href="https://medium.com/p/swiftui-and-the-uistackview-problem-34381ffaa71f" rel="noopener"/>，以及Android上的<a class="ae ky" href="https://michaellong.medium.com/swiftui-vs-jetpack-compose-why-android-wins-hands-down-b5f849b730db" rel="noopener"> Jetpack Compose如何做不同的事情</a>。在那里，你可以将你的应用程序与最新版本的程序库链接起来，并使用程序库中几乎所有的功能……不管那台设备有多旧，运行的是什么版本的Android。</p><p id="7cc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在iOS上呢？没有。不能这么做。想要使用一些非常酷、非常高级的SwiftUI功能，如拉至刷新？</p><p id="a530" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没问题。只要确保你的整个用户群都在iOS 15上。</p><p id="aef4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这…令人沮丧。</p><p id="a329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完全没有必要。</p><h1 id="fc38" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">式样</h1><p id="b3c4" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">注意，<code class="fe ne nf ng lw b">UITableView</code>支持的<code class="fe ne nf ng lw b">List</code>更改也可能导致问题，如果您试图使用<code class="fe ne nf ng lw b">UITableView.appearance</code>修饰符来设计表格视图的样式，以便做一些其他超级高级的功能，比如更改列表背景颜色。</p><p id="5d36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在iOS 13中这样做了，以解决SwiftUI的局限性，而且很有效……直到iOS 14出来打破了这种能力。我们在iOS 15中确实又找回来了，太棒了！</p><p id="e41f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只是在iOS 16中又失去了它，因为列表不再是表格视图。</p><p id="d106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不用担心！这么多年过去了，SwiftUI 4还是你的后盾。只需使用<code class="fe ne nf ng lw b">background</code>修改器和新的<code class="fe ne nf ng lw b">scrollContentBackground</code>修改器…</p><p id="e62e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，<code class="fe ne nf ng lw b">scrollContentBackground</code>只在iOS 16和更好的版本上可用，当然，也不会回移植到早期版本的iOS和SwiftUI。</p><p id="6d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我相信你可以找到一种方法来使用新特性，同时保持所有旧代码的向后兼容性。那一点也不乱也不方便。</p><p id="9e83" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对吗？</p><h1 id="4ca1" class="mg mb it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">完成块</h1><p id="160c" class="pw-post-body-paragraph kz la it lb b lc mx ju le lf my jx lh li mz lk ll lm na lo lp lq nb ls lt lu im bi translated">不要误解我。我喜欢SwiftUI，我真的认为它是iOS平台的未来。还有macOS。和其他地方。</p><p id="43e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望在我的所有平台和项目中全面使用它。但是，只要像跳转和字段聚焦或可刷新这样的高级功能被限制在最新、最高级的操作系统版本中，那么我们就有问题了。</p><p id="091d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">是的。我们可以填补并退回到UIKit，编写我们自己的导航栈和文本视图，使用<code class="fe ne nf ng lw b">UIViewControllerRepresentables</code>并编写<code class="fe ne nf ng lw b">UIHostingControllers</code> …</p><p id="09f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是所有这些都不是必须的。</p><p id="6c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们刚刚看到的，即使你的应用程序支持SwiftUI的最新版本，你的应用程序仍然不能免受苹果可能决定对SwftUI的<em class="ni">稍后</em>版本做出的任何改变的影响。</p><p id="cd16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">再说一遍，这应该没有必要。</strong></p><p id="a525" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嘿。苹果！</p><p id="b553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">安卓做对了。</p><p id="b1bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许我们应该考虑做同样的事情。</p><p id="51c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止。如往常一样，请在下面留下评论和问题，如果你想看更多，请点击“喜欢”按钮。</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="62c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ni">本文是</em> <a class="ae ky" href="https://michaellong.medium.com/the-swiftui-series-abc180690a9d" rel="noopener"> <em class="ni"> The SwiftUI系列</em> </a> <em class="ni">的一部分。</em></p></div></div>    
</body>
</html>