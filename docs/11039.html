<html>
<head>
<title>Basics Of Consistency And Locking In Databases</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据库中一致性和锁定的基础知识</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/basics-of-consistency-and-locking-in-databases-8156ffc1166f?source=collection_archive---------1-----------------------#2022-02-13">https://betterprogramming.pub/basics-of-consistency-and-locking-in-databases-8156ffc1166f?source=collection_archive---------1-----------------------#2022-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3b25" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们了解一下一致性、事务隔离级别和InnoDB中的锁定</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/70768725be4371bb6badeb6d3c97f762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rE1kVpSs_p0xTFDB"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">大卫·普帕扎在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="44af" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">酸</h1><p id="0e73" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">数据库事务是数据库管理系统中执行的一个工作单元。例如创建记录、更新记录、删除记录等等。</p><p id="fe9b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">酸是代表原子性、一致性、隔离性和持久性的首字母缩写词。这是可靠数据库事务的四个属性。</p><h1 id="9e7a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">“C”表示一致性</h1><p id="5f16" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这篇博客文章主要关注数据库事务的一致性方面。</p><p id="8afa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">一致性确保数据始终保持完整。这意味着数据库将始终处于有效状态。</p><p id="304d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们想象一个购物场景来更好地理解一致性。以下可能代表处理此类操作的步骤:</p><ol class=""><li id="2736" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">用户将商品添加到购物车</li><li id="2d1b" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">检查的项目数量</li><li id="5a27" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">用户使用他们的在线钱包支付物品</li><li id="9cb5" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">付款已批准</li><li id="f99e" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">项目数量已更新</li><li id="e650" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">用户余额已更新</li><li id="ade0" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">订单已处理</li></ol><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0c40" class="ni kx iq ne b gy nj nk l nl nm">+---------+---------+----------+<br/>| Item ID |  Price  | Quantity |<br/>+---------+---------+----------+<br/>|       9 | 200.00  |        1 |<br/>+---------+---------+----------+</span><span id="d9d5" class="ni kx iq ne b gy nn nk l nl nm">+-----------+---------+<br/>| Wallet ID | Balance |<br/>+-----------+---------+<br/>|        42 |  500.00 |<br/>+-----------+---------+</span></pre><p id="1df0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">假设这些步骤是单个数据库事务的一部分。一旦事务完成，我们期望一致的数据库处于这种状态:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="4103" class="ni kx iq ne b gy nj nk l nl nm">+---------+---------+----------+<br/>| Item ID |  Price  | Quantity |<br/>+---------+---------+----------+<br/>|       9 | 200.00  |        0 |<br/>+---------+---------+----------+</span><span id="000a" class="ni kx iq ne b gy nn nk l nl nm">+-----------+---------+<br/>| Wallet ID | Balance |<br/>+-----------+---------+<br/>|        42 |  300.00 |<br/>+-----------+---------+</span></pre><p id="6654" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这表明数据库从未处于无效状态。如果不能保证一致性，我们可以让数据库处于这样的状态:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="8d88" class="ni kx iq ne b gy nj nk l nl nm">+---------+---------+----------+<br/>| Item ID |  Price  | Quantity |<br/>+---------+---------+----------+<br/>|       9 | 200.00  |        0 |<br/>+---------+---------+----------+</span><span id="f7f1" class="ni kx iq ne b gy nn nk l nl nm">+-----------+---------+<br/>| Wallet ID | Balance |<br/>+-----------+---------+<br/>|        42 |  500.00 |<br/>+-----------+---------+</span></pre><p id="c112" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你看到这里的问题了吗？数据库处理了订单，但由于某种原因，钱包余额没有改变。这是数据库的不一致状态。这种不一致可能会损害我们的业务。</p><h1 id="e68c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在不同的一致性水平下会发生什么？</h1><p id="92af" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">三种现象解释了在一致性保证失败的情况下会发生什么。</p><p id="41f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在数据库中，“提交”意味着将数据永久保存在数据库中。</p><h2 id="4b9a" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">1.脏读</h2><p id="6bd8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">事务T1可以从其他事务中读取尚未提交的数据。</p><p id="8379" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">想象上述购物的交易如下所示:</p><p id="1650" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在假设库存中只剩下一件商品。</p><ul class=""><li id="769f" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj nz mv mw mx bi translated">用户1开始交易T1通过步骤1到8。</li><li id="3833" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj nz mv mw mx bi translated">就在用户2试图查看该项目的细节之后。</li></ul><p id="f3db" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">即使交易T1尚未完成，用户2也会看到该商品缺货。</p><p id="417a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在假设由于某种原因，T1在提交之前失败了。现在用户2认为该商品缺货，尽管用户1不能购买该商品。</p><h2 id="c984" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">2.不可重复读取</h2><p id="f15c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">事务T1读取一行两次，得到不同的结果。这可能是因为另一个事务更改了该行中的值或删除了该行。</p><h2 id="5365" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">3.幻像读取</h2><p id="db7c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">事务1执行相同的read语句，第一次读取时没有显示see行。这可能是因为另一个事务插入了与T1的读取标准相匹配的新行。</p><p id="3c9f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于我们假设的例子，我们可以用一个更好的设计来避免上面显示的问题。也有不同的隔离级别带来不同的一致性级别。为我们的业务选择合适的隔离级别是一个关键决策。</p><h1 id="ec6a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">了解锁</h1><p id="37db" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在继续讨论事务隔离级别之前，让我们理解不同锁的含义。</p><p id="bd48" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">锁定是为了达到承诺的一致性水平。为此，每个隔离级别根据其承诺使用不同的锁定方法。</p><h2 id="7cb3" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">共享锁</h2><p id="4779" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">持有锁的事务可以读取该行。</p><p id="b048" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果事务T1持有行R上的共享锁:</p><p id="ad2b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">-第二个事务T2可以获得行r上的S锁。它们“共享”该锁，并且可以同时读取该行。</p><p id="59b0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">-第二个事务T2无法获得行r上的X锁。T1不共享该锁，并防止T2修改行r</p><h2 id="8031" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">独占锁(X锁)</h2><p id="15d1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">持有锁的事务可以更新或删除该行。</p><p id="ebf0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果事务T1持有对行R的排他锁:</p><p id="8cbf" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">-第二个事务T2无法获取行r上的S锁或X锁。该锁只属于T1，直到T1释放它。</p><h2 id="a0b9" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">非锁定读取</h2><p id="c5d4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">非锁定读取是不锁定行的“SELECT”语句。这些是“SELECT … FROM …”形式的普通“SELECT”语句。它们不能保证一致性。</p><h2 id="eed0" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">锁定读取</h2><p id="a834" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">锁定读取是“SELECT”语句，它锁定行以防止其他人更改它们。</p><h2 id="5b2c" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">记录锁</h2><p id="ebb2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记录锁是仅在索引记录上的锁。这种锁定防止其他人修改该记录。</p><h2 id="f3a4" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">间隙锁</h2><p id="08b3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在索引记录之间的间隙上设置间隙锁。这是为了防止其他事务向锁定的间隙中插入新行。</p><p id="5729" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">间隙锁是下一把钥匙锁的一部分。InnoDB使用锁来锁定相关的间隙，以确保我们在工作的范围内不会遇到幻像行。</p><h2 id="0a7c" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">下一键锁</h2><p id="51f1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下一键锁是记录锁和间隙锁的组合。记录上的记录锁和间隙锁被设置在我们不希望被另一个事务影响的范围内。这可能是我们正在处理的记录之前和/或之后的间隙。</p><h1 id="20e9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">事务隔离级别</h1><p id="b139" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">事务隔离级别就像具有不同级别的一致性-性能权衡的预置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/f13d1d894b209d8575aade5a0915c56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2K5ecPhn6LtfY1Oe7PUnw.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当我们从未提交读取到可序列化时，一致性会增加，性能会降低。</p></figure><p id="74f4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不同的事务隔离级别解决不同的问题。</p><h2 id="86d9" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">未提交读取</h2><p id="49af" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这一级别，事务隔离处于最低级别——在这一级别时，它们没有被隔离，也没有设置锁。每个事务都将读取其他事务的最新更改。即使这些更改尚未提交。这可能会导致脏读。</p><h2 id="e311" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">已提交读取</h2><p id="2596" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这个级别，事务只读取其他事务提交的更改。此级别仅防止脏读。</p><p id="491c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">对于“SELECT … FOR UPDATE”、“SELECT … FOR SHARE”、“UPDATE”和“DELETE”语句，InnoDB会锁定索引记录。这是为了防止其他事务修改这些行。</p><h2 id="45d3" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">可重复读</h2><p id="0f2c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这是InnoDB的默认事务隔离级别。</p><p id="214d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个级别，事务内部的读取是一致的。事务在第一次读取时获取当前状态的快照，并在整个事务中使用该快照。这确保了所有的读取可以在同一个事务中重复，因此命名为Repeatable-Read。此级别可防止脏读和不可重复的读。</p><p id="772f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这个级别，InnoDB使用next-key锁进行搜索和索引扫描。下一键锁防止幻影读取。值得注意的是，这个级别保证只有“读”操作才不会出现幻像行。对表中所有记录的“更新”将对“所有提交的行”生效。这包括来自其他事务的行—那些是幻影行。这意味着幻像行仍然可以出现在这个级别。</p><h2 id="7bd9" class="ni kx iq bd ky no np dn lc nq nr dp lg lx ns nt li mb nu nv lk mf nw nx lm ny bi translated">可序列化</h2><p id="0de1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这个级别上，事务之间是完全隔离的。这可以防止脏读、不可重复读和幻像读。</p><p id="28c6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">正如我们所看到的，每个事务隔离级别解决不同的问题。我们实现隔离的方法是通过使用不同的锁定机制。</p><h1 id="8f96" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="33b2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当理解数据库中的锁时，我们需要记住目的是提供一定程度的一致性。而且俗话说，天下没有免费的午餐。为了获得更高的一致性，我们需要添加更多的锁，更多的锁意味着更多的开销，因此会损失性能。为了能够选择合适的解决方案，我们必须了解我们系统的需求。</p></div><div class="ab cl ob oc hu od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="ij ik il im in"><p id="f801" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><em class="oi">最初发表于</em>【https://recepinanc.com】<em class="oi"/></p></div></div>    
</body>
</html>