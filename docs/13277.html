<html>
<head>
<title>Optimizing Recomposition in Jetpack Compose: Stability System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jetpack Compose中的优化重组:稳定系统</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optimizing-recomposition-in-jetpack-compose-stability-system-f8ec0c92de33?source=collection_archive---------1-----------------------#2022-08-13">https://betterprogramming.pub/optimizing-recomposition-in-jetpack-compose-stability-system-f8ec0c92de33?source=collection_archive---------1-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3499" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">深入了解Jetpack Compose的稳定性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/537fbf5b358c5f1dfc380e8f378c04d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QNdVNqF6gqSjzVlZ"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@shmabbss?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿比盖尔·林恩</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="51a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Jetpack Compose具有智能重组功能，这是一个有助于高效重组的系统。它基本上是基于位置记忆设计的，对可组合的稳定性也有很大的影响。在本文中，我们将深入研究Jetpack Compose的稳定性。</p><p id="e839" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，Compose中的“稳定”是什么？稳定状态遵循三个条件。</p><ul class=""><li id="c701" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">当一个值改变时，它应该被通知给composable。(诱导重组)</li><li id="5fdb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果两个实例处于相同的状态，那么两个实例上的equals应该总是返回相同的结果。</li><li id="e2df" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">所有公共字段也必须是稳定的。</li></ul><p id="5879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果符合这三个条件，则合成会认为该字段处于稳定状态，如果该字段的值没有改变，则跳过可合成的重新合成。这被称为可跳过状态。skippable是跳过重组，直到有一个值改变的通知，由于条件是，当该字段的值改变时，composable将被通知。</p><p id="c1e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">基本上，基本类型和函数类型被认为是稳定的，因为它们不能被定义改变。</p><p id="2cc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做出这种稳定状态的注释是<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/StableMarker" rel="noopener ugc nofollow" target="_blank">@StableMarker</a></code>，Compose使用了两种稳定状态。(两个注释都使用了<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/StableMarker" rel="noopener ugc nofollow" target="_blank">@StableMarker</a></code></p><ul class=""><li id="5947" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Immutable" rel="noopener ugc nofollow" target="_blank">@不可变</a></li><li id="1c99" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/Stable" rel="noopener ugc nofollow" target="_blank">@稳定</a></li></ul><p id="94f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是<code class="fe mg mh mi mj b">@Immutable</code>注释，表示所有的公共字段自从创建以来都是不可变的，并且可以应用于一个类。因为值在创建后不会改变，所以稳定性的第一条规则是“当值改变时，应该通知可组合组件。”被忽略。这是一个比Kotlin的<code class="fe mg mh mi mj b">val</code>关键词更强的承诺。在<code class="fe mg mh mi mj b">val</code>的例子中，实例是相同的，但是内部值可以改变。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="df26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b">@Immutable</code>不允许这样。这对于所有字段都是<code class="fe mg mh mi mj b">val</code>并且没有额外的getters的<code class="fe mg mh mi mj b">data class</code>非常有用。</p><p id="901c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个是<code class="fe mg mh mi mj b">@Stable</code>，表示一个可变的状态，其值可以改变，根据应用的对象，角色略有不同。如果应用于任何类型，则StableMarker的角色在没有任何附加角色的情况下被接受。如果应用于函数或属性，它将具有StableMarker之外的角色。对于相同的输入，它总是产生相同的输出(一个纯函数)，在函数的情况下，它承诺所有的自变量也是稳定状态。如果输入相同，将跳过重组，因为输出也相同。</p><p id="2016" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于稳定系统的不变状态，有一点需要注意。下面代码中<code class="fe mg mh mi mj b">TextWithImmutableList</code>的<code class="fe mg mh mi mj b">texts</code>参数是不可变的吗？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b5e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">定义本身是不可变的，因为列表类型不是到<code class="fe mg mh mi mj b">MutableList</code>而是到<code class="fe mg mh mi mj b">List</code>，但是由于<code class="fe mg mh mi mj b">MutableList</code>扩展了<code class="fe mg mh mi mj b">List</code>，可变列表可以作为不可变类型传递。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="a123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，上述函数的<code class="fe mg mh mi mj b">texts</code>自变量被判断为不处于稳定状态，不可跳过。为了使<code class="fe mg mh mi mj b">texts</code>稳定，我们需要告诉编译器<code class="fe mg mh mi mj b">List</code>是不可变的。</p><p id="2efa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法是使用<code class="fe mg mh mi mj b">@Immutable</code> StableMarker为<code class="fe mg mh mi mj b">List</code>创建一个包装器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b4c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得<code class="fe mg mh mi mj b">ImmutableListWrapper</code>本身是不可变的，所以编译器认为<code class="fe mg mh mi mj b">texts</code>参数是稳定的，而<code class="fe mg mh mi mj b">TextWithImmutableList</code>可组合的变得可跳过。</p><p id="556c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方式是用科特林的<code class="fe mg mh mi mj b">ImmutableCollections</code>。这是一个没有内置到Kotlin中的Kotlin附加库。它由JetBrains创建和维护，目前处于alpha版本，但Compose在其稳定性系统中使用它。</p><div class="mm mn gp gr mo mp"><a href="https://github.com/Kotlin/kotlinx.collections.immutable" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd ir gy z fp mu fr fs mv fu fw ip bi translated">kot Lin/kot linx . collections . immutable</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">Kotlin的不可变集合接口和实现原型。</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">github.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd kp mp"/></div></div></a></div><p id="42af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果使用<code class="fe mg mh mi mj b">ImmutableCollections</code>接收到<code class="fe mg mh mi mj b">texts</code>参数，它被判断为不可变的，并且<code class="fe mg mh mi mj b">TextWithImmutableList</code>可组合的变得可跳过。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1f69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，所有的稳定性都被传播。在下面的代码中，由于<code class="fe mg mh mi mj b">provideSungbinLand</code>函数的返回类型<code class="fe mg mh mi mj b">SungbinLand</code>处于稳定状态，所以即使函数中没有StableMarker，也认为<code class="fe mg mh mi mj b">provideSungbinLand</code>函数处于稳定状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="981e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将上面代码中的StableMarker从<code class="fe mg mh mi mj b">SungbinLand</code>移到<code class="fe mg mh mi mj b">SungbinLandImpl</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="93a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，<code class="fe mg mh mi mj b">provideSungbinLand</code>函数被认为是不稳定的，因为StableMarker注释已经从<code class="fe mg mh mi mj b">provideSungbinLand</code>函数的返回类型中移除。再看<code class="fe mg mh mi mj b">SungbinLandDisplay</code> composable，<code class="fe mg mh mi mj b">data</code>参数的类型是不稳定状态，但是用于在<code class="fe mg mh mi mj b">provideSungbinLand</code>函数中提供一个值用作<code class="fe mg mh mi mj b">data</code>参数的默认值的<code class="fe mg mh mi mj b">SungbinLandImpl</code>类是稳定状态。所以，这个可组合的东西就可以跳过了。然而,<code class="fe mg mh mi mj b">data</code>争论仍然保持在不稳定的状态。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="ce06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe mg mh mi mj b">@StableMarker</code>使用不当，结果可能与Compose编译器预期的不同，并且可能出现运行时错误。此外，即使正确使用，也很难始终遵守规则。所以Compose有一个系统，除了基本公认稳定的类型之外，还能推断出是稳定类型。</p><p id="e19c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Compose的稳定性推理系统只适用于类，<code class="fe mg mh mi mj b"><a class="ae kv" href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/internal/StabilityInferred" rel="noopener ugc nofollow" target="_blank">@StabilityInferred</a></code>在编译时注释<strong class="ky ir">Compose中使用的所有</strong>类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="46ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，在上面的代码中，<code class="fe mg mh mi mj b">Name</code>类被认为是稳定的，因为所有字段都是不可变的稳定类型。</p><p id="01c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">泛型类呢？因为<code class="fe mg mh mi mj b">T</code>没有具体化，所以<code class="fe mg mh mi mj b">NameWithGeneric</code>类不知道类型。在这种情况下，Compose编译器在编译期间计算<code class="fe mg mh mi mj b">T</code>的位掩码，然后将相应的值作为<code class="fe mg mh mi mj b">StabilityInferred</code>的参数传递。这样，稳定性就可以从那个论点的值中推断出来。</p><p id="15e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，因为唯一的<code class="fe mg mh mi mj b">value</code>字段是可变的，所以不能保证“当一个值改变时，它应该被通知给可组合的”规则得到遵守，所以即使<code class="fe mg mh mi mj b">T</code>类型是稳定的，也认为<code class="fe mg mh mi mj b">NameWithGeneric</code>类是不稳定的。</p><p id="7e07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，我们已经了解了Compose的稳定性系统。感谢阅读。</p><pre class="kg kh ki kj gt nl mj nm nn aw no bi"><span id="a617" class="np nq iq mj b gy nr ns l nt nu"><a class="ae kv" href="https://sungbin.land/a-deep-dive-into-jetpack-compose-stability-38b5b109da71" rel="noopener ugc nofollow" target="_blank">[View in Korean]</a></span></pre></div></div>    
</body>
</html>