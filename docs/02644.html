<html>
<head>
<title>An Introduction to Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归入门</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-recursion-fdf2a4be2dc0?source=collection_archive---------10-----------------------#2019-12-14">https://betterprogramming.pub/an-introduction-to-recursion-fdf2a4be2dc0?source=collection_archive---------10-----------------------#2019-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="df4e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用例子探索递归的定义和目的</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3f180ef4e754a90e039ce419b3a56db9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_DXRSR_jyUSr3wGD"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这可能是打破记录是件好事的唯一例子。由<a class="ae ky" href="https://unsplash.com/@leecampbell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">李·坎贝尔</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</p></figure><p id="8dab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">韦氏词典将递归描述为:</p><blockquote class="lv lw lx"><p id="b344" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><em class="it">一种计算机程序设计技术，涉及一个过程、子程序、函数或算法的使用，该过程、子程序、函数或算法调用自身一次或多次，直到满足一个特定的条件，此时从最后一次调用到第一次调用，每次重复的其余部分都被处理。</em>”</p></blockquote><p id="bf44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">听起来很多。事实上，递归的概念很简单。基本上，它是一个在满足特定条件之前会一直执行的函数。有时这个术语被用来描述这种重复的行为，而不是功能本身，所以，尽管它可能依赖于上下文，但定义在很大程度上是相同的。</p><p id="3b1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有一个简单的例子，你现在就可以在你的控制台上运行:</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="cf3f" class="mh mi it md b gy mj mk l ml mm">function alertTillStop(){<br/>  if (prompt("Type STOP to stop this from appearing") === 'STOP') {<br/>    return null<br/>  } else {<br/>    alert('Incorrect input received. Recursing alertTillStop…')<br/>    alertTillStop()<br/>  }<br/>}</span></pre><p id="b13e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，该函数触发了一个警告，然后从头开始再次执行，直到客户端键入<code class="fe mn mo mp md b">STOP</code>为止。在函数内部再次调用同一个函数的行为就是递归。</p><p id="8994" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个基本的例子是阶乘，一个数减去一，然后再相乘(例如，5的阶乘是5*4*3*2*1)。布兰登·莫雷利在<a class="ae ky" href="https://codeburst.io/learn-and-understand-recursion-in-javascript-b588218e87ea" rel="noopener" target="_blank"> codeburst.io </a>中的一篇文章展示了递归在这里是如何工作的:一个函数接受一个数字，然后返回这个数字乘以这个函数的结果(又称为<em class="ly">递归</em>)减去1。这个函数中还有几个条件——这些条件用来处理接近于零的数字，并帮助为递归函数提供一个确定的结尾。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="30ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">递归函数类似于循环。你可能会发现自己不知道什么时候使用一个而不是另一个。因为这是编程，所以通常没有一个简单快速的答案。必须根据具体情况做出决定，考虑诸如语言、可读性、冗长性和对调用堆栈的影响等因素。</p><p id="e7ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在诸如<a class="ae ky" href="https://stackoverflow.com/questions/660337/recursion-vs-loops" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>和<a class="ae ky" href="https://arstechnica.com/information-technology/2013/04/recursion-or-while-loops-which-is-better/" rel="noopener ugc nofollow" target="_blank"> arstechnica </a>这样的网站上有关于这个主题的很好的讨论，但是它们超出了初学者指南的范围。在这个阶段，让我们只探索递归函数以及如何使用它们。</p><p id="40c3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，让我们讨论一些在构造递归时需要考虑的事情。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="29d5" class="mx mi it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">递归的目的</h1><p id="121b" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">递归函数有许多用途，但是像任何其他类型的代码一样，应该考虑它们的必要性。如上所述，考虑递归和循环之间的差异，并使用最适合您需求的一个。如果您决定使用递归，在开始编写实际代码之前，请决定您希望函数做什么。</p><h1 id="0735" class="mx mi it bd my mz nt nb nc nd nu nf ng jz nv ka ni kc nw kd nk kf nx kg nm nn bi translated">开始、继续和停止递归的条件</h1><p id="ceda" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">重要的是，首先要查看任何可能引发递归的参数或条件。例如，该函数可以有一个可能是字符串或数组的参数。函数本身可能必须识别数据类型，而不是在此之前被识别(比如被父函数识别)。在更简单的场景中，开始条件通常与迫使递归继续的条件完全相同。</p><p id="1c60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更重要的是，您希望建立一个递归操作停止的条件。这些条件称为基本情况，产生一个实际值，而不是对函数的另一个调用。然而，在尾端递归的情况下，返回值仍然调用一个函数，但是立即获得该函数的值。我知道这有点令人困惑，所以在这篇介绍性文章之后，请尽最大努力熟悉其他类型的递归。</p><p id="5811" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本用例的建立通常是通过让一个条件观察一些质量来实现的，比如一个数组的长度或者一个数的数量，就像循环一样。但是，有多种方法可以实现它，所以可以根据需要随意改变复杂性。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="4605" class="mx mi it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">放置递归动作的位置</h1><p id="858f" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">这似乎是显而易见的，但是你在函数中放置递归的位置将决定什么被重复，如果有的话。如果你把函数调用放在错误的地方，你可能根本不会执行递归。在天平的另一端，你可能会引起逻辑冲突，导致它无限地爆发，这是一件很不愉快的事情。</p><p id="c64b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">确保你的电话拨对了。即使它不会导致上述问题之一，错误的调用也会影响您正在处理的数据，导致错误，其病理可能变得模糊不清。</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><h1 id="93ad" class="mx mi it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">使用递归随机化一个数组并将其分段</h1><p id="1201" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">我将在这里构造一个更复杂的例子。假设你有一组20名学生，每个人都被分配了一个号码。这些数字可以用一个数组来表示。假设有一个学生要做的活动，我们想让他们随机分成三个小组。</p><p id="93ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们继续之前，让我们考虑几件事情:</p><ul class=""><li id="5d2f" class="ny nz it lb b lc ld lf lg li oa lm ob lq oc lu od oe of og bi translated">20不能被3整除。我必须通过找到另一个学生或者开除一个学生来解释这个问题，这两种方法在这种情况下都是不可行的。所以，我应该打算一组两个。没有必要恐慌——就像现实生活一样，分组不会总是按计划进行。</li><li id="dcae" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">记住，我们要随机分组学生。因此，我们不希望类似[1，2，3]和[4，5，6]等等的东西被分配在一起。我们应该构建某种随机函数在原始数组上运行，这样我们就可以很容易地将它分成三组。这个函数应该只是它接收的数组的一个混洗版本——在它的组成中不应该有重复的数据。</li><li id="6088" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu od oe of og bi translated">我需要为这些功能中的每一个建立停止点。对于随机化，我最有可能从一个被填充的空数组开始，所以当它的长度等于原始数组的长度时，我应该停止。对于我的分组函数，我可以砍掉数组的一部分，把它们交给另一个数组。当我的原始数组没有长度时，我可以停止这个分段操作。</li></ul><p id="25d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们组成我们的数据。假设我们有一个变量<code class="fe mn mo mp md b">studentNums</code>，它代表班上每个学生的数字。这将是一堆CSV文件，它们最终被封装在一个数组中，所以我将使用numbergenerator.org的<a class="ae ky" href="http://numbergenerator.org" rel="noopener ugc nofollow" target="_blank">给自己一个从1到20的CSV列表，然后我可以复制并粘贴它，最后用括号括起来。</a></p><p id="44f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mn mo mp md b">studentNums = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code></p><p id="5bf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们构造一个函数来随机化数组的顺序。在这个函数中，我们将使用递归和while循环。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="1468" class="mh mi it md b gy mj mk l ml mm">function randomizeArrayNow(arr){		<br/>    let newArr = []		<br/>  <br/>    let randomize = () =&gt; {<br/>        while (newArr.length !== arr.length){<br/>            let randomNum = randomNumber = Math.floor(Math.random()*arr.length)<br/>            if (newArr.includes(arr[randomNum])) {<br/>                randomize()<br/>            } else {<br/>                newArr.push(arr[randomNum])<br/>            }<br/>        }<br/>    }<br/>    randomize()<br/>    return newArr<br/>}</span></pre><p id="e902" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ly">完整代码见</em> <a class="ae ky" href="https://gist.github.com/TimeSmash/6e55e4e8e1947290e9e13e559e040e36" rel="noopener ugc nofollow" target="_blank"> <em class="ly"> Github </em> </a></p><p id="ba55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我分解这个东西之前，请注意它是高度未优化的。我有一个while循环，里面有一个递归，这使得它成为一个计算量很大的函数。也就是说，它很好地满足了我们的目的，并表明您可以一起使用这两个迭代过程(尽管通常有更好的解决方案)。</p><p id="7278" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个变量<code class="fe mn mo mp md b">newArr</code>，它将是一个完全随机的数组，由我们作为参数提供的原始数组<code class="fe mn mo mp md b">arr</code>组成。</p><p id="14a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们定义一个名为<code class="fe mn mo mp md b">randomize</code>的内部函数，并调用它。这个函数使用一个while循环来比较<code class="fe mn mo mp md b">newArr</code>的长度和原始数组的长度。当<code class="fe mn mo mp md b">newArr</code>的长度等于原始数组的长度时，我们想要逃离这个while循环。这是有意义的，因为我们只是对原始数组进行了洗牌——最终它们之间不应该有任何长度差异。如果你洗52张牌来玩一手纸牌，最后你还是会有52张。</p><p id="51ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">while循环内部展示了这种洗牌是如何发生的。我们通过将<code class="fe mn mo mp md b">Math.random()</code>和数组的长度相乘来定义一个变量<code class="fe mn mo mp md b">randomNum</code>。<code class="fe mn mo mp md b">Math.random()</code>总是产生一个以零开头的小数。例如，0.1370654083994609和0.4284194450359835。我们可以将这些小数乘以数组的长度，得到以非零数字开始的新小数。</p><p id="23af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用<code class="fe mn mo mp md b">Math.floor</code>，我们可以将这些小数四舍五入到最接近的整数。正因为如此，我永远不会遇到类似于<code class="fe mn mo mp md b">students[20]</code>(导致未定义)的事件，因为即使我得到了<code class="fe mn mo mp md b">19.994989…</code>，我也总是得到19。</p><p id="9793" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的条件说明了<code class="fe mn mo mp md b">newArr</code>中的重复。我想随机化我放入的数组，这意味着在这种情况下不允许重复。通过使用<code class="fe mn mo mp md b">.includes</code>，我可以查看原始数组中的一个数字是否已经被放入<code class="fe mn mo mp md b">newArr </code>——如果是，我可以再次调用randomize来重置<code class="fe mn mo mp md b">randomNum</code>。</p><p id="043f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最终，我们将遇到一个实例，其中原始数组中的一个值没有被插入到<code class="fe mn mo mp md b">newArr</code>中。当那发生时，我们简单地插入它。插入这个数字会使<code class="fe mn mo mp md b">newArr</code>的长度增加1，并且在某个时候<code class="fe mn mo mp md b">newArr</code>的长度会等于原始数组的长度。此时，我们退出while循环。这意味着我们最初的<code class="fe mn mo mp md b">randomize()</code>呼叫已经解决。现在，我们可以只返回<code class="fe mn mo mp md b">newArr</code>，这将是一个完全随机化的数组！</p><p id="5701" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们把学生编号都打乱了。下一步是尽可能将学生分成三人一组。虽然我们还剩下两个人，但在这种情况下没问题——我们不必太担心。</p><p id="8de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个名为<code class="fe mn mo mp md b">breakIntoThrees</code>的新函数来获取这些组。这个函数使用内部函数和递归。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="8699" class="mh mi it md b gy mj mk l ml mm">function breakIntoThrees(array){<br/>    let groups = []<br/>    let getGroups = (arr) =&gt; {<br/>        if (arr.length){<br/>            groups.push(arr.splice(0,3))<br/>            getGroups(arr)<br/>        } else { console.log("done!") }<br/>    }<br/>    getGroups(array)<br/>    return groups<br/>}</span></pre><p id="76d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这看起来类似于随机函数，对吗？我们定义一个等于空数组的变量，使用内部函数，最后返回修改过的数组变量。因为我试图在两个例子中获得新的数组，所以它们共享相似的框架就不足为奇了。</p><p id="e083" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这引出了重要的一点。虽然函数的结构相似，但有几种方法可以使用递归，我只是碰巧使用了这里首先想到的方法。递归函数的使用和结构很大程度上取决于你要做什么。</p><p id="6ac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们定义一个名为<code class="fe mn mo mp md b">getGroups</code>的内部函数来为我们进行排序。它会查看数组的长度，虽然数组的长度不是0 (falsy ),但我们通过拼接砍掉了数组的前三个元素。这将返回一个新的更小的数组。然后我们可以将这个更小的数组添加到<code class="fe mn mo mp md b">groups</code>，它从一个空数组开始。最终，<code class="fe mn mo mp md b">groups</code>将是一个充满数组的数组。</p><p id="b658" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个过程一直持续到原始数组什么都没有了。当这种情况发生时，我们向控制台发送一条消息，通知自己这个过程已经完成，然后返回组。如前所述，这将是一个包含多个数组的数组；在我们的例子中，六个长度为3的数组和一个长度为2的数组。</p><p id="2718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在你有了组，你可以做你想做的。在一个更大规模的函数中使用上述函数作为助手可能是一个好主意，这样您就可以随机化学生并在同一个步骤中返回组，以及您想要对所述组执行的任何操作(例如使用循环/迭代器宣布它们)。完全由你决定！</p></div><div class="ab cl mq mr hx ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="im in io ip iq"><p id="adf1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，您应该已经熟悉了什么是递归、递归的目的以及构造递归的方法。它们是非常漂亮的代码片段，是迭代数据或流程的另一种方式。</p><p id="8e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在网上寻找更多的例子来实践这种技术。如果你正在构建一个演示应用程序，试着加入递归，看看它是如何大规模应用的。例如，您可以通过修改上面的“我的学生组”示例来创建一个简单的应用程序。它肯定比三人小组更灵活——如果你让数字动态化呢？如果你把学生变成物体，这样他们的名字就可以和一个数字联系起来，会怎么样？你也可以回顾旧的项目，看看它们是否能从递归中受益。</p><p id="33d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">今天到此为止。开心快乐编码！</p><h1 id="261e" class="mx mi it bd my mz nt nb nc nd nu nf ng jz nv ka ni kc nw kd nk kf nx kg nm nn bi translated">来源</h1><ol class=""><li id="75e2" class="ny nz it lb b lc no lf np li om lm on lq oo lu op oe of og bi translated">b .莫雷利(2017年8月21日)。学习并理解JavaScript中的递归。检索于2019年12月12日，来自<a class="ae ky" href="https://codeburst.io/learn-and-understand-recursion-in-javascript-b588218e87ea." rel="noopener" target="_blank">https://code burst . io/learn-and-understand-recursion-in-JavaScript-b 588218 e 87 ea。</a></li><li id="3d90" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu op oe of og bi translated">斯塔科弗洛。递归与循环。(2009年3月18日)。检索于2019年12月12日，来自<a class="ae ky" href="https://stackoverflow.com/questions/660337/recursion-vs-loops." rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/660337/recursion-vs-loops。</a></li><li id="8f84" class="ny nz it lb b lc oh lf oi li oj lm ok lq ol lu op oe of og bi translated">递归和while循环:哪个更好？(2013年4月27日)。检索于2019年12月12日，来自<a class="ae ky" href="https://arstechnica.com/information-technology/2013/04/recursion-or-while-loops-which-is-better/." rel="noopener ugc nofollow" target="_blank">https://ars technica . com/information-technology/2013/04/recursion-or-while-loops-哪个更好/。</a></li></ol></div></div>    
</body>
</html>