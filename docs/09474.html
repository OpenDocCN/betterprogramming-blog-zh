<html>
<head>
<title>This Is How I Keep My Flutter Projects Organized for Better Scalability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是我如何组织我的Flutter项目以获得更好的可伸缩性</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/this-is-how-i-keep-my-flutter-projects-organized-for-better-scalability-870f22706915?source=collection_archive---------6-----------------------#2021-08-30">https://betterprogramming.pub/this-is-how-i-keep-my-flutter-projects-organized-for-better-scalability-870f22706915?source=collection_archive---------6-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7ff" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如果你的项目随着时间的推移变得凌乱不堪，那你来对地方了</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5127473496ea0ab0279e9ee0d2ba3857.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBwb100rAWcsRydFeTz5mQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">三层架构—由作者创建</p></figure><p id="2bea" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有许多软件架构模型，但最常见的是三层架构，它由三个不同的层组成:</p><ol class=""><li id="50fc" class="lu lv it la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">表示层</li><li id="63c8" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">领域或业务层</li><li id="f18f" class="lu lv it la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">数据或持久层</li></ol><p id="0a47" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">关于这个架构，我将描述我如何组织我的项目。无论您在项目中使用哪种架构，主要思想都是相同的。</p><p id="6d84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">保持你的图层尽可能的分离，因为当项目变大时，这将会派上用场。在UI代码中包含业务逻辑是一种糟糕的做法，但如果你正在YouTube或Udemy上观看视频教程，讲师会犯这个错误，以帮助你更快地开始。这并不是说你应该继续犯同样的错误。</p><h1 id="09ee" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">数据层</h1><p id="47ac" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">这一层应该包含处理数据访问的类。我使用<a class="ae nf" href="https://pub.dev/packages/moor" rel="noopener ugc nofollow" target="_blank"> Moor </a>库来管理数据，因此这一层包含表定义和Dao(数据访问对象)。这一层还旨在包含迁移逻辑。当我说迁移时，我指的是不同版本的应用程序的数据模型的差异。</p><p id="6b60" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们正在开发一个待办事项应用程序，允许你建立几个待办事项列表。为了表示数据层，我们首先创建一个名为<code class="fe ng nh ni nj b">persistence</code> <strong class="la iu"> </strong>的文件夹。之后，我们将专注于数据模型。这将是一个简单的设计，将<code class="fe ng nh ni nj b">todo_list</code>和<code class="fe ng nh ni nj b">todo</code>表放在<code class="fe ng nh ni nj b">table</code>目录中。最后，我们将开发允许我们操作数据库的DAO类。因此，<code class="fe ng nh ni nj b">todo_list_dao</code>和<code class="fe ng nh ni nj b">todo_dao</code>类将在<code class="fe ng nh ni nj b">dao</code>目录中找到。除了这些目录，还会有一个<code class="fe ng nh ni nj b">migration</code>文件夹，一开始会是空的，但在更新应用时会很有用。</p><p id="da0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，数据层将如下所示。随着应用程序的增长，新的表和Dao将有序地添加进来。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/9ce7a72dd0000f8acd13ca0ade44fad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*HxlRCDOyx8NTcMqkbQCsiQ.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">简单todo应用程序的持久层</p></figure><h1 id="53a6" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">畴层</h1><p id="68fd" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">应用程序的业务逻辑存储在域层(也称为业务层)。数据层可以依赖于域层，但域层不能依赖于数据层。除了数据和UI相关的项目，这是我放所有东西的地方。当然，这里的结构是最灵活的，因为这一层是程序运行的基础。</p><p id="7591" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们以同一个待办app为例。这里可能的逻辑是什么？首先，我们需要一个todo管理器类，它可以加载所有可能的todo列表或一个特定的列表，或者更改特定todo项的状态。模型也可以包含在这一层中。请记住，用户界面将依赖于这一层，因此将从这一层使用这些模型和管理器。</p><p id="d4b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">到目前为止，结构看起来如下。然而，它可能会随着应用程序的增长和对更多功能的需求而发展。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/81aec54845bba7401667ebe45e92955c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TroA5N301xqq23c0510hew.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">todo应用程序的域层</p></figure><p id="fc92" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我一般在这个文件夹里放两个子文件夹:<code class="fe ng nh ni nj b">core</code>和<code class="fe ng nh ni nj b">model</code>。当我不需要那么多的管理器类时，我把它们放在这个文件夹的根目录下。当我需要多个管理器时，我通常为每个屏幕(或路径)创建子文件夹，并将管理器类放在其中。</p><h1 id="9ed7" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">表示层</h1><p id="7102" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">表示层是最容易理解的，但是它也包含了大部分的歧义。即使在企业级，我也见过直接在UI中使用DAOs。为了加载所有的待办事项，你在网上找到的第一个待办事项应用教程很可能会直接调用数据库。这是完全错误的。表示层不能依赖于数据层。最佳实践是依赖管理器界面。</p><p id="53b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Flutter在用户界面方面提供了很多东西。但是，您可能会注意到，代码几乎立即变成了大量嵌套。大多数UI代码应该按照某种逻辑进行划分和组织。对于依赖注入和路由，我使用<a class="ae nf" href="https://pub.dev/packages/flutter_modular" rel="noopener ugc nofollow" target="_blank">模块化</a>插件。route小部件通常包含一个脚手架及其<strong class="la iu"> </strong> <code class="fe ng nh ni nj b">body</code>，是我进入每个屏幕的入口点。例如，如果我有一个<code class="fe ng nh ni nj b">todos_route.dart</code>，我总会有一个<code class="fe ng nh ni nj b">todos_widget.dart</code>成为脚手架的主体。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">TodosWidget包含应用程序入口页面的所有UI代码，而不是TodosRoute</p></figure><p id="81a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在这一层还有两个子文件夹叫做<code class="fe ng nh ni nj b">component</code>和<code class="fe ng nh ni nj b">widget</code>。术语<code class="fe ng nh ni nj b">component</code>指的是更通用的小部件。例如，有三列的卡片是一个组件，而todo项是一个小部件。组件可以在任何地方使用，但是，小部件通常是领域专用的，应该只在您的应用程序中使用。</p><p id="9f0f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">总而言之，路径文件夹存储了应用程序的所有路径。在Components文件夹中，您会发现一些更常见、更通用的小部件。在Widget文件夹中，每个路由都有子文件夹，每个子文件夹都包含该路由实现中使用的所有Widget。</p><p id="716f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此迭代中，项目的UI文件夹将如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/83db05a417ed30cacadd8fc47abb87e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8e2siKB15Va1uvZC6rcLmg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">因为UI代码随着时间的推移变得越来越混乱，所以我们需要对这一层进行更好的组织。</p></figure><p id="6dd3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，如果你能把你的屏幕分成五个面板，你应该有五个部件来代表它们，并且你应该在不同的文件中实现这些类。这样，当需要改变的时候，你就知道该去哪里找了。</p><h1 id="cc47" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">变更请求示例:为待办事项列表添加类别</h1><p id="ff9d" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">到目前为止，我们相信我们有一个可扩展的架构。如果我们可以添加类别，并为某个类别分配待办事项列表，那就太好了！将您的工作优先放在持久层，这是您应该开始的地方。这需要创建一个名为<code class="fe ng nh ni nj b">category</code>的新表和一个名为<code class="fe ng nh ni nj b">category_dao</code>的新dao。我们需要创建迁移代码，因为我们正在改变数据库模型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/a320234e0aad31f99bac627260577d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0T8rEr1l2R6tjsN_yUnzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加了'<strong class="bd nq">类别'</strong>功能后的持久层。</p></figure><p id="a516" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成持久层之后，我们应该继续到领域层。显然，最重要的增加将是<code class="fe ng nh ni nj b">category_manager</code>类，它将使用<code class="fe ng nh ni nj b">category_dao</code>和可能的<code class="fe ng nh ni nj b">todo_list_dao</code>操作数据。我可能会在<code class="fe ng nh ni nj b">core</code>子文件夹中添加更多的类，但是如前所述，这一层的组织完全取决于您的应用程序，所以要灵活，但是在添加任何东西之前要三思，尽量不要破坏有意义的层次结构。现在看起来是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/7d063c90da256695ffa3360bd531412d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5nI024yfwYMntgi2JSVAw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">添加<strong class="bd nq">类别</strong>特征后的域层</p></figure><p id="c8ad" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们已经完成了用户界面的修改。因为这是一个假设的app，所以我们会虚构一些需求。首先，我们希望在主页上有待办事项列表<code class="fe ng nh ni nj b">categorized</code>。我们习惯在回家的路上列出所有的待办事项。我们的类别面板现在将滑动，因此我们将需要一个新的部件和组件。此外，我们还需要一条新的路线，这样我们也可以更改这条路线上的类别。UI文件夹最终会是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/3df74225f27e92f0b0168cb7f97d6d2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8k1AlgVedl-RxMw3SqmC2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">引入类别功能后的UI层</p></figure><p id="3434" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我使用这种方法已经有一段时间了，尤其是对于UI，随着项目的发展，代码变得更容易处理。因为我几乎总是在我的辅助项目中使用三层设计，所以我从未有过例外。</p></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="6243" class="mi mj it bd mk ml oa mn mo mp ob mr ms jz oc ka mu kc od kd mw kf oe kg my mz bi translated">结论</h1><p id="ca68" class="pw-post-body-paragraph ky kz it la b lb na ju ld le nb jx lg lh nc lj lk ll nd ln lo lp ne lr ls lt im bi translated">您使用的体系结构会对文件夹的结构产生重大影响。即使您试图使用微服务架构，您也可以使用上述结构，至少对于UI是这样。我想说，如果你的UI代码组织得很好，随着项目的进展，你会有更少的麻烦。</p><p id="cc5c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你在这里读到的东西都不是一成不变的。然而，我强烈建议你重新考虑你的结构，以便在你发展的后期更容易成长。如果你使用任何其他有效的组织策略，请在评论中分享，以便我改进这个结构。</p></div></div>    
</body>
</html>