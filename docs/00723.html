<html>
<head>
<title>4 Different Approaches to Non-Redux Global State Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非冗余全局状态库的4种不同方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/4-different-approaches-to-non-redux-global-state-libraries-1fd159efb5fa?source=collection_archive---------1-----------------------#2019-07-06">https://betterprogramming.pub/4-different-approaches-to-non-redux-global-state-libraries-1fd159efb5fa?source=collection_archive---------1-----------------------#2019-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6895" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从消费者的角度来看</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e0531c1fb5da2e5287607d000f69b72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f6bvB6IiechdCZK4P2lkoQ.jpeg"/></div></div></figure><h1 id="5d4a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="7b96" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">自从React Hooks登陆以来，已经有很多针对全局状态的库被提出。其中一些是简单的上下文包装器，而另一些是全功能的状态管理系统。</p><p id="801f" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">从技术上讲，如何存储状态和通知更改有几种实现。在这篇文章中，我们不详细讨论，只注意两个轴:</p><ol class=""><li id="4b19" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh ms mt mu mv bi translated">无论是基于上下文的存储还是外部存储</li><li id="87b0" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh ms mt mu mv bi translated">无论是基于订阅还是上下文传播。</li></ol><p id="34c0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这篇文章中，我们关注的是消费者端钩子的API设计。根据我的观察，API设计有四种方法。让我们通过伪代码的例子来看看每种方法。举个简单的例子，我们假设一个应用程序具有以下内容:</p><ul class=""><li id="fbc4" class="mn mo it lo b lp mi ls mj lv mp lz mq md mr mh nb mt mu mv bi translated">两个全局计数器；</li><li id="295c" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nb mt mu mv bi translated">两个计数器组件；和</li><li id="75ad" class="mn mo it lo b lp mw ls mx lv my lz mz md na mh nb mt mu mv bi translated">增加两个计数器的动作。</li></ul><p id="491a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意，在提供者端，它是与实现无关的。因此，<code class="fe nc nd ne nf b">&lt;Provider&gt; </code>不一定意味着对上下文做出反应。</p><h1 id="4d44" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">方法1:多重环境</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="9b33" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这种方法可能是最惯用的。用React context和useContext可以很容易地实现这种方法。</p><p id="4753" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">有两个采用这种方法的库:<a class="ae ni" href="https://github.com/diegohaz/constate" rel="noopener ugc nofollow" target="_blank"> constate </a>和<a class="ae ni" href="https://github.com/jamiebuilds/unstated-next" rel="noopener ugc nofollow" target="_blank">unstated——next</a>。</p><h1 id="e0d5" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">方法2:通过属性名(或路径)进行选择</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="5130" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这种方法是将更多的价值放在一个商店中。单个存储允许您分派一个操作来更改多个值。您可以指定一个属性名来获取相应的值。通过名称来指定很简单，但是在复杂的情况下有点受限。</p><p id="a944" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这种方法有两个库:<a class="ae ni" href="https://github.com/dai-shi/react-hooks-global-state" rel="noopener ugc nofollow" target="_blank"> react-hooks-global-state </a>和<a class="ae ni" href="https://github.com/storeon/storeon" rel="noopener ugc nofollow" target="_blank"> shareon </a>。</p><h1 id="c274" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">方法3:通过选择器函数进行选择</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b74a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">与前面的代码相比，只有两行发生了变化。选择器函数比属性名更灵活。如此灵活，以至于它们可能会像进行昂贵的计算一样被误用。最重要的是，性能优化通常需要您保持对象引用相等。</p><p id="9cef" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">采用这种方法的两个库:<a class="ae ni" href="https://github.com/react-spring/zustand" rel="noopener ugc nofollow" target="_blank"> zustand </a>和<a class="ae ni" href="https://github.com/atlassian/react-sweet-state" rel="noopener ugc nofollow" target="_blank"> react-sweet-state </a>。</p><h1 id="7214" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">方法4:状态使用跟踪</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="17b9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">注意<code class="fe nc nd ne nf b">state</code>部分与之前的代码有所不同。<code class="fe nc nd ne nf b">dispatch</code>部分不变。这种方法消除了选择器功能，而且很难被误用。一个大问题是性能优化。这超出了本文的范围，但根据一些基准测试，它实际上已经相当不错了。如果你有兴趣，请查看<a class="ae ni" href="https://blog.axlight.com/posts/benchmark-react-tracked/" rel="noopener ugc nofollow" target="_blank">的另一个帖子</a>。</p><p id="8136" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里有一个采用这种方法的库:<a class="ae ni" href="https://github.com/dai-shi/react-tracked" rel="noopener ugc nofollow" target="_blank">反应跟踪</a>。</p><h1 id="07c7" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结束语</h1><p id="cb23" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这些例子可能太做作，但我希望它们能解释不同之处。就个人而言，我会根据案例及其需求使用任何方法。</p><p id="1b70" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">最后，本文的第二个目的是让读者了解最后一种方法，“状态使用跟踪”我希望你得到它。</p><p id="2c85" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">原刊<a class="ae ni" href="https://blog.axlight.com/posts/four-different-approaches-to-non-redux-global-state-libraries/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>