<html>
<head>
<title>withAnimation Completion Callback With Animatable Modifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有动画完成回调和动画修改器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/withanimation-completion-callback-with-animatable-modifiers-2df8a657cbfd?source=collection_archive---------16-----------------------#2020-09-01">https://betterprogramming.pub/withanimation-completion-callback-with-animatable-modifiers-2df8a657cbfd?source=collection_archive---------16-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd89" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">SwiftUI中缺少的方法</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/196bf84d73518220ba141e625a7424d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lk-V3D-Ww29XHWfV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">科尔顿·迪安·马歇尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="4ee5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">SwiftUI在动画方面非常棒，因为它用<code class="fe lv lw lx ly b">withAnimation</code>和<code class="fe lv lw lx ly b">animation(...)</code>这样的方法为你做了很多事情。你可以简单地传递你想让它动起来的东西，SwiftUI会确保你的视图从一种状态平滑地移动到另一种状态。</p><p id="069c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，有时你会希望拥有和你习惯的UIKit一样的功能，允许你在动画完成后更新状态。当你在寻找动画完成后获得回调的方法时，你会意识到这并不简单。事实上，动画完成处理程序没有内置的API。</p><p id="11c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自定义的<code class="fe lv lw lx ly b">AnimatableModifier</code>实现允许我们在特定属性的动画完成后获得回调。在大多数情况下，这足以构建所需的实现。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b3ee" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">一个示例实现</h1><p id="4cf5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了理解它是如何工作的，我们将从一个简单的示例实现开始，其中我们将一个简单的文本标签的不透明度制作成动画。您可以想象这是您的介绍动画，之后您想要触发导航到不同的视图:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="257c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该视图包含我们的介绍标签，该标签的动画在<code class="fe lv lw lx ly b">onAppear</code>回调中触发。我们使用一个<code class="fe lv lw lx ly b">introTextOpacity</code>值在动画中轻松地将不透明度从0改变到1。</p><p id="94c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该代码还包含我们的最终实现，用于在<code class="fe lv lw lx ly b">introTextOpacity</code>属性动画完成时获得回调。每当此属性的动画结束时，都会调用回调。这是通过定制实现<code class="fe lv lw lx ly b">AnimatableModifier</code>协议实现的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="566b" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用动画修改器触发动画完成</h1><p id="bb14" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了在<code class="fe lv lw lx ly b">withAnimation</code>触发的动画完成时获得回调，我们必须实现<code class="fe lv lw lx ly b">AnimatableModifier</code>协议的自定义实现。</p><p id="2d2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AnimatableModifier</code>协议要求实现<code class="fe lv lw lx ly b">ViewModifier</code>和<code class="fe lv lw lx ly b">Animatable</code>协议，并且可以调整视图的动画方式。它还要求我们通过<code class="fe lv lw lx ly b">animatableData</code>属性返回动画数据，我们将用它来验证动画是否完成。</p><p id="0fec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这是如何工作的，我将分享动画修改器的最终代码实现(我将在后面解释):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="07af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">AnimationCompletionObserverModifier</code>采用符合<code class="fe lv lw lx ly b">VectorArithmetic</code>协议的通用动画属性。需要这种类型来确保输入实际上是可动画化的，并且我们没有观察到永远不会动画化的东西。</p><p id="2ea9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的身体只是回到了最初的视角。这是因为我们不是真的在制作动画，而是在观察一个属性的动画。</p><p id="b781" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可能很难理解，所以让我们一步一步地分解它:</p><ol class=""><li id="1974" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated">当视图初始化时，动画修改器被实例化。</li><li id="b5f5" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">它将我们的动画属性作为输入，该属性最初被设置为初始值。在我们的例子中，这将是0的不透明度值。</li><li id="cf6a" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">当动画开始时，我们的动画修改器将被结果值实例化。在我们的例子中，这是1。</li><li id="535c" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">此时<code class="fe lv lw lx ly b">animatableData</code>和<code class="fe lv lw lx ly b">targetValue</code>都被设置为1，但是<code class="fe lv lw lx ly b">didSet</code>回调不是由<code class="fe lv lw lx ly b">init</code>方法触发的。换句话说，我们的<code class="fe lv lw lx ly b">notifyCompletionIfFinished</code>还没有调用。</li><li id="4180" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated">一旦动画出现，动画数据属性将更新为旧值。在我们的例子中，这意味着它被更新为0。这也将触发<code class="fe lv lw lx ly b">didSet</code>和<code class="fe lv lw lx ly b">notifyCompletionIfFinished</code>方法，这将导致负匹配。</li><li id="fcb5" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">notifyCompletionIfFinished</code>方法继续验证输入值是否与我们预期的结果匹配，如果匹配，它触发完成回调。</li></ol><p id="e07c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的魔法都发生在<code class="fe lv lw lx ly b">animatableData</code>属性内部。在制作动画时，SwiftUI使用该属性将旧的输入值更改为新的目标值。该值将被设置为旧值，直到动画完成。</p><p id="bf42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">换句话说，一旦动画完成，它将符合我们的预期结果。这正是我们如何知道一个动画是完整的。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="264c" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建一个视图扩展来访问完成回调</h1><p id="e9ec" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">建议您为自定义修饰符编写自己的视图扩展方法，因为这只会提高自定义修饰符的可读性。在我们的例子中，这意味着我们需要编写一个方法来设置动画监视器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="d2b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法将以动画形式显示的属性作为输入，并要求传入完成回调。</p><p id="6521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此方法的一个实现示例如下:</p><pre class="kj kk kl km gt nt ly nu nv aw nw bi"><span id="7c08" class="nx mh it ly b gy ny nz l oa ob">Text("Welcome to SwiftLee")<br/>    .opacity(introTextOpacity)<br/>    .onAnimationCompleted(for: introTextOpacity) {<br/>        print("Intro text animated in!")<br/>    }</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0b50" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="0929" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">SwiftUI中的动画是通过<code class="fe lv lw lx ly b">withAnimation</code>和<code class="fe lv lw lx ly b">animation(...)</code>这样的方法触发的。默认情况下，动画完成时不可能得到回调。自定义动画修改器允许我们构建一个自定义解决方案，一旦某个属性的动画完成就触发回调。</p><p id="dab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>