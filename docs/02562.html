<html>
<head>
<title>How To Start Using .map() .filter() and .reduce()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何开始使用？地图()。过滤器()和。减少()</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-start-using-map-filter-and-reduce-e01edba0d81?source=collection_archive---------3-----------------------#2019-12-09">https://betterprogramming.pub/how-to-start-using-map-filter-and-reduce-e01edba0d81?source=collection_archive---------3-----------------------#2019-12-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7f3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一个不假设你是开发者的解释</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4e0dd9c0e59c248a5c5345d466a81b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IwI3UFT8BmTwyY9k_vcbg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@helloquence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">hello queue</a>在<a class="ae ky" href="https://unsplash.com/s/photos/sales-tax?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="66d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我学会如何使用<code class="fe lv lw lx ly b">.map()</code>、<code class="fe lv lw lx ly b">.filter()</code>和<code class="fe lv lw lx ly b">.reduce()</code>时，我读到的、看到的、听到的一切听起来都很复杂。这些概念是作为独立的实现来教授的，我无法理解。</p><p id="a34b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我听说这些是象征着进入启蒙的提升的门户概念。我希望有人告诉我真相:这三个方法是识别和实现，你循环遍历一个iterable的原因通常属于三个功能类别中的一个。</p><p id="cb77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回顾我以前编写的代码，我意识到在95%的时间里，当循环字符串或数组时，我会执行下列操作之一:<strong class="lb iu">将一系列语句映射到每个值，<strong class="lb iu">过滤满足特定标准的值，或者<strong class="lb iu">将数据集缩减为单个聚合值。</strong></strong></strong></p><p id="dc12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我的突破时刻。映射，过滤和减少每一个简单地执行这些任务之一！</p><p id="cc54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了实践，我用这些方法重构了我的旧代码。那非常有帮助。</p><p id="7d8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以事不宜迟，我们继续吧。我们将解释每个方法，然后将常见的<code class="fe lv lw lx ly b">for</code>循环实现转换成它们各自的方法。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6959" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">地图</h1><p id="2982" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">.map()</code>方法是在你想1。用iterable中的每个值和2执行一组语句。返回(大概)修改后的值。</p><p id="8b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个简单的例子来计算一系列价格的销售税。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="33b5" class="nh mh it ly b gy ni nj l nk nl">const prices = [19.99, 4.95, 25, 3.50];<br/>let new_prices = [];</span><span id="6d64" class="nh mh it ly b gy nm nj l nk nl">for(let i=0; i &lt; prices.length; i++) {<br/>   new_prices.push(prices[i] * 1.06);<br/>}</span></pre><p id="dfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用<code class="fe lv lw lx ly b">.map()</code>获得相同的结果:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="bc33" class="nh mh it ly b gy ni nj l nk nl">const prices = [19.99, 4.95, 25, 3.50];</span><span id="3eb9" class="nh mh it ly b gy nm nj l nk nl">let new_prices = prices.map(price =&gt; price * 1.06);</span></pre><p id="8c09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的语法是精简的，所以让我们浏览一下。<code class="fe lv lw lx ly b">.map()</code>方法接受回调，这可以看作是一个函数。这就是括号中的内容。</p><p id="cbdd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">变量<code class="fe lv lw lx ly b">price</code>是用于标识每个值的名称。因为只有一个输入，我们可以省略参数周围通常的括号。</p><p id="1ddb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">箭头<code class="fe lv lw lx ly b">=&gt;</code>后的语句是我们回调的主体。由于主体只有一条语句，我们可以省略花括号和关键字<code class="fe lv lw lx ly b">return</code>。</p><p id="91ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以防这仍然令人困惑，让我们完整地写出来以供参考:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d24c" class="nh mh it ly b gy ni nj l nk nl">const prices = [19.99, 4.95, 25, 3.50];</span><span id="6f36" class="nh mh it ly b gy nm nj l nk nl">let new_prices = prices.map((price) =&gt; {<br/>   return price * 1.06<br/>});</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="b26e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">过滤器</h1><p id="14c0" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">接下来是<code class="fe lv lw lx ly b">.filter()</code>方法，当您想要从iterable中提取值的子集时会用到这个方法。当使用<code class="fe lv lw lx ly b">.filter()</code>时，记住我们是在过滤值，而不是过滤掉。这意味着iterable中评估为true的每个项目都将包含在过滤器中。</p><p id="f7e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们用一个只保存奇数的例子。我们使用模数运算符来计算除以2的余数。当余数等于1时，我们知道这个数是奇数。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="102f" class="nh mh it ly b gy ni nj l nk nl">const numbers = [1,2,3,4,5,6,7,8];<br/>let odds = [];</span><span id="eef7" class="nh mh it ly b gy nm nj l nk nl">for(let i=0; i &lt; numbers.length; i++) {<br/>   if(numbers[i] % 2 == 1) {<br/>      odds.push(numbers[i]);<br/>   }<br/>}</span></pre><p id="56d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似于<code class="fe lv lw lx ly b">.map()</code>方法，<code class="fe lv lw lx ly b">.filter()</code>接受一个回调，iterable中的每个值都将被传递到这个回调。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="08b8" class="nh mh it ly b gy ni nj l nk nl">const numbers = [1,2,3,4,5,6,7,8];</span><span id="0ead" class="nh mh it ly b gy nm nj l nk nl">let odds = numbers.filter(num =&gt; num % 2);</span></pre><p id="edd4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类似的规则也适用于此回调。因为只有一个输入，函数的主体是一个表达式，我们可以省略参数列表括号、定义主体的花括号和<code class="fe lv lw lx ly b">return</code>关键字。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="639a" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">减少</h1><p id="60bf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">最后，我们来到<code class="fe lv lw lx ly b">.reduce()</code>，不可否认，这是三种方法中最令人困惑的。该方法的名称是指将多个值减少到一个。然而，我发现更容易认为它是建立而不是减少。</p><p id="18d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该方法通过定义起始点来工作。当该方法迭代每个值时，该起始点被修改并向下传递。</p><p id="15d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个将一系列数字相加的经典案例。假设我们正在计算给你最喜欢的慈善机构的捐款总额:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a807" class="nh mh it ly b gy ni nj l nk nl">const donations = [5, 20, 100, 80, 75];<br/>let total = 0;</span><span id="16ba" class="nh mh it ly b gy nm nj l nk nl">for(let i=0; i &lt; donations.length; i++) {<br/>   total += donations[i];<br/>}</span></pre><p id="09f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与<code class="fe lv lw lx ly b">.map()</code>和<code class="fe lv lw lx ly b">.filter()</code>不同，<code class="fe lv lw lx ly b">.reduce()</code>方法的回调需要两个参数:累加器和当前值。累加器将是第一个参数，是“向下传递”的值。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="f275" class="nh mh it ly b gy ni nj l nk nl">const donations = [5, 20, 100, 80, 75];</span><span id="217d" class="nh mh it ly b gy nm nj l nk nl">let total = donations.reduce((total,donation) =&gt; {<br/>   return total + donation;<br/>});</span></pre><p id="3067" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们也可以将第二个参数传递给<code class="fe lv lw lx ly b">.reduce()</code>方法本身。这将作为累加器的起始值。假设我们将昨天总计450美元的捐款相加。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="3f6c" class="nh mh it ly b gy ni nj l nk nl">const donations = [5, 20, 100, 80, 75];</span><span id="0fe6" class="nh mh it ly b gy nm nj l nk nl">let total = donations.reduce((total,donation) =&gt; {<br/>   return total + donation;<br/>}, 450);</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="c162" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是了。这些方法不吓人！可以把它们看作是让你的代码更具可读性。您正在编写更精简的代码，但更重要的是，您实际上是在描述您的循环的意图。</p><p id="4939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">三个月后，当你回头看你的代码时，你会觉得读起来容易多了。您可以看到map/filter/reduce，并开始了解该块试图实现什么，而不必阅读for循环中的语句，只是为了理解它的高级意图。</p></div></div>    
</body>
</html>