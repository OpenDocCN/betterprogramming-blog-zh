<html>
<head>
<title>A Quick Performance Optimization Guide Using PHP Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PHP生成器的快速性能优化指南</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/a-quick-performance-optimization-example-using-php-generators-9e71aac810e0?source=collection_archive---------0-----------------------#2022-04-10">https://betterprogramming.pub/a-quick-performance-optimization-example-using-php-generators-9e71aac810e0?source=collection_archive---------0-----------------------#2022-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ab81" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用生成器减少执行时间和内存使用</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3d96ece3e31258bb91abcfd279205626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6T9iMU-LduxcU5SHTBTo-A.jpeg"/></div></div></figure><p id="0b8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">来自PHP官方网站:</p><blockquote class="ln lo lp"><p id="4586" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">生成器提供了一种简单的方法来实现简单的<a class="ae lu" href="https://www.php.net/manual/en/language.oop5.iterations.php" rel="noopener ugc nofollow" target="_blank">迭代器</a>，而没有实现实现<a class="ae lu" href="https://www.php.net/manual/en/class.iterator.php" rel="noopener ugc nofollow" target="_blank">迭代器</a>接口的类的开销或复杂性。</p><p id="2c66" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated">生成器允许您编写使用<a class="ae lu" href="https://www.php.net/manual/en/control-structures.foreach.php" rel="noopener ugc nofollow" target="_blank"><em class="iq">foreach</em></a><em class="iq"/>来迭代一组数据的代码，而无需在内存中构建数组，这可能会导致您超出内存限制，或者需要大量的处理时间来生成。相反，您可以编写一个生成器函数，它与普通的<a class="ae lu" href="https://www.php.net/manual/en/functions.user-defined.php" rel="noopener ugc nofollow" target="_blank">函数</a>相同，除了不是<a class="ae lu" href="https://www.php.net/manual/en/functions.returning-values.php" rel="noopener ugc nofollow" target="_blank">返回</a>一次，而是生成器可以根据需要<a class="ae lu" href="https://www.php.net/manual/en/language.generators.syntax.php#control-structures.yield" rel="noopener ugc nofollow" target="_blank">产生</a>多次，以便提供要迭代的值。</p></blockquote><h1 id="91b3" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">使用生成器减少内存使用</h1><p id="2f0d" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">让我们举下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6a98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个简单的脚本使用一个<code class="fe mu mv mw mx b">foreach</code> <em class="lq"> </em>循环来计算从0到<code class="fe mu mv mw mx b">THRESHOLD</code>的所有数字的总和。此外，我还包含了一个内存使用打印函数，在遍历执行期间和结束时，在循环结束后调用一次。</p><p id="cfb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于第一个版本，这些是我在尝试不同的<code class="fe mu mv mw mx b">THRESHOLD</code>时得到的值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="180d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当生成整数数组时，它被临时存储，直到<code class="fe mu mv mw mx b">foreach</code>循环执行完成。这解释了为什么当我们增加<code class="fe mu mv mw mx b">THRESHOLD</code>值(我们增加数组大小)时，内存使用在数组遍历期间会增加。然而，这似乎对脚本结尾的内存使用没有影响。</p><p id="9e1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们修改一下<em class="lq"> myIntegers </em>函数，以便利用PHP生成器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0048" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过利用PHP生成器，事情是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d3db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当使用生成器时，PHP只跟踪遍历的当前状态(我们用<code class="fe mu mv mw mx b">yield</code>返回的值)，而不需要存储被遍历的整个集合。因此，循环执行期间的内存使用比第一种方法低得多。</p><h1 id="0466" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated"><strong class="ak">用生成器减少执行时间</strong></h1><p id="09f9" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">对于第二个示例，让我们来看看下面的代码片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="35b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个简单的脚本遍历一个项目数组，每个项目需要2秒钟的时间来获取(因此，模拟一个场景，我们从一个远程资源，例如一个外部文件或API获取项目)。我包含了两个不同的计时器来测量我们应该等待的时间，直到第一个项目在循环中可用，以及总的执行时间。</p><p id="b3df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于第一种方法，由于PHP将在进入<code class="fe mu mv mw mx b">foreach</code>循环之前收集所有项目，我们将不得不等待6秒。直到第一个项目准备好在循环中使用。这与获取所有项目所花费的时间相同:在获取所有项目之前，我们无法开始处理第一个项目。当然，总执行时间也是6秒。</p><p id="2024" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过使用一个简单的生成器向<code class="fe mu mv mw mx b">foreach</code>循环提供每个项目，我们可以在仅仅2秒钟内准备好第一个项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="fed1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个例子的有趣之处在于，它允许您从正在遍历的集合的第N项开始工作，而不必担心第(N+1)项。当然，可能有一些用例需要处理第(N+1)或第(N-1)项以及第N项，对于这些场景，可能需要进一步的分析。</p><pre class="kg kh ki kj gt my mx mz na aw nb bi"><span id="e1c4" class="nc lw iq mx b gy nd ne l nf ng">&gt;php test.php<br/>Took 6 seconds to get the 1st item<br/>Execution finished in 6 seconds<br/>&gt;<br/>&gt;php test_2nd_approach.php<br/>Took 2 seconds to get the 1st item<br/>Execution finished in 6 seconds</span></pre><p id="b1ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们假设我们可以在依赖于该项的特定条件下停止迭代，就像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4b66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过对两个版本执行这段代码(在开始循环之前获取所有项目，而不是按需一次获取一个项目),我们得到:</p><pre class="kg kh ki kj gt my mx mz na aw nb bi"><span id="2a5c" class="nc lw iq mx b gy nd ne l nf ng">&gt;php test.php<br/>Took 6 seconds to get the 1st item<br/>Execution finished in 6 seconds<br/>&gt;<br/>&gt;php test_2nd_approach.php<br/>Took 2 seconds to get the 1st item<br/>Execution finished in 4 seconds</span></pre><p id="f8f1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，第一种方法在开始循环之前必须等待每个项目被获取，而第二种方法引入了“按需”行为模式。因此，记住“cat”项是items集合中的第二项，一旦满足条件并且<code class="fe mu mv mw mx b">foreach</code>循环中断，就不需要获取第三项，这使得脚本在最终执行时间上节省了2秒。</p><h1 id="8764" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="2aec" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">PHP生成器是一个强大的特性，已经证明它在性能和优化改进方面非常有用。它们不仅允许我们减少内存使用，还可以帮助我们处理缓慢的算法和执行时间相关的问题。</p><p id="2f6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然本文没有涉及，但是当使用迭代器和创建自己的迭代器扩展时，您应该能够从生成器中获得同样的好处。迭代器是一种更面向对象的选择，通常意味着通过实现所有的<em class="lq">迭代器接口</em>的方法来创建一个更复杂的解决方案。</p><p id="b29c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在一些特殊的场景中，应用生成器可能会很棘手，并且可能会导致更复杂的实现。这些例子包括当遍历集合时，必须访问第N个项目以及第(N+1)个或第(N-1)个项目；或者必须处理在同一集合上迭代的嵌套循环。我建议从实现解决方案时最简单的方法开始。</p><p id="c3ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，一旦你做了一些测量，你肯定有性能问题，尝试应用生成器和/或其他可能有效的替代方法，以重构的形式。不要试图开始使用生成器作为第一种方法，因为事情可能会变得复杂，代码本身可能会隐藏其真实意图。</p></div></div>    
</body>
</html>