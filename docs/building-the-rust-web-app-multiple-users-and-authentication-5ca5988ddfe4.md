# 构建 Rust Web 应用程序—多用户和身份验证

> 原文：<https://betterprogramming.pub/building-the-rust-web-app-multiple-users-and-authentication-5ca5988ddfe4>

## 创建存储密码的安全方式

![](img/5e76daee972bb552d2a898dd5c6d4774.png)

Thomas Ciszewski 在 [Unsplash](https://unsplash.com/) 上拍摄的照片|图像高度有所改变

这是关于编写 web 应用程序的系列文章的第五部分。对于这个系列，我们将在 [Rust](https://www.rust-lang.org/learn/get-started) 中编写 web 应用程序，我会向你解释如何自己编写。

但是，如果您不愿意自己编写代码，我已经创建了一个存储库，其中包含了本系列中编写的所有代码。在本系列的每一部分的结尾，我都提交了一个存储库。[在前一部分](https://medium.com/better-programming/building-the-rust-web-app-proper-error-handling-and-return-values-723f1f07f8cd)中，我们给了我们的应用更恰当的错误处理和返回值。在这一部分中，我们处理我们的应用程序不能处理多个用户的事实。

# 最后解决多用户问题

正如我前面提到的，我们的应用程序有一个问题，它只适合一个用户。或者，最起码，每个人都能看到他们添加的其他人的任务。显然，我们不想那样。我们希望每个使用该应用程序的用户都能看到自己的内容。在任何用户添加自己的数据或编辑自己的数据集的应用程序中，我们都必须实现某种系统来考虑多个用户。

由于考虑多用户是一个非常常见的问题，大多数框架都有一些内置的方法来处理它，即使您的框架没有，也有一些处理多用户的常见模式。

Rocket 没有专门验证用户的东西，但它有一个我们一直在使用的功能，叫做[请求保护](https://rocket.rs/v0.4/guide/requests/#request-guards)，它允许我们在数据进入之前验证或验证数据。我们将能够使用它来确保用户在访问或使用某些路由之前登录。

首先，我们需要在数据库中创建一个用户表。为什么？因为我们需要跟踪哪些用户正在使用我们的应用程序，我们需要跟踪他们的密码，以便当他们试图登录时，我们可以验证这个人是他们所说的那个人。而且，每当我们需要在 web 应用程序中保存或跟踪数据时，第一个想法应该是在数据库中为它创建一个表。

您可能想知道将密码存储在我们的数据库中是否安全。简单的回答是肯定的。最长的答案是，这取决于你如何存储密码。许多人这样做是错误的，所以它可能是不安全的。

[这篇文章](https://blog.codinghorror.com/youre-probably-storing-passwords-incorrectly/)讲了很多关于存储密码的问题。关于是否每个网站都应该实现自己的认证，还有一个更大的争论。也许我们应该对所有东西都只有一种认证方式。

然而，这并不是一件容易实现的事情，我们是否应该尝试这样做并没有普遍的一致意见。只看[这篇文章](https://blog.codinghorror.com/the-login-explosion/)里的讨论及其评论。不过那篇文章是 2006 年写的，像 [LastPass](https://www.lastpass.com/) 或者 [1Password](https://1password.com/) 之类的东西基本上解决了这个登录爆炸的问题。

在任何情况下，事实是许多 web 应用程序都有自己的身份验证，所以了解它通常如何工作的一些基础知识是有用的。解决这个问题后，让我们到我们的终端运行以下命令:

```
sea-orm-cli migrate generate create_users_table
```

这将创建一个新的迁移，完成后将创建一个存储用户的表。但是我们首先需要编写一些代码来实现这一点，所以转到`migration/src`中新创建的文件。我们将编写代码来创建一个名为`users`的表，该表有一个 id 和两个文本列:一个存储用户名，一个存储密码。代码如下所示:

完成后，让我们运行`cargo run`来调用这个迁移。之后，转到`entity/src`，创建一个名为`users.rs`的文件。然后，输入以下内容:

最后，进入`entity/src/lib.rs`，生成如下代码:

```
pub mod tasks;
pub mod users;
```

至此，用户的表、迁移和实体都完成了。现在，我们可以致力于实现我们想要的与用户相关的所有特性。正如您所看到的，设置 ORM 是相当痛苦的，但是现在我们有了它，它为我们节省了大量添加新表和新特性的时间。你可以看到，如果你有一个应用程序，最终可能有数百个表，这可能是相当的好处。

无论如何，我们需要为我们的用户写一些东西。我们需要一个返回登录页面的请求、一个返回注册页面的请求、一个创建用户的请求和一个登录用户的请求。然后，当然，在我们完成所有这些之后，我们需要使用请求保护的东西来验证人们，我们需要重写我们当前的请求，只允许我们为特定用户创建、编辑或删除东西。

这是一个很大的数字，但是我们会一步一步地来，我们会看到这个过程中的每一步实际上都没有那么大。

# 注册页面

首先，让我们为注册页面创建前端。创建一个名为`authorization.css`的文件，并添加以下代码:

接下来，在`container.css`中，添加以下代码:

```
* {
    box-sizing: border-box;
}
```

最后，在`templates`中创建一个名为`signup_page.html.tera`的文件，并添加以下代码:

现在，在`main.rs`中，我们添加路线服务模板:

当然，把`signup_page`放在路线里。

# 创建帐户请求

注册页面依赖于以`createaccount`为路径的 post 方法，所以我们必须讨论如何存储我们的用户。在很大程度上，它就像存储任务一样。它们进入表格，当我们需要表格中的信息时，我们从表格中读取。然而，我们需要更加安全地存储用户密码，因为如果有人获得了我们数据库的访问权限，我们不希望他们能够轻易登录其他人的帐户。

我们也不希望这些坏演员确定某人的密码是什么，因为人们经常对多个网站使用同一个密码。

因此，当我们存储用户的密码时，我们不只是以纯文本的形式存储它。相反，我们使用散列或加密函数将密码转换成可读性差得多的字符串。希望散列函数是不可逆的，所以拥有散列的人不能确定是什么输入创建了散列。这意味着用户的密码在很大程度上是安全的，即使有不良行为者访问了我们的数据库。

如果我们有一个随机的字符串，我们如何确定输入了正确的密码？我们简单地散列输入密码，并查看输入密码的散列是否与我们手头的散列匹配。因此，一切都是安全的，但人们仍然可以创建和登录帐户。

关于加密和散列还有很多内容，以及围绕它的所有细节，但就我们的目的而言，我们只需要知道加密函数的存在以及我们如何使用它们。对于我们的项目，我们将使用一个名为 [Argon2](https://github.com/P-H-C/phc-winner-argon2) 的密码散列函数。具体来说，我们将使用[这个为 Rust 创建的实现](https://docs.rs/rust-argon2/latest/argon2/)。因此，在根目录`Cargo.toml`中，将下面一行放在 dependencies 下:

```
rust-argon2 = "1.0"
```

现在，在`main.rs`的顶部，放入下面一行代码:

```
extern crate argon2;
```

在`users`实体中，添加下面一行代码:

```
pub const USER_PASSWORD_SALT: &[u8] = b"some_random_salt";
```

我们需要一个“盐”来让我们的散列函数工作。理想情况下，这种盐是安全的，不要放在一个地方，它将进入公共仓库。所以，我知道我在实体中放盐对于一个真实的项目来说不是一个好主意，但是对于现在的讨论来说，进入为我们的应用程序安全地存储某些数据的细微差别有点太多了(如果你想知道我们如何保守这个秘密，我们只是把它放在一个不放在 GitHub 上的文件中。

然后，对于任何加入该项目的新开发人员，您可以通过一些安全的消息应用程序与他们共享 salt。当然，这不是保密/安全的唯一方法，还有其他更好的方法。

最后，给`main.rs`添加如下功能，如下图所示:

它接收用户给出的用户名和密码，并使用我们的散列函数来存储新用户。当然，我们有 flashes 和重定向来处理成功和错误。它应该看起来很像`add_task`，因为两者都是创作操作。这个只是有几个额外的铃铛和哨子。

最后，在`rocket`登上这条路线，就像我们一直在做的其他事情一样。至此，我们已经创建了注册页面及其相关动作。

# 登录页面

接下来是登录页面！我们将取消注册页面的大部分外观，因此我们甚至不需要创建新的 CSS 文件。只需在`templates`中制作`login_page.html.tera`并输入以下代码:

现在，在`main.rs`中，让我们创建将显示该页面的路线。

您可能已经注意到，登录和注册页面非常相似，我们可以将它们相似的功能打包成函数或模板或其他任何东西。然而，你是否这样做取决于你有多希望这两者看起来一样。

这个例子中的很多代码并不完美或者非常干净，但是它完成了工作。但是，如果您希望将代码清理得更漂亮，请继续！这可能是一个很好的项目，真正想通所有正在做的事情。

无论如何，我们的登录页面现在已经完成了，所以现在我们可以实现验证我们帐户的路由了

# 验证帐户途径

现在，账户的验证应该不会太差。我们使用给我们的`username`在数据库中找到用户，并验证给定的密码是否与数据库中的密码匹配。没有任何帮助函数，我们只是散列给定的密码，然后比较给定的密码和存储的密码。

然而，Argon2 库提供了一种验证密码的方法，所以我们将使用它。如果密码不正确，我们将使用 flash 告诉用户。如果密码是正确的，我们用认证用户的 id 设置一个 cookie，并使用 flash 告诉用户他们已经成功登录。

不过，我们需要给 Rocket 添加`secrets`特性来附加私有 cookies，所以请转到`Cargo.toml`中的`dependencies.rocket`块，将其修改为如下所示:

```
[dependencies.rocket]
version = "0.5.0-rc.2"
features = ["json", "secrets"]
```

这样一来，我们现在可以将以下代码添加到`main.rs`中:

如您所见，我们的大部分代码都是为了找到用户，并在出错时返回适当的错误。只有底层才真正关心验证密码。这是相当混乱的代码，一旦一切都结束了，我们会做一些清理工作，但是我们还有一些认证的事情要做。

# 使用我们的帐户验证

现在我们已经设置了 cookie 并验证了我们的帐户，我们将创建一个请求防护来确保我们的帐户在进入某些路由时得到验证。就 Rocket 而言，请求守卫只是允许我们对我们附加的任何请求执行一些任意的验证。

在这里，我们将验证一个`user_id` cookie 是否被附加到请求中。

这并不完美。理想情况下，存储在我们 cookie 中的数据会告诉我们比用户验证的`id`更多的信息。它还会告诉我们用户何时登录、cookie 的有效期以及其他细节。手头有这些信息可以让我们做出决定，使我们的网站更加安全。除此之外，如果我们设置的 cookie 比简单的 id 更复杂，那么坏演员就更难伪造。JSON 网络令牌，或者 JWT，做一些完全一样的事情。

JWT 的工作方式是获取一个 JSON 对象并将其编码成一个字符串。然后，如果 JWT 进入后端，我们将把 JWT 解码回 JSON。这样，我们就可以得到我刚才提到的所有信息以及我们想要的任何其他信息。更好的是，这种 JWT 可以被签名，使其更容易相信其有效性，并被加密，使其更难被坏人逆向工程。

因此，在实际的 web 应用程序中，您可能会使用类似 JWT 的东西作为授权 cookie，而不仅仅是使用 ID。(但是，我应该提到，JWT 通常设置在头中，而不是在 cookie 中)

为什么我没有在这个例子中使用类似 JWT 的东西呢？主要是因为它需要我做更多的工作，授权已经是添加到这个项目中的一个大麻烦，我已经写了近 19，000 字关于这个 web 应用程序，并开始厌倦添加额外的功能，特别是因为我们已经接近尾声了。

无论如何，这是一个玩具示例，所以代码有点乱，我所做的选择对于安全性来说并不是很好。更重要的一点是，我所做的很多选择都是在模仿很多 web 应用程序的设计方式。虽然没有一个合格的 web 应用程序会将用户 id 设置为 cookie 并使用它进行验证，但是使用 cookie 来验证传入请求的想法已经被广泛使用。只是，cookie 通常会保存类似 JWT 的东西，而不是 id。

不管怎样，让我们编写请求保护程序。第一个任务是导入一个我们应该早就导入的库，名为`[anyhow](https://docs.rs/anyhow/latest/anyhow/)`。这是一个使 Rust 中的错误处理更加容易的库。注意，如果你打算用 Rust 写一个库，为你的错误做适当的枚举并返回给用户是值得的。

但是，当您为应用程序编写代码时，使用`anyhow`通常是节省复杂性和工作量的更好的主意。尤其是因为我们不需要像大多数时候正确的枚举错误提供的那样多的细节。因此，只需将下面一行添加到您的`Cargo.toml`依赖项中(我们实际上不会广泛使用它，但是我们将在请求保护中将其用于错误类型)

```
anyhow = "1.0"
```

现在，这里是请求保护的代码:

遗憾的是，现在我们不能直接对我们的请求应用请求保护。首先，我们必须更新我们的`tasks`模型和表，以正确地支持多个用户。我们来谈谈吧

# 更新我们的任务

在我们的应用程序中添加用户和身份验证的目的是为了让多人都可以使用它。显然，如果应用程序只是从一个表中添加和删除任务，并向用户显示表中的每个任务，每个人都会看到、编辑、添加和删除同一组任务。我们不想那样。

我们希望用户只能看到他们添加的任务，并且我们希望用户只能添加、编辑或删除他们自己的任务。然而，就像我们现在的`tasks`表一样，没有现实的方法可以做到这一点。没有办法区分哪个用户向表中添加了任务，因为我们只在表中存储了一个`id`和任务本身。

如果你够敏锐，你可能已经知道我们将如何区分它们。我们将在我们的`tasks`表中添加一个`user_id`列，它将为我们提供添加任务的用户的`id`。然后，我们可以找出谁添加了哪些任务，从而使应用程序为多个用户工作。这个`user_id`称为外键，使用外键将表相互关联是关系数据库的核心概念之一。而且，你猜对了，postgres 是一个关系数据库。

您不需要理解代码实际上是如何创建外键的，只要确保您的`create_tasks_table`迁移中的`up`函数如下所示

当然，您需要修改同一个文件中的`Tasks`枚举，使其看起来像这样:

```
#[derive(Iden)]
pub enum Tasks {
    Table,
    Id,
    Item,
    UserId
}
```

接下来，进入`migration/src/lib.rs`并确保`create_users_table`迁移列在`create_tasks_table`迁移之前，如下所示:

有了这个设置，您可以在项目目录下的终端中运行以下命令来修改您的`tasks`表，使其现在有一个用户 id。

```
sea-orm-cli migrate fresh
```

现在，转到我们的`tasks`实体，将其修改为如下所示:

最后，转到您的`users`实体，并确保它看起来如下所示:

解决了这个问题，我们可以回到`main.rs`并修改我们的 CRUD 操作。

# 任务 CRUD 操作

对于每个 CRUD 操作，我们希望修改它们以使用请求保护，并使用从请求保护返回的`user_id`来添加、删除、编辑和查看来自特定用户的任务，而不仅仅是将它们放在一起。此外，如果请求保护失败，我们希望我们的用户被重定向到我们的登录页面，这是额外的带有等级的路由的来源。我将一次完成所有这些，并将它们放入一个大的代码块中，以供您查看，因为这开始变得相当乏味，并且它们都将有非常相似的调整。

当然，要确保所有的路线都被添加到`rocket`功能中。

# 注销功能

现在，我们只需要添加功能来注销我们的应用程序，我们可以将这整个痛苦的授权事情抛在脑后。幸运的是，注销很简单。我们只需要移除验证我们的`cookie`。但首先，我们需要在我们的应用程序中添加一个允许我们注销的按钮。因此，转到`todo_list.html.tera`并在 Todo 列表标题的正上方添加下面的代码片段。

```
<form action="/logout" method="post">
    <button type="submit">Log Out</button>
</form>
```

之后，进入`main.rs`并添加以下代码，确保在`rocket`中注册路线。

这样，你现在应该能够在应用程序中使用多个用户。您应该能够创建多个帐户，登录到他们，进行更改，并发现每个帐户中所做的更改不会影响其他帐户。此外，如果你试图恶意地去任何不是登录或注册页面的路径，你应该被重定向。

但这就是我今天的全部内容。在本系列的下一个也是最后一个部分，我们将清理代码库，并讨论从这里你可以去哪里，比如追求什么资源或项目来增加你的 web 开发知识。

感谢您阅读这篇文章。我希望这个系列能继续帮助你提高你的 web 开发技能，甚至一直到最后。

# 资源

*   [入门— Rust 编程语言(rust-lang.org)](https://www.rust-lang.org/learn/get-started)
*   [本系列的 GitHub 库](https://github.com/garrettudstrand/rust-web-app/tree/main)
*   [总之— Rust (docs.rs)](https://docs.rs/anyhow/latest/anyhow/)
*   [JSON Web 令牌— jwt.io](https://jwt.io/)
*   [请求—火箭编程指南](https://rocket.rs/v0.4/guide/requests/#request-guards)
*   [你可能储存的密码不正确(codinghorror.com)](https://blog.codinghorror.com/youre-probably-storing-passwords-incorrectly/)
*   【codinghorror.com 登陆爆炸(T2)】
*   [#1 密码管理器&带单点登录的 Vault 应用& MFA 解决方案| LastPass](https://www.lastpass.com/)
*   [家庭、企业、团队的密码管理器| 1 密码](https://1password.com/)