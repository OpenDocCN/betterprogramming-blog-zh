<html>
<head>
<title>Lazy Loading Data From Firestore in Real Time Using Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Flutter实时从Firestore惰性加载数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/lazy-loading-data-from-firestore-in-real-time-using-flutter-baa4157462fe?source=collection_archive---------4-----------------------#2020-09-21">https://betterprogramming.pub/lazy-loading-data-from-firestore-in-real-time-using-flutter-baa4157462fe?source=collection_archive---------4-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e07" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过Firestore分页，并实时接收更新</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/71b65846b25c603b6121dbc9b4671340.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rh1whcVx8nRIj5-m.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:作者</p></figure><p id="c29c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从数据库获取数据并显示在列表上是应用程序开发中非常常见的任务。在这样做的时候，一个经常被忽视的关键任务，尤其是新开发人员，是懒惰地加载数据以避免获取整个集合，使你的应用程序变慢并增加你的账单。</p><p id="82dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用Firestore分页或延迟加载数据相对简单——前提是您只需一次获取文档。当您试图使用流来延迟加载数据以保持数据实时更新时，情况就完全不同了。</p><p id="1d45" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我将教你一种使用Bloc模式实时从Firestore惰性加载数据的技术。如果你对Bloc模式一无所知，我建议你阅读他们的<a class="ae lr" href="https://bloclibrary.dev/" rel="noopener ugc nofollow" target="_blank">文档</a>来了解它是如何工作的。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="bf3d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">我们正在建造的东西</h1><p id="718d" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们将构建一个简单的应用程序，lazy从Firestore集合中加载帖子，并在<code class="fe mw mx my mz b">ListView</code>上显示它们。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/1756e54378334f375f89d06d42ea1b15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/1*_GQoJlJMvVfmE21Or-rT_A.gif"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="00fb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">项目创建</h1><p id="3236" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">首先创建一个新的颤振项目:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="f5de" class="nf ma iq mz b gy ng nh l ni nj">$ flutter create lazy_loading_demo</span><span id="a869" class="nf ma iq mz b gy nk nh l ni nj">$ cd lazy_loading_demo</span></pre><p id="02e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下依赖项添加到您的<code class="fe mw mx my mz b">pubspec.yaml</code>:</p><pre class="kg kh ki kj gt nb mz nc nd aw ne bi"><span id="de2e" class="nf ma iq mz b gy ng nh l ni nj">firebase_core: ^0.5.0<br/>cloud_firestore: ^0.14.0+2<br/>flutter_bloc: ^6.0.5<br/>equatable: ^1.2.5</span></pre><p id="5137" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">接下来，转到Firebase控制台，创建一个新项目。创建项目后，启用Firestore，并按照说明将其添加到您的应用程序中。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="60ec" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发布存储库</h1><p id="2cd6" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们需要创建一个存储库，我们的Bloc可以用它从Firestore获取数据。创建一个名为<code class="fe mw mx my mz b">supplemental</code>的新文件夹，然后在里面创建<code class="fe mw mx my mz b">post_repository.dart</code>。添加以下代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单1</p></figure><p id="24cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们有了一个简单的存储库，可以用来获取数据。代码相对容易理解:<code class="fe mw mx my mz b">getPosts</code>返回包含<code class="fe mw mx my mz b">posts</code>集合的前15个文档的流。从集合中返回包含15个文档的流，从我们作为参数传递的文档之后开始。</p><p id="5a2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们创建了一个单独的存储库；然而，根据您的用例，您可能希望在您的应用程序中使用依赖注入或惰性单例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0200" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发布模型</h1><p id="03f4" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们需要一个模型来表示从数据库中检索到的每个帖子。对于这个例子，下面的类将完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单2</p></figure><p id="d79f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个名为<code class="fe mw mx my mz b">models/post.dart</code>的文件，并将其粘贴到前面的代码中。注意，我们扩展了<code class="fe mw mx my mz b">Equatable</code>，这样我们(和我们的块)可以比较<code class="fe mw mx my mz b">Post</code>的实例。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="88a7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">块实现</h1><p id="ab8e" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">创建一个名为<code class="fe mw mx my mz b">data_bloc</code>的新目录。在那里，创建以下文件:</p><ul class=""><li id="face" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">data_bloc.dart</code></li><li id="d646" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">data_events.dart</code></li><li id="bc27" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">data_state.dart</code></li></ul><p id="aca7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从为我们的块创建事件开始。在文件<code class="fe mw mx my mz b">data_events.dart</code>中，添加以下几行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单3</p></figure><p id="94f2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们创建了一个扩展<code class="fe mw mx my mz b">Equatable</code>的基类，这样我们就可以比较我们的事件。现在我们有了事件所基于的类，让我们定义我们的块应该有哪些事件:</p><ul class=""><li id="2a7b" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">DataEventStart</code>:用于配置我们的集团</li><li id="9d98" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">DataEventLoad</code>:用于通知Bloc新数据可用</li><li id="70a4" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">DataEventFetchMore</code>:用于在用完时获取更多数据</li></ul><p id="9b6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下几行添加到<code class="fe mw mx my mz b">data_events.dart</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单3.1</p></figure><p id="4603" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，让我们定义我们的集团将发出的状态:</p><ul class=""><li id="3d29" class="nn no iq kx b ky kz lb lc le np li nq lm nr lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">DataStateLoading</code>:数据尚未加载时使用</li><li id="b6f2" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">DataStateEmpty</code>:当我们提取的集合中没有文档时使用</li><li id="525f" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><code class="fe mw mx my mz b">DataStateLoadSuccess</code>:成功拉取数据时使用，包含帖子列表</li></ul><p id="a227" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">添加一个<code class="fe mw mx my mz b">DataLoadFailure</code>状态以在出错时发出可能是个好主意。试着自己去实现。</p><p id="5a42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">将以下代码添加到<code class="fe mw mx my mz b">data_state.dart</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单4</p></figure><p id="1a48" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们实现了之前定义的基类和状态。</p><p id="3f44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在是我们团结一致的时候了。将以下内容添加到<code class="fe mw mx my mz b">data_bloc.dart</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单5</p></figure><p id="acc2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大部分代码非常简单。当块接收到<code class="fe mw mx my mz b">DataEventStart</code>时，它重置类变量并取消流订阅。然后，它通过从我们的<code class="fe mw mx my mz b">PostRepository</code>请求来创建第一个订阅，并让<code class="fe mw mx my mz b">handleStreamEvent</code>(我们接下来将实现这个方法)处理从流接收的事件。</p><p id="a04b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们的块接收到一个<code class="fe mw mx my mz b">DataEventLoad</code>事件时，它首先展平帖子列表，然后检查它是否为空，并返回<code class="fe mw mx my mz b">DataStateLoadSuccess</code>或<code class="fe mw mx my mz b">DataStateEmpty</code>。</p><p id="0dbe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的最后一个事件<code class="fe mw mx my mz b">DataEventFetchMore</code>，从我们的<code class="fe mw mx my mz b">PostRepository</code>请求一个新的数据页面，并将流订阅添加到我们的订阅列表中。</p><p id="4552" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经完成了大部分的程序块，让我们来实现<code class="fe mw mx my mz b">handleStreamEvent</code>方法。将以下内容复制到您的块中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="74d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">方法比看起来简单。它有两个参数，一个是调用它的流(在<code class="fe mw mx my mz b">posts</code>列表中作为它的<code class="fe mw mx my mz b">index</code>传递)，另一个是从流接收的事件作为<code class="fe mw mx my mz b">QuerySnapshot</code>。</p><p id="18cb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当被调用时，该方法首先检查收到的<code class="fe mw mx my mz b">QuerySnapshot</code>的长度。我们一次请求15个文档，所以如果我们得到的少于这个数量，这意味着我们已经到达集合的末尾。</p><p id="c7c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后检查它是否正在处理列表中最后一个订阅的事件，如果是这样，它将变量<code class="fe mw mx my mz b">lastDoc</code>设置为查询快照中的最后一个文档。</p><p id="c3e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，它更新了<code class="fe mw mx my mz b">posts</code>列表并将<code class="fe mw mx my mz b">DataEventLoad</code>添加到我们的块中。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="6508" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">用户界面</h1><p id="8c79" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">既然我们有了一个延迟加载数据的机制，那么是时候创建一个UI来测试它了。用名为<code class="fe mw mx my mz b">lazy_list.dart</code>的文件为您的UI创建一个新目录。在那里，添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单6</p></figure><p id="db72" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">UI的实现非常简单。我们用一个<code class="fe mw mx my mz b">BlocBuilder</code>返回一个<code class="fe mw mx my mz b">Scaffold</code>，它处理Bloc可以发出的所有状态。</p><p id="14be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果帖子加载成功，它返回一个<code class="fe mw mx my mz b">ListView</code>，如果<code class="fe mw mx my mz b">hasMoreItems</code>为<code class="fe mw mx my mz b">true</code>，它会有一个额外的条目。在列表生成器中，如果当前索引大于或等于后列表长度，它会将<code class="fe mw mx my mz b">DataEventFetchMore</code>添加到块中，同时显示一个<code class="fe mw mx my mz b">CircularProgressIndicator</code>。最后，我们关闭了<code class="fe mw mx my mz b">dispose()</code>方法上的程序块。</p><p id="d1ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一件事，修改您的<code class="fe mw mx my mz b">main.dart</code>以包含下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nm l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">清单7</p></figure><p id="2005" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们只是初始化Firebase并将<code class="fe mw mx my mz b">LazyListScreen</code>设置为主屏幕。我们调用<code class="fe mw mx my mz b">WidgetsFlutterBinding.ensureInitialized()</code>，这样我们就可以在我们的主函数中调用Firebase核心插件。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="55f9" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="c9fe" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le mt lg lh li mu lk ll lm mv lo lp lq ij bi translated">我们已经成功地实现了一个延迟加载列表。这是一个非常简单的实现，您可以在其上构建；在一个真实的应用程序中，您可能想使用<code class="fe mw mx my mz b">BlocProvider</code>将块注入到UI中，或者修改这个例子来满足您的需求。还可以采用不同的方法来实现这种行为——这里使用的方法是我能想到的最简单的方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f33a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">资源</h1><ul class=""><li id="cdfd" class="nn no iq kx b ky mr lb ms le ob li oc lm od lq ns nt nu nv bi translated"><a class="ae lr" href="https://firebase.flutter.dev/docs/overview" rel="noopener ugc nofollow" target="_blank">扑火文件</a></li><li id="c63f" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://bloclibrary.dev/#/gettingstarted" rel="noopener ugc nofollow" target="_blank">阻止库文档</a></li><li id="f19d" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://firebase.google.com/docs" rel="noopener ugc nofollow" target="_blank"> Firebase文档</a></li><li id="7e7d" class="nn no iq kx b ky nw lb nx le ny li nz lm oa lq ns nt nu nv bi translated"><a class="ae lr" href="https://github.com/sofferjacob/lazy-loading-demo" rel="noopener ugc nofollow" target="_blank">该项目的源代码</a></li></ul></div></div>    
</body>
</html>