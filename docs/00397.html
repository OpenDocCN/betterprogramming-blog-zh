<html>
<head>
<title>Iteration versus Recursion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的迭代与递归</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/javascript-iteration-v-s-recursion-and-behind-the-scene-e12fe1756343?source=collection_archive---------2-----------------------#2019-05-13">https://betterprogramming.pub/javascript-iteration-v-s-recursion-and-behind-the-scene-e12fe1756343?source=collection_archive---------2-----------------------#2019-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fd29" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><strong class="ak"> <em class="ki">幕后观察差异以及如何做出正确决定使用</em> </strong></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/5435c81bca66911adb7a8010603570c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wb_8MAZhxH0JmZV8"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine ivani</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><h1 id="1638" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated"><strong class="ak"> <em class="ki">迭代</em> </strong></h1><p id="0987" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">控制流中最重要的工具之一是迭代语句的使用。这些迭代语句通常以下列形式出现:</p><ul class=""><li id="ac07" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated"><strong class="lu iu">用于声明</strong></li><li id="a749" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><strong class="lu iu"> for in语句</strong></li><li id="d2f0" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><strong class="lu iu"> for of语句</strong></li><li id="e1cc" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><strong class="lu iu"> while语句</strong></li><li id="7bcc" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated">do…while语句</li></ul><p id="b9c1" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在这些迭代语句中，“<strong class="lu iu">标签语句</strong>”、“<strong class="lu iu">继续语句</strong>”和“<strong class="lu iu">中断语句</strong>”可以结合使用，以进一步控制循环行为。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nh"><img src="../Images/6da7c81f5a99bea63915770894fbba1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r004c8Z0MsnGl6Swg-IBEg.png"/></div></div></figure><p id="2dbb" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">除了上面提到的迭代语句，还有迭代数组方法，例如:</p><ul class=""><li id="6c7c" class="mo mp it lu b lv mq ly mr mb ms mf mt mj mu mn mv mw mx my bi translated"><strong class="lu iu"> forEach </strong></li><li id="2b7a" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><strong class="lu iu">地图</strong></li><li id="8112" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><strong class="lu iu">过滤器</strong></li><li id="d806" class="mo mp it lu b lv mz ly na mb nb mf nc mj nd mn mv mw mx my bi translated"><strong class="lu iu">减少</strong></li></ul><p id="4869" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">这些方法与前面提到的不同之处在于，这些迭代数组方法需要一个回调函数。这是这些迭代数组方法与上面的传统迭代语句在操作方式上的根本区别，当我们在幕后观察时就会看到这一点。</p><h1 id="99a5" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">递归</h1><p id="d6a7" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">现在我们已经了解了什么是迭代，让我们来看看递归以及它们之间的区别。</p><p id="6c72" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">递归描述了递归函数的行为，即调用或调用自身。用于计算阶乘迭代和递归的基本比较如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nh"><img src="../Images/62a87c2d8089f3e7ecb6454138f2f60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vIucHfiroki0PAzZiuBHUg.png"/></div></div></figure><p id="8647" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated"><em class="ni">边注:尾部调用优化(TCO)是由编译器或引擎执行的优化，它允许“循环”继续而不增加堆栈。尽管ES6将TCO作为其新标准的一部分，但所有主流浏览器在实现它的过程中都经历了坎坷，到目前为止，它一直处于不确定状态。也就是说，最好记住如何转换一个以降低总拥有成本。看看</em> <a class="ae kz" href="https://stackoverflow.com/questions/54719548/tail-call-optimization-implementation-in-javascript-engines" rel="noopener ugc nofollow" target="_blank"> <em class="ni">这里的</em> </a> <em class="ni">了解更多关于JavaScript实现历史的细节。</em></p><p id="5481" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">当调用<em class="ni"> recursiveFactorial </em>时，会发生以下情况:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nj"><img src="../Images/5831ec5cf505fb513fe4f79e40170a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MhGT97t9TGTu1lF2VLIvGg.png"/></div></div></figure><p id="3683" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">我们可以看到，除了最初调用<em class="ni"> recursiveFactorial </em>之外，它本身被额外调用了四次，在到达n=== 1的<strong class="lu iu"> <em class="ni">基例</em> </strong>之后，它一路回溯，完成每一次后续计算达到120。</p><p id="46e2" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在深入了解代码之前，让我们具体定义一下递归函数的组件。有两个必要的组件使得递归函数具有理想的功能:递归<strong class="lu iu"><em class="ni"/></strong>和基础用例<strong class="lu iu"><em class="ni"/></strong>。</p><p id="4419" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated"><strong class="lu iu"> <em class="ni">递归</em> </strong>是调用函数的部分，在我们的阶乘示例中是<strong class="lu iu"><em class="ni">recursiveFactorial(n-1)</em></strong>。请注意，函数本身可以在多个地方调用，也可以在同一个表达式中使用不同的参数多次调用。这在技术上足以使一个函数递归，但这是不可取的，因为它会因堆栈溢出错误而崩溃。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nk"><img src="../Images/00485fcb9d566ec20b36f064a758ca07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PTQi1QO0ZwTaF10YNyRVQ.png"/></div></div></figure><p id="2fa9" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated"><strong class="lu iu"> <em class="ni">基本情况</em> </strong>是我们定义停止条件的地方。在我们的阶乘例子中，基例是<strong class="lu iu"><em class="ni">if</em></strong><strong class="lu iu"><em class="ni">(n = = = 1)</em></strong>。请注意，算法需要多少基本情况就有多少。</p><h1 id="987c" class="la lb it bd lc ld le lf lg lh li lj lk jz ll ka lm kc ln kd lo kf lp kg lq lr bi translated">走向幕后</h1><p id="5b73" class="pw-post-body-paragraph ls lt it lu b lv lw ju lx ly lz jx ma mb mc md me mf mg mh mi mj mk ml mm mn im bi translated">首先，我们需要明白JavaScript是一种单线程并发编程语言。这意味着JavaScript一次只做一件事(JavaScript运行时),并且通过与Web APIs、回调队列和事件循环的合作关系，允许调度形式的“多任务”。</p><p id="293e" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">下面展示了JavaScript的不同组件:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nl"><img src="../Images/5a5aaedfd7ca82e402032fc45183312a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRuvQTB-FrdbKXlCFSiZKg.jpeg"/></div></div></figure><p id="3a88" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated"><strong class="lu iu"> JavaScript运行时</strong>或JavaScript引擎(Chrome的V8，FireFox的SpiderMonkey)包含<strong class="lu iu">堆</strong>和<strong class="lu iu">调用栈</strong>。<strong class="lu iu">堆</strong>是一个非结构化的内存区域，在这里为所有变量和对象分配内存。<strong class="lu iu">调用堆栈</strong>是一种数据结构，遵循后进先出(LIFO)系统，跟踪堆栈帧中的函数调用(在上图中用黄色矩形表示),其中包含函数及其参数和局部变量。</p><p id="64d8" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated"><strong class="lu iu">Web API</strong>是浏览器的一部分，包含允许JavaScript以并发方式运行的基本API。例子包括DOM事件，比如点击和滚动事件、AJAX请求和setTimeOut函数。</p><p id="6168" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated"><strong class="lu iu">回调队列</strong>是遵循先进先出(FIFO)系统的数据结构，将Web APIs解析的函数排队。</p><p id="7453" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated"><strong class="lu iu">事件循环</strong>的目的是当调用栈<em class="ni">为空</em>时，从<strong class="lu iu">回调队列</strong>向<strong class="lu iu">调用栈</strong>添加一个队列项。</p><p id="21da" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi">— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="1e55" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">你能看到递归的例子中调用栈是如何变化的吗？：</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nl"><img src="../Images/70457c4045af5fc73d76071de08635df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XRh--Wm4UHn9ftkzNufeVQ.jpeg"/></div></div></figure><p id="edca" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">有了更完整的描述，让我们回到迭代和递归。</p><p id="6bed" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在迭代中，循环依赖于自身。调用堆栈几乎没有变化。然而，在递归中，循环依赖于对自身的重复调用，这因此为每个函数调用向调用堆栈添加了一个堆栈帧。这也意味着要进行大量的删除和添加，这反过来又会因为调用数量的增加而增加运行时的负担。当数据集或输入很小时，迭代和递归在时间上的差别是不明显的，否则，迭代通常表现得更好。</p><p id="0478" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在迭代中出现非常大的循环甚至无限循环的情况下，浏览器选项卡似乎对用户在页面上采取的任何操作都没有反应。这是因为发生在调用堆栈中的循环阻塞了来自回调队列的任何项。也就是说，其他选项卡将正常工作，因为只有那个选项卡的进程被停止。</p><p id="7205" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">在发生足够大的递归的类似情况下，JavaScript实际上会由于堆栈溢出而崩溃。每个浏览器都有一个堆栈限制，如果超过这个限制，就会导致堆栈溢出错误。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><p id="0b13" class="pw-post-body-paragraph ls lt it lu b lv mq ju lx ly mr jx ma mb ne md me mf nf mh mi mj ng ml mm mn im bi translated">通常，迭代可以转换为递归，反之亦然。因此，除了性能之外，在选择使用哪种方法时，还需要考虑可读性和可维护性。递归，由于其算法的本质，往往需要更少的代码行。此外，某些算法通过递归编程比迭代编程更容易理解和直观。最后，在选择要使用的工具和技术时，这完全取决于项目的范围、分配的资源、平台和受众规模等因素。</p></div></div>    
</body>
</html>