<html>
<head>
<title>Solidity Tutorial: All About Data Locations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚实度教程:关于数据位置的所有内容</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/solidity-tutorial-all-about-data-locations-dabd33212471?source=collection_archive---------0-----------------------#2022-07-12">https://betterprogramming.pub/solidity-tutorial-all-about-data-locations-dabd33212471?source=collection_archive---------0-----------------------#2022-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="acc2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解存储、内存和呼叫数据</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4fae876bf99621b58effb146ba6145ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rhv5M1507z2k_-uN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Ant Rozetski 在Unsplash上拍摄的照片</p></figure><blockquote class="kz la lb"><p id="e08c" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">这是一篇冗长、详细、深入的阅读。但是不要害怕。坐下来喝杯咖啡或你最喜欢的饮料。一切都会好的。</p><p id="ec3e" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">请参见下面的“目录”部分，跳转到您感兴趣的部分。</p></blockquote><p id="bd47" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">今天，我们探索一个新的和基本的部分:数据位置。具有挑战性的话题。非常低级，因为它涉及以太坊虚拟机(EVM)的架构。</p><p id="fdad" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是通过类比，我们总能更好地理解复杂的编程概念、架构、智能合约和一般的区块链。</p><p id="8321" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在本文中，如果EVM是一个“巨大的工业工厂”，我们将通过查看它来了解每个数据位置(不要担心，您将在下面看到，我希望我能帮助您理解)。</p><p id="cb29" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然后，我们将进入Solidity代码，学习引用类型的每个数据位置的规则和行为。所有这些都由您可能知道的流行项目的绘图、架构图、代码片段和源代码示例来支持。</p><blockquote class="kz la lb"><p id="5159" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">该子文章系列分为多个部分:</p><p id="749d" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae ky" href="https://jeancvllr.medium.com/all-about-solidity-data-locations-part-i-storage-e50604bfc1ad" rel="noopener"> -第一部分:所有关于存储</a> <br/> <a class="ae ky" href="https://jeancvllr.medium.com/solidity-tutorial-all-about-memory-1e1696d71ee4" rel="noopener"> -第二部分:所有关于内存</a> <br/> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/solidity-tutorial-all-about-calldata-aebbe998a5fc"> -第三部分:所有关于Calldata </a> <br/> <a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/solidity-tutorial-all-about-stack-c1ec6070fe60"> -第四部分:所有关于堆栈</a> <br/> <a class="ae ky" href="https://jeancvllr.medium.com/solidity-tutorial-all-about-code-10889b88632f" rel="noopener"> -第五部分:所有关于代码</a></p></blockquote><h1 id="8bee" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目录</h1><ul class=""><li id="b00d" class="mu mv it lf b lg mw lj mx lz my ma mz mb na ly nb nc nd ne bi translated">介绍</li><li id="b4a7" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">为什么要了解Solidity中的EVM数据位置？</li><li id="7dd2" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">数据位置→概述</li><li id="7097" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">数据位置→规则</li><li id="80d7" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">函数参数的规则</li><li id="106c" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">函数体的规则</li><li id="aae8" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">数据位置→行为</li><li id="f5bd" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">映射的(边缘)情形</li><li id="c2d5" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">结论</li><li id="35b9" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">参考</li></ul></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="63ca" class="mc md it bd me mf nr mh mi mj ns ml mm jz nt ka mo kc nu kd mq kf nv kg ms mt bi translated">介绍</h1><p id="1508" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">作为一个对事业充满热情的人，一个工业炉的建造者和改革者，我的父亲决定送我去工厂工作。</p><p id="f228" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">非常大的！熔化和制造钢铁和铝的工厂(Arcelor Mittal和Constellium)。</p><p id="3991" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">你需要一辆车往返于工厂的不同区域，比如钢铁厂和轧钢厂。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/60a53b468dfb6556e7312722e90be3b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kC4pmvHMtXdmymOX.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://ethereum.stackexchange.com/questions/268/ethereum-block-architecture" rel="noopener ugc nofollow" target="_blank">这是取自StackExchange </a>的以太坊和EVM建筑的代表图</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/ab9402ed6780719791c4436328e1252f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6di35QHcPQwQC4QryDT6TA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">就像EVM建筑的示意图一样，安赛乐米塔尔工厂的道路平面图一开始是很难理解的！</p></figure><p id="8c3b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我还记得的是我第一次进入包含轧机的<a class="ae ky" href="https://www.youtube.com/watch?v=kiyIaKynqsU" rel="noopener ugc nofollow" target="_blank">机库时的反应(看视频链接！).</a>工业炉巨大无比，从一头走到另一头需要几分钟！</p><p id="2d24" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">机库里挤满了其他建筑工人、瓦工、电工、四处移动和行驶的叉车，以及用巨大的机械臂控制机器将东西搬进搬出熔炉的人。</p><p id="9532" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">像我父亲一样，我是一个不同类型的建设者，人们在web3中称之为“建设者”。但是当我回头看这座工厂时，我发现它的内部和EVM的内部有很多相似之处。</p><p id="109f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">材料被储存在许多不同的地方，从架子上拿下来，放进炉子和其他随机的机器里。它们会被融化、加工或处理。</p><h2 id="6cae" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">EVM是一个工业工厂</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/732ac18f1dc30168f4e49e90c8f4c0c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TYrySnXlyW6CwoKH"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@worldsbetweenlines" rel="noopener ugc nofollow" target="_blank">帕特里克·亨利</a>在Unsplash上拍摄的照片</p></figure><p id="2b29" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在我之前的文章<a class="ae ky" href="https://coinsbench.com/solidity-tutorial-all-about-abi-46da8b517e7" rel="noopener ugc nofollow" target="_blank">“关于ABI的一切”</a>中，我提到:“聪明的合同是非常放松的小生命。”</p><p id="c851" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是一旦智能合约被调用，它们就会变得非常活跃！它们的底层逻辑作为字节码运行并被执行。多亏了EVM。</p><p id="55fc" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM从不放松。它在每台运行软件客户端的机器上不断重复运行。这是为了更新区块链的状态并使每个人保持同步。</p><p id="2bac" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">大的工业工厂也是一样。它一周7天，一天24小时不停地运转。门口总是有人，夜班工人在机库里整理东西，卡车进进出出，机器和熔炉在熔化、燃烧和加工更多的材料，</p><p id="4f96" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当您调用智能合约时，EVM运行并执行字节码中的指令集(=操作码)。这些操作码中的一些指令EVM从/向不同的位置读取和写入数据。EVM需要这些多个数据位置来正确完成工作。</p><p id="f55f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在工厂中，工序和材料可以在多个地方找到。</p><ul class=""><li id="8c71" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">叉车从位于工厂专用存储区的高大货架上抓取材料调色板。(又名<strong class="lf iu">存储</strong>)</li><li id="3d6a" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">操作员从控制室控制机器和机器人，将无法通过炉门的大块钢/铝破碎成小块。<strong class="lf iu"> </strong>(又名<strong class="lf iu">内存</strong>)</li><li id="98e1" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">待加工的材料通过运输工具(卡车或船只)运送，装在密封的容器中，在容器中你只能知道/看到内容，但不能触摸。(又名<strong class="lf iu">呼叫数据</strong>)</li><li id="f711" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">多亏了传送带，更多的材料在工厂里被加工和运输。(又名<strong class="lf iu">栈</strong>)</li><li id="58c7" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">最后，工厂有自己的道路交通规则。里面全是路标！(又名<strong class="lf iu">代码</strong>)</li></ul><p id="09a3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">你明白了，就像一个工厂，EVM使用许多不同的区域来计算和处理工作。</p><blockquote class="oq"><p id="8fa5" class="or os it bd ot ou ov ow ox oy oz ly dk translated">EVM就像一个工业工厂。</p></blockquote><h1 id="9029" class="mc md it bd me mf mg mh mi mj mk ml mm jz pa ka mo kc pb kd mq kf pc kg ms mt bi translated">为什么要理解Solidity中的Evm数据位置？</h1><p id="6f2b" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">学习每个数据位置如何工作涉及到学习多种东西，比如<code class="fe pd pe pf pg b">storage</code>、<code class="fe pd pe pf pg b">memory</code>和<code class="fe pd pe pf pg b">calldata</code>的结构和布局，或者“什么可以存储在哪里”</p><p id="9d73" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但最重要的是，它教会了你与它们相关的(气体)成本，以及我所说的可变性/安全性权衡。</p><p id="9b5a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">作为一名Solidity开发人员，对EVM中的数据位置以及如何充分利用它们的良好理解将使您能够:</p><ol class=""><li id="3f39" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly ph nc nd ne bi translated">提高智能合同的性能。</li><li id="0cb4" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">最小化其执行成本(调用其公共或内部函数时使用的gas)。</li><li id="5286" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">加强安全性并防止潜在的错误。</li></ol><h1 id="77b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据位置→概述</h1><p id="7aad" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">本文旨在对这些不同的数据位置给出一个很好的概述，在这些位置可以写入和读取数据。我们将看到一些位置是只读的，不能被写入，而另一些位置是可变的，存储在其中的值可以被编辑。</p><p id="e76b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM处理五个主要数据位置:</p><ul class=""><li id="61cb" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">储存；储备</li><li id="ba3c" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">记忆</li><li id="4843" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">呼叫数据</li><li id="56bc" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">堆</li><li id="0670" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">密码</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pi"><img src="../Images/0570a4fa34f71ba1cb660d7ba30837ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ArLLYlT2O3haZtvvyx4Rcw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">EVM可用数据位置概述(来源:<a class="ae ky" href="https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc" rel="noopener ugc nofollow" target="_blank">Andreas Antonopoulos和Gavin Wood </a>的《掌握以太坊》)。</p></figure><p id="8557" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">主要EVM数据位置的基础知识也在<a class="ae ky" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank">以太坊黄皮书的“9)执行模型&gt;基础知识”一节中有详细说明</a></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pj"><img src="../Images/81ca194cf0d6918db78bbc7771b22301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*B26EqaHZI0sxYu6f3tqawA.png"/></div></div></figure><h2 id="57ca" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">储存；储备</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/db44c856140034f508f57df20236eb03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Er1aK_ICvDes2JbV"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">智能合同仓库相当于工业机库上的货架单元(来源:Unsplash上的<a class="ae ky" href="https://unsplash.com/@petrebels" rel="noopener ugc nofollow" target="_blank">海燕</a></p></figure><p id="5b69" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在以太坊中，特定地址的每个智能契约都有自己的<code class="fe pd pe pf pg b">storage</code>，由一个键值存储组成，将256位字映射到256位字。存储中的数据在函数调用和事务之间保持不变。</p><p id="b9c0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">存储是所有契约状态变量驻留的地方。每个合同都有自己的存储空间。存储在存储器中的变量在函数调用之间保持不变。然而，这种存储使用起来相当昂贵。</p><p id="8972" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因为存储指的是约定存储，所以它指的是永久存储在区块链上的数据。</p><p id="2676" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">您可以对约定存储进行读写。在低级，用于这样做的EVM操作码是<code class="fe pd pe pf pg b">SSTORE</code>和<code class="fe pd pe pf pg b">SLOAD</code>。</p><h2 id="c874" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">记忆</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/abf27d668cdf04a15bb3d63abaf38eb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IcHMhbUJXM0BFVps"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(来源:<a class="ae ky" href="http://Simon Kadula" rel="noopener ugc nofollow" target="_blank">西蒙·卡杜拉</a>在Unsplash上)</p></figure><p id="4d1a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">EVM <code class="fe pd pe pf pg b">memory</code>用于保存临时值，在外部函数调用之间被擦除。不过，用起来比较便宜。</p><p id="b4fd" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在EVM中，记忆是易变的，并且特定于特定合同的上下文(环境)。这意味着当执行上下文从一个合同变为另一个合同时，白板/便笺簿被清除。每次调用新消息时，都会获得一个新清除的内存实例。</p><p id="873a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">因此，内存变量是临时的。它们在对其他契约的外部函数调用之间被擦除。</p><p id="9fa5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">你可以读写EVM存储器。在低级，可用于从/向存储器读取和写入的EVM操作码是<code class="fe pd pe pf pg b">MLOAD</code>、<code class="fe pd pe pf pg b">MSTORE</code>和<code class="fe pd pe pf pg b">MSTORE8</code>。</p><p id="853e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">某些EVM操作码，如<code class="fe pd pe pf pg b">CALL</code>、<code class="fe pd pe pf pg b">DELEGATECALL</code>或<code class="fe pd pe pf pg b">STATICCALL</code>，从EVM存储器中消耗它们的参数。</p><h2 id="6015" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">呼叫数据</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/4070ba5906a9e44c19e49c0c1ee21c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*OWRp77WYxbYL5Em8W9vkpQ.jpeg"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">calldata相当于从船或卡车中取出的容器。这些容器装有送到工厂进行加工的材料。Calldata是只读的。</p></figure><p id="f643" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe pd pe pf pg b">calldata</code>是存放事务数据或外部函数调用参数的地方。这是一个只读数据位置。你不能写它。</p><p id="8e7b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">calldata的行为很像内存，是一个字节可寻址的空间。您必须为要读取的字节数指定一个精确的字节偏移量。</p><p id="7368" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在低层，可用于读取calldata的EVM操作码有<code class="fe pd pe pf pg b">CALLDATALOAD</code>、<code class="fe pd pe pf pg b">CALLDATASIZE</code>和<code class="fe pd pe pf pg b">CALLDATACOPY</code>。</p><h2 id="42e3" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">堆</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/42d53514d3ba9604bba1e2f47e914469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-GttU4-H9V_Idy3j"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(来源:Unsplash上的<a class="ae ky" href="https://unsplash.com/@arnosenoner" rel="noopener ugc nofollow" target="_blank"> Arno Senoner </a></p></figure><p id="0219" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">堆栈用于保存小的局部变量。它几乎可以免费使用(使用非常少量的气体)，但体积有限，只能容纳有限数量的物品。</p><p id="c53c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">堆栈是函数内部创建的大部分局部变量所在的地方。它是EVM的重要组成部分。</p><p id="143a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在低层，可用于操作堆栈的EVM操作码是<code class="fe pd pe pf pg b">PUSH</code>、<code class="fe pd pe pf pg b">POP</code>、<code class="fe pd pe pf pg b">SWAP</code>和<code class="fe pd pe pf pg b">DUP</code>指令。大多数其他EVM操作码从堆栈中使用它(通过将它们从堆栈中取出)并将结果推回到堆栈中。</p><h2 id="920d" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">密码</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fcb383445f5fa35916d48aa61d922a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JF5o3tFSM4OczvUF"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">(来源:<a class="ae ky" href="https://unsplash.com/@waldemarbrandt67w" rel="noopener ugc nofollow" target="_blank">瓦尔德马尔·布兰特</a>在Unsplash上)</p></figure><p id="a1a9" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">代码指的是合同字节码。你只能从合同字节码中读取，不能写入。这通常是你可以在Solidity中找到定义为<code class="fe pd pe pf pg b">constant</code>的变量的地方。大多数EVM操作码从堆栈中消耗它们的参数。</p><p id="37d4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">字节码包含许多关于契约的信息和逻辑，包括调度程序和契约元数据。</p><p id="6699" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在低层，可以用来从智能合约的代码中读取的EVM操作码是<code class="fe pd pe pf pg b">CODESIZE</code>和<code class="fe pd pe pf pg b">CODECOPY</code>。操作码<code class="fe pd pe pf pg b">EXTERNALCODESIZE</code>和<code class="fe pd pe pf pg b">EXTERNALCODECOPY</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/40c9e34958b565ffc370e35dc3bd7422.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*oeSfgoTY45GbyFfhur3PBw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/CJ42/All-About-Solidity/blob/data-locations/articles/Data-Locations.md" rel="noopener ugc nofollow" target="_blank">https://github . com/CJ42/All-About-Solidity/blob/Data-locations/articles/Data-locations . MD</a></p></figure><h1 id="1220" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据位置—规则</h1><h2 id="3e2a" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">变量的默认位置</h2><p id="ec55" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">Solidity语言定义了一些缺省规则，根据定义变量的位置，缺省情况下变量应该位于什么位置。</p><ul class=""><li id="998f" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">变量定义为<code class="fe pd pe pf pg b">constant</code> =合同代码(=字节码)。</li></ul><p id="d5e5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这些变量是不可变的，一旦部署了契约，就不能更改。它们是只读的，可以内联。</p><ul class=""><li id="6698" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">默认情况下，状态变量(在函数外部声明)=在存储中。</li></ul><p id="826d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这些被称为状态变量，因为它们是契约状态的一部分，也是世界状态的一部分。这些变量被永久写入区块链。</p><ul class=""><li id="44b3" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">堆栈中的局部变量(在函数体内声明)。</li></ul><p id="0bb6" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">值类型的变量(例如，<code class="fe pd pe pf pg b">uint256</code>、<code class="fe pd pe pf pg b">bytes8</code>、<code class="fe pd pe pf pg b">address</code>)驻留在堆栈中。</p><p id="f5be" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">大多数情况下，您不需要使用数据位置关键字(storage、memory或calldata)，因为Solidity通过上面解释的默认规则来处理位置。</p><p id="0bd5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是，有时您确实需要使用这些关键字并指定数据位置，也就是说，当处理复杂类型的变量(如函数内部的struct和arrays)时。</p><h2 id="ee66" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">参考类型</h2><p id="80c0" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">对于数组(固定或动态大小的数组，如<code class="fe pd pe pf pg b">uint256[]</code>)、<code class="fe pd pe pf pg b">bytes</code>、<code class="fe pd pe pf pg b">string</code>、struct和mappings，您必须显式地提供存储值的数据区域。这可以是<code class="fe pd pe pf pg b">storage</code>、<code class="fe pd pe pf pg b">memory</code>或<code class="fe pd pe pf pg b">calldata</code>。</p><p id="eb2d" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">通过使用这些关键字之一，您创建了一个<code class="fe pd pe pf pg b">reference</code>类型的变量。这种类型必须比值类型更小心处理。</p><p id="dc0a" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">下一个自然会出现的问题是:</p><blockquote class="oq"><p id="2554" class="or os it bd ot ou ov ow ox oy oz ly dk translated">什么时候使用关键字<strong class="ak">存储</strong>、<strong class="ak">内存、</strong>和<strong class="ak">调用数据</strong>？</p></blockquote><blockquote class="kz la lb"><p id="221d" class="lc ld le lf b lg pm ju li lj pn jx ll lm po lo lp lq pp ls lt lu pq lw lx ly im bi translated">在Solidity 0.5.0之前，当变量作为函数参数传递时，可以不指定复杂类型变量(<em class="it">如动态大小数组</em>)的数据位置。</p></blockquote><p id="06f2" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">您可以在哪里指定数据位置？</strong></p><p id="8bf0" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">只能在函数中的三个位置指定引用变量的数据位置:</p><ul class=""><li id="0de9" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">a)对于参数(=函数定义)</li><li id="a503" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">b)对于函数(=函数体)内部的局部变量</li><li id="8d71" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">c)返回值总是在内存中(=函数定义)。</li></ul><h1 id="b18c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">函数参数的规则</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pr"><img src="../Images/8d66ed0511dea202bcf22e0fd589f31a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*25008Ad5Igy4wtOccnpxdA.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://github.com/CJ42/All-About-Solidity/blob/data-locations/articles/Data-Locations.md#data-location-rules-for-function-parameters" rel="noopener ugc nofollow" target="_blank">https://github . com/CJ42/All-About-Solidity/blob/Data-locations/articles/Data-locations . MD # Data-location-rules-for-function-parameters</a></p></figure><p id="0da4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当<code class="fe pd pe pf pg b">storage</code>用作函数参数的引用时，它是指向契约存储的指针。</p><p id="bf34" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">同样适用于<code class="fe pd pe pf pg b">memory</code>和<code class="fe pd pe pf pg b">calldata</code>。此类关键字创建指向EVM存储器中某个位置的指针，或者来自事务的输入数据字段(= calldata)。</p><h1 id="0e33" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">函数体的规则</h1><p id="22e7" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">在函数内部，可以指定所有三个数据位置，而不管函数的可见性如何。</p><p id="edc4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是，引用类型之间的赋值被绑定到特定的规则。(这里是它变得复杂和“轻微的舌头扭曲！”).</p><ul class=""><li id="b67e" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated"><code class="fe pd pe pf pg b">storage</code>引用:总是可以直接从契约存储器(=状态变量)或通过另一个<code class="fe pd pe pf pg b">storage</code>引用分配一些值，但不能分配给它们<code class="fe pd pe pf pg b">memory</code>或<code class="fe pd pe pf pg b">calldata</code>引用</li><li id="8b8c" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated"><code class="fe pd pe pf pg b">memory</code>引用:可以赋任何东西(直接状态变量，或者<code class="fe pd pe pf pg b">storage</code>、<code class="fe pd pe pf pg b">memory</code>或<code class="fe pd pe pf pg b">calldata</code>引用)。这总是会创建一个副本。</li><li id="f174" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated"><code class="fe pd pe pf pg b">calldata</code>引用:可直接(= tx/消息调用输入)或通过另一个<code class="fe pd pe pf pg b">calldata</code>引用从调用数据中分配一些值，但不能分配给它们一个<code class="fe pd pe pf pg b">storage</code>或<code class="fe pd pe pf pg b">memory</code>引用</li></ul><p id="ca4c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">更简单地说:</p><blockquote class="oq"><p id="44c0" class="or os it bd ot ou ov ow ox oy oz ly dk translated">For memory =我们总是可以复制内存中的任何数据(无论是来自契约的存储还是调用数据)。</p><p id="d8d5" class="or os it bd ot ou ov ow ox oy oz ly dk translated">对于storage和calldata =我们只能分配来自指定数据位置的值(直接或通过相同类型的引用)。</p></blockquote><p id="a49c" class="pw-post-body-paragraph lc ld it lf b lg pm ju li lj pn jx ll lz po lo lp ma pp ls lt mb pq lw lx ly im bi translated">让我们来看看一些真实而实用的可靠性示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/76481c0d98cce4a6e777806507a4fe77.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*RfaMTzv_wHxkkvqRAt16lA.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/76aff85baaa773bac54ba907e6a38efe.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*4Gkr_vZ4UAZfuqh5Tsl93w.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/467e9337c7ffc9bdd028ef3e5ab9609d.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/1*K0aeI63hpZU0oZZ8j0wVDA.png"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="41ad" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><a class="ae ky" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/DataLocationsReferences.sol" rel="noopener ugc nofollow" target="_blank">你可以在这里找到一份作为可靠性合同的摘要。</a></p><h2 id="8bfc" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated"><strong class="ak">内存←状态变量</strong></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="6a3e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当我们将一个状态变量赋给一个<code class="fe pd pe pf pg b">memory</code>引用的变量时，我们基本上是将数据从存储器复制到内存。</p><p id="36be" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">=我们正在写入内存=分配了新的内存。</p><p id="c1ac" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这意味着对变量的任何修改都不会向下传播到协定存储(=协定状态)。</p><p id="5051" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">=不会覆盖合同存储。</p><p id="3624" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">在上面的例子中，运行函数后，状态变量<code class="fe pd pe pf pg b">someData</code>没有改变。</p><h2 id="ba5c" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">状态变量←内存</h2><p id="fee3" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">这是上一个“内存←状态变量”的反例。这个例子可以在Solidity文档部分找到。</p><h2 id="8ebb" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">存储指针</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="ff13" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">当一个<code class="fe pd pe pf pg b">storage</code>变量在一个函数中被创建时，它基本上作为一个存储指针。存储指针只是引用存储中已经分配的数据。</p><p id="7e40" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">您可以重新分配存储指针，使其指向存储中的其他位置。</p><p id="8b7e" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">=引用存储中的一些现有值=不创建新存储</p><p id="a044" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是，我们可以通过直接给查找变量分配一个新值来覆盖契约存储。看一下这个例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="775f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果您随后查询第一个索引<code class="fe pd pe pf pg b">someData</code>，您将获得<code class="fe pd pe pf pg b">1</code>。</p><h2 id="6034" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated"><strong class="ak">内存←存储指针</strong></h2><p id="9c56" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">当我们将一个<code class="fe pd pe pf pg b">storage</code>引用的数据赋给一个<code class="fe pd pe pf pg b">memory</code>引用的变量时，我们是在从存储→内存复制数据。</p><p id="339f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">=我们正在写入内存=分配了新的内存。</p><p id="7e32" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这相当于我们之前讨论的第一种情况“内存←状态变量”,通过存储引用增加了“中间的附加路径”。存储引用将解析为状态变量，然后被复制到内存中。下面是一个建立在前面代码片段基础上的基本示例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="be7f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这里的<code class="fe pd pe pf pg b">copyFromRef</code>是整个数组<code class="fe pd pe pf pg b">someData</code>的副本。通过存储引用<code class="fe pd pe pf pg b">storageRef</code>将数组复制到内存中。</p><p id="507f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">同样在这种情况下，由于我们已经从存储拷贝到内存，所以我们是在操作数据的拷贝，而不是驻留在存储中的实际数据。因此，对<code class="fe pd pe pf pg b">copyFromRef</code>的任何修改都不会传播回合同存储器，也不会修改合同状态。</p><p id="ac61" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为了说明这一点，请将以下合同复制成Remix和:</p><ol class=""><li id="3221" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly ph nc nd ne bi translated">运行功能<code class="fe pd pe pf pg b">test()</code>。</li><li id="1e32" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">读取索引<code class="fe pd pe pf pg b">1</code>处的<code class="fe pd pe pf pg b">someData</code>数组。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="132c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">您将看到在运行该函数后，<code class="fe pd pe pf pg b">someData[1]</code>处的值仍然是<code class="fe pd pe pf pg b">2</code>，并且<code class="fe pd pe pf pg b">12345</code>没有传播回合同存储器。</p><p id="102b" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><strong class="lf iu">调用数据参考</strong></p><p id="7824" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">calldata引用的行为方式与<code class="fe pd pe pf pg b">storage</code>引用相同。它只能作为对事务数据的引用，或者对使用<code class="fe pd pe pf pg b">calldata</code>关键字提供的复杂类型的函数参数的引用。</p><p id="e821" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">简而言之，calldata类型的变量总是创建一个引用。</p><p id="db41" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">唯一的主要区别是不能修改作为<code class="fe pd pe pf pg b">calldata</code>引用的变量，因为calldata是只读的。</p><p id="d809" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这与<code class="fe pd pe pf pg b">storage</code>参考相反。当您给一个<code class="fe pd pe pf pg b">storage</code>引用分配一个新值时，这个变化会传播回契约状态。</p><h1 id="01c5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">数据位置—行为</h1><blockquote class="kz la lb"><p id="9a0a" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated"><a class="ae ky" href="https://medium.com/coinmonks/ethereum-solidity-memory-vs-storage-which-to-use-in-local-functions-72b593c3703a" rel="noopener">本节取材于<a class="px py ep" href="https://medium.com/u/5d668b546d10?source=post_page-----dabd33212471--------------------------------" rel="noopener" target="_blank">林芳</a>的文章</a>。我强烈推荐它一读！我用它来分析更多的底层EVM操作码，以了解在引擎盖下发生了什么。</p></blockquote><p id="4bd5" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">坚固性文件陈述如下:</p><blockquote class="oq"><p id="d22d" class="or os it bd ot ou ov ow ox oy oz ly dk translated">"数据位置不仅与数据的持久性相关，还与赋值的语义相关."</p></blockquote><p id="c97a" class="pw-post-body-paragraph lc ld it lf b lg pm ju li lj pn jx ll lz po lo lp ma pp ls lt mb pq lw lx ly im bi translated">当指定函数体内的数据位置时，必须考虑两个主要因素:效果和气体使用。</p><p id="2ebb" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们用一个简单的合同作为例子来更好地理解。此协定在存储中保存结构项的映射。为了比较每个数据位置的行为，我们将使用不同的函数，这些函数使用不同的数据位置关键字。</p><ul class=""><li id="4173" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">一个使用<code class="fe pd pe pf pg b">storage</code>的吸气剂。</li><li id="4123" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">一个使用<code class="fe pd pe pf pg b">memory</code>的吸气剂。</li><li id="3c18" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">使用<code class="fe pd pe pf pg b">storage</code>的设定器。</li><li id="d0dd" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">使用<code class="fe pd pe pf pg b">memory</code>的设定器。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><h2 id="5d25" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated"><strong class="ak">带存储器的吸气剂<em class="pz"> vs </em>存储器</strong></h2><p id="cd91" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">我们要问自己的第一个问题是:</p><blockquote class="oq"><p id="795e" class="or os it bd ot ou ov ow ox oy oz ly dk translated"><em class="pz">使用带内存的吸气剂还是带存储的吸气剂更便宜？</em></p><p id="db45" class="or os it bd ot ou ov ow ox oy oz ly dk translated"><em class="pz">它们各自是如何工作的？</em></p></blockquote><figure class="qa qb qc qd qe kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="76c1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">带有<code class="fe pd pe pf pg b">storage</code>的getter比带有<code class="fe pd pe pf pg b">memory </code>的getter稍微便宜一些，因为它充当存储指针。</p><p id="453c" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">使用<code class="fe pd pe pf pg b">memory</code>的吸气剂更加昂贵，消耗更多的气体，因为产生了一个新的变量。在上面的例子中，除了读取存储映射<code class="fe pd pe pf pg b">items[_itemIndex]</code>中的值，它还将复制内存中的值。</p><p id="baf8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">让我们确保了解这里到底发生了什么。根据关键字<code class="fe pd pe pf pg b">storage</code>或<code class="fe pd pe pf pg b">memory</code>，EVM在引擎盖下做什么？</p><p id="1574" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">我在下面列出了两种类型的getter的操作码序列(为了清楚和简洁，没有在左边列出程序计数器)。你可以通过在Remix中调试代码来浏览它们。</p><p id="e089" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">如果我们比较两个getter函数的操作码，我们会注意到，与使用内存的getter(45条指令)相比，使用存储的getter包含更少的操作码(30条指令)。</p><blockquote class="kz la lb"><p id="cab3" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">推荐:我强烈推荐使用evm.codes网站来测试这两个函数，并逐个分析操作码和存储/内存中的变化。</p></blockquote><pre class="kj kk kl km gt qf pg qg qh aw qi bi"><span id="dc85" class="oa md it pg b gy qj qk l ql qm">; getItemUnitsStorage = 30 instructions</span><span id="f057" class="oa md it pg b gy qn qk l ql qm">PUSH1 00   ; 1) manipulate + prepare the stack<br/>DUP1<br/>PUSH1 00   <br/>DUP1<br/>DUP5       <br/>DUP2<br/>MSTORE     ; 2.1) prepare the memory for hashing (1)<br/>PUSH1 20   <br/>ADD    <br/>SWAP1<br/>DUP2 <br/>MSTORE     ; 2.2) prepare the memory for hashing (2)<br/>PUSH1 20<br/>ADD<br/>PUSH1 00<br/>SHA3       ; 3) compute the storage number to load via hashing<br/>SWAP1<br/>POP<br/>DUP1<br/>PUSH1 00<br/>ADD<br/>SLOAD      ; 4) load mapping value from storage<br/>SWAP2    <br/>POP<br/>POP<br/>SWAP2<br/>SWAP1<br/>POP<br/>JUMP<br/>JUMPDEST<br/></span><span id="97e8" class="oa md it pg b gy qn qk l ql qm">; getItemUnitsMemory = 47 instructions</span><span id="0e1d" class="oa md it pg b gy qn qk l ql qm">PUSH1 00<br/>DUP1<br/>PUSH1 00<br/>DUP1<br/>DUP5<br/>DUP2<br/>MSTORE<br/>PUSH1 20<br/>ADD<br/>SWAP1<br/>DUP2<br/>MSTORE<br/>PUSH1 20<br/>ADD<br/>PUSH1 00<br/>SHA3<br/>PUSH1 40  ; &lt;------ additional opcodes start here<br/>MLOAD     ; 1) load the free memory pointer<br/>DUP1      <em class="le">; 2) reserve the free memory pointer by duplicating it<br/></em>PUSH1 20<br/>ADD       <em class="le">; 3) compute the new free memory pointer<br/></em>PUSH1 40<br/>MSTORE    <em class="le">; 4) store the new free memory pointer<br/></em>SWAP1<br/>DUP2<br/>PUSH1 00<br/>DUP3<br/>ADD<br/>SLOAD     <em class="le">; 5) load mapping value from storage<br/></em>DUP2<br/>MSTORE    <em class="le">; 6) store mapping value retrieved from storage in memory<br/></em>POP<br/>POP ; &lt;------------ additional opcodes end here<br/>SWAP1<br/>POP<br/>DUP1<br/>PUSH1 00<br/>ADD<br/>MLOAD<br/>SWAP2<br/>POP<br/>POP<br/>SWAP2<br/>SWAP1<br/>POP</span></pre><p id="0622" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于使用<code class="fe pd pe pf pg b">storage</code>的吸气剂，EVM执行以下步骤:</p><ol class=""><li id="fc31" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly ph nc nd ne bi translated">操作+准备堆栈</li><li id="bd95" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">准备用于散列的存储器((1)和(2))</li><li id="3035" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">通过哈希和<code class="fe pd pe pf pg b">SHA3</code> (=来自<code class="fe pd pe pf pg b">mapping</code>的值驻留在哪个存储槽)计算要加载的值的存储槽。<a class="ae ky" href="https://medium.com/coinmonks/solidity-tutorial-all-about-mappings-29a12269ee14" rel="noopener">请参阅我的文章“关于映射的一切”以更好地理解</a>如何计算映射的存储槽。</li><li id="3d02" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">通过<code class="fe pd pe pf pg b">SLOAD</code>从存储器加载数值。</li></ol><p id="34f7" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">以下是每一步堆栈的所有细节:</p><blockquote class="kz la lb"><p id="cede" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">您可以在以下位置查看带有存储功能的<strong class="lf iu"> getter的所有详细信息和指令:<a class="ae ky" href="https://github.com/CJ42/All-About-Solidity/blob/1d25ade27299aac229e5413830a5d5aef3f160dd/articles/data-locations/getter-storage.asm" rel="noopener ugc nofollow" target="_blank">https://github . com/CJ42/All-About-Solidity/blob/master/articles/data-locations/getter-storage . ASM</a></strong></p></blockquote><p id="7559" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">接下来的问题是:</p><blockquote class="oq"><p id="caa1" class="or os it bd ot ou ov ow ox oy oz ly dk translated">为什么一个带内存的getter在底层多了17个操作码指令？</p></blockquote><p id="f00e" class="pw-post-body-paragraph lc ld it lf b lg pm ju li lj pn jx ll lz po lo lp ma pp ls lt mb pq lw lx ly im bi translated">答案就在上面汇编代码的描述注释里。17条附加EVM指令执行以下操作:</p><ol class=""><li id="9595" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly ph nc nd ne bi translated">它通过1.1)加载空闲内存指针，1.2)保留它，1.3)计算内存中的下一个空闲空间，以及4)更新新的空闲内存指针，在内存中保留一些空间用于存储该值。(<code class="fe pd pe pf pg b">MLOAD</code> + <code class="fe pd pe pf pg b">MSTORE</code>)</li><li id="6176" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">一旦数值通过<code class="fe pd pe pf pg b">SLOAD</code>从合同存储器中加载，它就会通过<code class="fe pd pe pf pg b">MSTORE</code>写入内存。</li></ol><blockquote class="kz la lb"><p id="2144" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">你可以在这里看到栈的所有细节和带有内存的getter的指令:<a class="ae ky" href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/data-locations/getter-memory.asm" rel="noopener ugc nofollow" target="_blank">https://github . com/CJ42/All-About-Solidity/blob/master/articles/data-locations/getter-storage . ASM</a></p></blockquote><h2 id="ea4c" class="oa md it bd me ob oc dn mi od oe dp mm lz of og mo ma oh oi mq mb oj ok ms ol bi translated">带存储<em class="pz">和</em>存储器的设定器</h2><blockquote class="kz la lb"><p id="af43" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">我推荐文章<a class="ae ky" href="https://blog.b9lab.com/storage-pointers-in-solidity-7dcfaa536089" rel="noopener ugc nofollow" target="_blank">“Solidity中的存储指针。为了更好地理解setter函数的行为，Rob Hitchens </a>给出了龙的名字。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pt pu l"/></div></figure><p id="9490" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">为变量指定<code class="fe pd pe pf pg b">storage</code>并设置其值时，将修改状态变量并覆盖合同存储。这将使用<code class="fe pd pe pf pg b">SSTORE</code>操作码。</p><p id="bbbf" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">相反，如果使用关键字<code class="fe pd pe pf pg b">memory</code>，它将简单地覆盖局部变量，而不是覆盖契约存储。这将使用<code class="fe pd pe pf pg b">MSTORE</code>操作码。</p><p id="6fc4" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">说到EVM指令集，我们可以从下面的代码片段中看到，使用<code class="fe pd pe pf pg b">storage</code>生成的指令要少得多(使用<code class="fe pd pe pf pg b">storage</code>生成了28条指令，而使用<code class="fe pd pe pf pg b">memory</code>生成了48条指令)。然而，使用<code class="fe pd pe pf pg b">storage</code>会消耗更多的汽油，因为存储读/写是EVM中最昂贵的操作。</p><pre class="kj kk kl km gt qf pg qg qh aw qi bi"><span id="7e92" class="oa md it pg b gy qj qk l ql qm">; setItemUnitsStorage = 28 instructions</span><span id="03e9" class="oa md it pg b gy qn qk l ql qm">PUSH1 00<br/>DUP1<br/>PUSH1 00<br/>DUP5<br/>DUP2<br/>MSTORE<br/>PUSH1 20<br/>ADD<br/>SWAP1<br/>DUP2<br/>MSTORE<br/>PUSH1 20<br/>ADD<br/>PUSH1 00<br/>SHA3<br/>SWAP1<br/>POP<br/>DUP2<br/>DUP2<br/>PUSH1 00<br/>ADD<br/>DUP2<br/>SWAP1<br/>SSTORE<br/>POP<br/>POP<br/>POP<br/>POP</span><span id="1b18" class="oa md it pg b gy qn qk l ql qm">; setItemUnitsMemory = 46 instructions</span><span id="9d74" class="oa md it pg b gy qn qk l ql qm">PUSH1 00<br/>DUP1<br/>PUSH1 00<br/>DUP5<br/>DUP2<br/>MSTORE<br/>PUSH1 20<br/>ADD<br/>SWAP1<br/>DUP2<br/>MSTORE<strong class="pg iu"><br/></strong>PUSH1 20<br/>ADD<br/>PUSH1 00<br/>SHA3<br/>PUSH1 40<br/>MLOAD<br/>DUP1<br/>PUSH1 20<br/>ADD<br/>PUSH1 40<br/>MSTORE<br/>SWAP1<br/>DUP2<br/>PUSH1 00<br/>DUP3<br/>ADD<br/>SLOAD<br/>DUP2<br/>MSTORE<br/>POP<br/>POP<br/>SWAP1<br/>POP<br/>DUP2<br/>DUP2<br/>PUSH1 00<br/>ADD<br/>DUP2<br/>DUP2<br/>MSTORE<br/>POP<br/>POP<br/>POP<br/>POP<br/>POP</span></pre><h1 id="02a3" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">映射的(边缘)情形</h1><p id="81fb" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated"><code class="fe pd pe pf pg b">mapping</code>可以作为参数传递给函数或在函数体内定义。然而，它们是一种边缘情况，对此有两个特定的规则:</p><ul class=""><li id="66a9" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly nb nc nd ne bi translated">只能将数据位置<code class="fe pd pe pf pg b">storage</code>分配给它们，作为对合同存储中已存在的映射的引用。</li><li id="bce0" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly nb nc nd ne bi translated">它们必须初始化为一个值。</li></ul><p id="5c27" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">这是因为映射不能动态创建。它们只能在函数体内部定义，作为对已经作为状态变量存在的映射的引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qo"><img src="../Images/d66e1a67cfb49547df40b2657a167db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8TYUVxoHXwrHvuuV4mRd4g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">如果你用混音写这个…</p></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qp"><img src="../Images/60963737276d0eeaf62e114f888bf31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlRsvuA7AoHiqm3lNECIYA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">这是您将返回的错误。</p></figure><h1 id="271c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9e34" class="pw-post-body-paragraph lc ld it lf b lg mw ju li lj mx jx ll lz nw lo lp ma nx ls lt mb ny lw lx ly im bi translated">你是否应该使用<code class="fe pd pe pf pg b">storage</code>、<code class="fe pd pe pf pg b">memory</code>或<code class="fe pd pe pf pg b">calldata</code>取决于你试图在合同中做什么。</p><p id="4ab8" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">对于某些数据类型，如果数据很大，将它们从存储复制到内存会非常昂贵。</p><p id="d3a1" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">但是，在某些情况下，如果您希望在函数中覆盖变量，并且不将结果传播到协定存储，这可能是必要的。</p><p id="c376" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">另一方面，<code class="fe pd pe pf pg b">calldata</code>提供了几个优于记忆的好处。</p><ol class=""><li id="450c" class="mu mv it lf b lg lh lj lk lz on ma oo mb op ly ph nc nd ne bi translated">节省汽油=避免将数据复制到<code class="fe pd pe pf pg b">memory</code>(因此之后必须从内存中加载)。</li><li id="15a9" class="mu mv it lf b lg nf lj ng lz nh ma ni mb nj ly ph nc nd ne bi translated">更安全(某些情况下)=由于<code class="fe pd pe pf pg b">calldata</code>是只读的数据位置，可以确保数据不被修改。这可能会增加安全性，尤其是当传递给函数的参数表示“敏感”数据(例如64字节签名)时。</li></ol><p id="82c3" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><code class="fe pd pe pf pg b">calldata</code>在可靠性文件中确实被推荐:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qq"><img src="../Images/d6466d040c4a8c26627a83915045b50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-kpkw3ncQWUo2t87IkP3mw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://docs.soliditylang.org/en/v0.8.15/types.html#data-location" rel="noopener ugc nofollow" target="_blank">https://docs . solidy lang . org/en/v 0 . 8 . 15/types . html # data-location</a></p></figure><p id="2587" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">然而，在某些场景中，使用<code class="fe pd pe pf pg b">memory</code>而不是<code class="fe pd pe pf pg b">calldata</code>可以提高可组合性</p><p id="cf33" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">最后，请注意，不在函数中使用正确的数据位置会导致潜在的错误和漏洞。现实世界的一个例子是对Cover协议的无限薄荷攻击。</p><p id="c497" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated">请看一下来自Cover protocol的<code class="fe pd pe pf pg b">Blacksmith.sol</code>契约的代码片段。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi qr"><img src="../Images/54e59055da9857823910e26e4d3cae3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vgHlD53CCtpInT7yNJWb7w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">对池变量的任何更改都是在内存中进行的，不会传播回约定存储。</p></figure><blockquote class="kz la lb"><p id="113d" class="lc ld le lf b lg lh ju li lj lk jx ll lm ln lo lp lq lr ls lt lu lv lw lx ly im bi translated">关于这个bug的更多细节，请看Mudti Gupta的博文:<a class="ae ky" href="https://mudit.blog/cover-protocol-hack-analysis-tokens-minted-exploit/" rel="noopener ugc nofollow" target="_blank">https://mudit . blog/cover-protocol-hack-analysis-tokens-minted-exploit/</a></p></blockquote><h1 id="9b05" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">参考</h1><div class="qs qt gp gr qu qv"><a href="https://ethdebug.github.io/solidity-data-representation/" rel="noopener  ugc nofollow" target="_blank"><div class="qw ab fo"><div class="qx ab qy cl cj qz"><h2 class="bd iu gy z fp ra fr fs rb fu fw is bi translated">固体中的数据表示</h2><div class="rc l"><h3 class="bd b gy z fp ra fr fs rb fu fw dk translated">适用于代码调试器和其他调试相关实用程序的编写人员。作者哈里·奥特曼[@haltman-at]发表…</h3></div><div class="rd l"><p class="bd b dl z fp ra fr fs rb fu fw dk translated">ethdebug.github.io</p></div></div></div></a></div><div class="qs qt gp gr qu qv"><a href="https://medium.com/coinmonks/ethereum-solidity-memory-vs-storage-which-to-use-in-local-functions-72b593c3703a" rel="noopener follow" target="_blank"><div class="qw ab fo"><div class="qx ab qy cl cj qz"><h2 class="bd iu gy z fp ra fr fs rb fu fw is bi translated">以太坊稳固性:内存与存储&amp;在本地函数中使用哪一个</h2><div class="rc l"><h3 class="bd b gy z fp ra fr fs rb fu fw dk translated">“存储”和“内存”数据位置关键字之间的区别。</h3></div><div class="rd l"><p class="bd b dl z fp ra fr fs rb fu fw dk translated">medium.com</p></div></div><div class="re l"><div class="rf l rg rh ri re rj ks qv"/></div></div></a></div><div class="qs qt gp gr qu qv"><a href="https://blog.openzeppelin.com/ethereum-in-depth-part-2-6339cf6bddb9/" rel="noopener  ugc nofollow" target="_blank"><div class="qw ab fo"><div class="qx ab qy cl cj qz"><h2 class="bd iu gy z fp ra fr fs rb fu fw is bi translated">以太坊深度，第2部分- OpenZeppelin博客</h2><div class="rc l"><h3 class="bd b gy z fp ra fr fs rb fu fw dk translated">感谢你对这篇文章感兴趣！我们正在进行品牌重塑，所以如果有些名字…</h3></div><div class="rd l"><p class="bd b dl z fp ra fr fs rb fu fw dk translated">blog.openzeppelin.com</p></div></div><div class="re l"><div class="rk l rg rh ri re rj ks qv"/></div></div></a></div><div class="qs qt gp gr qu qv"><a href="https://docs.soliditylang.org/en/v0.8.15/types.html#data-location" rel="noopener  ugc nofollow" target="_blank"><div class="qw ab fo"><div class="qx ab qy cl cj qz"><h2 class="bd iu gy z fp ra fr fs rb fu fw is bi translated">类型-坚固性0.8.15文件</h2><div class="rc l"><h3 class="bd b gy z fp ra fr fs rb fu fw dk translated">Solidity是一种静态类型语言，这意味着每个变量(状态和局部)的类型都需要…</h3></div><div class="rd l"><p class="bd b dl z fp ra fr fs rb fu fw dk translated">docs.soliditylang.org</p></div></div></div></a></div><div class="qs qt gp gr qu qv"><a href="https://github.com/CJ42/All-About-Solidity/blob/master/articles/Data-Locations.md" rel="noopener  ugc nofollow" target="_blank"><div class="qw ab fo"><div class="qx ab qy cl cj qz"><h2 class="bd iu gy z fp ra fr fs rb fu fw is bi translated">主CJ42处的全可靠性/数据位置. MD/全可靠性</h2><div class="rc l"><h3 class="bd b gy z fp ra fr fs rb fu fw dk translated">你会发现这个话题可能是最具挑战性的。下表是每个数据位置的概述…</h3></div><div class="rd l"><p class="bd b dl z fp ra fr fs rb fu fw dk translated">github.com</p></div></div><div class="re l"><div class="rl l rg rh ri re rj ks qv"/></div></div></a></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="rm pu l"/></div></figure><div class="qs qt gp gr qu qv"><a href="https://www.evm.codes/about" rel="noopener  ugc nofollow" target="_blank"><div class="qw ab fo"><div class="qx ab qy cl cj qz"><h2 class="bd iu gy z fp ra fr fs rb fu fw is bi translated">EVM电码</h2><div class="rc l"><h3 class="bd b gy z fp ra fr fs rb fu fw dk translated">以太坊虚拟机(或EVM)是一种基于堆栈的计算机。这意味着所有指令都带参数…</h3></div><div class="rd l"><p class="bd b dl z fp ra fr fs rb fu fw dk translated">www.evm.codes</p></div></div><div class="re l"><div class="rn l rg rh ri re rj ks qv"/></div></div></a></div><div class="qs qt gp gr qu qv"><a href="https://noxx.substack.com/p/evm-deep-dives-the-path-to-shadowy?s=r" rel="noopener  ugc nofollow" target="_blank"><div class="qw ab fo"><div class="qx ab qy cl cj qz"><h2 class="bd iu gy z fp ra fr fs rb fu fw is bi translated">EVM深度挖掘:通向影子超级编码员🥷的道路💻-第一部分</h2><div class="rc l"><h3 class="bd b gy z fp ra fr fs rb fu fw dk translated">基本原则思维是我们经常听到的一个术语。它侧重于深入理解的基本概念，一个…</h3></div><div class="rd l"><p class="bd b dl z fp ra fr fs rb fu fw dk translated">noxx.substack.com</p></div></div><div class="re l"><div class="ro l rg rh ri re rj ks qv"/></div></div></a></div><p id="bc5f" class="pw-post-body-paragraph lc ld it lf b lg lh ju li lj lk jx ll lz ln lo lp ma lr ls lt mb lv lw lx ly im bi translated"><a class="ae ky" href="https://mudit.blog/cover-protocol-hack-analysis-tokens-minted-exploit/" rel="noopener ugc nofollow" target="_blank">https://mudit . blog/cover-protocol-hack-analysis-tokens-minted-exploit/</a></p></div></div>    
</body>
</html>