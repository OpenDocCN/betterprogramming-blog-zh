# 初学者应避免的 5 种代码气味反应

> 原文：<https://betterprogramming.pub/5-code-smells-react-beginners-should-avoid-480c97799162>

## *在提交*之前，请务必仔细检查您对这些东西的拉动请求

![](img/7359303c4b8d9aedbd0cd0e1616c1335.png)

Priscilla Du Preez 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片。

作为来自各种不同背景(包括训练营和其他非传统教育途径)的前端初学者的导师，我观察到了许多不同的 React 编码方法。React 的部分魅力在于，相对于 Angular 和 Vue 这样的框架，它通常是相当独立的。这使得它足够灵活，可以插入许多用不同框架编写的现有代码库。此外，它激发了大量不同用例的社区库，从而推动了整个行业的发展。

然而，与传统无关的、重配置的生态系统的缺点是，它给初学者留下了很多偏离最佳实践的空间。下面是五个经常被违反的最佳实践——或者说代码味道——这是我在审查 React 新开发人员的拉请求时经常发现的。

应该注意的是，在这个上下文中的“代码味道”只是我注意到的一种模式，它吸引我的注意力以进行进一步的检查。这并不意味着这些总是不适当的实现。好的软件工程没有绝对的规则。在特殊情况下，如果有适当的上下文，这些代码气味中的每一种都是有意义的。也就是说，如果你发现自己在使用这些模式，你应该停下来问问自己，“这真的有必要吗？”

# **1。可变变量**

在过去的五年里，我只需要使用一次可变变量——就像我说的，每个最佳实践都有例外。可变变量是在代码执行过程中可以重新赋值的变量。JavaScript 中的这些变量是`let`和`var`。如果你正在使用 ES6 语法，你可能永远不会想使用`var`，但是我仍然发现许多 React 初学者在使用`let`。

当审查一个拉请求时，在 React 中看到任何不是`const`变量的变量都告诉我，开发人员可能最熟悉过程化设计模式。[累加器模式](https://blog.devgenius.io/replace-the-accumulator-pattern-665c9969d9f4)是一个利用可变变量的过程化设计模式的例子，我看到许多初学者都在使用。几乎所有使用可变变量的设计模式都可以用等价的函数式编程来代替。

[](https://blog.devgenius.io/replace-the-accumulator-pattern-665c9969d9f4) [## 更换累加器模式

### 保持代码安全不变的函数式编程策略

blog.devgenius.io](https://blog.devgenius.io/replace-the-accumulator-pattern-665c9969d9f4) 

# 2.程序模式

如前所述，过程模式通常表示使用可变变量。每当我看到以下任何一个操作者，我都能嗅到一种正在形成的程序模式:

*   `for`循环
*   `while`循环
*   `forEach`作战
*   一个`push`对一个阵

这些通常表示 React 组件内部的副作用，这在纯函数式编程中是不好的做法。React 实际上旨在用于函数式和声明式范例。有关 JavaScript 函数式编程的更多信息，请参见下文:

[](/functional-programming-in-javascript-introduction-and-practical-examples-d268e44395b2) [## JavaScript 中的函数式编程:简介和实例

### 从纯函数和组合子到组合和容器

better 编程. pub](/functional-programming-in-javascript-introduction-and-practical-examples-d268e44395b2) 

作为这些代码味道的替代，您通常可以使用`map`、`reduce`、`find`和`filter`数组方法。

# **3。字符串文字**

字符串文字是任何“匿名字符串”或代码中没有作为某种类型的变量或数据结构存储在内存中的任何字符串。字符串文字使得你的代码在重构时更加脆弱，并且不太支持国际化。许多初学者在早期的代码中使用字符串文字，因为他们还没有遇到最终会变得痛苦的情况。

请考虑下面的代码示例:

图 1.1—React 组件中使用的字符串文字，用于有条件地呈现文本样式。

图 1.1 展示了一个 React 组件，它根据`status`属性是否等于字符串文字`'active'`来有条件地呈现`Badge`组件的背景。因为`status` prop 也用于将文本呈现到屏幕上，所以假设用户需求在某个时候可能会发生变化，并且他们更愿意看到“就绪”而不是“活动”这个词，这并不令人费解在这种情况下，开发人员将不得不检查应用程序中任何类型的业务逻辑中使用字符串文字`'active'`的地方。如果他们错过了这个特殊的三元表达式，那么单词“ready”*将会*显示在屏幕上，但是它将会有一个红色的背景——这不是想要的用户体验。

如果他们改而重构代码以使用内存中的单个引用点，如图 1.2 所示，他们已经成功地为将来最小化了他们的重构工作。如果用户回来后决定再次从“ready”更改为“complete”，那么开发人员就不必在代码中到处寻找对字符串“ready”的引用。相反，他们可以简单地改变他们的`status.js`文件中的`status`对象的`active`属性的值，这样就可以了！

图 1.2 —重构 badge 组件以消除字符串文字。

最大限度地减少字符串文字的使用也使您的代码更适合翻译成其他语言，因为您可以调用语言文件来返回对适当字符串的引用。例如，如果`Badge`组件将语言代码作为其`props`之一，那么您可以重构组件中的标签，使其不再使用字符串文字。这在下面图 1.3 的中的第 9 行进行了演示。现在，为了支持更多的语言，你所要做的就是更新你的`labels`对象，你就可以立即在你的组件中呈现新的语言。

图 1.3 —重构我们的代码以允许国际化。

# 4.直接 DOM 操作

我经常看到 React 初学者试图在 React 功能组件的主体中使用普通的 JavaScript 来直接访问 HTML DOM 元素。很多时候，他们使用这种方法，因为这是他们学习 JavaScript 的方式，或者他们发现了一个与 React 无关的关于堆栈溢出的帖子，这给了他们当时需要的解决方案——从他们的角度来看，这就是工作！

```
document.getElementById('virtual-div')
```

但是，因为 React 使用虚拟 DOM，所以不能保证您试图访问的 DOM 元素在您查询它时会存在。它可能还没有挂载，也可能正在重新渲染。无论哪种方式，在组件生命周期的整个过程中，您对实际 DOM 元素所做的任何更改都将丢失。

您不需要直接在 DOM 上操作，而是需要使用`useRef`钩子来创建对您想要操作的 DOM 元素的引用，以便您可以在组件重新呈现的整个过程中继续访问它。React 官方网站上的`useRef` Hook 文档是进一步理解这一点的很好的参考:

[](https://reactjs.org/docs/hooks-reference.html#useref) [## 钩子 API 参考-反应

### 钩子是 React 16.8 中的新增功能。它们允许您使用状态和其他 React 特性，而无需编写类。这个…

reactjs.org](https://reactjs.org/docs/hooks-reference.html#useref) 

# 5.大型组件文件

这可能更像是一种架构的味道，而不是代码的味道，但无论如何还是值得一提。我见过许多全新的工程师，他们只独自编写代码，从不与其他工程师团队合作。在这种情况下，开发人员用一两个非常大的组件编写整个应用程序的情况并不少见。默认情况下，他们不需要将代码抽象和组合成更小、更易消化和更易维护的组件。毕竟，没有其他人需要阅读代码，对不对？

这对新工程师来说是一个非常重要的教训:我们不为计算机写代码。我们为下一个到来的工程师写代码。

即使你是一个人的团队，下一个出现的工程师也是你未来的自己。有时候，在未来的几个月或几年，你会回过头来看你的代码，这些代码都聚集在一个组件中，你会想，“这又意味着什么？”

有时候，这种建筑的味道并没有那么强烈。相反，我可能会看到一个开发人员写了一些他们不想创建新组件的代码——也许这只是觉得有点矫枉过正。但是，如果随着时间的推移，你在一个组件上添加了许多小的变化，最终你会得到一个大的组件。您甚至可能欺骗自己在另一个组件中编写一个组件，而自己却没有意识到这一点。

考虑图 2.1:

图 2.1 —一个可能比实际需要的要大的组件文件。

我以前见过一模一样的场景。开发人员心里想，“我不想为一系列数据中的每一行重写所有这些代码行，所以我只是将其抽象成一个快速函数。”他们没有意识到的是，他们实际上已经创建了一个新的组件。他们为`renderRow`函数创建的`rowData`参数的操作与传统函数组件的`props`参数非常相似。当这种情况发生时，我要求开发人员将代码放在自己的组件文件中，以便将来可以单独维护和迭代。

我调查了我组织中的几位高级工程师，我们得出了以下经验法则。如果你的组件文件有 100-200 行代码，你就需要重构你的代码来抽象它，使它变得更小。如果你的代码超过 200 行，你可能需要想办法把你的文件变小。文件可能太大有两个主要原因:

1.  你在一个组件中放了太多的 UI 元素。在这种情况下，您可以简单地将一些 UI 抽象成更小的组件，然后在父组件中引用它们。
2.  您在组件中加入了大量的业务逻辑。一般来说，我尽量让我的工程师避免这种情况。写在功能组件主体中的业务逻辑往往更难测试。如果业务逻辑位于您的功能组件中，那么测试业务逻辑的唯一真正方法是将组件安装到您的测试文件中，并模拟用户交互，以查看您是否获得了想要的 UI 结果。或者，您可以将任何业务逻辑完全从组件中提取出来，并将它们放在实用程序文件中，或者作为状态管理逻辑的一部分(例如 Redux)。我一般倾向于后一种解决方案。它允许编写简单的纯函数，可以很容易地用单元测试来测试。这里有另一条经验法则:尽可能减少表示层中的业务逻辑！

如果我在 React 应用程序的表示层(组件)中看到大量业务逻辑，即使组件文件不超过 200 行代码，我也倾向于要求工程师重构他们的代码，并将业务逻辑移出组件。大多数时候，如果你用纯函数编码，这是相当容易的。然而，这只是一个经验法则。这并不总是可能的。

# 结论

还是那句话，这些“气味”没有一个是不好的。他们只是倾向于让我在审查拉请求时看两遍代码。如果我发现自己在使用它们，我一定会给我的评论者留下一条评论，证明为什么它是必要的。如果你有正当的理由使用它们，我很乐意在评论中听到(GitHub 代码的链接会很棒)。

编码快乐！

[](https://www.medium.com/@jasonleehodges) [## 杰森·李·霍奇斯-中等作家

### 杰森·李·霍奇斯是一位资深软件工程经理，也是《从零开始的软件工程》一书的作者

www.medium.com](https://www.medium.com/@jasonleehodges)