<html>
<head>
<title>Build Single Activity Apps With Jetpack Compose</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jetpack Compose构建单一活动应用程序</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/single-activity-apps-with-jetpack-compose-bba4938ad630?source=collection_archive---------2-----------------------#2022-02-01">https://betterprogramming.pub/single-activity-apps-with-jetpack-compose-bba4938ad630?source=collection_archive---------2-----------------------#2022-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="36e3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">创建独立的Android应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/93394b17baa4cf819aaecfbe4ffcb68c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kUUx_YBG5bWWo16d"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com/@rmrdnl?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·罗梅罗</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="4008" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我在2017年开始开发android应用程序时，我记得为应用程序中的每个屏幕或功能构建活动，并在这些活动中烘焙所有的业务逻辑。代码看起来如此复杂和混乱，我会自豪地向我的朋友炫耀。我大约15-16岁的时候上11年级，我认为我很聪明，“没有人能做我做的事”，我对自己说。</p><p id="9060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我了解了片段，我最讨厌android开发。重点是什么？它们看起来就像活动，但却让一切变得更加困难。如果不经历迷宫般的错误(顺便说一下，这教会了我很多)，我就无法让片段事务工作或在多个片段之间传递一些数据。为了避免麻烦，我只在必要时使用片段，并在整个应用程序中继续使用活动。</p><p id="ab3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我追求不断提高技能和学习的过程中，我发现了干净的架构和坚实的原则，我试图将它们应用到我构建的每一个软件中，无论是手机还是其他。我构建的下一个应用程序有一个活动和大约4个片段。事实证明碎片并没有那么糟糕。在这一点上，我对片段有了更好的理解，并发誓永远使用它们。直到我拿起jetpack compose。长话短说，我又讨厌碎片了。</p><p id="a9df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您从未使用过jetpack compose，您应该尝试一下。我不会深入讨论它的工作原理或基本原理。我使用的最好的资源是mitch的<a class="ae kv" href="https://codingwithmitch.com/" rel="noopener ugc nofollow" target="_blank">编码</a>和Google的<a class="ae kv" href="https://developer.android.com/jetpack/compose" rel="noopener ugc nofollow" target="_blank">文档</a>。在本文中，我将介绍使用jetpack库构建单活动应用程序的许多方法中的一种。</p><p id="6726" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键的想法是有一个单一的活动，作为你的应用程序的主要入口和出口。某些应用程序可能需要构建几个活动，例如一个<code class="fe ls lt lu lv b">MainActivity</code>和一个<code class="fe ls lt lu lv b">SettingsActivity</code>，但是基本思想是相同的。</p><p id="b33b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们开始之前，了解组成大多数应用程序的主要组件是很重要的，在这种情况下，主要是一个或多个用户交互的屏幕，以及在这些屏幕之间导航的机制(如果有多个屏幕的话)。那么这是如何工作的呢？</p><h1 id="fbfb" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创建应用程序的主要活动</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b884" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们准备好了基本活动，我们现在需要设置导航控制器，它将允许我们在不同的屏幕之间导航。对于这个例子，我们假设我们的应用程序只有3个可能的屏幕，主页，搜索和图书馆。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="a11e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是创建一个顶层的Singleton Screen对象，为应用程序中所有可能的屏幕分配唯一的路径。对于我们的例子，这个对象——存储在一个顶级Kotlin文件中——看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h1 id="b305" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">添加NavHost</h1><p id="dbe8" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">回到<code class="fe ls lt lu lv b">MainActivity</code>,我们现在添加一个<code class="fe ls lt lu lv b">NavHost</code>,初始路线设置为<code class="fe ls lt lu lv b">Screen.Home.route</code>,因为这是我们应用程序的默认屏幕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="522a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步是将所有顶级目的地——在我们的例子中是Home、Search和Library目的地——放入NavHost。为此，我们利用Kotlin的扩展函数，将每个屏幕表示为<code class="fe ls lt lu lv b">NavGraphBuilder</code>的扩展。</p><blockquote class="mv mw mx"><p id="ac4c" class="kw kx my ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">我们利用Kotlin的扩展函数，将每个屏幕表示为NavGraphBuilder的扩展</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为搜索和库屏幕编写完全相同的代码</p></figure><p id="8750" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe ls lt lu lv b">MainActivity</code>，我们现在把这些放在<code class="fe ls lt lu lv b">NavHost</code>里，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="3f07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，应用程序不会这样工作。为了在屏幕间导航，你需要一个带有底部应用程序栏或其他导航方式的支架，例如一个调用<code class="fe ls lt lu lv b">navController.navigate(route)</code>的按钮点击。上述函数允许您创建一个导航图，定义应用程序中不同屏幕之间的关系。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><p id="21e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个好的做法是将导航逻辑提取到一个单独的顶级Kotlin文件中，因为对于一个生产应用程序来说，导航图通常会变得非常复杂。另一个最佳实践是将我们的屏幕放在单独的模块中，但这是另一天的主题。</p><p id="2a15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">谢谢你过来。保持警惕！</p></div></div>    
</body>
</html>