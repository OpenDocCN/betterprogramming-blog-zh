<html>
<head>
<title>Routing and Code Splitting in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的路由和代码拆分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/routing-and-code-splitting-in-react-fc7315f0bde4?source=collection_archive---------5-----------------------#2020-01-20">https://betterprogramming.pub/routing-and-code-splitting-in-react-fc7315f0bde4?source=collection_archive---------5-----------------------#2020-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="80b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用React.lazy()和悬念正确实现React路由器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7b0e7a880344264a8f9dce5cfa4539fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_FDHvGxLyn-pOZmf"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">尼古拉斯·杰夫韦在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="51c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您希望React应用程序中有多个路由，您应该了解React路由器的实现。没那么难。</p><p id="fcc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您的应用程序可能会扩展并添加更多路线，您可能会遇到性能问题。一些路线可能甚至没有被用户访问过，但是它们仍然会被导入。这将增加应用程序所需的数据量。</p><p id="0eba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，您不能忘记处理应用程序中不存在的路线。一个好的开发人员应该预料到这样的问题会发生。</p><p id="2c16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我将演示如何使用React路由器，同时考虑使用基于路由的代码分割进行性能优化。</p><p id="62d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，您可以克隆GitHub repo 。如果你有兴趣从头开始构建整个应用程序，请随意阅读我关于用钩子构建React应用程序的最佳实践的文章。</p><p id="5cef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们言归正传。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1785" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">安装</h1><p id="da34" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">首先，我们需要使用以下命令安装React路由器:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7d47" class="nc mb iq my b gy nd ne l nf ng">npm install --save react-router-dom</span></pre><p id="3362" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我们在它们之间创建路线和链接。</p><p id="cb61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的应用程序中，我们需要更新我们的文件夹结构。因为您可能不确定将来会有多少条路线，所以最好将路线分别放在单独的文件夹中。</p><p id="2fff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在<code class="fe nh ni nj my b">src</code>目录下创建这个文件夹，并将其命名为<code class="fe nh ni nj my b">routes</code>。这是我们将要创建和管理所有路由的地方，其中每条路由都是一个单独的组件。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="613f" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">构建路线作为示例</h1><p id="a90e" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">首先，我们将有三条路线:<code class="fe nh ni nj my b">Home</code>、<code class="fe nh ni nj my b">Favourites</code>和<code class="fe nh ni nj my b">CountriesContainer</code>:</p><ul class=""><li id="0e68" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">让我们从默认路线开始，它在路径<code class="fe nh ni nj my b">/</code>上。它应该是第一页，如果用户访问您的网站，就会显示出来。在我们的例子中是<code class="fe nh ni nj my b">Home.js</code>。</li><li id="7a19" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">我们还创建了route <code class="fe nh ni nj my b"><a class="ae kv" href="https://github.com/Dromediansk/countries-app-blog/blob/react-router-implementation/src/routes/Favourites.js" rel="noopener ugc nofollow" target="_blank">Favourites.js</a></code>，用图片展示了几个国家。这条路线将是一个很好的例子，在这篇文章的后面演示路线的代码分割。到这条路线的路径将是<code class="fe nh ni nj my b">/favourites</code>。</li><li id="90f7" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">我们正在将<code class="fe nh ni nj my b">CountriesContainer.js</code>移动到<code class="fe nh ni nj my b">/data</code>路径中的<code class="fe nh ni nj my b">routes</code>文件夹。在前一篇文章中已经构建了这个组件。</li><li id="af12" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">您可以随意添加任意多的路线。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ee59" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">404页</h1><p id="5d86" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">每一个坚实的网站都应该照顾到用户意想不到的行为。如果你想成为一名优秀的开发者，你的责任就是处理这些情况。那么让我们来解决下面这个问题:</p><p id="b59e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">如果用户输入了您网站上不存在的路线，应该显示什么？</em></p><p id="5695" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它应该告诉用户这样的页面不存在，这样也更人性化。这里有一些404页的好例子，你可以从中获得灵感。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="606b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">创建导航栏</h1><p id="6f8d" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">当然，您需要能够在路线之间导航，所以让我们在<code class="fe nh ni nj my b">components</code>文件夹中构建我们的导航栏:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><ul class=""><li id="a0c1" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">路线是在项目列表中创建的。</li><li id="d041" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">每个条目(route)都使用react-router-dom中的<code class="fe nh ni nj my b">NavLink</code>组件，这是我们之前安装的。</li><li id="76a4" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe nh ni nj my b">NavLink</code>有一个必需的属性<code class="fe nh ni nj my b">to</code>，点击后会重定向到路由。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="f1be" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">航线实施</strong></h1><p id="bdd6" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在，让我们用最重要的部分来完成这个设置。所有的路线都将在<code class="fe nh ni nj my b">App.js</code>中实现，它位于组件树结构的顶部。</p><p id="e425" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要从<code class="fe nh ni nj my b">react-router-dom</code>导入一些组件:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="a215" class="nc mb iq my b gy nd ne l nf ng">import { Switch, Route, BrowserRouter as Router } from "react-router-dom"</span></pre><p id="f465" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们将路线添加到应用程序组件中，它将看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="e0d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在React路由器的实施过程中，请记住以下原则:</p><ul class=""><li id="3961" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">最上面的标签是<code class="fe nh ni nj my b">Router</code>，所有的路线都包含在<code class="fe nh ni nj my b">Switch</code>中。</li><li id="5730" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">每个<code class="fe nh ni nj my b">Route</code>都有支柱<code class="fe nh ni nj my b">path</code>和<code class="fe nh ni nj my b">component</code>。</li><li id="2ce8" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">路由的顺序很重要，因为React路由器会遍历每条路由，并选择路径正确的路由。</li><li id="2511" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">作为最后一条路线，你要加一个没有<code class="fe nh ni nj my b">path</code>道具的404页面。这意味着如果上述路径都不等于要求的路径，路由器将显示此页面。</li></ul></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="3942" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">代码分割</h1><p id="f3ad" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">现在，随着项目的增长，你需要考虑网站的捆绑大小。</p><p id="777e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是来自<a class="ae kv" href="https://reactjs.org/docs/code-splitting.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>的捆绑的确切定义:</p><blockquote class="oa ob oc"><p id="9c20" class="kw kx ls ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">捆绑就是跟踪导入的文件并将它们合并成一个文件的过程:一个“捆绑包”。然后，这个包可以包含在网页上，一次加载整个应用程序。</p></blockquote><p id="640a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你需要留意你的包中包含的代码——不要意外地使它变得太大，以至于你的网站需要很长时间来加载。</p><p id="d30d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这也适用于路由。如果您添加15条路线，它们将被捆绑在一个文件中，并在用户访问网站时立即加载。这是没有效率的，因为一些路线可能甚至没有被用户访问过，或者他们甚至是不可访问的(例如，管理页面)。</p><p id="8737" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，正确的解决方案是使用代码分割。这个特性允许您将代码分成不同的包，然后按需或并行加载。</p><p id="bde0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们在我们的网站上演示一下。</p><h2 id="ef1c" class="nc mb iq bd mc og oh dn mg oi oj dp mk lf ok ol mm lj om on mo ln oo op mq oq bi translated">用lazy()和悬念进行代码拆分</h2><p id="5299" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">React在16.8版本中发布了适合这些情况的特性:<code class="fe nh ni nj my b">React.lazy()</code>和<code class="fe nh ni nj my b">Suspense</code>。</p><p id="056f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们更新一下我们的<code class="fe nh ni nj my b">App.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="1e05" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是一些需要记住的亮点:</p><ul class=""><li id="7c73" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">如果需要，可以使用<code class="fe nh ni nj my b">React.lazy()</code>动态导入路线</li><li id="455b" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><code class="fe nh ni nj my b">&lt;Suspense&gt;</code>是作为整个内容的包装器添加的。它有一个必需的道具<code class="fe nh ni nj my b">fallback</code>，在加载<code class="fe nh ni nj my b">&lt;Suspense&gt;</code>里面的内容时显示一个组件。通常，它应该是某种装载旋转器。</li></ul><p id="1d0d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nh ni nj my b">React.lazy()</code>和<code class="fe nh ni nj my b">&lt;Suspense&gt;</code>也可以用于组件的动态导入，而不仅仅是路由。至少在大尺寸的内容中使用它是一个好习惯，比如图像和视频。它们只有在用户需要时才会被导入。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="55cf" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">测试我们的结果</h1><p id="b1fc" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">你如何知道通过使用上面的技术你实际上节省了多少数据？</p><p id="2c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来分析一下我们的网站。在Chrome中，打开DevTools，点击网络选项卡。</p><p id="0cfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>为了获得正确的结果，请清理内存缓存，并使用键盘上的<em class="ls"> shift </em> + <em class="ls"> F5 </em>重新加载页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/c9b79b4bb10040940a00e8bfa472a924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rg6u7GmGvFKBzFjDjX4_KA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">主页</p></figure><p id="b7e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您在下面看到的，资源的总大小是2.1 MB。</p><p id="c5ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们重定向到收藏夹路径，在这里我们动态导入几个图像:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/e0fff15b52a48f6917ed9ed6cca14b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzuLjaelgWIzjLjZz-8hFQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">收藏夹路线</p></figure><p id="bc30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此页面上请求的数据总大小为2.4MB。如果我们没有实施代码分割，所有图像将在用户访问第一页时立即下载。那会浪费资源和加载时间！</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="35aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以检查、克隆或派生GitHub repo 的最终版本。</p><p id="8cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你有兴趣更深入地了解性能，你可以使用另一种叫做<em class="ls">记忆</em>的技术。</p><div class="ot ou gp gr ov ow"><a href="https://medium.com/better-programming/boost-performance-of-your-react-app-with-memoization-e414f4f64c05" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ir gy z fp pb fr fs pc fu fw ip bi translated">通过记忆提升React应用的性能</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">React.memo()和useMemo()挂钩何时有用的全面解释</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kp ow"/></div></div></a></div></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="ab8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>