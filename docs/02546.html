<html>
<head>
<title>An Introduction to Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的承诺介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/an-introduction-to-promises-in-javascript-a29bfdad4643?source=collection_archive---------2-----------------------#2019-12-08">https://betterprogramming.pub/an-introduction-to-promises-in-javascript-a29bfdad4643?source=collection_archive---------2-----------------------#2019-12-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="32fc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将您从JavaScript的异步问题中解救出来</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/e9b78143cd8b68c7ce56b1b2dfb17549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*N1Z8yM1QFi4ptE1NiX4s2g.jpeg"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae ku" href="https://unsplash.com/photos/aiyBwbrWWlo" rel="noopener ugc nofollow" target="_blank">凯文·Ku</a>在<a class="ae ku" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0d6d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果你对现代JavaScript稍有了解，你可能以前听说过承诺。不过，可能会出现你没有真正使用它们的情况。或者你不知道如何或何时使用它们。</p><p id="5b39" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">承诺用于处理JavaScript中的异步操作。它们很容易实现，可以让您避免许多令人头疼的异步问题。当你有多个异步操作时，承诺也可以让你省去处理大量回调的麻烦。当你使用回调的时候，它们会创建一个回调地狱，导致不可管理的代码。幸运的是，承诺是一个很好的选择。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="9455" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">回调的问题是</h1><p id="66e2" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">虽然承诺在JavaScript中已经存在了几年，但是让我们回到承诺不存在的时代。这将使您更好地理解为什么承诺是处理异步操作的最佳方式。</p><p id="274e" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在承诺出现之前，处理异步操作的一种方法是使用回调——在很长一段时间内，回调是处理异步操作的首选方法。但是回调有其缺点。</p><p id="6b88" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们看看下面的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e0bb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如您所见，<code class="fe mx my mz na b">loadScript</code>函数被传递了一个回调参数，该参数在脚本加载时被执行。这很好。尽管这提出了一个大问题:当脚本由于某种原因无法加载时会发生什么？忽视加载脚本可能失败的事实是天真的。</p><p id="5154" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么我们该如何改进呢？这很简单。我们向回调函数添加了一个新参数，该参数告诉我们脚本是否已经正确加载。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3ba7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">但是，如果我们不依赖于加载一个图像，而是加载三个图像，会发生什么呢？或者更多？</p><p id="56be" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们将结束的是所谓的<em class="nb">回调地狱</em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="0b56" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">承诺简介</h1><p id="40b4" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">在我们深入研究承诺以及它们是如何工作的之前，让我们先来看看<a class="ae ku" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> MDN </a>是如何描述承诺的。</p><blockquote class="nc nd ne"><p id="677f" class="kv kw nb kx b ky kz ju la lb lc jx ld nf lf lg lh ng lj lk ll nh ln lo lp lq im bi translated">"<code class="fe mx my mz na b"><strong class="kx iu">Promise</strong></code>对象表示异步操作的最终完成(或失败)及其结果值."</p></blockquote><p id="f2d3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如MDN所提到的，承诺用于处理异步操作。事实上，承诺是以最简单的方式处理异步操作的方法。它们可以轻松处理多个异步操作，并提供比回调和事件更好的错误处理。最重要的是，承诺也增加了代码的可读性。</p><p id="9d68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">承诺可以有以下四种状态之一:</p><ol class=""><li id="557d" class="ni nj it kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><strong class="kx iu">完成</strong>:承诺相关动作成功</li><li id="ea30" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx iu">拒绝</strong>:承诺相关动作失败</li><li id="ad35" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx iu">待定</strong>:承诺仍待定(尚未履行或拒绝)</li><li id="041b" class="ni nj it kx b ky nr lb ns le nt li nu lm nv lq nn no np nq bi translated"><strong class="kx iu">已解决</strong>:承诺已经实现或被拒绝</li></ol></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="d824" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">代码中的承诺</h1><p id="1f09" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">如前所述，承诺通常用于更容易地处理异步操作，如API调用或文件操作。这些异步操作在<code class="fe mx my mz na b">executor</code>函数内部启动。</p><p id="ec79" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果异步操作成功，调用<code class="fe mx my mz na b">resolve</code>函数返回预期结果。同样，如果在异步操作的执行过程中发生了一些意外错误，结果将由<code class="fe mx my mz na b">reject</code>函数返回。</p><p id="569a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们先来看看如何用JavaScript创建一个承诺。</p><pre class="kj kk kl km gt nw na nx ny aw nz bi"><span id="2b25" class="oa lz it na b gy ob oc l od oe">new Promise(<em class="nb">executor</em>);<br/>new Promise(function(resolve, reject) { ... });</span></pre><p id="0388" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">正如您在上面的例子中看到的，Promise构造函数接受了一个名为<code class="fe mx my mz na b">executor</code>的函数。这个<code class="fe mx my mz na b">executor</code>函数有两个参数:<code class="fe mx my mz na b">resolve</code> <em class="nb"> </em>和<code class="fe mx my mz na b">reject</code>，都是函数。</p><p id="b0dc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">既然我们知道了承诺是如何产生的，是时候创造一个简单的承诺来帮助我们理解了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="09aa" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在上面的例子中，我们试图从一个API获取一些数据。如果API返回HTTP状态代码200，则请求成功。否则，请求失败。</p><p id="e6ba" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">换句话说，如果HTTP状态代码是200，则承诺得到解析。否则，承诺会被拒绝。</p><p id="c609" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那么，我们如何利用我们刚刚创造的承诺呢？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="be89" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当<code class="fe mx my mz na b">resolve</code>或<code class="fe mx my mz na b">reject</code>被调用时，承诺被确定。在这一点上，链的下一部分得到执行。这通常是一个<code class="fe mx my mz na b">then</code>或<code class="fe mx my mz na b">catch</code>或<em class="nb">。</em>只能由<code class="fe mx my mz na b">executor</code>调用一次解决或拒绝。承诺的状态改变是最终的，并且<code class="fe mx my mz na b">resolve</code>和<code class="fe mx my mz na b">reject</code>的所有进一步调用都被忽略。</p><p id="cdaf" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">当承诺被解决时，触发<code class="fe mx my mz na b">then</code>回调。也可以链接<code class="fe mx my mz na b">then</code>方法回调。当承诺被拒绝时，执行<code class="fe mx my mz na b">catch</code>回调。<code class="fe mx my mz na b">finally</code> <em class="nb"> </em>回调无论成败都调用。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h1 id="bf72" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">所有人和种族</h1><p id="9c82" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">我们还没有复习的最后两个函数是<code class="fe mx my mz na b">all</code>和<code class="fe mx my mz na b">race</code>函数。虽然它们可以派上用场，但你可能比其他promise函数用得少。</p><h2 id="d2ef" class="oa lz it bd ma of og dn me oh oi dp mi le oj ok mk li ol om mm lm on oo mo op bi translated">全部</h2><p id="d537" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated">使用<code class="fe mx my mz na b">Promise.all</code>的最佳例子是一次发出多个AJAX请求。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="db58" class="oa lz it bd ma of og dn me oh oi dp mi le oj ok mk li ol om mm lm on oo mo op bi translated">人种</h2><p id="49d4" class="pw-post-body-paragraph kv kw it kx b ky mq ju la lb mr jx ld le ms lg lh li mt lk ll lm mu lo lp lq im bi translated"><code class="fe mx my mz na b">Promise.race </code>不是等待所有承诺都被解决或拒绝，而是只要数组中的任何承诺被解决或拒绝就触发。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mv mw l"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">控制台中的输出是“输出:秒！”</p></figure><p id="4373" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">请注意，在上面的例子中,<code class="fe mx my mz na b">request1</code>承诺从未得到解决！</p></div></div>    
</body>
</html>