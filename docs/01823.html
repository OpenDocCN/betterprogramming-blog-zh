<html>
<head>
<title>Optionals in Swift Explained: 5 Things You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift的期权解释:你应该知道的5件事</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/optionals-in-swift-explained-5-things-you-should-know-d737e2d52a9e?source=collection_archive---------18-----------------------#2019-10-15">https://betterprogramming.pub/optionals-in-swift-explained-5-things-you-should-know-d737e2d52a9e?source=collection_archive---------18-----------------------#2019-10-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8d9a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写干净的代码，同时注意可能的零值</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d63dc5ff463187b890d582d328c1909.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FLTksMxK2CtoI8nx7m7QMA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@maxcodes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Max Nelson </a>在<a class="ae ky" href="https://unsplash.com/s/photos/swift?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="5843" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可选方案是Swift的核心，从Swift的第一个版本开始就存在了。可选值允许我们编写干净的代码，同时注意可能的零值。</p><p id="eb4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您是Swift新手，您可能需要习惯向属性添加问号的语法。一旦你习惯了它们，你实际上可以开始从它们中获益，例如，扩展。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1746" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">Swift中的可选值是什么？</h1><p id="1e53" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在我们深入了解你应该知道的关于期权的一系列事情之前，先了解一些基础知识是有好处的。</p><p id="c2dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性、方法和下标可以返回一个可选的，这基本上意味着它要么返回一个值(如果它存在的话)，要么返回另一个值<code class="fe mz na nb nc b">nil</code>。多个查询可以链接在一起，称为<em class="nd">可选链接</em>。这是对<em class="nd">强制展开</em>的一种替代，稍后将对此进行更详细的解释。</p><p id="0fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码示例显示了可选的<code class="fe mz na nb nc b">String</code>和可选的链接的定义，以打印出字符数。</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="55a7" class="ni md it nc b gy nj nk l nl nm">let name: String? = "Antoine van der Lee"<br/>print(name?.count ?? 0)</span></pre><p id="bad9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意:<code class="fe mz na nb nc b">??</code>操作符(零合并操作符)将在后面解释。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="43a5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.Swift中的强制解包选项</h1><p id="309c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><em class="nd">强制展开</em>如果可选项存在，则返回该值；如果可选项为<code class="fe mz na nb nc b">nil</code>，则触发运行时错误。</p><p id="bdeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是在我们深入到力展开之前，让我们先来看看在没有力的情况下展开可选的可能性。</p><h2 id="4ada" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">如何解开可选的？</h2><p id="c32b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在Swift中有多种方法可以打开可选的。你可以用一句<code class="fe mz na nb nc b">guard</code>陈述:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="1f1f" class="ni md it nc b gy nj nk l nl nm">let name: String? = "Antoine van der Lee"<br/>guard let unwrappedName = name else {<br/>    return<br/>}<br/>print(unwrappedName.count)</span></pre><p id="17e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以使用<code class="fe mz na nb nc b">if let</code>语句:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="7019" class="ni md it nc b gy nj nk l nl nm">let name: String? = "Antoine van der Lee"<br/>if let unwrappedName = name {<br/>    print(unwrappedName.count)<br/>}</span></pre><p id="d4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以使用双问号运算符，也称为nil合并运算符。这将返回可选值(如果存在)或默认值(在本例中定义为零):</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="48ff" class="ni md it nc b gy nj nk l nl nm">let name: String? = "Antoine van der Lee"<br/>print(name?.count ?? 0)</span></pre><h2 id="c576" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">使用感叹号(！idspnonenote)强制打开可选的。)</h2><p id="c9ad" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可以直接在可选值后使用感叹号(<code class="fe mz na nb nc b">!</code>)强制展开可选值。</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="a657" class="ni md it nc b gy nj nk l nl nm">var name: String? = "Antoine van der Lee"<br/>print(name!.count)</span></pre><p id="d2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每当上述示例中的name变量被设置为<code class="fe mz na nb nc b">nil</code>时，都会导致如下致命的运行时错误:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="686f" class="ni md it nc b gy nj nk l nl nm">Fatal error: Unexpectedly found nil while unwrapping an Optional value</span></pre><h2 id="8797" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">解包可以连锁</h2><p id="4eb5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">可选链接可以这样完成:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="f783" class="ni md it nc b gy nj nk l nl nm">struct BlogPost {<br/>    let title: String?<br/>}<br/><br/>let post: BlogPost? = BlogPost(title: "Learning everything about optionals")<br/>print(post?.title?.count ?? 0)</span></pre><p id="9c9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">强制解包选项的计数相同:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="3003" class="ni md it nc b gy nj nk l nl nm">let post: BlogPost? = BlogPost(title: "Learning everything about optionals")<br/>print(post!.title!.count)</span></pre><p id="fffc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是要注意，如果你只打开最后一个可选的，你仍然会得到一个可选的。</p><p id="81c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的例子中，我们只打开了标题，而没有打开文章。这意味着如果帖子是<code class="fe mz na nb nc b">nil</code>的话，我们仍然得不到标题:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="b00b" class="ni md it nc b gy nj nk l nl nm">let post: BlogPost? = BlogPost(title: "Learning everything about optionals")<br/>print(post?.title!.count) // Prints: Optional(35)</span></pre><h2 id="f633" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">选项作为最佳实践，强制展开以捕捉编程错误</h2><p id="342b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最佳实践是在默认情况下使用选项，如果不需要就不要使用感叹号。有些人甚至建议启用<a class="ae ky" href="https://github.com/realm/SwiftLint/blob/master/Source/SwiftLintFramework/Rules/Idiomatic/ForceUnwrappingRule.swift" rel="noopener ugc nofollow" target="_blank">强制展开SwiftLint规则</a>。这将防止您引入许多意外的崩溃。</p><p id="cb54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，如果一个值是<code class="fe mz na nb nc b">nil</code>，当它是一个编程错误时，有时使用强制展开也是好的。因此，您可以通过强制解包并在早期捕获bug来帮助自己进行调试。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1957" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.可选的是两种情况的枚举</h1><p id="afcb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">很高兴知道可选的基本上是两种情况的列举:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="608f" class="ni md it nc b gy nj nk l nl nm">enum Optional&lt;Wrapped&gt; {<br/>    /// The absence of a value.<br/>    case none<br/><br/>    /// The presence of a value, stored as `Wrapped`.<br/>    case some(Wrapped)<br/>}</span></pre><p id="72a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，您可以使用<code class="fe mz na nb nc b">nil</code>来表示缺少值，而不是使用<code class="fe mz na nb nc b">.none</code>案例。</p><p id="0e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住这一点，您也可以使用enum将上面的name变量定义为可选变量:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="781d" class="ni md it nc b gy nj nk l nl nm">let name = Optional.some("Antoine van der Lee")<br/>print(name!.count)</span></pre><p id="1dfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，您可以像使用普通枚举一样切换可选的:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="2103" class="ni md it nc b gy nj nk l nl nm">func printName(_ name: String?) {<br/>    switch name {<br/>    case .some(let unwrappedValue):<br/>        print("Name is \(unwrappedValue)")<br/>    case .none:<br/>        print("Name is nil")<br/>    }<br/>}<br/><br/>printName(nil) // Prints: "Name is nil"<br/>printName("Antoine van der Lee") // Prints: "Name is Antoine van der Lee"</span></pre><p id="d1a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且查看它的<a class="ae ky" href="https://developer.apple.com/documentation/swift/optional" rel="noopener ugc nofollow" target="_blank">文档</a>，你可以看到一个可选的附带了一些方便的方法。一个很好的例子是<code class="fe mz na nb nc b">map</code>方法:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="3486" class="ni md it nc b gy nj nk l nl nm">let sideLength: Int? = Int("20")<br/>let possibleSquare = sideLength.map { $0 * $0 }<br/>print(possibleSquare) // Prints: "Optional(400)"</span></pre><p id="c464" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者是<code class="fe mz na nb nc b">flatMap</code>方法，在这种情况下，只有通过了至少包含五个字符的验证，才会返回名称:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="8066" class="ni md it nc b gy nj nk l nl nm">var name: String? = "Antoine van der Lee"<br/>let validName = name.flatMap { name -&gt; String? in<br/>    guard name.count &gt; 5 else { return nil }<br/>    return name<br/>}<br/>print(validName) // Prints: "Optional("Antoine van der Lee")"</span></pre><h2 id="6480" class="ni md it bd me nn no dn mi np nq dp mm li nr ns mo lm nt nu mq lq nv nw ms nx bi translated">扩展选项</h2><p id="aeb8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在你知道一个可选的被定义为一个枚举，你可以猜测你也可以为它写扩展！</p><p id="eecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最常见的例子是扩展一个可选的<code class="fe mz na nb nc b">String</code>并处理一个空值:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="467a" class="ni md it nc b gy nj nk l nl nm">extension Optional where Wrapped == String {<br/>    var orEmpty: String {<br/>        return self ?? ""<br/>    }<br/>}<br/><br/>var name: String? = "Antoine van der Lee"<br/>print(name.orEmpty) // Prints: "Antoine van der Lee"<br/>name = nil<br/>print(name.orEmpty) // Prints: ""</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dc34" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.编写可选的单元测试</h1><p id="49ec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">当你写测试的时候，有一个很好的方法来处理选项而不需要强制解包。如果您使用强制解包，您将冒导致致命错误的风险，这将阻止您的所有测试成功。</p><p id="70a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以使用<code class="fe mz na nb nc b">XCTUnwrap</code>，如果可选选项不包含值，它将抛出一个错误:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="4c9e" class="ni md it nc b gy nj nk l nl nm">func testBlogPostTitle() throws {<br/>    let blogPost: BlogPost? = fetchSampleBlogPost()<br/>    let unwrappedTitle = try XCTUnwrap(blogPost?.title, "Title should be set")<br/>    XCTAssertEqual(unwrappedTitle, "Learning everything about optionals")<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4441" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">4.任择议定书方法</h1><p id="418d" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果您有使用Objective-C的经验，您可能会错过可选协议方法。</p><p id="0a65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管在Swift中有更好的方法来编写可选协议方法，但标准库中最常见的方法是这样的:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="4ea9" class="ni md it nc b gy nj nk l nl nm">protocol UITableViewDataSource : NSObjectProtocol {<br/><br/>    optional func numberOfSections(in tableView: UITableView) -&gt; Int<br/><br/>    // ...<br/>}</span></pre><p id="a236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这允许您使用问号来调用方法:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="7eb3" class="ni md it nc b gy nj nk l nl nm">let tableView = UITableView()<br/>let numberOfSections = tableView.dataSource?.numberOfSections?(in: tableView)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1f73" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">5.嵌套期权是一种东西</h1><p id="2be4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">尽管<a class="ae ky" href="https://github.com/apple/swift-evolution/blob/master/proposals/0230-flatten-optional-try.md" rel="noopener ugc nofollow" target="_blank"> SE-0230 —展平“尝试”产生的嵌套选项</a>去掉了嵌套可选的一个最常见的原因，它还是一个东西！</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="5ef3" class="ni md it nc b gy nj nk l nl nm">var name: String?? = "Antoine van der Lee"<br/>print(name!!.count)</span></pre><p id="1afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你已经解开了一个可选的，它仍然返回一个可选的。在早期的Swift版本中，当您使用<code class="fe mz na nb nc b">try?</code>操作符时，通常就是这种情况。</p><p id="c3fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的例子是当您使用包含可选值的词典时:</p><pre class="kj kk kl km gt ne nc nf ng aw nh bi"><span id="f4a1" class="ni md it nc b gy nj nk l nl nm">let nameAndAges: [String:Int?] = ["Antoine van der Lee": 28]<br/>let antoinesAge = nameAndAges["Antoine van der Lee"]<br/>print(antoinesAge) // Prints: "Optional(Optional(28))"<br/>print(antoinesAge!) // Prints: "Optional(28)"<br/>print(antoinesAge!!) // Prints: "28"</span></pre><p id="ac08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到，它基本上只需要你使用一个额外的感叹号或问号。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="259a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="9961" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">就是这样！我们介绍了在Swift中使用选件时您需要了解的许多事情。从使用感叹号(<code class="fe mz na nb nc b">!!</code>)展开可选元素的基础到扩展<code class="fe mz na nb nc b">Optional</code>枚举的更高级实现。</p></div></div>    
</body>
</html>