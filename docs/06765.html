<html>
<head>
<title>10 Tips to Run Swift From Your Terminal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从您的终端运行Swift的10个技巧</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/10-tips-to-run-swift-from-your-terminal-b5832cd9cd8c?source=collection_archive---------3-----------------------#2020-11-03">https://betterprogramming.pub/10-tips-to-run-swift-from-your-terminal-b5832cd9cd8c?source=collection_archive---------3-----------------------#2020-11-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4f67" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">“swift”、“swiftc”和“lldb”</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/14f40324360b59df04b2b37e99bcc9f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MYlpfyiFReVGaBtp"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">伊利亚·巴甫洛夫在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时候写一段Swift代码，我都懒得启动Xcode。从终端运行Swift命令<code class="fe lv lw lx ly b">swift</code>和<code class="fe lv lw lx ly b">swiftc</code>更加轻量和方便。为了调试和设置断点，<code class="fe lv lw lx ly b">lldb</code>完成了这项工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="d3c2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">1.获取swift版本的“Swift”命令</h1><p id="2791" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">从<a class="ae ky" href="https://swift.org/download/" rel="noopener ugc nofollow" target="_blank">下载</a>页面安装最新版本的Swift后，我将运行命令来验证我运行的是预期的Swift版本:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="4779" class="nh mh it ly b gy ni nj l nk nl">$ swift --version</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/4f93842a9efc5014c2494947991dd613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qbcsE2pz1qbLyhXlPk4cfw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift版本</p></figure><ul class=""><li id="1b62" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">它显示我目前使用的是Swift 5.3</li><li id="fdcd" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">Swift/Objective-C编译器版本为12</li><li id="ddb5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">Swift环境是64位CPU上的MacOS Catalina</li></ul></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="9ba4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">2.运行Swift文件的Swift命令</h1><p id="f491" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我们使用<code class="fe lv lw lx ly b">vi</code>编辑器来编写我们的第一个Swift文件<code class="fe lv lw lx ly b">Foo.swift</code>以打印出<code class="fe lv lw lx ly b">“Hello world!”</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c7a4" class="nh mh it ly b gy ni nj l nk nl">$ vi Foo.swift</span></pre><p id="b318" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记下<code class="fe lv lw lx ly b">foo()</code>功能，并执行它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/0bb7d31400a84488f62eba0a8249d8f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dINR2rWfESZ-aZMz6Gicpg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">' Foo.swift '</p></figure><p id="4b5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行该文件，我们使用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0374" class="nh mh it ly b gy ni nj l nk nl">$ swift Foo.swift</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/dad25e6829a807c5fc123ac835a725da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpN3kAMLMtEWKB89oC9cFA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行Swift文件</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="2fa5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">3.使用参数运行Swift文件</h1><p id="c49f" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated"><code class="fe lv lw lx ly b">CommandLine</code>枚举是Swift标准库的一部分，用于提供命令行参数。我们使用<code class="fe lv lw lx ly b">CommandLine.arguments</code>来获得<code class="fe lv lw lx ly b">swift</code>命令后的参数。</p><p id="0cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要打印出<code class="fe lv lw lx ly b">“Hello, Foo!”</code>消息，代码是:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/eaa67f220fa5be45f450c7796fb656a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9NKfAxz8Gr8ZzYpzPP-hQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带参数的“Foo.swift”</p></figure><p id="3972" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行带参数的文件，我们使用:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d805" class="nh mh it ly b gy ni nj l nk nl">$ swift Foo.swift Foo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/6e04e8b83baa005638df397151e6cf3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUG4EWZ32VXlZkzIQA5rOQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">使用参数运行Swift文件</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="abff" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">4.使用“swiftc”制作可执行文件</h1><p id="f662" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在Swift的世界里，让Swift文件可执行有两个步骤:<code class="fe lv lw lx ly b">compile</code>和<code class="fe lv lw lx ly b">link</code>。</p><ul class=""><li id="0d74" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">我们用<code class="fe lv lw lx ly b">compile</code>Swift文件(<code class="fe lv lw lx ly b">.swift</code>)来产生对象文件(<code class="fe lv lw lx ly b">.o</code>)。</li><li id="02e1" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">我们<code class="fe lv lw lx ly b">link</code>把目标文件生成可执行文件。</li></ul><p id="3d82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建可执行的Swift文件的最简单方法是一个命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a4ea" class="nh mh it ly b gy ni nj l nk nl">$ swiftc Foo.swift</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/5a640dacb8ad46292cf05b67c0a58b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SlRFTBgaHPC5L4SPYuufIQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Foo '可执行文件</p></figure><p id="d4ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要运行可执行文件，我们使用以下命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d7fc" class="nh mh it ly b gy ni nj l nk nl">$ ./Foo Foo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/7550f3369e6927102bb77899ccea36c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vt1FUb1tQB7yftK73SLYKw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行可执行文件</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6dd8" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">5.使用“swiftc”制作目标文件</h1><p id="0b86" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">目标文件(<code class="fe lv lw lx ly b">.o</code>)是源代码(<code class="fe lv lw lx ly b">.swift</code>)的机器代码表示。它是根据源代码编译的，但还不能运行。</p><p id="7ae4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，如果源文件依赖于一个系统库或另一个源文件，那么目标文件就需要链接到编译后的代码。</p><p id="9e4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了生成目标文件(<code class="fe lv lw lx ly b">.o</code>)，我们使用<code class="fe lv lw lx ly b">-c</code>标志通知编译器只进行编译并跳过链接:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="98b8" class="nh mh it ly b gy ni nj l nk nl">$ swiftc -c Foo.swift</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/d42cb42333297c0ab382fdbd09bc5f51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iJxermzWS78e71ujGL2KXw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Foo.o '</p></figure><p id="c1c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了指定输出对象的文件名，我们使用了<code class="fe lv lw lx ly b">-o</code>标志:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="71d8" class="nh mh it ly b gy ni nj l nk nl">$ swiftc -c Foo.swift -o Main.o</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/2c5f51ddb32d5233738b8bec12917d12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5RsIyCAt0qch6gAfPnI97w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">主界面</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="385d" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">6.将多个目标文件链接到模块</h1><p id="90a7" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">将代码写入不同的文件以保持一个干净的结构是相当常见的。每个文件编译成目标文件后，我们需要把它们链接在一起，组成可执行模块。</p><p id="5d4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们创建另一个名为<code class="fe lv lw lx ly b">Event.swift</code>的Swift文件来保存我们计划要做的所有事件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="dd86" class="nh mh it ly b gy ni nj l nk nl">$ vi Event.swift</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ceace8d04474fd06187ef4c7206c0419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnCOohWzn8u16WJv7wT59w.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">' Event.swift '</p></figure><p id="75ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后更新<code class="fe lv lw lx ly b">Foo.swift</code>文件，以便能够打印出消息<code class="fe lv lw lx ly b">“Hello Foo! Let’s go to the Gym!”</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/c03d18318e581c05d795d524b452f37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3V908cpZnnmaiWbn1mYAqQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">“Foo.swift”与事件</p></figure><p id="95e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了编译和链接这两个文件，我们需要将<code class="fe lv lw lx ly b">Foo.swift</code>重命名为<code class="fe lv lw lx ly b">main.swift</code>，因为<code class="fe lv lw lx ly b">main.swift</code>是唯一允许我们在顶层放置可执行表达式<code class="fe lv lw lx ly b">foo()</code>的地方。</p><p id="8f63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要重命名它，我们使用<code class="fe lv lw lx ly b">mv</code>命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="75c6" class="nh mh it ly b gy ni nj l nk nl">$ mv Foo.swift main.swift</span></pre><p id="9640" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件夹中现在有两个Swift文件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="bb06" class="nh mh it ly b gy ni nj l nk nl">.<br/>|- main.swift<br/>|- Event.swift</span></pre><p id="764a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要将源代码编译到模块中，我们可以使用以下命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="5f80" class="nh mh it ly b gy ni nj l nk nl">$ swiftc -c main.swift Event.swift -module-name Foo</span></pre><ul class=""><li id="d535" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">-c</code>标志指定源文件</li><li id="f013" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">-module-name</code>告诉编译器源代码正在组成一个名为<code class="fe lv lw lx ly b">Foo</code>的模块</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/b1a3ab8299b505af144a330dc1269d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1czPc-wG6qurT0bHa-23TA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">编译多个文件</p></figure><p id="dd2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们需要链接目标文件来创建可执行模块:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="301d" class="nh mh it ly b gy ni nj l nk nl">$ swiftc -emit-executable main.o Event.o -o Foo</span></pre><ul class=""><li id="f8f6" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">这里，我们传递两个而不是一个目标文件</li><li id="f593" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">我们通过使用<code class="fe lv lw lx ly b">-o</code>标志指定可执行输出文件将是<code class="fe lv lw lx ly b">Foo</code></li></ul><p id="8fd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目录现在看起来像这样:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b96c" class="nh mh it ly b gy ni nj l nk nl">.<br/>|- main.swift<br/>|- Event.swift<br/>|- main.o<br/>|- Event.o<br/>|- Foo</span></pre><p id="b637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运行我们的可执行文件并查看结果:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="168c" class="nh mh it ly b gy ni nj l nk nl">$ ./Foo Foo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/a6f93ce4b1822669b27f41c68f19f8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SbzwVrwHFByDfdHNb33DBw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行“Foo”可执行文件</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="47f4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">7.编译Swift文件时导入框架</h1><p id="0eff" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当我们将iOS或macOS框架<code class="fe lv lw lx ly b">import</code>到Swift文件时，我们也可以从终端使用<code class="fe lv lw lx ly b">swiftc</code>命令。</p><p id="8575" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将以下代码添加到<code class="fe lv lw lx ly b">MyView.swift</code>中，并创建一个带有自定义框架的<code class="fe lv lw lx ly b">UIView</code>实例:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a73b" class="nh mh it ly b gy ni nj l nk nl">import UIKit</span><span id="2535" class="nh mh it ly b gy ok nj l nk nl">func createView() -&gt; UIView {</span><span id="79ee" class="nh mh it ly b gy ok nj l nk nl">let view = UIView(frame: CGRect(x:0,y:0,width:200,height:200))</span><span id="fa86" class="nh mh it ly b gy ok nj l nk nl">return view</span><span id="0468" class="nh mh it ly b gy ok nj l nk nl">}</span><span id="46ec" class="nh mh it ly b gy ok nj l nk nl">let view = createView()</span><span id="9a81" class="nh mh it ly b gy ok nj l nk nl">print(view)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/2b0d0f483b2644cf1c71eb57c4ab0355.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yW2ZCVmbgMVp_gYSMazlDw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe lv lw lx ly b">'MyView.swift'</code></p></figure><p id="4f40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用下面的命令来编译<code class="fe lv lw lx ly b">MyView.swift</code>文件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="9f73" class="nh mh it ly b gy ni nj l nk nl">$ swiftc -c MyView.swift -o MyView.o -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS14.1.sdk -target arm64-apple-ios14.1</span></pre><ul class=""><li id="b4b0" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">-c</code>标志表示编译下面的源文件</li><li id="d656" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">-o</code>指定输出文件名</li><li id="bc57" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">-sdk</code>是导入框架所在的源。对于这个示例，它是Xcode SDKs文件夹中的<code class="fe lv lw lx ly b">iPhoneOS14.1.sdk</code>。</li><li id="74b3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">然后我们使用<code class="fe lv lw lx ly b">-target</code>标志来指定它运行在ARM64设备(iPhone/iPad)的iOS 14.1上</li></ul><p id="4dc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们使用<code class="fe lv lw lx ly b">-emit-executable</code>标志将目标文件链接到可执行文件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="b656" class="nh mh it ly b gy ni nj l nk nl">$ swiftc -emit-executable MyView.o -sdk /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS14.1.sdk  -target arm64-apple-ios14.1</span></pre><p id="7243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目录中的文件如下:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="989f" class="nh mh it ly b gy ni nj l nk nl">.<br/>|- MyView.swift<br/>|- MyView.o<br/>|- MyView</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ace5" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">8.创建可执行包的Swift命令</h1><p id="1fb1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为了创建可执行的Swift包，我们运行以下命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7de3" class="nh mh it ly b gy ni nj l nk nl">$ swift package init --type executable</span></pre><p id="0944" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">包的基本结构是自动生成的:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0906" class="nh mh it ly b gy ni nj l nk nl">.<br/>|- Package.swift<br/>|- README.md<br/>|- .gitignore<br/>|- Sources<br/>    |- Package<br/>        |- main.swift<br/>|- Tests<br/>    |- LinuxMain.swift<br/>    |- PackageTests<br/>        |- PackageTests.swift<br/>        |- XCTestManifests.swift</span></pre><ul class=""><li id="3999" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">Package.swift</code>是每个包裹的入口</li><li id="6b6f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">自动生成了两个目标:<code class="fe lv lw lx ly b">Package</code>和<code class="fe lv lw lx ly b">PackageTests</code></li><li id="d981" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">Package</code>目标包含<code class="fe lv lw lx ly b">main.swift</code>，这意味着它是可执行的</li><li id="cdc4" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">文件夹是我们测试的地方。每个目标都有自己的文件夹。</li><li id="4fa5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">Sources</code>文件夹是代码存放的地方。每个模块目标都有一个文件夹。</li><li id="9c98" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">executable modules</code>和<code class="fe lv lw lx ly b">library modules</code>由<code class="fe lv lw lx ly b">main.swift</code>文件区分</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/a9bfedb567fd908e0a86f06472eb18f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1sDdYNpOKT9yrQAajoK8Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Swift包裹</p></figure><p id="f08f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要构建、运行和测试包，我们只需使用以下命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7251" class="nh mh it ly b gy ni nj l nk nl">$ swift build<br/>$ swift run<br/>$ swift test</span></pre><ul class=""><li id="b7dc" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b">swift build</code>将解析、下载并编译包清单文件中提到的任何依赖项。然后，它将构建指定的目标依赖项(如果有的话)，最后是目标本身。</li><li id="1633" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">至于构建阶段，因为我们只有一个目标，所以我们可以省略它的名字。完整的命令是<code class="fe lv lw lx ly b">$ swift run package</code>。</li><li id="f315" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">最好总是运行所有的测试。如果我们只想运行一个子集，<code class="fe lv lw lx ly b">swift test</code>命令提供了一个<code class="fe lv lw lx ly b">--filter</code>标志来完成这个任务。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/0c90a05d7a10f30986c8436dbfd1b649.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uupi4NGxB1E9xbcPW2_SVw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">快速构建运行和测试</p></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c7df" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">9.斯威夫特·REPL用斯威夫特做实验</h1><p id="ff61" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">斯威夫特read代表交互式<em class="on">阅读-评估-打印-循环</em> <strong class="lb iu">。</strong>这是另一种尝试Swift的方式。要开始，启动终端应用程序，并键入<code class="fe lv lw lx ly b">swift</code>:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d81f" class="nh mh it ly b gy ni nj l nk nl">$ swift</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oo"><img src="../Images/515dbb632394e0c20858182706e0a479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4f9ALxKTM_oCnB3xdxZrWg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">斯威夫特·REPL</p></figure><p id="c41a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需输入Swift代码，就能看到它编译并运行:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="479c" class="nh mh it ly b gy ni nj l nk nl">1&gt; let name = "Foo"<br/>name: String = "Foo"<br/>2&gt; print(name)<br/>Foo</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/66714f369b15c57bf49f387de858a46c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gGlhzmIBiWkmrUkkFvpVwA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">REPL代码示例</p></figure><p id="76c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要退出REPL，请使用以下命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cf9e" class="nh mh it ly b gy ni nj l nk nl">1&gt; :quit</span></pre></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="3416" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">10.使用LLDB调试器</h1><p id="829d" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">LLDB是macOS上Xcode中的默认调试器，支持在桌面和iOS设备上调试C、Objective-C、C++和Swift。</p><p id="83ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于样本<code class="fe lv lw lx ly b">main.swift</code>文件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="d270" class="nh mh it ly b gy ni nj l nk nl">func foo() {</span><span id="495f" class="nh mh it ly b gy ok nj l nk nl">let name = CommandLine.arguments[1]</span><span id="1570" class="nh mh it ly b gy ok nj l nk nl">print("Hello \(name)! Let's go to the \(Event.gym.rawValue)!")</span><span id="53ce" class="nh mh it ly b gy ok nj l nk nl">}</span><span id="5391" class="nh mh it ly b gy ok nj l nk nl">foo()</span></pre><p id="48c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以及相关的<code class="fe lv lw lx ly b">Event.swift</code>文件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="6351" class="nh mh it ly b gy ni nj l nk nl">enum Event: String {</span><span id="3358" class="nh mh it ly b gy ok nj l nk nl">case gym = "Gym"</span><span id="5cd7" class="nh mh it ly b gy ok nj l nk nl">case golf = "Golf"</span><span id="0ca2" class="nh mh it ly b gy ok nj l nk nl">}</span></pre><p id="3d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<code class="fe lv lw lx ly b">-g</code>标志和<code class="fe lv lw lx ly b">swiftc</code>命令来生成包含调试信息的可执行文件。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="8272" class="nh mh it ly b gy ni nj l nk nl">$ swiftc -g main.swift Event.swift</span></pre><p id="4af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文件在以下文件夹中生成:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="c9ae" class="nh mh it ly b gy ni nj l nk nl">.<br/>|- main.swift<br/>|- Event.swift<br/>|- main.dSYM<br/>|- main</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/285c81814cd764c602a41cc960bb90df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*De7zNqP8t1IYT0OkmJ-gzQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">带'-g '标志的Swiftc</p></figure><p id="2cbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用LLDB调试器运行主要的可执行文件:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="7940" class="nh mh it ly b gy ni nj l nk nl">$ lldb main Foo</span></pre><p id="8c06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它将启动交互控制台运行<code class="fe lv lw lx ly b">lldb</code>命令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/905490fa482209c1542772d96dba2f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lNmb-FcipMaBeLYrpXWxXQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">交互式控制台</p></figure><p id="eda7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在第三行设置断点…</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="2061" class="nh mh it ly b gy ni nj l nk nl">3: print("Hello \(name)! Let's go to the \(Event.gym.rawValue)!")</span></pre><p id="14a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">…我们使用break ( <code class="fe lv lw lx ly b">b</code>)命令:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1a85" class="nh mh it ly b gy ni nj l nk nl">(lldb) b 3</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/4c4d5d25a1030024bf1f730abc64bcf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XD9JXJQSa5ZXDgLzQxz1uA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">断点</p></figure><p id="9706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们用run ( <code class="fe lv lw lx ly b">r</code>)命令运行这个过程。该过程将在断点(第3行)处停止，并等待另一个命令。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="0cb1" class="nh mh it ly b gy ni nj l nk nl">(lldb): r</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/b8f44a33c17df3047e8324aabf8299f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQt8cxl0VZr_jkaqAzveEw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">运行流程</p></figure><p id="018d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了打印出<code class="fe lv lw lx ly b">name</code>的值，我们使用print ( <code class="fe lv lw lx ly b">p</code>)命令。</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="a145" class="nh mh it ly b gy ni nj l nk nl">(lldb): p </span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/0a97a0201b91bf4190f3e18bb2a03359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tBV9_QUUNRpDHMilnC9tg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">打印值</p></figure><p id="e549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以使用continue ( <code class="fe lv lw lx ly b">c</code>)命令来恢复进程，使用breakpoint-disable ( <code class="fe lv lw lx ly b">br di</code>)命令来禁用所有断点。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="34ee" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">结论</h1><p id="d934" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">Swift命令是从终端编译和运行Swift代码的一种强大而轻量级的方式。当我们验证概念时，甚至当我们开发项目时，它们都很方便。</p><p id="b4d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。上面提到的所有代码都可以在这个<a class="ae ky" href="https://github.com/ericleiyang/SwiftCommandsDemo" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中找到。</p></div></div>    
</body>
</html>