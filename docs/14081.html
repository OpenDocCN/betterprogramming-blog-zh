<html>
<head>
<title>How to Create a Figma-like Infinite Canvas in WebGL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在WebGL中创建类似Figma的无限画布</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-create-a-figma-like-infinite-canvas-in-webgl-8be94f65674f?source=collection_archive---------1-----------------------#2022-11-03">https://betterprogramming.pub/how-to-create-a-figma-like-infinite-canvas-in-webgl-8be94f65674f?source=collection_archive---------1-----------------------#2022-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ae03" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何做一个简单的2D相机投影来模拟一个无限的画布的初级读本</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/24187297cbf5bd1519c7589b79daf724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y8aMr8e00dRhoOhY"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">由<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kv" href="https://unsplash.com/@theshubhamdhage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Shubham Dhage </a>拍摄的照片</p></figure><p id="5ee7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无限画布是你能给用户的最美的体验之一。互联网的好处之一是我们可以创造在现实世界中不可能获得的体验。您可以在Blender中构建任意宽任意远的3D模型，而不受现实世界的任何空间限制。</p><p id="d3b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，无限画布并不是新发明。3D工具已经有很长时间了，游戏引擎和其他创作工具也是如此。如果我们选择接受它，我们的挑战是将我们需要的来自这些现有工具的想法合并起来，并构建我们自己的简化版本。</p><h1 id="a7e6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基础</h1><p id="f555" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了做到这一点，我们需要首先了解什么是三维投影。无限画布背后的思想是，有一个世界(所有物体都放在那里)，有一个相机(相机只是世界的投影)。用户看到的就是相机投射的东西。用户可以在摄像机周围随意移动。这样，世界可以存在于看似无限的空间中，你可以沿着x-y轴的正负走向无限。如果需要，您可以限制相机只显示一个区域，但是如果您愿意，您也可以允许在画布上进行无限的探索。</p><p id="c332" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于3D投影来说，这样做的方式很吸引人，但是对于我们来说，实现投影矩阵可能有点大材小用。由于我们是在类似Figma的画布上模拟2D世界，我们的数学看起来简单多了，只需要记住一些几何概念。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/07681f542104944cea20c982a5b7bb71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59IngIJ4xqwC629qD89APA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">摄像机在画布上对某个区域的投影</p></figure><p id="9cb6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的例子中，我们的相机是z轴上的一个点，它总是指向我们的x-y平面。我们可以通过将相机限制在某些z值来控制允许的缩放比例。我们的画布可以在x轴和y轴上无限延伸。</p><p id="c3ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们需要找到我们的初始投影。这意味着我们需要找到最初放置相机的位置。我们只想在浏览器上投射足够的画布。如果用户看不到画布，就没有必要在画布上绘制更多的内容。所以我们将使用浏览器屏幕的长宽比。</p><p id="7553" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了得出我们的方程，让我们试着在画布上画一个区域。我们将从在x-y平面上从(0，0)到(屏幕宽度，屏幕高度)投影画布开始。让我们试着想想把相机放在哪里，这样我们就能看到这个区域了。相机的x和y坐标很简单。我们将把它们放在投影的中间，向下看。所以x和y坐标是(屏幕宽度/ 2，屏幕高度/ 2)。</p><p id="4534" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了放置我们相机的z坐标，我们需要设置一个常数，这个常数将保持不变，与变焦或相机的位置无关。这个常数就是摄像机的角度。我们将保持30度，但我们也可以用不同的值进行实验。</p><p id="6f68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们知道了我们的角度，我们就有可能找到相机的高度。但在此之前，让我们先复习一些简单的几何概念</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/6368076ba51df193ea58e8663bac4684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_V2itBQ3Mn7U3Eiio4_a3w.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">计算摄像机高度的图表</p></figure><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="cbb4" class="mw lt iq ms b gy mx my l mz na">tan θ is also called as <strong class="ms ir">law of tangent</strong>. The tangent formula for a right-angled triangle can be defined as the ratio of the opposite side of a triangle to the adjacent side.</span><span id="f2a5" class="mw lt iq ms b gy nb my l mz na">Tan(θ) = (ScreenWidth / 2) / z<br/>z = ScreenWidth / (2 * Tan(θ))</span></pre><p id="ad4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦我们有了这个公式，我们就可以放置摄像机。每当我们移动摄像机，我们就可以用上面的公式计算出投影矩形的宽度。一旦你算出了宽度，我们就可以推导出浏览器屏幕的长宽比。我们希望保持相同纵横比的原因是，我们不想绘制超出用户所能看到的内容。</p><h1 id="432b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">履行</h1><p id="855b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然我们已经了解了无限画布的2D投影背后的主要概念，我们可以进入实现阶段了。在我们进入状态管理和逻辑之前，让我们对我们正在构建的东西建立期望。我们想测试一些东西-</p><ul class=""><li id="6b70" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">我们应该放大和缩小画布，看到更多的画布</li><li id="8e50" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">我们应该能够左右移动相机，看到画布的不同部分</li></ul><p id="8a3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了测试这些东西，这是我们能做的最简单的概念证明，它将测试我们所有的条件-</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/2f757bf807c469f258d69336cb4ca777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2I8aLs5sR2_BaACI7pTCvg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">我们计划的预期产出。它是一个由许多颜色组成的网格，每个块上都有文字</p></figure><p id="b615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个想法是，我们在每个块的中间画一堆不同颜色和不同文字的块。我们最初将相机设置在画布的中间，然后当我们缩放和滚动时，我们可以看到我们无限的画布在运动。</p><p id="d0fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将使用Pixi.js作为我们的WebGL库来进行绘制，但是绘制的确切框架并不重要。状态管理和逻辑可以用任何库和语言来理解和实现。一旦奠定了基础，它就可以随处使用。</p><pre class="kg kh ki kj gt mr ms nr bn ns nt bi"><span id="04fc" class="nu lt iq ms b be nv nw l nx na">import { Application, Container, Graphics, Text } from "pixi.js";<br/>// Listener that will host our zoom and strafe camera actions<br/>const wheelListener = (e: Event) =&gt; {<br/>  e.preventDefault();<br/>  e.stopPropagation();<br/>};<br/>// Listener to keep track of our pointer. Used for accurate zoom<br/>const pointerListener = (event: PointerEvent) =&gt; {<br/>  CanvasStore.movePointer(event.offsetX, event.offsetY);<br/>};<br/>class App {<br/>  // Draws blocks with texts in the middle of them<br/>  private drawCanvas() {<br/>    const container = new Container();<br/>    const colors = [<br/>      0xf1f7ed, 0x61c9a8, 0x7ca982, 0xe0eec6, 0xc2a83e, 0xff99c8, 0xfcf6bd,<br/>      0x9c92a3, 0xc6b9cd,<br/>    ];<br/>    const texts = [<br/>      "Infinite",<br/>      "Canvases",<br/>      "Are",<br/>      "Easy",<br/>      "When",<br/>      "You",<br/>      "Know",<br/>      "The",<br/>      "Fundamentals",<br/>    ];<br/>    const rectW = 500;<br/>    const rectH = 500;<br/>    for (let i = 0; i &lt; 9; i++) {<br/>      const block = new Container();<br/>      const randomColor = colors[i];<br/>      const bg = new Graphics();<br/>      const leftOffset = (i % 3) * rectW;<br/>      const topOffset = Math.floor(i / 3) * rectH;<br/>      bg.beginFill(randomColor);<br/>      bg.drawRect(leftOffset, topOffset, rectW, rectH);<br/>      bg.endFill();<br/>      block.addChild(bg);<br/>      const textElement = new Text(texts[i], {<br/>        fontSize: 10,<br/>        fill: 0x000000,<br/>        fontWeight: "700",<br/>        wordWrap: false,<br/>      });<br/>      textElement.anchor.set(0.5);<br/>      textElement.position.set(leftOffset + block.width / 2, topOffset + block.height / 2);<br/>      block.addChild(textElement);<br/>      container.addChild(block);<br/>    }<br/>    return container;<br/>  }<br/>  attach(root: HTMLElement) {<br/>    const app = new Application({<br/>      width: document.body.clientWidth,<br/>      height: document.body.clientHeight,<br/>      backgroundColor: 0xffffff,<br/>      resolution: 2,<br/>      antialias: true,<br/>      autoDensity: true,<br/>    });<br/>    root.appendChild(app.view);<br/>    const canvas = this.drawCanvas();<br/>    app.stage.addChild(canvas);<br/>    root.addEventListener("mousewheel", wheelListener, { passive: false });<br/>    root.addEventListener("pointermove", pointerListener, {<br/>      passive: true,<br/>    });<br/>  }<br/>  detach(root: HTMLElement) {<br/>    root.removeEventListener("mousewheel", wheelListener);<br/>    root.removeEventListener("pointermove", pointerListener);<br/>  }<br/>}<br/>// Loading and Unloading logic for our app<br/>let _app: App | null;<br/>window.onload = () =&gt; {<br/>  _app = new App();<br/>  _app.attach(document.body);<br/>};<br/>window.onbeforeunload = () =&gt; {<br/>  if (_app) _app.detach(document.body);<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/05e6d7e9e993a48d1cc26cec16e570d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NpWKrhXDL63MrfOpmzmgqg.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在没有投影和滚动/缩放的情况下，我们当前的输出是什么样的</p></figure><h2 id="c036" class="mw lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">状态管理</h2><p id="adfe" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们现在已经画出了我们的画布，但我们无法欣赏它所有的辉煌。我们既不能滚动也不能放大。这是因为我们还没有设置我们的摄像机，所以让我们从这开始。现在，我们将保留一个名为CanvasStore的单例，它保存我们的逻辑和相机状态。根据应用程序的规模和需求，我们可以将所有这些迁移到更好的结构中，但这不是概念验证所必需的。</p><pre class="kg kh ki kj gt mr ms nr bn ns nt bi"><span id="aa8d" class="nu lt iq ms b be nv nw l nx na">interface CanvasState {<br/>  pixelRatio: number; // our resolution for dip calculations<br/>  container: {   //holds information related to our screen container<br/>    width: number;<br/>    height: number;<br/>  };<br/>  camera: {  //holds camera state<br/>    x: number;<br/>    y: number;<br/>    z: number;<br/>  };<br/>}<br/>export const getInitialCanvasState = (): CanvasState =&gt; {<br/>  return {<br/>    pixelRatio: window.devicePixelRatio || 1,<br/>    container: {<br/>      width: 0,<br/>      height: 0,<br/>    },<br/>    camera: {<br/>      x: 0,<br/>      y: 0,<br/>      z: 0,<br/>    },<br/>  };<br/>};<br/>const radians = (angle: number) =&gt; {<br/>  return angle * (Math.PI / 180);<br/>};<br/>export const CAMERA_ANGLE = radians(30);<br/>export const RECT_W = 500;<br/>export const RECT_H = 500;<br/>export default class CanvasStore {<br/>  private static get data() {<br/>    if (!canvasData) canvasData = {<br/>    pixelRatio: window.devicePixelRatio || 1,<br/>    pixelsPerFrame: 1,<br/>    container: {<br/>      width: 0,<br/>      height: 0,<br/>    },<br/>    pointer: {<br/>      x: 0,<br/>      y: 0,<br/>    },<br/>    canvas: {<br/>      width: 0,<br/>      height: 0,<br/>    },<br/>    camera: {<br/>      x: 0,<br/>      y: 0,<br/>      z: 0,<br/>    },<br/>  };<br/>    return canvasData;<br/>  }<br/>static initialize(width: number, height: number) {<br/>    const containerWidth = width;<br/>    const containerHeight = height;<br/>    canvasData = getInitialCanvasState();<br/>    canvasData.pixelRatio = window.devicePixelRatio || 1;<br/>    canvasData.container.width = containerWidth;<br/>    canvasData.container.height = containerHeight;<br/>    canvasData.camera.x = 1.5 * RECT_W;<br/>    canvasData.camera.y = 1.5 * RECT_H;<br/>    canvasData.camera.z = containerWidth / (2 * Math.tan(CAMERA_ANGLE));<br/>  }<br/>public static get screen() {<br/>    const { x, y, z } = this.camera;<br/>    const aspect = this.aspect;<br/>    const angle = radians(30);<br/>    return cameraToScreenCoordinates(x, y, z, angle, aspect);<br/>  }<br/>public static get camera() {<br/>    return this.data.camera;<br/>  }<br/>public static get scale() {<br/>    const { width: w, height: h } = CanvasStore.screen;<br/>    const { width: cw, height: ch } = CanvasStore.container;<br/>    return { x: cw / w, y: ch / h };<br/>  }</span></pre><p id="242d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面代码块中的一个重要概念是<code class="fe ok ol om ms b">initialize</code>方法，它设置了以下值</p><ul class=""><li id="44e8" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">如果需要，存储我们的<code class="fe ok ol om ms b">pixelRatio</code>进行密度独立像素计算</li><li id="124d" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">存储浏览器上画布元素的高度和宽度(目前是整个文档体，但可以是任意大小)</li><li id="b07f" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">计算并设置我们的初始摄像机位置。它在我们9个街区的中间。每个块的尺寸为<code class="fe ok ol om ms b">RECT_W</code> x <code class="fe ok ol om ms b">RECT_H</code>。在这篇文章的开始，我们已经列出了相机高度的公式</li></ul><p id="0d19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一个重要的概念是这个函数<code class="fe ok ol om ms b">cameraToScreenCoordinates</code>，我们还没有讲到。这个函数的工作方式是，它获取相机坐标、相机角度、容器纵横比，并向我们返回用户可见的无限画布部分。因此，我们可以只显示这个函数的返回值指定的矩形，用户将看到摄像机看到的内容。</p><pre class="kg kh ki kj gt mr ms nr bn ns nt bi"><span id="8e36" class="nu lt iq ms b be nv nw l nx na">export const cameraToScreenCoordinates = (<br/>  x: number,<br/>  y: number,<br/>  z: number,<br/>  cameraAngle: number,<br/>  screenAspect: number<br/>) =&gt; {<br/>  const width = 2 * z * Math.tan(CAMERA_ANGLE);<br/>  const height = width / screenAspect;<br/>  const screenX = x - width / 2;<br/>  const screenY = y - height / 2;<br/>return { x: screenX, y: screenY, width, height };<br/>};</span></pre><h2 id="fab2" class="mw lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">整合摄像机投影</h2><p id="c01b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们已经设置了逻辑和状态，我们需要将它连接到我们的显示代码，以便我们只看到和绘制要显示给用户的摄像机投影。我们这样做的方法是，我们必须重写我们上面使用的<code class="fe ok ol om ms b">attach</code> <strong class="ky ir"> <em class="on"> </em> </strong>函数。现在看起来是这样的:</p><pre class="kg kh ki kj gt mr ms nr bn ns nt bi"><span id="bb63" class="nu lt iq ms b be nv nw l nx na">attach(root: HTMLElement) {<br/>    CanvasStore.initialize(<br/>      document.body.clientWidth,<br/>      document.body.clientHeight<br/>    );<br/>    const app = new Application({<br/>      width: document.body.clientWidth,<br/>      height: document.body.clientHeight,<br/>      backgroundColor: 0xffffff,<br/>      resolution: 2,<br/>      antialias: true,<br/>      autoDensity: true,<br/>    });<br/>    root.appendChild(app.view);<br/>    const canvas = this.drawCanvas();<br/>    app.stage.addChild(canvas);<br/>    app.ticker.add(() =&gt; {<br/>      const { x, y } = CanvasStore.screen;<br/>      const scale = CanvasStore.scale;<br/>      canvas.position.set(-scale.x * x, -scale.y * y);<br/>      canvas.scale.set(scale.x, scale.y);<br/>    });<br/>    root.addEventListener("mousewheel", wheelListener, { passive: false });<br/>    root.addEventListener("pointermove", pointerListener, {<br/>      passive: true,<br/>    });<br/>  }</span></pre><p id="e8eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经在应用程序开始时初始化了我们的存储，每一帧，我们都在重新定位我们的应用程序，将<code class="fe ok ol om ms b">CanvasStore.screen</code> <strong class="ky ir"> <em class="on"> </em> </strong>提到的区域移动到(0，0)和(屏幕宽度，屏幕高度)。</p><p id="6935" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在，基于比例和位置，只有相机投影对用户可见。我们还可以添加一个遮罩，只根据屏幕大小来绘制部分，但这是留给用户的练习。</p><h2 id="9268" class="mw lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">用锚点实现滚动和缩放</h2><p id="3d2f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们已经设置了我们的显示和状态，我们可以进入本教程最重要和最有趣的部分——让事物移动。无限画布的全部好处是可以到处乱搞和移动。让我们来看看我们将放在<code class="fe ok ol om ms b">CanvasStore</code>中的滚动函数:</p><pre class="kg kh ki kj gt mr ms nr bn ns nt bi"><span id="ec28" class="nu lt iq ms b be nv nw l nx na">public static moveCamera(mx: number, my: number) {<br/>    const scrollFactor = 1.5;<br/>    const deltaX = mx * scrollFactor;<br/>    const deltaY = my * scrollFactor;<br/>    const { x, y, z } = this.camera;<br/>    this.data.camera.x += deltaX;<br/>    this.data.camera.y += deltaY;<br/>    // move pointer by the same amount<br/>    this.movePointer(deltaY, deltaY);<br/>  }<br/>public static movePointer(deltaX: number, deltaY: number) {<br/>    const scale = this.scale;<br/>    const { x: left, y: top } = this.screen;<br/>    this.data.pointer.x = left + deltaX / scale.x;<br/>    this.data.pointer.y = top + deltaY / scale.y;<br/>  }</span></pre><p id="17ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里面的逻辑非常简单，我们根据滚动的量来移动摄像机和指针。我们也有一个滚动因子，所以我们可以加快或减缓滚动行为。为什么我们要保持指针的位置？当我们开始实现下一部分——使用锚点滚动时，我们会明白这一点。描述这种行为的最佳方式是展示它</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6f18ea71927203e201745236debca708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*oRSw2JCxpZUbCbSMQ0xtkw.gif"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向指针位置目标缩放(在文本元素处)</p></figure><p id="36a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的放大图中，你可以看到我们检测到用户的指针位置，并确保放大到他们的指针停留的地方。我们这样做的方法是，我们改变比例，但也滚动画布一点点，使指针仍然指向相同的像素。既然我们已经理解了这种行为是如何工作的，我们就可以深入逻辑了:</p><pre class="kg kh ki kj gt mr ms nr bn ns nt bi"><span id="dbf6" class="nu lt iq ms b be nv nw l nx na">const scaleWithAnchorPoint = (<br/>  anchorPointX: number,<br/>  anchorPointY: number,<br/>  cameraX1: number,<br/>  cameraY1: number,<br/>  scaleX1: number,<br/>  scaleY1: number,<br/>  scaleX2: number,<br/>  scaleY2: number<br/>) =&gt; {<br/>  const cameraX2 =<br/>    (anchorPointX * (scaleX2 - scaleX1) + scaleX1 * cameraX1) / scaleX2;<br/>  const cameraY2 =<br/>    (anchorPointY * (scaleY2 - scaleY1) + scaleY1 * cameraY1) / scaleY2;<br/>return { x: cameraX2, y: cameraY2 };<br/>};<br/>public static zoomCamera(deltaX: number, deltaY: number) {<br/>    // Normal zoom is quite slow, we want to scale the amount quite a bit<br/>    const zoomScaleFactor = 10;<br/>    const deltaAmount = zoomScaleFactor * Math.max(deltaY);<br/>    const { x: oldX, y: oldY, z: oldZ } = this.camera;<br/>    const oldScale = { ...this.scale };<br/>const { width: containerWidth, height: containerHeight } = this.container;<br/>    const { width, height } = cameraToScreenCoordinates(<br/>      oldX,<br/>      oldY,<br/>      oldZ + deltaAmount,<br/>      this.cameraAngle,<br/>      this.aspect<br/>    );<br/>    const newScaleX = containerWidth / width;<br/>    const newScaleY = containerHeight / height;<br/>    const { x: newX, y: newY } = scaleWithAnchorPoint(<br/>      this.pointer.x,<br/>      this.pointer.y,<br/>      oldX,<br/>      oldY,<br/>      oldScale.x,<br/>      oldScale.y,<br/>      newScaleX,<br/>      newScaleY<br/>    );<br/>    const newZ = oldZ + deltaAmount;<br/>    this.data.camera = {<br/>      x: newX,<br/>      y: newY,<br/>      z: newZ,<br/>    };<br/>  }</span></pre><p id="4c86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在可以将它集成到上面定义的滚轮处理程序中:</p><pre class="kg kh ki kj gt mr ms nr bn ns nt bi"><span id="ded6" class="nu lt iq ms b be nv nw l nx na">const wheelListener = (e: Event) =&gt; {<br/>  e.preventDefault();<br/>  e.stopPropagation();<br/>  const friction = 1;<br/>  const event = e as WheelEvent;<br/>  const deltaX = event.deltaX * friction;<br/>  const deltaY = event.deltaY * friction;<br/>  if (!event.ctrlKey) {<br/>    CanvasStore.moveCamera(deltaX, deltaY);<br/>  } else {<br/>    CanvasStore.zoomCamera(deltaX, deltaY);<br/>  }<br/>};</span></pre><p id="127f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">做完这些，我们终于可以看看我们无限画布的输出了。我们从第五块中间的摄像机开始，我们滚动、缩小和放大文本几次，以显示它是如何一起工作的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/4522e99a7ae9bef300a86e94f34fd860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aPUJhRWwD09cXe_f_xkYfA.gif"/></div></figure><h1 id="d513" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="5256" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是关于如何做一个简单的2D相机投影来模拟一个无限的画布的初级读本。剩下的唯一事情就是把东西放在无限的画布上，这个相机系统理论上应该能够容纳和显示任意数量的内容，这取决于用例。我一直对有Canvas接口的creator工具很着迷，很好奇想看看别人上来的是什么。</p><p id="bf2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这个教程，并希望看到更多这样的内容，请喜欢，分享和评论，也许我会做一些更复杂的深入项目。前进，建造东西。</p></div></div>    
</body>
</html>