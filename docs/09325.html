<html>
<head>
<title>Git Merge vs. Git Rebase Workflow: Which Is Better?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git合并与Git Rebase工作流:哪个更好？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/git-merge-vs-git-rebase-workflow-which-is-better-47511fba0a6a?source=collection_archive---------5-----------------------#2021-08-11">https://betterprogramming.pub/git-merge-vs-git-rebase-workflow-which-is-better-47511fba0a6a?source=collection_archive---------5-----------------------#2021-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9937" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">以及为什么我们的团队选择合并而不是重置基础</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d307cac036435d589190abb700700fc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wW0UnpWhXsvath67"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">阿克塞尔·瓦兹奎在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1c11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近我在工作中进行了一次讨论:我们开始了一个新项目，一个新团队，和一个新的git库。每个开发人员开发一个特性分支，这个分支将被同事们评审，用来自<code class="fe lv lw lx ly b">main</code>分支的最新变化进行更新，并最终包含在<code class="fe lv lw lx ly b">main</code>中。那么，我们可以使用什么过程来充分利用git呢？</p><p id="7d4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们讨论的两个选项是关于合并和重定基础的工作流。在这篇文章中，我捕捉到了一些我们曾经有过的争论，并阐明了这些工作流的优势。</p><p id="8007" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">已经有<a class="ae ky" href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" rel="noopener ugc nofollow" target="_blank">资源可以比我更好地解释合并和重定基础</a>，所以我将总结这些资源，并为讨论差异和优势打下基础。最后，我将分享为什么我们的团队决定使用合并而不是重定基础，以及为什么你可能会为你的项目做出不同的决定。</p><p id="5208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是让我们首先提醒自己，在合并和重定基数的过程中到底发生了什么。</p><h1 id="3c83" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">合并要素分支</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mr"><img src="../Images/3f0c308725fe92f098086bdcb8c34f3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PCMQuwXiCRzibo72pjOr2Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将特征分支合并回干管之前和之后</p></figure><p id="85f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您<code class="fe lv lw lx ly b">git merge</code>您的特性分支时，您创建了一个单独的合并提交(上图中的C5)。这在提交之间创建了一个偏序。就我们而言，C4和C3之间没有直接关系。从非数学的角度来说，git历史不会假设哪个提交先出现。</p><h1 id="90ba" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">重置基础干线</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ms"><img src="../Images/186a3cad4e144d90b0e5cf3d40bfce90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTrDFBpe0cEF2gtFFf-TNQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将特征重置为主特征之前和之后</p></figure><p id="378e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当重置基础时，你实际上做了两件事:首先，你<code class="fe lv lw lx ly b">git rebase</code>在<code class="fe lv lw lx ly b">main</code>之上的特征分支，然后你<code class="fe lv lw lx ly b">git merge</code>特征分支进入<code class="fe lv lw lx ly b">main</code>。</p><p id="7970" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该合并是所谓的<a class="ae ky" href="https://git-scm.com/docs/git-merge#_fast_forward_merge" rel="noopener ugc nofollow" target="_blank">快进合并</a>，因此不需要创建合并提交。与基于合并的工作流相比，我们在<code class="fe lv lw lx ly b">main</code>中以完全线性的git历史结束。C4出现在C3面前，因为他们是按到达梅恩的时间顺序排列的。</p><h1 id="e180" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将更新合并到要素分支中</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/f3d5405cde713ce6829314ddbd094837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nMkLeiMcZD0g0i5ZuH5sKA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将主分支合并到特征分支之前和之后</p></figure><p id="5bce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您处理您的特征分支时，您周围的世界不会停止。<code class="fe lv lw lx ly b">main</code>分支可能已经转移了，您想在您的特性分支中包含最新的变化。</p><p id="a647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b">git merge main</code>您将完全做到这一点，这一次在您的特性分支上创建一个合并提交C5。任何冲突通常都将作为合并提交的一部分得到解决。</p><h1 id="2697" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">将特征分支重置到主分支上</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mu"><img src="../Images/68fb385281dee2386e92114aa9b97e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6Lgn9wXKMFe--a2g2zCZA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将特征支管重设基础之前和之后</p></figure><p id="0946" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将最新的<code class="fe lv lw lx ly b">main</code>修改为<code class="fe lv lw lx ly b">git rebase</code>很简单，因为这是将基础修改为<code class="fe lv lw lx ly b">main</code>的第一步。不过，有一个问题。</p><p id="cba6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为特性分支中的提交被重定了基，所以提交散列将会改变(这就是为什么在图中它现在被称为<code class="fe lv lw lx ly b">C3`</code>，而之前它是<code class="fe lv lw lx ly b">C3</code>)。这本身没关系，但是如果有其他东西引用了<code class="fe lv lw lx ly b">C3</code>，你就有麻烦了。</p><p id="6718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要在远程存储库上推送更新的特性分支，您需要强制推送您的更改，这可能会覆盖同时进行的其他更改。</p><h1 id="6015" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">重定基数的优势</h1><p id="6ca6" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">重置基础归结为两件事:首先，您允许“重写”特征分支的历史。当您将您的特性分支重置到最新的main上时，您的更改的提交散列将会改变。</p><p id="53ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能还需要修复冲突，这些修复将包含在您过去的提交中。这使得更改接近解释它们的提交消息。</p><p id="a582" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na"> git rebase允许你重写特性分支的历史。</em></p><p id="241b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你开始重写你的git提交(使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" rel="noopener ugc nofollow" target="_blank">git commit --amend</a></code> <a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" rel="noopener ugc nofollow" target="_blank">或</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" rel="noopener ugc nofollow" target="_blank">git rebase -i</a></code>，你也将有机会重写和完善你的提交消息。Chris Beams 提供了一个明确的关于编写良好提交消息的指南。但是没有人是完美的，我不期望任何人第一次就能得到正确的提交消息。现在，我们刚刚为自己赢得了一个改善它们的机会。对于代码评审来说更是如此。</p><p id="b201" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在原始提交本身中进行这些更改，而不是用“地址注释”或“修复测试”这样的消息在提交后创建提交。</p><p id="c10c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二，当你更新<code class="fe lv lw lx ly b">main</code>时，你把你的历史串联成一个线性顺序。一旦变更在<code class="fe lv lw lx ly b">main</code>中，所有提交就有了一个总的顺序。我阅读历史的<code class="fe lv lw lx ly b">main</code>方式是滚动和搜索日志。</p><p id="3f74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当提交被序列化时，这就简单多了。当我查看一个提交时，我知道在那个提交之前的每一个提交都到达了之前的<code class="fe lv lw lx ly b">main</code>，以及在那个提交之后的所有内容。</p><p id="1474" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一个小陷阱，提交是按照它们到达<code class="fe lv lw lx ly b">main</code>的时间排序的，而不是按照创建的时间，这可能是不同的。我从来不太关注创建时间，但是如果你的工作流依赖于它，那么你至少要小心。</p><p id="d696" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">git rebase在main中生成了一个很好的序列化历史。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/555dcde07fd5b60ff15dfe304bdc9b4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbW_rtW6wgvkEzyjcjW31Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">git日志，带有rebase工作流(左)和合并工作流(右)</p></figure><p id="5698" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你遵循<a class="ae ky" href="https://kevincox.ca/2020/08/15/git-green-ci/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">保持主绿</strong> </a>的规则时，调整基线也是很自然的事情。</p><p id="c44e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总之，不是在您的分支上运行CI测试，然后合并，而是在<code class="fe lv lw lx ly b">main</code>之上重新调整您的变更，运行测试，并在成功时合并。这是用自动化机器人最容易做到的，如<a class="ae ky" href="https://bors.tech/" rel="noopener ugc nofollow" target="_blank"> Bors </a>或<a class="ae ky" href="https://github.com/smarkets/marge-bot" rel="noopener ugc nofollow" target="_blank"> Marge </a>。</p><p id="5d30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用rebase工作流的最后一个优点是，它消除了大量的合并提交，这些提交会使历史变得混乱，并且很难看出为什么代码被更改了。</p><p id="09f2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我在VS代码中使用GitLens，当我不太明白一段代码在做什么时，我会寻找commit消息作为指导。我最不希望看到的就是一个“合并分支‘特征-xzy’”作为我唯一的参考。</p><h1 id="60b8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">重置基础时的一句警告</h1><p id="f32d" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">重定基础有一个重要的警告，以至于Atlassian称之为<a class="ae ky" href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" rel="noopener ugc nofollow" target="_blank">黄金法则</a> : <strong class="lb iu">不要重定公共分支</strong>。</p><p id="64fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对此，我反驳道:你什么时候想把一个部门上市？在他们的例子中，公共分支是一个被推到远程存储库的分支。他们是对的，如果你将你的特性转移到<code class="fe lv lw lx ly b">main</code>上，而其他人正在处理它，这将导致一个难以解决的混乱。</p><p id="4fae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这真的取决于你的团队、公司或一般贡献者之间的合作规则。如果没有人编辑您的特征分支，除非他们明确地与您协调，那么不会发生任何不好的事情。</p><p id="4dc1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我以前用过这种设置，从来没有遇到过问题。如果其他人依赖于它，它也鼓励快速地将变化带入<code class="fe lv lw lx ly b">main</code>。</p><p id="64d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na">不要改变或重写你合作的分支机构的历史。</em></p><p id="2ec5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这延伸到另一个用例。如果您有一个长期运行的特性分支，并且您开始基于它创建子特性分支，那会怎么样呢？</p><p id="1931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我的建议是:不要这样做。</p><p id="16fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你将花费越来越多的时间来更新你的所有分支，而不是写代码。但是让我们假设你发现自己处于这种情况。当您将特征分支重置到<code class="fe lv lw lx ly b">main</code>上时，会发生以下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/bcc664508865115c9530611b03768c46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FvbKCmiDrHpbdlicwXIYkg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">重置具有特征分支的特征分支</p></figure><p id="8239" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，子特性分支仍然引用了被放弃的提交C3。那么，如果您将子特性分支重置到<code class="fe lv lw lx ly b">main</code>上会发生什么呢？</p><p id="dc22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不幸的是，这要看情况。如果C3和C3 '有完全相同的变化，git会很好地解决这个问题，并且特性分支会看起来像这个<code class="fe lv lw lx ly b">C4 -&gt; C3` -&gt; C5` -&gt; C6</code>。</p><p id="8596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你不得不在<code class="fe lv lw lx ly b">main</code>的基础上解决冲突。你以<code class="fe lv lw lx ly b">C4 -&gt; C3` -&gt; C5` -&gt; C3 -&gt; C6</code>结束。您可以使用<a class="ae ky" href="https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" rel="noopener ugc nofollow" target="_blank">交互式重定基础</a>来删除某些提交来解决这个问题，但是这很复杂，需要对git有深入的了解。</p><p id="91f4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们回到我的建议:尽可能避免它！</p><h1 id="349a" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">合并的优势</h1><p id="7ad4" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">从重定基础的陷阱中，让我们迅速转向合并的优势。通过合并，您可以保留准确的提交。</p><p id="0194" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它鼓励您不要在您的特征分支中重写历史。相反，您总是在其上添加新的提交或合并提交。</p><p id="7588" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na">当你从不改变特性分支中的git历史时，git合并工作得很好。</em></p><p id="e3ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不需要一条金科玉律来告诉你不要做什么，它让分支机构之间的合作变得更加容易。</p><p id="88c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您将永远不需要强制向上游推送，因此您不会覆盖其他人的更改。如果您的同事在没有与您协调的情况下对您的特征分支进行更改，这一点很重要。这是否有用真的取决于你如何合作。</p><p id="c6e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">合并在审查拉取请求时也非常有效。如果您总是添加到您的功能分支，您可以通过提交来查看PR。</p><p id="9a7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第一次审阅和后续更改之后，您可以只审阅自那以后发生的更改。在重写提交的工作流中，这是不可能的。</p><p id="5efa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na">GitHub上的评论最好使用基于合并的工作流</em></p><p id="d03f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GitHub还提供了一种非常有用的方式来评论浏览器界面中的pull请求。这些注释在提交时连接到文件中的一个行号。</p><p id="ff22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为rebase重写了分支中的提交散列，所以注释变成了悬空指针，引用了不再存在的提交。</p><p id="4bc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您使用merge来更新您的分支时，您的注释会一直指向它们所引用的代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/f31506f2d44d1bf1498108d02fc68f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQnrB_lqIfdX3EoW0qL2cQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">引用提交中某行的注释。换个底就没了！</p></figure><p id="1164" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与重定基础不同，基于合并的流程具有较少的缺陷。我已经提到了它是如何避免重定基础的黄金法则的需要的。</p><p id="5fa4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个警告是关于特征分支的。我建议不要这样做，这仍然有效，但是至少对于基于合并的流程来说是有效的，并且您不会以重复提交而告终。</p><p id="8f15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且陷阱更少，您和您的团队可以遵循工作流，而不需要对git有很深的理解。</p><h1 id="b211" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">从这里去哪里</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/ca529fd700e9ea507965568fd580952f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LpJ6v7ZSX9SGNaHE"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@rosiefoto13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rosie Steggles </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="15d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们看到了两种方法的优点，那么“使用哪种工作流”的问题就变成了对你、你的团队和你的组织来说什么更重要。</p><p id="2d4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个开发人员都从事他们自己的功能分支，还是其他人也参与其中？变化进入<code class="fe lv lw lx ly b">main</code>的速度有多快？你有多重视有描述性提交的干净历史？你从GitHub的公关评论功能中获得了多少？</p><p id="9acb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="na">我们使用基于rebase的合并，因为我们想让公关审查尽可能简单。</em></p><p id="a9d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们的团队决定采用基于合并的工作流程，因为我们希望让公关审查尽可能简单。</p><p id="fd89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将更改合并到<code class="fe lv lw lx ly b">main</code>中，因为它是GitHub中的默认设置。当您处理您的功能时，每个开发人员可以选择他们喜欢的工作流，直到他们创建一个PR。然后我们总是把<code class="fe lv lw lx ly b">main</code>并入其中。</p><p id="e7dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它类似于Atlassian的黄金法则，但我们将public定义为“我们为它创建了一个PR。”由于我们目前是一个小团队，我们通过只允许包含最新<code class="fe lv lw lx ly b">main</code>和通过CI的合并来保持<code class="fe lv lw lx ly b">main</code>绿色。这不是一个可以扩展的东西，但它是一座我们必须跨越的桥梁。</p><h1 id="8dbb" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">两全其美？</h1><p id="36ea" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">你可能会问自己，为什么我们一定要选择其中一个，或者我们可以两者兼得？</p><p id="cd1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我能想到一种结合两种优势的方法。您在开发和代码审查时使用基于合并的工作流，并且您可以增量地这样做——而无需重写历史。</p><p id="8c40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦准备好进入<code class="fe lv lw lx ly b">main</code>，你就可以把所有的事情都压缩到一个提交中，你可以把它快进到main中。快进会阻止合并提交，从而产生一个连续的git历史记录。</p><p id="1562" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在最后的挤压过程中，您还可以进行最后的检查来润色您的提交信息。不幸的是，在大多数团队中，倾向于至少有一个人强烈反对压制pr，这种讨论为单独的帖子提供了足够的材料。</p><p id="7671" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还没有调查GitHub和GitLab或bors之类的机器人对此的支持程度。</p><h1 id="b6f5" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">最后的想法</h1><p id="bbb3" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">这种比较没有确定的赢家；这完全取决于您希望如何在存储库中进行协作。现在，您知道了要问什么问题，以及为您的团队找到最佳工作流程需要做哪些权衡。</p><h2 id="aded" class="nf ma it bd mb ng nh dn mf ni nj dp mj li nk nl ml lm nm nn mn lq no np mp nq bi translated">资源</h2><ul class=""><li id="322e" class="nr ns it lb b lc mv lf mw li nt lm nu lq nv lu nw nx ny nz bi translated"><a class="ae ky" href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" rel="noopener ugc nofollow" target="_blank"> Atlassian比我更好地解释了git合并和rebase的技术细节</a></li><li id="ce6c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://git-scm.com/doc" rel="noopener ugc nofollow" target="_blank">git参考与书籍</a></li><li id="4ce3" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://chris.beams.io/posts/git-commit/" rel="noopener ugc nofollow" target="_blank"> Chris Beams提交消息终极指南</a></li><li id="ba29" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://kevincox.ca/2020/08/15/git-green-ci/" rel="noopener ugc nofollow" target="_blank">保持主绿色</a></li><li id="5f8f" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://blog.acolyer.org/2019/04/18/keeping-master-green-at-scale/" rel="noopener ugc nofollow" target="_blank">优步关于保持绿色的博文</a></li><li id="bd15" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://bors.tech/" rel="noopener ugc nofollow" target="_blank">用于GitHub的Bors合并机器人</a></li><li id="213c" class="nr ns it lb b lc oa lf ob li oc lm od lq oe lu nw nx ny nz bi translated"><a class="ae ky" href="https://github.com/smarkets/marge-bot" rel="noopener ugc nofollow" target="_blank">git lab的Marge合并机器人</a></li></ul></div></div>    
</body>
</html>