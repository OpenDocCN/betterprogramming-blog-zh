<html>
<head>
<title>Understanding the MutationObserver API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解变异观察器API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-mutationobserver-api-f9ac9f93d1a2?source=collection_archive---------12-----------------------#2022-05-20">https://betterprogramming.pub/understanding-the-mutationobserver-api-f9ac9f93d1a2?source=collection_archive---------12-----------------------#2022-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9058" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这个浏览器API给了我们一些你应该使用的很酷的特性。这可能看起来很可怕，但我向你保证这不是！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/727166e93e49770a143d8e80ff4b61e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndE1FVeIFoZmFkHSWk2jCw.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">DOM和变异观测器</p></figure><p id="d915" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我在这里描述的<a class="ae lv" rel="noopener ugc nofollow" target="_blank" href="/the-intersectionobserver-b19fca5a194e"/>，在API的工作方式上<code class="fe lr ls lt lu b">MutationObserver</code>很像<code class="fe lr ls lt lu b">IntersectionObserver</code>。除了名称相似之外，这两个API的输出非常不同。大多数大型浏览器都支持<code class="fe lr ls lt lu b">MutationObserver</code>，因此你可以开始利用它的功能。</p><p id="4d06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="lw">那么这是怎么回事呢？</em></p><p id="df37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">DOM的变化！</p><p id="fcbd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这听起来很简单，但它也非常强大。有了这个特性，您可以检测特定的元素是否被插入、删除，或者元素的属性是否发生了变化。</p><p id="ac54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果不使用这个API，相对简单的任务会有很多边缘情况，并且性能可能会根据您的实现而有所不同。使用标准浏览器API可以确保开箱即用的性能和稳定性。</p><h1 id="3b96" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">一些使用案例</h1><ul class=""><li id="338f" class="mp mq iq kx b ky mr lb ms le mt li mu lm mv lq mw mx my mz bi translated">如果一些元素是异步插入的，您希望运行一些代码</li><li id="93de" class="mp mq iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">您希望在单页应用程序中检测到“页面变化”</li><li id="2568" class="mp mq iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">比方说，你不能控制从第三方库中插入的HTML元素</li><li id="03a7" class="mp mq iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">您有一个在站点上实现的第三方库，并且您想知道站点何时在页面上插入某个元素</li></ul><p id="8ac5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后一个例子是我接触API的方式。</p><h1 id="39d5" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">如何使用它</h1><p id="19aa" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">同样，IntersectionObserver API使用起来有点古怪，我们可以很容易地创建一个小的包装器，在我看来，它使使用起来更加流畅。本机实现需要三个参数:</p><ol class=""><li id="6628" class="mp mq iq kx b ky kz lb lc le ni li nj lm nk lq nl mx my mz bi translated">HTML元素(可以是整个正文)</li><li id="1d3c" class="mp mq iq kx b ky na lb nb le nc li nd lm ne lq nl mx my mz bi translated">决定某些细节的配置对象(<a class="ae lv" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe" rel="noopener ugc nofollow" target="_blank">见此处</a>)</li><li id="4e19" class="mp mq iq kx b ky na lb nb le nc li nd lm ne lq nl mx my mz bi translated">一个回调函数，只要API注册了一个符合您的配置参数(1和2)的更改，就会执行该函数</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">变异观测器包装</p></figure><p id="0353" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我将默认配置和元素，以便在上面的包装器中进行检查。这个配置的作用是观察整个文档体的变化。<code class="fe lr ls lt lu b">subtree: true</code>将确保我们查看嵌套的插入或删除。</p><p id="0b03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您已经知道您想在其中寻找变化的子元素，那么给出一个比<code class="fe lr ls lt lu b">document.body</code>更具体的选择器会更有效。<br/>为了简单起见，上面的包装器只需要一个回调函数，只要任何元素发生变化，这个函数就会被触发。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">变异观察器回调函数</p></figure><p id="6adc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能看起来有点嵌套和可怕，但现在不要介意。<br/>上面将检查添加到DOM中的所有节点。如果节点有一个<code class="fe lr ls lt lu b">id=’color-node’</code>，它将等待200ms，并将背景更改为橙色。</p><h2 id="b953" class="no ly iq bd lz np nq dn md nr ns dp mh le nt nu mj li nv nw ml lm nx ny mn nz bi translated">一个例子</h2><p id="583a" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">现在，假设我们是一个第三方库的制作者，该库在将具有特定id的div元素插入站点后，将它们更改为特定的颜色。现在，我们无法控制网站是如何实现的。它可能是一个SPA或者一个WordPress站点。</p><p id="25ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">网站可能会使用自己的JavaScript或其他库来插入元素。</p><p id="a3df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了简单起见，让我们假设站点定期插入一个特定的节点。现在我们的虚拟库将改变插入节点的背景颜色。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oa nn l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">一个简单的实现，在插入元素时改变颜色</p></figure><p id="00be" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的例子中，我模拟站点以500毫秒的间隔插入9个div元素。在现实生活中，这不太可能发生。但这就是<code class="fe lr ls lt lu b">MutationObserver</code>的妙处。每当插入、删除或更改元素时，它都会触发回调函数。</p><p id="6b54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:与<code class="fe lr ls lt lu b">IntersectionObserver</code>一样，当您不再希望订阅DOM中的变化时，使用<code class="fe lr ls lt lu b">disconnect</code>方法很重要。</p><h2 id="4058" class="no ly iq bd lz np nq dn md nr ns dp mh le nt nu mj li nv nw ml lm nx ny mn nz bi translated">SPA URL更改</h2><p id="1ee8" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">在另一个小用例中，我们使用<code class="fe lr ls lt lu b">MutationObserver</code>来检测单页面应用程序中的页面变化。现在，由于他们不做真正的浏览器页面更改，而是使用内部路由，我们的脚本将不会像在“普通”网站上那样被加载和执行。</p><p id="4ef6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe lr ls lt lu b">MutationObserver</code>，我们可以在DOM中寻找变化(SPA路由器的变化),并对照先前的检查<code class="fe lr ls lt lu b">location.href</code>,以确定SPA是否改变了它的视图。在这之后，我们应该重新运行我们的核心代码逻辑。一个简单的例子如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nm nn l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">检测SPA URL中的更改</p></figure><h1 id="fa1f" class="lx ly iq bd lz ma mb mc md me mf mg mh jw mi jx mj jz mk ka ml kc mm kd mn mo bi translated">最终注释</h1><p id="99ec" class="pw-post-body-paragraph kv kw iq kx b ky mr jr la lb ms ju ld le nf lg lh li ng lk ll lm nh lo lp lq ij bi translated">作为一个维护在许多站点上实现的库的人，使用<code class="fe lr ls lt lu b">MutationObserver</code>有助于我们有一个统一的API来处理DOM中的异步插入或删除。</p><p id="62a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，每当站点插入特定的div元素时，我们都需要做出反应。</p><p id="4b3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果一个新的div元素满足一组标准，我们将把我们的“产品”插入到该div元素中。</p><p id="a8b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，因为<code class="fe lr ls lt lu b">MutationObserver</code>在所有插入时触发我们的回调，所以不管客户端是无限滚动来不断添加元素，还是通过单击按钮来添加元素，都没有关系。</p><p id="234e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">再加上<code class="fe lr ls lt lu b">IntersectionObserver</code> API，处理某些DOM的事情超级简单，不需要实现很多定制代码。</p><p id="6465" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这两种API都已经有一段时间了，但我觉得采用率仍然很低。</p><p id="e934" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这可能是因为旧的堆栈溢出答案或它们可怕的名字。</p><p id="4f7a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！敬请关注更多内容。</p></div></div>    
</body>
</html>