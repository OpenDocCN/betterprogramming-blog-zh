<html>
<head>
<title>Essentials of Java’s Time API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java的时间API的要点</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/essentials-of-javas-time-api-b372d9a2903b?source=collection_archive---------12-----------------------#2021-01-07">https://betterprogramming.pub/essentials-of-javas-time-api-b372d9a2903b?source=collection_archive---------12-----------------------#2021-01-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="72d7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JSR310如何改变我们处理日期和时间的方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/19d27a964549989fc5505f21a0f5bad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgyaQlvDrEktKF7Fzj2EQA.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">红色透明玻璃——尼罗河(<a class="ae ky" href="https://pixabay.com/photos/hourglass-time-hours-clock-620397/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>)</p></figure><p id="d971" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多编程语言中，处理日期和时间是一项繁琐的任务。但是有了Java 8，JDK为我们提供了一个全面的、全新的API，改变了我们处理时间相关概念的方式。</p><p id="b7ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管JSR310是在Java 8中引入的，但代码示例将使用Java 10的一个特性，<a class="ae ky" href="https://medium.com/better-programming/local-variable-type-inference-in-java-10-cb4967dd6eb0" rel="noopener">局部变量类型推断</a>，以提高可读性。<br/>不过，代码示例本身都是Java 8兼容的。<br/>代码示例的<code class="fe lv lw lx ly b">// =&gt;</code>部分将显示前一行/变量的<code class="fe lv lw lx ly b">toString()</code>输出。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b2fc" class="md me it ly b gy mf mg l mh mi"><strong class="ly iu">Table of Contents</strong></span><span id="9da7" class="md me it ly b gy mj mg l mh mi"><a class="ae ky" href="#7210" rel="noopener ugc nofollow">Pre-JSR310</a><br/><a class="ae ky" href="#c68f" rel="noopener ugc nofollow">The Java Time API (JSR310)</a><br/><a class="ae ky" href="#b9c4" rel="noopener ugc nofollow">Local Types</a><br/><a class="ae ky" href="#7fbf" rel="noopener ugc nofollow">Time Zones and Offsets</a><br/><a class="ae ky" href="#f824" rel="noopener ugc nofollow">Other Date and Time Types</a><br/><a class="ae ky" href="#a422" rel="noopener ugc nofollow">General API Design</a><br/><a class="ae ky" href="#a1c5" rel="noopener ugc nofollow">Android Support</a><br/><a class="ae ky" href="#0b5a" rel="noopener ugc nofollow">Java Time API for Java 6 and 7</a><br/><a class="ae ky" href="#c931" rel="noopener ugc nofollow">Resources</a></span></pre></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7210" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">JSR310之前的版本</h1><p id="4eaa" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在新的API之前，JDK只提供了几个处理日期和时间的类。</p><p id="430d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是最常见的几种:</p><ul class=""><li id="d5c6" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html" rel="noopener ugc nofollow" target="_blank">java.util.Date</a></code>:精确的时间瞬间，毫秒精度，相对于1970年1月1日00:00:00 GMT</li><li id="cb17" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html" rel="noopener ugc nofollow" target="_blank">java.util.Calendar</a></code>:瞬间时间和日历字段(如月、年、日等)之间的桥梁。)</li><li id="9622" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html" rel="noopener ugc nofollow" target="_blank">java.util.TimeZone</a></code>:负责时区偏移和处理夏令时(DST)</li><li id="d94f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/text/DateFormat.html" rel="noopener ugc nofollow" target="_blank">java.text.DateFormat</a></code>:格式化和解析</li></ul><p id="9f30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">乍一看，这四个似乎涵盖了最常见的场景。</p><p id="88eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，他们真的能够处理日期和时间的所有微妙的专业吗？</p><h2 id="c450" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">毫秒</h2><p id="613a" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">由于<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html" rel="noopener ugc nofollow" target="_blank">java.util.Date</a></code>是基于从Unix时间戳“0”开始的毫秒，我们倾向于认为日期和时间是毫秒的总和:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2f0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用毫秒可能看起来很直观，但最终会导致错误。</p><p id="1f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与时间打交道很有挑战性，因为我们对日期和时间的假设实际上并不正确。我们对日期和时间有许多误解。<a class="ae ky" href="https://twitter.com/davedelong" rel="noopener ugc nofollow" target="_blank">戴夫·德隆</a>正在维护一份<a class="ae ky" href="https://yourcalendricalfallacyis.com/" rel="noopener ugc nofollow" target="_blank">的大型清单</a>，其中附有快速解释。以下是一些错误的假设:</p><ul class=""><li id="1b5f" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">一天有86400秒长</li><li id="4f34" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://yourcalendricalfallacyis.com/#every-day-has-a-midnight" rel="noopener ugc nofollow" target="_blank">每天都有午夜</a></li><li id="3af7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://yourcalendricalfallacyis.com/#timezones-always-are-on-the-hour-mark" rel="noopener ugc nofollow" target="_blank">时区总是在小时刻度上</a></li></ul><p id="7e6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">边缘案例的问题在于，在我们触发它们之前，我们往往意识不到它们的存在。如果我们的代码只在闰年出错，它可能会运行四年。</p><h2 id="d2ac" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">并非一切都是完美的时间点</h2><p id="8b13" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一个<code class="fe lv lw lx ly b">Date</code>代表毫秒精度的单个时间点。但是更广泛的单位呢？</p><p id="c47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2021年1月是星期几？1月6日是几点？</p><p id="cd68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了一个点之外，我们需要能够表示不同的日期和时间概念:</p><ul class=""><li id="b40b" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated">不带时间的日期:2020年12月30日</li><li id="34f7" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">没有日期的时间:12:24</li><li id="8cbe" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">年月:2020年12月</li><li id="d591" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">年份:2020年</li><li id="896a" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">期限:七天</li><li id="5bfe" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">不同的日历系统:日本日历</li><li id="35b5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">更多</li></ul><p id="7e98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些概念必须由我们自己通过代码契约来实现，比如将一个永恒的日期表示为午夜的<code class="fe lv lw lx ly b">java.util.Date</code>。这样的合同使得我们的数据不容易交换，也太容易被破坏。这些边缘情况和考虑因素很容易导致许多不会立即变得明显的错误。</p><h2 id="7c82" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">Joda时间</h2><p id="1faa" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">幸运的是，第三方框架开发了一个更好的日期和时间表示概念，使其成为Java 8之前Java事实上的标准日期和时间库:<a class="ae ky" href="https://www.joda.org/joda-time/" rel="noopener ugc nofollow" target="_blank"> Joda-Time </a>。</p><p id="3742" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，在Java 8中，JDK接受了他们的工作，并基于他们的概念提供了一个新的时间API。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="c68f" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Java时间API (JSR310)</h1><p id="8467" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">为了解决前面提到的缺点，需要一个全新的API。</p><p id="ddcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它是从零开始构建的，Joda-Time的作者Stephen Colebourne共同领导了这项工作。</p><p id="7bc0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其结果是对JDK的一个完整和全面的补充。但是是什么让这个API比它的前身好这么多呢？</p><h2 id="5a47" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">设计目标</h2><p id="b366" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">新API的构建遵循了几个核心原则:</p><p id="95fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果可能的话，每个类型都应该是不可变的。我以前写过关于不可变性的<a class="ae ky" href="https://medium.com/better-programming/functional-programming-with-java-immutability-8dc748e85f9e" rel="noopener">重要性和优点</a>:线程安全，由于没有可变状态而导致的错误更少，并且它对垃圾收集器更友好。</p><p id="e233" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">流畅的API <br/> </strong> <a class="ae ky" href="https://medium.com/better-programming/how-fluent-interfaces-can-lead-to-more-meaningful-code-cb6d947d77bb" rel="noopener">流畅的代码</a>是更容易理解的代码。</p><p id="991b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">清晰、明确、预期<br/> </strong>每种方法都应该定义明确，自成一体，并使其意图显而易见。具有一致的方法名前缀的领域驱动的设计应该导致更清晰和可读性。</p><p id="13f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">可扩展<br/> </strong>即使<a class="ae ky" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank"> ISO 8601 </a>是最常用的日历系统，是新API的主日历系统，也应该对其他人开放。它们应该由应用程序开发人员提供，而不仅仅是JDK本身。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="b9c4" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">本地类型</h1><p id="766f" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">新包<code class="fe lv lw lx ly b">java.time.*</code>中有很多不同的类型，每一种都有特定的用途。</p><p id="8fea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们了解不知道时区概念的<code class="fe lv lw lx ly b">Local</code>类型。</p><h2 id="08e1" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.LocalDate</h2><p id="0cc7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">顾名思义，这种类型表示没有时间的无时区日期。只是一天，一月，一年:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ab9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="93b4" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.LocalTime</h2><p id="2dc7" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是一个没有日期或时区偏移的时间。</p><p id="8d1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间的标准定义适用于:一天中的时间，基于24小时制，从午夜开始。</p><p id="a54f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">LocalTime</code>存储小时、分钟、秒和纳秒。尽管该类型支持纳秒精度，但要知道实际精度取决于JVM/JDK实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="905d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="6fde" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.util.LocalDateTime</h2><p id="9b33" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是<code class="fe lv lw lx ly b">LocalDate</code>和<code class="fe lv lw lx ly b">LocalTime</code>的组合。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="dca5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它也可以很容易地降级到它的组成部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="d89a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html" rel="noopener ugc nofollow" target="_blank">文档</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="7fbf" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">时区和时差</h1><p id="5ca8" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">时区和它们的偏移量是每个与时间打交道的人的banes。很多事情都可能(而且通常会)出错。</p><p id="9641" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了减轻处理它们的痛苦，Java Time API将责任分成多个类:</p><ul class=""><li id="c4dc" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html" rel="noopener ugc nofollow" target="_blank">ZoneOffset</a></code>:相对于UTC/GMT时间的偏移量，+14:00到-12:00</li><li id="6bb8" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/zone/ZoneRules.html" rel="noopener ugc nofollow" target="_blank">ZoneRules</a></code>:单个时区的偏移量如何变化的规则(例如，夏令时、历史变化)</li><li id="50a5" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html" rel="noopener ugc nofollow" target="_blank">ZoneId</a></code>:时区标识符，如“欧洲/柏林”</li></ul><p id="f982" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有两种不同的时区类型可供选择:</p><ul class=""><li id="28b3" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html" rel="noopener ugc nofollow" target="_blank">ZonedDateTime</a></code>:绑定到特定的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html" rel="noopener ugc nofollow" target="_blank">ZoneId</a></code></li><li id="eec3" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/OffsetDateTime.html" rel="noopener ugc nofollow" target="_blank">OffsetDateTime</a></code> / <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/OffsetTime.html" rel="noopener ugc nofollow" target="_blank">OffsetTime</a></code>:带有偏移量的日期/时间，但不绑定到特定时区</li></ul><h2 id="a7b0" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">Java . time . offset datetime/Java . time . offset time</h2><p id="213c" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/OffsetDateTime.html" rel="noopener ugc nofollow" target="_blank">OffsetDateTime</a></code>是<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html" rel="noopener ugc nofollow" target="_blank">ZonedDateTime</a></code>的一个简单版本，没有与特定时区的关系，只由它的偏移量定义。这样，它更适合交换格式，比如保存在数据库或JSON/XML中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f686" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/OffesetDateTime.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="ca03" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.ZonedDateTime</h2><p id="5dcd" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">尽管偏移量通常就足够了，但有时我们需要处理特定于时区的数据。对于这样的用例，我们有<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html" rel="noopener ugc nofollow" target="_blank">ZonedDateTime</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="b7e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html" rel="noopener ugc nofollow" target="_blank">文档</a></p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="f824" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">其他日期和时间类型</h1><p id="0be1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">除了日期、时间和日期时间类型之外，新的API还为其他与日期和时间相关的概念提供了特定的类。</p><h2 id="f5ce" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.Instant</h2><p id="7fe4" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" rel="noopener ugc nofollow" target="_blank">Instant</a></code>是最接近我们所拥有的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/util/Date.html" rel="noopener ugc nofollow" target="_blank">java.util.Date</a></code>的等价物。这是一个与时代相关的经典时间戳。默认纪元从Unix时间戳“0”开始(1970-01-01T00:00:00Z，UTC 1970年1月1日午夜开始)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="152d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果提供了缺少的信息，它可以转换为其他类型。例如，要创建一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html" rel="noopener ugc nofollow" target="_blank">LocalDateTime</a></code>，我们需要提供适当的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/ZoneId.html" rel="noopener ugc nofollow" target="_blank">ZoneId</a></code>，这样任何规则，比如DST和offset，都可以应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9d7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="7c5b" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.Duration</h2><p id="4960" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">A <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" rel="noopener ugc nofollow" target="_blank">Duration</a></code>表示基于时间的量(小时、分钟、秒、纳秒)。它可以直接创建，也可以作为其他类型之间的差异来创建:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="4234" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="e8d5" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.Period</h2><p id="a68d" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html" rel="noopener ugc nofollow" target="_blank">Period</a></code>是与基于时间的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" rel="noopener ugc nofollow" target="_blank">Duration</a></code>相对应的基于日期的(年、月、日):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="ab31" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.Year</h2><p id="8552" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">ISO日历中的一年:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e470" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，它只匹配现代年份的公历和儒略历。</p><p id="4e2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，俄罗斯部分地区直到1920年才改用现代公历。此外，多重<a class="ae ky" href="https://en.wikipedia.org/wiki/Gregorian_calendar#Gregorian_reform" rel="noopener ugc nofollow" target="_blank">日历改革</a>可以使历史日期的计算变得复杂。</p><p id="3bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Year.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="1665" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.YearMonth</h2><p id="d889" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">无日日期类型，例如2021年1月:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="e147" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/YearMonth.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="e830" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.MonthDay</h2><p id="cd33" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">日期的无年份表示，例如1月6日:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="73d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该字符串输出可能看起来很奇怪，但它正是ISO 8601:2000定义的，尽管更新后的ISO 8601:2004不允许忽略一年中的一个月。(<a class="ae ky" href="https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates" rel="noopener ugc nofollow" target="_blank">维基百科</a>)</p><p id="6680" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/MonthDay.html" rel="noopener ugc nofollow" target="_blank">文档</a></p><h2 id="6ec8" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">月/日周枚举</h2><p id="4fb2" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">大量错误的另一个来源是关于月份和工作日的一次性错误。</p><p id="bf1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一月用1还是0表示？<br/>12月12日还是11日？</p><p id="3851" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一周什么时候开始？周日还是周一？它们代表了什么价值？</p><p id="3c9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Java Time API是基于ISO 8601的，所以一周总是从星期一开始。为了保持一致，它从值1开始表示星期一和一月。</p><p id="669d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了使它更加有用，我们提供了两个枚举，在大多数方法中它们可以与数值互换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="fcd8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档:</p><ul class=""><li id="4c59" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Month.html" rel="noopener ugc nofollow" target="_blank">java.time.Month</a></code></li><li id="681e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/DayOfWeek.html" rel="noopener ugc nofollow" target="_blank">java.time.DayOfWeek</a></code></li></ul></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a422" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">通用API设计</h1><p id="15d1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">通常，一个有许多新类的API意味着我们必须理解和记住许多新的方法和概念。为了减轻认知负担，API被设计成具有一致的方法名前缀，并在类型之间共享概念。</p><h2 id="0a0b" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">方法名称前缀</h2><p id="2a25" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们可以很容易地探索一个类型的不同功能，只需在开始一个前缀后触发自动完成。</p><p id="79e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">获取</strong></p><p id="b1f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个经典的<em class="oo"> </em> getter，用来检索零件的类型:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="73db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">同</strong></p><p id="3734" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回包含指定更改的副本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f6d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">加/减</strong></p><p id="a8ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回计算结果的副本:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="a287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">乘/除/求反</strong></p><p id="3ca6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html" rel="noopener ugc nofollow" target="_blank">Duration</a></code> / <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/Period.html" rel="noopener ugc nofollow" target="_blank">Period</a></code>的附加计算:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="fe50" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">至</strong></p><p id="2332" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类型之间的转换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">在</strong></p><p id="42f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">返回具有与时间/时区相关的更改的新对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="9369" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">共</strong></p><p id="3dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有转换的静态工厂方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="0f43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">出自</strong></p><p id="ad98" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">带转换的静态工厂方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="8576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，转换仅适用于降级。例如，我们不能从一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html" rel="noopener ugc nofollow" target="_blank">LocalDate</a></code>创建一个<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html" rel="noopener ugc nofollow" target="_blank">LocalDateTime</a></code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="ccd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解析</strong></p><p id="1f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解析文本输入的静态工厂方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="604f" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">解析和格式化</h2><p id="8771" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">基于ISO 8601及其精度，所有类型都有明确定义的<code class="fe lv lw lx ly b">toString()</code>方法:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6c03" class="md me it ly b gy mf mg l mh mi"> TYPE           | FORMAT<br/>----------------|-------------------------------------<br/>LocalDate       | uuuu-MM-dd<br/>LocalTime       | HH:mm<br/>                | HH:mm:ss<br/>                | HH:mm:ss.SSS<br/>                | HH:mm:ss.SSSSSS<br/>                | HH:mm:ss.SSSSSSSSS<br/>LocalDateTime   | uuuu-MM-dd'T'HH:mm<br/>                | uuuu-MM-dd'T'HH:mm:ss<br/>                | uuuu-MM-dd'T'HH:mm:ss.SSS<br/>                | uuuu-MM-dd'T'HH:mm:ss.SSSSSS<br/>                | uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSS<br/>Year            | value without leading zeroes<br/>YearMonth       | uuuu-MM<br/>MonthDay        | --MM-dd<br/>OffesetDateTime | uuuu-MM-dd'T'HH:mmXXXXX<br/>                | uuuu-MM-dd'T'HH:mm:ssXXXXX<br/>                | uuuu-MM-dd'T'HH:mm:ss.SSSXXXXX<br/>                | uuuu-MM-dd'T'HH:mm:ss.SSSSSSXXXXX<br/>                | uuuu-MM-dd'T'HH:mm:ss.SSSSSSSSSXXXXX<br/>OffestTime      | HH:mm:ssXXXXX<br/>                | HH:mm:ss.SSSXXXXX<br/>                | HH:mm:ss.SSSSSSXXXXX<br/>                | HH:mm:ss.SSSSSSSSSXXXXX<br/>ZonedDateTime   | LocalDateTime + ZoneOffset<br/>ZoneOffset      | Z (for UTC)<br/>                | +h<br/>                | +hh<br/>                | +hh:mm<br/>                | -hh:mm<br/>                | +hhmm<br/>                | -hhmm<br/>                | +hh:mm:ss<br/>                | -hh:mm:ss<br/>                | +hhmmss<br/>                | -hhmmss<br/>Duration        | PT[n]H[n]M[n]S <br/>Period          | P[n]Y[n]M[n]D</span></pre><p id="c4fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由<code class="fe lv lw lx ly b">toString()</code>产生的格式在各自的<code class="fe lv lw lx ly b">parse(CharSequence text)</code>方法中也是可用的，这对于交换方法或非本地化显示来说是很棒的。</p><p id="6374" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于更加人性化和本地化的表示，可以使用类<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html" rel="noopener ugc nofollow" target="_blank">java.time.format.DateTimeFormatter</a></code>。它是线程安全的、不可变的，并提供了流畅的API:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f30d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过为<code class="fe lv lw lx ly b">parse</code>方法提供格式化程序，它也可以用于解析:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="43df" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">java.time.TemporalAdjuster</h2><p id="f6a3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">通过功能接口<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjuster.html" rel="noopener ugc nofollow" target="_blank">TemporalAdjuster</a></code>，我们可以定义如何调整实现<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html" rel="noopener ugc nofollow" target="_blank">Temporal</a></code>的类型的策略。这样，我们可以对新的Java Time API类型进行定义良好的、可重用的调整。</p><p id="0469" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Java Time API通过其实用程序类<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html" rel="noopener ugc nofollow" target="_blank">TemporalAdjusters</a></code>提供了多个预定义的调整器。在API的一般精神中，方法名(大部分)不言自明:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="c5af" class="md me it ly b gy mf mg l mh mi"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#dayOfWeekInMonth-int-java.time.DayOfWeek-" rel="noopener ugc nofollow" target="_blank">dayOfWeekInMonth</a>(int ordinal, DayOfWeek dayOfWeek)</span><span id="2017" class="md me it ly b gy mj mg l mh mi"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#firstDayOfMonth--" rel="noopener ugc nofollow" target="_blank">firstDayOfMonth</a>()<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#firstDayOfNextMonth--" rel="noopener ugc nofollow" target="_blank">firstDayOfNextMonth</a>()<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#firstDayOfNextYear--" rel="noopener ugc nofollow" target="_blank">firstDayOfNextYear</a>()<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#firstDayOfYear--" rel="noopener ugc nofollow" target="_blank">firstDayOfYear</a>()<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#firstInMonth-java.time.DayOfWeek-" rel="noopener ugc nofollow" target="_blank">firstInMonth</a>(DayOfWeek dayOfWeek)</span><span id="d4f8" class="md me it ly b gy mj mg l mh mi"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#lastDayOfMonth--" rel="noopener ugc nofollow" target="_blank">lastDayOfMonth</a>()<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#lastDayOfYear--" rel="noopener ugc nofollow" target="_blank">lastDayOfYear</a>()<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#lastInMonth-java.time.DayOfWeek-" rel="noopener ugc nofollow" target="_blank">lastInMonth</a>(DayOfWeek dayOfWeek)</span><span id="f50f" class="md me it ly b gy mj mg l mh mi"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#next-java.time.DayOfWeek-" rel="noopener ugc nofollow" target="_blank">next</a>(DayOfWeek dayOfWeek)<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#nextOrSame-java.time.DayOfWeek-" rel="noopener ugc nofollow" target="_blank">nextOrSame</a>(DayOfWeek dayOfWeek)</span><span id="162c" class="md me it ly b gy mj mg l mh mi"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#ofDateAdjuster-java.util.function.UnaryOperator-" rel="noopener ugc nofollow" target="_blank">ofDateAdjuster</a>(UnaryOperator&lt;LocalDate&gt; dateBasedAdjuster)</span><span id="60bc" class="md me it ly b gy mj mg l mh mi"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#previous-java.time.DayOfWeek-" rel="noopener ugc nofollow" target="_blank">previous</a>(DayOfWeek dayOfWeek)<br/><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html#previousOrSame-java.time.DayOfWeek-" rel="noopener ugc nofollow" target="_blank">previousOrSame</a>(DayOfWeek dayOfWeek)</span></pre><p id="3ff1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，在基于订阅的应用程序中，我们可以创建像<code class="fe lv lw lx ly b">nextBillingDate(Customer customer)</code>这样的特定于客户的调整器。代码很容易理解，根据客户计算账单日期的逻辑只在一个地方。</p><h2 id="f0bd" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">Java . time . temporal . temporal unit和java.time.temporal.ChronoUnit</h2><p id="5e88" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">接口<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html" rel="noopener ugc nofollow" target="_blank">TemporalUnit</a></code>提供了一种表达日期和时间单位的方法，然后可以在计算中使用。</p><p id="560c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">enum <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html" rel="noopener ugc nofollow" target="_blank">ChronoUnit</a></code>已经提供了最常用的单位，为各种不同的单位提供了常量，如<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MILLENNIA" rel="noopener ugc nofollow" target="_blank">MILLENNIA</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#DAYS" rel="noopener ugc nofollow" target="_blank">DAYS</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#HOURS" rel="noopener ugc nofollow" target="_blank">HOURS</a></code>、<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#MILLIS" rel="noopener ugc nofollow" target="_blank">MILLIS</a></code>等。</p><p id="ded6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">作为参数</strong></p><p id="243b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了具体的计算方法，如<code class="fe lv lw lx ly b">LocalDate <a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html#plusDays-long-" rel="noopener ugc nofollow" target="_blank">plusDays</a>(long daysToAdd)</code>，也有非具体的需要<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalUnit.html" rel="noopener ugc nofollow" target="_blank">TemporalUnit</a></code>的方法，如<code class="fe lv lw lx ly b">LocalDate plus(long amountToAdd, TemporalUnit unit)</code>。</p><p id="7d64" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有的Java时间API计算都将尽最大努力保持合理，并保持在各自的单元和相关的更大的单元内。我们必须把新类型看作不同单元的组合，而不是一个单一的值。</p><p id="e71f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着如果我们给<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html" rel="noopener ugc nofollow" target="_blank">LocalDate</a></code>添加一个月，它将影响它的月份(以及相关的单位，如年份):</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="23fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html" rel="noopener ugc nofollow" target="_blank">ChronoUnit</a></code>也可以轻松计算差异。以<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html" rel="noopener ugc nofollow" target="_blank">LocalDate</a></code>为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="be92" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">静态方法</strong></p><p id="a889" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举值本身也包含两种更易于理解的计算代码的方法:</p><ul class=""><li id="855f" class="nn no it lb b lc ld lf lg li np lm nq lq nr lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#addTo-R-long-" rel="noopener ugc nofollow" target="_blank">&lt;R extends Temporal&gt; R addTo(R temporal, long amount)</a></code></li><li id="644f" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#between-java.time.temporal.Temporal-java.time.temporal.Temporal-" rel="noopener ugc nofollow" target="_blank">long between(Temporal temporal1Inclusive, Temporal temporal2Exclusive)</a></code></li></ul><p id="24da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面的例子也可以用这些方法来表达:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="262f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<code class="fe lv lw lx ly b">static import</code>，它变得更具可读性:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="eef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">持续时间</strong></p><p id="c600" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">枚举常量也可以用ISO日历定义表示为<code class="fe lv lw lx ly b">Duration</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="0d22" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">在类型之间转换</h2><p id="c534" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我们不能只是用一种新类型替换所有的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/7/docs/api/java/util/Date.html" rel="noopener ugc nofollow" target="_blank">java.util.Date</a></code>实例，所以我们需要能够在它们之间进行转换。新方法<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/sql/Date.html#toInstant--" rel="noopener ugc nofollow" target="_blank">java.util.Date#toInstant()</a></code>提供了一种介于新旧之间的车辆。</p><p id="dc07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果提供适当的时区相关数据，可以将<code class="fe lv lw lx ly b">Instant</code>转换为另一种类型:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/a69c34e762ea426ccceeb1d0bfade02e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAJxT6sbN_sbGG_KlEMQtw.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不同Java时间类型的可转换性</p></figure><p id="eb07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相应的代码非常简单明了:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="2a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那里，我们可以使用另一个<code class="fe lv lw lx ly b">to</code>方法来转换它。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="a1c5" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Android支持</h1><p id="3da3" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在过去，许多激动人心的Java 8+新特性需要一段时间才能在Android中实现。我们需要一个第三方框架或后台来使用它们。</p><p id="f955" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于Android Gradle插件4.0，许多Java 8功能可以通过<a class="ae ky" href="https://developer.android.com/studio/write/java8-support#library-desugaring" rel="noopener ugc nofollow" target="_blank">去糖</a>使用，而不需要更高的API级别。虽然需要对<code class="fe lv lw lx ly b">build.gradle</code>和一个新的依赖项进行一些更改:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="7186" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以下是通过去糖化可以获得的所有API的列表:<a class="ae ky" href="https://developer.android.com/studio/write/java8-support-table" rel="noopener ugc nofollow" target="_blank"> Android开发者</a>。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><h1 id="0b5a" class="mr me it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Java 6和7的Java时间API</h1><p id="1c54" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">即使Java 8发布于6年前，2018年3月，也不是每个人都有使用它的奢侈。</p><p id="3774" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是不要绝望。多亏了反向移植，我们仍然可以使用新的API。</p><p id="95b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">ThreeTen Backport项目提供了一种兼容Java 6和7的方式来使用新类型，而不需要额外的依赖。它由Java Time API的主要作者Stephen Colebourne维护。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt lz ly oq bn or os bi"><span id="b518" class="ot me it ly b be ou ov l mh mi"><strong class="ly iu">You like my ramblings about Java?<br/>Check out my upcoming book!<br/></strong><a class="ae ky" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre><h1 id="c931" class="mr me it bd ms mt ow mv mw mx ox mz na jz oy ka nc kc oz kd ne kf pa kg ng nh bi translated">资源</h1><ul class=""><li id="6f95" class="nn no it lb b lc ni lf nj li pb lm pc lq pd lu ns nt nu nv bi translated"><a class="ae ky" href="https://jcp.org/aboutJava/communityprocess/pfd/jsr310/JSR-310-guide.html" rel="noopener ugc nofollow" target="_blank">JCP.org</a>JSR-310日期和时间API指南</li><li id="3b6e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html" rel="noopener ugc nofollow" target="_blank">包java.time </a> (Oracle)</li><li id="de1e" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/ISO_8601" rel="noopener ugc nofollow" target="_blank"> ISO 8601 </a>(维基)</li><li id="b8d6" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated"><a class="ae ky" href="https://www.threeten.org/threetenbp/" rel="noopener ugc nofollow" target="_blank">三十端口</a></li><li id="6655" class="nn no it lb b lc nw lf nx li ny lm nz lq oa lu ns nt nu nv bi translated">你的历法谬误是…(戴夫·德隆)</li></ul><h2 id="b6c8" class="md me it bd ms ob oc dn mw od oe dp na li of og nc lm oh oi ne lq oj ok ng ol bi translated">提及的文章</h2><div class="pe pf gp gr pg ph"><a href="https://medium.com/better-programming/functional-programming-with-java-immutability-8dc748e85f9e" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">Java函数式编程:不变性</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">具有不可变状态的更好的数据结构</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">medium.com</p></div></div><div class="pq l"><div class="pr l ps pt pu pq pv ks ph"/></div></div></a></div><div class="pe pf gp gr pg ph"><a href="https://medium.com/better-programming/how-fluent-interfaces-can-lead-to-more-meaningful-code-cb6d947d77bb" rel="noopener follow" target="_blank"><div class="pi ab fo"><div class="pj ab pk cl cj pl"><h2 class="bd iu gy z fp pm fr fs pn fu fw is bi translated">流畅的界面如何能产生更有意义的代码</h2><div class="po l"><h3 class="bd b gy z fp pm fr fs pn fu fw dk translated">更简单、更安全的对象创建工作流程等等</h3></div><div class="pp l"><p class="bd b dl z fp pm fr fs pn fu fw dk translated">medium.com</p></div></div><div class="pq l"><div class="pw l ps pt pu pq pv ks ph"/></div></div></a></div></div></div>    
</body>
</html>