<html>
<head>
<title>GraphQL vs. Rest API: Data Fetching In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL与Rest API:Python中的数据提取</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/graphql-vs-rest-api-data-fetching-in-python-9df76d8eead7?source=collection_archive---------7-----------------------#2021-08-05">https://betterprogramming.pub/graphql-vs-rest-api-data-fetching-in-python-9df76d8eead7?source=collection_archive---------7-----------------------#2021-08-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2e93" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">两种方法的对比</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9252d84ddeb9b51016a87ddbcbf17de9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxMKB3UFKyc_F4REFS5w2g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="0251" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在本文中，您将了解GraphQL和REST在获取数据方面的主要区别。代码片段将作为两种方法的并列参考提供。</p><p id="ef77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">供您参考，REST指的是API中的<code class="fe lu lv lw lx b">representational state transfer</code>架构，它遵循以下设计原则:</p><ul class=""><li id="33f9" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><code class="fe lu lv lw lx b">uniform interface</code> —对相同资源的所有请求属于一个统一资源标识符(URI)。</li><li id="dea5" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">client-server decoupling</code> —客户端和服务器相互独立，通过HTTP端点连接。</li><li id="8324" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">statelessness</code> —每个请求必须包含处理所需的相关信息。</li><li id="1f0f" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">cacheability</code> —为了性能和可伸缩性，资源应该尽可能可缓存。</li><li id="2d4c" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">layered system architecture</code> —它必须以这样一种方式设计，即客户机和服务器都不知道它是与终端应用程序通信还是与它们之间的中间中间件通信。</li></ul><p id="4812" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一方面，开发GraphQL是为了解决通过REST架构获取数据时的一些主要问题。主要目标是在从各种数据源获取大量数据时需要更高的效率和灵活性。总的来说，它解决了以下问题:</p><ul class=""><li id="4f49" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><code class="fe lu lv lw lx b">over-fetching of data</code>—指客户端下载的数据超过需求的情况。例如，调用<code class="fe lu lv lw lx b">employee</code>端点将返回一个JSON数组，其中包含与雇员相关的所有信息(姓名、年龄等。).响应可能包含对客户端无用的不必要信息。</li><li id="a358" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">under-fetching of data</code> —当特定端点没有提供所需的所有信息时发生。在这种情况下，客户端必须调用多个端点来检索所有相关信息。例如，为了获得雇员和供应商的信息，客户端可能需要调用<code class="fe lu lv lw lx b">employee</code>和<code class="fe lu lv lw lx b">supplier</code>端点。</li></ul><p id="366a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">GraphQL不是REST的替代品，因为两者各有优缺点。它是一种替代架构，为某些用例提供了灵活性和效率。</p><h1 id="2312" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">问题陈述</h1><p id="c73f" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">假设您正在构建一个向客户端提供以下数据的后端:</p><ul class=""><li id="4430" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">员工的详细信息</li><li id="5ea8" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">所有可用产品的详细信息</li><li id="3ed7" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">供应商的详细信息</li></ul><p id="61a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">理论上，对于上面的问题陈述，在一个数据库中应该有三个表。为了保持简洁，让我们创建一个新的Python文件作为假数据库。将文件命名为<code class="fe lu lv lw lx b">data.py</code>，并在其中添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="50bc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它包含了我们问题陈述中每一项的三个列表。此外，代码还定义了三个相应的函数，可以直接从GraphQL和REST服务器调用。每个函数接受一个<code class="fe lu lv lw lx b">id</code>输入参数并返回匹配的数据。如果没有定义<code class="fe lu lv lw lx b">id</code>，它将返回列表中的所有数据。</p><h1 id="49fa" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">设置</h1><p id="51f7" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">现在，让我们安装本教程所需的所有Python包。强烈建议您在继续安装之前创建一个新的虚拟环境。激活它，并按照以下说明操作:</p><h2 id="8d6f" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">FastAPI</h2><p id="b053" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们的REST API将使用FastAPI框架构建。运行以下命令进行安装:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="830a" class="nl mn it lx b gy ob oc l od oe">pip install fastapi</span></pre><h2 id="edc3" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">阿里阿德涅</h2><p id="a28d" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">本教程使用<a class="ae of" href="https://ariadnegraphql.org/docs/intro" rel="noopener ugc nofollow" target="_blank"> Ariadne </a>来实现GraphQL。您可以将其作为独立的WSGI或ASGI服务器。按照以下方式安装:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="19c1" class="nl mn it lx b gy ob oc l od oe">pip install ariadne</span></pre><p id="d66e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，FastAPI确实通过graphene提供了GraphQL支持，而graphene以前是由Starlette支持的。然而，正如<a class="ae of" href="https://www.starlette.io/graphql/" rel="noopener ugc nofollow" target="_blank">官方文档</a>中所指出的，从0.15版本起，GraphQL支持将被弃用。</p><p id="10e7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Python中提供GraphQL支持的其他第三方库如下:</p><ul class=""><li id="f034" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><a class="ae of" href="https://tartiflette.github.io/tartiflette-asgi/" rel="noopener ugc nofollow" target="_blank"> tartiflette-asgi </a></li><li id="bf38" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><a class="ae of" href="https://strawberry.rocks/docs/integrations/asgi" rel="noopener ugc nofollow" target="_blank">草莓</a></li><li id="c626" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><a class="ae of" href="https://github.com/ciscorn/starlette-graphene3" rel="noopener ugc nofollow" target="_blank">星形石墨烯3 </a></li></ul><h2 id="d2dc" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">紫玉米</h2><p id="9fae" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">除此之外，您还需要一个ASGI服务器来服务FastAPI (REST)和Ariadne (GraphQL)服务器。您可以通过以下命令安装它:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="3124" class="nl mn it lx b gy ob oc l od oe">pip install fastapi</span></pre><p id="9bc9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在接下来的小节中，您将实现REST和GraphQL服务器。它们提供相关的端点供假设的客户使用。让我们从FastAPI服务器开始。</p><h1 id="d544" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">FastAPI (REST)</h1><p id="5937" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">用下面的代码创建一个名为<code class="fe lu lv lw lx b">restapp.py</code>的新文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8b70" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据是从我们之前定义的<code class="fe lu lv lw lx b">data.py</code>中获得的。</p><p id="a202" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它将有三个GET HTTP端点:</p><ul class=""><li id="1c92" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">雇员</li><li id="4248" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">产品</li><li id="0ba0" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">供应者</li></ul><p id="7d50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个<code class="fe lu lv lw lx b">employee</code>数据点仅包含以下内容:</p><ul class=""><li id="5beb" class="ly lz it la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">姓</li><li id="f0de" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">名字</li><li id="f9be" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">年龄</li></ul><p id="257a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以进一步扩展<code class="fe lu lv lw lx b">employee</code>端点，添加另一个名为<code class="fe lu lv lw lx b">fullName</code>的字段，它表示雇员的全名。这将在后面用来说明REST和GraphQL在数据处理方面的区别。</p><h2 id="f941" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">运行服务器</h2><p id="3a4d" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">保存文件并运行以下命令来启动REST服务器:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="e4a7" class="nl mn it lx b gy ob oc l od oe">uvicorn restapp:app</span></pre><h2 id="6c7a" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">测试GET端点</h2><p id="50ff" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">打开浏览器，转到以下URL:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="adae" class="nl mn it lx b gy ob oc l od oe">http://localhost:8000/employee</span></pre><p id="9d56" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于没有说明<code class="fe lu lv lw lx b">id</code>，您应该得到所有员工的数据如下:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="4c13" class="nl mn it lx b gy ob oc l od oe">[<br/>  {<br/>    "id": 1001,<br/>    "firstName": "John",<br/>    "lastName": "Doe",<br/>    "age": 28,<br/>    "fullName": "John Doe"<br/>  },<br/>  {<br/>    "id": 1002,<br/>    "firstName": "Bob",<br/>    "lastName": "McBobby",<br/>    "age": 45,<br/>    "fullName": "Bob McBobby"<br/>  }<br/>]</span></pre><h2 id="8e2a" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">测试id为的GET端点</h2><p id="4e84" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">接下来，让我们尝试使用<code class="fe lu lv lw lx b">id</code>进行访问:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="a8ed" class="nl mn it lx b gy ob oc l od oe">http://localhost:8000/employee?id=1001</span></pre><p id="6cc3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务器将使用与给定的<code class="fe lu lv lw lx b">id</code>相匹配的员工数据进行响应:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="0e4e" class="nl mn it lx b gy ob oc l od oe">[<br/>  {<br/>    "id": 1001,<br/>    "firstName": "John",<br/>    "lastName": "Doe",<br/>    "age": 28,<br/>    "fullName": "John Doe"<br/>  }<br/>]</span></pre><p id="358a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，返回的响应包含与员工相关的所有信息。在实际的用例中，您可能有几十或几百个字段，如果客户端只打算获取几个特定的字段，这是一种资源浪费。这就是我们所说的数据过度提取。</p><p id="4d44" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，如果客户机应用程序需要雇员、产品和供应商的详细信息，它必须调用三个不同的端点。这个问题被称为数据提取不足。</p><h1 id="b984" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">阿里阿德涅语</h1><p id="854e" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">让我们实现相应的GraphQL API，它返回与REST服务器相同的数据。因为GraphQL是一个强类型系统，所以您必须定义模式作为客户机和服务器之间的契约。</p><h2 id="c465" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">(计划或理论的)纲要</h2><p id="7072" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在这种情况下，您可以将其定义如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="2f57" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">下决心者</h2><p id="6035" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在GraphQL中，只有一个端点，您必须创建<a class="ae of" href="https://ariadnegraphql.org/docs/resolvers" rel="noopener ugc nofollow" target="_blank">解析器</a>来确定如何返回数据。看看下面的例子，它说明了<code class="fe lu lv lw lx b">employee</code>的解析器:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="5661" class="nl mn it lx b gy ob oc l od oe"># Map resolver functions to Query fields using QueryType<br/>query = QueryType()</span><span id="c183" class="nl mn it lx b gy og oc l od oe"># Resolvers are simple python functions<br/>@query.field("employee")<br/>def resolve_employee(_, info, id=0):<br/>    return data.get_employee(id)</span></pre><p id="754d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">随后，您也可以为自定义字段构建解析器函数。例如，您可以使用以下代码片段创建一个名为<code class="fe lu lv lw lx b">fullName</code>的新字段:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="c0e4" class="nl mn it lx b gy ob oc l od oe"># Map resolver functions to custom type fields using ObjectType<br/>employee = ObjectType("Employee")</span><span id="b993" class="nl mn it lx b gy og oc l od oe">@employee.field("fullName")<br/>def resolve_person_fullname(person, *_):<br/>    return "%s %s" % (person["firstName"], person["lastName"])</span></pre><p id="3d76" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">完成所有解析器后，只需调用<code class="fe lu lv lw lx b">make_executable_schema</code>并传入所有的<code class="fe lu lv lw lx b">QueryType</code>和<code class="fe lu lv lw lx b">ObjectType</code>变量:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="9094" class="nl mn it lx b gy ob oc l od oe"># Create executable GraphQL schema<br/>schema = make_executable_schema(type_defs, query, employee)</span><span id="38fa" class="nl mn it lx b gy og oc l od oe"># Create an ASGI app using the schema, running in debug mode<br/>app = GraphQL(schema, debug=True)</span></pre><p id="ef5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在以下要点中找到GraphQL服务器的完整代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="48da" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">运行服务器</h2><p id="99ab" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">将代码保存为<code class="fe lu lv lw lx b">graphqlapp.py</code>，并在您的终端中运行以下命令:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="97db" class="nl mn it lx b gy ob oc l od oe">uvicorn graphqlapp:app</span></pre><p id="b159" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您正在运行REST服务器，您可以选择关闭服务器并使用另一个端口运行GraphQL:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="797c" class="nl mn it lx b gy ob oc l od oe">uvicorn graphqlapp:app --port 8001</span></pre><p id="466d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在浏览器中访问以下URL，启动一个名为GraphQL Playground的交互式网页(相应地修改端口):</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="7fbe" class="nl mn it lx b gy ob oc l od oe">http://localhost:8000/</span></pre><h2 id="317e" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">GraphQL游乐场</h2><p id="c9c0" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">您应该会看到以下用户界面:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/17f4d27bfd567c9011de5902e4817097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oi6gv7cgN1aLiyQX25p4uA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者图片</p></figure><p id="8232" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它允许您在GraphQL服务器上测试任何查询。在左侧写下以下查询，并点击<code class="fe lu lv lw lx b">play</code>按钮:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="ffb8" class="nl mn it lx b gy ob oc l od oe">{ employee { fullName } }</span></pre><p id="e92d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您应该得到以下输出:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="5965" class="nl mn it lx b gy ob oc l od oe">{<br/>  "data": {<br/>    "employee": [<br/>      {<br/>        "fullName": "John Doe"<br/>      },<br/>      {<br/>        "fullName": "Bob McBobby"<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="763c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务器将只返回您指定的内容。在这种情况下，它只返回了<code class="fe lu lv lw lx b">employee</code>的所有<code class="fe lu lv lw lx b">fullName</code>。</p><p id="53ed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们尝试另一个带有<code class="fe lu lv lw lx b">id</code>的查询。这一次，设置为返回<code class="fe lu lv lw lx b">fullName</code>和<code class="fe lu lv lw lx b">age</code>为<code class="fe lu lv lw lx b">id 1001</code>。</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="e2c1" class="nl mn it lx b gy ob oc l od oe">{ employee(id: 1001) { fullName age } }</span></pre><p id="a6a5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">输出如下所示:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="0363" class="nl mn it lx b gy ob oc l od oe">{<br/>  "data": {<br/>    "employee": [<br/>      {<br/>        "fullName": "John Doe",<br/>        "age": 28<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="c3f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您想获得员工、产品和供应商的数据，您可以在一个查询中完成:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="dd85" class="nl mn it lx b gy ob oc l od oe">{<br/>  employee(id: 1001) { fullName age }<br/>  product { name price }<br/>  supplier { name address }<br/>}</span></pre><p id="2e39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">服务器将返回以下响应:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="477a" class="nl mn it lx b gy ob oc l od oe">{<br/>  "data": {<br/>    "employee": [<br/>      {<br/>        "fullName": "John Doe",<br/>        "age": 28<br/>      }<br/>    ],<br/>    "product": [<br/>      {<br/>        "name": "Tofu",<br/>        "price": 12.7<br/>      },<br/>      {<br/>        "name": "Chocolate",<br/>        "price": 18.2<br/>      },<br/>      {<br/>        "name": "Pepper Sauce",<br/>        "price": 23.3<br/>      }<br/>    ],<br/>    "supplier": [<br/>      {<br/>        "name": "Tokyo Sweet",<br/>        "address": "7-11 Akimai Mushi-shi"<br/>      },<br/>      {<br/>        "name": "New England",<br/>        "address": "85 King's Street"<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="490e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，这就是本文前面提到的灵活性和效率。只有一个端点，客户端可以通过传入相应的查询来获得所需的所有数据。不会出现数据提取过量或不足的情况。</p><p id="8255" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这类似于查询SQL数据库:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="a66a" class="nl mn it lx b gy ob oc l od oe">SELECT fullName, age from employee WHERE id=1001</span></pre><p id="47db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是，GraphQL不支持通过其规范中的通配符查询某个类型的所有字段。在SQL中，您可以使用星号作为通配符来获取所有列，如下所示:</p><pre class="kj kk kl km gt nx lx ny nz aw oa bi"><span id="7eb8" class="nl mn it lx b gy ob oc l od oe">SELECT * from employee WHERE id=1001</span></pre><p id="d512" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在GraphQL中，您必须显式定义所有字段。这个问题很久以前就被提出来了，开发者之间也有过<a class="ae of" href="https://github.com/graphql/graphql-spec/issues/127" rel="noopener ugc nofollow" target="_blank">激烈的争论</a>。在撰写本文时，该功能还没有解决方案。</p><h2 id="e0f2" class="nl mn it bd mo nm nn dn ms no np dp mw lh nq nr my ll ns nt na lp nu nv nc nw bi translated">GraphQL的缺点</h2><p id="f94a" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">与REST架构相比，GraphQL确实有自己的缺点。如果输出数据的结构未知，或者您有非常复杂的嵌套结构数据，那么创建相应的模式和解析器将是一场噩梦。相比之下，在使用REST架构时，您可以简单地将整个字典返回给用户。客户端将自行决定如何使用它。</p><p id="b50f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除此之外，GraphQL的学习曲线比REST要高得多。如果您打算在GraphQL中构建用于创建、更新和删除数据的API，您需要学习另一个名为<code class="fe lu lv lw lx b">Mutation</code>的概念。</p><h1 id="c0e1" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">结论</h1><p id="f30a" class="pw-post-body-paragraph ky kz it la b lb ne ju ld le nf jx lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">让我们回顾一下你今天所学的内容。</p><p id="e6c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文首先简要解释了GraphQL和REST架构的基本概念和原理。</p><p id="5399" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后，它将重点放在一个简单的问题陈述上，并提供了一个示例假数据库，供本教程后面使用。</p><p id="0b53" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">REST和GraphQL服务器的实现将在随后的章节中介绍，并比较了REST和GraphQL查询数据的不同之处。</p><p id="727b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，探讨了GraphQL的不足之处。</p><p id="5bb3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">感谢你阅读这篇文章。希望在我的下一篇文章中再次见到你。祝你有美好的一天！</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><h1 id="cc6d" class="mm mn it bd mo mp op mr ms mt oq mv mw jz or ka my kc os kd na kf ot kg nc nd bi translated">参考</h1><ol class=""><li id="77ae" class="ly lz it la b lb ne le nf lh ou ll ov lp ow lt ox me mf mg bi translated">IBM —什么是REST API？</li><li id="21c2" class="ly lz it la b lb mh le mi lh mj ll mk lp ml lt ox me mf mg bi translated"><a class="ae of" href="https://ariadnegraphql.org/" rel="noopener ugc nofollow" target="_blank">阿里阿德涅— Python GraphQL </a></li></ol></div></div>    
</body>
</html>