<html>
<head>
<title>Built-In Module Imports and Exports: JavaScript ES6 Feature Series (Pt 7)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内置模块导入和导出:JavaScript ES6特性系列(Pt 7)</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/built-in-module-imports-and-exports-javascript-es6-feature-series-part-7-5f0864049e1f?source=collection_archive---------9-----------------------#2019-10-14">https://betterprogramming.pub/built-in-module-imports-and-exports-javascript-es6-feature-series-part-7-5f0864049e1f?source=collection_archive---------9-----------------------#2019-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4c91" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">导入意味着再也不用写‘要求’</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4b57065e0fdee3dc4f9ef902f11d7b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSXGvtPfGnaIv7cfBWwBKw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">马库斯·斯皮斯克在<a class="ae ky" href="https://unsplash.com/s/photos/learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="2787" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">介绍</h1><p id="ffa7" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">这些作品背后的灵感很简单:对于很多开发人员来说，JavaScript并没有多大意义——或者至少有时令人困惑。</p><p id="ccb1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">根据维基百科的数据，截至2017年5月，在1000万个最受欢迎的网页中，JavaScript占了不到95%。</p><p id="d90e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">由于JS对web的贡献如此之大，我想提供一些我经常使用的ES6+特性的片段和例子，供其他开发人员参考。</p><p id="9f60" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我们的目标是让这些文章简短、深入地解释对该语言的各种改进，我希望它们能启发您使用JS编写一些真正酷的东西。谁知道呢？在这个过程中，你甚至可能会学到一些新东西。</p><p id="3ff5" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我的系列文章中的第七篇涉及JavaScript中的内置模块支持，这是一种更简单的方法，可以用最少的语法在代码库中的任何地方使用对象、函数、类和变量。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="26d6" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">要求被ES模块取代</h1><p id="5e5e" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">在深入研究内置模块之前，让我给你上一堂关于CommonJS和<code class="fe na nb nc nd b">require</code>语法的简短历史课。</p><p id="0ba8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在ES2015之前，最广泛使用的将各种库模块添加到JavaScript文件范围的方法是通过<a class="ae ky" href="http://www.commonjs.org/" rel="noopener ugc nofollow" target="_blank"> CommonJS </a>。Node.js使用它，它是今天npm上大多数包使用的系统。CommonJS模块中的主要概念是一个名为<code class="fe na nb nc nd b">require</code>的函数。当您使用依赖项的模块名调用此函数时，它会确保模块已加载，并返回要在文件范围内使用的接口。</p><p id="b751" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果您曾经使用过Node.js脚本，或者更早的客户端JavaScript文件，您可能以前见过这种语法。下面是一个将广泛使用的服务器端框架ExpressJS导入Node.js <code class="fe na nb nc nd b">app.js</code>文件的例子:</p><h2 id="403c" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">普通人需求剖析</h2><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="d51f" class="ne lh it nd b gy nu nv l nw nx">const express = require('express');</span></pre><p id="b9f1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">只需声明变量<code class="fe na nb nc nd b">express</code>并调用<code class="fe na nb nc nd b">require('express')</code>，ExpressJS的所有不同方法现在都可以用于该文件。</p><p id="0ebf" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">很长一段时间以来，CommonJS模块工作得非常好，允许JavaScript社区通过npm大规模共享代码。</p><p id="245c" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是CommonJS有一些怪癖，使它不是理想的解决方案:也就是说，<code class="fe na nb nc nd b">require</code>是一个普通的函数调用，接受任何类型的参数，而不仅仅是字符串文字，这使得在不运行代码的情况下很难确定模块的依赖关系。还有比这更多的问题，但我不会在这里讨论它们。毕竟，这是一段短暂的历史。</p><p id="33d1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">可以说，ES2015引入了自己的模块系统，并在这样做的过程中，将新的模块支持符号集成到语言中。依赖关系和接口的主要概念保持不变，但是细节有所不同——这就是我现在要讨论的。</p><p id="9479" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你想更深入地了解模块、包和共性，我推荐你阅读《雄辩的JavaScript》的这一章。</p><p id="a324" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是现在，让我们继续讨论ES6的内置模块支持。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="232a" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">进口所有的东西</h1><p id="63ee" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">当es模块出现时，与CommonJS的模块语法最大的不同之一是访问依赖项的特殊的新关键字<code class="fe na nb nc nd b">import</code>。</p><p id="53c1" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">让我们看一下所有可用的不同类型的导入。在下面的部分，我还将介绍导出选项。</p><h2 id="b80c" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">导入默认导出</h2><p id="74d2" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">第一种类型的进口围绕着默认出口。这是最常用的导入类型，有几种不同的方法可以将默认导出与其他类型的导入结合起来。</p><p id="58b0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">仅导入默认导出的最简单示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="010f" class="ne lh it nd b gy nu nv l nw nx">import carTires from './autoParts/tires.js';</span></pre><p id="d76e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在第一个例子中，<code class="fe na nb nc nd b">carTires</code>是从文件<code class="fe na nb nc nd b">tires.js</code>默认导出的。要在这个文件中访问它，需要做的就是用相同的名称声明导出。</p><p id="c31e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果一个文件有多个您想要访问的值(比如说，一个函数或变量，加上一个默认导出)，语法将类似于下面的默认导出和附加函数的导入示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="4517" class="ne lh it nd b gy nu nv l nw nx">import carTires, { shineTires } from './autoParts/tires.js';</span></pre><p id="8400" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在这个特定的导入语句中，被析构的导出<code class="fe na nb nc nd b">{ shineTires }</code>就是所谓的名为导入的<strong class="ma iu">，因为它被括在花括号中，并从<code class="fe na nb nc nd b">tires.js</code>文件中以相同的名称导出。</strong></p><p id="7ca6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">还有一个选项，默认导出可以通过通配符导入<code class="fe na nb nc nd b">*</code>与整个模块的内容结合。</p><p id="7941" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在文件中导入默认导出和所有其他导出的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="25c7" class="ne lh it nd b gy nu nv l nw nx">import carTires, * as tireOptions from './autoParts/tires.js';</span></pre><p id="81c4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果文件<code class="fe na nb nc nd b">tires.js</code>中有一个名为<code class="fe na nb nc nd b">tireType</code>的变量和一个名为<code class="fe na nb nc nd b">rotateTires()</code>的函数，导入文件可以通过调用<code class="fe na nb nc nd b">tireOptions.tireType</code>或<code class="fe na nb nc nd b">tireOptions.rotateTires()</code>来访问它们。因为额外的导出是用语法<code class="fe na nb nc nd b">* as tireOptions</code>导入的，所以文件的所有导出都可以被引用<code class="fe na nb nc nd b">tireOptions.xyz</code>。这就是所谓的<strong class="ma iu">名称空间导入。</strong></p><p id="b91a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意:如果您在导入命名或名称空间导入的同时导入默认导出，请注意必须首先声明默认导出。</p><p id="1214" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">但是我想得太多了。让我们从导入默认导出转移到所有其他导入类型，然后细节应该会变得更加清楚。</p><h2 id="74fa" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">整个模块的内容:名称空间导入</h2><p id="cf77" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">正如我在上面提到的，如果一个文件有很多你想要访问的单独的导出，而不需要通过名字全部导入，有一种方法可以在<code class="fe na nb nc nd b">import * as abc</code>的帮助下完成。</p><p id="93a3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这将把<code class="fe na nb nc nd b">abc</code>插入到当前作用域中，包含来自位于<code class="fe na nb nc nd b">/romanAlphabet/letters.js</code>的文件中的模块的所有导出。</p><p id="d0e7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从文件一次导入多个导出的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="59c7" class="ne lh it nd b gy nu nv l nw nx">import * as <em class="mz">abc</em> from '<!-- -->/romanAlphabet/letters.js<!-- -->';</span></pre><p id="1b86" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这里，访问导出意味着使用模块名(本例中为<em class="mz"> abc </em>)作为<strong class="ma iu">名称空间</strong>。例如，如果上面导入的模块包含一个导出<code class="fe na nb nc nd b">singMyAbcs()</code>，您可以这样调用它:<code class="fe na nb nc nd b">abc.singMyAbcs();</code></p><p id="0750" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">很简单，对吧？现在我们继续。</p><h2 id="6c54" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">模块的单个导出:命名导入</h2><p id="137c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">上面的第二个例子，在默认导出部分，提到了命名导入，这是一个简单的方法，使用ES6对象析构将一个对象或值引入导入文件的范围。</p><p id="4cd7" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">下面是另一个单个命名导入的示例，让它更加清晰:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="9da1" class="ne lh it nd b gy nu nv l nw nx">import { apples } from './plants/fruits.js';</span></pre><p id="f281" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">对象<code class="fe na nb nc nd b">apples</code>从文件<code class="fe na nb nc nd b">fruits.js</code>中导出，要么隐式地导出整个模块，要么使用<code class="fe na nb nc nd b">export</code>语句显式地导出，然后插入当前范围。</p><p id="ee15" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">同样的语法也可以用于多次导入。</p><h2 id="ce2f" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">单个模块的多个导出</h2><p id="6e7c" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">与单个命名导入类似，可以使用相同的代码样式从一个文件中导出多个值和对象。</p><p id="9bb2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">多个命名导入的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="acef" class="ne lh it nd b gy nu nv l nw nx">import { carrots, potatoes, onions } from './plants/veggies.js';</span></pre><p id="c2bd" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从<code class="fe na nb nc nd b">veggies.js</code>的所有导出都被导入到当前文件的范围内，并且可以通过名称访问，就像一个单独的导入值一样。</p><h2 id="497d" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">用更方便的名称作为导入的别名</h2><p id="cea3" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">现在假设您有一个想要导入到文件中的导出，但是它有一个非常长的名字，比如<code class="fe na nb nc nd b">mySuperCaliFragilisticExpialidociusObject</code>。打出来挺痛苦的，对吧？</p><p id="510b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">好吧，有一个解决方案:在导入导出时用一个更方便的名称给它起别名。看看这个。</p><p id="9e70" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">为方便起见，重命名命名导出的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="10f0" class="ne lh it nd b gy nu nv l nw nx">import { <!-- -->mySuperCaliFragilisticExpialidociusObject as mySuperObject } from './maryPoppins.js'</span></pre><p id="51c0" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">每当您需要访问当前作用域中的导入值时，您可以简单地用<code class="fe na nb nc nd b">mySuperObject</code>调用它，而不是原来的、长得多的导出名称。多方便啊！</p><h2 id="9f18" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">在导入过程中重命名多个导出</h2><p id="60f1" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">但是假设您有多个长的命名导出对象。你能在导入时重命名它们吗？事实证明，你可以。</p><p id="ab21" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">就像重命名一个导出一样，您可以在导入时重命名多个导出。</p><p id="5076" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">多个导出的别名示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="5fe0" class="ne lh it nd b gy nu nv l nw nx">import { ladyMaryCrawley as ladyMary, ladyEdithCrawley as ladyEdith, ladyCoraCrawley as ladyGrantham } from './downtonAbbeyFamily/ladies.js';</span></pre><p id="4119" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">《唐顿庄园》中所有被导入到当前文件中的女士都有很长的头衔，因此，为了方便起见，当前作用域将用她们的简短别名<code class="fe na nb nc nd b">ladyMary</code>、<code class="fe na nb nc nd b">ladyEdith</code>和<code class="fe na nb nc nd b">ladyGrantham</code>来访问她们。</p><h2 id="2006" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">仅导入副作用</h2><p id="32f6" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">下一个例子我从未亲自使用过，但是你可以选择只导入一个完整的模块来产生副作用，而不导入任何东西。这有运行模块的全局代码的副作用，但实际上并没有导入任何值。</p><p id="49f4" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">导入模块但不导入任何特定内容的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="185d" class="ne lh it nd b gy nu nv l nw nx">import './helperFunctions.js';</span></pre><p id="76dc" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果有什么不同的话，这个语法让我想起了CSS文件导入到单独的JavaScript文件中的方式。</p><h2 id="35f3" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">动态导入</h2><p id="70f5" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">好了，最后一个导入:动态导入。这一提议将在ES2020版本中最终确定，因此我不会将它投入生产，但它值得关注。</p><p id="0358" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">可以调用关键字<code class="fe na nb nc nd b">import</code>作为动态导入模块的函数。当这样使用时，它返回一个承诺。</p><p id="f482" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">带有promise语法的动态导入示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="1aa1" class="ne lh it nd b gy nu nv l nw nx">import ('./waysToTravel.js')<br/>  .then((vehicles) =&gt; {<br/>    // do something with planes, trains and automobiles<br/>  });</span></pre><p id="8833" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">它也可以与较新的ES6 <code class="fe na nb nc nd b">async / await</code>语法一起使用。</p><p id="9ac6" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">使用async / await语法的动态导入示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="2520" class="ne lh it nd b gy nu nv l nw nx">let vehicles = await import('./waysToTravel.js');</span></pre><p id="2684" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我自己还没有使用过这种类型的导入，但是在内置模块支持的帮助下，他们正在用这么多不同的方法跨范围访问对象和值，这很好。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="d6e2" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">出口所有其他的东西</h1><p id="2686" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">好了，我们已经讨论了ES6模块支持的导入方面。现在让我们看看等式的另一半:ES6 <code class="fe na nb nc nd b">export</code>关键字和语法。</p><h2 id="eaf7" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">默认导出</h2><p id="276d" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果您曾经在ReactJS中工作过，您可能会非常熟悉默认导出。如果您简单地将<code class="fe na nb nc nd b">default</code>关键字放在您为导出定义的变量之后，它将成为默认导出。因此，当导入到另一个文件中时，您已经排除了它需要花括号。让我们来看一些例子。</p><p id="d60a" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从文件导出的默认函数、变量或类的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="0e53" class="ne lh it nd b gy nu nv l nw nx">// this is how to export a function as a default<br/>export default function getMovies() {<br/>  // fetch some movie data and return it<br/>};</span><span id="1eae" class="ne lh it nd b gy ny nv l nw nx">// this is how to export a variable as a default<br/>export default const movie = {<br/> title: "The Lion King", <br/> releaseDate: "July 19, 2019",<br/> synopsis: "Simba idolizes his father, King Mufasa, and takes to heart his own royal destiny on the plains of Africa."<br/>};</span><span id="4802" class="ne lh it nd b gy ny nv l nw nx">// this is how to export an ES6 class (a React class to be exact)<br/>export default class Movies extends Component {<br/>  // render some movie data in JSX<br/>}</span></pre><p id="8e58" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">注意:<strong class="ma iu"> </strong>每个JavaScript文件只能有一个默认导出。同一个文件中的所有其他导出文件前面都会有关键字<code class="fe na nb nc nd b">export</code>。</p><h2 id="77a6" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">个别指定出口</h2><p id="db81" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">下一个要讨论的导出类型是单独命名的导出，我在上面的导入部分讨论这些值的导入时已经提到了。</p><p id="d549" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">命名导出并不复杂——正如我前面说过的，除了默认导出之外，您希望在其他JavaScript文件中使用的任何内容都可以是命名导出。</p><p id="bb29" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">文件中多个命名导出的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="10d5" class="ne lh it nd b gy nu nv l nw nx">// this first array of pets is available to be imported into any other file because it has the 'export' keyword<br/>export const myPets = [ "dog", "cat", "guinea pig", "gold fish"];</span><span id="cf87" class="ne lh it nd b gy ny nv l nw nx">// mySecretPets can't be directly accessed outside the scope of this file because it lacks the 'export' keyword ahead of it<br/>const mySecretPets = [ "dragon", "griffin", "Loch Ness monster", "Big Foot"]</span><span id="f1d5" class="ne lh it nd b gy ny nv l nw nx">// nameMyPets can be called in the scope of other files<br/>export function nameMyPets() {<br/>  console.log(myPets, mySecretPets)<br/>}</span></pre><p id="3378" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">从上面的例子可以看出，变量<code class="fe na nb nc nd b">myPets</code>和函数<code class="fe na nb nc nd b">nameMyPets</code>都是从文件中显式导出的，因此可以使用指定的导入语法<code class="fe na nb nc nd b">import { myPets, nameMyPets } from './pets.js';</code>导入到另一个文件中。然而，另一个变量<code class="fe na nb nc nd b">mySecretPets</code>没有从文件中导出，因此不能在它的原始范围之外显式访问。</p><h2 id="fefe" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">单行中的多个命名导出</h2><p id="0919" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">如果您不想在整个文件中多次键入<code class="fe na nb nc nd b">export</code>,还有另一种方法可以在JavaScript中从单个文件中导出多个值。</p><p id="7420" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">在模块的最后，使用与导入多个命名导入几乎相同的语法，您可以声明任何您想要导出到当前文件之外的其他范围的值。</p><p id="6073" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">具有多个命名导出的单行示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="21ea" class="ne lh it nd b gy nu nv l nw nx">export { cakes, cookies, makeDessert, makeTea };</span></pre><p id="6878" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">如果你可以想象在上面的例子中，变量<code class="fe na nb nc nd b">cakes</code>和<code class="fe na nb nc nd b">cookies</code>与函数<code class="fe na nb nc nd b">makeDessert()</code>和<code class="fe na nb nc nd b">makeTea()</code>一起存在，并且你想在你的代码库的其他区域访问所有这些值，简单地通过在模块的末尾导出它们，你可以在任何你想要的地方访问它们。</p><p id="1635" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这是一个稍微干净的语法，但是实际上，在模块的末尾，每个值的显式导出或者所有值的单个导出将为您实现完全相同的事情。</p><h2 id="46bf" class="ne lh it bd li nf ng dn lm nh ni dp lq mh nj nk ls ml nl nm lu mp nn no lw np bi translated">使用别名导出</h2><p id="c810" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">我将介绍的最后一个导出选项是使用别名导出，这类似于使用别名导入。</p><p id="afc2" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">别名导出的示例:</p><pre class="kj kk kl km gt nq nd nr ns aw nt bi"><span id="583b" class="ne lh it nd b gy nu nv l nw nx">export { dumplings, xiaoLongBao as soupDumplings, bbqPorkBuns, orderDimSum, pickUpSteamerBaskets, pourTea as fillTeaCups };</span></pre><p id="bc8e" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">正如在导入文件中重命名命名的导出一样，您实际上可以在导出导出时重命名导出。在上面的例子中，我将变量<code class="fe na nb nc nd b">xiaoLongBao</code>重命名为<code class="fe na nb nc nd b">soupDumplings</code>，将函数<code class="fe na nb nc nd b">pourTea</code>重命名为<code class="fe na nb nc nd b">fillTeaCups</code>，以便导入任何其他范围。</p><p id="67a3" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">老实说，我真的不知道为什么在一个文件中给一个值一个名称，然后选择用不同的名称导出到所有其他文件。(如果在另一个文件的范围内存在命名冲突，为什么不直接重命名导入呢？)但这是一种选择，我想用我所能掌握的所有知识来武装你。</p><p id="1078" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">这就结束了我们通过ES6的内置模块支持导入和导出的详细过程！</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="f4bf" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">结论</h1><p id="3c19" class="pw-post-body-paragraph ly lz it ma b mb mc ju md me mf jx mg mh mi mj mk ml mm mn mo mp mq mr ms mt im bi translated">JavaScript的ES6语法已经出来很多年了(在久而久之得到了越来越广泛的采用)，但是它引入了一些突破性的语言变化，这些变化对于一些开发人员来说太陌生了，以至于他们没有兴趣立即学习。</p><p id="678b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">虽然我同意它非常不同，但它也非常强大，使得编写JavaScript代码比几年前容易得多。</p><p id="f28b" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">我撰写这一系列文章的目的是强调您每天使用的ES6语法，并解释如何使用JavaScript语言的这些新部分来获得最大效果。</p><p id="5623" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">到目前为止，npm中所有非常有用的JavaScript库模块都没有标准化的内置模块支持。ES2015改变了这一点，引入了新的专业关键词和无数种方法，可以将各种JS值从一个范围导入和导出到另一个范围，比以前少了很多麻烦和烦恼。这是一个很大的游戏改变。</p><p id="17c8" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">感谢您的阅读，如果您还没有开始在自己的项目中利用内置模块支持，我希望您能开始利用它。</p><p id="1860" class="pw-post-body-paragraph ly lz it ma b mb mu ju md me mv jx mg mh mw mj mk ml mx mn mo mp my mr ms mt im bi translated">本系列以前的文章:</p><ul class=""><li id="9ff9" class="nz oa it ma b mb mu me mv mh ob ml oc mp od mt oe of og oh bi translated"><a class="ae ky" href="https://itnext.io/enhanced-object-literal-value-shorthand-javascript-es6-feature-series-pt-6-e00dfdc24f64" rel="noopener ugc nofollow" target="_blank">增强的对象文字值速记:JavaScript ES6特性系列(Pt 6) </a></li><li id="147b" class="nz oa it ma b mb oi me oj mh ok ml ol mp om mt oe of og oh bi translated"><a class="ae ky" href="https://medium.com/better-programming/string-template-literals-javascript-es6-feature-series-pt-5-a40e55a5485b" rel="noopener">字符串模板文字:JavaScript ES6特性系列(Pt 5) </a></li><li id="bbf3" class="nz oa it ma b mb oi me oj mh ok ml ol mp om mt oe of og oh bi translated"><a class="ae ky" href="https://itnext.io/spread-rest-parameters-javascript-es6-feature-series-pt-4-c9e9f0c0228f" rel="noopener ugc nofollow" target="_blank"> Spread &amp; Rest参数:JavaScript ES6特性系列(Pt 4) </a></li><li id="842f" class="nz oa it ma b mb oi me oj mh ok ml ol mp om mt oe of og oh bi translated"><a class="ae ky" href="https://itnext.io/default-function-parameter-values-javascript-es6-feature-series-pt-3-bd8392a88a12" rel="noopener ugc nofollow" target="_blank">默认函数参数值:JavaScript ES6特性系列(Pt 3) </a></li><li id="31b0" class="nz oa it ma b mb oi me oj mh ok ml ol mp om mt oe of og oh bi translated"><a class="ae ky" href="https://itnext.io/arrow-functions-javascript-es6-feature-series-pt-2-e8c31c823392" rel="noopener ugc nofollow" target="_blank">箭头功能:JavaScript ES6特性系列(Pt 2) </a></li><li id="694c" class="nz oa it ma b mb oi me oj mh ok ml ol mp om mt oe of og oh bi translated"><a class="ae ky" href="https://itnext.io/var-let-const-javascript-es6-feature-series-pt-1-fa603567809e" rel="noopener ugc nofollow" target="_blank"> Var，Let &amp; Const: JavaScript ES6特性系列(Pt 1) </a></li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="5e03" class="lg lh it bd li lj lk ll lm ln lo lp lq jz lr ka ls kc lt kd lu kf lv kg lw lx bi translated">参考资料和更多资源</h1><ul class=""><li id="1add" class="nz oa it ma b mb mc me mf mh on ml oo mp op mt oe of og oh bi translated">导入，MDN Docs:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/Web/JavaScript/Reference/Statements/import</a></li><li id="06c7" class="nz oa it ma b mb oi me oj mh ok ml ol mp om mt oe of og oh bi translated">导出，MDN Docs:<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/Docs/web/JavaScript/reference/statements/export</a></li><li id="1971" class="nz oa it ma b mb oi me oj mh ok ml ol mp om mt oe of og oh bi translated">模块，雄辩的JavaScript:<a class="ae ky" href="https://eloquentjavascript.net/10_modules.html" rel="noopener ugc nofollow" target="_blank">https://eloquentjavascript.net/10_modules.html</a></li></ul></div></div>    
</body>
</html>