<html>
<head>
<title>Make Use of RxJS to Create Efficient React Components With Ease</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用RxJS轻松创建高效的React组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/make-use-of-rxjs-to-create-efficient-react-components-with-ease-def018644e23?source=collection_archive---------11-----------------------#2019-11-06">https://betterprogramming.pub/make-use-of-rxjs-to-create-efficient-react-components-with-ease-def018644e23?source=collection_archive---------11-----------------------#2019-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0e428a84b794ee77de825cd51514a6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TTACMbpgq7xa_ePN"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">Joel Filipe 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><h1 id="3327" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="accc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">React组件基于<a class="ae kc" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">属性</a>和<a class="ae kc" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">状态</a>的概念。属性表示来自其他(主机)组件的输入值，而状态表示组件的内部条件。状态可以从属性中导出，甚至可以异步计算——例如..作为进行HTTP调用的结果。</p><p id="7007" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">React库确保在对属性或状态的更新会产生视觉效果时重新呈现组件。</p><p id="d075" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">从性能角度来看，我们希望确保:</p><ul class=""><li id="d907" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mj mk ml mm bi translated">组件的<code class="fe mn mo mp mq b">render</code>方法的执行应该尽可能快——也就是说，我们希望避免进行昂贵的计算或对象分配</li><li id="bdb6" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">调用<code class="fe mn mo mp mq b">render</code>方法的次数应该尽可能少<a class="ae kc" href="https://reactjs.org/docs/optimizing-performance.html#avoid-reconciliation" rel="noopener ugc nofollow" target="_blank"/>。每次调用<code class="fe mn mo mp mq b">render</code>时，React必须运行它的<a class="ae kc" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">协调</a>算法来比较更新和现有状态的虚拟DOM。尽管这种方法实现起来非常有效，但是完全避免<a class="ae kc" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">和解</a>会更有效。</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="73a1" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">最小化渲染时间</h1><p id="c53d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们通过预先预计算所有需要的数据结构来最小化花费在<code class="fe mn mo mp mq b">render</code>方法中的时间。这包括潜在的昂贵计算以及对象分配。</p><p id="3ee9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们使用RxJS操作符对输入的变化做出反应，并使用<code class="fe mn mo mp mq b">state</code>概念将我们的计算和对象创建的结果传递给<code class="fe mn mo mp mq b">render</code>方法。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="17d5" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">避免和解</h1><p id="e3ba" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">组件开发人员有责任判断属性或状态的修改是否会导致应用程序的重新呈现。对于简单的用例，这通常通过覆盖<code class="fe mn mo mp mq b">shouldComponentUpdate</code>方法或从<code class="fe mn mo mp mq b">PureComponent</code>派生来完成。</p><p id="92c8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">默认情况下，如果属性或状态改变，React将重新呈现组件。从<code class="fe mn mo mp mq b">PureComponent</code>派生通过对属性进行简单的比较，假设对象本身的不变性，稍微改善了这种情况。这种方法仍然会导致不希望的重新呈现操作，因为:</p><ul class=""><li id="d4c0" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mj mk ml mm bi translated">组件的呈现可能不直接依赖于属性，而是依赖于该属性的派生信息。尽管资产发生了变化，但这种情况可能会保持稳定。</li><li id="7b2d" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">对于受控组件，我们经常通过属性传入回调函数。我们有时可以观察到(反)模式，即主机组件将成员函数绑定到它们的<code class="fe mn mo mp mq b">render</code>调用中的回调，或者它们使用呈现期间生成的Lambda函数。这将在每次宿主呈现时创建新的函数对象，导致子组件不必要的重新呈现。</li></ul><p id="06fe" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">所以为了避免这些问题，我们的策略是确保组件的呈现不直接使用属性——而只使用来自<code class="fe mn mo mp mq b">state</code>的信息。</p><p id="0a60" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这是组件开发人员可以完全控制的信息。我们还要求组件<code class="fe mn mo mp mq b">state</code>中的对象是<a class="ae kc" href="https://reactjs.org/docs/optimizing-performance.html#the-power-of-not-mutating-data" rel="noopener ugc nofollow" target="_blank">不可变的</a>，这样我们可以通过简单的等号检查来判断状态是否改变。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="1d6f" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">关注点分离</h1><p id="d28f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">讨论的优化模式围绕着为组件的呈现计算理想的<code class="fe mn mo mp mq b">state</code>的思想。</p><p id="1a70" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这使我们有机会将计算该状态的任务分离到一个<a class="ae kc" href="https://www.raywenderlich.com/4074597-getting-started-with-the-bloc-pattern" rel="noopener ugc nofollow" target="_blank">业务逻辑组件(BLoC) </a>中，并将实际呈现分离到一个表示组件中。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="8cf4" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">例子</h1><p id="297a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在我们开始解释该方法之前，让我们添加一个非常简单的“Hello，World！”举例。</p><p id="a3d0" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们将使用所讨论模式的<a class="ae kc" href="https://www.npmjs.com/package/rx-react-component" rel="noopener ugc nofollow" target="_blank"> rx-react-component </a>实现:</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">“你好，世界！”例子</p></figure><p id="6030" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">解释:</p><ol class=""><li id="6f1a" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly no mk ml mm bi translated">构造一个以<code class="fe mn mo mp mq b">HelloWorldProps</code>为输入的组件。该组件将实现一些简单的业务逻辑(用<code class="fe mn mo mp mq b">'Hello'</code>作为输入的前缀)，然后将结果传递给一个表示组件。</li><li id="1ff9" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly no mk ml mm bi translated">将输入属性转换为状态的业务逻辑层。注意<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged" rel="noopener ugc nofollow" target="_blank"> distinctUntilChanged </a>操作符是如何确保只有在输入真正改变时才更新状态的。</li><li id="14a0" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly no mk ml mm bi translated">呈现组件被实现为功能组件。</li></ol></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="e9e7" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">方法</h1><p id="1d5a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们为性能优化的电抗组件实现了一个匿名类。本课程的目的是:</p><ul class=""><li id="ec19" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mj mk ml mm bi translated">公开一种从属性计算<code class="fe mn mo mp mq b">state</code>的反应式RxJS方法，包括对生命周期方法的反应式访问</li><li id="e9b4" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">通过实施<code class="fe mn mo mp mq b">shouldComponentUpdate</code>方法来最小化<a class="ae kc" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">协调</a></li></ul><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/90a00e72e69285a0c3192173328af804.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6qG_9E71SMO33U9rOHipCQ.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">组件设计，RxJS业务层在块中，视图层分离成一个哑表示组件</p></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="d851" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">最小化渲染时间</h1><p id="1fc2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们将<a class="ae kc" href="https://reactjs.org/docs/react-component.html" rel="noopener ugc nofollow" target="_blank">反应生命周期方法</a>表示为<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/guide/observable" rel="noopener ugc nofollow" target="_blank">可观测量</a>，并使用<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/guide/operators" rel="noopener ugc nofollow" target="_blank">反应运算符</a>导出组件状态。</p><p id="6534" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">抽象类采用一个函数将属性转换成可观察的状态。然后，它将确保正确地挂钩到生命周期方法来订阅和取消订阅。</p><p id="0795" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">调用者基于输入属性(通过<code class="fe mn mo mp mq b">props$</code>可观察值)或者通过使用RxJS机制异步计算状态来构造<code class="fe mn mo mp mq b">state$</code>可观察值。</p><h2 id="2971" class="nq ke iq bd kf nr ns dn kj nt nu dp kn lm nv nw kr lq nx ny kv lu nz oa kz ob bi translated">初态</h2><p id="8ed6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在调用<code class="fe mn mo mp mq b">componentDidMount</code>方法之前，由<code class="fe mn mo mp mq b">state$</code>可观察对象发出的任何状态都被自动视为初始化状态。您可以使用<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/api/operators/startWith" rel="noopener ugc nofollow" target="_blank"> startWith </a>操作符来确保这样的状态存在。没有必要(也没有办法)显式设置<code class="fe mn mo mp mq b">this.state</code>。</p><h2 id="d237" class="nq ke iq bd kf nr ns dn kj nt nu dp kn lm nv nw kr lq nx ny kv lu nz oa kz ob bi translated">来自主机组件的输入</h2><p id="255a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们的React组件将通过<a class="ae kc" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">属性</a>从其主机接收输入。这些属性可以通过<code class="fe mn mo mp mq b">props$</code>观察得到。</p><p id="743c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">使用<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/api/operators/pluck" rel="noopener ugc nofollow" target="_blank">puck</a>和<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/api/operators/distinctUntilChanged" rel="noopener ugc nofollow" target="_blank"> distinctUntilChanged </a>等操作符访问单个属性，仅当这些属性改变时才改变状态。</p><h2 id="c056" class="nq ke iq bd kf nr ns dn kj nt nu dp kn lm nv nw kr lq nx ny kv lu nz oa kz ob bi translated">来自子组件的输入</h2><p id="4789" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">从子组件到父组件的通信通常通过将回调函数作为事件处理程序经由属性传递给子组件来实现。</p><p id="95b1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们区分<a class="ae kc" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">受控</a>或非受控组件。受控组件将其状态委托给其宿主组件，并期望通过其属性将状态更改镜像回来。不受控制的组件保持其自身的状态。</p><p id="5075" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">因为我们将组件分成了块组件和表示组件，所以表示组件应该总是由块组件控制，而块组件可以是受控的，也可以是不受控的。</p><p id="3a78" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">控制表现组件</strong>:我们为视图组件的状态变化定义回调函数，并在块的状态中管理它们。这些函数被绑定到<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/api/index/class/Subject" rel="noopener ugc nofollow" target="_blank"> Subject </a>上的<code class="fe mn mo mp mq b">next</code>调用，这允许BLoC将这些回调集成到可观察管道中。</p><p id="64f1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">非受控闭锁</strong>:非受控闭锁通常通过<a class="ae kc" href="https://rxjs-dev.firebaseapp.com/api/operators/scan" rel="noopener ugc nofollow" target="_blank">扫描</a>操作器维持其状态。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/27f9ed877f325466934d21b7b131579e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cCTQDSmgWiLXgmAEq8u6Zg.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">非受控组件的布局。BLoC通过扫描操作符维护其状态，并在被点击主体触发时更新它。</p></figure><p id="8fd6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">举例:</strong>想象一个维护计数器值的组件。视图组件显示该值，并呈现一个按钮来增加该值。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">不受控制的计数器组件示例</p></figure><p id="d5e1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">受控块</strong>:受控块通过其属性中的回调函数将状态管理委托给其主机。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/252fb58031950235e1e33a8801f1defe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wMn4DuIZEY658Fz40bgv-w.jpeg"/></div></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">受控组件的布局。反应层将输入属性转换为状态，并将点击发送回控制器。</p></figure><p id="aac4" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">例子:</strong>同样，我们有一个带按钮的计数器来增加它的值。与上一个示例相比，本示例使用相同视图实现。</p><figure class="ni nj nk nl gt jr"><div class="bz fp l di"><div class="nm nn l"/></div><p class="jy jz gj gh gi ka kb bd b be z dk translated">受控计数器组件的示例</p></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="07a6" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">避免和解</h1><p id="4686" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">抽象类实现了<code class="fe mn mo mp mq b">shouldComponentUpdate</code>，并使用简单的<code class="fe mn mo mp mq b">equals</code>检查将新状态与当前状态进行比较。属性被完全忽略。这行得通，因为</p><ul class=""><li id="ae00" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mj mk ml mm bi translated">对象是不可变的</li><li id="a76f" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">所有来自属性的信息都应该通过<code class="fe mn mo mp mq b">state$</code>可观察值转换成<code class="fe mn mo mp mq b">state</code></li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="00d2" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">关注点分离</h1><p id="fa4c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我们使用<code class="fe mn mo mp mq b">rxComponent</code>函数来创建我们的组件。该函数接受一个函数来计算属性的<code class="fe mn mo mp mq b">state$</code>可观察值、生命周期可观察值，以及对接受状态作为其输入属性的表示组件的引用。</p><p id="65c7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这种方法具有以下优点:</p><ul class=""><li id="3e3d" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mj mk ml mm bi translated">清楚地将业务逻辑与呈现逻辑分开</li><li id="1580" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">不需要为每个组件创建一个自定义类，从而减少了应用程序的整体大小</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="fbd8" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated">摘要</h1><ul class=""><li id="c5d8" class="me mf iq ld b le lf li lj lm oc lq od lu oe ly mj mk ml mm bi translated">将组件分成一个业务逻辑组件(BLoC)和一个表示组件</li><li id="d218" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">使用RxJS实现块，将属性和上下文转换成状态</li><li id="173e" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">使用内置的RxJS操作符进行初始化(<code class="fe mn mo mp mq b">startWith</code>)、最小化更新(<code class="fe mn mo mp mq b">distinctUntilChanged</code>)、维护状态(<code class="fe mn mo mp mq b">scan</code>)、与上下文相关的潜在异步数据结合(<code class="fe mn mo mp mq b">merge</code>、<code class="fe mn mo mp mq b">switch</code>等。).</li><li id="1f0c" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated">将结果状态作为输入属性传递给表示组件</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="6c52" class="kd ke iq bd kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw nh ky kz la bi translated"><strong class="ak">资源</strong></h1><ul class=""><li id="277d" class="me mf iq ld b le lf li lj lm oc lq od lu oe ly mj mk ml mm bi translated"><a class="ae kc" href="https://www.npmjs.com/package/rx-react-component" rel="noopener ugc nofollow" target="_blank">引用实现</a></li><li id="acef" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated"><a class="ae kc" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> React文档</a></li><li id="6038" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated"><a class="ae kc" href="https://rxjs-dev.firebaseapp.com/api" rel="noopener ugc nofollow" target="_blank"> RxJS文档</a></li><li id="accd" class="me mf iq ld b le mr li ms lm mt lq mu lu mv ly mj mk ml mm bi translated"><a class="ae kc" href="https://www.raywenderlich.com/4074597-getting-started-with-the-bloc-pattern" rel="noopener ugc nofollow" target="_blank">阻塞模式</a></li></ul></div></div>    
</body>
</html>