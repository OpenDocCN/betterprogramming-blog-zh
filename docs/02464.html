<html>
<head>
<title>Node.js’ fs Module — Getting File Information</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js的fs模块—获取文件信息</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/node-js-fs-module-getting-file-information-a81cce4b0c8?source=collection_archive---------7-----------------------#2019-12-02">https://betterprogramming.pub/node-js-fs-module-getting-file-information-a81cce4b0c8?source=collection_archive---------7-----------------------#2019-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e5e9" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">将文件及其数据引入您的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1f821e3cc64a5864dc76a34d8999b75d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f4n8BeXiKPyMt6eL"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@gmalhotra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gayatri Malhotra </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="619f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">操作文件和目录是任何程序的基本操作。由于Node.js是一个服务器端平台，可以直接与运行它的计算机交互，因此能够操作文件是一个基本特性。</p><p id="ce4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">幸运的是，Node.js的库中内置了一个<code class="fe lv lw lx ly b">fs</code>模块。它有许多功能，可以帮助操纵文件和文件夹。支持的文件和目录操作包括基本的操作，如操作和打开目录中的文件。</p><p id="2dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，它也可以对文件做同样的事情。它可以同步和异步地做到这一点。它有一个异步API，该API具有支持承诺的功能。此外，它还可以显示文件的统计数据。</p><p id="5636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几乎所有我们能想到的文件操作都可以用内置的<code class="fe lv lw lx ly b">fs</code>模块来完成。</p><p id="ec16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将使用<code class="fe lv lw lx ly b">fs</code>模块中的函数，通过<code class="fe lv lw lx ly b">fs.stat()</code>、<code class="fe lv lw lx ly b">fs.lstat()</code>和<code class="fe lv lw lx ly b">fs.fstat()</code>函数获取位于<code class="fe lv lw lx ly b">fs.Stats</code>对象中的文件的数据。</p><p id="88af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得关于文件的信息，我们可以使用由<code class="fe lv lw lx ly b">fs.stat()</code>、<code class="fe lv lw lx ly b">fs.lstat()</code>和<code class="fe lv lw lx ly b">fs.fstat()</code>函数返回的<code class="fe lv lw lx ly b">fs.Stats</code>对象，以及它们的同步对应物。</p><p id="49f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们可以将数字数据显示为<code class="fe lv lw lx ly b">bigint</code>，因为它是作为option键传入的，其值设置为<code class="fe lv lw lx ly b">true</code>。它具有以<code class="fe lv lw lx ly b">Ns</code>为后缀的纳秒精度属性。</p><p id="a43c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">stat</code>函数将一个path对象作为第一个参数，这个对象可以是一个字符串、缓冲区或URL对象。</p><p id="5309" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是一个对象，它可以将<code class="fe lv lw lx ly b">bigint</code>作为键，这是一个布尔值。如果设置为<code class="fe lv lw lx ly b">true</code>，那么数值信息将作为<code class="fe lv lw lx ly b">bigInts</code>返回。</p><p id="7031" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是一个回调函数，它的第一个参数是error对象，第二个参数是<code class="fe lv lw lx ly b">stats</code>对象，它包含文件的信息，并且在检索文件信息时它正在运行。</p><p id="cc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">stat</code>函数异步运行。它的同步对应物是<code class="fe lv lw lx ly b">statSync</code>函数，它接受同样的前两个参数，没有回调函数。<code class="fe lv lw lx ly b">statSync</code>以对象形式返回文件信息。</p><p id="4ef5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">lstat</code>类似于<code class="fe lv lw lx ly b">stat</code>，但不遵循符号链接。它接受一个path对象作为第一个参数，该对象可以是字符串、缓冲区或URL对象。</p><p id="2313" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是一个对象，它可以将<code class="fe lv lw lx ly b">bigint</code>作为键，这是一个布尔值。如果设置为<code class="fe lv lw lx ly b">true</code>，那么数值信息将作为<code class="fe lv lw lx ly b">bigInts</code>返回。</p><p id="af4b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是一个回调函数，它的第一个参数是error对象，第二个参数是<code class="fe lv lw lx ly b">stats</code>对象，它包含了文件的信息，并且在检索文件信息时正在运行。</p><p id="5ceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当传入的路径是一个符号链接时，它给出了这个符号链接的信息。<code class="fe lv lw lx ly b">lstat</code>异步运行，以便在不确定的时间内检索数据。</p><p id="ecf5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的同步对应物<code class="fe lv lw lx ly b">lstatSync</code>函数接受与<code class="fe lv lw lx ly b">lstat</code>函数相同的参数，但没有回调函数，并返回包含文件信息的<code class="fe lv lw lx ly b">Stat</code>对象。</p><p id="8cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fstat</code>功能类似于<code class="fe lv lw lx ly b">stat</code>功能。它接受一个path对象作为第一个参数，该对象可以是字符串、缓冲区或URL对象。</p><p id="5d8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第二个参数是一个可以将<code class="fe lv lw lx ly b">bigint</code>作为键的对象，它是一个布尔值。如果设置为<code class="fe lv lw lx ly b">true</code>，那么数值信息将作为<code class="fe lv lw lx ly b">bigInts</code>返回。</p><p id="8237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个参数是一个回调函数，它的第一个参数是error对象，第二个参数是<code class="fe lv lw lx ly b">stats</code>对象，它包含文件的信息，并且在检索文件信息时它正在运行。</p><p id="5a0c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"><code class="fe lv lw lx ly b">stat</code>和<code class="fe lv lw lx ly b">fstat</code>唯一的区别</strong>是它采用文件描述符而不是路径对象。</p><p id="2ad3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以从回调中获得文件描述符，回调由<code class="fe lv lw lx ly b">fs.open</code>函数及其对应的promise和同步函数<code class="fe lv lw lx ly b">fsPromises.open</code>和<code class="fe lv lw lx ly b">fs.opensync</code>接受。</p><p id="3952" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">fs.stat</code>函数，我们可以像下面的代码一样使用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="5e6d" class="md me it ly b gy mf mg l mh mi">const fs = require("fs");</span><span id="952c" class="md me it ly b gy mj mg l mh mi">fs.stat("./files/file.txt", (err, stat) =&gt; {<br/>  if (err) throw err;<br/>  console.log(stat);<br/>});</span></pre><p id="9911" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，如果我们运行上面的代码，我们会得到类似下面的输出:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b34a" class="md me it ly b gy mf mg l mh mi">Stats {<br/>  dev: 3605029386,<br/>  mode: 33206,<br/>  nlink: 1,<br/>  uid: 0,<br/>  gid: 0,<br/>  rdev: 0,<br/>  blksize: 4096,<br/>  ino: 22799473115106240,<br/>  size: 0,<br/>  blocks: 0,<br/>  atimeMs: 1572569358035.625,<br/>  mtimeMs: 1572569358035.625,<br/>  ctimeMs: 1572569358035.625,<br/>  birthtimeMs: 1572569358035.625,<br/>  atime: 2019-11-01T00:49:18.036Z,<br/>  mtime: 2019-11-01T00:49:18.036Z,<br/>  ctime: 2019-11-01T00:49:18.036Z,<br/>  birthtime: 2019-11-01T00:49:18.036Z<br/>}</span></pre><p id="fc3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所见，<code class="fe lv lw lx ly b">Stats</code>物体有许多属性。上面列出了数据属性。它还有一些函数属性。</p><p id="4f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Stats</code>对象中的数据属性含义如下:</p><ul class=""><li id="e813" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">dev</code> —存储给定文件的设备的数字标识符。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="5b89" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">ino</code> —文件的“信息节点”号。它是一个包含文件、目录或其他文件系统对象的基本信息的数字。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="1b1c" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">mode</code> —文件类型和模式的位域描述。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="151a" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">nlink</code> —文件存在的硬链接数量。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="b949" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">uid</code> —拥有文件的用户的数字用户标识符。仅适用于POSIX系统。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="4add" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">gid</code> —拥有文件的用户的数字组标识符。仅适用于POSIX系统。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="9eb2" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">rdev</code> —如果是特殊文件，文件的数字设备标识符。如果一个文件用于I/O，它就是特殊的。例如，页面文件和休眠文件被认为是特殊的文件。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="246b" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">size</code> —文件的大小，以字节为单位。它可以是一个数字或一个<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="fefc" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">blksize</code> —文件系统I/O的块大小，可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="9d51" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">blocks</code> —分配给文件的块数。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="263b" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">atimeNs</code> —时间戳，指示自POSIX纪元(相对于1970年1月1日午夜的时间)以来最后一次以纳秒为单位访问文件的时间。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="f60d" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">mtimeNs</code> —时间戳，指示自POSIX纪元(相对于1970年1月1日午夜的时间)以来文件的最后修改时间(以纳秒为单位)。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="37d6" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">ctimeNs</code> —时间戳表示自POSIX纪元(相对于1970年1月1日午夜的时间)以来文件最后一次更改的时间，单位为纳秒。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="f4c9" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">birthtimeNs</code> —时间戳表示自POSIX纪元(相对于1970年1月1日午夜的时间)以来文件创建的时间，单位为纳秒。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="8f08" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">atime</code> —时间戳，指示自POSIX纪元(相对于1970年1月1日午夜的时间)以来最后一次访问文件的时间(以毫秒计)。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="2115" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">mtime</code> —时间戳，指示自POSIX纪元(相对于1970年1月1日午夜的时间)以来最后一次修改文件的时间(毫秒)。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="e5a4" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">ctime</code> —时间戳，指示自POSIX纪元(相对于1970年1月1日午夜的时间)以来最后一次更改文件的时间(以毫秒为单位)。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li><li id="01f0" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">birthtime</code> —时间戳，指示自POSIX纪元(相对于1970年1月1日午夜的时间)以来文件创建的时间(毫秒)。可以是数字，也可以是<code class="fe lv lw lx ly b">bigInt</code>。</li></ul><p id="e165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Stats</code>对象还具有以下功能属性，用于检查文件的基本信息:</p><ul class=""><li id="0cd6" class="mk ml it lb b lc ld lf lg li mm lm mn lq mo lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">isBlockDevice()</code> —这是一个带有布尔返回值的函数，如果文件是块设备，则返回<code class="fe lv lw lx ly b">true</code>。块设备指的是代表以块存储文件并同样检索它们的设备的文件。</li><li id="2936" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">isCharacterDevice()</code> —这是一个带有布尔返回值的函数，如果文件是字符设备，则返回<code class="fe lv lw lx ly b">true</code>。字符设备指的是代表设备的文件，它提供对硬件设备的无缓冲直接访问。他们不需要允许程序一次读写一个字符。</li><li id="ac64" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">isDirectory()</code> —这是一个具有布尔返回值的函数，如果项目是目录，则返回<code class="fe lv lw lx ly b">true</code>。</li><li id="1768" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">isFIFO()</code> —这是一个具有布尔返回值的函数，如果项目是先进先出管道，则返回<code class="fe lv lw lx ly b">true</code>。FIFO管道意味着进入设备的文件的第一个位将与检索时出来的位相同。它只允许单向通信。</li><li id="6c32" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">isFile()</code> —这是一个具有布尔返回值的函数，如果项目是文件，则返回<code class="fe lv lw lx ly b">true</code>。</li><li id="eb3b" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">isSocket()</code> —这是一个具有布尔返回值的函数，如果项目是一个套接字，则返回<code class="fe lv lw lx ly b">true</code>。套接字是一种特殊的文件，它支持两个进程之间的通信。它可以通过域套接字发送数据和文件描述符。它可以进行双向通信。</li><li id="d6cc" class="mk ml it lb b lc mt lf mu li mv lm mw lq mx lu mp mq mr ms bi translated"><code class="fe lv lw lx ly b">isSymbolicLink()</code> —这是一个具有布尔返回值的函数，如果项目是符号链接，则返回<code class="fe lv lw lx ly b">true</code>。符号链接是以绝对或相对路径的形式对另一个文件或目录的引用。</li></ul><p id="38a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用同步版本的<code class="fe lv lw lx ly b">stat</code>函数，即<code class="fe lv lw lx ly b">statSync</code>函数，我们可以编写类似下面的代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="504f" class="md me it ly b gy mf mg l mh mi">const fs = require("fs");</span><span id="8665" class="md me it ly b gy mj mg l mh mi">const stat = fs.statSync("./files/file.txt");<br/>console.log(stat);</span></pre><p id="7d0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Stat</code>对象直接从<code class="fe lv lw lx ly b">statSync</code>函数返回。</p><p id="b521" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要使用<code class="fe lv lw lx ly b">fstat</code>函数，我们必须首先获得文件描述符，这可以通过<code class="fe lv lw lx ly b">open</code>函数及其变体来实现。例如，如果我们想使用<code class="fe lv lw lx ly b">open</code>函数来获取文件描述符，我们可以编写以下代码:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="3951" class="md me it ly b gy mf mg l mh mi">const fs = require("fs");</span><span id="bcb2" class="md me it ly b gy mj mg l mh mi">fs.open("./files/file.txt", "r", (err, fd) =&gt; {<br/>  if (err) throw err;<br/>  fs.fstat(fd, (err, stat) =&gt; {<br/>    if (err) throw err;<br/>    console.log(stat);<br/>    fs.close(fd, err =&gt; {<br/>      if (err) throw err;<br/>    });<br/>  });<br/>});</span></pre><p id="6100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以将<code class="fe lv lw lx ly b">fstat</code>与<code class="fe lv lw lx ly b">open</code>函数的promise版本一起使用，如以下代码所示:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="a3bc" class="md me it ly b gy mf mg l mh mi">const fsPromises = require("fs").promises;<br/>const fs = require("fs");</span><span id="054c" class="md me it ly b gy mj mg l mh mi">(async () =&gt; {<br/>  const fdObj = await fsPromises.open("./files/file.txt", "r");<br/>  fs.fstat(fdObj.fd, (err, stat) =&gt; {<br/>    if (err) throw err;<br/>    console.log(stat);<br/>    fs.close(fdObj.fd, err =&gt; {<br/>      if (err) throw err;<br/>    });<br/>  });<br/>})();</span></pre><p id="f9c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">open</code>函数的promise版本返回一个promise，该promise解析为一个包含文件描述符的对象。我们可以使用<code class="fe lv lw lx ly b">fd</code>属性获取文件描述符，并将其传递给<code class="fe lv lw lx ly b">fstat</code>函数。</p><p id="1e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，对于<code class="fe lv lw lx ly b">lstat</code>函数，我们可以用下面的代码来调用它:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="453c" class="md me it ly b gy mf mg l mh mi">const fs = require("fs");</span><span id="11a8" class="md me it ly b gy mj mg l mh mi">fs.lstat("./files/file.txt", (err, stat) =&gt; {<br/>  if (err) throw err;<br/>  console.log(stat);<br/>});</span></pre><p id="f22b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了获取符号链接的数据而不是跟随它之外，<code class="fe lv lw lx ly b">lstat</code>几乎做了和<code class="fe lv lw lx ly b">stat</code>一样的事情，所以我们将得到与上面类似的输出。</p><p id="3773" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">fs.stat()</code>、<code class="fe lv lw lx ly b">fs.lstat()</code>和<code class="fe lv lw lx ly b">fs.fstat()</code>函数对于获取关于文件、目录和符号链接的数据非常有用。</p><p id="8f23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们可以让我们获得<code class="fe lv lw lx ly b">Stat</code>对象，该对象包含大量我们可以使用的信息，包括访问时间、修改时间、文件是否是特殊文件、存储该文件的设备以及通过其值和函数属性获得的许多其他信息。</p><p id="e342" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">数据可以显示为数字或<code class="fe lv lw lx ly b">bigInt</code>(如果它们是数字的话),时间戳可以以毫秒和纳秒为单位，以获得额外的精度。</p></div></div>    
</body>
</html>