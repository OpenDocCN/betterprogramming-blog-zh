<html>
<head>
<title>Testing Flutter Apps: Build Confidence in Your Code and Iterate Faster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试Flutter应用程序:建立对代码的信心，更快地迭代</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/testing-flutter-apps-build-confidence-in-your-code-and-iterate-faster-450ea52b2068?source=collection_archive---------13-----------------------#2020-09-22">https://betterprogramming.pub/testing-flutter-apps-build-confidence-in-your-code-and-iterate-faster-450ea52b2068?source=collection_archive---------13-----------------------#2020-09-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d98" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">测试从未如此简单</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dbfe2363afd0e425dc92fe889d3d7f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pYQpdgmoiQNRtkL-"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@spacex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SpaceX </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="5090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Flutter是一个跨平台的应用程序开发框架。但是没有一个全面的测试套件，任何应用程序都是不完整的。在这篇文章中，我将告诉你单元测试和小部件测试Flutter应用程序的基本原理，以及模仿依赖性。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1ca9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">为什么要测试？</h1><p id="18e9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">开发任何严肃的软件项目时，测试都是至关重要的。有了一个好的测试套件，您可以对代码的任何部分进行修改，而不用担心这会破坏任何东西。如果系统运行正常，您可以随时运行测试，并在几分钟内获得答案。</p><p id="3e3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名开发人员，如果你不测试你的代码，你怎么能期望你的客户测试它呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ed01" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">单元测试</h1><p id="a7bb" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们将从单元测试开始，因为它们是最简单的。值得注意的是，Flutter清楚地将<em class="mz">单元</em>测试与<em class="mz">小部件</em>测试分开。在<em class="mz">窗口小部件</em>测试断言窗口小部件树并测试UI的地方，<em class="mz">单元</em>测试不应该呈现UI并纯粹测试业务逻辑。</p><p id="2be4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要开始测试您的类，您需要将<code class="fe na nb nc nd b">test</code>依赖项添加到您的<code class="fe na nb nc nd b">pubspec.yaml</code>中:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="6ead" class="ni md it nd b gy nj nk l nl nm">dev_dependencies: <br/>  test: <br/>    1.14.4</span></pre><p id="1b4d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们创建一个简单的模型类来进行测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="892c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个简单的类，有两个属性和一个自定义的getter。现在，在<code class="fe na nb nc nd b">test</code>文件夹中创建一个名为<code class="fe na nb nc nd b">PersonTest.dart</code>的文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="bdac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是有史以来最简单的测试示例。首先，在第1-2行，我们导入了将要测试的<code class="fe na nb nc nd b">test</code>模块和<code class="fe na nb nc nd b">Person</code>类。然后，在<code class="fe na nb nc nd b">main</code>方法中，我们使用<code class="fe na nb nc nd b">test</code>函数定义一个测试。它将接受测试的名称和一个执行测试本身的回调函数。在其中，我们创建了<code class="fe na nb nc nd b">person</code>模型和<code class="fe na nb nc nd b">person.name</code>将成为<code class="fe na nb nc nd b">'John Smith'</code>的<code class="fe na nb nc nd b">expect</code>。</p><p id="bd67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe na nb nc nd b">test</code>包公开了许多可以和<code class="fe na nb nc nd b">expect</code>一起使用的断言函数，比如:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="75c9" class="ni md it nd b gy nj nk l nl nm">expect(person, isA(Person)) <br/>expect(person, isA(String))</span></pre><p id="64d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是来自<code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/documentation/matcher/latest/matcher/matcher-library.html" rel="noopener ugc nofollow" target="_blank">matcher</a></code>模块(内置于<code class="fe na nb nc nd b">test</code>)的一些常见断言:</p><ul class=""><li id="d2f0" class="np nq it lb b lc ld lf lg li nr lm ns lq nt lu nu nv nw nx bi translated"><code class="fe na nb nc nd b">isEmpty</code></li><li id="43b9" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe na nb nc nd b">isList</code></li><li id="1420" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe na nb nc nd b">isFalse</code> / <code class="fe na nb nc nd b">isTrue</code></li><li id="52e9" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe na nb nc nd b">isNaN</code></li><li id="4465" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe na nb nc nd b">isNull</code></li><li id="be7b" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe na nb nc nd b">throwsException</code></li></ul><p id="8178" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，如果您尝试运行测试(您可以使用Android Studio，<em class="mz"> Run - &gt; Run tests </em>)，您将会看到这个测试通过了。干得好！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0deb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">小部件测试</h1><p id="58c4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">单元测试非常简单:执行动作，断言结果。当UI发挥作用时，一切都变得复杂了。让我们再写一个最简单的例子:一个显示你的名字的小部件。我们将确保它正确渲染，并在屏幕上显示您的姓名。</p><p id="410b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们创建小部件。将以下内容添加到您的<code class="fe na nb nc nd b">main.dart</code>文件中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="773b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里应该没有什么令人惊讶的——只是一个需要命名参数<code class="fe na nb nc nd b">name</code>的无状态小部件。完成后，在<code class="fe na nb nc nd b">test/main_test.dart</code>中添加测试代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="35fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以看到，我们没有导入<code class="fe na nb nc nd b">test</code>包，而是导入了<code class="fe na nb nc nd b">flutter_test</code>包。为了让它工作，确保你的<code class="fe na nb nc nd b">pubspec.yaml</code>中有这个:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="a52c" class="ni md it nd b gy nj nk l nl nm">dev_dependencies: <br/>  flutter_test: <br/>    sdk: flutter</span></pre><p id="98d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在第5行，注意我们如何使用<code class="fe na nb nc nd b">testWidgets</code>函数而不是<code class="fe na nb nc nd b">test</code>。它为您注入了包含一些渲染所需的UI设备的<code class="fe na nb nc nd b">WidgetTester</code>对象。它也是异步的，因此回调函数使用了<code class="fe na nb nc nd b">async</code>关键字。</p><p id="7c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第6行，我们用<code class="fe na nb nc nd b">pumpWidget</code>函数呈现用户界面。它的行为完全符合您的预期。您只需向它传递一个小部件。之后，我们创建一个<em class="mz">查找器</em>，用于在UI树中查找小部件。我们希望找到具有指定名称的文本框。最后，在第10行，我们<code class="fe na nb nc nd b">expect</code>说<code class="fe na nb nc nd b">nameFinder</code>将<code class="fe na nb nc nd b">findsOneWidget</code>。对于其他情况，也可以用<code class="fe na nb nc nd b">findsNothing</code>、<code class="fe na nb nc nd b">findsWidgets</code>(一个或多个)、或者<code class="fe na nb nc nd b">findsNWidgets</code>(确切的说是<code class="fe na nb nc nd b">n</code>小部件)来断言。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e0c7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是嘲讽？</h1><p id="d633" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在测试时，我们主要想检查我们编写的代码<em class="mz">是否有效。特别是对于单元测试来说，我们并不关心互联网是否工作或者数据库是否可用。我们想孤立地检查函数。</em></p><p id="74be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但大多数情况下，不可能得到完全纯的、非依赖的函数。他们将导入其他模块和库，这在测试环境中可能是有问题的或者完全不可能调用的。为了解决这个问题，devs想出了嘲讽的主意。</p><p id="bb53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">模仿是用模仿代替系统的一部分(一个函数，一个导入，任何东西)。模拟看起来就像它所替换的部分，但是它根本不做任何事情。使用mock，我们能够指定它的返回值和副作用来测试所有可能的场景。此外，我们能够在模拟上断言，这为我们的测试场景增加了另一个维度。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi od"><img src="../Images/1158c959a52ccf865412ecbc7deb2dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*TG0SWU-yu-c87Vv5"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">作者照片。</p></figure><p id="a9f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常简化的MVC应用程序中依赖树的示意图。假设我们要测试<em class="mz">控制器</em>类，它依赖于<em class="mz">模型</em>类，后者依赖于<em class="mz">数据库</em>。由于我们无法在单元测试环境中访问数据库，我们制作了一个名为<em class="mz"> MockModel </em>的mock，它将具有与<em class="mz"> Model </em>完全相同的接口，但不会对数据库执行任何操作。</p><h2 id="914c" class="ni md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">添加依赖关系</h2><p id="1f46" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">利用<code class="fe na nb nc nd b">mockito</code>库可以模仿，所以您需要将它添加到您的<code class="fe na nb nc nd b">pubspec.yaml</code>中:</p><pre class="kj kk kl km gt ne nd nf ng aw nh bi"><span id="56c4" class="ni md it nd b gy nj nk l nl nm">dev_dependencies:<br/>  mockito: 4.1.2</span></pre><p id="8aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">查看<a class="ae ky" href="https://pub.dev/packages/mockito" rel="noopener ugc nofollow" target="_blank">发布开发</a>获取最新版本。</p><h2 id="4c8c" class="ni md it bd me oe of dn mi og oh dp mm li oi oj mo lm ok ol mq lq om on ms oo bi translated">模仿HTTP调用</h2><p id="d464" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">模仿的一个常见用例是API调用。假设您有一个查询汽车的<em class="mz">汽车API </em>的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="78d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第5-8行，我们定义了一个带有单个字段<code class="fe na nb nc nd b">model</code>的<code class="fe na nb nc nd b">Car</code>模型。我们要测试的函数是<code class="fe na nb nc nd b">fetchCar</code>。但是，当然，在每次测试运行时进行HTTP调用(您应该经常这样做)是不合适的。</p><p id="ac40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能想知道为什么我们将<code class="fe na nb nc nd b">client</code>作为参数传递给函数。为什么不在函数本身中创建它呢？嗯，这是<code class="fe na nb nc nd b">mockito</code>库的缺点之一。虽然它创建了优秀的模拟，但它不允许您模拟任意的导入。换句话说，您必须通过参数/setter/阿迪解决方案来传递您的mock，以使它们工作。在这种情况下，TDD实践变得更加重要，因为您必须将代码设计成从第1行就可以测试。</p><p id="b82e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，在您的测试文件中，我们可以创建一个模拟客户端:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="abf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这么简单！首先，导入<code class="fe na nb nc nd b">mockito</code>和<code class="fe na nb nc nd b">http</code>库，然后定义一个包含<code class="fe na nb nc nd b">extends</code> <code class="fe na nb nc nd b">Mock</code>和<code class="fe na nb nc nd b">implements</code> <code class="fe na nb nc nd b">Client</code>的类。因此，每个模拟类都必须扩展<code class="fe na nb nc nd b">Mock</code>并实现你所模拟的任何类。剩下的就交给我了。现在，测试本身:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="ef54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们这里有两个测试:一个测试它是否工作，另一个测试它是否损坏。在第3行和第12行，您可以看到mock <code class="fe na nb nc nd b">client</code>的创建。那里没什么特别的。然后，在第5-6行和第14-15行，我们为模拟客户端设置目标行为。我们用这个<code class="fe na nb nc nd b">);</code>说<code class="fe na nb nc nd b">when(</code>某个动作<code class="fe na nb nc nd b">).thenAnswer(</code>。在第一种情况下，我们返回一个有效的响应来检查(第8行)函数是否返回一辆汽车。在第二种情况下，我们返回一个HTTP 500来检查是否抛出了异常。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="ad18" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结束语</h1><p id="2bab" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在本文中，我解释了测试Flutter应用程序的基础。感谢您的阅读。如果你知道任何在Dart中嘲讽任意进口的方法，请在评论中告诉我！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e961" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">资源</h1><ul class=""><li id="38b3" class="np nq it lb b lc mu lf mv li op lm oq lq or lu nu nv nw nx bi translated"><code class="fe na nb nc nd b"><a class="ae ky" href="https://pub.dev/packages/test" rel="noopener ugc nofollow" target="_blank">test</a></code> <a class="ae ky" href="https://pub.dev/packages/test" rel="noopener ugc nofollow" target="_blank">模块文档</a></li><li id="3f7d" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><code class="fe na nb nc nd b"><a class="ae ky" href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" rel="noopener ugc nofollow" target="_blank">flutter_test</a></code> <a class="ae ky" href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" rel="noopener ugc nofollow" target="_blank">模块文档</a></li><li id="8ada" class="np nq it lb b lc ny lf nz li oa lm ob lq oc lu nu nv nw nx bi translated"><a class="ae ky" href="https://medium.com/flutter-community/bloc-in-flutter-implement-clean-flux-like-architecture-e8af2869bcc0" rel="noopener">在颤动中阻塞</a></li></ul></div></div>    
</body>
</html>