<html>
<head>
<title>Promises vs. Observables in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的承诺与观察</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/promises-vs-observables-in-javascript-208ec84f701b?source=collection_archive---------16-----------------------#2020-02-17">https://betterprogramming.pub/promises-vs-observables-in-javascript-208ec84f701b?source=collection_archive---------16-----------------------#2020-02-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b3e8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">直观的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c041031637fff136adbacbc785a0f59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X5hE3_MgjJJ3Sm27"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@plushdesignstudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">毛绒设计工作室</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="9ead" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据来自<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> MDN Web Docs </a>的官方定义，<code class="fe lv lw lx ly b">Promise</code>是一个“代表异步事件的最终完成或失败”的对象。这意味着一旦一个<code class="fe lv lw lx ly b">Promise</code>被创建，它就被异步执行，当它解析或拒绝时，结果被传递给适当的处理函数，<code class="fe lv lw lx ly b">Promise</code>完成。就这么简单！以下示例演示了这一简单的功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><pre class="kj kk kl km gt mb ly mc md aw me bi"><span id="aa38" class="mf mg it ly b gy mh mi l mj mk">Output:</span><span id="a3c9" class="mf mg it ly b gy ml mi l mj mk"># After 5 seconds, both results are printed immediately</span><span id="ff58" class="mf mg it ly b gy ml mi l mj mk">Message: 1</span><span id="2ad3" class="mf mg it ly b gy ml mi l mj mk">2</span></pre><p id="c9a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以很容易地使用<code class="fe lv lw lx ly b">Promise</code>来执行HTTP调用，并将多个调用按顺序链接起来或者并行运行——并以一种直接的方式处理错误。</p><p id="be67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，看看这段代码和输出，我们可以看到<code class="fe lv lw lx ly b">Promise</code>甚至都不是与反应式数据流交互的理想方法。</p><p id="3bd3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，<code class="fe lv lw lx ly b">Promise</code> s在声明的瞬间被执行。在上面的例子中，两个<code class="fe lv lw lx ly b">Promise</code>一旦被声明就开始执行。这就是为什么第二个<code class="fe lv lw lx ly b">Promise</code>的输出会在第一个<code class="fe lv lw lx ly b">Promise</code>解析后立即打印:第一个<code class="fe lv lw lx ly b">Promise</code>在五秒后解析，而第二个在两秒后解析，在第一个解析之前。</p><p id="3bde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其次，没有取消<code class="fe lv lw lx ly b">Promise</code>的机制——它们是不可变的。这意味着在处理需要很长时间才能解决的HTTP调用时会出现严重的问题。在这种情况下，我们需要依靠一些第三方库来执行额外的逻辑。</p><p id="50ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，但最重要的是，<code class="fe lv lw lx ly b">Promise</code> s处理产生单个值的数据源。也就是说，我们不能将<code class="fe lv lw lx ly b">Promise</code>用于异步数据序列，比如鼠标/键盘事件。</p><p id="fad8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了克服这些缺点，RxJS库提供了以相同方式处理每个异步数据源的方法，无论是鼠标/键盘还是HTTP事件。在RxJS中，我们必须从流的角度来考虑，流可以定义为一段时间内发出的一系列事件。这些流由几个组件组成(生产者、消费者和数据管道)。现在，我们只需要关注生产者，它是由随时间异步生成事件并发送给所有消费者的东西创建的。在RxJS中，生产者被称为<em class="mm">可观测量</em>。</p><p id="7a95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的例子演示了如何通过可观测量来克服<code class="fe lv lw lx ly b">Promise</code> s的上述缺点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="7752" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我正在从鼠标事件<code class="fe lv lw lx ly b">mousedown</code>、<code class="fe lv lw lx ly b">mouseup</code>和<code class="fe lv lw lx ly b">mousemove</code>中创建可观察对象。我也链接这些可观察的事物，最后，订阅这个链接。</p><p id="2862" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，异步事件流和链接流保持休眠状态，直到订阅者开始监听。这样，<code class="fe lv lw lx ly b">Promise</code>的一个主要缺点就被可观测量克服了。</p><p id="5992" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，如果你仔细观察链接的可观察对象，我正在定义一个条件来取消它:当一个<code class="fe lv lw lx ly b">mouseup</code> <strong class="lb iu"> </strong>事件被发出时，取消可观察对象并停止监听。我们也正在克服<code class="fe lv lw lx ly b">Promise</code> s的另一个主要缺点。</p><p id="ae18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们可以说，随着时间的推移，观察对象可以与异步值一起工作，而不仅仅是像<code class="fe lv lw lx ly b">Promise</code> s的情况那样的单个值。在这个示例中，我有三个从鼠标事件创建的观察对象，以及一个链接的观察对象，当鼠标被单击和拖动时开始发出值，当鼠标键被释放时停止。</p><p id="1b66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在您离开之前，一定要看看这个关于从异步事件中创建可观测量的精彩动画<a class="ae ky" href="https://reactive.how/fromevent" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b2fa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保重。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8073" class="mu mg it bd mv mw mx my mz na nb nc nd jz ne ka nf kc ng kd nh kf ni kg nj nk bi translated">资源</h1><div class="nl nm gp gr nn no"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">承诺</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">Promise对象表示异步操作的最终完成(或失败),及其结果…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">developer.mozilla.org</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ks no"/></div></div></a></div></div></div>    
</body>
</html>