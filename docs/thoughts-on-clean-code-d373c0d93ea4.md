# 读完《干净的代码》后我学到的 30 个编码概念

> 原文：<https://betterprogramming.pub/thoughts-on-clean-code-d373c0d93ea4>

## 我对干净代码的想法

![](img/3aa52b7c6a63ffe0e8833fafee647918.png)

乔纳斯·雅各布森在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

最近我读完了鲍勃大叔的经典《干净的代码》。
因为我喜欢记下我读过的所有东西，所以我认为总结这本书并创建一个方便的剧本将是一个很好的主意。

显然，这个列表并不完整。随着我体验和发现更多的编码风格、方案和观点，它可能会以许多方式发展和转变。

由于应该有一个清晰的代码，所以本文将以同样的方式进行概述。首先，我将介绍宏观原则——总体思想，以及干净代码的概念。随着本文的深入(与代码一样)，细节、策略和实用信息也将被传达。

# 干净的编码方法

## 你可能是下一个阅读你写的代码的人——帮你未来的自己一个忙

尽管开发人员为他们的职业写代码，他们也做了大量的*阅读代码*。事实上，大多数开发人员做的阅读比实际编码更多。

你刚刚写的代码看了多少遍？显然，这种比例有利于阅读，而不利于实际编码。

如果我们的大部分时间都花在理解和阅读代码上，我们最好确保当我们真正编码时，它对我们所有的同行都是明确的。既然你很可能是下一个阅读你正在写的代码的人，那就确保你从现在起两个月后也会理解它。我敢肯定，几乎每个程序员(至少我)都在凌晨 3 点写代码，只是为了第二天醒来，然后花几个小时试图弄清楚发生了什么。

确保你的代码清晰明了将会减少 WTF 时刻，提高你的生产力，并且从长远来看会有持久的效果。帮你自己一个忙，开始写干净的代码。

## 除了“可行”和“不可行”之外，还有更多参数需要编码

代码不应该仅仅以“有效”或“无效”来衡量。当然，不起作用的代码不是好的——因为它不起作用。

但是有效的代码不一定是好的，这是一个非常重要的区别。一旦我们的代码被证明有效，我们作为开发人员的工作就没有结束。

专业的开发人员确保代码通过所有的测试后，它也是清晰、干净和可维护的。如何编写干净的代码的实际原则将会遵循，但是现在，我们不能只根据代码的可使用性来判断代码。

对于一段写得好的代码，有更多的参数和指导原则。

## 清晰比聪明好

作为软件工程师，我们致力于解决问题、创造和深入思考。很多时候，当遇到复杂的问题时，我们的代码可能会变得“聪明”——比如，做一些非常聪明的事情，只有编写代码的人才能理解到底发生了什么。

即使问题很难解决，这也不是一个令人满意的结果。真正的精通和专业是解决一个复杂的问题，并清晰明了地展示其解决方案，这样其他人就能够审阅代码并参与其中。这不是因为我们需要对我们的同事友好，并与他们分享乐趣(尽管这也是一个很好的理由)，而是如果你是唯一一个理解代码的人，从长远来看，这将对你有害。

你的同事不仅会在重构代码时遇到困难，而且还会限制项目并使其变慢——你将永远依附于一段代码，直到你死去或离开公司。

我们必须确保在我们解决了一个问题之后，这个解决方案对任何阅读这段代码的人来说都是清晰而简单的。

## 预期和信任至关重要

当有人阅读你的代码时，你和读者之间会有一个建立信任的过程。信任基本上是传达给信心的。读者对你写的代码有一定程度的信心，当信心很高时，项目可以进行得更快。

我希望现在很清楚，读者也是你未来的自己。如果你不信任你自己的代码，那么祝你好运。

那么，如何才能与读者建立信任和信心呢？让他们正确预测将要发生的事情。一旦读者理解了代码，知道了代码应该做什么，并且正确地*预测了接下来*会发生什么，双方之间就建立了信任。

防止可能使读者困惑的意外、不清楚和不明确的代码。如果一个函数或一个类被期望做某个动作，但是读者感到惊讶，其他的动作也完成了——信心动摇了，读者不能再相信程序员了，他们怎么能相信呢？他们在这段代码上是错误的，现在他们将在整个审查过程中处于不断猜测的模式中。

## 干净的代码不会自己立刻出现

既然我们已经阐明了为什么干净的代码对我们作为开发人员的成功至关重要，我们面临着一个致命的问题:

*如何编写干净的代码？*

嗯，它肯定不会自己发生。它需要实践、持续的迭代和重构，并不断坚持干净代码的原则。Bob 叔叔清楚地提到，即使是他也不会第一次就写出干净的代码。每一段代码在编写和重构后都要经过检查，以遵守干净代码的原则。

# 永恒的原则

## 单独关注

代码中的每一部分都应该处理软件的某一方面。编写涉及独特问题的函数或类不是干净代码的例子。相反，要保持业务逻辑的分离。无论我们谈论的是模块、类、函数——每一个都有自己的抽象层次。

然而，原则很简单:我现在写的逻辑是什么？这里主要关心的是什么？我还有其他需要关注的问题吗？如果有，就把它们分开。

## 代码就像一篇文章

一篇文章，或者一个博客，有一个清晰的结构。主主题在顶部，当我们继续阅读文章时，我们可以注意到主主题被分成了几个子部分，在这些子部分中，我们有关于每个部分的更多细节。

代码应该遵循同样的原则。

开始时，我们将主要关注这段代码正在处理的问题。随着我们的进展，函数和类将需要更多的实现细节，并保持关注点的清晰分离——就像每个博客都有一个副标题和一个与之紧密相关的段落。

每段代码都应该分成处理特定问题的类和函数，当我们在它们内部进行时，它们只处理那个问题

## **童子军规则**

当我在童子军的时候，我是有特殊需要的孩子的指导员。我们去实地考察时的指导原则是“让这个地方比你发现时更干净”。

显然，鲍勃大叔在他的书中对代码也有同样的感觉——*总是让代码比你发现的更好。*如前所述，干净的代码是一个过程。它包括您和组织中其他人的持续改进和发展。

因此，让代码比你发现的更好。糟糕的变量名，无用的注释，注释掉的代码——它停留的时间越长，味道就越难闻。积极主动。做一名童子军。

## **干净、可重复使用、可维护**

始终确保您的代码遵循这些准则。通过确保这一点，你就核对了这本书的大部分原则。

干净的代码是具有良好结构的代码，清晰，命名良好，并且不包含意外。

可重用代码迫使您分离关注点，保持正确的抽象级别，并防止您编写逻辑上依赖于其他部分的代码(稍后将详细介绍)。

可维护的代码允许其他人参与并理解正在发生的事情。它考虑到了软件会随着时间而变化。因此，预测变化，并确保如果发生变化，代码将易于重构。

## **永不重复**

重复意味着代码不干净。遵循干巴巴的原则——不要重复自己。复制需要一个函数、类、组件——无论什么！只是不要重复！

每当你发现自己在做最轻微的`ctrl+c`和`ctrl+v`序列时，直觉地问自己是否有更好的选择。大多数情况下，答案是肯定的。

## **避免逻辑依赖**

逻辑依赖意味着一段代码依赖于一段单独的代码来包含特定的业务逻辑，假设代码不会改变，因此实现是好的。

当我们编写代码时，我们必须确保代码是“独立的”——我们有正确的抽象级别，代码不知道它不应该知道的信息(基于它的抽象和关注级别)，并且如果代码被重构，我们将不会在其他函数和类中有不寻常的副作用。

# 命名

## 选择描述性和明确的名称

名称应该描述做了什么或包含了什么。清晰的一部分是不要让这个名字有任何其他的解释，并且只引导读者得出一个可能的结论。请注意，下面的例子不需要任何形式的注释或解释。这是描述性的，只能得出一个结论。

```
// BADlet days;// elapsed time in days //CLEAN 
let daysSinceCreation;
let daysSinceUpdate;
let ageInDays;
let elapsedDays;
```

## **做出有意义的区分**

重要的是要有上下文和结构不同的名称。出于显而易见的原因，我们不想混淆一个变量/函数与另一个变量/函数的上下文和含义。

然而，他们也不能有一个非常相似的名字。

```
// Not distincting context 
getActiveAccount();
getActiveAccountInfo();
getActiveAccountData();
```

在上面的例子中，不能确定`Account`、`AccountInfo`和`AccountData`之间的区别。他们说的差不多一样。什么是*数据*？什么是*信息*？什么是*账户*如果不是*账户数据*它们有什么不同？这些模棱两可的名字引发了很多问题。

```
// Not disticnting structure
getActiveAccount()
getActiveAccounts()
getActivityAccount()//With distinction 
getActiveAccount()
getManyActiveAccounts()
getAccountActivity()
```

还应该考虑所有代码编辑器中的自动完成特性。拥有非常相似的名字很容易导致自动提示错误、不正确的阅读，从而导致调用不正确的函数。

## **使用可搜索的名字**

当我们在代码中命名变量时，我们必须确保它们没有被编码，不要太短(1-2 个字母)，也不要太常见——这取决于它们的重要性和范围。

在下面的例子中，该应用程序是学生的课程管理平台。

```
//Bad examples
const max=7;
const students=7;//Clean example
const MAX_CLASSES_PER_STUDENT=7;
```

我认为你找到那个变量不会有任何困难，而`max` 和`students` 很可能是这个应用程序中的常用词

## **没有魔法值**

神奇的值是“神奇地”出现在代码中的值，应该传达一些意义，但是没有人能分辨，因为它们只是数字/字符串。
不惜一切代价避免在代码中喷洒魔法值。确保为这些值分配一个变量，以便于清晰和重构。

```
//BAD 
if(val === 38) console.log('congratulations!')//CLEAN
const JACKPOT=38;
if(val === JACKPOT) console.log('congratulations!')
```

## **不披露实施情况**

我们实现代码的方式不时不同，并且完全不同。将某种实现方式绑定是一种约束，随着时间的推移，这种约束实际上会变得过时。

```
//BAD 
spliceProductFromArr()
let productArr=[]; //CLEAN 
removeProductById()
let products=[];
```

## **谨防命名约定**

如果我们正在开发一个主要与汽车相关的应用程序，我们的命名约定是什么？汽车？车辆？汽车？无论哪一个，请考虑`car`一致。

在需要的时候，应该在函数、变量、服务、类中引用所选择的名称。然而，同义词非常令人困惑，所以选择一个一个词的约定并坚持下去。

## **避免思维导图**

要求读者(和编码者)记住其含义的变量通常是坏的变量名。想到的唯一例外是循环中的迭代器`i`和`j`。

除此之外，名字应该反映现实，足够一致和描述性，以避免任何心理映射或任何类型的记忆。

# 功能

## **应小**

小功能帮助你正确地讲述故事。它们增加了代码的顺序、关注点的分离、适当的抽象和正确的结构。

如果你的功能不小，它可能没有遵循我们很快会发现的其他重要原则。如果命名正确，小函数可以使代码清晰、易于调试、易于理解。

*多小？*你可能会想。好吧，根据《干净的代码》的作者鲍勃叔叔的说法，一个函数不应该超过 20 行代码。

根据鲍勃的说法，如果是的话，那么你可以把它分解成另一个函数。关于确切的数字，我确信如果我们编写大型函数，这只是一个经验法则或一个警告。

> “函数的第一条规则是它们必须很小。第二条规则是，它们必须比这个小。”

## **做一件事**

函数应该做一件事，而且只做一件事。有时，很难确定函数只做一件事，但一个重要的原则是确保我们不会同时做多件事。鲍勃的规则？如果它做不止一件事，那么你可能有两个功能，而不是一个。

> “功能应该做一件事。他们应该把它做好。他们应该只做这件事”

## **宜名正言顺**

所有的功能都有作用。这就是它们的目的——发挥作用。因此，在命名函数时，它们应该有动词来表示它们的作用。

`get`、`set`、`save`、`remove`、`load`、*……*、**、*、*、**你明白其中的要义了吧？

然而，一个众所周知的常见例外是单词`is` *—* 用于检查布尔条件。

约定是函数应该返回一个关于条件的布尔值(没有错误的预期)。因此，一个无效的密码 *(* `password` *)* 预计会返回一个布尔值。

## **应尽量减少争论**

理想情况下，争论越少越好。然而，如果我们想使我们的功能可重用并且独立于任何其他业务逻辑，可能需要一些参数。

因此，最多两个参数就可以了，应该避免三个参数，超过三个参数就会招致麻烦。这一原则背后的思想是，函数无论如何都是非常小的，所以如果你需要 3 个对业务逻辑至关重要的参数，可能大函数的解耦做得很差。

也就是说，逻辑过于紧密地联系在一起，也许在代码中的不同点分离会更好。

## **不产生副作用**

除了它的主要职责之外，功能不应该对其他过程有任何副作用或影响。正如“做一件事”规则所建议的，除了指定的任务之外，它不应该做任何其他事情。

这有助于防止意外，更容易调试和准确跟踪什么做什么。

## 编写函数的简洁方法

我们承认吧。我们第一次尝试就很难写出符合这些原则的函数。为了在第一次尝试中得到它，我们可能会想太多，做太多的计划。

但事实是，我们第一次写函数时，它并不应该是完美的。就像写作一样，编码有它的层次、草稿、细化(重构)和发展，直到它变得清晰而闪亮。鲍勃叔叔雄辩地说:

> “写软件就像任何其他类型的写作一样。当你写一篇论文或一篇文章时，你首先把你的想法写下来，然后你对它进行按摩，直到它读起来很好。初稿可能很笨拙，也没有条理，你会对它进行文字加工、重组和精炼，直到它达到你想要的效果吗

# 班级

## **应该是小**

班级的第一条规则是他们必须很小。第二条规则是，他们需要比这更小。听起来很熟悉？类应该遵循和函数一样的原则——尽可能的小。

然而，有一个小的区别——类可能做不止一件事。大多数时候，他们可能会做不止一件事。也就是说，他们必须遵循单一责任原则

## **单一责任原则**

类应该有一个责任，仅此而已。这就是关注点分离的实际关注点…作为开发人员，我们必须确保类只有一个责任来创建小而干净的类。

责任是一个术语，在这个上下文中意味着改变的的*理由。这个类改变的原因应该只有一个。如果多重原因能导致班级发生变化，说明班级的责任太多了。这是一种简洁的方法来确保这个类有一个单一的职责。*

## **衔接**

一个类中的逻辑是如何“粘合”在一起的，并且在其中有连接点吗？这些方法用逻辑和类实现得有多好，它们在正确的位置吗？

可能有助于回答这些问题的一个好指标是一个类中实例变量的数量。理想情况下，我们希望减少实例变量的数量，并在类的方法中使用它们。这就是班级的凝聚力。

这些方法与类密切相关，它们使用实例变量，逻辑由所有方法培养和使用。这是一个强有力的指标，表明所有的方法和关注点都在正确的位置。

> 保持函数小和参数列表短的策略有时会导致方法子集使用的实例变量激增。当这种情况发生时，几乎总是意味着至少有一个其他的类试图脱离这个更大的类。你应该试着把变量和方法分成两个或更多的类，这样新的类更有凝聚力”

# 干净代码的一般概念

## 最好的评论是你没写的评论

代码中的注释，不包括技术方面，要尽可能地减少。它们很难维护，它们通常试图掩盖不够干净的代码。

如果你觉得有必要写一个注释来解释代码是做什么的，这应该是一个危险信号，你应该仔细检查你的代码，确保它足够干净。

我们不是指作为库文档一部分的注释，也不是指许可的技术注释。

评论应该减轻。首要原则是，如果你需要解释代码做什么，代码不够清楚。代码应该自己解释自己。应该是不言自明的，供其他同行审阅。

## **了解算法**

理解算法是编写干净代码的关键一步。除了我们需要理解算法的明显原因之外，只有当一个人真正理解了算法，他才能写出干净的代码。

如果我们花时间学习算法，并确保我们知道它的复杂性，我们将能够把它分解成更小的部分。从那里开始，编写干净代码的路径相当简单

> 我们编写干净代码的能力来源于我们对算法的理解，以及选择精确的点将其分解成更小的部分

## **小心抽象层次**

在计划和编写代码时，抽象级别是一个需要考虑的重要概念。当我们写一个函数时，我们考虑它在解决方案中的位置。

是不是高级函数这个和算法密切相关？或者它是一个负责实用目的的函数(比如解析命令行、检查条件、执行某些计算)？

抽象层次原则是另一种确保我们将所有的函数和类保持在原位，并且我们的函数只做一件事的方法。如果一个函数混合了不同层次的抽象，那么它肯定不止做一件事。

从抽象的角度思考是一种工具，可以帮助我们更好地组织功能的结构，并计划如何组装整个拼图。

实际上，我们总是从处于最高抽象层次的高级功能开始。每个函数在调用另一个函数时只能下降一级。

正如我们已经讨论过的，算法和具体实现的粒度细节将在源代码中进一步揭示。

主导问题是*在这个逻辑中我关心什么？当然，我们关心每一行。然而，包含主要逻辑的算法的必要部分是什么？这是最高层次的抽象。*

整个逻辑的编排。边界检查、错误处理、解析、计算——它们处于不同的抽象层次。它们应该被提取到不同的功能中，每个功能处理自己的抽象层次。

考虑以下代码:

```
//Mongoose call to create a product
async function createProduct(productToSave) { try { const product = new Product(productToSave) return await product.save() } catch (e) { _handleError('failed to create product in db', e)}}
```

注意到`_handleError` 功能了吗？除了指出错误是什么，函数`createProduct`不知道错误是如何处理的。它只是传递错误，让一个不同的函数在较低的抽象层次上运行。

这是为什么呢？因为这不是它的责任。该函数获取一个产品，并从数据库返回一个保存的产品。错误？太好了。不是它的责任。它激活了`_handleError`函数，正如它的名字所表明的那样:处理错误。

```
function _handleError(msg, e = 'initiated') { logger.error(msg, e) throw Error(msg, e)}
```

上面的函数知道记录器如何处理错误吗？一点也不。

正如我们可能已经理解的那样，记录错误不是它的工作。它的工作是处理错误——在下一个更低的抽象层次调用相关函数并传递信息

# **最后一句话:保持一致**

总之，我相信这是干净代码和成为伟大程序员的秘诀。每个人都有自己的风格、独特的观点和解决问题的不同方法。

因此，与本文中提到的所有原则保持一致是能够编写可维护、可重用、清晰和干净的代码的关键。

祝你好运！