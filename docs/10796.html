<html>
<head>
<title>The Facade Design Pattern in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的外观设计模式</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/design-patterns-in-swift-facade-a7303dc3d95b?source=collection_archive---------18-----------------------#2022-01-27">https://betterprogramming.pub/design-patterns-in-swift-facade-a7303dc3d95b?source=collection_archive---------18-----------------------#2022-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="464b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们使用Swift中的一个真实例子来讨论门面设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/747be9490a7dd8ec98c58aa9ddc9bddd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rS1ObhdGW3gIl5lpy-7qvA.jpeg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@danielfazio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">丹尼尔·法齐奥</a>在<a class="ae kv" href="https://unsplash.com/s/photos/facade?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="e060" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Facade是一种设计模式，它为一组子系统提供了一个简单的接口。</p><p id="0b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它有助于降低复杂性，并最小化子系统之间的依赖性。</p><p id="bbac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们来看一个Facade实现的通用结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="a512" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">门面实现通常有两个主要参与者:</p><p id="4e5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Facade </strong>:提供了一个更高级别的接口，当我们不关心我们子系统的细节，或者当我们想要简化它们之间的交互时，可以使用这个接口。它可以是一个类或者一个结构(为了简单起见，我们只是在例子中使用了一个类，但是如果场景允许的话，它肯定可以是一个结构)。</p><p id="0604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">子系统</strong>:实现子系统的功能，对外观类型一无所知。与Facade组件相同，它可以是类或结构。</p><h2 id="a858" class="lu lv iq bd lw lx ly dn lz ma mb dp mc lf md me mf lj mg mh mi ln mj mk ml mm bi translated">真实世界的例子</h2><p id="e154" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">假设我们正在开发一个电影应用程序，我们负责获取即将上映的电影列表。</p><p id="dc5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种获取应该考虑到我们有两种类型的用户帐户:高级和非高级，并且显示的列表将包含每种帐户类型的不同电影。</p><p id="2784" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有这些信息(用户帐户类型和根据帐户类型的电影列表)都应该从后端服务中检索。</p><p id="9f09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，假设我们的应用程序中已经有了这两个客户端:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="10fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ms mt mu mv b">AccountClient</code>有一个方法来检索当前用户的帐户类型，而<code class="fe ms mt mu mv b">MoviesClient</code>有一个方法来检索给定特定帐户类型的即将上映的电影列表。</p><p id="053d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意</strong>:这两个协议的实现细节对于本文来说不是必需的。我们只需要关注协议的方法定义。</p><p id="bd45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可能会想，无论谁想要检索电影列表，都应该将这两个方法链接起来(从<code class="fe ms mt mu mv b">AccountClient</code>获取帐户类型，并将其传递给<code class="fe ms mt mu mv b">MovieClient</code>以获取即将上映的电影)；但是这种方法有几个缺点:</p><ol class=""><li id="62c8" class="mw mx iq ky b kz la lc ld lf my lj mz ln na lr nb nc nd ne bi translated">我们依赖两个客户端来执行一个相当简单的任务(如果要执行的任务非常复杂，依赖性可能会迅速增加)。任何时候，我们想要获得即将上映的电影列表，无论是付费的还是非付费的，我们都需要与这两种依赖关系进行交互。</li><li id="ec82" class="mw mx iq ky b kz nf lc ng lf nh lj ni ln nj lr nb nc nd ne bi translated">当检索电影列表时，我们需要了解两个客户端的实现细节。这些客户可能有很多我们不关心的方法，在列出电影时对我们没有用。</li></ol><p id="2560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个使用门面模式的好地方！</p><p id="ecbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将实现一个<code class="fe ms mt mu mv b">MovieListFetcher</code>,作为我们两个客户的门面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="686e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所注意到的，<code class="fe ms mt mu mv b">AccountClient</code>和<code class="fe ms mt mu mv b">MoviesClient</code>将是我们的子系统，<code class="fe ms mt mu mv b">MovieListFetcher</code>将是这两个子系统的门面实现。</p><p id="dc70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用Facade模式，我们基本上抽象了子系统的接口，使它们更容易使用:我们不应该再关心<code class="fe ms mt mu mv b">AccountClient</code>或<code class="fe ms mt mu mv b">MoviesClient</code>如何工作，我们只需要创建一个<code class="fe ms mt mu mv b">MovieListFetcher</code>的实例，并调用它的<code class="fe ms mt mu mv b">getMovies</code>方法！</p><p id="2489" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑每个子系统本身也可以是一个门面也很重要:<code class="fe ms mt mu mv b">MovieClient</code>或<code class="fe ms mt mu mv b">AccountClient</code>实现可以有大量内部使用的子系统。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="53e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！我希望这个Facade模式的真实用例对您和您未来的项目有用。</p></div></div>    
</body>
</html>