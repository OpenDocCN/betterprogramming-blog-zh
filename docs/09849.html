<html>
<head>
<title>Decoupling Concrete Coordinators From Your Navigation System in iOS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在iOS中将具体的协调器从导航系统中分离出来</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/decoupling-concrete-coordinators-from-your-navigation-system-in-ios-27f39f8e8d8?source=collection_archive---------3-----------------------#2021-10-21">https://betterprogramming.pub/decoupling-concrete-coordinators-from-your-navigation-system-in-ios-27f39f8e8d8?source=collection_archive---------3-----------------------#2021-10-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6090" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用通用工厂从协调器实例化中分离导航</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ae7e29d76a50fa3000615404df1e6e17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wcya-0PIswsB2X4x"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@goran_ivos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Goran Ivos </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="f282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MVVM是实现应用最常见的架构之一。这个架构的目标是通过将表示逻辑转移到另一个组件<code class="fe lv lw lx ly b">ViewModel</code>来减轻<code class="fe lv lw lx ly b">ViewController</code>的责任。</p><p id="f003" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MVVM没有直接解释如何解决从一个<code class="fe lv lw lx ly b">ViewController</code>到另一个【】的导航问题。这个问题如此重要，以至于MVVM的一个变种被开发出来:MVVM-C</p><p id="ab45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">MVVM-C架构通过引入一组新的组件<code class="fe lv lw lx ly b">Coordinators</code>解决了这个问题。他们唯一的责任是正确处理导航。</p><p id="78cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，每当一个<code class="fe lv lw lx ly b">ViewController</code>完成它的任务，它就调用<code class="fe lv lw lx ly b">ViewModel</code>的一个方法，要求<code class="fe lv lw lx ly b">Coordinator</code>转到下一个屏幕。</p><p id="871d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种架构是可行的，所有的职责都是明确定义的。部件划分整齐隐蔽:<code class="fe lv lw lx ly b">ViewControllers</code>不知道其他<code class="fe lv lw lx ly b">ViewControllers</code>的存在<code class="fe lv lw lx ly b">ViewModels</code>不知道其他<code class="fe lv lw lx ly b">ViewModels</code>的存在。</p><p id="d749" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Coordinators</code>是了解app <strong class="lb iu">中不同<code class="fe lv lw lx ly b">Coordinators</code> <strong class="lb iu"> </strong>的组件。</strong>他们像胶水一样工作，把所有东西粘在一起。</p><p id="8ebf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管有这些优点，还是有一些缺点值得考虑:</p><ol class=""><li id="2a33" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">如果使用一个协调器从特性A移动到特性B，它应该在哪个模块中？</li><li id="01dc" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">为什么生活在不同模块中的<code class="fe lv lw lx ly b">Coordinators</code>应该相互了解？</li></ol><p id="a316" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在今天的文章中，我想展示我们如何用一组合适的工厂对象来解决这些问题。</p><h1 id="c370" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">开始的情况</h1><p id="15eb" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">让我们在实现建议的解决方案之前，先看看代码在开始时是什么样子。</p><p id="b1f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将使用一个示例应用程序，这是一个餐馆预订应用程序。主屏幕是一个表单，用户可以在其中设置一些搜索标准。当搜索被发出时，我们给出一个带有加载器的模态视图控制器。当(模拟的)网络调用完成时，我们转到一个显示餐馆列表的屏幕。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/232bc572774e61c6061f6dee4754884c.png" data-original-src="https://miro.medium.com/v2/resize:fit:592/1*2NMncLdAQEo7LjikfDk1ug.gif"/></div></figure><p id="36d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会深入所有的屏幕细节，也不会在这里报告全部代码:我在本文的<em class="nl">结论</em>部分添加了存储库。</p><p id="37b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们把注意力集中在<code class="fe lv lw lx ly b">RootCoordinator</code>上，看看导航是如何编排的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b090" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个代码片段中，<code class="fe lv lw lx ly b">RootCoordinator</code>与其他协调器紧密耦合。它也直接呈现了<code class="fe lv lw lx ly b">RootViewController</code>。这违反了<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">依赖倒置</strong> </a>原则。</p><p id="27b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">依赖倒置原则声明代码不应该依赖于对象的实现细节，而应该只依赖于它的接口。在这种情况下，我们严格依赖于<code class="fe lv lw lx ly b">ViewController</code>和另一个<code class="fe lv lw lx ly b">Coordinators</code>的具体实例。</p><p id="9106" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要呈现一个不同的具体的协调器或视图控制器，我们需要更新<code class="fe lv lw lx ly b">RootCoordinator</code>代码来改变哪个组件被创建和呈现。</p><p id="6aeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们没有任何方法来控制哪个具体的<code class="fe lv lw lx ly b">ViewController</code>或<code class="fe lv lw lx ly b">Coordinator</code>被创建。这可能会使编写我们的单元测试变得困难。</p><p id="1ba7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果我们有一个组件，一旦出现，它会立即执行一些指令，它们就会被执行，即使我们在一个测试环境中，我们并不想实际执行它们。</p><p id="9f71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，<code class="fe lv lw lx ly b">RootCoordinator</code>知道<code class="fe lv lw lx ly b">LoadingCoordinator</code>和<code class="fe lv lw lx ly b">RestaurantsCoordinator</code>的存在，尽管它们驻留在其他模块中。我们不想泄露这些知识。</p><blockquote class="no np nq"><p id="bb8d" class="kz la nl lb b lc ld ju le lf lg jx lh nr lj lk ll ns ln lo lp nt lr ls lt lu im bi translated">注意:这些问题也可能出现在层级结构中。例如，<code class="fe lv lw lx ly b">RestaurantsCoordinator</code>可能知道一个<code class="fe lv lw lx ly b">RestaurantCoordinator</code>或<code class="fe lv lw lx ly b">BookingCoordinator</code>，即使它们是在其他模块中定义的。</p></blockquote><h1 id="b07c" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用工厂解耦协调器</h1><p id="08b7" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">为了解耦<code class="fe lv lw lx ly b">Coordinators</code>，我们需要将需要创建哪个组件的决定推到应用程序的组合级别。</p><p id="207f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这可以通过向<code class="fe lv lw lx ly b">Coordinators</code>注入工厂来实现。我们架构的最佳方法是在<code class="fe lv lw lx ly b">Dependencies</code>值中注入一个<code class="fe lv lw lx ly b">CoordinatorFactory</code>。</p><p id="3c6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是为所有的<code class="fe lv lw lx ly b">Coordinators</code>定义一个公共协议，让我们让所有的<code class="fe lv lw lx ly b">Coordinators</code>都遵守它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5a2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们需要创造能够创造我们的<code class="fe lv lw lx ly b">Coordinators</code>的工厂。我们需要为每个协调员创建不同的工厂。所有的工厂必须有一个公共接口，所以我们需要引入一个新的协议:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d34d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从这个片段中，您可以看到我引入了一个关联类型<code class="fe lv lw lx ly b">R</code>，它必须符合一个名为<code class="fe lv lw lx ly b">Requirements</code>的协议。该协议是一些配置对象的标记。这个对象允许我们统一所有<code class="fe lv lw lx ly b">Coordinators</code>的接口。</p><p id="328b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具体来说，这些是<code class="fe lv lw lx ly b">Requirements</code>的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="ae47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些值只包含数据，没有附加逻辑。而且，这些是我们模块的公共接口的一部分，它们是公共的。在<code class="fe lv lw lx ly b">Requirement</code>中使用的所有类型都是公共的，并且<code class="fe lv lw lx ly b">Requirement</code>不公开任何特定于模块的类型。</p><p id="9e24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个模块只暴露另一个<code class="fe lv lw lx ly b">public</code>组件:T10。其他的一切(视图控制器、视图模型、协调器等等)都是私有的，可以留在相应的模块中，而不需要泄漏它。</p><h1 id="d101" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">使用工厂</h1><p id="1d9e" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">既然我们已经有了所有的碎片，我们可以试着把它们拼在一起。第一个想法可能是传递依赖关系中所有不同的工厂。</p><p id="81e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码看起来会像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5681" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们看到<code class="fe lv lw lx ly b">Dependencies</code>值包含了我们在上一步中创建的所有工厂。我们在<code class="fe lv lw lx ly b">AppDelegate</code>中使用这些工厂来创建<code class="fe lv lw lx ly b">RootCoordinator</code>，在<code class="fe lv lw lx ly b">RootCoordinator</code>中呈现装载和餐馆屏幕。</p><p id="e3f0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法是可行的，但是它违反了<a class="ae ky" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">开/关原则</strong> </a> <strong class="lb iu"> : </strong>一个软件应该对扩展开放，但对修改关闭。在这种情况下，如果我们想引入一个新的<code class="fe lv lw lx ly b">Coordinator</code>，我们将需要修改依赖对象，但没有必要这样做。</p><p id="ff7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以通过添加一个<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>图层来解决这个问题。这是一个单一的值，给定一些需求，可以为我们创建一个合适的工厂。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0418" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个额外的层只是接受一个绑定到工厂的需求。这是允许的:<code class="fe lv lw lx ly b">Requirement</code>和<code class="fe lv lw lx ly b">Factory</code>位于同一个模块中，它们是模块本身的公共接口。</p><p id="f43f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们用<code class="fe lv lw lx ly b">Provider</code>创建的工厂符合<code class="fe lv lw lx ly b">CoordinatorFactory</code>协议，因此它将能够根据需求创建正确的<code class="fe lv lw lx ly b">Coordinator</code>。</p><p id="9ebd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这一更改，我们可以按如下方式更新我们的依赖项和调用站点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="51a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的依赖性已经缩小，我们不必在我们的<code class="fe lv lw lx ly b">Coordinator</code>中添加对不同工厂的访问。一切都是由我们传递给<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>的需求驱动的。</p><p id="df54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要为一个新的<code class="fe lv lw lx ly b">Coordinator</code>添加一个新工厂，没有必要做任何改变:我们可以在需要的地方创建需求对象，并使用<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>为它检索一个合适的工厂。</p><h1 id="41e7" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">改进模块化</h1><p id="e051" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">目前的解决方案仍然不是最佳的。<code class="fe lv lw lx ly b">RootCoordinator</code>正在使用来自<code class="fe lv lw lx ly b">Loading</code>和<code class="fe lv lw lx ly b">Restaurants</code>模块的一些公共类型。这意味着<code class="fe lv lw lx ly b">Root</code>模块与这些其他模块紧密耦合。</p><p id="0712" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果明天我们想用不同的模块替换<code class="fe lv lw lx ly b">Loading</code>模块，如果要求或工厂发生变化，我们也必须更新<code class="fe lv lw lx ly b">RootCoordinator</code>。</p><p id="d608" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个解决方案可以是移动<code class="fe lv lw lx ly b">Composition</code>模块中的<code class="fe lv lw lx ly b">Factories</code>和<code class="fe lv lw lx ly b">Requirements</code>，其中定义了所有协议和<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>。通过这样做，假设<code class="fe lv lw lx ly b">RootCoordinator</code>已经依赖于那个模块，我们就不会受到其他模块变化的影响。如果一个新实现的模块使用相同的<code class="fe lv lw lx ly b">Requirements</code>，我们只需要更新<code class="fe lv lw lx ly b">Composition</code>模块。</p><p id="1a25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我们可以通过向<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>添加一些预定义的方法来进一步推动解耦。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="01fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们正在添加一些方法来创建我们在<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>中需要的特定协调器。如果我们看看调用站点，情况有了很大的改善，更加清晰，现在<code class="fe lv lw lx ly b">Root</code>模块不再依赖于其他模块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="99f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这最后一步可能看起来像是倒退。我们牺牲了一些更抽象的行为，换来了一个不那么通用的行为。然而，如果我们考虑这一点，这并不是倒退。</p><ol class=""><li id="f68e" class="lz ma it lb b lc ld lf lg li mb lm mc lq md lu me mf mg mh bi translated">我们的<code class="fe lv lw lx ly b">RootCoordinator</code>和<code class="fe lv lw lx ly b">AppDelegate</code>对其他<code class="fe lv lw lx ly b">Coordinators</code>的具体类型一无所知。</li><li id="0989" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">通过只作用于<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>，我们可以改变返回的协调器的具体类型。</li><li id="6583" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">仍然不违反<strong class="lb iu">开/关原则。</strong>如果我们想要添加新的协调者，我们不会被强制添加其他特定的方法。</li><li id="47e6" class="lz ma it lb b lc mi lf mj li mk lm ml lq mm lu me mf mg mh bi translated">这种方法推动了重用:假设餐馆模块必须呈现<code class="fe lv lw lx ly b">Loading</code>屏幕。<code class="fe lv lw lx ly b">Restaurants</code>模块从<code class="fe lv lw lx ly b">CoordinatorFactoryProvider</code>那里得到了它所需要的一切，它不必担心模块所需要的具体类型。</li></ol><h1 id="a403" class="mn mo it bd mp mq mr ms mt mu mv mw mx jz my ka mz kc na kd nb kf nc kg nd ne bi translated">结论</h1><p id="ddea" class="pw-post-body-paragraph kz la it lb b lc nf ju le lf ng jx lh li nh lk ll lm ni lo lp lq nj ls lt lu im bi translated">在今天的文章中，我们探讨了如何通过利用一些工厂对象和<a class="ae ky" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>原则来分离我们的应用程序的协调器结构。</p><p id="c613" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们走了很长一段路才获得一个非常简单的结果，导致特定架构决策的过程比展示最终结果重要得多。</p><p id="0a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们需要做出一个权衡取舍的决定:是使用更多耦合模块的通用代码更好，还是使用更明确、更清晰的代码库来推动非耦合模块更好，即使添加新组件可能需要修改组合根？</p><p id="280d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种方法(和这种解决方案！)可以应用于其他环境:<code class="fe lv lw lx ly b">ViewControllers</code>和<code class="fe lv lw lx ly b">ViewModels</code>经常会出现类似的问题，尤其是当我们决定不使用协调器的时候。</p><p id="8cf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">完整的项目可以在这个<a class="ae ky" href="https://github.com/cipolleschi/restaurants" rel="noopener ugc nofollow" target="_blank">库</a>中找到。<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/cipolleschi/Restaurants/tree/main/Restaurant" rel="noopener ugc nofollow" target="_blank">main</a></code>分支包含重构前的代码。<a class="ae ky" href="https://github.com/cipolleschi/Restaurants/tree/feat/coordinator-refactoring/Restaurant" rel="noopener ugc nofollow" target="_blank">feat/coordinator-refactoring</a>包含了重构后的代码。为了检查差异，我打开了一个从<code class="fe lv lw lx ly b">feat/coordinator-refactoring</code>分支到<code class="fe lv lw lx ly b">main</code>分支的<a class="ae ky" href="https://github.com/cipolleschi/Restaurants/pull/1" rel="noopener ugc nofollow" target="_blank"> PR </a>，这样就可以更详细地探索变化。</p></div></div>    
</body>
</html>