<html>
<head>
<title>SwiftUI and Core Data: The MVVM Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI和核心数据:MVVM之路</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/swiftui-and-coredata-the-mvvm-way-ab9847cbff0f?source=collection_archive---------0-----------------------#2021-02-03">https://betterprogramming.pub/swiftui-and-coredata-the-mvvm-way-ab9847cbff0f?source=collection_archive---------0-----------------------#2021-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f089" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在SwiftUI中处理核心数据实体的简洁直观的方式</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8554874f1de4abba25deb5a7fc4d9d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHvUN7ChPohtbbPGlIrn2A.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@bantersnaps?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戏谑的抓拍</a>在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure><p id="a39d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我第一次开始为一些小项目使用SwiftUI时，我立即欣赏到了它的易用性和表现力。然而，事情并非一帆风顺。</p><p id="93a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我开始开发一些更大的应用程序时——尤其是需要核心数据的应用程序——我清楚地意识到，我必须给项目本身一个不同的结构。否则，我很快就会陷入一个非常严重的可维护性和测试问题。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e55d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">坏的，简单的方法</h1><p id="76ec" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">通过阅读苹果的文档和许多其他关于堆栈溢出的答案，你会发现很多人将<code class="fe mz na nb nc b">FetchRequest</code>属性包装变量放在需要从核心数据模型获取一些数据的<code class="fe mz na nb nc b">View</code>结构中。</p><p id="70b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你刚刚开始，这可能很有诱惑力，但是当你稍微深入研究提取的实体所涉及的逻辑时，你将很快意识到不仅很难——如果不是不可能的话——测试那些函数/变量，而且你也不再遵循MVVM模式。在这一点上，<code class="fe mz na nb nc b">View</code>结构知道很多关于实体和你在它们内部定义的函数/属性的信息。让我给你看一个很容易在其他实体中复制的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/de7ce11a8636405e76c9cec90966c65c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6ynNiRw1TxaQWvCEypFLw.png"/></div></div></figure><p id="e524" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我将获取存储在核心数据中的所有<code class="fe mz na nb nc b">Course</code>实体，并引入一些逻辑，我将在稍后的视图中展示这些逻辑。我们如何检验这个计算变量呢？您可以创建一个可以稍后测试的特殊函数，但这不是一个干净的方法。另外，您不希望在任何视图中出现数据逻辑。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d03f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">干净的替代品</h1><p id="edc6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我倾向于每个<code class="fe mz na nb nc b">View</code>有一个单独的<code class="fe mz na nb nc b">ViewModel</code>,这样我可以单独测试每个组件，并在每个组件中使用我需要的东西，而不是让一个巨大的<code class="fe mz na nb nc b">ViewModel</code>在视图中传递。</p><p id="8eac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用SwiftUI 2.0，您会发现初始项目将一个<code class="fe mz na nb nc b">managedObjectContext</code>作为一个<code class="fe mz na nb nc b">environmentObject</code>属性传递。我们不希望这样。每次在需要从数据库获取数据的每个<code class="fe mz na nb nc b">View</code>中获取上下文是不干净的，我也不希望我的视图知道这些。</p><p id="d165" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想到的是一种更MVVM的方式，让我们易于使用的出版商和订户参与进来。</p><p id="087d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基本上，您将创建一个singleton实例，该实例监视数据库中的一个实体(在本例中为<code class="fe mz na nb nc b">Course</code>实体),并将所有课程发送给订阅它的每个订户。这样，您可以轻松地实例化订阅存储发布者的多个<code class="fe mz na nb nc b">ViewModels</code>,并在更专用和可测试的空间中对这些实体操作一些逻辑。让我们来看一个<code class="fe mz na nb nc b">CourseStorage</code>的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/9a02a2c7d73ae7224a17394ec6d004f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i57R81lz4e6LmsnA4XC3Hg.png"/></div></div></figure><p id="81f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在代码中看到的，我正在创建一个singleton <code class="fe mz na nb nc b">ObservableObject</code>，它公开了一个课程发布者。当<code class="fe mz na nb nc b">managedObjectContext</code>实体改变时，它将发出一个新的值。您可能也注意到了，我将<code class="fe mz na nb nc b">PersistenceController</code>放在了类本身中。这样，我们就可以忘记将它传递给视图，就像我之前解释的那样。在这个类中，我还处理与核心数据操作相关的一切，比如保存、添加和删除存储中的实体。因此，我将数据库逻辑与应用程序的业务逻辑分开。</p><p id="a339" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是一个例子，说明如何利用这些变化来构建<code class="fe mz na nb nc b">ViewModel</code>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/2dc2a95564a13f1debc34289b1addfae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrhzxdvA0EtFcgy_0j8lCA.png"/></div></div></figure><p id="91ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">ViewModel</code>现在封装了它应该处理的所有数据和逻辑。代码基本上是不言自明的:<code class="fe mz na nb nc b">CourseViewModel</code>订阅了<code class="fe mz na nb nc b">CourseStorage</code>发布者，并从它那里接收最新的课程值。</p><p id="4797" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道为什么我用一个<code class="fe mz na nb nc b">AnyPublisher</code>值初始化<code class="fe mz na nb nc b">ViewModel</code>。还记得测试优势吗？正是针对这种情况。如果我现在想测试<code class="fe mz na nb nc b">CourseViewModel</code>及其逻辑，我可以创建一个包含一系列课程的样本测试数组，将其作为数组发布者传递给<code class="fe mz na nb nc b">ViewModel</code>，并做出测试所需的所有断言。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/d9ffe464cd8285c747ba500e95a6c650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MPA8266RH3O1aS3sHWz_yQ.png"/></div></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f9d5" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">决赛成绩</h1><p id="35f5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">现在，我将向您展示经过这些更改后的<code class="fe mz na nb nc b">View</code>结构看起来是多么简单和整洁:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/059d42aee83e82c1f5863cf277ed30ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*psU-vMuux5iZX-QmaDRVgg.png"/></div></div></figure><p id="6eab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不再有<code class="fe mz na nb nc b">managedObjectContext</code>传来传去的观点。有逻辑分离。它符合MVVM标准，易于测试，并且干净。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f8db" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="feac" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我不得不说我对结果相当满意。我的组件现在都是以这种方式构建的，我没有发现实现中的任何问题。这就是为什么我鼓励你尝试这样做，这样你就能以一种结构良好、可维护、更优雅的方式组织大项目(和小项目)。</p></div></div>    
</body>
</html>