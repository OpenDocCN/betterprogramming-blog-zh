<html>
<head>
<title>Choosing Between an Interface and an Abstract Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在接口和抽象类之间选择</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/choosing-between-interface-and-abstract-class-7a078551b914?source=collection_archive---------0-----------------------#2019-12-04">https://betterprogramming.pub/choosing-between-interface-and-abstract-class-7a078551b914?source=collection_archive---------0-----------------------#2019-12-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="00a4" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">他们完成相同的结果；这取决于你想做什么</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/38e7149794c990d1899160d3c747e125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zDoTAjvFlQkiZZb0"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@wocintechchat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂娜@ wocintechchat.com</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="8fbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在一些采访中，我被要求解释接口和抽象类之间的区别，以及什么时候我会选择一个而不是另一个。</p><p id="2edb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为这种情况发生得太多了，所以我将定义每一个并解释两者之间的区别，并给出一个何时选择一个而不是另一个的例子。</p><p id="a2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我将使用Java编写示例代码，但是这个概念在其他语言中也应该是类似的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7177" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是接口？</h1><p id="2dc2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接口是多个系统之间的行为契约。</p><p id="6443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着任何实现一个接口的类保证并且<em class="mz">必须</em>为它的所有方法提供一些实现。接口中的所有方法都必须是公共的和抽象的。</p><p id="1409" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口定义如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="964b" class="nf md it nb b gy ng nh l ni nj">public interface Movable {<br/>    public void accelerate();<br/>    public void decelerate();<br/>}</span><span id="b3e3" class="nf md it nb b gy nk nh l ni nj">public interface Drivable{<br/>    public void drive();<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e82b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是抽象类？</h1><p id="b969" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">抽象类在其声明中以abstract关键字为前缀，是为其派生的具体类创建的准则。抽象类必须至少有一个抽象方法，并为其非抽象方法提供实现。</p><p id="e718" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用实现来定义一个抽象类，那么你可能需要考虑使用接口是否是一个更好的选择。</p><p id="4873" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">抽象类定义如下所示:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="ae55" class="nf md it nb b gy ng nh l ni nj">public abstract class Vehicle {<br/>    <br/>    public void getReady(){<br/>        System.<em class="mz">out</em>.println("I'm all set and ready to go");<br/>    }<br/>    public abstract void start();<br/>    public abstract void stop(); <br/>}</span></pre><p id="7f8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将所有这些放在一起，让我们创建一个<code class="fe nl nm nn nb b">Bus</code>类，它扩展了<code class="fe nl nm nn nb b">Vehicle</code>抽象类并实现了<code class="fe nl nm nn nb b">Drivable</code>和<code class="fe nl nm nn nb b">Movable</code>接口。</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="b3d7" class="nf md it nb b gy ng nh l ni nj">public class Bus extends Vehicle implements Drivable, Movable {</span><span id="ee10" class="nf md it nb b gy nk nh l ni nj">    @Override<br/>    public void Drive() {<br/>        System.<em class="mz">out</em>.println("Driving...");<br/>    }</span><span id="a9d1" class="nf md it nb b gy nk nh l ni nj">    @Override<br/>    public void accelerate() {<br/>        System.<em class="mz">out</em>.println("accelerating...");<br/>    }</span><span id="72fe" class="nf md it nb b gy nk nh l ni nj">    @Override<br/>    public void decelerate() {<br/>        System.<em class="mz">out</em>.println("decelerating...");<br/>    }</span><span id="145c" class="nf md it nb b gy nk nh l ni nj">    @Override<br/>    public void start() {<br/>        System.<em class="mz">out</em>.println("Starting engine...");<br/>    }</span><span id="c988" class="nf md it nb b gy nk nh l ni nj">    @Override<br/>    public void stop() {<br/>        System.<em class="mz">out</em>.println("Shutting down engine...");<br/>    }<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="5471" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">差异和相似之处</h1><p id="79c0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">接口中的所有方法都是公共的，并且是隐式抽象的。抽象类可以对它们的方法使用公共的、部分的、受保护的和静态的访问修饰符。</p><p id="c9e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">类可以实现多个接口，但只能实现一个抽象类。抽象类可以包含非抽象方法。</p><p id="10c7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们都可以有方法和变量，但都不能被实例化。接口中声明的所有变量都是final，而抽象类可能包含非final变量。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3b9e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">选择哪一个</h1><p id="3404" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">如果你需要提供一些实现或者需要一个基类，那么抽象类是一个不错的选择。</p><p id="829a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，也许你想确保在一个类中初始化一些变量，以便在一个所有派生类都可以使用的helper方法中执行逻辑，选择一个抽象类是正确的选择。</p><p id="5bfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你需要为你的类提供额外的行为，那么接口是一个不错的选择。</p><p id="7fcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">两者可以实现相同的功能，然而，当考虑编码标准时，接口可以帮助你实现抽象和多态，这是四个主要OOP原则中的两个。</p><p id="0bf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它还使您的代码更容易保持松散耦合，而不是紧密耦合，当高级模块依赖于低级模块时会发生这种情况。</p><p id="973d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接口也用于依赖注入(也称为DI/IoC ),并且在测试时更容易模仿派生类。</p><p id="bbb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读。编码快乐！</p></div></div>    
</body>
</html>