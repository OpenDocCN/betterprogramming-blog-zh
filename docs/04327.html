<html>
<head>
<title>How to Automate Design Tokens in a Design System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在设计系统中自动化设计令牌</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-automate-design-tokens-in-a-design-system-189d3e6fd103?source=collection_archive---------11-----------------------#2020-04-06">https://betterprogramming.pub/how-to-automate-design-tokens-in-a-design-system-189d3e6fd103?source=collection_archive---------11-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="091c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">颜色、间距、字体粗细和字体大小都是设计的标志</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3a103e12a6d7cf3211ac2e143b7a10ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FyZiphENgmQe4D0m"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">诺德伍德主题公司在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片。</p></figure><p id="e131" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在设计系统中，传统上设计和代码是有区别的。我们有设计组件外观的设计师和实现这些组件的开发人员。然而，需要一些努力来保持两者同步。</p><p id="0518" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以当我开始一个新的设计系统时，我想知道是否有可能消除一些这种摩擦。这个想法变成了创建一个自动化的过程，这个过程将保持设计工具的设计符号与其背后的代码同步。</p><p id="6c6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">设计记号是保持我们设计系统一致性的东西:颜色、间距、字体粗细和字体大小都是记号的例子。在理想世界中，它们遵循一个序列(4px，8px，等等。)并且总是从这个序列中选择。</p><p id="3401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种自动化流程的好处是什么？好吧，让我们说，我们没有任何自动化到位，一个设计师改变了蓝色。他们必须与开发人员沟通，才能在代码中做出相同的更改。您能看出这会如何导致不同步的问题吗？相比之下，在自动化过程的工作流程中，设计者做出了一个改变，它会自动反映在代码中。</p><p id="dcf8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将带您了解如何建立一个自动化的过程来保持设计和代码之间的设计标记同步。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cb47" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">概观</h1><p id="bb4a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我知道到目前为止这有点抽象。因此，下面是一个概述，让您直观地了解我们正在努力实现的目标:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/41821b2179272ffca2136b5d9098408b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pxdLkDI5UMEoVoVF-sNECg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">自动化流程概述。</p></figure><p id="bc0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，我们选择的设计工具是Figma。它们提供了一个很好的API来进行交互，这使得访问设计令牌变得更加容易。</p><p id="c12b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将创建一个Node.js服务器，它将与Figma连接以检索标记(文本权重、间距、颜色等)。).之后，节点实例将生成主题文件供开发人员使用。</p><p id="9fcd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将生成一个包含所有变量的Sass和<a class="ae ky" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> Tailwind </a>文件，但是创建另一个主题文件(可能是一个样式化组件主题)也很容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4c03" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">设置Figma设计标志</h1><p id="19bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了让Node.js服务器知道如何获取设计令牌，我们需要以某种方式在Figma中构造它们。这就是为什么现在创建一个抽象实现很复杂的原因。一切都需要以同样的方式设置。然而，当它被设置时，该过程将顺利运行。</p><p id="ec2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最好在Figma中为每个设计标记创建一个文件。因此，一个文件的间距，颜色，字体大小等。</p><p id="00b7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这些文件中，我们可以创建一个名为令牌的页面。我们可以用所有的值来填充这一页。对于间距，我们可以为每个值创建组件:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/81b400013dc690b0d57110dbfe003123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9HTpoDChkN8YrD57KJSc0A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Figma中声明间距。</p></figure><p id="c26a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Figma中，我们遵循相同的过程来定义颜色:在一个名为Tokens的页面中创建一个新文件，其中包含颜色。命名很重要，因为这些名称将由Node.js服务器获取，并可供开发人员使用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/27fcb3fa6d9fdff200cda60e8d1675da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J1W8OAuN5A2wsct9w7mDlA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Figma中声明颜色。</p></figure><p id="4776" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是设计令牌的简化声明。我们可能想提供一些额外的结构。然而，演示这个过程如何工作就足够了。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="fcf9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">创建Node.js服务器</h1><p id="903f" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了访问Figma API，我们需要首先生成一个个人访问令牌，Node.js将使用这个令牌进行身份验证。</p><p id="c01b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Figma中创建一个是相当容易的。您可以在“个人资料”&gt;“设置”&gt;“个人访问令牌”中找到它。单击“创建新的个人访问令牌”并复制粘贴值。将它保存在安全的地方很重要，因为我们在下一步会用到它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/399e004b4afed0ca85631a56555acc5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BaWwyHdELCmIKSISrVH95g.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Figma中生成个人访问令牌。</p></figure><p id="265e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以从创建Node.js服务器开始，它将从Figma获取设计令牌。为了让文章不跑题，我就不详细介绍如何设置Node了。参见<a class="ae ky" href="https://nodejs.org/en/docs/guides/getting-started-guide/" rel="noopener ugc nofollow" target="_blank">官方文件</a>获取说明。</p><p id="028f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的Node.js服务器需要几个依赖项:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4429" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们可以将Figma个人访问令牌保存在一个. env文件中。这样，我们可以在JavaScript代码中使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="dc49" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们首先用以下内容创建Node.js入口点<code class="fe nf ng nh ni b">application.js</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以连接Figma并获取间距和颜色标记。第一步是创建一个通过我们的PAT连接到Figma的函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="978c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该函数可用于从Figma中获取所有间距值。在使用下面的代码片段之前，我们需要定义<code class="fe nf ng nh ni b">spacingFileId</code>。这可以通过获取Figma URL来查找。这些总是以相同的方式构成:<a class="ae ky" href="https://www.figma.com/file/0vZ6G51n9R7uEsj8H873WE/" rel="noopener ugc nofollow" target="_blank">https://www.figma.com/file/xxxx/</a>。从您的URL中获取“xxxx”值，并将其放入<code class="fe nf ng nh ni b">spacingFileId</code>变量中:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6933" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">获取颜色非常相似。唯一的区别是颜色值需要转换成RGB值，然后我们将转换成十六进制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="bb07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是获取设计令牌所需的全部代码。现在我们将继续基于这些令牌生成主题文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="0d6e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">生成主题文件</h1><p id="2af6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">既然我们已经学习了如何从Figma获取设计令牌，我们可以继续生成主题文件。开发人员将使用这些主题文件来创建一致的用户界面。</p><h2 id="9748" class="nj md it bd me nk nl dn mi nm nn dp mm li no np mo lm nq nr mq lq ns nt ms nu bi translated">Sass文件</h2><p id="5dd2" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">让我们首先基于设计令牌生成Sass变量。我们可以从创建<code class="fe nf ng nh ni b">convertToSassFile</code>函数开始:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="863a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里到底发生了什么？</p><ul class=""><li id="c068" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated"><code class="fe nf ng nh ni b">reduce</code>函数将把每个设计令牌值转换成一个Sass变量，并组合输出。</li><li id="63cf" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">我们将给每个变量一个设计系统前缀。我选择了<code class="fe nf ng nh ni b">$tb</code>。</li><li id="e253" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">内容将被写入输出文件(<code class="fe nf ng nh ni b">theme.scss</code>)。</li></ul><p id="8e71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将产生以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><h2 id="ba85" class="nj md it bd me nk nl dn mi nm nn dp mm li no np mo lm nq nr mq lq ns nt ms nu bi translated">顺风文件</h2><p id="9482" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">生成顺风文件遵循相同的结构。唯一的区别是配置文件是如何构建的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a990" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这会产生以下输出:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="110c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些主题文件的下一步会是什么？你可以通过NPM发布它们，分发给每一个使用这个设计系统的项目。</p><p id="9538" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将来，通过创建一个新的<code class="fe nf ng nh ni b">convertTo</code>函数来支持一个新的样式机制也很容易。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="697f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="584a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">看看是否可以为设计令牌建立一个自动化的过程是非常有趣的。我认为它有很大的潜力来消除设计者和开发者之间的不同步问题。</p><p id="78eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">仍然有一些可以改进的地方，比如弄清楚是否可以在每次Figma文件发生变化时调用webhook来重新生成主题文件，或者甚至可以有一个更大胆的想法，比如自动将组件变化转换为代码。</p></div></div>    
</body>
</html>