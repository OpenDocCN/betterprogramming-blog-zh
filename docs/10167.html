<html>
<head>
<title>One Way to Manage Credentials in Multiple Software Environments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在多个软件环境中管理凭证的一种方法</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/one-way-to-manage-credentials-in-multiple-software-environments-b2d725a73777?source=collection_archive---------9-----------------------#2021-12-07">https://betterprogramming.pub/one-way-to-manage-credentials-in-multiple-software-environments-b2d725a73777?source=collection_archive---------9-----------------------#2021-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9753" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保护您的API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f88b94c2ffb92cdbb3b16e376b322055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oAUX0_U_Xt5N9pc2.jpg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">参考:<a class="ae kv" href="https://commons.wikimedia.org/wiki/File:Steal_password.jpg" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/wiki/File:Steal_password.jpg</a></p></figure><p id="8acc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在维护凭证和访问凭证的奇妙世界中，没有人能够在单一方法上达成一致。</p><p id="f151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在一个完美的世界里，没有人会窃取密码并试图窃取信息，但不完美正是软件有趣的地方。</p><p id="f8b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总的来说，我将详细说明当无法从本地设置访问凭证存储时，我用来管理凭证的一种方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="0eac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我解释一下这个方法有意义的场景。我正在开发的一个API可以访问一个数据库，并且需要一个密码来认证为一个特定的用户。作为该过程的一部分，我必须将密码的加密版本交给IT部门，他们将它存储到一个解决方案中。</p><p id="a177" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，这个解决方案不能通过任何员工的笔记本电脑访问，只能在部署了容器的集群上访问。因此，自然的问题是:我如何用一个实时数据库在本地测试这一点？</p><p id="098d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，每个人都可以想出几种方法来访问凭证，但我们希望有一种可重复的方法来做到这一点，而不必记住4-5个不同的命令来设置它。通常，容器/服务的环境变量是一个好主意，但是，我们如何以一种简单的方式多次设置它呢？可以添加bash别名，但是如果其他人有该项目的票怎么办？给他们相同的bash别名？我们可以做得更好。</p><p id="5cea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我对本地环境的要求:</p><ul class=""><li id="2fd0" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">能够在机器环境中运行(<code class="fe mi mj mk ml b">venv</code>、<code class="fe mi mj mk ml b">nodenv</code>等)。)</li><li id="81d7" class="lz ma iq ky b kz mm lc mn lf mo lj mp ln mq lr me mf mg mh bi translated">能够在我的机器上的docker容器中运行</li></ul><p id="1b8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是项目所需的一些文件:</p><ul class=""><li id="330f" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">配置文件(本例中为YAML)</li><li id="4546" class="lz ma iq ky b kz mm lc mn lf mo lj mp ln mq lr me mf mg mh bi translated">配置模块(在这个例子中是Python)</li><li id="46ab" class="lz ma iq ky b kz mm lc mn lf mo lj mp ln mq lr me mf mg mh bi translated">生成文件</li><li id="f735" class="lz ma iq ky b kz mm lc mn lf mo lj mp ln mq lr me mf mg mh bi translated">Dockerfile文件</li><li id="8126" class="lz ma iq ky b kz mm lc mn lf mo lj mp ln mq lr me mf mg mh bi translated">头脑清楚</li></ul><p id="fab3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有的是一个配置模块，它打开一个带有YAML扩展名的配置文件，扩展名如下:</p><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="50c2" class="mv mw iq ml b gy mx my l mz na">db:<br/>  host: the-host<br/>  port: 5432<br/>  database: my-database</span></pre><p id="7ee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个项目还存在其他一些配置，但是，这是一个简单的设置，目前没有凭证。在下面的代码片段中，config模块以类似的方式打开:</p><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="656d" class="mv mw iq ml b gy mx my l mz na"># requires install of pyyaml<br/>import yaml</span><span id="6d3d" class="mv mw iq ml b gy nb my l mz na">def read():<br/>    with open("config.yaml", "r") as stream:<br/>        try:<br/>            return yaml.safe_load(stream)<br/>        except yaml.YAMLError as exc:<br/>            print(exc)</span></pre><p id="1e53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我做的第一件事是复制并修改同一个目录下的配置文件，并将其命名为<code class="fe mi mj mk ml b">config-local.yaml</code></p><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="252a" class="mv mw iq ml b gy mx my l mz na">db:<br/>  host: the-host<br/>  port: 5432<br/>  database: my-database<br/>  password: ultra-secret-password</span></pre><p id="316f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，执行以下步骤<strong class="ky ir"> : </strong></p><ul class=""><li id="a32a" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">将上述文件添加到<code class="fe mi mj mk ml b">.gitignore</code></li></ul><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="7152" class="mv mw iq ml b gy mx my l mz na">&lt;PATH&gt;/&lt;TO&gt;/config-local.yaml</span></pre><ul class=""><li id="0ef6" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">然后用<code class="fe mi mj mk ml b">git status</code>仔细检查，确保文件没有被意外地提交到存储库中。</li><li id="0de7" class="lz ma iq ky b kz mm lc mn lf mo lj mp ln mq lr me mf mg mh bi translated">接下来，创建一个<code class="fe mi mj mk ml b">Dockerfile.dockerignore</code>文件，用于忽略将该文件添加到主docker构建中。这应该等同于将它添加到<code class="fe mi mj mk ml b">.gitignore</code>中，并构建/检查容器文件以确保它没有被添加。</li><li id="2135" class="lz ma iq ky b kz mm lc mn lf mo lj mp ln mq lr me mf mg mh bi translated">现在我将修改上面的模块来处理自定义文件名:</li></ul><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="783e" class="mv mw iq ml b gy mx my l mz na"># requires install of pyyaml<br/>import yaml<br/>import os</span><span id="f57d" class="mv mw iq ml b gy nb my l mz na"># I only have to worry about local vs every environment so this is     # the only check I need</span><span id="22a4" class="mv mw iq ml b gy nb my l mz na">CONFIG_NAME = 'config.yaml' if not os.getenv('LOCAL_ENV') else \ 'config-local.yaml'.format(os.getenv('LOCAL_ENV'))</span><span id="4d58" class="mv mw iq ml b gy nb my l mz na">def read():<br/>    with open(<!-- -->CONFIG_NAME<!-- -->, "r") as stream:<br/>        try:<br/>            return yaml.safe_load(stream)<br/>        except yaml.YAMLError as exc:<br/>            print(exc)</span></pre><p id="58eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，现在每当我在Python的虚拟环境中运行时，我都可以执行以下操作(下面的示例是针对FastAPI设置的):</p><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="e63b" class="mv mw iq ml b gy mx my l mz na">PYTHONPATH=src/ LOCAL_ENV=true uvicorn main:app --reload</span></pre><p id="db1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我将它转换成了make目标(这是一个很好的技巧，所以您不必记住命令):</p><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="79c3" class="mv mw iq ml b gy mx my l mz na"># The source keyword doesn't work so a period is needed<br/># Source: <a class="ae kv" href="https://stackoverflow.com/a/27801227" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/27801227</a><br/>ACTIVATE_VENV =. path/to/venv/activate</span><span id="6531" class="mv mw iq ml b gy nb my l mz na">.PHONY: run-local<br/>run-local:<br/>    $(ACTIVATE_VENV); PYTHONPATH=src/ LOCAL_ENV=true uvicorn main:app --reload</span></pre><p id="ce77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注<strong class="ky ir"> : </strong>这是一个激活虚拟环境的技巧，这样当您将目录更改为存储库时，就不必每次都运行源命令。</p><p id="8b7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这太棒了！对意外提交明文密码的担忧消失了，密码的本地副本被添加到配置模块，可以快速访问该模块以进行本地测试(不要在zoom会议期间打开)。这并不理想，但确实在不中断代码进度的同时简化了对凭证的访问。</p><p id="a0cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">剩下的最后一件事是设置docker在本地运行。现在，由于基本docker文件忽略了新文件，让我们创建另一个文件。可以创建一个名为<code class="fe mi mj mk ml b">Dockerfile.local</code>的新文件，它不必跟在<code class="fe mi mj mk ml b">.dockerignore</code>后面(不幸的是，docker中没有忽略参数)。</p><p id="fa1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mi mj mk ml b">Dockerfile.local</code>和<code class="fe mi mj mk ml b">Dockerfile</code>的唯一区别是这条线:</p><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="c88e" class="mv mw iq ml b gy mx my l mz na">ENV LOCAL_ENV=true</span></pre><p id="f67a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们添加一个make目标:</p><pre class="kg kh ki kj gt mr ml ms mt aw mu bi"><span id="a6e7" class="mv mw iq ml b gy mx my l mz na">.PHONY: run-docker-local<br/>run-docker-local:<br/>   <!-- -->DOCKER_BUILDKIT=1 <!-- -->docker build -f Dockerfile.local -t &lt;IMAGE_NAME&gt;:local .<br/>   docker run &lt;IMAGE_NAME&gt;:local</span></pre><p id="8f29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:匹配dockerfiles的<code class="fe mi mj mk ml b">.dockerignore</code>命名需要将<code class="fe mi mj mk ml b">DOCKER_BUILDKIT</code>变量设置为1才能工作。</p><p id="595d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这张图片不能被推送到任何环境中(我建议使用本地标签来避免意外推送)。</p><p id="52b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，现在我们有两种方法来运行我们的服务，同时避免凭据被推送到在线存储库。我并不认为这是处理凭证的最佳方式，但这是我在本地测试并与流程保持一致的同时不断改进服务的一种方法。请随意批评这个过程或提出改进建议，因为我想看看其他人做了什么。</p><p id="ac42" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>