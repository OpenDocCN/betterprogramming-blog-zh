<html>
<head>
<title>Understanding the JavaScript Spread Operator — From Beginner to Expert</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript Spread操作符——从初学者到专家</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-the-javascript-spread-operator-from-beginner-to-expert-8f1c110c64db?source=collection_archive---------0-----------------------#2019-09-16">https://betterprogramming.pub/understanding-the-javascript-spread-operator-from-beginner-to-expert-8f1c110c64db?source=collection_archive---------0-----------------------#2019-09-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ec78ae476050661b3896a9cca3ccb25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ong1Dd5pjzVoIBj9BgaaA.png"/></div></div></figure><h1 id="9623" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="81dc" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">扩展运算符<code class="fe lx ly lz ma b">…</code>、<strong class="lb iu">、</strong>最早是在ES6中引入的。它很快成为最受欢迎的功能之一。以至于尽管它只在数组上工作，有人提议将其功能扩展到对象。这个特性最终在ES9中引入。</p><p id="647b" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">本教程分为两个部分，旨在向您展示为什么应该使用spread运算符，它是如何工作的，并从最基本到最高级深入探究它的用法。</p><p id="8991" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">以下是本教程内容的简短总结:</p><h2 id="0571" class="mg kc it bd kd mh mi dn kh mj mk dp kl lk ml mm kp lo mn mo kt ls mp mq kx mr bi translated">第一部分</h2><ol class=""><li id="d7ef" class="ms mt it lb b lc ld lg lh lk mu lo mv ls mw lw mx my mz na bi translated">为什么应该使用扩展运算符</li><li id="ea66" class="ms mt it lb b lc nb lg nc lk nd lo ne ls nf lw mx my mz na bi translated">克隆数组/对象</li><li id="5f03" class="ms mt it lb b lc nb lg nc lk nd lo ne ls nf lw mx my mz na bi translated">将类似数组的结构转换为数组</li><li id="4e8f" class="ms mt it lb b lc nb lg nc lk nd lo ne ls nf lw mx my mz na bi translated">作为参数的扩展运算符</li><li id="d269" class="ms mt it lb b lc nb lg nc lk nd lo ne ls nf lw mx my mz na bi translated">向数组/对象添加元素</li><li id="a97c" class="ms mt it lb b lc nb lg nc lk nd lo ne ls nf lw mx my mz na bi translated">合并数组/对象</li></ol><h2 id="970c" class="mg kc it bd kd mh mi dn kh mj mk dp kl lk ml mm kp lo mn mo kt ls mp mq kx mr bi translated">第二部分</h2><ol class=""><li id="70df" class="ms mt it lb b lc ld lg lh lk mu lo mv ls mw lw mx my mz na bi translated">扩展运算符的高级用途</li></ol></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="5c3f" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">为什么应该使用扩展运算符</h1><p id="8ad7" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">读完前面的列表后，您可能会有这样的想法:<em class="ns"> </em>“但是JavaScript具有完成所有这些事情的功能。我为什么要使用spread运算符？”请允许我向你介绍不变性。</p><blockquote class="nt nu nv"><p id="f22a" class="kz la ns lb b lc mb le lf lg mc li lj nw md lm ln nx me lq lr ny mf lu lv lw im bi translated">摘自<a class="ae nz" href="https://www.lexico.com/en" rel="noopener ugc nofollow" target="_blank">牛津词典</a>:不变性——不随时间变化或者不能改变。</p></blockquote><p id="955d" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">在软件开发中，我们使用术语“不可变”来指代其状态不能随时间改变的值。其实我们平时用的大部分值(原语值，比如字符串，整数等。)都是不可变的。</p><p id="b240" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">然而，当涉及数组和对象时，JavaScript有一种奇特的行为；事实上，它们是可变的。这可能会成为一个大问题。这里有一个例子，说明为什么:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8dea" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">正如您在前面的代码片段中看到的，我们有一个杰尼龟。我们的杰尼龟有100的HP，因为我们刚刚参观了神奇宝贝中心。</p><p id="aea6" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">因为我们想要另一个杰尼龟，我们声明了变量<code class="fe lx ly lz ma b">anotherSquirtle</code>，指定我们最初的杰尼龟作为它的值。经过一场艰苦的战斗，<code class="fe lx ly lz ma b">anotherSquirtle</code>被打败了。我们因此访问<code class="fe lx ly lz ma b">anotherSquirtle</code>的HP并将其更改为0。下一步是检查我们原来的杰尼龟。我们<code class="fe lx ly lz ma b">console.log</code>和…</p><p id="2431" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">等等，什么？我们原来的杰尼龟的HP降到了0。怎么会这样呢？我们可怜的杰尼龟怎么了？JavaScript发生了突变。让我解释一下这是怎么回事。</p><p id="07e1" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">当我们创建了<code class="fe lx ly lz ma b">anotherSquirtle</code>变量并将我们最初的杰尼龟赋值给它时，我们真正做的是将一个引用赋值给最初的杰尼龟对象的内存位置。这是因为JavaScript数组和对象是引用数据类型。与原始数据类型不同，它们指向存储实际对象/数组的内存地址。</p><p id="ecc8" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">为了更容易理解，您可以将引用数据类型想象成指向全局变量的指针。通过改变引用数据类型的值，我们真正做的是改变全局变量的值。</p><p id="951a" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">这意味着当我们将<code class="fe lx ly lz ma b">anotherSquirtle</code>的<em class="ns"> </em>的HP值更改为0时，我们实际上是将内存中存储的杰尼龟对象的HP值更改为0。这就是为什么<em class="ns"/><code class="fe lx ly lz ma b">mySquirtle</code><em class="ns"/>的HP值是0——因为<code class="fe lx ly lz ma b">mySquirtle</code>保存了一个对存储在内存中的对象的引用，我们通过<code class="fe lx ly lz ma b">anotherSquirtle</code>变量改变了它。谢谢JavaScript。</p><h2 id="57c1" class="mg kc it bd kd mh mi dn kh mj mk dp kl lk ml mm kp lo mn mo kt ls mp mq kx mr bi translated">我们如何解决这个问题？</h2><p id="2fe8" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了避免变量的意外突变，每当我们想要复制一个数组/对象时，我们必须做的就是创建一个数组/对象的新实例<strong class="lb iu"> </strong>。我们如何实现这一点？</p><p id="9fe9" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">使用spread运算符。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0dc8" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">Spread运算符是如何工作的？</h1><blockquote class="nt nu nv"><p id="de3f" class="kz la ns lb b lc mb le lf lg mc li lj nw md lm ln nx me lq lr ny mf lu lv lw im bi translated">MDN docs: Spread语法允许在需要0个或多个参数(对于函数调用)或元素(对于数组文本)的地方扩展iterable，例如数组表达式或字符串，或者在需要0个或多个键值对(对于对象文本)的地方扩展对象表达式。</p></blockquote><p id="1639" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">简而言之，spread操作符<code class="fe lx ly lz ma b">…</code>将包含在iterable中的项目展开(iterable<em class="ns">iterable</em>是任何可以循环的东西，比如字符串、数组、集合等等)。)在一个接收器里面。(接收器是接收传播值的东西。)下面是几个简单的数组示例，可以让您更好地理解它:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">数组上使用的扩展运算符的三个示例</p></figure><p id="d504" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">正如你所看到的，当我们在一个数组上使用spread操作符时，我们获得了数组中包含的每一项。在所有前面的例子中，接收器是一个函数，即<code class="fe lx ly lz ma b">console.log</code>函数。很简单，对吧？</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="858e" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">克隆数组和对象</h1><p id="990d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">现在我们知道了spread操作符是如何工作的，我们可以利用它来不变地复制数组和对象。怎么会？通过展开内容，然后使用数组或对象文字(分别为<code class="fe lx ly lz ma b">[]</code>和<code class="fe lx ly lz ma b">{}</code>)来生成数组/对象的新实例。</p><p id="bffb" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">让我们以前面的杰尼龟为例，通过不可变地克隆<code class="fe lx ly lz ma b">mySquirtle </code>变量来修复它:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">使用扩展操作符不变地复制对象</p></figure><p id="ad0a" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">通过用spread操作符析构<code class="fe lx ly lz ma b">mySquirtle</code>变量的内容并使用对象文字，我们创建了杰尼龟对象的一个新实例。这样，我们就防止了意外的变量突变。</p><p id="44bb" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">要复制数组，我们使用完全相同的语法:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">用spread运算符不变地复制数组</p></figure><p id="3dd6" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated"><strong class="lb iu">注意:</strong>请记住，spread操作符只执行浅层复制。这意味着，如果您在数组/对象中存储了引用数据类型，当您使用spread操作符进行复制时，嵌套的数组/对象将包含对原始数组/对象的引用，因此是可变的。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="8cd5" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">将类似数组的对象转换为数组</h1><p id="faf4" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">类似数组的对象与数组非常相似。它们通常有编号元素和长度属性。然而，它们有一个重要的区别:类似数组的对象没有任何数组函数。</p><p id="28f1" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">类似数组的对象包括大多数DOM方法返回的HTML节点列表、每个JS函数中自动生成的参数变量，以及其他一些对象。</p><p id="6959" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">使用与克隆数组时相同的语法，我们可以使用spread操作符将类似数组的结构转换为数组，作为使用<code class="fe lx ly lz ma b">Array.from</code>的替代方法。这里有一个例子，将一个<code class="fe lx ly lz ma b">nodeList</code>转换成一个数组:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">将节点列表转换为数组</p></figure><p id="a161" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">使用这种技术，我们可以将任何类似数组的结构转换成数组，从而可以访问所有的数组函数。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="e90b" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">作为参数的扩展运算符</h1><p id="f573" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">一些函数接受可变数量的参数。这类函数的一个很好的例子是<code class="fe lx ly lz ma b">Math</code>集合中的函数。对于我们的例子，让我们选择<code class="fe lx ly lz ma b">Math.max()</code>函数，它接受<em class="ns"> n </em>个数字参数，并返回最大的一个。假设我们有一个数组想要传递给<code class="fe lx ly lz ma b">Math.max()</code>函数。我们怎么做呢？</p><p id="9abd" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">我们可以这样做(不要因为下面的代码而恨我):</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="759c" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">但是，当然，这样做无异于自杀。如果我们有20个值呢？还是1000？我们真的要通过索引来访问每个值吗？答案是否定的。正如我们已经知道的，spread操作符接受一个数组并提取每个单独的值。这正是我们要找的。因此，我们可以这样做:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="dbc8" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">让接线员去救援。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="f546" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">添加新元素</h1><h2 id="6e17" class="mg kc it bd kd mh mi dn kh mj mk dp kl lk ml mm kp lo mn mo kt ls mp mq kx mr bi translated">向数组中添加项目</h2><p id="bb68" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">要向数组中添加新元素，我们首先扩展数组的内容，并使用数组文字<code class="fe lx ly lz ma b">[]</code> <strong class="lb iu"> <em class="ns"> </em> </strong>创建数组的新实例，其中包含原始数组的内容以及我们要添加的值:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">使用spread运算符向数组中添加项</p></figure><p id="2b89" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">正如你所看到的，我们可以添加尽可能多的新项目。</p><h2 id="d010" class="mg kc it bd kd mh mi dn kh mj mk dp kl lk ml mm kp lo mn mo kt ls mp mq kx mr bi translated">向对象添加属性</h2><p id="388a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">通过使用与数组相同的语法，我们可以在克隆对象时轻松地添加新属性。稍微转换一下，这里有一个不同的语法来为对象添加属性(它也可以用于数组):</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="226d" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">正如你所看到的，我们可以直接在对象内部声明和初始化新的变量，而不是在外部。</p></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="0b23" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">合并数组/对象</h1><h2 id="e361" class="mg kc it bd kd mh mi dn kh mj mk dp kl lk ml mm kp lo mn mo kt ls mp mq kx mr bi translated">数组</h2><p id="f473" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们可以通过展开两个数组并使用数组文字来合并它们，就像前面的例子一样。然而，我们不是简单地添加一个新元素，而是要添加另一个(扩展)数组:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">用spread运算符合并两个数组</p></figure><p id="4286" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">如果我们有一个对象数组，它也是有效的:</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">用spread运算符合并两个对象数组</p></figure><h2 id="2e57" class="mg kc it bd kd mh mi dn kh mj mk dp kl lk ml mm kp lo mn mo kt ls mp mq kx mr bi translated">目标</h2><p id="ba82" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们可以使用与之前相同的语法将两个(或更多)对象合并成一个对象(您现在可能已经注意到，spread运算符的用法非常相似，既用于数组也用于对象):</p><figure class="oa ob oc od gt ju"><div class="bz fp l di"><div class="oe of l"/></div><p class="og oh gj gh gi oi oj bd b be z dk translated">用扩展操作符合并两个对象</p></figure></div><div class="ab cl ng nh hx ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="im in io ip iq"><h1 id="8790" class="kb kc it bd kd ke nn kg kh ki no kk kl km np ko kp kq nq ks kt ku nr kw kx ky bi translated">结论</h1><p id="3a02" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在本教程的第一部分中，我们已经了解了为什么我们应该使用spread运算符(不变性！)，它是如何工作的，以及所述运算符的几种基本用法。在教程的第二部分，我们将通过一些高级技术和用例来加深我们对这个操作符的了解。以下是教程第二部分的链接:</p><p id="734e" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated"><a class="ae nz" href="https://medium.com/better-programming/understanding-the-javascript-spread-operator-from-beginner-to-expert-part-2-1ec1808d015e" rel="noopener">了解JavaScript扩展运算符—高级用途</a></p><p id="599f" class="pw-post-body-paragraph kz la it lb b lc mb le lf lg mc li lj lk md lm ln lo me lq lr ls mf lu lv lw im bi translated">非常感谢您的阅读。</p></div></div>    
</body>
</html>