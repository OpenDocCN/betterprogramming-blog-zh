<html>
<head>
<title>“You Don’t Know JS:” My Understanding of Scopes and Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“你不知道JS:”我对作用域和闭包的理解</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/you-dont-know-js-my-understanding-of-scopes-closures-e0d2bfe4c328?source=collection_archive---------13-----------------------#2019-11-12">https://betterprogramming.pub/you-dont-know-js-my-understanding-of-scopes-closures-e0d2bfe4c328?source=collection_archive---------13-----------------------#2019-11-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="aac9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了尽可能深入地理解JavaScript，阅读Kyle Simpson的YDKJS系列丛书是必不可少的。下面是我对这个令人惊奇的系列丛书中的第二本书“范围&amp;闭包”的理解。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><figure class="kx ky kz la gt lb gh gi paragraph-image"><div class="gh gi kw"><img src="../Images/9ac53c6348219dc13cf447c01aeb35de.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*KB0m1gkDbhqJsV_wa2ISXQ.jpeg"/></div><p class="le lf gj gh gi lg lh bd b be z dk translated"><a class="ae ko" href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/README.md" rel="noopener ugc nofollow" target="_blank">“范围&amp;关闭”凯尔·辛普森</a></p></figure><p id="37b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的程序中包含变量是执行任务的最基本要求之一。但这也引发了一些问题:</p><p id="e749" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.这些变量存在于哪里，或者存储在哪里？<br/> 2。我们的程序在需要它们的时候是如何找到它们的？</p><p id="0be8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">针对上述问题以及更多问题的一组定义明确的规则被称为<em class="li">范围。</em></p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="3f82" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">编译理论</h1><p id="dce6" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">尽管JavaScript属于动态语言或解释语言的范畴，但事实上，它是编译语言。为了简单起见，我就不深究编译的各个步骤了。</p><p id="510b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">任何JavaScript代码片段都必须先编译(通常是<em class="li">对</em>之前！)就执行了。所以JS编译器将首先获取程序<code class="fe mm mn mo mp b">var a = 2;</code>并编译它，然后准备执行它——通常是马上。</p><p id="b2fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们以<code class="fe mm mn mo mp b">var a = 2;</code>为例，JavaScript引擎会将<code class="fe mm mn mo mp b">var a = 2;</code>分解成单独的块字符，将这些块解析成所谓的<em class="li">抽象语法树，</em>，然后将该树转化为一组机器指令，以实际创建一个名为<code class="fe mm mn mo mp b">a if not previously declared in the current scope</code>的变量(在编译阶段)，并在稍后为其分配值<code class="fe mm mn mo mp b">2</code>(在执行阶段)。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="31bf" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">编译器查找</h1><p id="3850" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这里，作者介绍了左侧(LHS)和右侧(RHS)查找的概念。但问题是:到<em class="li">的那一边是什么？</em>向<strong class="js iu">侧</strong>进行作业。</p><p id="70e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个变量出现在赋值操作的左边时，就完成了LHS查找，就像在<code class="fe mm mn mo mp b">var a = 2;</code>的例子中，LHS查找试图找到变量容器本身，以便它可以赋值。</p><p id="cfcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当变量在赋值操作的右边时，RHS查找完成，如<code class="fe mm mn mo mp b">console.log(a);</code>所示。<strong class="js iu"> </strong>对<code class="fe mm mn mo mp b">a</code> <strong class="js iu"> </strong>的引用是一个<strong class="js iu"> </strong> RHS引用，因为这里没有给<code class="fe mm mn mo mp b">a</code>赋值。相反，我们希望检索<code class="fe mm mn mo mp b">a</code>的值，这样该值就可以传递给<code class="fe mm mn mo mp b">console.log(…)</code>。相比之下，在<code class="fe mm mn mo mp b">a = 2;</code>中，对<code class="fe mm mn mo mp b">a</code>的引用是一个LHS引用，因为我们实际上并不关心当前值是多少——我们只是想找到变量作为<code class="fe mm mn mo mp b">=2</code>赋值操作的目标。</p><p id="c734" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在LHS查找的作用域链中找不到该变量，将自动创建一个全局变量(在非严格模式下)，或者抛出一个<code class="fe mm mn mo mp b">ReferenceError</code>(在严格模式下)。</p><p id="d765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在RHS查找的作用域链中找不到该变量，将抛出<code class="fe mm mn mo mp b">ReferenceError</code>。</p><p id="9392" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，无论何时您在控制台中看到一个<code class="fe mm mn mo mp b">ReferenceError</code>，您都可以确定它与范围故障有关。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="3117" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">词法范围</h1><p id="c660" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated"><em class="li">词法范围</em>是JavaScript作者在编写代码时定义的范围。(这是一种很好的思考范围的方式！)这完全取决于作者选择将他/她的变量和函数(以及块)放在哪里。这个位置告诉JavaScript引擎应该在哪里执行LHS和RHS查找——换句话说，就是它需要向上移动来查找变量的范围链。</p><h2 id="326d" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">JavaScript使用词法范围</h2><p id="e7ae" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">当我们从RHS和LHS的角度来看待嵌套作用域的概念时，理解和编码变得更加容易和有趣。</p><p id="7790" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="9fce" class="mq lk it mp b gy ng nh l ni nj">function foo(a) {<br/>	console.log( a + b );<br/>}<br/><br/>var b = 2;<br/><br/>foo( 2 ); // 4</span></pre><p id="5703" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe mm mn mo mp b">b</code>的RHS引用不能在函数<code class="fe mm mn mo mp b">foo</code>中解析，但是可以在它周围的作用域中解析(在这种情况下，它是全局作用域)。</p><h2 id="4fdf" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">遍历嵌套范围的简单规则</h2><p id="27a8" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我们从当前执行的范围开始，在那里寻找变量。如果找不到，我们继续向上一级——以此类推。如果到达最外层的全局范围，搜索就会停止，不管是否找到变量。</p><p id="232b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这本书给出了一个非常好的嵌套作用域的例子，即“相互嵌套的气泡”</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="8fd6" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">作弊词汇</h1><p id="5156" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在我讨论两个欺骗或者修改词法范围的方法之前，我必须给出一个警告——主要有两个原因:</p><ol class=""><li id="0b8f" class="nk nl it js b jt ju jx jy kb nm kf nn kj no kn np nq nr ns bi translated">这是一种不好的做法，会被更广泛的JavaScript社区所反对</li><li id="ca3f" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated">这会导致较差的性能</li></ol><p id="a836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我将不再赘述。尽管如此，这很有趣。好了，我们开始吧:</p><h2 id="67a6" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">evaluate 评价</h2><p id="2e2d" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">考虑一下这个:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="d1ee" class="mq lk it mp b gy ng nh l ni nj">function foo(str, a) {<br/>	eval( str ); // cheating!<br/>	console.log( a, b );<br/>}<br/><br/>var b = 2;<br/><br/>foo( "var b = 3;", 1 ); // 1 3</span></pre><p id="6add" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">很简单，您可以看到,<code class="fe mm mn mo mp b">eval(..)</code>接受一个字符串，并将该字符串的内容视为实际上是在程序中的该点编写的代码。</p><p id="4d7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，您可以在您创作的代码中以编程方式生成代码，并运行生成的代码，就像它在创作时就在那里一样。</p><h2 id="945f" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">随着</h2><p id="d0a3" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated"><code class="fe mm mn mo mp b">with</code>通常被解释为对一个对象进行多个属性引用而不每次都重复对象引用本身的简写。</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="71c9" class="mq lk it mp b gy ng nh l ni nj">var obj = {<br/>	a: 1,<br/>	b: 2,<br/>	c: 3<br/>};<br/><br/>// more "tedious" to repeat "obj"<br/>obj.a = 2;<br/>obj.b = 3;<br/>obj.c = 4;<br/><br/>// "easier" short-hand<br/>with (obj) {<br/>	a = 3;<br/>	b = 4;<br/>	c = 5;<br/>}</span></pre></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="0767" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">在函数中隐藏东西</h1><p id="6405" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这里我们介绍<em class="li">最小曝光</em>原理。顾名思义，我们应该只暴露最不必要的东西，本质上，隐藏所有其他的东西。</p><h2 id="a406" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">防止空中相撞</h2><p id="2a7b" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">将变量和函数隐藏在作用域内的另一个好处是避免两个名称相同但用途不同的不同标识符之间的意外冲突。冲突通常会导致意外的值覆盖。</p><p id="c5fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="381a" class="mq lk it mp b gy ng nh l ni nj">function foo() {<br/>	function bar(a) {<br/>		i = 3; // changing the `i` in the enclosing scope's for-loop<br/>		console.log( a + i );<br/>	}</span><span id="3080" class="mq lk it mp b gy ny nh l ni nj">	for (var i=0; i&lt;10; i++) {<br/>		bar( i * 2 ); // oops, infinite loop ahead!<br/>	}<br/>}</span><span id="3ee1" class="mq lk it mp b gy ny nh l ni nj">foo();</span></pre><p id="2c70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在for循环中，<code class="fe mm mn mo mp b">bar(..)</code>中的<code class="fe mm mn mo mp b">i = 3</code>赋值意外地覆盖了<code class="fe mm mn mo mp b">foo(..)</code>中声明的<code class="fe mm mn mo mp b">i</code>。</p><p id="48c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，这将导致一个无限循环，因为<code class="fe mm mn mo mp b">i</code>被设置为固定值<code class="fe mm mn mo mp b">3</code>，并且将永远保持<code class="fe mm mn mo mp b">&lt; 10</code>。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="a3db" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">函数声明与函数表达式</h1><p id="6e3d" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这是一个非常重要的概念，但我完全忘记了。</p><p id="6eb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简单来说，如果<code class="fe mm mn mo mp b">function</code>是语句中的第一件事，那么它就是一个函数声明。否则就是函数表达式。</p><p id="2881" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数声明:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="8a66" class="mq lk it mp b gy ng nh l ni nj">function foo() { <br/>	console.log("This is a function declaration");<br/><br/>}</span></pre><p id="77eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑一下这个:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="0743" class="mq lk it mp b gy ng nh l ni nj">var a = 2;</span><span id="bd41" class="mq lk it mp b gy ny nh l ni nj">(function foo(){ // &lt;-- insert this</span><span id="1d53" class="mq lk it mp b gy ny nh l ni nj">	var a = 3;<br/>	console.log( a ); // 3</span><span id="b1ed" class="mq lk it mp b gy ny nh l ni nj">})(); // &lt;-- and this</span><span id="6af9" class="mq lk it mp b gy ny nh l ni nj">console.log( a ); // 2</span></pre><p id="3207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为表达式的<code class="fe mm mn mo mp b">(function foo(){ .. })</code>表示标识符<code class="fe mm mn mo mp b">foo</code>只在<code class="fe mm mn mo mp b">..</code>指示的范围内，而不在外部范围内。因此，包围<code class="fe mm mn mo mp b">(function foo(){ .. })</code>的作用域中的值不会被全局作用域中的值污染。</p><p id="63af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是编写函数表达式的不同方法:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="588d" class="mq lk it mp b gy ng nh l ni nj">var foo = function() { <br/>	console.log("This is an anonymous function expression");<br/><br/>}</span><span id="0e90" class="mq lk it mp b gy ny nh l ni nj">var x = function foo() { <br/>	console.log("This is a <em class="li">named</em> function expression");<br/><br/>}</span><span id="fc24" class="mq lk it mp b gy ny nh l ni nj">(function() { <br/>	console.log("This is a self-invoking function expression");<br/><br/>})()</span><span id="4244" class="mq lk it mp b gy ny nh l ni nj">(function foo() { <br/>	console.log("This is a named self-invoking function expression");<br/>})()</span><span id="45ed" class="mq lk it mp b gy ny nh l ni nj">setTimeout( function(){<br/>	console.log("This is an anonymous function expression as a callback parameter");<br/>}, 1000 );</span><span id="5786" class="mq lk it mp b gy ny nh l ni nj">setTimeout( function(){<br/>	console.log("This is a named function expression as a callback parameter");<br/>}, 1000 );</span></pre></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="7460" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">立即调用函数表达式(IIFE)</h1><p id="9b0f" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">生活可以用两种不同的方式书写:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="4f7a" class="mq lk it mp b gy ng nh l ni nj">(function() {<br/>  console.log('First')<br/>})();</span><span id="5aaa" class="mq lk it mp b gy ny nh l ni nj">(function() {<br/>  console.log('Second')<br/>}());</span></pre></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="4d9f" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">块作为作用域</h1><p id="8ab3" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">考虑一个for循环:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="7533" class="mq lk it mp b gy ng nh l ni nj">for (var i=0; i&lt;10; i++) {<br/>	console.log( i );<br/>}<br/>console.log(i) //10</span></pre><p id="7eeb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以清楚地看到，在for循环中声明<code class="fe mm mn mo mp b">i </code>是有意义的，但是当使用<code class="fe mm mn mo mp b">var</code>时，这是不相关的，因为它们总是属于封闭范围。那么，为什么要用只在for循环中使用的<code class="fe mm mn mo mp b">i</code>变量来污染函数的整个范围呢？解决方案是<code class="fe mm mn mo mp b">let</code>和<code class="fe mm mn mo mp b">const</code>。让我们来看看它们:</p><p id="3874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mm mn mo mp b">Let</code>和<code class="fe mm mn mo mp b">const</code>创建它们自己的块范围，就像try…catch语句中的catch一样。</p><p id="41dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下示例将进一步阐明这一点:</p><h2 id="abf6" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">试着…接住</h2><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="1a35" class="mq lk it mp b gy ng nh l ni nj">try {<br/>	undefined(); // illegal operation to force an exception!<br/>}<br/>catch (err) {<br/>	console.log( err ); // works!<br/>}<br/><br/>console.log( err ); // ReferenceError: `err` not found</span></pre><p id="c524" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，<code class="fe mm mn mo mp b">err</code>仅存在于catch子句中，当您试图在其他地方引用它时会抛出一个错误。</p><h2 id="5e38" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">让</h2><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="3f7a" class="mq lk it mp b gy ng nh l ni nj">var foo = 1;<br/><br/>if (foo) {<br/>	let bar = foo * 2;<br/>	console.log( bar );// 2<br/>}<br/><br/>console.log( bar ); // ReferenceError</span></pre><p id="ecd2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe mm mn mo mp b">var</code>运行时的相同代码:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="6ed9" class="mq lk it mp b gy ng nh l ni nj">var foo = 1;<br/><br/>if (foo) {<br/>	var bar = foo * 2;<br/>	console.log( bar );// 2<br/>}<br/><br/>console.log( bar ); // 2</span></pre><h2 id="6b24" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">常数</h2><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="a230" class="mq lk it mp b gy ng nh l ni nj">var foo = 1;<br/><br/>if (foo) {<br/>	var a = 2;<br/>	const b = 3; // block-scoped to the containing `if`<br/><br/>	a = 3; // just fine!<br/>	b = 4; // error!<br/>}<br/><br/>console.log( a ); // 3<br/>console.log( b ); // ReferenceError!</span></pre><p id="482c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Const也创建一个块范围的变量，但是值是固定的(常量)。以后任何更改该值的尝试都会导致错误。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="3ea2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">提升</h1><p id="40b0" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">这可能是我们在上面学到的所有东西中最重要的结论——也可能是最有趣的。</p><p id="9338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看两个场景:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="c957" class="mq lk it mp b gy ng nh l ni nj">Scenario 1:<br/>a = 2;<br/><br/>var a;<br/><br/>console.log( a ); // 2</span><span id="cbd2" class="mq lk it mp b gy ny nh l ni nj">Scenario 2:<br/>console.log( a ); // undefined<br/><br/>var a = 2;</span></pre><p id="58a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">输出看起来令人困惑的原因是因为提升。</p><p id="0871" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JS引擎分两步工作:第一步是<em class="li">编译</em>阶段，接下来是<em class="li">执行</em>阶段。这两步的工作是不同的。</p><p id="3b42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在编译阶段，处理所有变量和函数声明。</p><p id="72f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在编译阶段之后，在执行阶段，所有的逻辑和赋值都发生了。</p><p id="b434" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你看到<code class="fe mm mn mo mp b">var a = 2;</code>时，你可能认为那是一个陈述。但是JavaScript实际上把它想成了两个语句:<code class="fe mm mn mo mp b">var a;</code>和<code class="fe mm mn mo mp b">a = 2;</code>。第一个语句是声明，在编译阶段处理。第二个语句，赋值，留在执行阶段的位置。</p><p id="156f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">注意:</strong>在上面的例子中，<em class="li">到位</em>部分非常重要。同样重要的是要注意，吊装是按范围进行的。</p><p id="66fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的第一个片段是:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="3d55" class="mq lk it mp b gy ng nh l ni nj">var a;</span><span id="5421" class="mq lk it mp b gy ny nh l ni nj">a = 2;<br/><br/>console.log( a ); // 2</span></pre><p id="36f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的第二个片段:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="891f" class="mq lk it mp b gy ng nh l ni nj">var a;</span><span id="8cf7" class="mq lk it mp b gy ny nh l ni nj">console.log( a ); //undefined<br/><br/>a = 2;</span></pre><h2 id="8075" class="mq lk it bd ll mr ms dn lp mt mu dp lt kb mv mw lx kf mx my mb kj mz na mf nb bi translated">功能第一</h2><p id="cc92" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">一个微妙但重要的细节:函数首先被提升，然后是变量。</p><p id="fade" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="7c5e" class="mq lk it mp b gy ng nh l ni nj">foo(); // 1</span><span id="6a19" class="mq lk it mp b gy ny nh l ni nj">var foo;</span><span id="85b1" class="mq lk it mp b gy ny nh l ni nj">function foo() {<br/>    console.log( 1 );<br/>}</span><span id="d1af" class="mq lk it mp b gy ny nh l ni nj">foo = function() {<br/>    console.log( 2 );<br/>};</span></pre><p id="d409" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打印<code class="fe mm mn mo mp b">1</code>而不是<code class="fe mm mn mo mp b">2</code>。该代码片段被引擎解释为:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="48d9" class="mq lk it mp b gy ng nh l ni nj">function foo() {<br/>    console.log( 1 );<br/>}</span><span id="ab0b" class="mq lk it mp b gy ny nh l ni nj">foo(); // 1</span><span id="497e" class="mq lk it mp b gy ny nh l ni nj">foo = function() {<br/>    console.log( 2 );<br/>};</span></pre><p id="a4e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">虽然多重/重复的<code class="fe mm mn mo mp b">var</code>声明被有效地忽略了，但是后续的函数声明确实覆盖了之前的声明。</p><p id="0d3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑接下来的两个片段:</p><p id="2ffa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">片段1:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="8f35" class="mq lk it mp b gy ng nh l ni nj">foo(); // 3 since the second function decalaration overrides the first one.<br/><br/>function foo() {<br/>    console.log( 1 );<br/>}<br/><br/>var foo = function() {<br/>    console.log( 2 );<br/>};<br/><br/>function foo() {<br/>    console.log( 3 );<br/>}</span></pre><p id="b0f4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">片段2:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="2fc1" class="mq lk it mp b gy ng nh l ni nj">foo(); // "b"<br/><br/>var a = true;<br/>if (a) {<br/>   function foo() { console.log( "a" ); }<br/>}<br/>else {<br/>   function foo() { console.log( "b" ); }<br/>}</span></pre><p id="15d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">出现在普通块内部的函数声明通常提升到封闭范围，而不是像上面的代码所暗示的那样是有条件的。</p></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="5338" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">关闭</h1><p id="d71b" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">如果对词法范围理解得足够好，闭包是一个很容易理解的概念。本质上，我们经常使用闭包，但并没有真正理解它。</p><p id="346e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以把闭包看作一种调用函数或者在函数的词法范围之外使用函数的方式，或者看作函数访问其词法范围的能力，即使该函数在其词法范围之外被调用。</p><p id="3c57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑这个简单的代码:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="b7e0" class="mq lk it mp b gy ng nh l ni nj">function foo() {<br/>	var a = 2;<br/><br/>	function bar() { // this function has a closure over the scope of foo<br/>		console.log( a ); <br/>	}<br/><br/>	bar();<br/>}<br/><br/>foo(); // 2</span></pre><p id="0af2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使上面的代码更加清晰，请考虑以下情况:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="9c06" class="mq lk it mp b gy ng nh l ni nj">function foo() {<br/>	var a = 2;<br/><br/>	function bar() {<br/>		console.log( a );<br/>	}<br/><br/>	return bar; // we return the entire function of bar<br/>}<br/><br/>var baz = foo(); // now baz has the same function definition as bar but it can acess bar's lexical scope<br/><br/>baz(); // guess what the output is, yes it's the same as above: 2</span></pre><p id="0a10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以定义一下:</p><blockquote class="nz oa ob"><p id="67cb" class="jq jr li js b jt ju jv jw jx jy jz ka oc kc kd ke od kg kh ki oe kk kl km kn im bi translated">闭包是指函数能够记住并访问其词法范围——即使该函数在其词法范围之外执行。</p></blockquote></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="88b1" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">模块</h1><p id="6ad8" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我并不熟悉本书中解释的<em class="li">模块</em>的概念，但是它们非常有趣并且很有帮助。</p><p id="2382" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模块是利用闭包力量的代码模式。</p><p id="1a1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以此为例:</p><pre class="kx ky kz la gt nc mp nd ne aw nf bi"><span id="1086" class="mq lk it mp b gy ng nh l ni nj">function Module() {<br/>	var a= "This is a module!";<br/>	<br/>	function func() {<br/>		console.log( a );<br/>	}<br/><br/>	return {<br/>		func: func<br/>	};<br/>}<br/><br/>var foo = Module();<br/>foo.func(); // This is a module!</span></pre><p id="19c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是JavaScript中的模式，我们称之为模块。</p><p id="d98b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">更简单地说，对于要运用的模块模式有两个要求:</p><ol class=""><li id="e94c" class="nk nl it js b jt ju jx jy kb nm kf nn kj no kn np nq nr ns bi translated">必须有一个外包函数，并且至少要调用一次(上例中是<code class="fe mm mn mo mp b">Module</code>)。</li><li id="3bc7" class="nk nl it js b jt nt jx nu kb nv kf nw kj nx kn np nq nr ns bi translated">外部封闭函数必须返回至少一个内部函数，因此这个内部函数在私有范围上具有闭包，并且可以访问和/或修改私有状态。(上例中，是<code class="fe mm mn mo mp b">func</code> <em class="li">。</em>)</li></ol></div><div class="ab cl kp kq hx kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="im in io ip iq"><h1 id="b7f5" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">完成的</h1><p id="1b70" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">现在是时候深入研究第三本关于<a class="ae ko" href="https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/README.md" rel="noopener ugc nofollow" target="_blank"> this和对象原型</a>的书了</p><p id="f433" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！</p></div></div>    
</body>
</html>