<html>
<head>
<title>Practical Asynchronous Iteration in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中实用的异步迭代</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/practical-asynchronous-iteration-in-javascript-a-hackernews-stories-iterable-f3c7a70466d?source=collection_archive---------9-----------------------#2020-08-25">https://betterprogramming.pub/practical-asynchronous-iteration-in-javascript-a-hackernews-stories-iterable-f3c7a70466d?source=collection_archive---------9-----------------------#2020-08-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f993" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">黑客新闻故事连载</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9b3e5985603c875a66e2b783a88b0e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipeD1Bk0pNrwkwQ4zwzSmw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@nate-castner-345362?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">内特·卡斯特纳</a>从<a class="ae ky" href="https://www.pexels.com/photo/man-walking-in-the-snow-at-daytime-950740/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄。</p></figure><p id="2b8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着ES6的引入，我们获得了对数据同步迭代的支持。当然，我们已经可以迭代iterable <em class="lv"> </em>内置的结构，比如对象或数组，但是主要的引入是形式化一个可实现的接口来创建我们的iterable<strong class="lb iu"/>和生成器。</p><p id="76d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，如果我们的迭代是在从一个异步数据源获得的数据上完成的，比如一组远程HTTP调用或从一个文件中读取，那该怎么办呢？</p><p id="88ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将对<a class="ae ky" href="https://tc39.es/proposal-async-iteration/" rel="noopener ugc nofollow" target="_blank">“异步迭代”</a>提案进行实际分析，该提案旨在添加:</p><blockquote class="lw lx ly"><p id="69b0" class="kz la lv lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">"使用AsyncIterable和AsyncIterator协议支持异步迭代。它引入了一个新的迭代语句，<strong class="lb iu"> for-await-of </strong>，并添加了创建异步生成器函数和方法的语法。</p></blockquote><p id="1237" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本指南，只需要JavaScript(或一般编程)的基础知识。我们所有的例子都可以在<a class="ae ky" href="https://github.com/josetapadas/async_iterators/blob/master/src/index.ts" rel="noopener ugc nofollow" target="_blank"> this GitHub repository </a>中找到，这些例子将带有一些简单的TypeScript注释。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="181f" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">同步迭代器和生成器概述</h1><p id="902c" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">在这一节中，我们将快速回顾一下JavaScript中的同步迭代器和生成器，这样我们可以更容易地将它们推广到异步情况。</p><h2 id="eb5f" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">到底什么是迭代？</h2><p id="5ae8" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">让我们通过自我意识到迭代时手头通常有什么来研究这个问题。例如，一方面，我们有数组，字符串等。<strong class="lb iu"><em class="lv"/></strong><strong class="lb iu"><em class="lv"/></strong>基本上是我们的出处。另一方面，我们有通常用来通过迭代消费数据的方法——即我们的<code class="fe ns nt nu nv b">for</code>循环、扩展操作符等。</p><p id="ffaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">基于此，我们可以将迭代视为一个协议，当由我们的源实现时，它将允许消费者使用一组常规操作顺序地“消费”它的内容。该协议可以由以下接口表示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/01eb39f83749e358bf9c8e54f6f5dc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WOaQQRQL-peefmTnXyjUEQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.1为每次迭代定义同步可迭代、迭代器和后续结果的接口。</p></figure><p id="2878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于那些可能不熟悉TS接口描述的读者，我直截了当地说:</p><ul class=""><li id="11eb" class="nx ny it lb b lc ld lf lg li nz lm oa lq ob lu oc od oe of bi translated">一个<code class="fe ns nt nu nv b">SynchronousIterable</code>通过一个将返回一个<code class="fe ns nt nu nv b">SynchronousIterator</code>的<code class="fe ns nt nu nv b">Symbol.iterator</code>提供一个方法。</li><li id="61cb" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">然后我们的<code class="fe ns nt nu nv b">SynchronousIterator</code>将从<code class="fe ns nt nu nv b">.next()</code>方法的实现中返回我们的<code class="fe ns nt nu nv b">IteratorResults</code>。</li><li id="0844" class="nx ny it lb b lc og lf oh li oi lm oj lq ok lu oc od oe of bi translated">然后，<code class="fe ns nt nu nv b">IteratorResults</code>将包含一个保存当前迭代值的值以及一个<code class="fe ns nt nu nv b">done</code>标志，该标志在最后一项被迭代后被设置为<code class="fe ns nt nu nv b">true</code>(迭代时为false)。</li></ul><p id="ea36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">注:你可以通过阅读</em> <a class="ae ky" href="https://tc39.es/ecma262/#sec-iteration" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> ECMAScript 2021语言规范文档</em> </a> <em class="lv">了解更多关于这方面的内容。</em></p><p id="b948" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过手动迭代数组，可以很容易地展示使用该接口的示例:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/a2923b833c105456bf71a08f9200afd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_83kTRsFEiQOppdpaLz1LQ.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.2简单的手工迭代。请注意，当我们过度遍历对象时,“done”被设置为true。</p></figure><p id="976f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实现这个接口的源代码也可以通过<code class="fe ns nt nu nv b">for..of</code>迭代指令进行迭代，您可能在某个时候使用过这个指令:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2c687f0f6677a74e822de981341b7596.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*WnctW7b1TOYDAiRQlklTsw.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.3使用for..迭代我们的源代码。</p></figure><p id="a2eb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我们希望像内置数组(如上所述)这样的源自然是可迭代的。为了以不同的方式展示它，我们将实现该接口，例如，生成一系列数字:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/0086d445291caff16e0be95f0d03e312.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSTuukAQ6tEcn4_LgtOgbA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.4一个可迭代源的自定义实现，生成从“开始”到“结束”的数字范围</p></figure><h2 id="8942" class="ng mk it bd ml nh ni dn mp nj nk dp mt li nl nm mv lm nn no mx lq np nq mz nr bi translated">发电机呢？</h2><p id="09d7" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">通常，函数要么返回单个值，要么不返回任何值。我们可以把生成器<strong class="lb iu"> </strong>看作是可以依次返回多个值的实体。这种价值观的持有，被归因于屈服的概念。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/46596274222878a33ed74c7e0c62c020.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*dwW78X2V61yXSTJknoDwTg.png"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.5定义同时产生相同1，2，3序列的发生器函数。</p></figure><p id="8c3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些生成器函数的行为不像常规函数，因为它们是延迟求值的。所以当被调用时，它们会返回一个生成器对象，负责管理它的执行。这些生成器也是可迭代的，<em class="lv"> </em>这意味着它们也实现了我们的接口，所以我们实际上可以像上面一样对它们进行循环:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi op"><img src="../Images/50a2565925840835fea712ff1ea24b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4psE_Mw2FGeheZYa9DL9Xg.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.6.检查我们的生成器函数的值。没错生成器的主要方法也是。下一个()。</p></figure><p id="8a32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，指出<code class="fe ns nt nu nv b">.next()</code>函数是获取这些生成器对象的下一个生成值的关键也是非常重要的。这将产生预期的输出。</p><p id="2282" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们现在可以产生值(而不是状态)，所以我们可以重新实现图1.4中的可迭代范围，但是现在使用一个生成器函数:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/d52f990caf639d063a1cbd4ea469c8dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWvfD7qO8vfwQmxsU07a-Q.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">1.7我们的范围可迭代源现在使用生成器函数实现。</p></figure><p id="222a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们所看到的，我们现在可以利用一个生成器函数来简化我们原来的范围可迭代的。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="9cec" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">异步接口提议</h1><p id="61f3" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">掌握了iterable接口定义背后的思想(图1.1)后，现在很容易扩展它，使我们迭代的每一步都返回异步操作的结果。这通常是通过承诺来实现的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi or"><img src="../Images/8079b85a1170a84c120d6ccd3abb2597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RAoZvdJOCjHVOh43dfaoWA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2.1.异步可迭代的接口。</p></figure><p id="ff3b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的定义中，我们可以很容易地识别出，当提供迭代的<code class="fe ns nt nu nv b">.next()</code>元素时，异步操作确实是。因此，以一种将结果作为承诺来处理的方式来实现它是微不足道的。让我们以这种方式修改我们的范围迭代器(来自图1.5)来弄清楚这一点，带有一个人为的延迟:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi os"><img src="../Images/d7d067b773f360d2e7520e6a8c0c3176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGFEVEVqDcmYEVSCsqX3Ag.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2.2 for…of的异步范围迭代。</p></figure><p id="78ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以使用这个概念在(1.7)中抽象我们的生成器。<strong class="lb iu"> <em class="lv"> </em> </strong>使用异步发电机实现相同的范围是微不足道的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/6acb941889f413af8391e6bc0ba6c305.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lhNDd7-SNXEbp2PiHG-t8A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">2.3异步发电机的实现</p></figure><p id="63c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管我们如何生成数据，我们可以简单地迭代元素，就好像异步源是另一个可迭代的。实际上，只要它实现了我们的接口就可以了。</p><p id="ad48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了演示这一点，下一节将使用一个异步源(一个Hacker News top stories提要),我们将使用它来操作任何其他可迭代结构。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="249d" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated"><strong class="ak">实战练习:一篇黑客新闻</strong></h1><p id="cd32" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">基于异步生成器(2.3)的实现，现在为我们的帖子实现一个生成器源是很容易的。对于这个例子，我们将使用<a class="ae ky" href="https://github.com/HackerNews/API" rel="noopener ugc nofollow" target="_blank"> HN API </a>:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oq"><img src="../Images/72d15b85d3ae52ac14c541c2ebd42f38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y9zjdE5ZsR9cqW6sFY0Z5A.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.1异步发电机，用于HN的顶级故事。</p></figure><p id="5e65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码只是通过实现异步迭代器的常用接口来隐藏异步逻辑。对于这个例子，我们将条目限制为迭代，这是可选的。通过产生每个迭代值，我们可以使用下面的简单实现轻松地使用这个源:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ot"><img src="../Images/3ed7b7fe461c101bf0e921e14d010e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcTH3VFav1fCT4KGG3hrrA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.2迭代我们的异步新闻源。</p></figure><p id="858c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如所料，这将为我们的源循环并呈现一个注释列表:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ou"><img src="../Images/7587c710d7d33d24b58c8bd8a2e14c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQ07YPoCO0GvmrDCVY9cPA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">3.3迭代结果来自我们的HN生成器。</p></figure><p id="c7cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以查看我们的数据源，并将其作为一个简单的数据序列来处理，将完整的异步获取和操作逻辑保留在我们的生成器定义中。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="e807" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">摘要</h1><p id="1891" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">希望这篇文章展示了通过应用语言规范中已经可用的简单语言形式来转换和观察我们的异步数据源以及可迭代对象是很容易的。</p><p id="4a47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过将同步情况推广到异步生成，我们现在可以迭代任何可迭代的数据源，不管数据源的性质如何——只要它实现了我们的接口。将我们的异步数据源视为可迭代的，这为我们开发更符合习惯、更有说服力的代码库的想法打开了一个创造性的潜力。</p><p id="bdef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有代码示例请参考本<a class="ae ky" href="https://github.com/josetapadas/async_iterators" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p></div></div>    
</body>
</html>