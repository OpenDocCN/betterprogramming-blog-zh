<html>
<head>
<title>How to Persist Sensitive Data Using Keychain in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Swift中使用Keychain保存敏感数据</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-persist-sensitive-data-using-keychain-in-swift-142b5769666c?source=collection_archive---------8-----------------------#2021-07-28">https://betterprogramming.pub/how-to-persist-sensitive-data-using-keychain-in-swift-142b5769666c?source=collection_archive---------8-----------------------#2021-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89ab" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">不要使用用户默认值来存储数据。请改用钥匙链</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4369855c388eaba720e8d5454e6374e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*neJU2PXhstwmqXiN"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@creativemomentsphotography09?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vinit Vispute </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="bd32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发iOS应用程序时，有时我们需要在本地存储敏感数据(密码、访问令牌、密钥等)。对于初级开发人员来说，首先想到的是使用<code class="fe lv lw lx ly b">UserDefaults</code>来存储它。</p><p id="1dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，众所周知，使用<code class="fe lv lw lx ly b">UserDefaults</code>存储敏感数据是一个<a class="ae ky" href="https://www.youtube.com/watch?v=UAgtOTOH2nQ" rel="noopener ugc nofollow" target="_blank">非常糟糕的主意</a>，因为使用<code class="fe lv lw lx ly b">UserDefaults</code>存储的数据没有加密，非常不安全。</p><p id="2ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了安全地在本地存储敏感数据，我们应该使用苹果公司提供的<a class="ae ky" href="https://developer.apple.com/documentation/security/keychain_services" rel="noopener ugc nofollow" target="_blank">钥匙链服务</a>。这是一个相当老的框架，因此正如你将在后面看到的，它的API不像苹果的其他现代框架那样快捷。</p><p id="c05e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将向您展示如何创建一个通用的助手类，它可以在iOS和macOS中工作，使用keychain服务保存、更新、读取和删除数据。涉及的话题太多了，所以让我们开始吧！</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="ee78" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">将数据存储到钥匙串</h1><p id="00e2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如前所述，我们将在文章中创建一个助手类。为了简单起见，让我们将helper类设为单例类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4ac1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将数据保存到keychain，我们必须利用接受类型为<code class="fe lv lw lx ly b">CFDictionary</code>的查询对象的<code class="fe lv lw lx ly b">SecItemAdd(_:_:)</code>方法。</p><p id="3143" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的想法是创建一个查询对象，其中包含我们想要保存的数据以及与数据相关联的主键。之后，我们将通过向<code class="fe lv lw lx ly b">SecItemAdd(_:_:)</code>方法提供查询对象来执行保存操作。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="12bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从上面的代码片段中可以看出，查询对象由4个字典键组成，让我们详细了解一下:</p><ul class=""><li id="a2fe" class="nf ng it lb b lc ld lf lg li nh lm ni lq nj lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">kSecValueData</code>:表示保存到钥匙串的数据的密钥。</li><li id="d9ba" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">kSecClass</code>:表示正在保存的数据类型的键。这里我们将它的值设置为<code class="fe lv lw lx ly b">kSecClassGenericPassword</code>,表示我们正在保存的数据是一个通用密码项。</li><li id="a4fa" class="nf ng it lb b lc no lf np li nq lm nr lq ns lu nk nl nm nn bi translated"><code class="fe lv lw lx ly b">kSecAttrService</code>和<code class="fe lv lw lx ly b">kSecAttrAccount</code>:当<code class="fe lv lw lx ly b">kSecClass</code>设置为<code class="fe lv lw lx ly b">kSecClassGenericPassword</code>时，这两个键是必须的。这两个键的值将作为保存数据的主键。换句话说，我们稍后将使用它们从钥匙串中检索保存的数据。</li></ul><p id="920f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">专业提示:查看<a class="ae ky" href="https://developer.apple.com/documentation/security/keychain_services/keychain_items/item_class_keys_and_values#1678477" rel="noopener ugc nofollow" target="_blank">这个</a>和<a class="ae ky" href="https://developer.apple.com/documentation/security/errsecduplicateitem" rel="noopener ugc nofollow" target="_blank">这个</a>文档，了解<code class="fe lv lw lx ly b">kSecClass</code>的其他可能值和它们各自的主键。</p><p id="f1b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于<code class="fe lv lw lx ly b">kSecAttrService</code>和<code class="fe lv lw lx ly b">kSecAttrAccount</code>使用什么值没有硬性规定。但是，建议使用有意义的字符串。例如，如果我们正在保存脸书访问令牌，我们可以将<code class="fe lv lw lx ly b">kSecAttrService</code>设置为“<em class="nt">访问令牌</em>”，将<code class="fe lv lw lx ly b">kSecAttrAccount</code>设置为“<em class="nt"> facebook </em>”。</p><p id="0004" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建查询对象后，我们可以调用<code class="fe lv lw lx ly b">SecItemAdd(_:_:)</code>方法将数据保存到keychain中。</p><p id="e652" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe lv lw lx ly b">SecItemAdd(_:_:)</code>方法将返回一个<code class="fe lv lw lx ly b">OSStatus</code>来指示保存操作的状态。如果我们获得<code class="fe lv lw lx ly b">errSecSuccess</code>状态，这意味着数据已经成功保存到钥匙串中。</p><p id="3114" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是如何使用我们刚刚创建的<code class="fe lv lw lx ly b">save(_:service:account:)</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="5f8b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Keychain在Xcode playground中不工作，因此您可以在视图控制器、SwiftUI视图中运行上面的代码，也可以将其作为单元测试用例运行。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="34d2" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">更新钥匙串中的现有数据</h1><p id="33e6" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">现在我们已经有了<code class="fe lv lw lx ly b">save(_:service:account:)</code>方法，让我们尝试使用相同的<code class="fe lv lw lx ly b">kSecAttrService</code>和<code class="fe lv lw lx ly b">kSecAttrAccount</code>值保存另一个令牌:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f306" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次，我们将无法将访问令牌保存到钥匙串中。相反，我们将在Xcode控制台中得到一条消息，显示“<code class="fe lv lw lx ly b">Error: -25299</code>”。错误代码<code class="fe lv lw lx ly b">-25299</code>表示保存操作失败，因为我们使用的密钥已经存在于钥匙串中。</p><p id="cc6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解决这个问题，我们需要检查<code class="fe lv lw lx ly b">-25299</code>错误代码(相当于<code class="fe lv lw lx ly b">errSecDuplicateItem</code>)，然后使用<code class="fe lv lw lx ly b">SecItemUpdate(_:_:)</code>方法更新密钥链。让我们继续更新我们之前的<code class="fe lv lw lx ly b">save(_:service:account:)</code>方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="0a28" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与保存操作类似，我们必须首先创建一个由<code class="fe lv lw lx ly b">kSecAttrService</code>和<code class="fe lv lw lx ly b">kSecAttrAccount</code>组成的查询对象。但是这一次，我们将不得不创建另一个由<code class="fe lv lw lx ly b">kSecValueData</code>组成的字典，并将其提供给<code class="fe lv lw lx ly b">SecItemUpdate(_:_:)</code>方法。</p><p id="5368" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们就使我们的<code class="fe lv lw lx ly b">save(_:service:account:)</code>方法能够更新keychain中的任何现有项目。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c217" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">从钥匙串中读取数据</h1><p id="c815" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">从钥匙串中读取数据的方式与我们将数据保存到钥匙串中的方式非常相似。我们首先创建一个查询对象，然后调用一个方法从keychain中获取数据:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="6e2c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，我们需要为查询对象设置<code class="fe lv lw lx ly b">kSecAttrService</code>和<code class="fe lv lw lx ly b">kSecAttrAccount</code>的值。除此之外，我们还需要在查询对象中包含一个新键<code class="fe lv lw lx ly b">kSecReturnData</code>，并将其值设置为<code class="fe lv lw lx ly b">true</code>。这表明我们希望查询返回项目数据。</p><p id="57a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后，我们将利用<code class="fe lv lw lx ly b">SecItemCopyMatching(_:_:)</code>方法并通过引用传入一个<code class="fe lv lw lx ly b">AnyObject</code>类型的<code class="fe lv lw lx ly b">result</code>对象。这个<code class="fe lv lw lx ly b">result</code>对象将保存查询对象所请求的项目数据。</p><p id="0dc8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们将把<code class="fe lv lw lx ly b">result</code>对象转换成<code class="fe lv lw lx ly b">Data</code>并返回它。值得注意的一点是，就像<code class="fe lv lw lx ly b">SecItemAdd(_:_:)</code>方法一样，<code class="fe lv lw lx ly b">SecItemCopyMatching(_:_:)</code>方法也将返回一个表示读取操作状态的<code class="fe lv lw lx ly b">OSStatus</code>，但是我们在这里不做任何检查，因为如果读取操作失败，我们将返回<code class="fe lv lw lx ly b">nil</code>。</p><p id="33c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是让我们的keychain helper类支持读操作的全部内容。让我们来看看它的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="c6a4" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">从钥匙串中删除数据</h1><p id="d398" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">如果我们的钥匙串助手类不支持删除操作，它将是不完整的。继续添加以下代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b6e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您一直在跟进，那么您应该对上面的代码很熟悉。这几乎是不言自明的，只需注意这里我们使用<code class="fe lv lw lx ly b">SecItemDelete(_:)</code>方法从keychain中删除项目。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="4e52" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">创建通用钥匙串助手类</h1><p id="e5c1" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">在这个阶段，我们已经实现了keychain helper类的所有必要功能。但是，有一个限制——它只支持读写类型为<code class="fe lv lw lx ly b">Data</code>的项目。如果我们可以在钥匙串上存储任何数据类型的对象，那不是很好吗？</p><p id="5c66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的想法是创建一个通用的保存方法，该方法接受任何数据类型符合<code class="fe lv lw lx ly b">Codable</code>协议的对象。这样，我们将能够使用<code class="fe lv lw lx ly b">JSONEncoder</code>编码给定的对象，并使用我们之前创建的<code class="fe lv lw lx ly b">save(_:service:account:)</code>方法存储它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2dd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用相同的思想，创建一个通用的read方法非常简单。我们将使用<code class="fe lv lw lx ly b">JSONDecoder</code>来解码从钥匙链中获得的数据并将其返回。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f56f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，我们就成功地使我们的keychain helper类通用化了。让我们来看看它的实际应用:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="16e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您想在自己的项目中尝试keychain helper类，您可以在这里获得完整的示例代码<a class="ae ky" href="https://gist.github.com/LeeKahSeng/2452e90a57a5324de367907a36d88a49" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0a70" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">包扎</h1><p id="e809" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">创建应用程序时，我们有责任保护用户的隐私，并确保他们的敏感数据安全地存储在应用程序中。因此，如果你还在使用<code class="fe lv lw lx ly b">UserDefaults</code>保存用户的敏感数据，你绝对应该停止这样做，而开始使用钥匙链！</p><p id="d105" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢阅读这篇文章，并希望在新文章发布时得到通知，请随时在Twitter上关注我。</p><p id="61b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div></div>    
</body>
</html>