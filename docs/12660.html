<html>
<head>
<title>Build a Dialog Manager With State Machines and XState in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript中的状态机和XState构建一个对话管理器</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-a-dialog-manager-with-state-machines-and-xstate-in-javascript-4002e7f03d92?source=collection_archive---------16-----------------------#2022-06-20">https://betterprogramming.pub/build-a-dialog-manager-with-state-machines-and-xstate-in-javascript-4002e7f03d92?source=collection_archive---------16-----------------------#2022-06-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3d25" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">带有XState的对话管理器</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5ca135be0fc182950698e12fed92295c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AvUyeCXqzW9Stl2qgsjMWA.png"/></div></div></figure><p id="e6a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">我们使用对话框通知用户可能需要他们执行额外操作或任务的特定和关键信息。大多数应用程序对话框都是动态的，我们通常负担不起将所有对话框作为占位符添加到主根元素中。因此，我们需要一个系统来管理，在运行时为单个对话框实例呈现适当的内容，并相应地触发打开/关闭和相关的动作。</em></p><p id="b0d2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了实现这个目标，我们使用状态机和状态图。</p><h1 id="2df8" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">什么是状态机？</h1><p id="e4c7" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">状态机或有限状态机包含有限数量的状态，代表机器在给定时间对一系列事件的反应。状态机一次只能存储一种状态，并且可以根据给定的事件输入从一种状态转移到另一种状态。</p><p id="6943" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用状态图来演示状态机的流程，每个节点代表一个状态，每个边代表从一个状态到另一个状态的事件转换。此外，对于每个事件边缘，我们可以在状态改变时执行动作来控制机器的内部数据上下文。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/72e59c94480239d6d3dc77e60f26e750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*934ItpXow7zo1au4"/></div></figure><p id="6145" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是一个带有两个状态节点(开/关)的切换状态机的例子，一个使用<code class="fe mp mq mr ms b">TOGGLE</code>事件连接到另一个。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/b624ae71f7fa8842d105d222b0ce1627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/0*OGMBpbBgODKwqCv6"/></div></figure><p id="361d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，让我们定义我们的对话状态图流程。</p><h1 id="7d39" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">定义对话状态图流程</h1><p id="f6f3" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">对话框的本质是从用户打开它的那一刻起，直到他关闭它或完成对话框上的一个所需动作，它都是可见的和焦点的。</p><p id="f050" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，对话机有两种主要状态:<code class="fe mp mq mr ms b">closed</code>和<code class="fe mp mq mr ms b">open</code>。<code class="fe mp mq mr ms b">closed</code>代表用户看不到对话框，<code class="fe mp mq mr ms b">open</code>则不然。我们使用<code class="fe mp mq mr ms b">OPEN</code>事件从<code class="fe mp mq mr ms b">closed</code>移动到<code class="fe mp mq mr ms b">open</code>，使用<code class="fe mp mq mr ms b">DONE</code>事件从<code class="fe mp mq mr ms b">open</code>移动到<code class="fe mp mq mr ms b">closed</code>，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/f018725817796fe403d8042439952b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/0*Qmk9g0caPxN5oe1b"/></div></figure><p id="ec7f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，这个流程图只适用于简单的对话框，在这种情况下，用户除了打开/关闭对话框之外，不需要执行任何额外的操作。</p><p id="e2e3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在用户必须执行确认的情况下，在关闭对话框之前，对话框将触发附加的动作，通常是附加到对话框的自定义动作。</p><p id="e40e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在其<code class="fe mp mq mr ms b">open</code>状态中，它必须在内部从<code class="fe mp mq mr ms b">idled</code>(等待用户点击确认按钮)转换到<code class="fe mp mq mr ms b">executing</code>模式(在确认后触发自定义动作)。自定义动作执行完成后，进入<code class="fe mp mq mr ms b">closed</code>状态。在这种情况下，我们将打开状态分为两种内部状态:<code class="fe mp mq mr ms b">idle</code>和<code class="fe mp mq mr ms b">executing</code>，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mv"><img src="../Images/6bb647a6489e7a672d7a4ad9b17e48d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QITZFtD4ura2OZMg"/></div></div></figure><p id="edce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">事实上，我们可以从<code class="fe mp mq mr ms b">executing</code>状态转换到<code class="fe mp mq mr ms b">idle</code>，反之亦然。我们通过<code class="fe mp mq mr ms b">open</code>的嵌套状态<code class="fe mp mq mr ms b">executing</code>从初始状态<code class="fe mp mq mr ms b">open</code>过渡到<code class="fe mp mq mr ms b">closed</code>。因此，我们的图表包含以下状态节点:</p><p id="048f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们通过以下事件(边)连接每个状态节点:</p><ul class=""><li id="47c4" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">OPEN</code> -(关闭、打开、闲置)</li><li id="8134" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">EXECUTING</code> -(打开.空闲，打开.执行)</li><li id="ed64" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">DISMISS</code> -(打开、闲置、关闭)</li><li id="fc98" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">RETRY</code> -(打开.执行，打开.空闲)</li><li id="40d4" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">DONE</code> -(打开.执行，关闭)</li></ul><p id="9fee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用大写字母命名每个事件，代表源状态和目的状态节点之间的流。我们现在可以展示我们的状态机图如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/10d4b94d67d1c4886e36a5343864fab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CcHPFm8utb0wrfH2"/></div></div></figure><p id="b472" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于每个事件转换，我们希望触发一些额外的动作来控制对话框的数据上下文，例如:</p><ul class=""><li id="3ea9" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">基于输入打开对话框时初始化上下文数据。</li><li id="7000" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">解除或关闭对话时重置数据上下文。</li><li id="9682" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">对话框确认时调用自定义动作(在<code class="fe mp mq mr ms b">executing</code>状态时)。</li><li id="3768" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">将错误消息分配给上下文，以显示调用确认时的错误。</li></ul><p id="4330" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的对话状态机图现在变成了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/cf3425a0549928ec4d503419d3ba32eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*miZrENApgXkDzo2n"/></div></div></figure><p id="0607" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以通过把我们的对话需求分解成一个有代表性的图形来看对话机制应该是什么样子。</p><p id="a841" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下一步是在XState库的帮助下将这个图转化成代码。</p><h1 id="75be" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">用XState构建对话机</h1><p id="17e0" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">XState是一个使用状态机和状态图的JavaScript状态管理库。</p><p id="ce56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们不要把它与VueX、Redux或其他标准的状态管理库混淆。</p><p id="33c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我看来，XState是一个显式的UI状态管理库，这意味着它有助于管理不同UI控件之间的状态流，同时还在侧面执行数据控件。</p><p id="a0d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可以使用以下命令在项目中安装XState:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="7069" class="nq ls it ms b gy nr ns l nt nu">npm i xstate</span><span id="7d17" class="nq ls it ms b gy nv ns l nt nu">#<em class="lq">OR</em></span><span id="806d" class="nq ls it ms b gy nv ns l nt nu">yarn add xstate</span></pre><p id="65fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">安装完成后，您可以使用来自<code class="fe mp mq mr ms b">xstate</code>包的<code class="fe mp mq mr ms b">createMachine</code>创建一个状态机，并将所需的机器配置作为方法的输入参数传递。</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="bd08" class="nq ls it ms b gy nr ns l nt nu">import { createMachine } from 'xstate'</span><span id="fe96" class="nq ls it ms b gy nv ns l nt nu">export const dialogMachine = createMachine({<br/>  /* configurations */<br/>})</span></pre><p id="9d91" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">XState库接受的配置API有很多字段。在本文中，我们将只采用以下主要配置来设置我们的机器:</p><ul class=""><li id="d415" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">id</code> -状态机的唯一标识符。</li><li id="8473" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">initial</code> -机器所需的启动状态(入口点)。</li><li id="9824" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">context</code>——机器的内部数据。我们使用这个字段来存储我们的自定义<code class="fe mp mq mr ms b">action</code>处理程序和自定义对话框选项，如<code class="fe mp mq mr ms b">title</code>、<code class="fe mp mq mr ms b">dataToSubmit</code>等。</li><li id="d97a" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">states</code> -该对象包含机器所有可能状态的定义。我们用一个<code class="fe mp mq mr ms b">[key, value]</code>对来表示每个状态，其中<code class="fe mp mq mr ms b">key</code>是状态的名称，<code class="fe mp mq mr ms b">value</code>是状态的配置对象。</li></ul><p id="a573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们的对话机的示例结构:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="4905" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们在<code class="fe mp mq mr ms b">states</code>下设置每个状态对象。根据之前的图表，我们定义了两个主要状态- <code class="fe mp mq mr ms b">closed</code>和<code class="fe mp mq mr ms b">open</code>，并将初始状态定义为<code class="fe mp mq mr ms b">closed</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0536" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于状态<code class="fe mp mq mr ms b">open</code>，我们也将使用对象属性<code class="fe mp mq mr ms b">states</code>定义其嵌套状态<code class="fe mp mq mr ms b">idle</code>和<code class="fe mp mq mr ms b">executing</code>，方法相同:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="0690" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是由于<code class="fe mp mq mr ms b">open</code>有它的内部状态，我们需要确定它的默认状态(初始状态)。该步骤对于机器在转换到<code class="fe mp mq mr ms b">open</code>状态后正确设置其状态至关重要。由于对话框是打开的，用户没有执行任何确认操作，我们将初始状态设置为<code class="fe mp mq mr ms b">idle</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="bf01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，让我们给我们的状态添加一些事件。</p><h1 id="a893" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">在状态之间添加事件</h1><p id="357a" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">每个状态对象都包含属性<code class="fe mp mq mr ms b">on</code>，它代表事件的对象，这些事件被接受来触发从该状态到其他状态的转换。</p><p id="3a58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">XState中的每个事件对象都有一个属性字段<code class="fe mp mq mr ms b">target</code>，表示要转换的目标状态的<code class="fe mp mq mr ms b">id</code>。对于<code class="fe mp mq mr ms b">closed</code>州，<code class="fe mp mq mr ms b">OPEN</code>事件的目标是<code class="fe mp mq mr ms b">open</code>州。该事件允许对话从<code class="fe mp mq mr ms b">closed</code>转换到<code class="fe mp mq mr ms b">open.</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="3067" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们将<code class="fe mp mq mr ms b">open</code>的默认内部状态设置为<code class="fe mp mq mr ms b">idle</code>，从<code class="fe mp mq mr ms b">closed</code>到<code class="fe mp mq mr ms b">open</code>的转换将自动将状态机设置为<code class="fe mp mq mr ms b">open.idle</code>状态。</p><p id="d128" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们需要创建的以下事件是用户提交(或确认)对话框时的<code class="fe mp mq mr ms b">EXECUTING</code>和用户选择关闭对话框而不执行任何操作时的<code class="fe mp mq mr ms b">DISMISS</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="c50e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们需要添加<code class="fe mp mq mr ms b">#</code>来指示<code class="fe mp mq mr ms b">DISMISS</code>事件的目标状态中的父级状态<code class="fe mp mq mr ms b">closed</code>。没有它，XState会将目标状态识别为<code class="fe mp mq mr ms b">open</code>的内部状态之一。</p><p id="e298" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">类似地，对于<code class="fe mp mq mr ms b">executing</code>状态，我们添加以下两个事件:</p><ul class=""><li id="523c" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">RETRY</code>，如果执行对话框动作时出现错误，将机器状态移回<code class="fe mp mq mr ms b">idle</code>状态</li><li id="4436" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">DONE</code>当动作执行成功完成时关闭对话框。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="91b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，一切顺利吗？我们刚刚为我们的机器设置了基本配置。完整的工作代码如下:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="33e2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了可视化我们的状态机并验证流程，XState团队(或庄严团队)开发了一个很棒的<a class="ae ny" href="https://stately.ai/viz" rel="noopener ugc nofollow" target="_blank">可视化工具</a>。该工具允许您对您的状态机进行实时编码，进行可视化调试，并查看转换流是如何工作的。</p><p id="c47d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们如何用这个工具测试我们新创建的<code class="fe mp mq mr ms b">dialog-machine</code>机器的流程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/2fb291cb693633a8f0a60c16d17be6dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dxqKHCORGvmHDB79.gif"/></div></div></figure><p id="85ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此工具允许您使用右侧窗格中的“状态”选项卡和“事件”选项卡，查看当前状态及其在您从一种状态切换到另一种状态时触发的事件。这个可视化器被证明在可视化状态机流和在早期验证我们的机器逻辑方面非常有用。</p><p id="e178" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们需要添加动作来控制每个事件转换的机器数据上下文。</p><h1 id="3e3b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">添加事件的动作</h1><p id="6f17" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">正如在开始时所讨论的，我们希望为我们的对话机器执行以下数据控制动作:</p><ul class=""><li id="a00d" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">基于输入打开对话框时初始化上下文数据。</li><li id="a673" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">解除或关闭对话时重置数据上下文。</li><li id="88e0" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">对话框确认时调用自定义动作(在<code class="fe mp mq mr ms b">executing</code>状态)。</li><li id="2536" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">将错误消息分配给上下文，以便在调用确认时出现错误时显示。</li></ul><p id="4663" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们研究每个行动要求。</p><p id="c40b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">打开时，我们的对话框组件应该在其模板中动态显示内容，除了标题头和页脚操作，如下图所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/cfc1dd7c098cff24fca29db81c0fe0a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x0e7xUyyNsHsiihx"/></div></div></figure><p id="c17b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它还包括每当用户确认对话框时绑定到正确的外部动作执行。因此，对话机器应该接收并保存其上下文中的一些基本数据，例如:</p><ul class=""><li id="c0a8" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">一个组件<code class="fe mp mq mr ms b">instance</code>来呈现对话框中的内容。如果没有可用的组件，对话框将呈现默认的“对话框机器”文本。</li><li id="e3b4" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">Title </code>的对话</li><li id="2cb5" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">对话框按钮<code class="fe mp mq mr ms b">labels </code>(确认/提交，取消)</li><li id="f998" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">Executor </code>用于在用户确认对话框时触发。</li><li id="1f2b" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">如果需要，外部<code class="fe mp mq mr ms b">data </code>将传递给执行者。</li><li id="e198" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><code class="fe mp mq mr ms b">Error </code>如果需要，在对话框中显示。</li></ul><p id="17a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将这个数据对象作为它的<code class="fe mp mq mr ms b">context</code>保存在状态机中。为了更新状态机的上下文，我们使用来自<code class="fe mp mq mr ms b">xstate</code>包的<code class="fe mp mq mr ms b">assign</code> API方法和状态事件的属性字段<code class="fe mp mq mr ms b">actions</code>。</p><p id="5856" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">assign</code>接收一个对象，该对象定义了机器应该如何更新当前<code class="fe mp mq mr ms b">context</code>的每个字段。每个字段都是一个函数，它接受以下两个参数，并返回适当的值以分配给该上下文字段:</p><ul class=""><li id="1db2" class="mw mx it kw b kx ky la lb ld my lh mz ll na lp nb nc nd ne bi translated">当前<code class="fe mp mq mr ms b">context</code></li><li id="a3fb" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">电流<code class="fe mp mq mr ms b">event</code>触发</li></ul><p id="632d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于我们的<code class="fe mp mq mr ms b">OPEN</code>事件，我们基于用<code class="fe mp mq mr ms b">event</code>对象传递的<code class="fe mp mq mr ms b">data</code>更新上下文，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="1695" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，正如我们之前在状态机流中定义的，我们希望每当用户关闭对话框时(通过<code class="fe mp mq mr ms b">DISMISS</code>或<code class="fe mp mq mr ms b">DONE</code>)清除所有保存的数据上下文。</p><p id="9156" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们对两个事件执行相同的操作，我们可以创建一个通用操作<code class="fe mp mq mr ms b">clear</code>，如下所示:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="6916" class="nq ls it ms b gy nr ns l nt nu">const clear = assign({<br/>   dataToSubmit: (_, event) =&gt; undefined,<br/>   error: (_, event) =&gt; '',<br/>   Component: (_, event) =&gt; undefined,<br/>   executor: (_, event) =&gt; undefined,<br/>})</span></pre><p id="cdff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后将它作为数组的一部分传递给两个事件的<code class="fe mp mq mr ms b">actions</code>字段，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="eae6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于它指示了<code class="fe mp mq mr ms b">RETRY</code>事件的错误，我们希望在返回到<code class="fe mp mq mr ms b">idle</code>状态时更新<code class="fe mp mq mr ms b">context.error</code>字段。我们继续使用<code class="fe mp mq mr ms b">assign</code>来相应地设置我们的<code class="fe mp mq mr ms b">context.error</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="cd0a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们想要更新<code class="fe mp mq mr ms b">dataToSubmit</code>而不在状态之间转换。在我们想要触发一个定制动作的场景中，比如对话框内容组件的表单提交，这个更新是必不可少的。为了实现这个目标，我们为<code class="fe mp mq mr ms b">idle</code>状态创建一个新的事件<code class="fe mp mq mr ms b">UPDATE_DATA</code>，只需一个动作，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8436" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经完成了设置打开和关闭对话框所需的动作，在需要时分配错误，以及更新保存的数据以传递给自定义动作。</p><p id="974c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们来看看我们的<code class="fe mp mq mr ms b">executing</code>状态，在这里我们必须调用我们的自定义<code class="fe mp mq mr ms b">executor</code>。</p><h1 id="2ac6" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">对状态调用服务操作</h1><p id="e6b6" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在XState中，我们使用<code class="fe mp mq mr ms b">actions</code>来执行上下文更新。我们还可以用它来调用一个自定义操作。然而，如果定制动作是异步的，并且需要根据动作执行状态转换到不同的状态，我们必须创建一个专用的状态来处理这个问题。在我们的对话机中，<code class="fe mp mq mr ms b">executing</code>就是这样一种状态。</p><p id="9e6b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">XState为状态的配置对象提供了一个<code class="fe mp mq mr ms b">invoke</code>属性对象字段，以调用状态中的附加逻辑。一旦对话框处于<code class="fe mp mq mr ms b">executing</code>状态，需要立即用<code class="fe mp mq mr ms b">dataToSubmit</code>触发自定义<code class="fe mp mq mr ms b">executor</code>。在执行状态下，它会将机器重定向回<code class="fe mp mq mr ms b">idle</code>状态(如果错误)或<code class="fe mp mq mr ms b">closed</code>(如果执行成功)。</p><p id="3ed5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们用于对话机的<code class="fe mp mq mr ms b">invoke</code>字段的结构示例:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="f010" class="nq ls it ms b gy nr ns l nt nu">invoke: {<br/>  src: 'executeAction', //the source for the invoking service, can be a string or function<br/>  id: 'execute-dialog', //required identifier for the invoke logic source<br/>  onDone: {}, //transition event object when service action's returned promise resolves<br/>  onError: {} //transition event object when action returned promise rejects<br/>},</span></pre><p id="c2ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">src</code>是我们定义调用逻辑的地方。它可以是一个字符串，表示在创建过程中传递给机器的服务动作的名称，也可以是一个函数方法，它接收<code class="fe mp mq mr ms b">context</code>和<code class="fe mp mq mr ms b">event</code>作为其参数并返回一个<code class="fe mp mq mr ms b">Promise</code>。</p><p id="4d64" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们定义<code class="fe mp mq mr ms b">executeAction</code>如下:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="27ce" class="nq ls it ms b gy nr ns l nt nu">const executeAction = async (context, event) =&gt; {</span><span id="11dc" class="nq ls it ms b gy nv ns l nt nu">  const { dataToSubmit } = context;</span><span id="7d6a" class="nq ls it ms b gy nv ns l nt nu">  return context.executor?.(dataToSubmit);</span><span id="62b7" class="nq ls it ms b gy nv ns l nt nu">}</span></pre><p id="c12c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后将其绑定到<code class="fe mp mq mr ms b">src</code>字段:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="2582" class="nq ls it ms b gy nr ns l nt nu">invoke: {<br/>  src: executeAction, <br/>  id: 'execute-dialog', <br/>  onDone: {}, //transition event object when service action's returned promise resolves<br/>  onError: {} //transition event object when action returned promise rejects<br/>},</span></pre><p id="60b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe mp mq mr ms b">invoke</code>的一个显著好处是，它自动为异步函数提供到<code class="fe mp mq mr ms b">onDone</code>和<code class="fe mp mq mr ms b">onError</code>的绑定。一旦函数解析，机器将触发<code class="fe mp mq mr ms b">onDone</code>转换。否则，它相应地启动<code class="fe mp mq mr ms b">onError</code>。</p><p id="6fbf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">之前，我们为<code class="fe mp mq mr ms b">executing</code>状态定义了<code class="fe mp mq mr ms b">DONE</code>和<code class="fe mp mq mr ms b">RETRY</code>事件。使用<code class="fe mp mq mr ms b">invoke</code>，我们可以将<code class="fe mp mq mr ms b">DONE</code>内的内容分别移动到<code class="fe mp mq mr ms b">onDone</code>内，从<code class="fe mp mq mr ms b">RETRY</code>移动到<code class="fe mp mq mr ms b">onError</code>内，并完全删除<code class="fe mp mq mr ms b">on</code>字段。<code class="fe mp mq mr ms b">executing</code>状态的代码现在变为:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="2572" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是我们的对话机的完整工作代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h1 id="9b1b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">用createMachine的第二个输入参数创建一个可扩展的机器</h1><p id="75d9" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">至此，我们的对话机已经可以使用了。然而，由于某些动作如<code class="fe mp mq mr ms b">clear</code>和<code class="fe mp mq mr ms b">executeAction</code>是本地定义的，如果不直接对原机器进行更改，我们将无法扩展机器并定制这些动作以备将来使用。</p><p id="fc72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">幸运的是，<code class="fe mp mq mr ms b">createMachine</code>接受第二个参数，这是一个包含额外选项的对象，如在机器中使用的标准<code class="fe mp mq mr ms b">services</code>(用于调用服务)、<code class="fe mp mq mr ms b">guards</code>和<code class="fe mp mq mr ms b">actions</code>(用于事件数据操作)。</p><p id="d2b8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将<code class="fe mp mq mr ms b">clear</code>和<code class="fe mp mq mr ms b">executeAction</code>移动到这个对象中它们各自的位置，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="8729" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的机器状态中，我们可以通过传递名称<code class="fe mp mq mr ms b">clear</code>和<code class="fe mp mq mr ms b">executeAction</code>来替换直接函数绑定，XState将处理其余的绑定:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="b306" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。下面是最终的工作代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nw nx l"/></div></figure><p id="badb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您使用的是TypeScript，下面是对话机上下文的数据接口示例:</p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="0a62" class="nq ls it ms b gy nr ns l nt nu">export interface DialogMachineContext {<br/>  Component?: Component | string;<br/>  executor?: (data?: any) =&gt; Promise&lt;any&gt;;<br/>  title?: string;<br/>  confirmBtn?: string;<br/>  cancelBtn?: string;<br/>  dataToSubmit?: any;<br/>  error?: string;<br/>}</span></pre><p id="8b67" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可视化工具生成的整个对话图如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/92ef19ee7b74713381df27f8222f8486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v1WY31y7ijXJSitv"/></div></div></figure><p id="c982" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的对话机现在是完整的和可扩展的。我们可以继续在对话框管理器组件中使用它，或者在React中使用<code class="fe mp mq mr ms b">@xstate/react</code>，或者在Vue中使用<code class="fe mp mq mr ms b">@xstate/vue</code>钩子。</p><h1 id="d17b" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">资源</h1><ul class=""><li id="e50c" class="mw mx it kw b kx mj la mk ld oc lh od ll oe lp nb nc nd ne bi translated"><a class="ae ny" href="https://xstate.js.org/docs" rel="noopener ugc nofollow" target="_blank">x state的API文档在此处</a></li><li id="af4a" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated">【XState的优秀教程</li><li id="2374" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae ny" href="https://github.com/mayashavin/vurian-wizard" rel="noopener ugc nofollow" target="_blank">使用XState和Vue的Vurian组件库项目</a></li><li id="b731" class="mw mx it kw b kx nf la ng ld nh lh ni ll nj lp nb nc nd ne bi translated"><a class="ae ny" href="https://stately.ai/viz" rel="noopener ugc nofollow" target="_blank">状态机可视化工具</a></li></ul><h1 id="0ed3" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">摘要</h1><p id="6fae" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">使用状态机既有趣又具有挑战性。这需要一点学习曲线，并且在你通常处理一个新特性/组件的方式上有很大的改变。</p><p id="52a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要构建一个合适的状态机，您必须提前定义和计划您的组件/特性流，将其模块化，然后编码。我发现它非常有助于组织我的代码和创建一个状态系统来管理我的UI组件，比如对话框。</p><p id="fee3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们知道了如何用XState创建一个对话框管理器，让我们在Vue或React中创建一个可重用的通用对话框组件，以及<code class="fe mp mq mr ms b">dialog</code>元素，好吗？</p><p id="bded" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><em class="lq">最初发表于</em><a class="ae ny" href="https://mayashavin.com/articles/state-management-dialog" rel="noopener ugc nofollow" target="_blank"><em class="lq">https://mayashavin.com</em></a><em class="lq">。</em></p><pre class="kj kk kl km gt nm ms nn no aw np bi"><span id="267d" class="nq ls it ms b gy nr ns l nt nu"><strong class="ms iu">Want to Connect?</strong></span><span id="18f9" class="nq ls it ms b gy nv ns l nt nu">If you’d like to catch up with me sometimes, follow me on <a class="ae ny" href="https://twitter.com/MayaShavin" rel="noopener ugc nofollow" target="_blank">Twitter</a>.</span></pre></div></div>    
</body>
</html>