<html>
<head>
<title>Swift 5.1 Takes Dependency Injection to the Next Level</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift 5.1将依赖注入提升到了一个新的高度</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/taking-swift-dependency-injection-to-the-next-level-b71114c6a9c6?source=collection_archive---------0-----------------------#2019-07-01">https://betterprogramming.pub/taking-swift-dependency-injection-to-the-next-level-b71114c6a9c6?source=collection_archive---------0-----------------------#2019-07-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="57b8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何使用Swift 5.1属性包装器将依赖注入代码减少一半？</h2></div><p id="f8b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Swift 5.1为该语言带来了许多新功能，其中一些有望彻底改变我们编写和构建Swift代码的方式。</p><p id="9b22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将讨论Swift属性包装器，并演示一种可以用来显著简化代码的方法。</p><p id="532f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">更新:以下文章已更新，以反映Swift 5.2中的变化。</em></p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="c8f8" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">一些背景</h2><p id="a295" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">现代软件开发是管理复杂性的一种练习，我们尝试的方法之一是通过架构。反过来，架构实际上只是一个术语，用来描述我们如何将复杂的软件分解成容易理解的层和组件。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mk"><img src="../Images/c69c6edccc80a27451c9b4f6ed624b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPY-fOTBJDIFqahx5TSXSw.png"/></div></div></figure><p id="7153" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们遵循规则，将我们的软件分解成简化的组件，这些组件易于编写，只做一件事(SRP)，并且易于测试。</p><p id="ed9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，一旦我们有了一堆组件，我们就必须将所有的组件重新连接起来，形成一个工作应用程序。数字。</p><p id="2ac8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以正确的方式将事物连接在一起，我们就有了一个由一组松散耦合的组件组成的整洁的结构。</p><p id="123b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果做错了，我们最终会陷入一个紧密耦合的泥沼，其中太多的部分拥有太多关于它们的子组件是如何构造的以及它们如何在内部操作的信息。</p><p id="3a82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得组件共享变得几乎不可能，并且使得从一个组件层交换到另一个组件层变得同样困难。</p><p id="d065" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们有一个第二十二条军规。我们用来简化代码的工具和技术最终会让我们的生活变得更加复杂。</p><p id="247b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">幸运的是，我们可以使用另一种技术来管理这种额外的复杂性，这种技术被称为<a class="ae mw" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank"> <em class="le">依赖注入</em> </a>，它基于一种被称为<a class="ae mw" href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="noopener ugc nofollow" target="_blank"> <em class="le">控制反转</em> </a>的原理。</p><figure class="ml mm mn mo gt mp gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/16d61f2def54b8a98eb1907e5af0cd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRO_zVc-6mgm-0LB8KR5yw.png"/></div></figure><h2 id="6d87" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">依赖注入</h2><p id="29cf" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">对依赖注入的完整和彻底的解释超出了本文的范围，所以让我们假设依赖注入让一个给定的组件请求系统连接到它完成工作所需的所有部分。</p><p id="1632" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那些<em class="le">依赖关系</em>被返回给完全形成并准备使用的组件。</p><p id="f88a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，ViewController可能需要一个视图模型。该视图模型可能需要一个API组件来获取一些数据，这又需要访问我们的身份验证系统和我们当前的会话管理器。ViewModel还需要一个数据转换服务，它有自己的依赖项。</p><p id="8371" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ViewController不关心所有这些，也不应该关心。它只是想与完成工作所需的组件进行对话。</p><p id="4580" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示所涉及的技术，本文将使用一个轻量级但功能强大的Swift依赖注入系统，名为<a class="ae mw" href="https://github.com/hmlongco/Resolver" rel="noopener ugc nofollow" target="_blank"> Resolver </a>。如果你用不同的，不要担心。可以使用任何DI框架。</p><p id="7c02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想了解更多，在Resolver GitHub知识库上有一个<a class="ae mw" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Introduction.md" rel="noopener ugc nofollow" target="_blank">关于依赖注入的简明介绍</a>指南，以及很多关于Resolver本身的文档。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="140f" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">一个简单的例子</h2><p id="5f22" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">使用依赖注入的一个非常基本的视图模型可能如下所示:</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="d223" class="lm ln it mz b gy nd ne l nf ng">class XYZViewModel {</span><span id="b7aa" class="lm ln it mz b gy nh ne l nf ng">    private var fetcher: XYZFetching<br/>    private var service: XYZService</span><span id="908e" class="lm ln it mz b gy nh ne l nf ng">    init(fetcher: XYZFetching, service: XYZService) {<br/>        self.fetcher = fetcher<br/>        self.service = service<br/>    }</span><span id="c346" class="lm ln it mz b gy nh ne l nf ng">    func load() -&gt; Image {<br/>        let data = fetcher.getData(token)<br/>        return service.decompress(data)<br/>   }</span><span id="6d66" class="lm ln it mz b gy nh ne l nf ng">}</span></pre><p id="0e1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">列出了我们的视图模型需要的组件，以及一个初始化函数，其作用基本上是将传递给模型的任何组件分配给模型的实例变量。</p><p id="0fa1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是所谓的<em class="le">构造函数注入</em>，使用它可以确保我们不能实例化一个给定的组件而不给它所需要的一切。</p><p id="b248" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了视图模型，但是视图控制器是如何得到它的呢？</p><p id="7ce1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Resolver可以在几种模式下工作来自动解决这个问题，但这里显示的最简单的方法是使用一种称为服务定位器的模式…它基本上是一些知道如何定位所请求的服务的代码。</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="2819" class="lm ln it mz b gy nd ne l nf ng">class XYZViewController: UIViewController {</span><span id="1cf5" class="lm ln it mz b gy nh ne l nf ng">    private let viewModel: XYZViewModel = Resolver.resolve()</span><span id="04f3" class="lm ln it mz b gy nh ne l nf ng">    override func viewDidLoad() {<br/>       ...<br/>    }</span><span id="cbd7" class="lm ln it mz b gy nh ne l nf ng">}</span></pre><p id="464c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此视图控制器要求解析器“解析”依赖关系。解析器使用提供的类型信息来查找工厂，该工厂用于创建所请求类型的对象的实例。</p><p id="0f3f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们的视图模型需要一个获取器和一个提供给它的服务，但是视图控制器完全忽略了这一事实，让DI系统处理所有这些混乱的小细节。</p><p id="e5b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一些其他的好处。例如，我们可以运行一个“模拟”方案，在这个方案中，我们的数据层被替换为来自应用程序中嵌入的JSON文件的模拟数据。这在开发、调试和测试时非常方便。</p><p id="795a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">依赖系统可以完全在幕后轻松地处理这类事情，我们所有的视图控制器都知道它仍然得到了它需要的视图模型。<a class="ae mw" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Names.md" rel="noopener ugc nofollow" target="_blank">解析器文档显示了一个</a>的例子。</p><p id="cb81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，注意在依赖注入行话中，我们的依赖通常被称为<em class="le">服务</em>。</p><h2 id="c8cb" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">登记</h2><p id="54c9" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">为了让一个典型的依赖注入系统工作，我们的服务必须<em class="le">注册</em>。这意味着我们需要提供一个与系统可能需要创建的每个类型相关联的工厂方法。</p><p id="f5ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在一些系统中，依赖关系是命名的，而在另一些系统中，依赖关系类型是必须指定的。然而，解析器通常可以推断出所需的类型信息。</p><p id="116d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，Resolver中的典型注册块可能如下所示。</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="40dd" class="lm ln it mz b gy nd ne l nf ng">func setupMyRegistrations {<br/>    register { XYZViewModel(fetcher: resolve(), service: resolve()) }<br/>    register { XYZFetcher(session: resolve()) as XYZFetching }<br/>    register { XYZService() }<br/>    register { XYZSessionManager()<br/>}</span></pre><p id="9426" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，第一个<em class="le">寄存器</em>函数注册了我们的<em class="le"> XYZViewModel </em>，并提供了一个工厂函数来创建一个新的实例。注册的类型由工厂的返回类型自动推断。</p><p id="4e22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> XYZViewModel的</em>初始化函数所需的每个参数也通过再次推断类型签名并依次解析它们来解析。</p><p id="b334" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个函数注册了<em class="le">XYZFetcher</em>协议，这是通过构建一个具有自己的依赖关系的<em class="le"> XYZFetcher </em>的实例来实现的。</p><p id="209d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个过程递归地重复，直到所有部分都有了初始化它们自己和做它们需要做的事情所需的所有部分。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="d6b2" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">问题是</h2><p id="f730" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">然而，大多数现实生活中的程序都很复杂，因此我们的初始化函数可能会开始失控。</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="1e99" class="lm ln it mz b gy nd ne l nf ng">class MyViewModel {</span><span id="8541" class="lm ln it mz b gy nh ne l nf ng">var userStateMachine: UserStateMachine<br/>    var keyValueStore: KeyValueStore<br/>    var bundle: BundleProviding<br/>    var touchIdService: TouchIDManaging<br/>    var status: SystemStatusProviding</span><span id="9dbb" class="lm ln it mz b gy nh ne l nf ng">    init(userStateMachine: UserStateMachine,<br/>         bundle: BundleProviding,<br/>         touchID: TouchIDManaging,<br/>         status: SystemStatusProviding,<br/>         keyValueStore: KeyValueStore) {</span><span id="07da" class="lm ln it mz b gy nh ne l nf ng">    self.userStateMachine = userStateMachine<br/>        self.bundle = bundle<br/>        self.touchIdService = touchID<br/>        self.status = status<br/>        self.keyValueStore = keyValueStore<br/>    }</span><span id="927e" class="lm ln it mz b gy nh ne l nf ng">...</span><span id="7eda" class="lm ln it mz b gy nh ne l nf ng">}</span></pre><p id="12e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">初始化函数中有相当多的代码。这是必要的，但所有这一切都是样板。怎么摆脱？</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="6268" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">Swift 5.1和属性包装器</h2><p id="0a28" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">幸运的是，Swift 5.1为我们提供了一个名为property wrappers的新工具，(正式名称为<em class="le">“property delegates”)，</em>作为<a class="ae mw" href="https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md" rel="noopener ugc nofollow" target="_blank">提案SE-0258 </a>的一部分在Swift论坛上发布，并被添加到Swift 5.1和Xcode 11中。</p><p id="2e5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个新特性使属性值能够自动包装在自定义的get/set实现中，因此得名。</p><p id="92e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，您可以在属性值上使用定制的getters和setters来做这些事情，但是缺点是必须在每个属性上编写几乎相同的代码。(更多样板。)如果每个属性都需要某种内部支持变量，情况会变得更糟。(更多样板文件。)</p><h2 id="92bd" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">@Injected属性包装</h2><p id="af68" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">因此，在get/set对中自动包装属性听起来并不令人兴奋，但是属性包装器将对我们的Swift代码产生重大影响。</p><p id="b42c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行演示，我将创建一个名为@Injected的属性包装器，并将其添加到我们的代码库中。(实现将在下一节介绍。)</p><p id="08a1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们回到“失控”的例子，看看我们全新的属性包装器给我们带来了什么。</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="673c" class="lm ln it mz b gy nd ne l nf ng">class MyViewModel {</span><span id="9521" class="lm ln it mz b gy nh ne l nf ng">    @Injected var userStateMachine: UserStateMachine<br/>    @Injected var keyValueStore: KeyValueStore<br/>    @Injected var bundle: BundleProviding<br/>    @Injected var touchIdService: TouchIDManaging<br/>    @Injected var status: SystemStatusProviding</span><span id="baee" class="lm ln it mz b gy nh ne l nf ng">    ...</span><span id="a775" class="lm ln it mz b gy nh ne l nf ng">}</span></pre><p id="32f8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">仅此而已。只需将一个属性标记为@Injected，每个属性都会根据需要自动解析(注入)。</p><p id="b247" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">初始化函数中的所有样板代码都不见了！</p><p id="df6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，从@Injected注释中可以非常清楚地看出依赖注入系统提供了哪些服务。</p><p id="1859" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种特殊类型的注释模式在其他语言中也有使用，特别是在Android上用Kotlin编程和使用<a class="ae mw" href="https://medium.com/@yostane/dependency-injection-with-dagger-2-inject-and-provides-ce21f7449ec5" rel="noopener"> Dagger 2依赖注入</a>框架时。</p><h2 id="2d7d" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">履行</h2><p id="5d23" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">我们的属性包装器实现很简单。我们用服务类型定义了一个通用结构，并将其标记为@propertyWrapper。</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="6788" class="lm ln it mz b gy nd ne l nf ng">@propertyWrapper<br/>struct Injected&lt;Service&gt; {</span><span id="8b18" class="lm ln it mz b gy nh ne l nf ng">    private var service: Service!<br/>    public var container: Resolver?<br/>    public var name: String?</span><span id="48a1" class="lm ln it mz b gy nh ne l nf ng">    public init() {}</span><span id="251c" class="lm ln it mz b gy nh ne l nf ng">    public init(name: String? = nil, container: Resolver? = nil) {<br/>        self.name = name<br/>        self.container = container<br/>    }</span><span id="68b9" class="lm ln it mz b gy nh ne l nf ng">    public var wrappedValue: Service {<br/>        mutating get {<br/>            if self.service == nil {<br/>                self.service = container?.resolve(Service.self, name: name) ?? Resolver.resolve(Service.self, name: name)<br/>            }<br/>            return service<br/>        }<br/>        mutating set { service = newValue  }<br/>    }</span><span id="b1f3" class="lm ln it mz b gy nh ne l nf ng">    public var projectedValue: Injected&lt;Service&gt; {<br/>        get { return self }<br/>        mutating set { self = newValue }<br/>    }<br/>}</span></pre><p id="0e84" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有属性包装器必须实现一个名为<em class="le"> wrappedValue </em>的变量。</p><p id="9277" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当从变量请求值或将值赋给变量时，WrappedValue提供属性包装使用的getter和setter实现。</p><p id="510a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，当我们的服务被请求时，我们的值“getter”将检查这是否是它第一次被调用。如果是这样，当访问时，包装器代码要求解析器基于泛型类型解析所需服务的实例，将结果存储到私有变量中以备后用，并返回服务。</p><p id="54e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还提供了一个setter，用于我们可能需要手动分配服务的时候。这在一些情况下会派上用场，尤其是在进行单元测试的时候。</p><p id="5098" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该实现还公开了一些额外的参数，如名称和容器，稍后会详细介绍。</p><p id="29f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">更新:上述实现从Xcode Beta 6更新，支持Beta 5中对propertyWrapper语法的wrappedValue和projectedValue </em> <em class="le">更改。</em></p><p id="d788" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">更新:通过添加公共初始化器，上述实现也被更改为支持Xcode 11和Resolver的发布版本。</em></p><h2 id="16e1" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">更多示例</h2><p id="500e" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">我们最初的视图控制器代码现在是…</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="2d16" class="lm ln it mz b gy nd ne l nf ng">class XYZViewController: UIViewController {<br/>    @Injected private var viewModel: XYZViewModel<br/>    override func viewDidLoad() {<br/>       ...<br/>    }<br/>}</span></pre><p id="a8cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的视图模型精简到最基本的东西…</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="d7b3" class="lm ln it mz b gy nd ne l nf ng">class XYZViewModel {<br/>    @Injected private var fetcher: XYZFetching<br/>    @Injected private var service: XYZService<br/>    func load() -&gt; Image {<br/>        let data = fetcher.getData(token)<br/>        return service.decompress(data)<br/>   }<br/>}</span></pre><p id="cd2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">甚至我们的注册代码也被简化了，因为构造函数的参数被左放右放…</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="9511" class="lm ln it mz b gy nd ne l nf ng">func setupMyRegistrations {<br/>    register { XYZViewModel() }<br/>    register { XYZFetcher() as XYZFetching }<br/>    register { XYZService() }<br/>    register { XYZSessionManager()<br/>}</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="b69f" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">回复和即时注射</h2><p id="c822" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">上面显示的最初为本文编写的注入代码执行了<em class="le">惰性注入</em>。换句话说，直到包装器的值被第一次访问，服务才被解析。</p><p id="0478" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这适用于许多情况，但在非可变结构(例如SwiftUI)中使用注入时会失败。</p><p id="f2a0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Resolver中，基本注入属性包装器的当前实现如下…</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="07d0" class="lm ln it mz b gy nd ne l nf ng"><a class="ae mw" href="http://twitter.com/propertyWrapper" rel="noopener ugc nofollow" target="_blank">@propertyWrapper</a><br/>public struct Injected&lt;Service&gt; {</span><span id="a0d8" class="lm ln it mz b gy nh ne l nf ng">    private var service: Service</span><span id="158e" class="lm ln it mz b gy nh ne l nf ng">    public init() {<br/>        self.service = Resolver.resolve(Service.self)<br/>    }</span><span id="eea4" class="lm ln it mz b gy nh ne l nf ng">    public init(name: String? = nil, container: Resolver? = nil) {<br/>        self.service = container?.resolve(Service.self, name: name) ?? Resolver.resolve(Service.self, name: name)<br/>    }</span><span id="e664" class="lm ln it mz b gy nh ne l nf ng">    public var wrappedValue: Service {<br/>        get { return service }<br/>        mutating set { service = newValue }<br/>    }</span><span id="4d14" class="lm ln it mz b gy nh ne l nf ng">    public var projectedValue: Injected&lt;Service&gt; {<br/>        get { return self }<br/>        mutating set { self = newValue }<br/>    }</span><span id="bdec" class="lm ln it mz b gy nh ne l nf ng">}</span></pre><p id="f305" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对所需服务的即时解析确保了我们的对象拥有它所需要的一切，并准备好进行初始化。</p><p id="8714" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认为立即注入也支持解析<a class="ae mw" href="https://github.com/hmlongco/Resolver/blob/master/Documentation/Scopes.md#graph" rel="noopener ugc nofollow" target="_blank">依赖图</a>。(图形和范围是高级主题，超出了本文的范围。如果你真的感兴趣，请点击链接。)</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="8046" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">命名服务类型</h2><p id="d9e5" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">解析器支持命名类型，这使得程序能够区分相同类型的服务或协议。</p><p id="b73c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也让我们展示了属性包装器的一个有趣的属性[抱歉]，所以让我们来检查一下。</p><p id="5606" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个常见的用例可能是一个视图控制器，它需要两种不同的视图模型中的一种，这种选择取决于它是否被传递了数据，因此应该在“添加”或“编辑”模式下操作。</p><p id="afc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注册可能如下所示，两个模型都符合XYZViewModel协议或基类。</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="5a94" class="lm ln it mz b gy nd ne l nf ng">func setupMyRegistrations {<br/>    register(name: "add") { NewXYZViewModel() as XYZViewModel }<br/>    register(name: "edit") { EditXYZViewModel() as XYZViewModel }<br/>}</span></pre><p id="cd63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在视图控制器中…</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="74f2" class="lm ln it mz b gy nd ne l nf ng">class XYZViewController: UIViewController {</span><span id="5195" class="lm ln it mz b gy nh ne l nf ng">    @Injected private var viewModel: XYZViewModel</span><span id="c1a4" class="lm ln it mz b gy nh ne l nf ng">    var myData: MyData?</span><span id="1b4a" class="lm ln it mz b gy nh ne l nf ng">    override func viewDidLoad() {<br/>        $viewModel.name = myData == nil ? "add" : "edit"<br/>        viewModel.configure(myData)<br/>        ...<br/>    }<br/>}</span></pre><p id="2258" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意在<em class="le"> viewDidLoad </em>中引用的<em class="le"> $viewModel.name </em>。</p><p id="1f2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在大多数情况下，我们希望Swift假设包装的价值是资产的实际价值。然而，在属性包装器前面加上美元符号可以让我们引用属性包装器<em class="le">本身</em>，这样就可以访问任何可能在它上面公开的公共变量或函数。</p><p id="1554" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，我们设置了<em class="le"> name </em>参数，当我们第一次尝试使用我们的视图模型时，以及当解析器解析我们的依赖关系时，该参数将被传递给解析器。</p><p id="5d47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，当使用$前缀访问属性时，propertyWrapper实现中的<em class="le"> projectedValue </em>为我们提供了所使用(预计)的值。</p><p id="1210" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">长话短说，在属性包装器上使用$前缀让我们可以操纵和/或引用包装器本身。在SwiftUI中你会看到很多这样的东西。</p><p id="b323" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">更新:上面的代码将在最新版本的Resolver中使用新的@LazyInjected属性包装器工作。如前所述，使用Resolver版本的@Injected将立即解决依赖性。</em></p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="dc31" class="lm ln it mz b gy nd ne l nf ng">@LazyInjected private var viewModel: XYZViewModel</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="47f6" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">为什么注射？</h2><p id="1ce6" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">我向一些人展示了这段代码，他们总是问:为什么使用术语<em class="le"> Injected？</em></p><p id="28af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的意思是，既然代码使用了Resolver，为什么不把它标记为@Resolve呢？</p><p id="c786" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理性很简单。我现在用Resolver，主要是因为我写的。但是我可能希望在另一个应用程序中共享或使用我的一些模型或服务代码，而那个应用程序可能使用不同的系统来管理依赖注入。比如说，Swinject故事板。</p><p id="d150" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，Injected变成了一个更中性的术语，我所需要做的就是提供一个新版本的@Injected属性包装器，它使用Swinject作为后端。一旦完成，我就准备好了。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="5df6" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">其他使用案例</h2><p id="fc24" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">我们将会看到属性包装器在Swift中的很多应用。</p><p id="d69c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们提到了依赖注入，SwiftUI广泛使用包装器(@State、@Binding等。)，但是看到Cocoa和UIKit中的标准类提供了一些额外的包装器，我不会感到惊讶。</p><p id="1dbe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想到了关于用户默认值和钥匙串访问的常见包装器。想象一下用…包装任何财产</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="55c4" class="lm ln it mz b gy nd ne l nf ng">@Keychain(key: "username") var username: String?</span></pre><p id="13de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且自动将您的数据存储到钥匙串中以及从钥匙串中获取数据！</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="889a" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">过度的使用</h2><p id="0c87" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">然而，像任何酷的新锤子一样，我们冒着过度使用它的风险，因为每个问题看起来都像钉子。</p><p id="561a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在某一点上，一切都需要一个协议，记得吗？然后我们开始理解协议最适合用在哪里(比如在数据层代码中),于是我们放弃了。单个实现类上的太多协议只会使我们的代码变得混乱，实际上增加了协议和实现之间的耦合，使我们的代码更加僵化，难以更改。</p><p id="75a6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此之前，C++添加了自定义操作符，突然我们试图弄清楚user1 + user2的结果可能是什么？</p><p id="fd3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为使用属性包装器的关键问题是问自己:我会在我所有的代码库中广泛使用包装器吗？如果是这样，那么属性包装器可能是一个很好的选择。</p><p id="96c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者你至少可以考虑最小化它的足迹。如果你要制作一个如上所示的@Keychain包装器，你可以在KeychainManager类的同一个文件中把它实现为fileprivate，这样就避免了在你的代码中到处散布它的诱惑。</p><p id="7322" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">毕竟，现在使用它就像…</p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="5fba" class="lm ln it mz b gy nd ne l nf ng">@Injected var keychain: KeychainManager</span></pre><p id="342d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们<em class="le">不想要的是达到这样一种状态，即每个模型看起来都像是…</em></p><pre class="ml mm mn mo gt my mz na nb aw nc bi"><span id="8a8a" class="lm ln it mz b gy nd ne l nf ng">class MyModel {<br/>    @Injected private var fetcher: XYZFetching<br/>    @Injected private var service: XYZService<br/>    @Error private var error: String<br/>    @Constrain private var myInt: Int<br/>    @Status private var x = 0<br/>    @Status private var y = 0<br/>  }</span></pre><p id="d169" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后让下一个查看代码的开发人员忙不迭地弄清楚每个包装器都做了什么。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h2 id="da89" class="lm ln it bd lo lp lq dn lr ls lt dp lu kr lv lw lx kv ly lz ma kz mb mc md me bi translated">完成块</h2><p id="8fde" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">属性包装器只是Swift 5.1和Xcode 11中引入的众多功能之一，这些功能有望彻底改变我们编写iOS应用程序的方式。</p><p id="f34b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SwiftUI和Combine受到了媒体的广泛关注，但是我认为属性包装器将会极大地减少我们在日常编程中编写的样板代码的数量，特别是在<a class="ae mw" href="https://medium.com/better-programming/swiftui-and-the-uistackview-problem-34381ffaa71f" rel="noopener">我们可以使用 SwiftUI和Combine </a>实际启动<em class="le">之前。</em></p><p id="3f3d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与SwiftUI和Combine不同，属性包装器可以在早期版本的iOS上使用！不仅仅是iOS 13。</p><p id="ddd4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像往常一样，在下面的评论区留下任何问题，如果你喜欢这个作品并想看到更多类似的东西，请给我一两个掌声。</p><p id="a4f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="3db6" class="ni ln it bd lo nj nk nl lr nm nn no lu jz np ka lx kc nq kd ma kf nr kg md ns bi translated">工厂</h1><p id="5210" class="pw-post-body-paragraph ki kj it kk b kl mf ju kn ko mg jx kq kr mh kt ku kv mi kx ky kz mj lb lc ld im bi translated">请注意，截至2022年6月，我推荐使用Factory，这是我新的编译时安全依赖注入系统，也是Resolver的替代品。</p><p id="e94b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在Medium上阅读<a class="ae mw" href="https://medium.com/better-programming/factory-swift-dependency-injection-14da9b2b5d09" rel="noopener">Factory:Swift Dependency Injection</a>，该项目可在GitHub <a class="ae mw" href="https://github.com/hmlongco/Factory" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="62b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要担心，您在这里读到的所有内容在使用Factory时都是一样的。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="8c24" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">本文是</em> <a class="ae mw" href="https://medium.com/p/365ce5038ef7/edit" rel="noopener"> <em class="le">雨燕依赖注入系列</em> </a> <em class="le">的一部分。</em></p></div></div>    
</body>
</html>