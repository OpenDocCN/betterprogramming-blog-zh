<html>
<head>
<title>Retro Programming 1970s, Part 2 — Critical Code Section</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">追溯编程20世纪70年代，第2部分—关键代码部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/retro-programming-1970s-part-2-critical-code-section-9924ad9a09fd?source=collection_archive---------15-----------------------#2022-07-12">https://betterprogramming.pub/retro-programming-1970s-part-2-critical-code-section-9924ad9a09fd?source=collection_archive---------15-----------------------#2022-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="19ab" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">沿着记忆的小路</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1966a75f8743398217bc184077b06ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d9KE_0gYoJEkujA1"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">保罗·基亚布兰多在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="40b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<a class="ae kv" href="https://medium.com/@graeme.t.bentley/software-engineering-1970s-retro-part-1-4951e1afa08c" rel="noopener">的上一篇</a>中，我介绍了我在1970年继承的一个生化实验室自动化系统的背景，以记录、调试系统崩溃并扩展其处理能力。</p><h1 id="63d6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">亲身体验钻头</h1><p id="3112" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">像这样的系统，内存这么小，没有系统或调试工具，实际上是在位级工作。</p><p id="56b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统崩溃后，人们必须使用控制台的拨动开关来检查内存中的单词。我稍微修改了程序代码，留下了“面包屑”,记录了程序各部分的执行顺序。</p><p id="0fbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过拨动开关，我查看了每个子程序中记录的返回地址。</p><h1 id="7100" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">“关键代码段”问题</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/fc74f69ad2eb60b22448ef61e3342d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/0*sHxeqWWpZX1YsNyl.jpg"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated"><strong class="bd mq">说明“临界区”的流程图。图片来自'</strong><a class="ae kv" href="https://en.wikipedia.org/wiki/Critical_section" rel="noopener ugc nofollow" target="_blank"><strong class="bd mq"/></a><strong class="bd mq">'</strong></p></figure><p id="2527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很快就发现崩溃与打印程序有关。现在我不记得是先想到“鸡”还是先想到“蛋”，但它们几乎是同时出现的。</p><p id="604e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了操作员启动的打印之外，还打印了实时日志，因此它们之间存在潜在的冲突。这看起来像是一个经典的“<a class="ae kv" href="https://en.wikipedia.org/wiki/Critical_section" rel="noopener ugc nofollow" target="_blank">关键代码段</a>”问题(谢天谢地，我在去年学过操作系统原理)。</p><h1 id="d1ec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">压断骆驼背的稻草</h1><p id="b239" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">但是像PDP-8这样的老式计算机体系结构的怪癖使诊断变得老套了。在面向堆栈的计算机体系结构之前，子例程调用在入口点存储与子例程代码一致的返回地址。</p><p id="875a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果中断发生时执行在子例程内部，并且中断代码调用相同的子例程，则先前的返回地址被覆盖，并且当中断完成后执行返回时，相同的子例程继续执行，但是返回到错误的地址。QED！</p><h1 id="7b37" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">受保护的代码段解决方案</h1><p id="a3ec" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们做了一些尝试来修补一个信号量/标志，以尝试序列化对共享例程的访问，但是它们导致了实时日志打印的问题。我对中断处理和打印机功能的设计研究得越多，我发现基本的操作设计原则并没有被遵循。</p><h1 id="fdcb" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">类似操作系统的打印处理程序</h1><p id="a0a9" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">根据上述诊断以及未来将打印扩展到第三台(或更多)打印机的需求，对打印处理代码进行了重大重写。每台打印机都在一个控制表中定义，包括指向单个缓冲区的指针，在该缓冲区中存储来自打印请求的文本行。中断例程只是从缓冲区中为中断打印机设备检索下一个要输出的字符。</p><p id="ff54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当容量扩展发生变化时(如第3部分所述)，添加了一个具有并行接口的Centronics打印机，上面的表驱动打印驱动程序很容易修改来处理它。</p><h1 id="6ac7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">一些杂项增强</h1><p id="2cff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">二进制代码纸带的大小和它通过机械阅读器所花费的时间，产生了偶尔堵塞和错误的问题。因此交叉汇编器被修改为输出1K块的二进制代码，并带有校验和。因此，在读取错误后，磁带可以简单地重新定位在前面的块间隙中，并重新开始以继续。</p><p id="c8f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开发过程中，经常将修复程序切换到内存中，因此实现了修改部分的磁带转储，因此如果重新加载了以前的主磁带，则可以在其上加载后续的补丁。</p><p id="c5c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有时候，我甚至通过手工穿孔磁带的某些部分来恢复次要的代码修正补丁(二进制)(啊，那是‘动手’编程的时代)！</p></div><div class="ab cl mr ms hu mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="ij ik il im in"><p id="6fe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本系列的<a class="ae kv" href="https://medium.com/@graeme.t.bentley/retro-programming-1970s-part-3-message-passing-data-processing-e07a5ba2ce8a" rel="noopener">最后一篇文章中，我将描述支持并发数据输入和报告的多处理的主要重写。为了给多批数据释放内存，操作员程序代码段被移动到鼓/盘上进行覆盖加载。</a></p></div></div>    
</body>
</html>