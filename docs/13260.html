<html>
<head>
<title>Introducing Scoped Threads — The New Addition to Rust 1.63.0</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">引入作用域线程——Rust 1 . 63 . 0的新增功能</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/scoped-threads-the-great-addition-of-rust-1-63-0-2a4c1d411c0a?source=collection_archive---------5-----------------------#2022-08-11">https://betterprogramming.pub/scoped-threads-the-great-addition-of-rust-1-63-0-2a4c1d411c0a?source=collection_archive---------5-----------------------#2022-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5fb8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一瞥令人敬畏的更新</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8bba813d9e4aaa568cb20f17caa963c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GbdyTOBfStfaodY6"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">让蟹线横行</p></figure><p id="4b4f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Rust 1.63.0 已经发布，这个版本包含了最近最期待的特性之一。毕竟，<a class="ae lu" href="https://crates.io/crates/crossbeam" rel="noopener ugc nofollow" target="_blank">横梁</a>的这种能力是用这个机箱而不是用标准库在Rust中实现多线程的主要原因之一。让我们看看新的作用域线程允许我们做什么。</p><h1 id="ec72" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们曾经拥有的</h1><p id="3314" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">下面的代码是一个相当基本的多线程实现。这可能是任何并行编程入门练习的一部分。</p><p id="ebd5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们正在读取数字列表，并在两个不同的线程上计算该列表的两个统计数据。最后，我们等待两个结果并打印结果。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">只读并在离开作用域之前加入，这应该是安全的吧？</p></figure><p id="a673" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，如果我们尝试运行这段代码会发生什么呢？我们得到如下所示的两个错误，我们生成的每个线程一个:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="e502" class="mz lw it mv b gy na nb l nc nd">error[E0373]: closure may outlive the current function, but it borrows `numbers`, which is owned by the current function<br/> --&gt; src/main.rs:7:28<br/>  |<br/>7 | std::thread::spawn(|| numbers.iter().sum::&lt;i32&gt;() as f32...);<br/>  |                    ^^ ------- `numbers` is borrowed here<br/>  |                    |<br/>  |                    may outlive borrowed value `numbers`<br/>  |<br/>note: function requires argument type to outlive `'static`<br/> --&gt; src/main.rs:7:9<br/>  |<br/>7 | std::thread::spawn(|| numbers.iter().sum::&lt;i32&gt;() as f32...);<br/>  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^<br/>help: to force the closure to take ownership of `numbers` (and any other referenced variables), use the `move` keyword<br/>  |<br/>7 | std::thread::spawn(move || numbers.iter().sum::&lt;i32&gt;() as ...);</span></pre><p id="b1d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它说用线程调用的闭包可以比我们的引用活得长。它给出了使用<code class="fe ne nf ng mv b">move</code>赋予线程引用的所有权的提示，这样我们就知道它不会因为它而存活。事情是这样的，我们希望在当前范围内继续使用我们的列表，并且我们还希望将它传递给另一个线程。我们可以只使用<code class="fe ne nf ng mv b">Clone</code>,但是我们知道不应该需要它，那么为什么我们不能继续使用借用列表呢？</p><p id="da8d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们没有变异任何东西。而且我们知道，当<code class="fe ne nf ng mv b">numbers</code>还在范围内时，我们正在使用连接。所以，我们知道这是安全的，应该行得通。为什么会这样？因为<code class="fe ne nf ng mv b">std::thread::spawn</code>不知道范围，它假设我们借用的数字列表可能会在线程完成计算之前被丢弃。这就是为什么它需要一个<code class="fe ne nf ng mv b">move</code>或<code class="fe ne nf ng mv b">'static</code>的寿命。然而，现在我们可以用这些知识来生成线程。</p><h1 id="84ab" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">我们现在能做什么</h1><p id="c653" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">随着Rust版本今天的发布和这个特性的稳定，我们现在可以传递一个闭包给<code class="fe ne nf ng mv b">std::thread::scope</code>来运行我们的线程。闭包将接收一个<code class="fe ne nf ng mv b">Scope</code>作为第一个也是唯一的参数。我们可以用它来产生线程，而不是调用<code class="fe ne nf ng mv b">std::thread::spawn</code>。我们产生的这些线程现在会意识到它们的范围。所以，上面的代码应该是这样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="26ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这运行得很好。如您所见，我们将线程的生成和连接移到了新的闭包中，并使用<code class="fe ne nf ng mv b">scope</code>来生成这些线程。现在我们的代码知道线程确实会在这个范围内完成计算，所以它们不会比我们借用的数字活得长，这是一个更大范围的一部分。</p><h1 id="28e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">另一个例子</h1><p id="5e91" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">最后，作为一个额外的我会让你在这里的另一个例子工作代码，这在以前是不可能的。Rust 1.63.0公告中提供了这个例子，你可以在这里阅读详细的<a class="ae lu" href="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="3399" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个例子中，<code class="fe ne nf ng mv b">a</code>可以在两个线程中被借用，就像我们对<code class="fe ne nf ng mv b">numbers</code>所做的那样，不需要编译器询问<code class="fe ne nf ng mv b">'static </code>的生存期，<code class="fe ne nf ng mv b">x</code>也可以被借用，即使是可变的，它们都可以被使用，甚至在<code class="fe ne nf ng mv b">std::thread::scope</code>之后发生变异。甚至不需要连接。这就是我所说的令人敬畏的更新。</p><div class="nh ni gp gr nj nk"><a href="https://github.com/kriogenia/medium/tree/main/scoped_threads" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">中/主克里金处的作用域线程数/中</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">存放我在Medium帖子上使用的示例的存储库——Medium/scoped _ threads位于main kriogenia/medium</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">github.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny ks nk"/></div></div></a></div></div></div>    
</body>
</html>