<html>
<head>
<title>How to Load Third-Party Scripts Dynamically In React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中动态加载第三方脚本</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/loading-third-party-scripts-dynamically-in-reactjs-458c41a7013d?source=collection_archive---------0-----------------------#2020-07-06">https://betterprogramming.pub/loading-third-party-scripts-dynamically-in-reactjs-458c41a7013d?source=collection_archive---------0-----------------------#2020-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4672" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仅在需要时加载您需要的内容</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eea5875227fcd8b2968da39a91195b4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zmjBhAuZ1DWo6sGZR3Z70Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@elmeng?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">戴克</a>在<a class="ae ky" href="https://unsplash.com/collections/8975469/focu%24?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><p id="cbb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发React应用程序时，我们有时不得不依赖第三方库。这些库大多可以通过<a class="ae ky" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npm </a>包获得，但有时需要在我们的HTML内容的<code class="fe lv lw lx ly b">&lt;head&gt;&lt;/head&gt;</code>或<code class="fe lv lw lx ly b">&lt;body&gt;&lt;/body&gt;</code>中放置一个<code class="fe lv lw lx ly b">script</code>标签。</p><p id="411c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于要在整个站点中全局使用的库，将它们放在我们的主<code class="fe lv lw lx ly b">&lt;head&gt;&lt;/head&gt;</code>中是绝对没问题的，但是对于只在一个或几个地方使用的库，将脚本放在我们的应用程序的<code class="fe lv lw lx ly b">&lt;head&gt;&lt;/head&gt;</code>中会增加不必要的页面加载，从而导致更长的加载时间。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="cac1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">那我们该怎么办？</h1><p id="9ad2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">许多解决方案中的一个可以是创建一个函数，我们可以在需要第三方库的页面上调用它，并动态地创建<code class="fe lv lw lx ly b">&lt;script&gt;&lt;/script&gt;</code>标签并将其注入到应用程序的<code class="fe lv lw lx ly b">&lt;body&gt;&lt;/body&gt;</code>中。</p><p id="2050" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们想通过一个脚本集成Google Maps API，并在我们的一个页面上显示地图。让我们看一个例子:</p><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="cd99" class="nh mh it ly b gy ni nj l nk nl">const loadGMaps = (callback) =&gt; {</span><span id="face" class="nh mh it ly b gy nm nj l nk nl">  const existingScript = document.getElementById('<!-- -->googleMaps<!-- -->');</span><span id="2f4e" class="nh mh it ly b gy nm nj l nk nl">  if (!existingScript) {<br/>    const script = document.createElement('script');<br/>    script.src = '<a class="ae ky" href="https://maps.googleapis.com/maps/api/js?key=" rel="noopener ugc nofollow" target="_blank">https://maps.googleapis.com/maps/api/js</a>';</span><span id="f8fb" class="nh mh it ly b gy nm nj l nk nl">    script.id = '<!-- -->googleMaps<!-- -->';<br/>    document.body.appendChild(script);</span><span id="723f" class="nh mh it ly b gy nm nj l nk nl">    script.onload = () =&gt; { <br/>      if (callback) callback();<br/>    };<br/>  }</span><span id="5a81" class="nh mh it ly b gy nm nj l nk nl">  if (existingScript &amp;&amp; callback) callback();<br/>};</span><span id="9fbd" class="nh mh it ly b gy nm nj l nk nl">export default loadGMaps;</span></pre><p id="bdf9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们试着理解我们的函数在做什么。我们首先通过寻找一个<code class="fe lv lw lx ly b">&lt;script&gt;&lt;/script&gt;</code>标签，并将其<code class="fe lv lw lx ly b">id</code>设置为<code class="fe lv lw lx ly b">googleMaps</code>，来检测我们是否已经加载了谷歌地图。如果我们这样做了，我们就停止——因为没有必要加载库两次。</p><p id="f401" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果找不到一个<code class="fe lv lw lx ly b">existingScript</code>；我们动态地创建脚本。我们首先在内存中创建一个空的<code class="fe lv lw lx ly b">&lt;script&gt;&lt;/script&gt;</code>标签作为<code class="fe lv lw lx ly b">script</code>，然后为它的<code class="fe lv lw lx ly b">src</code>和<code class="fe lv lw lx ly b">id</code>分配必要的属性，以便稍后识别脚本。最后，我们将脚本添加到我们的<code class="fe lv lw lx ly b">&lt;body&gt;&lt;/body&gt;</code>标签中来实际加载它。</p><p id="7dbc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们调用<code class="fe lv lw lx ly b">callback()</code>，如果它存在的话，无论是在我们第一次加载脚本时，还是在脚本已经存在的后续调用中。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="0650" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用</h1><pre class="kj kk kl km gt nd ly ne nf aw ng bi"><span id="1d46" class="nh mh it ly b gy ni nj l nk nl">import React, { useEffect, useState } from 'react';<br/>import GoogleMap from '../GoogleMap';<br/>import loadGMaps from '../scripts/loadGMaps.js';</span><span id="4aa7" class="nh mh it ly b gy nm nj l nk nl">const Maps = (props) =&gt; {<br/>  const [loaded, setLoaded] = useState(false);</span><span id="3de3" class="nh mh it ly b gy nm nj l nk nl">  useEffect(() =&gt; {<br/>    <!-- -->loadGMaps<!-- -->(() =&gt; {<br/>      setLoaded(true);<br/>    });<br/>  });</span><span id="3a9f" class="nh mh it ly b gy nm nj l nk nl">  return (<br/>    &lt;div className="maps-component"&gt;<br/>      {<!-- -->loaded<!-- --> ? &lt;GoogleMap /&gt; : ''}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="5a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们的组件开始挂载时，我们将调用我们的库来动态创建并将<code class="fe lv lw lx ly b">&lt;script&gt;&lt;/script&gt;</code>注入到<code class="fe lv lw lx ly b">&lt;body&gt;&lt;/body&gt;</code>中。一旦它被加载并调用了<code class="fe lv lw lx ly b">script.onload</code>函数，我们在这里传递的回调将触发并更新我们组件的<code class="fe lv lw lx ly b">setLoaded</code>值为<code class="fe lv lw lx ly b">true</code>。</p><p id="bfb1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样！不执行是不是太简单了？</p></div></div>    
</body>
</html>