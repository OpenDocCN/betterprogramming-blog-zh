# JWT:JavaScript 最佳实践终极指南

> 原文：<https://betterprogramming.pub/jwt-ultimate-how-to-guide-with-best-practices-in-javascript-f7ba4c48dfbd>

## Node.js 中的 JSON Web Token 从基础到代码示例

![](img/4c2ee1dd0b82c05658fdcb4b2a2bd8d9.png)

作者原创作品。

[JSON Web Token (JWT)](https://jwt.io/) 是一个标准的 [RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519) ，用于交换加密签名的 JSON 数据。这可能是目前 web 上最流行的授权标准，尤其是对于微服务和分布式架构。

作为一名开发人员，当您被要求实现一个现代的 web 应用程序时，您可能需要将其分解成独立的服务。独立服务和分布式架构有很多优点。您需要考虑的一件事是，您的服务如何知道用户被允许使用它们。

![](img/ec670296cd7847a086f876abedc91f88.png)

图片来源:作者

使用有状态会话管理，您的解决方案将是创建一个在系统的所有部分之间共享的用户会话。但是随着分布式系统的发展，共享一个会话可能会很有挑战性。

有状态会话管理的替代方法是传递一个无状态的 JSON Web 令牌，它将代表一个访问令牌或一个身份令牌。它将持有允许您的服务授权其用户的声明，并且它将使用密码学的魔力来确保令牌是可信的并且没有被篡改。

![](img/b14ae7e62a49174b441234bd02c4bb31.png)

图片来源:作者

这样，您的服务不需要共享有状态会话，它们只需要信任提供给它们的令牌。

# 标准会议

如果你像我一样已经有一段时间了，你会知道 web 上的标准方法是使用会话和基于会话的 cookies。

用户将使用他们的凭证登录，服务器将返回一个带有他们的会话 ID 的 cookie。然后，每次请求授权用户时，用户都会发送该 cookie。

如今，这个过程是如此自动化，你几乎不需要写任何代码来支持它，浏览器知道自动发送每个请求的会话 cookie。超级方便。

![](img/55c66558a902ace4d00ea322f68050c7.png)

图片来源:作者

上面的图表应该感觉相当熟悉和简单，这是网站已经做了很长时间。

现代 web 解决方案通常基于多个服务器或多个服务协同工作。如果您希望将会话用于这些目的，这意味着您将需要一些集中式存储，以便您的会话可用于需要授权访问的体系结构的所有部分。

对于一个简单的网站，实现标准的会话管理要容易得多，服务器上的库和浏览器中的 cookie 管理都很好地支持标准的会话管理。

JWT 更难实现，需要一个有经验的团队来做一个架构良好的安全解决方案，即使使用像 [Auth0](https://auth0.com/) 这样的产品。

我不认为经典的会话管理已经死亡。我甚至会一直推荐使用它，直到您能够证明基于您的解决方案的分布式架构需要 JWT。

但是，因为 JWT 是一个具有挑战性和令人兴奋的话题，让我们深入它的复杂性，了解它的优势。

# 什么是 JWT？

JWT 只是一个签名的 JSON，旨在供双方共享。签名用于验证令牌的真实性，以确保 JSON 数据没有被篡改。令牌本身的数据没有加密。

验证用户身份的方法不会因 JWT 而改变。您仍然可以使用用户名和密码(尽管您应该使用更安全的方法，如双因素身份验证或 DID Auth)。区别仅在于如何管理用户授权(如何让您的服务知道用户有权限做某事)。

在服务器上，验证令牌签名并直接访问 JSON 数据，这对于分布式架构来说要简单得多。

在您的 web 应用程序前端，您的代码需要管理令牌如何存储在浏览器中(cookie、会话存储或本地存储)以及它如何随请求传递到服务器(作为授权承载标头)。

![](img/1fa05ff097ca970a22b621561b57fa97.png)

图片来源:作者

如果您比较基于会话的授权和 JWT 的图表，您会注意到原理非常相似。使用 JWT 的主要原因是客户端-服务器通信保持无状态。

JWT 之所以流行，是因为无状态使得设计独立的服务变得更加容易，而不必处理共享的会话管理。然而，无论是亚马逊网络服务、[微软 Azure](https://azure.microsoft.com/es-es/blog/using-sql-azure-for-session-state/) 还是[谷歌云](https://cloud.google.com/go/getting-started/session-handling-with-firestore)，每个云提供商都有管理会话的解决方案。在您自己的服务器上，您可以使用 [Redis](https://redis.com/solutions/use-cases/session-management/) 作为会话存储的共享缓存。

JWT 通常被认为是比通用会话管理更安全的解决方案。然而，我认为这是很有争议的。这两种方法各有优缺点，为了方便用户，您必须做出妥协。

# 使用 axios 的 Node.js 的 jsonwebtoken 库

Node.js 有一个很棒的库，来自 JWT 的 auth 0 guys:[jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken)，直接出现在 [JWT 网页](https://jwt.io/)上。

要创建令牌，您只需拨打:

这个基本调用将使用一个秘密密钥加密 JSON 数据，这个秘密密钥通常存储为一个环境变量。没有其他参数，这是一个同步调用，将使用对称加密 HS256 (HMAC 与 SHA-256)。

生成的令牌可能如下所示:

```
*eyJhbGciOfJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkaWWiOiJka…afyMH0.WrIEBW5LNLjfGWqIA4XKsyIiuWzbIIpNadfZVkmA6hPs*
```

令牌只是 Base64 代码，解码后看起来像这样:

```
{"alg":"HS256","typ":"JWT"}{"id":"fo:%sk@lr"}�k��c~¶.�S��K�`ѱ
```

您在末尾看到的随机字符是允许您验证令牌真实性的签名，但是您添加的数据和声明不会被加密，除非您对它们进行加密，如您所见。

将这个令牌作为服务器响应的一部分返回给前端应用程序。

然后，前端应用程序需要将令牌添加到每个需要授权的请求的标头中。使用 [axios](https://www.npmjs.com/package/axios) 库时，这样的调用可能是这样的:

注意授权头，这是我们添加令牌的地方。

然后，我们在服务器端验证令牌并访问其秘密:

这就是它的神奇之处。有了这些信息，你应该能够制定一个可行的解决方案。

但是，对于您的实现，也有一些您应该考虑的事项。

HS512 的完整实施如下所示:

# Node.js 中的 jose 库示例

对于 JWT 来说，更好的 Node.js 库是 jose。

它使用起来有点复杂，但它支持使用 JWK，或 JWE，以及与 EdDSA 签约，所以我会向您推荐它作为一个选项。

这是一个使用带有 EdDSA 的库并导入 PEM 私有和公共密钥的示例(还要注意 EdDSA 密钥有多短，尽管提供了更好的保护):

# 在 JWT 代币中存储什么？

在我们的场景中，JWT 代表一个身份令牌，它应该持有关于主体(用户)的声明。这意味着令牌包含用户标识符，比如:`{ "sub": "awWF#$512" }`。

根据您的应用程序，令牌还可以包含能力声明，例如，表明主题可以访问您系统的某些服务。

您当然可以在 cookie 中存储其他信息，包括用户的电子邮件等等。但是，考虑一下您的服务真正需要什么样的用户信息，以及您在令牌中存储了什么，假设这些信息没有加密。用户标识符(主题权利要求)通常就足够了。

如果您使用 JWT 作为身份令牌，那么最重要的声明就是主题，因为您可以使用它来标识服务中的用户。

如果您使用 JWT 作为访问令牌，那么您使用了一个声明，即该令牌的持有者被授权使用系统的某个部分。您可以使用受众声明来实现这一点，受众声明可以是单个 uri 或字符串记录，也可以是它们的数组。消费该令牌的服务然后可以验证它是在 JWT 中收听的观众之一。

JWT RFC 7519 还建议在有效载荷中存储许多其他信息。这些可选索赔包括:

*   **iss** :发卡行字符串或 URI，
    例如:`"iss": "https://didauth.meet-martin.com"`
*   **sub** :主题标识符字符串或 URI，
    例如:`"sub": "OCfs425k"`
*   **aud** :观众字符串或者 URI，或者这些的数组，
    例如:`"aud": "https://api.meet-martin.com"`
*   **exp** ，到期时间，超过该时间后令牌按 NumericDate 无效，
    例如:`"exp": "1630983721"`
*   **nbf** ，not before 标识在此之前令牌不能被接受的数字日期，
    例如:`"nbf": "1630983612"`
*   **iat** ，issue at 包含令牌发布时的 NumbericDate，
    例如:`"iat": "163983612"`
*   **jti** ，JWT，持有 JWT 的唯一标识符作为区分大小写的字符串，
    例如:`"jti": "fsg1R34"`

请记住，除非您自己提供额外的加密，否则这些声明都不会加密。如果你需要传输敏感数据，看看 JWE 标准。

Base 64 解码的令牌如下所示:

```
{"alg":"ES512","typ":"JWT"}{"iss":"[https://domain.tld](https://domain.tld)","sub":"martin@mail.tld","aud":"[https://domain.tld](https://domain.tld)","exp":1630986887,"nbf":1630983287,"jti":"asfasgsadg","iat":1630983287}☺ɱ��%�§�∟x��8�k��c~¶.�S��K�`ѱ���♣��►C∟�8����ϖ↔C�x�����<����c♫♥���q/W�
� �♂t�↑V�0�☼�4��
�hG��Z��‼u�     �oU▬Q[L�hʒ‼�(♀�H
```

# 在浏览器中哪里存储 JWT 令牌？

你有三个选择。你要么使用 cookies，web 存储，要么在内存中。最常用的选项似乎是本地存储。

## 饼干里的 JWT

Cookies 的优点是它们会自动与每个请求一起发送，因此您不需要处理授权头。

Cookies 仍然容易受到跨站点请求伪造(CSRF)攻击，因此您还应该实现 CSRF 令牌。CSRF 令牌是作为 cookie 随每个请求一起发送的随机字符串，并且它对于每个请求是不同的。

您还应该使用`httpOnly`标志使 cookie 只在服务器端可用。JavaScript `document.cookie` API 无法访问具有`HttpOnly`属性的 cookie 它只发送到服务器。

带有`Secure`属性的 cookie 仅通过 HTTPS 协议与加密请求一起发送到服务器(但是，仅在本地主机上，您仍然可以使用 HTTP)。

这是 Nodej.js 中 Express 的一个示例实现:

在 Express 中，您可以使用 [csurf 中间件](https://www.npmjs.com/package/csurf)，它会为您处理 CSRF 令牌。 [express-session](https://www.npmjs.com/package/express-session) 使用默认为`httpOnly`的 cookies，但是您需要通过一个参数使它们成为`secure`，正如您在代码中看到的。

## web 存储中的 JWT:本地存储与会话存储

这两者的区别在于本地存储更加持久。当用户关闭网站窗口时，会话存储被清除。必须显式删除本地存储数据。

与 cookies 不同，本地存储被沙盒化到特定的域中，其数据不能被任何其他域(包括子域)访问。但是请记住，你仍然容易受到跨站脚本(XSS)。cookie 和 web 存储解决方案都容易受到 XSS 的攻击。

本地存储在 JWT 实施中使用最多。然而，会话存储在这里是更安全的选择。

使用 localStorage 时，JWT 不会随每个请求自动传递，您需要自己通过授权头将其传递给服务器。

## 记忆中的 JWT

这里最安全的解决方案是将 JWT 存储在单页应用程序的内存中。这意味着您最终将令牌存储在 JavaScript 的一个变量中，而没有额外的持久性。

这有一些限制。您不能实现单点登录(SSO ),浏览器中的每个选项卡或打开的窗口都需要自己的登录，因为 JavaScript 内存不是共享的。但是，共享问题可以通过使用刷新令牌来解决。

当然，像所有其他解决方案一样，这种解决方案仍然容易受到跨站点脚本的攻击。

您需要使用授权头为每个请求传递 JWT，就像前面代码示例中的 web 存储一样。

# 刷新令牌

您的应用程序设计应该包括刷新令牌的提供。

JWT 代表一个短暂的访问令牌。这里的“短寿命”通常是指 5 分钟到 24 小时或几天，具体取决于您的应用。

刷新令牌是长期存在的，并且代表了一种用于静默认证的机制，以在没有任何用户动作的情况下获得新的访问令牌。长期存在的时间长短取决于用户的便利性，或者您希望用户在两次使用您的服务之间保持身份验证的时间长短。例如，如果您希望您的用户在两周未使用网站后访问您的网站，并且仍然发现他们已经过身份验证，那么两周就是您的刷新令牌到期日期。

您的刷新令牌续订策略还取决于您的到期日期。

例如，您可以设计您的系统来提供一个 24 小时过期时间的访问令牌。您还需要提供一个有 2 周过期时间的刷新令牌。但是，每次更新访问令牌时，您还需要提供一个新的刷新令牌。

您可能还希望在令牌中存储它的创建时间(`iat`)，以便可以使用该信息在所有旧令牌的原始到期时间之前集中使其失效。

刷新令牌通常只保存一个不透明的标识符，它或者存储为一个`httpOnly`、`secure` cookie，或者存储在 web 存储器中(如果您按照前面的建议将访问令牌存储在内存中，这两种方式都可以使您的网站在多个打开的标签中工作)。

# 如何使用 JWT 访问令牌注销用户？

用户可以在多个设备上登录，这意味着一个用户将拥有多个访问令牌和刷新令牌。这些东西中的任何一个都可能被一个邪恶的黑客所拥有。

您应该在数据库中单独存储注销操作，并使用它来使所有刷新令牌失效。

通常，我们依靠 JWT 到期，但 JWT 和刷新令牌可能会因其`id` ( `jti`)而失效。

一个简单的解决方案是在您的数据库中存储注销时间，并将该日期(`iat`)之前创建的所有 JWT 和刷新令牌视为无效。

在您的浏览器应用程序端，您应该简单地将 JWT 从其存储器(web 存储器或内存)中移除。

# 您应该使用什么加密？

JWT 加密最常用的算法是 HMAC 和 RSA。还支持其他算法，包括 RSASSA-PKCS 算法、RSASSA-PSS 算法和 ECDSA 算法。默认的是 HMAC，最流行的是 RSA，最安全的是 ECDSA。

## HMAC

最简单和最不安全的选择是 HS256，这是 HMAC 与 SHA-256。这是一种对称算法，这意味着一个秘密用于签名和验证令牌。一个秘密的例子是:`Much$3cr3tS0S3cureVerySafe`。

在这种情况下，身份验证服务以及所有需要授权的服务都需要访问同一个密钥，这就为通过 API 漏洞窃取密钥提供了更多的机会。

通常不建议在生产中使用。尽管如此，演示应用程序或代码示例更容易。

## 南非共和国(Republic of South Africa)

对于 JWT，您的另一个选择是使用 RS 256(SHA-256 RSA ),这是一种使用私钥和公钥的不对称加密算法。它也可能是 web 应用程序最常用的算法，因为许多开发人员都熟悉它，尽管它不是最安全或性能最好的选项。

身份验证服务使用私钥来生成原始令牌。然后，其他服务使用公钥来验证令牌。如果公钥被泄露，它可以用于读取数据，但不能用于创建其他令牌。建议在 HMAC 上使用 RSA。

公钥也可以对其他第三方消费者公开，这样任何人都可以使用它来访问令牌中的数据，并验证这些数据确实来自您，因为它们是由您的私钥签名的。

您可以通过`openssl`生成您的 RSA 公钥和私钥:

## ECDSA

使用`jsonwebtoken`节点库时，你的最佳选择是 ES512，这是一种使用 P-521 曲线和 SHA-512 哈希算法的椭圆曲线数字签名算法( [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) )。ECDSA 也被比特币使用。ECDSA 是另一种类似 RSA 的非对称加密，被认为是更安全的选择。

> 椭圆曲线加密(ECC)比 RSA 更难破解(或者也许我们真的很擅长破解 RSA)。因此，ECDSA 可以使用比 RSA 短得多的密钥和短得多的签名。大约 256 位的短椭圆曲线(EC)密钥提供了与 3072 位 RSA 密钥相同的安全性。
> -[https://www . Scott Brady 91 . com/JOSE/JWTs-Which-Signing-Algorithm-Should-I-Use](https://www.scottbrady91.com/JOSE/JWTs-Which-Signing-Algorithm-Should-I-Use)

这里的方法与 RSA 相同。作为身份验证的一部分，使用您的私钥对令牌进行签名，并在您的服务中使用公钥。

您可以通过`openssl`生成您的 ECDSA ES512 公钥和私钥:

美国商务部国家标准与技术研究所(NIST)已将 ECDSA 纳入 FIPS 186–4 数字签名标准(DSS):[https://csrc.nist.gov/publications/detail/fips/186/4/final](https://csrc.nist.gov/publications/detail/fips/186/4/final)

## 埃德萨

如果您使用`jose`节点库，您还将获得 Edwards-curve 数字签名算法( [EdDSA](https://en.wikipedia.org/wiki/EdDSA) )加密算法，这是 JWT 实现的[最终最佳选择。它使用 SHA-512 和曲线 25519 给出了 Ed25519 方法。](https://crypto.stackexchange.com/questions/60383/what-is-the-difference-between-ecdsa-and-eddsa)

正如您所猜测的，EdDSA 是一种使用公钥和私钥的非对称算法，因此其用途与 RSA 或 ECDSA 相同。EdDSA 比 ECDSA 具有更好的性能和更短的密钥，同时提供更好的安全性。

您可以通过`openssl`生成您的 EdDSA ed25519 公钥和私钥:

美国商务部国家标准与技术研究院(NIST)已将 EdDSA 纳入 FIPS 186–5 数字签名标准(DSS)草案:[https://csrc.nist.gov/publications/detail/fips/186/5/draft](https://csrc.nist.gov/publications/detail/fips/186/5/draft)

FIPS 186–5 自 2019 年 10 月以来一直处于草案状态，但尚未成为 2021 年 11 月发布的标准。

但是，如果美国 NIST 不是您所关心的，那么 EdDSA 是您目前可以用于 JWT 签名的最安全和性能最好的选项。

## 签名加密结论

在您的应用程序中，尝试使用 EdDSA。如果不可能，那么使用 ES512。使用像 HMAC 这样的对称算法应该是你最后的选择。

为了比较密钥长度，运行示例`openssl`代码，RSA 私钥是 1674 个字符，es512 是 308 个字符，而 ed25519 只有 64 个字符。

在身份验证服务中使用私钥，在其他服务中使用公钥。为了增加安全性，还可以考虑密钥轮换。一段时间后生成新的密钥。

不要将加密密钥直接保存在代码中，或者保存在像 git 这样的代码版本控制系统中。您应该使用密钥管理系统或环境变量。

# 摘要:十大 JWT 建议

![](img/3394e827c818635e53de7e8fcd67d94d.png)

图片来源:作者

*   在 JWT 之前，您还需要考虑使您的身份验证过程安全。对您的用户或分散标识符使用双因素身份验证。只有用户名和密码不被认为是安全的解决方案。
*   如果你正在建立一个标准的前端/后端网站，使用标准的会话管理。如果您正在构建带有服务的分布式系统，请实现 JWT 授权。
*   通过使用非对称加密算法的私钥签署 JWT 来创建访问令牌。对`jsonwebtoken` NPM 图书馆使用 ES512，对`jose` NPM 图书馆使用 Ed25519。
*   使用`sub`主题声明存储用户 ID，但除非必要，否则不要保存其他用户数据，因为存储在 JWT 中的所有内容都可以直接读取。数据没有加密。
*   创建具有长期过期日期的刷新令牌。
*   在前端，将访问令牌存储在客户端 JavaScript 应用程序的内存中，并将刷新令牌存储在 web 商店中。
*   将 JWT 访问令牌作为 HTTP 标头中的载体与每个需要授权的服务器请求一起发送。
*   使用公钥(对您的服务公开)验证服务器上的 JWT。根据存储在 JWT 主题中的用户 ID 从数据库中加载用户数据。
*   当访问令牌过期时，使用刷新令牌再次对用户进行静默身份验证。
*   通过使用刷新令牌提供新的访问令牌和新的刷新令牌来执行静默认证。
*   通过使连接到用户 ID 的所有访问令牌和请求令牌无效，将用户从所有设备注销。

# 结论

当您实现 JWT 逻辑时，您的解决方案决策应该考虑最佳实践、安全性以及用户便利性。

希望我已经包含了你可能需要的所有必要信息。