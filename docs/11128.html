<html>
<head>
<title>Common Goroutine Leaks that You Should Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您应该避免的常见Goroutine泄漏</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/common-goroutine-leaks-that-you-should-avoid-fe12d12d6ee?source=collection_archive---------1-----------------------#2022-02-21">https://betterprogramming.pub/common-goroutine-leaks-that-you-should-avoid-fe12d12d6ee?source=collection_archive---------1-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cbf0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">永远不要在不知道它将如何停止的情况下开始一场战争。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a91df99881470a12ce4ca3a9653f0163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J5Tfijd26oaLUQMu056QGg.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">路易斯·金特罗在<a class="ae ky" href="https://www.pexels.com/photo/photo-of-gray-faucet-2339722/" rel="noopener ugc nofollow" target="_blank">的照片</a></p></figure><p id="1cd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用Go编写的最大好处之一是能够在轻量级线程中并发运行代码，也就是Goroutines。</p><p id="1218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，权力越大，责任越大。</p><p id="bb46" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然很方便，但Goroutines很容易引入错误，如果不小心处理，这些错误几乎不可追踪。</p><p id="2088" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Goroutine泄露</strong>就是其中之一。它在后台悄悄生长，最终可能在你不知情的情况下削弱你的应用程序。</p><p id="39d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这篇文章是关于什么是Goroutine泄漏以及如何防止泄漏的。</p><p id="405d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们开门见山吧！</p><h1 id="827e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">什么是Goroutine泄漏？</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/d245c8710645d4b9251ec969746e86fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*epSl86BjYn9Vt4r_cat14w.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://wallpaperaccess.com/plumber#google_vignette" rel="noopener ugc nofollow" target="_blank">壁纸获取</a></p></figure><p id="3d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建一个新的Goroutine时，计算机在堆中分配内存，并在执行完成后释放它们。</p><p id="ba00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Goroutine泄漏是一种内存泄漏，发生在Goroutine没有被终止，并且在应用程序的生命周期内一直挂在后台的时候。</p><p id="ad0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看一个简单的例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="59a3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理程序返回时，Goroutine继续生活在后台，阻塞并等待数据通过通道发送——这是永远不会发生的。</p><p id="c7b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，引入了Goroutine泄漏。</p><p id="e1c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我将带您了解两种很容易导致Goroutine泄漏的常见模式</p><ul class=""><li id="412e" class="mq mr it lb b lc ld lf lg li ms lm mt lq mu lu mv mw mx my bi translated">被遗忘的发送者</li><li id="c62e" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated">被遗弃的接收者</li></ul><p id="5133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Jacob Walker在他的文章<a class="ae ky" href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html" rel="noopener ugc nofollow" target="_blank">中非常好地解释了这些模式，我推荐你去看看。在这篇文章中，我将用更多的例子来重申它们。</a></p><p id="ab07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们开始吧！</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="7431" class="lv lw it bd lx ly nl ma mb mc nm me mf jz nn ka mh kc no kd mj kf np kg ml mm bi translated">1.0被遗忘的发送者</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nq"><img src="../Images/8ee52ff3ec08d3daecdf18ebb3d63779.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1pmtdtpIk63ShfOfbqzz7Q.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@enginakyurt" rel="noopener ugc nofollow" target="_blank"> Engin Akyurt </a>在<a class="ae ky" href="https://www.pexels.com/photo/person-sitting-outdoors-3368246/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄</p></figure><p id="9f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当发送方由于没有接收方在通道的另一端等待接收数据而被阻塞时，就会出现被遗忘的发送方。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="c717" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然乍一看这似乎微不足道，但在以下两个场景中很容易被忽略。</p><h2 id="da2a" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">上下文使用不当</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="d713" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们模拟了一个标准的web服务处理程序。</p><p id="8996" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们定义了一个在10ms后发出超时的上下文，然后是一个异步发出网络调用的Goroutine。</p><p id="2833" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe od oe of og b">select</code>语句等待多通道操作。它一直阻塞，直到<strong class="lb iu">它的一个</strong>案例可以运行并执行该案例。</p><p id="ec66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果在网络调用完成之前超时，那么<code class="fe od oe of og b">case &lt;- ctx.Done()</code>将运行，处理程序将返回一个错误。</p><p id="5a06" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当处理程序返回时，不再有任何接收者等待接收数据。<code class="fe od oe of og b">forgottenSender</code>将被阻塞，等待有人接收数据，这永远不会发生！</p><p id="f61d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个漏洞。</p><h2 id="252f" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">错误检查后接收器的放置</h2><p id="68ed" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">这是另一个典型的场景。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="abcf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，我们定义了一个处理程序，并生成了一个新的Goroutine来异步进行网络调用。</p><p id="f4ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在等待调用返回的同时，我们继续其他验证逻辑。</p><p id="3de0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，当<code class="fe od oe of og b">continueToValidateOtherData</code>返回一个导致处理程序返回的错误时，就会发生泄漏。</p><p id="dd3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有人在等待接收数据，forgottenSender将被永远阻止！</p><h2 id="4bc3" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">解决方案:被遗忘的发送者</h2><p id="3b23" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated"><strong class="lb iu">使用缓冲通道。</strong></p><p id="1966" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你回想一下，被遗忘的发送者是因为对方没有接收者。阻塞问题的罪魁祸首是无缓冲通道！</p><p id="94ff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无缓冲通道是一种一旦消息发出就需要接收者的通道，否则发送者将被阻塞。它是在没有给通道分配容量的情况下声明的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="b861" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过向通道添加特定的容量，在本例中为<code class="fe od oe of og b">1</code>，我们将缓解所有提到的问题。</p><p id="293b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">发送方可以在不需要接收方的情况下将数据注入信道。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="2bea" class="lv lw it bd lx ly nl ma mb mc nm me mf jz nn ka mh kc no kd mj kf np kg ml mm bi translated">2.0被放弃的接收者</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi om"><img src="../Images/ae9964d6f215985735160d996f275e05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxMEXG3XqnGyV7QG1ipjxw.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://www.pexels.com/@jeswin" rel="noopener ugc nofollow" target="_blank">杰斯温·托马斯</a>在<a class="ae ky" href="https://www.pexels.com/photo/person-sitting-on-bench-under-tree-1280162/" rel="noopener ugc nofollow" target="_blank">像素</a>上拍摄的照片</p></figure><p id="acac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顾名思义，被抛弃的接收者是完全相反的。</p><p id="013f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当接收方由于另一端没有发送方发送数据而被阻塞时，就会发生这种情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="0a15" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为没有发送者发送数据，所以线路3永远被阻塞。</p><p id="2d04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看两个经常被忽略的常见场景。</p><h2 id="a7d6" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">发送方未关闭通道</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="7623" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，处理程序接收一段字符串，创建一个通道，并将数据插入到通道中。</p><p id="2d8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，处理程序通过一个Goroutine产生一个工人。工作进程被期望处理数据，并且一旦通道中的所有数据被处理完就终止。</p><p id="01d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，即使所有的数据都被消耗和处理，工人也永远不会到达<code class="fe od oe of og b">line 6</code>！</p><p id="aefc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通道虽然空了，但它没有关闭！工人继续认为将来可能会有<strong class="lb iu">传入数据</strong>。因此，它永远坐着等待。</p><p id="f501" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是Goroutine再次泄漏的地方。</p><h2 id="0a09" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">错误检查后发送方的位置</h2><p id="dcd9" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">这非常类似于我们之前的一个例子。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="04e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的例子中，处理程序首先生成一个Goroutine worker来处理和使用一些数据。</p><p id="632a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，处理程序从数据库中查询记录，然后将记录注入通道供工作人员使用。</p><p id="d33c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果数据库出错，处理程序会立即返回。将不再有任何发送方向通道传递数据。</p><p id="f61a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，工人被遗弃了。</p><h2 id="9497" class="nr lw it bd lx ns nt dn mb nu nv dp mf li nw nx mh lm ny nz mj lq oa ob ml oc bi translated">解决方案:被放弃的接收者</h2><p id="8144" class="pw-post-body-paragraph kz la it lb b lc oh ju le lf oi jx lh li oj lk ll lm ok lo lp lq ol ls lt lu im bi translated">在这两种情况下，接收器都处于挂起状态，因为它们“认为”会有来自通道的输入数据。因此，他们永远阻塞和等待。</p><p id="f6a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">解决方案是一个简单的一行程序。</p><pre class="kj kk kl km gt on og oo op aw oq bi"><span id="c51b" class="nr lw it og b gy or os l ot ou">defer close(ch)</span></pre><p id="cf89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你产生一个新的通道时，推迟通道的关闭总是一个好的做法。</p><p id="67b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它确保当数据发送完成或函数退出时通道关闭。</p><p id="9d12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接收器可以判断通道是否关闭，并相应地终止。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mo mp l"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="026b" class="lv lw it bd lx ly nl ma mb mc nm me mf jz nn ka mh kc no kd mj kf np kg ml mm bi translated">结论</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/72dd33166149dae362c883058b43cdc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJKwzbUt7iao7L7O_1RYmQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/shallow-focus-photography-of-luigi-plastic-figure-209679/" rel="noopener ugc nofollow" target="_blank">像素</a>上的<a class="ae ky" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="959f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是关于Goroutine泄漏！</p><p id="ebca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然它不像其他Goroutine错误那样强大，但这种泄漏仍然会极大地消耗应用程序的内存。</p><p id="fd24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">记住，权力越大，责任越大。</p><p id="c647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">保护我们的应用程序免受bug的责任在你和我——开发人员身上！</p><p id="b4ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回头见，再见！</p><h1 id="1164" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">参考</h1><ul class=""><li id="a49a" class="mq mr it lb b lc oh lf oi li ow lm ox lq oy lu mv mw mx my bi translated"><a class="ae ky" href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html" rel="noopener ugc nofollow" target="_blank">雅各布·沃克的《戈罗廷泄密——被遗忘的寄信人》</a></li><li id="b4b9" class="mq mr it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="https://www.ardanlabs.com/blog/2018/12/goroutine-leaks-the-abandoned-receivers.html" rel="noopener ugc nofollow" target="_blank">雅各布·沃克的《戈鲁廷泄密——被遗弃的接收者》</a></li></ul></div></div>    
</body>
</html>