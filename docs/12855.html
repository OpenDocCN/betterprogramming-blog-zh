<html>
<head>
<title>The Concept of Triple CCC: Currying, Closure, Callback in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">三重CCC的概念:JavaScript中的Currying、闭包、回调</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-concept-of-triple-ccc-currying-closure-callback-in-javascript-47da06df9bb4?source=collection_archive---------18-----------------------#2022-07-06">https://betterprogramming.pub/the-concept-of-triple-ccc-currying-closure-callback-in-javascript-47da06df9bb4?source=collection_archive---------18-----------------------#2022-07-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f8c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解这些概念可以帮助你在面试中脱颖而出</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/54fd85746d0ac670ec4cfee74815330b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ifYb3jjDhDWXvfDS5zO5AQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@goshua13?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·阿拉贡</a>在<a class="ae ky" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="0dfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JavaScript是一种编程语言，用于前端和后端来构建交互式web应用程序。它是浏览器唯一能理解的脚本语言。迄今为止，几乎98%的网站在客户端使用这种语言来处理网页行为。它是世界上最流行的编程语言。</p><p id="8d60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这门语言的旅程并不顺利。这种语言由<code class="fe lv lw lx ly b">Brendan Eich</code>设计，于1995年12月4日首次出现。最初，它只是用来给网页带来交互性，而HTML和CSS是用来构建和设计网页的。</p><p id="6581" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当<code class="fe lv lw lx ly b">Ryan Dahl</code>在2010年首次引入NodeJS时，改变游戏规则的时刻发生了。它只不过是一个开源的、跨平台的后端JavaScript运行时环境，运行在V8引擎上，在web浏览器之外执行JavaScript代码。</p><p id="0d3d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从那时起，这种语言被广泛使用。在2022年，学习这种令人惊叹的语言是值得的，以便在Web开发领域建立强大的职业生涯。为了让你的学习之旅更加顺利，也为了夯实你的基础，今天，我将讨论JavaScript的概念，它们是Currying、Closure和Callback (CCC)。</p><p id="d7a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管你现在在哪个位置！如果你想成为一名优秀的JavaScript开发人员，那么你需要对这些主题有一个坚实的理解。此外，这将有助于你破解面试问题，因为大多数时候面试官会问一些关于这些话题的常见问题。在本教程结束时，您将对JavaScript中的Currying、Closure和Callback有一个清晰的理解。</p><h1 id="4ac0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">您将从本教程中学到的东西</h1><p id="ba52" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">我们将在本教程中讨论以下主题:</p><ul class=""><li id="322d" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">充当一等公民</li><li id="eeb9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">Currying</li><li id="4736" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">关闭</li><li id="e9a9" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">回收</li></ul><h1 id="d6c8" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">充当一等公民</h1><p id="7f70" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在了解CCC的概念之前，你需要理解一等公民的概念。在JavaScript中，函数被称为一等公民有以下三个原因</p><ul class=""><li id="2a77" class="mw mx it lb b lc ld lf lg li my lm mz lq na lu nb nc nd ne bi translated">一个函数可以被赋值给一个变量</li><li id="da92" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">一个函数可以作为参数传递给其他函数</li><li id="4110" class="mw mx it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">一个函数可以由另一个函数返回</li></ul><p id="5ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们来看一些代码片段，它们展示了JavaScript中的函数如何满足上述三个原因</p><h1 id="e8b0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">一个函数可以被赋值给一个变量</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="87e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，你可以看到我们已经声明了一个箭头函数，稍后，我们将它存储到一个名为<code class="fe lv lw lx ly b">myFunc</code>的变量中。</p><h1 id="2643" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">一个函数可以作为参数传递给其他函数</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ca8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在接受一个函数参数，而不是在函数<code class="fe lv lw lx ly b">myFunc</code>中硬编码“Hello”。正如你所看到的，有三个不同的函数<code class="fe lv lw lx ly b">hello</code>、<code class="fe lv lw lx ly b">bonjour</code>和<code class="fe lv lw lx ly b">salut</code>，它们中的每一个都作为参数传递给<code class="fe lv lw lx ly b">myFunc</code></p><h1 id="8535" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">一个函数可以由另一个函数返回</h1><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c341" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们有一个名为<code class="fe lv lw lx ly b">outerFunc</code>的函数。它没有做太多事情，只是简单地向控制台打印一条语句。内部创建了另一个名为<code class="fe lv lw lx ly b">innerFunc</code>的函数。<code class="fe lv lw lx ly b">innerFunc</code>也做不了什么，它只是向控制台打印一条语句。<code class="fe lv lw lx ly b">outerFunc</code>返回<code class="fe lv lw lx ly b">innerFunc</code>。</p><p id="e9bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有几种方法可以使用它。第一种方法是一起使用两个大括号。第一对括号调用<code class="fe lv lw lx ly b">outerFunc</code>，第二对括号调用<code class="fe lv lw lx ly b">outerFunc</code>返回的对象，即函数<code class="fe lv lw lx ly b">innerFunc</code>。</p><p id="1eaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在第二种方法中，我们将返回的函数存储在一个变量中，并像普通函数一样调用它</p><h1 id="d89c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">Currying</h1><p id="9629" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">简单地说，Currying是一种链接多个函数的技术。这是一个函数式编程特性。让我们通过解决一个常见的面试问题来理解这个概念:</p><p id="94be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题</strong></p><p id="5768" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看下面的代码片段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ed30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你需要执行的任务是调用sum函数比如sum(10)(20)(30)而不是sum(10，20，30) this。</p><pre class="kj kk kl km gt nm ly nn no aw np bi"><span id="cf66" class="nq ma it ly b gy nr ns l nt nu">// Current way of Invoking function<br/>sum(10, 20, 30)</span><span id="2d02" class="nq ma it ly b gy nv ns l nt nu">// Desired way of Invoking function<br/>sum(10)(20)(30)</span></pre><p id="8f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何执行这个动作？答案很简单，你需要使用的术语是奉承。请参见下面的代码示例</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a2df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，你可以看到我们在另一个函数中声明了一个函数，并且创建了一个函数链。你也可以看到我们得到了完全相同的输出，这个过程在JavaScript中被称为Currying。</p><p id="50cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Currying在流行的javascript库中使用，例如<a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>和<a class="ae ky" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> Rambda </a></p><h1 id="390c" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">关闭</h1><p id="2de6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">JavaScript中的闭包只不过是一个从内部作用域引用外部作用域中的变量的函数。让我们在下一节看看closure解决的问题，这样你就能知道为什么我们需要</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="e5a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，您可以看到我们得到了预期的输出。但主要问题是我们如何得到它？让我们在下面的部分进行分解:</p><p id="e151" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们声明了一个名为<code class="fe lv lw lx ly b">sayHello()</code>的函数，并在<code class="fe lv lw lx ly b">name</code>变量中存储了一个字符串。后来，我们声明了另一个函数，并用<code class="fe lv lw lx ly b">Hello</code>消息打印其名称，并返回了<code class="fe lv lw lx ly b">inner()</code>函数。最后，我们将返回的函数存储到了<code class="fe lv lw lx ly b">abc</code>变量中。</p><p id="a4e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，当JavaScript执行代码时，它将找不到<code class="fe lv lw lx ly b">name</code>变量，因为<code class="fe lv lw lx ly b">sayHello()</code>函数的内存已经被破坏了。但是我们如何获得预期的输出呢？</p><p id="6d81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这背后的主要原因是关闭。这里，<code class="fe lv lw lx ly b">sayHello()</code>函数的内存确实被破坏了，但它创建了该函数的引用，因此，在执行<code class="fe lv lw lx ly b">inner()</code>时，它可以从<code class="fe lv lw lx ly b">sayHello()</code>函数的引用中访问变量。要执行这个操作，您不需要编写一行额外的代码。因为JavaScript引擎足够智能来执行这个动作。你需要做的就是理解闭包的概念，默认情况下，每次在JavaScript中创建一个函数时，它都会被创建。</p><h1 id="64e1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">回收</h1><p id="ad49" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">回调是作为参数传递给另一个函数的函数。下面我们来看一个用例。</p><p id="c929" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设，我们在数据库中保存了一个姓名数组。我们希望添加一个新的名称，稍后，我们希望打印带有新添加名称的名称。为了执行此操作，我们编写了以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="437c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，您可以看到，我们添加了添加新名称的功能，但在输出中，新名称尚未添加。这背后的主要原因是JavaScript的<code class="fe lv lw lx ly b">asynchronous</code>行为。我们知道，对于需要很多时间的任务，JavaScript不会等待它们，而是处理其他较轻的任务，并将较重的任务放在队列中。同样的事情也发生在这里。</p><p id="214b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要使用一个回调函数，这样我们就可以打破JavaScript的<code class="fe lv lw lx ly b">asynchronous</code>行为，它可以基于一个特定的任务来等待我们。请参见下面的代码示例，以便更清楚地理解它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="60df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将一个函数(printNames)作为参数传递给了另一个函数(addNewName)。这一次<code class="fe lv lw lx ly b">printNames</code>只有在前面的功能执行完之后才会执行。这个概念被称为回调，你可以看到，在前一个函数完成任务后，我们调用了这个函数。这就是我们把回调称为稍后调用的原因。</p><p id="5a87" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在回调的基础上构建了许多高级概念。你可能也听说过<code class="fe lv lw lx ly b">Callback hell</code>这个概念。我将在以后的文章中讨论这个问题。</p><h1 id="d268" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="a842" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">在本教程中，我们已经介绍了JavaScript的三个基本概念(Currying、Closure和Callback)。我希望这篇文章对你有所帮助和启发。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><pre class="kj kk kl km gt nm ly nn no aw np bi"><span id="7e0e" class="nq ma it ly b gy nr ns l nt nu"><strong class="ly iu">Want to Connect?</strong></span><span id="2b10" class="nq ma it ly b gy nv ns l nt nu">This article was originally posted on <a class="ae ky" href="https://realjavascriptproject.com/javascript-currying-closure-callback/" rel="noopener ugc nofollow" target="_blank">realjavascriptproject.com</a></span><span id="abd9" class="nq ma it ly b gy nv ns l nt nu">Connect with me on <a class="ae ky" href="https://www.linkedin.com/in/rahulbanerjee2699/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a></span></pre></div></div>    
</body>
</html>