<html>
<head>
<title>How to Use Node.js Workers for Video Encoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Node.js Workers进行视频编码</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-to-use-node-js-workers-for-video-encoding-f1379d3933d0?source=collection_archive---------8-----------------------#2020-02-17">https://betterprogramming.pub/how-to-use-node-js-workers-for-video-encoding-f1379d3933d0?source=collection_archive---------8-----------------------#2020-02-17</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="77ef" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">视频编码非常耗费CPU资源，但是让我们看看如何实现这一点</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/a011d80fe8cb98fc1ad195ed758bc8b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZRfv8lyPzA2mMZYz"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@solimonster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">索尔</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</p></figure><p id="8517" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">昨晚，我又在做我的兼职项目，<a class="ae kz" href="https://medium.com/@pkalkman/new-year-new-side-project-e69991252bf4" rel="noopener">迷你视频编码器</a>。我添加了一个新的视频编码服务。工作流编码器，我称之为服务，使用Node.js。你可能知道视频编码是非常CPU密集型的。</p><p id="337a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在过去，Node.js从来都不是执行CPU密集型任务的好选择。原因是Node.js使用单线程来执行JavaScript代码。但是自从<a class="ae kz" href="https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V11.md#11.7.0" rel="noopener ugc nofollow" target="_blank"> 11.7.0 </a>发布后，Node.js有了一个新的模块叫做<code class="fe lw lx ly lz b">worker_threads</code>。</p><p id="42bd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Node.js团队这样描述工人:</p><blockquote class="ma mb mc"><p id="7248" class="la lb md lc b ld le jv lf lg lh jy li me lk ll lm mf lo lp lq mg ls lt lu lv in bi translated">“Workers(线程)对于执行CPU密集型JavaScript操作很有用。它们对I/O密集型工作没有多大帮助。Node.js内置的异步I/O操作比Workers更高效。”</p></blockquote><p id="de00" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因此，我使用Workers实现了工作流编码器。在这篇文章中，我描述了实现。</p></div><div class="ab cl mh mi hy mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="in io ip iq ir"><h1 id="cd96" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">编码视频</h1><p id="3663" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">在描述实现之前，我需要谈一谈为什么视频流需要编码。</p><p id="4118" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该工作流编码器是一个名为<a class="ae kz" href="https://github.com/PatrickKalkman/MiniVideoEncoder" rel="noopener ugc nofollow" target="_blank">迷你视频编码器</a> (MVE)的更大项目的一部分。MVE是一个转换视频的开源平台。转换后，常规HTTP服务器可以使用自适应流传输视频。</p><h2 id="fcf7" class="nl mp iu bd mq nm nn dn mu no np dp my lj nq nr na ln ns nt nc lr nu nv ne nw bi translated">什么是自适应流？</h2><p id="3445" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">自适应流在回放过程中改变视频的比特率和分辨率。视频播放器不断测量连接的带宽，并提高或降低视频质量。</p><p id="e333" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，Workflow Encoder创建了同一视频的多个版本。每个版本都有不同的比特率和分辨率。这个比特率和分辨率列表被称为<em class="md">编码阶梯。</em></p><p id="008c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于1080p视频，Apple建议使用以下编码阶梯。如果你对你的视频进行编码，使用这个梯子——视频将在苹果设备上正确播放。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://developer.apple.com/documentation/http_live_streaming/hls_authoring_specification_for_apple_devices" rel="noopener ugc nofollow" target="_blank">苹果为HLS x264推荐的编码阶梯</a></p></figure><p id="e14d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用这个阶梯意味着工作流编码器必须创建九种不同的编码。所以你明白为什么我们需要使用最有效的方法进行视频编码。</p><p id="513e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">工作流编码器使用<a class="ae kz" href="https://www.ffmpeg.org/" rel="noopener ugc nofollow" target="_blank"> FFmpeg </a> 4.2.2 <strong class="lc iv">。</strong> FFmpeg是一个开源的视频和音频编码器。它还使用了<a class="ae kz" href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg#fluent-ffmpeg-api-for-nodejs-" rel="noopener ugc nofollow" target="_blank"> Fluent ffmpeg-API </a>来简化与ffmpeg的交互。</p><p id="5613" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了测试，我使用了1080p版本的<a class="ae kz" href="http://www.caminandes.com/" rel="noopener ugc nofollow" target="_blank"> Caminandes 3: Llamigos </a>。Caminandes 3是来自<a class="ae kz" href="https://www.blender.org/institute/" rel="noopener ugc nofollow" target="_blank"> Blender Institute </a>的一个2.5分钟的搞笑小开源动画视频。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nz ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">Caminandes 3，用于测试视频编码的视频</p></figure></div><div class="ab cl mh mi hy mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="in io ip iq ir"><h1 id="20e5" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">使用Workers实现工作流编码器</h1><p id="2bef" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">当工作流引擎接收到视频作业时，它首先拆分作业。对于编码阶梯中的每个比特率和分辨率组合，工作流引擎都会创建一个任务。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj oa"><img src="../Images/78b786e1f205386d4d73bda7bf0a0636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*bIxdQngrO5TapZjbhtcFiA.jpeg"/></div></figure><p id="730c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">工作流编码器与工作流引擎通信，并询问是否有任务要执行。工作流编码器使用工作流引擎的REST API进行通信。</p><h2 id="cf5e" class="nl mp iu bd mq nm nn dn mu no np dp my lj nq nr na ln ns nt nc lr nu nv ne nw bi translated">创建和启动工作进程</h2><p id="10db" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">如果有任务要执行，工作流编码器调用函数<code class="fe lw lx ly lz b">startEncoder</code>。<code class="fe lw lx ly lz b">startEncoder</code>函数创建并启动工人。它通过调用构造函数并传递一个JavaScript文件的相对路径来创建<code class="fe lw lx ly lz b">Worker</code>对象。该文件包含必须在不同线程上执行的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">通过创建工作线程启动编码器</p></figure><p id="5d7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe lw lx ly lz b">Worker</code>构造函数的第二个参数是一个选项对象。我用这个来设置<code class="fe lw lx ly lz b">workerData</code>到<code class="fe lw lx ly lz b">encodingInstructions</code>。这个赋值克隆了<code class="fe lw lx ly lz b">encodingInstructions</code>，并使它在Worker函数中可用。</p><p id="5bcb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">执行工作的实际函数是<code class="fe lw lx ly lz b">encoder.js</code>中的<code class="fe lw lx ly lz b">encode</code>。该文件包含一个工人执行的函数。我省略了大部分，只关注最重要的部分。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">encoder.js中的编码器函数是工作线程</p></figure><p id="54e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在第5行，我通过读取<code class="fe lw lx ly lz b">workerData</code>得到了<code class="fe lw lx ly lz b">encodingInstructions</code>。在文件的开头，我还需要<code class="fe lw lx ly lz b">parentPort</code>，函数使用它来执行主线程和工作线程之间的通信。</p><h2 id="251b" class="nl mp iu bd mq nm nn dn mu no np dp my lj nq nr na ln ns nt nc lr nu nv ne nw bi translated">如何从工作线程与主线程通信</h2><p id="148c" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">工作模块允许主线程和工作线程之间的双向通信。我想从主线程上的工作线程获得进度反馈。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从工作线程向主线程发送消息</p></figure><p id="b0bc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">大多数例子使用<code class="fe lw lx ly lz b">postMessage</code>来发送一个字符串。相反，我传达的是一个物体。我想发送不同的消息，并能够在主线程中区分它们。</p><p id="11ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">另一方面，主线程通过事件接收这些消息。在第8行，<code class="fe lw lx ly lz b">worker.on</code>定义了接收消息事件的函数。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">启动工作进程并接收消息事件</p></figure><p id="a7c2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">根据消息的类型，该函数执行特定的操作。对于<code class="fe lw lx ly lz b">PROGRESS</code>消息，它使用log对象记录消息。这样，我们可以在主线程中看到工作线程的进度。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj ob"><img src="../Images/42b7a32e25073eb9dd8847cfbdea6c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tsXbtjSpaiWIjBaXXgpidA.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">工作线程向主线程报告进度</p></figure><h2 id="5ee1" class="nl mp iu bd mq nm nn dn mu no np dp my lj nq nr na ln ns nt nc lr nu nv ne nw bi translated">如何从主线程与辅助线程通信</h2><p id="e563" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">我们还希望能够以相反的方式进行通信，从主线程到工作线程——例如，当我们想要停止正在运行的编码任务时。</p><p id="f1a1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">该机制几乎与从工作线程到主线程的通信相同。这里，我们对<code class="fe lw lx ly lz b">worker</code>对象使用了<code class="fe lw lx ly lz b">postMessage</code>方法。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从主线程向工作线程发送消息</p></figure><p id="2c56" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Worker使用<code class="fe lw lx ly lz b">parentPort</code>创建一个接收消息的事件处理程序。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nx ny l"/></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">从工作线程上的主线程接收消息</p></figure><p id="2aaf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当Worker收到<code class="fe lw lx ly lz b">STOP_ENCODING</code>时，它停止正在运行的编码任务。它通过调用<code class="fe lw lx ly lz b">ffmpegCommand.kill()</code>来停止任务。这将<code class="fe lw lx ly lz b">SIGKILL</code>到FFmpeg进程并停止它。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj oc"><img src="../Images/9e56e801366c43538162402e99facf59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vHMyFHZW7boLDdD8k2kofw.jpeg"/></div></div><p class="kv kw gk gi gj kx ky bd b be z dk translated">工作线程在收到主线程的停止消息时停止</p></figure></div><div class="ab cl mh mi hy mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="in io ip iq ir"><h1 id="958c" class="mo mp iu bd mq mr ms mt mu mv mw mx my ka mz kb na kd nb ke nc kg nd kh ne nf bi translated">结论</h1><p id="16d0" class="pw-post-body-paragraph la lb iu lc b ld ng jv lf lg nh jy li lj ni ll lm ln nj lp lq lr nk lt lu lv in bi translated">我喜欢Node.js团队使用Workers实现线程的方式。通过在线程之间建立显式的通信通道，它们可以防止同步问题。同步会给其他编程语言带来很多问题。</p><p id="a8e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">工作流编码器的当前实现使用工作器来编码视频。你可以在<a class="ae kz" href="https://github.com/PatrickKalkman/MiniVideoEncoder" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到源码。这仍然是一项正在进行的工作。</p><p id="4836" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读。</p></div></div>    
</body>
</html>