<html>
<head>
<title>Take Advantage of the Enum Class to Implement Enumerations in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Enum类在Python中实现枚举</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/take-advantage-of-the-enum-class-to-implement-enumerations-in-python-1b65b530e1d?source=collection_archive---------1-----------------------#2020-07-30">https://betterprogramming.pub/take-advantage-of-the-enum-class-to-implement-enumerations-in-python-1b65b530e1d?source=collection_archive---------1-----------------------#2020-07-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b19" class="pw-subtitle-paragraph jr is it bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">轻松创建自己的枚举</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/fd586de3c1f7ae525d48d12e7a88d048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HMFfpwGakQiKrCR0"/></div></div><p class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@snowshade?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥列格·拉普捷夫</a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照。</p></figure><p id="21c9" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果您有使用一些常见现代语言的编程经验，比如Java、Swift或Kotlin，您应该熟悉枚举。简单地说，枚举就是你如何在同一个保护伞下组织一组密切相关的成员。</p><p id="c230" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">下面用Kotlin写的枚举向你展示了我们在<code class="fe lw lx ly lz b">Direction</code>的概念下组织了四个方向，每个成员就是一个方向:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">方向计数</p></figure><p id="86ca" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了方向之外，颜色、国籍、季节、工作日和许多其他具有离散成员的信息都可以作为枚举来实现。您可能知道，枚举给我们带来了更容易处理相关概念的好处。因此，当我们遇到这些数据时，我们应该考虑枚举。</p><p id="c9ad" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在大多数编程语言中，枚举通常作为数据结构的一种基本形式来表达，这些主题在一个人学习的早期就出现了。但是，由于某些原因，当人们在学习Python时，这一点很少被讨论。具体原因我不知道，一个可能的原因是在Python中，枚举不是一个内置的数据结构(不像<code class="fe lw lx ly lz b">bool</code>、<code class="fe lw lx ly lz b">str</code>、<code class="fe lw lx ly lz b">int</code>、<code class="fe lw lx ly lz b">list</code>)。因此，有些人试图使用自定义类来模仿枚举的行为，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用常规类在Python中枚举</p></figure><p id="c410" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">然而，用常规类实现枚举并不具备您可能想到的其他编程语言中枚举的所有特性。一个这样的问题如下所示。本质上，这种实现是通过利用Python类的属性进行“黑客攻击”。因此，如果您检查类型，您会发现它的行为并不理想。在这种情况下，类型是<code class="fe lw lx ly lz b">int</code>，它揭示了属性的类型。换句话说，他们不被视为某个群体的成员。相反，它们只是类的独立属性:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用常规类枚举的潜在问题</p></figure><p id="b77d" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在本文中，我们将通过利用<code class="fe lw lx ly lz b"><a class="ae kz" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">enum</a></code>模块来学习定义真正的工作枚举类的正确方法，该模块是Python标准库的一部分。因此，一旦在计算机上安装了Python，就可以使用<code class="fe lw lx ly lz b">enum</code>模块来创建枚举了。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="4226" class="mj mk it bd ml mm mn mo mp mq mr ms mt ka mu kb mv kd mw ke mx kg my kh mz na bi translated">声明一个枚举类</h1><p id="4acd" class="pw-post-body-paragraph la lb it lc b ld nb jv lf lg nc jy li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">在Python中声明一个枚举类实际上是非常容易的。为此，您只需通过从<code class="fe lw lx ly lz b">enum</code>模块中子类化<code class="fe lw lx ly lz b">Enum</code>类来创建自己的类，如下面的代码片段所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">Python中方向的枚举</p></figure><p id="c81e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">语法非常简单。在类定义中，我们列出了成员及其相关值——就像将它们作为属性列出来一样。上面的代码还向您展示了您可以通过使用分号在一行中分隔成员来声明您的成员，尽管我建议使用前一种方式，即每行定义一个成员，因为这将增强代码的可读性。</p><p id="7ff1" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">虽然我们通常不太关心这些枚举成员的原始值，但有一点需要注意的是，您不必为它们的原始值使用整数。例如，如果您愿意，可以使用字符串。另外，当我们使用整数时，这些数不一定是递增的。这里有一些简单的代码向您展示这些特性:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">原始值的灵活性</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="7517" class="mj mk it bd ml mm mn mo mp mq mr ms mt ka mu kb mv kd mw ke mx kg my kh mz na bi translated">使用和检查单个成员</h1><p id="2dc3" class="pw-post-body-paragraph la lb it lc b ld nb jv lf lg nc jy li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">要使用单个成员，我们只需像访问枚举类的属性一样访问它们。然而，<code class="fe lw lx ly lz b">Enum</code>班不同于普通班。这些属性被认为是枚举的成员，正如它们应该的那样。有了这个区别，我们就可以使用自省功能(例如<code class="fe lw lx ly lz b">type</code>和<code class="fe lw lx ly lz b">isinstance</code>)。一些相关的代码如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用成员</p></figure><p id="7e08" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如您所见，枚举类的这些“属性”属于该类的类型。当我们检查实例时，对象的类确实是枚举类— <code class="fe lw lx ly lz b">Direction</code>。它们与我们对枚举类的预期完全一样。</p><p id="6e36" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">对于每个成员，它都有附加属性。有用的包括<code class="fe lw lx ly lz b">name</code>和<code class="fe lw lx ly lz b">value</code>，它们表示枚举成员的名称及其相关值、整数或字符串(如果您这样定义的话)。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">名称和值</p></figure><p id="7099" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">通过理解成员的价值，我们可以用它做一些有趣的事情。例如，假设我们从一个web HTTP请求中得到一个JSON对象响应，它使用一个数值(例如2)来表示方向。有了这个整数，我们可以创建一个<code class="fe lw lx ly lz b">Direction</code>实例成员。一旦创建了该成员，就可以很容易地将它用于各种其他操作:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">用原始值创建成员</p></figure><p id="dd0b" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如上所示，我们使用获取的值2创建了一个<code class="fe lw lx ly lz b">Direction</code>成员。有了创建的实例，我们可以进行非常简单的比较，正如所料，当与东方向比较时，提取的方向被评估为<code class="fe lw lx ly lz b">True</code>。值得注意的是，我们在这里通过使用<code class="fe lw lx ly lz b">is</code>关键字来使用身份比较，因为您可以将成员视为枚举类的单一实例对象。然而，如果使用比较值的<code class="fe lw lx ly lz b">==</code>进行等式比较，您仍然会得到有效的比较结果。</p><p id="fb6e" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">顺便提一下，如果您试图从一个无效的值(例如，我们示例中的&gt; 4)创建成员，您会遇到一个异常，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">数值误差</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="3626" class="mj mk it bd ml mm mn mo mp mq mr ms mt ka mu kb mv kd mw ke mx kg my kh mz na bi translated">迭代成员</h1><p id="4390" class="pw-post-body-paragraph la lb it lc b ld nb jv lf lg nc jy li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">我们经常需要迭代枚举类的所有成员。下面的代码显示了枚举类最基本的迭代形式:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">For循环</p></figure><p id="331b" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如您所见，我们可以简单地在for循环中使用类名，这表明枚举类本身是可迭代的(即可以迭代的Python对象)。因此，我们也可以从类名中创建一个成员列表，因为它是一个iterable。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">方向列表</p></figure><p id="7b78" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与该迭代相关的其他高级知识是使用特殊的方法<code class="fe lw lx ly lz b">__members__</code>，该方法将检索枚举类的映射，其名称及其成员存储为键-值对。请注意，映射与字典不是完全相同的概念，尽管它们听起来很相似。映射是一个比字典更通用的术语。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">成员项目</p></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="f40a" class="mj mk it bd ml mm mn mo mp mq mr ms mt ka mu kb mv kd mw ke mx kg my kh mz na bi translated">定义方法</h1><p id="7c5e" class="pw-post-body-paragraph la lb it lc b ld nb jv lf lg nc jy li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">虽然基类<code class="fe lw lx ly lz b">Enum</code>不同于其他常规类，因为它专门将其属性作为成员来处理，但是我们仍然可以像其他类一样为该类定义方法。这使我们有机会对枚举类进行更强大、更灵活的操作。</p><p id="7139" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设我们想找出地图上各个方向的角度。我们可以实现一些相关的功能，如下所示:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">自定义方法</p></figure><p id="77fe" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如上图所示，<code class="fe lw lx ly lz b">angle()</code>函数被定义为一个实例方法，它将计算某个方向的度数，北方为0度。为了向您展示概念证明，我还声明了一个静态方法<code class="fe lw lx ly lz b">angle_interval()</code>,它计算两个方向之间的角度差。上述代码片段中声明的类后面的示例显示了这些方法的用法。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="b606" class="mj mk it bd ml mm mn mo mp mq mr ms mt ka mu kb mv kd mw ke mx kg my kh mz na bi translated">功能API</h1><p id="5fd1" class="pw-post-body-paragraph la lb it lc b ld nb jv lf lg nc jy li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">前面几节回顾了枚举的基于类的实现。为了使<code class="fe lw lx ly lz b">Enum</code>更加灵活，Python提供了用于创建枚举的功能API。如果你不知道什么是函数式API，这里有一个直观的解释。在前面的章节中，我们通过定义<code class="fe lw lx ly lz b">Enum</code>类的子类创建了枚举成员。正如您可能知道的，它主要是一种面向对象的编程(OOP)风格。基本上，我们使用类和对象来处理成员。相比之下，函数式API采用函数式方法。我们简单地通过调用一个函数来创建枚举。</p><p id="1712" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">还是很困惑？先来看一些相关代码。为了使比较更加直观，我将使用函数式API方法实现相同的方向成员。如下所示，我们将只使用<code class="fe lw lx ly lz b">Enum</code>函数——更准确地说，它应该被称为工厂函数。像<code class="fe lw lx ly lz b"><a class="ae kz" href="https://medium.com/swlh/empower-a-lightweight-python-data-structure-from-tuples-to-namedtuples-ca4abddd8ef6" rel="noopener">namedtuple</a></code>函数一样，这些函数创建了一个新的类:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">使用函数式API枚举</p></figure><p id="28aa" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">因为我们没有使用类声明接口来实现这个枚举类，那么有没有可能为这个枚举类(使用functional API创建的那个)定义函数？答案是肯定的，因为我们可以利用Python中一个叫做<a class="ae kz" href="https://medium.com/better-programming/what-are-duck-typing-and-monkey-patching-in-python-2f8e3d6b864f" rel="noopener"> monkey patching </a>的特性。简单地说，这是一种允许您在运行时创建和/或修改现有模块或类的行为的技术。让我们看下面一个简单的例子:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div><p class="kv kw gj gh gi kx ky bd b be z dk translated">猴子补丁</p></figure><p id="7553" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如上所示，我们首先创建了一个函数，并将该函数分配给了<code class="fe lw lx ly lz b">DirectionFunctional</code>类的<code class="fe lw lx ly lz b">angle</code>属性。值得注意的是，这个属性被认为是一个实例方法，因为<code class="fe lw lx ly lz b">angle</code>函数的第一个参数是类名。与类中声明的函数中的<a class="ae kz" href="https://medium.com/better-programming/unlock-the-4-mysteries-of-self-in-python-d1913fbb8e16" rel="noopener">自参数</a>相同。</p><p id="a8e9" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在猴子修补之后，我们能够得到向南方向的角度，如预期的那样是180度。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="d155" class="mj mk it bd ml mm mn mo mp mq mr ms mt ka mu kb mv kd mw ke mx kg my kh mz na bi translated">结论</h1><p id="0fad" class="pw-post-body-paragraph la lb it lc b ld nb jv lf lg nc jy li lj nd ll lm ln ne lp lq lr nf lt lu lv im bi translated">在本文中，我们回顾了如何用Python创建枚举。这些功能主要是通过在<code class="fe lw lx ly lz b">enum</code>模块中创建<code class="fe lw lx ly lz b">Enum</code>类的子类来实现的。这里快速回顾一下要点。</p><ul class=""><li id="48e8" class="ng nh it lc b ld le lg lh lj ni ln nj lr nk lv nl nm nn no bi translated">与常规类不同，<code class="fe lw lx ly lz b">Enum</code>类的属性将被视为该类的独立成员。</li><li id="70dc" class="ng nh it lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">这些成员有名称和值，可以是整数(它们是默认的)、字符串或其他数据类型。</li><li id="3efb" class="ng nh it lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">方法可以用枚举类来声明，这允许我们创建额外的操作来更容易地处理成员。</li><li id="02ef" class="ng nh it lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">我们可以迭代这个类的所有成员，它本身就是一个可迭代的。我们还可以利用类是iterable来创建这些成员的列表。</li><li id="dce2" class="ng nh it lc b ld np lg nq lj nr ln ns lr nt lv nl nm nn no bi translated">作为一个灵活的特性，我们可以使用函数式API在运行时创建一个枚举类。此外，我们可以使用monkey patching向类中添加额外的方法。</li></ul><p id="e5fe" class="pw-post-body-paragraph la lb it lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">感谢你阅读这篇文章。如果你想了解更多关于Python中枚举的内容，可以参考<a class="ae kz" href="https://docs.python.org/3/library/enum.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p></div></div>    
</body>
</html>