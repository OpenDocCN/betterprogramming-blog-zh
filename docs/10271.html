<html>
<head>
<title>Understanding Synchronized in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Java中的同步</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-synchronization-in-java-b8b84e55e974?source=collection_archive---------5-----------------------#2021-12-20">https://betterprogramming.pub/understanding-synchronization-in-java-b8b84e55e974?source=collection_archive---------5-----------------------#2021-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="134e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如果你想了解同步是如何工作的？它给开发商提供了什么保障？你对什么时候同步对象和什么时候同步类感到困惑吗？这篇文章是给你的。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/583e95f2412f2d10bcabebf40b6c7653.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLKbnV10CxTtOlEW-sGpqA.jpeg"/></div></div></figure><p id="3d51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当一个新的Java/Kotlin开发人员第一次遇到线程安全时，<code class="fe ln lo lp lq b">synchronized</code>关键字是他们学习的第一件事。它看起来很简单，确实如此，但是在使用它之前，您需要了解它的一些注意事项。</p><p id="77fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多线程是编写快速高效软件的好方法，但是如果使用不当，它可能会成为你遇到的最大的怪物。这可能是最糟糕的噩梦，也可能是极其难以调试的错误的来源，因此在职业生涯的早期阶段获得正确的概念至关重要。本文旨在一劳永逸地奠定正确的基础。</p><p id="d75f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面的代码将向您展示如果一个线程调用<code class="fe ln lo lp lq b">increment()</code>方法会发生什么？答案很简单；它会将<code class="fe ln lo lp lq b">count</code>的当前值加1。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="0de2" class="lv lw iq lq b gy lx ly l lz ma">public class SharedResource {<br/><br/>    int count = 0;<br/><br/>    public int get() {<br/>        return count;<br/>    }<br/><br/>    public void increment() {<br/>        System.<em class="mb">out</em>.println("Reading, and will increment now: "+get()+ " Thread: "+Thread.<em class="mb">currentThread</em>().getName());<br/>        ++count;<br/>        System.<em class="mb">out</em>.println("Value after increment: " + count + " Thread: "+Thread.<em class="mb">currentThread</em>().getName());<br/>    }<br/><br/>}</span></pre><p id="2832" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要我们不在线程间共享这个对象，这段代码就很有效。一旦多个线程共享了<code class="fe ln lo lp lq b">SharedResource</code>类的实例，并试图调用<code class="fe ln lo lp lq b">increment()</code>，我们能保证这段代码将正确运行吗？</p><p id="c15c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">答案是否定的。</p><p id="3e01" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有什么问题？像<code class="fe ln lo lp lq b">++</code>这样的操作本质上不是原子的(由多个步骤组成),线程在执行时会被抢占(CPU周期被分配给系统中的另一个线程的状态)。</p><p id="8c4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们正在处理一个多线程应用程序，那么我们应用程序中使用这个共享对象的另一个线程将有机会执行并可能改变<code class="fe ln lo lp lq b">count</code>的状态。</p><p id="b30d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个简单的增量操作是三个原子操作的组合，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/5988e2eca411a1dab29f7c79c4255e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*yorGLFhrvMfbnRsJvr3dLg.png"/></div><p class="md me gj gh gi mf mg bd b be z dk translated">增量操作</p></figure><p id="1a47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">操作系统可以在切割点[A]和[B]取走CPU份额(时隙)。如果发生这种情况，我们将有并发错误。在下图中，蓝色箭头表示CPU调度，当蓝色箭头出现时，我们将移动到不同的线程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mh"><img src="../Images/b7ec5b5436da473e9646d34d14e9cb44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iq46fEhnR6SEQznWlGAEqA.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">并发错误说明</p></figure><p id="d709" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在这里会看到，T1和T2各调用一次增量，但<code class="fe ln lo lp lq b">count</code>的值仍然是1。这是一个非常简单的例子，但是你明白了。真实世界的用例可能有许多中间步骤，这些步骤可能会被打断，线程可能会干扰。</p><p id="65e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最简单的解决方案是什么？大家说说吧。</p><p id="1692" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们不允许一个线程在执行时进入代码的一个特定区域——称为<strong class="kt ir">临界区</strong>——会怎样？这能解决问题吗？不，不完全是，因为多个线程可以在同一个CPU的不同内核上执行，这些内核将拥有自己的L1缓存(离CPU最近，速度最快)，在那里它们可以拥有自己的变量副本。如果T1/T2维护它们自己的副本，则线程以独占方式运行，这可能会导致一个问题，因为写入的值不会传回到CPU缓存；他们可能会按照旧的价值观行事。</p><p id="b3fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Synchronize</code>通过提供一些保证来解决上述两个问题:</p><ol class=""><li id="f349" class="mi mj iq kt b ku kv kx ky la mk le ml li mm lm mn mo mp mq bi translated"><strong class="kt ir">互斥</strong> —保证一次只有一个线程访问临界区。</li><li id="81fa" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated"><strong class="kt ir">可见性</strong> —写入该区域的值将对下一个进入临界区的线程可见。这意味着进入同一个同步块的下一个线程将看到离开临界区的线程所看到的世界(变量值)。</li><li id="10fe" class="mi mj iq kt b ku mr kx ms la mt le mu li mv lm mn mo mp mq bi translated"><strong class="kt ir">排序</strong> <strong class="kt ir">和</strong> <strong class="kt ir">发生在</strong>之前——我们不会在本帖中讨论这个问题，因为我们限制了范围。</li></ol><p id="01e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同步看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mw"><img src="../Images/ca6274a5e6b352e64dd7a557998c92ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5TDQGRCU1TaSK0sWqlWPqA.png"/></div></div><p class="md me gj gh gi mf mg bd b be z dk translated">同步插图</p></figure><h1 id="7659" class="mx lw iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">了解监视器</h1><p id="fa3a" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">我们知道互斥体是一种不允许多线程在它所保护的区域上运行的构造，但是Java的<code class="fe ln lo lp lq b">synchronized</code>远不止于此——它工作在监视器之上。</p><p id="8f8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Monitor是一个构造，它允许一个线程同时拥有互斥和通信机制。在Java中，我们有<code class="fe ln lo lp lq b">wait()</code>、<code class="fe ln lo lp lq b">notify()</code>和<code class="fe ln lo lp lq b">notifyAll()</code>方法来帮助线程相互通信。</p><p id="bb43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您使用如下所示的<code class="fe ln lo lp lq b">synchronized</code>关键字时，每个Java对象都被绑定到一个监视器:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="0436" class="lv lw iq lq b gy lx ly l lz ma">synchronized (this) {<br/>    <em class="mb">// block of code <br/></em>}</span></pre><p id="38ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将可以访问与该对象相关的监视器区域<code class="fe ln lo lp lq b">this</code>。因此，如果一个线程正在这个监视器中执行代码，那么在这个对象上同步的任何其他代码都将等待。</p><p id="1fbe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我们有两个在不同监视器上工作的块，在第一种情况下，该方法在最终对象上同步。代码如下:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="b1d3" class="lv lw iq lq b gy lx ly l lz ma">private final Object mLock = new Object();<br/>public int get() {<br/>    synchronized (mLock) {<br/>        <em class="mb">// do something<br/>    </em>}<br/>    return something;<br/>}</span></pre><p id="2fda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第二种情况下，它同步对象实例<code class="fe ln lo lp lq b">this</code>。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="3794" class="lv lw iq lq b gy lx ly l lz ma">public void increment() {<br/>    synchronized (this) {<br/>        <em class="mb">// block of code<br/>    </em>}<br/>    ++count;<br/>}</span></pre><p id="4a72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的场景中，两个线程可以并行执行这些方法。T1可以执行<code class="fe ln lo lp lq b">get()</code>，T2可以执行<code class="fe ln lo lp lq b">increment()</code>。理解这一点很重要。</p><p id="d5a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经学习了互斥属性，但是现在我们将看到这个简单结构的不同风格如何带来不同的行为。</p><h1 id="89de" class="mx lw iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">不同风格的同步</h1><ol class=""><li id="6808" class="mi mj iq kt b ku no kx np la nt le nu li nv lm mn mo mp mq bi translated"><code class="fe ln lo lp lq b">synchronized (this) </code> —监视器与方法所属的对象相关联。</li></ol><p id="ee63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您创建了一个共享资源的对象，并与多个线程共享它，那么只有一个线程能够独占地执行与该技术同步的方法，但是为什么呢？因为所有线程共享同一个对象，并且锁定是在这个对象上完成的。</p><p id="8049" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们创建<code class="fe ln lo lp lq b">n</code>对象并与不同的线程共享每个对象，那么所有的线程将能够执行这个方法，因为每个线程持有不同的对象，并且<code class="fe ln lo lp lq b">this</code> <strong class="kt ir"> </strong>对于每个线程将是不同的。</p><p id="4f19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想要这样的功能，无论我们创建多少个<code class="fe ln lo lp lq b">SharedResource</code>对象，对方法的访问都是互斥的，该怎么办？我们继续下一个口味。</p><p id="81a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.<code class="fe ln lo lp lq b">synchronized (SomeClass.class)</code>——这是课堂上同步的。如果一个方法使用了这一点，无论JVM上有多少对象实例，每个实例都由不同的线程共享，但是只有一个实例能够执行这样保护的方法。</p><p id="a8ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得同一类的不同实例之间能够互斥。我们在使用DCL创建单例时使用这个，对吗？</p><p id="b6c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.<code class="fe ln lo lp lq b">public <strong class="kt ir">synchronized</strong> someMethod() { }</code> —与synchronized (this)相同，但它同步整个方法，而不是一个小块。如果我们需要保护整个方法，那么我们使用这个味道。如果需要保护该方法的一小部分，它应该使用我们在第一种情况中展示的同步块。</p><h1 id="6ed9" class="mx lw iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">性能影响</h1><p id="0d9e" class="pw-post-body-paragraph kr ks iq kt b ku no jr kw kx np ju kz la nq lc ld le nr lg lh li ns lk ll lm ij bi translated">正如我们已经看到的，在<code class="fe ln lo lp lq b">synchronized</code>的情况下，我们知道如果一个线程处于临界区，其他线程必须等待。因此，由于等待时间和从/向m/m的额外读取和写入，它稍微减慢了执行速度。</p><p id="3d69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在最近的开发中，在只有一个线程的情况下，Java团队已经大大降低了性能成本。但是万一发生争用，成本还是有的。因此，在代码中添加同步时，请始终考虑利弊。我们将在另一篇文章中讨论这方面的优化。</p><p id="d9ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你喜欢你所读的！</p></div></div>    
</body>
</html>