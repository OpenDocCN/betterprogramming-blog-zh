<html>
<head>
<title>Inputs and Outputs: Working With Angular Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">输入和输出:使用角度组件</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/inputs-and-outputs-working-with-angular-components-f3204e6599f?source=collection_archive---------6-----------------------#2020-10-09">https://betterprogramming.pub/inputs-and-outputs-working-with-angular-components-f3204e6599f?source=collection_archive---------6-----------------------#2020-10-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="21dc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">学习使用输入属性和输出事件来管理父组件和子组件</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d2dc54e9aabfbbdaf69702f9a4da26c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kI2msY7jthfH_O1I"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae ky" href="https://unsplash.com/@magnusengo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Magnus eng</a>拍摄的照片</p></figure><p id="c5cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近发表的一篇<a class="ae ky" href="https://medium.com/better-programming/learn-angular-basics-by-building-a-simple-app-using-angular-material-9bbc19aa33cf" rel="noopener">教程</a>中，我们走过了构建一个应用程序并让它运行的过程。这个应用程序运行良好，但是它的结构还有待改进。现在，视图和逻辑的所有代码都存在于一个组件中，这意味着随着应用程序的增长，事情会变得越来越复杂，越来越难以理解。</p><p id="41d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个应用程序需要改头换面。</p><blockquote class="lv"><p id="e74a" class="lw lx it bd ly lz ma mb mc md me lu dk translated">"随着程序的发展，它的复杂性会增加，除非做些工作来维护或减少它."——曼尼·雷曼</p></blockquote></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b748" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">我们今天学了什么？</h1><ul class=""><li id="6942" class="ne nf it lb b lc ng lf nh li ni lm nj lq nk lu nl nm nn no bi translated">本教程强调了保持Angular应用程序整洁和结构化的重要性，这样你就不会在一个文件中有一堆代码。</li><li id="8fa2" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我将展示一个我们最近构建的应用程序的例子，它可以使用更多的结构，并提供分解成组件的代码供我们使用。</li><li id="b11b" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们将学习如何使用输出事件让父组件知道数据的变化。</li><li id="3449" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们将使用输入属性将数据从父组件传递到子组件。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="0235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你<a class="ae ky" href="https://stackblitz.com/edit/habit-tracker-basic?file=src%2Fapp%2Fapp.component.html" rel="noopener ugc nofollow" target="_blank">按照我们之前离开时的样子看应用</a>，一切都存在于应用组件中。随着时间的推移，当我们添加新的功能并更改这个应用程序时，这一大堆代码将变得令人遗憾地难以处理，因此重要的是要确保我们将代码封装到组件中，这样事情才不会失控。</p><h2 id="ead9" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">为什么组件是必由之路？</h2><ul class=""><li id="fc1a" class="ne nf it lb b lc ng lf nh li ni lm nj lq nk lu nl nm nn no bi translated">组件是一段自我关注的代码。它只包含它需要的东西，可以作为一个独立的视图提供。</li><li id="7475" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">将代码放入一个组件中使其可重用，所以如果你需要在代码中的多个地方使用给定的表单或UI元素，你可以通过将它放入一个组件中来大大减少重复。</li><li id="3d62" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">组件使得你的代码<strong class="lb iu">更易测试</strong>。您可以更容易地对相关的逻辑进行分组，并编写更集中的测试，这也使得当您稍后回来进行更改或添加特性时，事情变得更容易推理。</li></ul><p id="beeb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你看一下<code class="fe og oh oi oj b"><a class="ae ky" href="https://stackblitz.com/edit/habit-tracker-basic?file=src%2Fapp%2Fapp.component.html" rel="noopener ugc nofollow" target="_blank">app.component.html</a></code>中的所有HTML，我们已经有了一些可以成为组件的非常清晰的部分:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><h2 id="4b86" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">在我们的启动文件中，我已经将这个应用程序重组为四个组件:</h2><ul class=""><li id="7843" class="ne nf it lb b lc ng lf nh li ni lm nj lq nk lu nl nm nn no bi translated"><code class="fe og oh oi oj b">app</code>组件——这是父组件。</li><li id="c7ef" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe og oh oi oj b">toolbar</code>组件——它保存导航的代码，在本教程的剩余部分是静态的。</li><li id="41e3" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe og oh oi oj b">all-habits</code>组件——这个子组件包含管理已创建习惯列表的所有代码。</li><li id="b67c" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><code class="fe og oh oi oj b">habit-form</code>组件——这是一个子组件，封装了我们将用来为应用程序添加和编辑习惯的表单。</li><li id="4b2d" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">此外，我们已经将习惯数据移动到导出的const文件中，这样就可以共享了。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="d839" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">设置</h1><h2 id="6c0a" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">开发环境</h2><ul class=""><li id="cc9d" class="ne nf it lb b lc ng lf nh li ni lm nj lq nk lu nl nm nn no bi translated">如果你在你的机器上使用过Angular应用程序，确保你已经安装了<a class="ae ky" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>和<a class="ae ky" href="https://angular.io/guide/setup-local" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>。</li><li id="d2f6" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我将展示如何使用<a class="ae ky" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git" rel="noopener ugc nofollow" target="_blank"> Git </a>下载启动文件，如果您以前从未使用过，这也需要安装。</li></ul><h2 id="b2d9" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">起始文件</h2><p id="c415" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">要获得启动项目，从这个GitHub <a class="ae ky" href="https://github.com/jessipearcy/habit-tracker-basic" rel="noopener ugc nofollow" target="_blank"> repo </a>中把它拉下来。要从命令行执行此操作，请导航到您想要下载应用程序的位置，并键入以下Git命令:</p><pre class="kj kk kl km gt op oj oq or aw os bi"><span id="85c2" class="nu mn it oj b gy ot ou l ov ow">git clone <a class="ae ky" href="https://github.com/jessipearcy/habit-tracker-components-split" rel="noopener ugc nofollow" target="_blank">https://github.com/jessipearcy/habit-tracker-components-split</a></span></pre><p id="f8f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将把文件复制到文件夹中。接下来，运行以下两个命令导航到该文件夹，并安装Angular应用程序运行所需的软件包:</p><pre class="kj kk kl km gt op oj oq or aw os bi"><span id="62c9" class="nu mn it oj b gy ot ou l ov ow">cd habit-tracker-components-split<br/>npm ci</span></pre><p id="a174" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在所有的包安装完成后，在命令行中输入<code class="fe og oh oi oj b">ng serve</code>，按enter，然后导航到<code class="fe og oh oi oj b"><a class="ae ky" href="http://localhost:4202" rel="noopener ugc nofollow" target="_blank">http://localhost:420</a>0</code>，你应该会看到正在运行的应用程序。</p><h2 id="785f" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">让我们检查一下我们从什么开始</h2><ul class=""><li id="a315" class="ne nf it lb b lc ng lf nh li ni lm nj lq nk lu nl nm nn no bi translated">app组件模板包含三个子组件。</li><li id="7d6d" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们习惯列表的数据源位于<code class="fe og oh oi oj b">habits.ts</code>中导出的const中——这允许习惯数组在组件间共享和操作。</li><li id="779c" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">现在，应用程序组件正在呈现其中列出的所有组件——我们将添加一些属性和结构指令，以根据用户操作决定视图中应该显示的内容。</li></ul><p id="6b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，让我们开始吧！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="3339" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">使用输出事件和输入属性</h1><h2 id="0e89" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">实现结构化指令来管理视图</h2><p id="4fef" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">目前，我们同时显示表单和习惯列表，这在视图中占据了太多的空间——我们希望只在需要时才看到编辑表单！让我们以此为契机，学习如何结合使用<code class="fe og oh oi oj b">*ngIf</code>和<code class="fe og oh oi oj b">&lt;ng-template&gt;</code>来显示或隐藏代码。</p><p id="f79e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe og oh oi oj b">app.component.ts</code>中添加一个标志属性，如果<code class="fe og oh oi oj b">true</code>则显示表单，如果<code class="fe og oh oi oj b">false</code>则显示列表。默认情况下，我们将其设置为<code class="fe og oh oi oj b">false</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="4ff2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe og oh oi oj b">app.component.html</code>中，我们将使用角度结构指令设置一个if/else:</p><pre class="kj kk kl km gt op oj oq or aw os bi"><span id="45ec" class="nu mn it oj b gy ot ou l ov ow">&lt;app-habit-form <strong class="oj iu">*ngIf</strong>="formOpen; <strong class="oj iu">else</strong> allHabits"&gt;&lt;/app-habit-form&gt;</span><span id="eb75" class="nu mn it oj b gy ox ou l ov ow">&lt;ng-template <strong class="oj iu">#allHabits</strong>&gt;<br/>    &lt;app-all-habits&gt;&lt;/app-all-habits&gt;<br/>&lt;/ng-template&gt;</span></pre><p id="88d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">*ngIf</code>表达式中的<code class="fe og oh oi oj b">else</code>指的是我们在<code class="fe og oh oi oj b">&lt;ng-template&gt;</code>上设置的局部参考。使用<code class="fe og oh oi oj b">&lt;ng-template&gt;</code>意味着<code class="fe og oh oi oj b">all-habits</code>组件不仅不在视图中显示，而且实际上根本不在DOM中呈现。</p><h2 id="ce48" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">向<code class="fe og oh oi oj b">all-habits</code>组件添加一个输出事件</h2><p id="2cd0" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">习惯列表和我们的习惯表单现在都是app组件的子组件。输出事件允许子组件让它们的父组件知道数据的变化。我们将向<code class="fe og oh oi oj b">all-habits</code>组件添加一个输出事件，然后监听父<code class="fe og oh oi oj b">app</code>组件中的事件。</p><p id="6ddd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe og oh oi oj b">all-habits.component.ts</code>中，使用<code class="fe og oh oi oj b">Output()</code>装饰器添加一个属性，并将其设置为新的<code class="fe og oh oi oj b">EventEmitter</code>。<strong class="lb iu">确保从</strong> <code class="fe og oh oi oj b"><strong class="lb iu">@angular/core</strong></code>导入 <code class="fe og oh oi oj b"><strong class="lb iu">EventEmitter</strong></code> <strong class="lb iu">！然后我们将在一个函数中发出事件。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="bd2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们将更新HTML模板，以便在点击添加新习惯按钮时调用<code class="fe og oh oi oj b">onAdd()</code>函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="20e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们正在发出一个事件，我们的父组件需要监听它。</p><p id="9b3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe og oh oi oj b">app.component.html</code>中，放置一些事件监听器语法来监听事件，并调用一个新方法。</p><pre class="kj kk kl km gt op oj oq or aw os bi"><span id="1982" class="nu mn it oj b gy ot ou l ov ow">&lt;app-habit-form *ngIf="formOpen"&gt;&lt;/app-habit-form&gt;</span><span id="6c84" class="nu mn it oj b gy ox ou l ov ow">&lt;app-all-habits *ngIf="!formOpen"<br/>    (addEvent)="onAdding()"&gt;&lt;/app-all-habits&gt;</span></pre><p id="e244" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后在<code class="fe og oh oi oj b">app.component.ts</code>中添加方法来接收事件并采取一些行动:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="7058" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们应该可以点击显示我们的表单了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oy ol l"/></div></figure><h2 id="ebe1" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">从表单中输出事件</h2><p id="5e8e" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">该表单还需要能够让父组件知道我们何时想要取消表单并返回列表。</p><p id="4e84" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们给<code class="fe og oh oi oj b">habit-form.component.ts</code>添加一个新的输出事件属性，并更新<code class="fe og oh oi oj b">exitform()</code>方法以在被调用时发出事件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="5dfb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们仍然需要重置表单，这样当我们在列表和表单之间来回移动时就有了新的数据。</p><p id="8243" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们已经在<code class="fe og oh oi oj b">habit-form</code>的模板中调用了<code class="fe og oh oi oj b">exitForm()</code>，所以我们现在需要做的就是开始监听<code class="fe og oh oi oj b">app</code>父组件中的这个事件:</p><pre class="kj kk kl km gt op oj oq or aw os bi"><span id="1f69" class="nu mn it oj b gy ot ou l ov ow">&lt;app-habit-form *ngIf="formOpen; <strong class="oj iu">else </strong>allHabits"<br/>    (onExit)="<strong class="oj iu">closeForm()</strong>"&gt;&lt;/app-habit-form&gt;</span></pre><p id="8b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">将<code class="fe og oh oi oj b">closeForm()</code>方法添加到<code class="fe og oh oi oj b">app.component.ts</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="141a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以打开和关闭习惯表单。</p><h2 id="c942" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">用数据发出输出事件</h2><p id="9373" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">我们从starter项目继承了添加新习惯的能力，所以如果您测试添加一个新习惯，它应该工作得很好。然而，我们需要有一种方法来告诉我们的表单我们处于编辑模式，并给它更新现有项目所需的所有信息。</p><p id="bbe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这提出了一个挑战，因为我们想要给表单的习惯数据将来自<code class="fe og oh oi oj b">all-habits</code>，而我们想要输入来自<code class="fe og oh oi oj b">app</code>的数据。我们需要采取一些步骤来实现这一点:</p><ul class=""><li id="e4b5" class="ne nf it lb b lc ld lf lg li oz lm pa lq pb lu nl nm nn no bi translated">从<code class="fe og oh oi oj b">all-habits</code>发出一个包含习惯数据的事件。</li><li id="f585" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">将习惯存储在<code class="fe og oh oi oj b">app</code>中。</li><li id="1f0c" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">在模板中的<code class="fe og oh oi oj b">habit-form</code>元素上输入习惯。</li><li id="c493" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">从输入习惯中填充数据。</li><li id="6408" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">更新列表中已有的习惯。</li></ul><p id="559b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从当用户点击编辑按钮时发出一个事件开始:</p><p id="3b27" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">all-habits.component.ts</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="5c23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">all-habits.component.html</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="cf8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这些变化的一些说明:</p><ul class=""><li id="5074" class="ne nf it lb b lc ld lf lg li oz lm pa lq pb lu nl nm nn no bi translated">在这个输出事件中，我们添加了一个类型。这是因为当我们发出这个事件时，我们想要传递我们的习惯对象，它将是类型<code class="fe og oh oi oj b">Habit</code>。</li><li id="44eb" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">还要注意，我们的<code class="fe og oh oi oj b">onEdit()</code>函数接受一个参数，我们可以通过在HTML中传递来自<code class="fe og oh oi oj b">*ngFor</code>的习惯来访问我们需要的特定习惯。</li></ul><p id="ed45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们监听<code class="fe og oh oi oj b">app</code>中的事件并存储它:</p><p id="73c1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">app.component.html</code></p><pre class="kj kk kl km gt op oj oq or aw os bi"><span id="ac08" class="nu mn it oj b gy ot ou l ov ow">&lt;ng-template #allHabits&gt;<br/>    &lt;app-all-habits<br/>        (addEvent)="onAdding()"<br/>        (editEvent)="onEditing($event)"&gt;<br/>    &lt;/app-all-habits&gt;<br/>&lt;/ng-template&gt;</span></pre><p id="1789" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe og oh oi oj b">app.component.ts</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d94a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此代码片段中有趣的变化:</p><ul class=""><li id="a3ec" class="ne nf it lb b lc ld lf lg li oz lm pa lq pb lu nl nm nn no bi translated">别忘了导入<code class="fe og oh oi oj b">Habit</code>型号。</li><li id="3c56" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">我们已经更新了<code class="fe og oh oi oj b">closeForm()</code>,以便在表单关闭时清空<code class="fe og oh oi oj b">editHabit</code>属性。这可以防止下次打开表单时不小心将不需要的数据传递到表单中。</li></ul><h2 id="737f" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">将输入添加到元素中</h2><p id="719f" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">现在，如果您保存了所有内容并进行尝试，我们的click事件将被触发，我们将在应用程序组件中获取数据——但是，当表单打开时，它仍然是空白的！这就是输入装饰器的用武之地。</p><p id="0300" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们将输入添加到<code class="fe og oh oi oj b">app.component.html</code>中的<code class="fe og oh oi oj b">habit-form</code>元素:</p><pre class="kj kk kl km gt op oj oq or aw os bi"><span id="e6b9" class="nu mn it oj b gy ot ou l ov ow">&lt;app-habit-form <br/>    *ngIf="formOpen; else allHabits"<br/>    (onExit)="closeForm()"<br/>    [habit]="editHabit"&gt;<br/>&lt;/app-habit-form&gt;</span></pre><p id="8a97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左侧绑定括号内的变量引用了我们将要创建的子组件的<code class="fe og oh oi oj b">habit</code>属性，我们将它设置为当前作用域内的app组件的<code class="fe og oh oi oj b">editHabit</code>属性的值。</p><h2 id="69f5" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">将输入属性添加到表单中</h2><p id="3809" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">为了获取和使用被输入的属性，我们将更新<code class="fe og oh oi oj b">habit-form</code>组件来使用它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="3aba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意事项:</p><ul class=""><li id="536b" class="ne nf it lb b lc ld lf lg li oz lm pa lq pb lu nl nm nn no bi translated">当点击添加新习惯按钮时，输入属性将为空或未定义，这就是为什么我们可以方便地检查它的存在，以了解我们是否处于编辑模式。</li><li id="e2b7" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">注意，我们正在使用<code class="fe og oh oi oj b">.indexOf()</code>检查我们的习惯对象的索引，并传入整个对象。点击阅读更多关于<a class="ae ky" href="https://www.freecodecamp.org/news/javascript-array-of-objects-tutorial-how-to-create-update-and-loop-through-objects-using-js-array-methods/" rel="noopener ugc nofollow" target="_blank">在JavaScript中使用数组和对象的信息。</a></li><li id="976c" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">为了更新我们现有的习惯，我们使用<code class="fe og oh oi oj b">.splice()</code>从数组中删除条目，并用表单中提交的值替换它。</li><li id="1fd1" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如果没有习惯传入，我们知道我们处于添加模式，所以我们可以简单地将新习惯推送到数组中。</li></ul><p id="58ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧！现在，您可以通过传递整个角度组件系列的数据来创建、更新、编辑和删除习惯。干得好！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="3798" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">包裹</h1><p id="5604" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">非常感谢您完成本教程。让我们回顾一下今天所学的内容:</p><ul class=""><li id="3784" class="ne nf it lb b lc ld lf lg li oz lm pa lq pb lu nl nm nn no bi translated">为什么我们应该将代码分割成组件，以保持应用程序的整洁和可维护性</li><li id="d58f" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如何使用输出事件属性将警报和数据从子组件传递到父组件</li><li id="2fab" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">如何使用输入属性将数据从父组件向下传递到子组件</li></ul><h2 id="6b1d" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">多练习一下</h2><p id="7708" class="pw-post-body-paragraph kz la it lb b lc ng ju le lf nh jx lh li om lk ll lm on lo lp lq oo ls lt lu im bi translated">更多的实践，尝试分裂出这个应用程序中的另一个组件。<code class="fe og oh oi oj b">all-habits</code>组件包括一个习惯列表，可以很好地放入它自己的组件。尝试将这些代码放入一个组件中，并弄清楚如何确保列表随着编辑和添加而保持最新。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h2 id="3315" class="nu mn it bd mo nv nw dn ms nx ny dp mw li nz oa my lm ob oc na lq od oe nc of bi translated">资源</h2><ul class=""><li id="8301" class="ne nf it lb b lc ng lf nh li ni lm nj lq nk lu nl nm nn no bi translated"><a class="ae ky" href="https://stackblitz.com/edit/angular-ivy-xd4hjl?file=src%2Fapp%2Fapp.component.html" rel="noopener ugc nofollow" target="_blank">最终代码演示</a></li><li id="ed5a" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://angular.io/guide/component-interaction" rel="noopener ugc nofollow" target="_blank">了解关于组件交互性的更多信息</a></li><li id="5b36" class="ne nf it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated"><a class="ae ky" href="https://angular.io/guide/structural-directives" rel="noopener ugc nofollow" target="_blank">了解更多关于角度结构指令的信息</a></li></ul></div></div>    
</body>
</html>