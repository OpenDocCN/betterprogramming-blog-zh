<html>
<head>
<title>Advanced Programming With Kotlin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kotlin进行高级编程</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/advanced-android-programming-with-kotlin-5e40b1be22bb?source=collection_archive---------1-----------------------#2019-12-20">https://betterprogramming.pub/advanced-android-programming-with-kotlin-5e40b1be22bb?source=collection_archive---------1-----------------------#2019-12-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="cf62" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">kot Lin-您应该使用的独有功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/49feaa131b88068a1a3104fe7661de1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*v4LXaVKgUORTM_BP565Q8g.jpeg"/></div></figure><p id="e84f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">与我们需要编写所有内容的Java不同，Kotlin编译器可以理解代码，并在幕后编写样板代码——例如，它可以推断变量声明中的类型。这提高了生产率并节省了时间。</p><h2 id="b4cc" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">科特林让Android开发更有趣</h2><p id="bc94" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">如果你在网上搜索，你会发现很多Kotlin解决Java痛点的方法，以及Kotlin的特性如何让Android开发更有趣。</p><p id="fb08" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如<a class="ae mk" href="https://opensourceforu.com/2018/07/kotlin-a-language-for-modern-multi-platform-applications/" rel="noopener ugc nofollow" target="_blank">为你开源</a>所描述的，</p><blockquote class="ml mm mn"><p id="ad1a" class="kq kr mo ks b kt ku ju kv kw kx jx ky mp la lb lc mq le lf lg mr li lj lk ll im bi translated">“Kotlin是一种多平台编程语言，简洁、安全、可互操作且工具友好。它是一种静态类型的编程语言，运行在Java虚拟机上，也可以编译成JavaScript源代码，或者可以使用LLVM编译器基础设施。”</p></blockquote><p id="cdd3" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">无论您在这里学到了什么编程进步，其中大部分都适用于使用Kotlin进行开发的其他平台。</p><p id="9c77" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">所以，事不宜迟，让我们进入编码部分。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="f499" class="mz ln it bd lo na nb nc lr nd ne nf lu jz ng ka lx kc nh kd ma kf ni kg md nj bi translated">科特林扩展</h1><p id="1fa9" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">我们要讨论的第一个概念是科特林扩展。正如科特林自己的<a class="ae mk" href="https://kotlinlang.org/docs/reference/extensions.html" rel="noopener ugc nofollow" target="_blank">文档</a>所说:</p><blockquote class="ml mm mn"><p id="34f5" class="kq kr mo ks b kt ku ju kv kw kx jx ky mp la lb lc mq le lf lg mr li lj lk ll im bi translated">“Kotlin提供了用新功能扩展类的能力，而不必从类继承或使用设计模式，如装饰器。”</p></blockquote><p id="dcd6" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这可以通过一个叫做<em class="mo">扩展的特殊声明来完成。</em>例如，我们可以在第三方库中为一个不能修改的类编写新的功能，并将它们作为该类中的实际函数使用。这些功能称为<em class="mo">扩展功能。</em></p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="8ccb" class="mz ln it bd lo na nb nc lr nd ne nf lu jz ng ka lx kc nh kd ma kf ni kg md nj bi translated">默认Kotlin扩展</h1><p id="08b1" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">Kotlin是一个包含许多有用功能的包。默认的扩展名是数组列表中的<code class="fe nk nl nm nn b">filter</code>、<code class="fe nk nl nm nn b">single</code>、<code class="fe nk nl nm nn b">first</code>和<code class="fe nk nl nm nn b">last</code>以及用于检查字符串最后一个字符的<code class="fe nk nl nm nn b">last</code>。</p><h2 id="44d8" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">过滤器</strong></h2><p id="9a09" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><code class="fe nk nl nm nn b">filter</code>是数组列表类的扩展函数，通过它我们可以过滤结果，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">使用筛选器扩展</p></figure><p id="b7e0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这不是很棒吗？在Java中，我们需要编写所有的循环，创建一个单独的数组，并将所有的对象添加到一个新的数组中…等等。</p><p id="2a68" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但在Kotlin中，这一切都是通过一个简单的关键字来完成的。</p><h2 id="c998" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">单个</strong></h2><p id="b0df" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><code class="fe nk nl nm nn b">single</code>的工作方式与<code class="fe nk nl nm nn b">filter</code>相同，实现它的语法也是一样的——唯一的区别是<code class="fe nk nl nm nn b">single</code>只返回一个匹配给定条件的对象。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="1c5e" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">第一个和最后一个</strong></h2><p id="da8f" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">根据名称本身，我们可以猜测它们分别返回数组的第一个和最后一个对象。</p><pre class="kj kk kl km gt nu nn nv nw aw nx bi"><span id="c82c" class="lm ln it nn b gy ny nz l oa ob"><strong class="nn iu">val last </strong>=  arrayAllSeries.<strong class="nn iu">last</strong>()<br/><strong class="nn iu">val first </strong>=  arrayAllSeries.<strong class="nn iu">first</strong>()</span></pre><p id="d3ef" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有了科特林，总会有更多的东西。在这里，我们可以应用一个条件，并在数组中获取满足这些条件的<code class="fe nk nl nm nn b">first</code>和<code class="fe nk nl nm nn b">last</code>对象，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">带有条件的数组中的第一个和最后一个对象</p></figure><p id="ff95" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这只是冰山一角。Kotlin有无数这样的扩展函数，可以减少业务逻辑中对样板代码的需求。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="59b3" class="mz ln it bd lo na nb nc lr nd ne nf lu jz ng ka lx kc nh kd ma kf ni kg md nj bi translated">用户定义的扩展</h1><p id="8baf" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">我们可以为Kotlin中的任何类创建扩展，以获得用户想要的功能。下面是我经常使用的一些扩展。</p><h2 id="8ad4" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">视图扩展</h2><p id="af42" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">例如，考虑为一个视图编写一个<code class="fe nk nl nm nn b">RxClick</code>。下面是代码，展示了我们一般是如何编写的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">RxClick实现</p></figure><p id="c1a4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">拜托，都快2020年了。谁会写这么多代码来实现一个简单的点击呢？有了Kotlin，总有简化的空间。</p><p id="dc4d" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，创建一个名为<code class="fe nk nl nm nn b">viewextensions</code>的Kotlin文件，然后编写一个扩展函数在一个视图上实现<code class="fe nk nl nm nn b">RxClick</code>，如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">RxClick Kotlin扩展</p></figure><p id="1a91" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">正如我在开始时解释的那样，我为类<code class="fe nk nl nm nn b">View</code>、<strong class="ks iu">、</strong>编写了一个新功能，函数名设置为<code class="fe nk nl nm nn b">reactiveclick</code>、<strong class="ks iu">、</strong>，并编写了我们需要在该函数中运行的任何功能。</p><p id="eb44" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这个<code class="fe nk nl nm nn b">reactiveclick</code>非常类似于视图上的通用点击功能，比如<code class="fe nk nl nm nn b">setOnClickListener</code>。</p><p id="eee0" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">下面是我们如何使用<code class="fe nk nl nm nn b">reactiveclick</code> <strong class="ks iu"> </strong>函数在一个视图上实现<code class="fe nk nl nm nn b">RxClick</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">使用RxClick Kotlin扩展</p></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b888" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当你开始使用这样的扩展函数时，你就会知道它们的优点了。就好像你在实现自己的风格。</p><p id="3b7a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以下是我在项目中使用的几个视图扩展<strong class="ks iu"> </strong>来提高我的工作效率。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">我每天使用的几个视图扩展</p></figure><h2 id="ff74" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">字符串扩展</h2><p id="4c8f" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">到目前为止，我们已经研究了视图扩展。接下来，让我们专注于我们可以使用扩展来做的一些验证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">常用的字符串扩展</p></figure><p id="f584" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">以上是我经常使用的字符串扩展。我们可以根据项目级别的要求编写任何应用于字符串的功能——就像当你创建一个聊天应用程序时，如果用户键入@，那么你可能希望开始显示用户名建议。</p><p id="bc36" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">看看我是如何使用扩展来实现的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="b739" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">上下文扩展</h2><p id="5e9b" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">这是我的最爱之一。我们可以使用上下文编写很多扩展，比如设置状态栏颜色、获取屏幕高度和宽度、显示吐司，甚至检查互联网连接。</p><p id="9f73" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">看看我最常用的基于上下文的扩展:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="fc8b" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这些扩展是不是很棒？这是我在Kotlin会议上第一次看到他们时的想法。</p><p id="10e4" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">但是不要把所有的扩展功能都组合到一个文件里，几个星期或者几个月之后就标记为垃圾。创建单独的Kotlin文件。如<code class="fe nk nl nm nn b">ViewExtensions</code>、<code class="fe nk nl nm nn b">StringExtensions</code>、<code class="fe nk nl nm nn b">FileExtensions</code>等。—就像在Java中处理实用程序文件一样。</p><p id="52a9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">通常编写这种类型的扩展让我感觉像是在编写自己的语言。这是我喜欢科特林的原因之一。</p><p id="8f56" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我在这里展示的扩展是我在所有项目中常用的，但是我们可以为特定于项目的功能编写更多的扩展，就像我们在上面的例子中为聊天应用程序中的提及扩展所做的那样。</p></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="d49a" class="mz ln it bd lo na nb nc lr nd ne nf lu jz ng ka lx kc nh kd ma kf ni kg md nj bi translated">高阶函数</h1><p id="35f3" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">可以作为参数传递或者可以从函数返回的函数称为<em class="mo">高阶函数。</em>换句话说，高阶函数就是以函数为参数或者返回函数的函数。</p><p id="b9ca" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不管您在哪个平台上开发，这些类型的函数都非常方便。作为一名Android开发人员，我发现高阶函数可以非常方便地代替点击监听器并将函数作为参数传递。</p><p id="7a32" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了更清楚地理解这一切，让我用一个例子来解释一下。</p><p id="d942" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们最常使用的是创建一个<code class="fe nk nl nm nn b">RecyclerView</code>，其中我们创建一个点击监听器并将其传递给适配器。我没有这样做，而是将函数直接作为一个参数传递，该参数应该在用户单击时调用。看一看。</p><p id="7ecc" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，让我们看看适配器的构造函数部分，它有一个高阶函数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">使用高阶函数作为参数的RecyclerView适配器构造函数</p></figure><p id="e905" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这里，第二个参数，<code class="fe nk nl nm nn b">block,</code> <strong class="ks iu"> </strong>是带有两个参数的高阶函数，需要在点击<code class="fe nk nl nm nn b">RecyclerView</code>项时调用。</p><p id="2cd1" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">点击<code class="fe nk nl nm nn b">RecyclerView</code>项，我们将调用<code class="fe nk nl nm nn b">block</code>、<strong class="ks iu">、</strong>，如下图所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">在RecyclerView项目上调用块函数单击</p></figure><p id="7406" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在是创建适配器的时候了。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="415c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nk nl nm nn b">coutriesItemClick</code> <strong class="ks iu"> </strong>是我们在<code class="fe nk nl nm nn b">CountryAdapter</code> <strong class="ks iu"> </strong>中传递的函数，作为参数在项目点击时调用。</p><pre class="kj kk kl km gt nu nn nv nw aw nx bi"><span id="9d90" class="lm ln it nn b gy ny nz l oa ob">{  <strong class="nn iu">viewType </strong>: Int, <strong class="nn iu">data </strong>: CountryDetails -&gt; coutriesItemClick(viewType,data) }</span></pre><p id="369e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><code class="fe nk nl nm nn b">viewType</code>和<code class="fe nk nl nm nn b">data</code>是通过点击项目视图中调用的<code class="fe nk nl nm nn b">block</code> <strong class="ks iu"> </strong>函数传递到这里的参数，如上图所示。</p><p id="149a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这很好，对吧？我们删除了所有的样板代码来创建一个点击监听器，并且也不需要识别在项目中哪个视图被点击了。</p><h2 id="b146" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">具有多点击区域的Recyclerview适配器</h2><p id="407a" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">当项目中有一个或两个单击区域时，将高阶函数作为参数传递是可行的，但如果有两个以上的单击区域呢？那么在构造函数中传递所有的函数是没有优化的。</p><p id="022a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">看看如何有效地处理这种情况。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">双击以上即可回收视图适配器</p></figure><p id="5d4e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以创建任意数量的点击，并且可以从适配器实例中调用它们，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">使用适配器中的点击功能</p></figure></div><div class="ab cl ms mt hx mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="im in io ip iq"><h1 id="cb0c" class="mz ln it bd lo na nb nc lr nd ne nf lu jz ng ka lx kc nh kd ma kf ni kg md nj bi translated">限定作用域的函数</h1><p id="43ce" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">如果您使用Kotlin已经有一段时间了，那么您应该已经知道作用域函数— <code class="fe nk nl nm nn b">let</code>、<code class="fe nk nl nm nn b">run</code>、<code class="fe nk nl nm nn b">apply</code>等等—在使用它们时有其优势。</p><p id="bd5a" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">基本上，这些函数做同样的事情—对一个对象执行一段代码。不同的是这个对象如何在块中变得可用，以及整个表达式的结果是什么。</p><p id="962e" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们来看看其中的一些。</p><h2 id="ee57" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">让</strong></h2><p id="a261" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">Kotlin的<code class="fe nk nl nm nn b">let</code>是一个作用域函数，其中在表达式内部声明的变量不能在外部使用。<code class="fe nk nl nm nn b">let</code>将调用它的对象作为参数，并返回lambda表达式的结果。</p><p id="4a8c" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们看看<code class="fe nk nl nm nn b">let</code>块的用法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">让科特林进来</p></figure><p id="31b2" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果你不用<code class="fe nk nl nm nn b">let</code>写同样的代码，你将不得不引入一个新的变量，并在你使用它的时候重复它的名字。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">没有信</p></figure><p id="1e0f" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">范围函数没有引入任何新的技术功能，但是它们可以使您的代码更加简洁，可读性更好。</p><p id="eb41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">另一方面，<code class="fe nk nl nm nn b">let</code>在空检查中也很方便。看一看:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">带字母的空支票</p></figure><h2 id="a240" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">奔跑</h2><ul class=""><li id="d5a0" class="oc od it ks b kt mf kw mg kz oe ld of lh og ll oh oi oj ok bi translated">类似于<code class="fe nk nl nm nn b">let</code>函数，<code class="fe nk nl nm nn b">run</code>函数也返回最后一条语句</li><li id="80a8" class="oc od it ks b kt ol kw om kz on ld oo lh op ll oh oi oj ok bi translated">与<code class="fe nk nl nm nn b">let</code>不同，<code class="fe nk nl nm nn b">run</code>功能不支持<code class="fe nk nl nm nn b">it</code> <strong class="ks iu"> </strong>关键字</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated">在科特林跑步</p></figure><h2 id="150f" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">应用</strong></h2><p id="31e6" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><code class="fe nk nl nm nn b">apply</code>是另一个限定了作用域的函数，但是我们可以改变我们在块中应用关键字的实体的属性。</p><pre class="kj kk kl km gt nu nn nv nw aw nx bi"><span id="853d" class="lm ln it nn b gy ny nz l oa ob">textviewName?.<strong class="nn iu">apply</strong>{<br/>     <strong class="nn iu">text </strong>= "print this from apply"<br/>}</span></pre><p id="7ace" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们对其应用关键字的实体的属性将在块中直接可用——就像在上面的示例中<code class="fe nk nl nm nn b">textview</code>的<code class="fe nk nl nm nn b">text</code> <strong class="ks iu"> </strong>是可用的。</p><h2 id="63dd" class="lm ln it bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">随着</h2><p id="6e06" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated"><code class="fe nk nl nm nn b">with</code>是另一个关键字，其作用类似于<code class="fe nk nl nm nn b">apply</code> <strong class="ks iu"> </strong>，并且可以访问该关键字实际应用到的实体的属性。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div><p class="nq nr gj gh gi ns nt bd b be z dk translated"><strong class="ak">同</strong>在科特林</p></figure><p id="d937" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">范围函数的不同之处在于它们返回的结果:</p><ul class=""><li id="8059" class="oc od it ks b kt ku kw kx kz oq ld or lh os ll oh oi oj ok bi translated"><code class="fe nk nl nm nn b"><strong class="ks iu">a</strong>pply</code>和<code class="fe nk nl nm nn b">also</code>返回上下文对象</li><li id="ed26" class="oc od it ks b kt ol kw om kz on ld oo lh op ll oh oi oj ok bi translated"><code class="fe nk nl nm nn b">let</code>、<code class="fe nk nl nm nn b">run</code>和<code class="fe nk nl nm nn b">with</code>返回lambda结果</li></ul><p id="85b7" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">这两个选项允许您根据代码中的下一步操作选择适当的函数。</p><h1 id="1d00" class="mz ln it bd lo na ot nc lr nd ou nf lu jz ov ka lx kc ow kd ma kf ox kg md nj bi translated">更新</h1><p id="2891" class="pw-post-body-paragraph kq kr it ks b kt mf ju kv kw mg jx ky kz mh lb lc ld mi lf lg lh mj lj lk ll im bi translated">要了解更多关于Kotlin的内容，请阅读Kotlin高级编程系列中的其他文章:</p><ul class=""><li id="934e" class="oc od it ks b kt ku kw kx kz oq ld or lh os ll oh oi oj ok bi translated"><a class="ae mk" href="https://medium.com/android-dev-hacks/advanced-android-programming-with-kotlin-part-2-aae2a15258b0" rel="noopener">“使用Kotlin进行高级编程—第二部分</a>”</li><li id="6560" class="oc od it ks b kt ol kw om kz on ld oo lh op ll oh oi oj ok bi translated"><a class="ae mk" href="https://medium.com/better-programming/advanced-programming-in-kotlin-2e01fbc39134" rel="noopener">“使用Kotlin进行高级编程—第3部分</a>”</li><li id="069e" class="oc od it ks b kt ol kw om kz on ld oo lh op ll oh oi oj ok bi translated"><a class="ae mk" href="https://medium.com/better-programming/advanced-android-programing-in-kotlin-part-4-187b88fea048" rel="noopener">“用Kotlin进行高级编程—第四部分”</a></li><li id="1de2" class="oc od it ks b kt ol kw om kz on ld oo lh op ll oh oi oj ok bi translated"><a class="ae mk" href="https://medium.com/better-programming/advanced-programming-in-kotlin-part-5-b674ce9e692f" rel="noopener">“使用Kotlin进行高级编程—第5部分”</a></li></ul></div></div>    
</body>
</html>