<html>
<head>
<title>Everything You Need To Know About Data Classes in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于Python中的数据类，您需要知道的一切</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/everything-you-need-to-know-about-data-classes-in-python-46a93a90f9d3?source=collection_archive---------17-----------------------#2021-08-11">https://betterprogramming.pub/everything-you-need-to-know-about-data-classes-in-python-46a93a90f9d3?source=collection_archive---------17-----------------------#2021-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0103" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Python中字典和命名元组的更好替代方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c7d3eb5529e5e4e39151812540378a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tOliIR25Z0RIAi41"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·伊恩在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure><p id="1268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们经常使用简单的数据结构，比如Python中的Tuple ( <code class="fe lv lw lx ly b">tuple</code>)或Dictionary ( <code class="fe lv lw lx ly b">dict</code>)。在我们的生活中，程序员几乎在任何地方和每天都使用它们来存储数据。</p><p id="a942" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们可以用下面的代码示例表示一个汽车对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="6c86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，当我们必须处理更复杂的数据时，这些基本的数据结构就变得不那么理想了。这里，我们需要记住<code class="fe lv lw lx ly b">car</code>在我们的应用程序中代表一个汽车字典或元组，而不是一些字符串或整数。</p><p id="c7ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们只有三个字段(<code class="fe lv lw lx ly b">name</code>、<code class="fe lv lw lx ly b">brand</code>和<code class="fe lv lw lx ly b">price</code>)，那么在上面的例子中使用Tuple来表示我们的car对象就可以了。当我们添加更多的字段到我们的汽车对象中，比如<code class="fe lv lw lx ly b">manufacturer</code>、<code class="fe lv lw lx ly b">condition</code>等等。，我们需要记住属性的顺序。</p><p id="502f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于使用字典的情况，我们不能使用<a class="ae ky" href="https://www.askpython.com/python/built-in-methods/dot-notation" rel="noopener ugc nofollow" target="_blank">点符号</a>(即<code class="fe lv lw lx ly b">car.name</code>)来访问我们的属性。此外，深度嵌套的字典往往很难使用。</p><p id="276e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将讨论常规字典或元组的更好替代方案。</p><h2 id="80b3" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">涵盖的主题</h2><ul class=""><li id="02fd" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu nb nc nd ne bi translated">命名元组</li><li id="8fcd" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">数据类，命名元组的更好替代</li><li id="4401" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">自定义数据类</li><li id="6951" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">何时使用数据类</li></ul><p id="e454" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开始吧！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="28cf" class="nr mc it bd md ns nt nu mg nv nw nx mj jz ny ka mm kc nz kd mp kf oa kg ms ob bi translated">命名元组来拯救</h1><p id="1289" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">为了提高代码的可读性，一种更常见的方法是使用Python内置的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/collections.html" rel="noopener ugc nofollow" target="_blank">collections</a></code>库中的命名元组(<code class="fe lv lw lx ly b">namedtuple</code>)。</p><p id="ff07" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">以我们上面的汽车为例，命名元组应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="bcf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好多了。那么，为什么不一直使用命名元组呢？</p><p id="5148" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好吧，命名元组确实有它自己的限制。除了不能为我们的汽车属性分配默认值之外，命名元组本质上是不可变的。</p><p id="f100" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是PEP对<a class="ae ky" href="https://www.python.org/dev/peps/pep-0557/#why-not-just-use-namedtuple" rel="noopener ugc nofollow" target="_blank">为什么我们不应该只使用命名元组</a>的解释。</p><p id="f80c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且，使用Dictionary、Tuple，甚至命名Tuple都不允许我们拥有自定义的类方法，这就回避了问题:为什么不直接使用常规的<a class="ae ky" href="https://docs.python.org/3/tutorial/classes.html" rel="noopener ugc nofollow" target="_blank"> Python类</a>？</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="231a" class="nr mc it bd md ns nt nu mg nv nw nx mj jz ny ka mm kc nz kd mp kf oa kg ms ob bi translated">Python类</h1><p id="4a53" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">在Python中，一切都是对象，大多数对象都有属性和方法。通常，我们会在Python中使用<code class="fe lv lw lx ly b">class</code>来创建我们自己的定制对象，它们有自己的属性和方法。</p><p id="7db2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用我们之前的示例创建一个简单的汽车对象:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="ce9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每次一个新的属性被添加到我们的汽车对象中，我们都需要将它们传递到<code class="fe lv lw lx ly b">__init__</code>方法中。如果我们需要在我们的<code class="fe lv lw lx ly b">__repr__</code>方法中添加一个更具描述性的汽车对象的表示会怎么样？如果我们需要比较同一个汽车对象的两个汽车实例，该怎么办？</p><p id="3b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">老实说，当我们只处理单个汽车对象时，事情并没有那么糟糕。但是如果我们不得不增加更多的职业，比如<code class="fe lv lw lx ly b">Manufacturer</code>、<code class="fe lv lw lx ly b">CarDealer</code>等，那该怎么办呢？？</p><p id="07c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您已经知道的，代码重复的迹象无处不在，而且很难闻！说实话，除非我们真的需要自定义方法，否则使用命名元组可能会更好。</p><p id="c724" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为坏消息的传递者，现实生活中往往不是这样。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="ea75" class="nr mc it bd md ns nt nu mg nv nw nx mj jz ny ka mm kc nz kd mp kf oa kg ms ob bi translated">输入数据类别</h1><p id="618b" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">在Python 3.7中引入的<a class="ae ky" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank">数据类(</a> <code class="fe lv lw lx ly b"><a class="ae ky" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank">dataclasses</a></code> <a class="ae ky" href="https://docs.python.org/3/library/dataclasses.html" rel="noopener ugc nofollow" target="_blank"> ) </a>为我们提供了一种简单的方法，使我们的类对象不那么冗长。简而言之，数据类只是帮助我们抽象大量样板代码的常规类。</p><p id="6930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要用数据类重写我们前面的例子，我们只需用<code class="fe lv lw lx ly b">@dataclass</code>修饰我们的基本类:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="c434" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Data类最好的部分是它自动生成类中的公共<a class="ae ky" href="https://www.geeksforgeeks.org/dunder-magic-methods-python/" rel="noopener ugc nofollow" target="_blank"> Dunder方法</a>，如<code class="fe lv lw lx ly b">__repr__</code>和<code class="fe lv lw lx ly b">__eq__</code>，消除了所有重复的代码。</p><h2 id="40d5" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">自定义数据类</h2><ol class=""><li id="c50d" class="mu mv it lb b lc mw lf mx li my lm mz lq na lu of nc nd ne bi translated">在某些情况下，我们可能需要定制我们的数据类字段:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="5700" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2.为了在我们新创建的数据类中覆盖<code class="fe lv lw lx ly b">__init__</code>之后发生的事情，我们可以声明一个<code class="fe lv lw lx ly b">__post_init__</code>方法。例如，我们可以很容易地根据汽车的初始化条件覆盖汽车的价格:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="fccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3.为了使我们的数据类不可变，我们只需添加<code class="fe lv lw lx ly b">@dataclass(frozen=True)</code>作为装饰器。</p><p id="14e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">4.数据类的另一个好的用例是当我们需要处理嵌套字典的时候。下面是一个数据类可以做什么的简单例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="532f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">5.最后，如果不明显的话，数据类也支持继承，因为它们的行为就像我们以前的普通类一样。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="fd06" class="nr mc it bd md ns nt nu mg nv nw nx mj jz ny ka mm kc nz kd mp kf oa kg ms ob bi translated">那么，什么时候使用数据类呢？</h1><h2 id="20cc" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">与命名元组</h2><p id="dd7a" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">数据类的使用最常与命名元组的使用相比较。在很大程度上，数据类提供了相同的优势，如果不超过命名元组的话。</p><p id="6b7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在需要<a class="ae ky" href="https://www.w3schools.com/python/python_tuples_unpack.asp" rel="noopener ugc nofollow" target="_blank">解包</a>变量的情况下，你可能会考虑使用命名元组。</p><h2 id="2ddc" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated">对比字典</h2><p id="46c0" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">当我们的字典有一组固定的键，它们对应的值有固定的类型时，使用数据类几乎总是更好。</p><p id="3e16" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">简而言之，经验法则相当简单，如果你创建一个字典或者一个主要由底层数据的属性组成的类，使用数据类。这可以节省你很多时间。</p><p id="8930" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，数据类还保留了每个属性的类型信息，这是一个巨大的附加优势！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="4aa9" class="nr mc it bd md ns nt nu mg nv nw nx mj jz ny ka mm kc nz kd mp kf oa kg ms ob bi translated">结束语</h1><p id="4da4" class="pw-post-body-paragraph kz la it lb b lc mw ju le lf mx jx lh li oc lk ll lm od lo lp lq oe ls lt lu im bi translated">再说一遍，在Python中创建常规类没有任何问题。然而，这可能意味着仅仅为了设置我们的类实例就要编写大量重复的样板代码。</p><p id="d812" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总结一下我们所经历的，数据类很棒，因为它:</p><ul class=""><li id="88e0" class="mu mv it lb b lc ld lf lg li og lm oh lq oi lu nb nc nd ne bi translated">节省时间并减少代码重复</li><li id="e09a" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">提供更多的灵活性，它可以是可变的或不可变的</li><li id="f359" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">支持继承</li><li id="ebac" class="mu mv it lb b lc nf lf ng li nh lm ni lq nj lu nb nc nd ne bi translated">允许自定义和默认值</li></ul><p id="d0e0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要误解我。并非Python中的每个类都需要是数据类。数据类不是灵丹妙药。</p><p id="2ada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在大多数情况下，我们应该永远记住，如果没有必要，我们不应该把事情复杂化。只要我们不是在处理过于复杂的事情，一本好的旧字典可能就能胜任。</p><p id="01e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="7761" class="mb mc it bd md me mf dn mg mh mi dp mj li mk ml mm lm mn mo mp lq mq mr ms mt bi translated"><a class="ae ky" href="https://jerrynsh.com/all-you-need-to-know-about-data-classes-in-python/" rel="noopener ugc nofollow" target="_blank">最初发表于jerrynsh.com</a></h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/everything-you-need-to-know-about-context-managers-in-python-f83556fbdfb"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">关于Python中的上下文管理器，您需要知道的一切</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">通过示例了解Python中“with”语句背后的魔力</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">better编程. pub</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ks om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-write-clean-code-in-python-5d67746133f2"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">如何用Python写干净的代码</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">使用Python示例编写干净代码的3个技巧</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">better编程. pub</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ks om"/></div></div></a></div></div></div>    
</body>
</html>