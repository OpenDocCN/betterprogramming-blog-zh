<html>
<head>
<title>Creating Your Own E-Commerce Keystone.js-Based System — Build a Cart</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建您自己的基于Keystone.js的电子商务系统——构建购物车</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/creating-your-own-e-commerce-keystone-js-based-system-build-a-cart-8c433ccf5443?source=collection_archive---------14-----------------------#2022-04-27">https://betterprogramming.pub/creating-your-own-e-commerce-keystone-js-based-system-build-a-cart-8c433ccf5443?source=collection_archive---------14-----------------------#2022-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="96b4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们创建自己的电子商务系统的下一步</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/691541d67e98c61d50c5ff774ac932d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XL5juiHya_D7mse6"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">肯尼·埃利亚松在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><h1 id="1dbf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="8a41" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">前一段时间，我有一个大胆的想法，用Kesytone.js来建立一个电子商务系统。这一旅程始于几周前，到目前为止，我们已经讨论了<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-e-commerce-keystone-js-based-system-requirements-and-architecture-3d639241b963">系统需求</a>、<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/build-your-own-e-commerce-keystone-js-based-system-environment-setup-and-base-models-2c02a3e3a70b">环境设置和基本模型</a>，以及<a class="ae kv" rel="noopener ugc nofollow" target="_blank" href="/building-your-own-e-commerce-keystone-js-based-system-access-control-1a366ed7e064">访问控制</a>。在本文中，让我们集中讨论购物车的主要功能。此外，本文的完成代码可以在我的<a class="ae kv" href="https://github.com/eabald/keystone-e-commerce/tree/Cart" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><h1 id="eb67" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">推车流量</h1><p id="f98b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本系列的前几部分中，当我们设置基本模式时，我们决定每个用户只有一个购物车，它将包含所有添加的产品，直到用户从该购物车创建订单。基于此，用户可以在他们的购物车上执行三种操作。首先，可以向购物车中添加一个商品，然后删除它并改变它的数量。</p><p id="6fd2" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此外，还有一个主要问题需要考虑，这与其说是技术问题，不如说是业务问题。我们是否应该允许用户向购物车中添加比当前可用产品更多的产品？我的意思是，在产品有库存的情况下，例如，四件商品可用，但是用户试图添加到购物车五，在这种情况下应该发生什么？</p><p id="7348" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当然，这个问题应该在UI中得到解决，但是在某些情况下，它还是会发生。使用SSR和Next.js有一些缺点，在最基本的情况下，只在页面渲染上检查可用产品的数量。这可能会导致产品可用性在渲染和将产品添加到购物车之间的时间内发生变化的情况。</p><p id="8c59" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有两个主要的解决方案:首先，在这种情况下阻止添加到购物车，或者将这个验证步骤向前移动，并阻止创建缺货产品的订单。尽管我们做出了决定，但从安全角度来看，这一步骤是必要的。</p><p id="2984" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我相信这个问题还有第三种解决方案——介于前面提到的两种方案之间。模式包括关于下一次送货的信息，所以如果库存中没有足够的商品，但加在一起足够了，那么用户可以将它添加到购物车中。但是订单会因此而延迟。</p><p id="ae5a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">另一方面，如果没有下一个交货信息，它将被阻止。这个解决方案应该确保更好的用户保留，更重要的是实施起来更有趣。</p><p id="b68d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样一来，我们就可以专注于这三个操作了。首先，将产品添加到购物车中。基本上有两个步骤。验证库存并更新购物车中的产品。这同样适用于更新数量。删除产品只是对购物车模型的更新，对吗？不完全是。让我们看看我们的<code class="fe mp mq mr ms b">Cart</code>模式:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4c17" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">有与<code class="fe mp mq mr ms b">Product</code>相关的列表，但是没有办法存储关于添加产品数量的信息。因此，我们必须创建一个中间列表(在SQL术语中称为数据透视表)来处理多对多关系并存储数量信息。</p><h1 id="9dcd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">购物车商品列表</h1><p id="9cc4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">该列表的主要目的是存储<code class="fe mp mq mr ms b">Cart</code>和<code class="fe mp mq mr ms b">Product</code>实体之间的关系和数量信息。基本上应该只是从<code class="fe mp mq mr ms b">Cart</code>开始作为关系请求。直接要求是没有意义的。让我们创建<code class="fe mp mq mr ms b">cart-product.schema.ts</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b78e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是等等，只有两个字段？很简单，这个列表不需要了解任何关于<code class="fe mp mq mr ms b">Cart</code>或者这些产品属于什么。但是另一方面，<code class="fe mp mq mr ms b">Cart</code>模型需要这个信息，所以我们必须更新这个列表，并将关系从<code class="fe mp mq mr ms b">Product</code>更改为<code class="fe mp mq mr ms b">CartProduct</code>。此外，不再需要隐藏从管理用户界面创建这个实体的可能性。</p><pre class="kg kh ki kj gt mv ms mw mx aw my bi"><span id="e84c" class="mz kx iq ms b gy na nb l nc nd">products: relationship({<br/>  ref: 'CartProduct',<br/>  many: true,<br/>}),</span></pre><p id="aa54" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好了，现在我们可以更新我们的流程了:</p><ul class=""><li id="89dc" class="ne nf iq lq b lr mk lu ml lx ng mb nh mf ni mj nj nk nl nm bi translated">添加到购物车:<br/> 1。验证库存<br/> 2。创建<code class="fe mp mq mr ms b">CartProduct</code>实体<br/> 3。更新<code class="fe mp mq mr ms b">Cart</code>型号</li><li id="c696" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">从购物车中取出产品:<br/> 1。移除<code class="fe mp mq mr ms b">CartProduct</code>实体<br/> 2。更新<code class="fe mp mq mr ms b">Cart</code></li><li id="9519" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated">改变购物车中的数量:<br/> 1。验证库存<br/> 2。更新<code class="fe mp mq mr ms b">CartProduct</code>实体<br/> 3。更新<code class="fe mp mq mr ms b">Cart</code></li></ul><h1 id="c5cb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">简单介绍一下框架抽象及其局限性</h1><p id="810c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">但是为什么这么麻烦呢？让我们看一下我们数据库的当前ER图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/01b5f9db304c90d387268cdc57974a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7WP4DqRdyBPwnYiaWAgM3w.png"/></div></div></figure><p id="0647" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们有自己的<code class="fe mp mq mr ms b">Cart</code>、<code class="fe mp mq mr ms b">CartProduct</code>和<code class="fe mp mq mr ms b">Product</code>表，但也有<code class="fe mp mq mr ms b">_Cart_products</code>表。我们没有创造最后一个，对吗？取消延期Prisma为我们做到了。这就是为什么对我们使用的工具有一个基本的了解是有好处的。</p><p id="26c7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Prisma有两种创建多对多关系的方法(<a class="ae kv" href="https://www.prisma.io/docs/concepts/components/prisma-schema/relations/many-to-many-relations#relational-databases" rel="noopener ugc nofollow" target="_blank">更多信息可在文档</a>中获得)，显式或隐式。在第一个例子中，我们负责在我们的<code class="fe mp mq mr ms b">schema.prisma</code>文件中创建透视表和其他表上的关系。在第二个例子中，我们跳过数据透视表，由ORM为我们创建。</p><p id="096a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是在我们的例子中，我们不能直接控制<code class="fe mp mq mr ms b">schema.prisma</code>文件；Keystone解决了这个问题，并使用了隐式方法。在大多数情况下，这是非常好的，但有时它可能有一些缺点，就像这个不必要的表。</p><p id="97c4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">框架通常会在厚厚的抽象层下隐藏很多实现细节，这在大多数情况下是一件好事。它允许开发人员专注于<code class="fe mp mq mr ms b">business</code>逻辑，工作更快更有效。但在某些情况下，我们不得不接受一些问题。</p><h1 id="94f3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挂钩和验证流</h1><p id="e012" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了执行每个cart操作中涉及的所有步骤，我们需要一个允许我们执行一些副作用的工具，包括更新<code class="fe mp mq mr ms b">Cart</code>模式时的额外验证。幸运的是，Keystone拥有完美的工具。</p><p id="355f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">还有<code class="fe mp mq mr ms b">Hooks API</code>，它对整个模式或其中的特定字段执行同样的操作。他们有五个人:</p><ul class=""><li id="1931" class="ne nf iq lq b lr mk lu ml lx ng mb nh mf ni mj nj nk nl nm bi translated"><code class="fe mp mq mr ms b">resolveInput</code>允许我们在验证创建或更新操作之前修改输入数据。</li><li id="1598" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe mp mq mr ms b">validateInput</code>和<code class="fe mp mq mr ms b">validateDelete</code>分别为我们提供了在创建/更新和删除操作中返回额外验证错误的可能性。</li><li id="9750" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe mp mq mr ms b">beforeOperation</code>在数据库操作之前处理副作用</li><li id="d41c" class="ne nf iq lq b lr nn lu no lx np mb nq mf nr mj nj nk nl nm bi translated"><code class="fe mp mq mr ms b">afterOperation</code>操作后情况相同。</li></ul><p id="1b98" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在<a class="ae kv" href="https://keystonejs.com/docs/guides/hooks" rel="noopener ugc nofollow" target="_blank">文档</a>中阅读更多关于钩子的内容。</p><p id="5fcd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好了，让我们回到我们的系统。整个流程比看起来要简单；我们只需要用两个钩子(第三个是奖金)。首先，让我们假设每个<code class="fe mp mq mr ms b">updateCart</code>突变都必须包含当前购物车中的所有产品(之前也添加了)。这样，当我们提交产品列表时，购物车内容就被设置到这个列表中。当有空列表时，购物车内容被清除，当没有产品列表时，购物车内容不变。例如，一个突变应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3ea4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了处理这个问题，我们必须删除所有的<code class="fe mp mq mr ms b">CartProduct</code>实体，并在每次更新时添加一个新的实体。为此，我们需要使用<code class="fe mp mq mr ms b">Cart</code>模式中的<code class="fe mp mq mr ms b">beforeOperation</code>钩子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c168" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这很简单——当更新突变中有产品时，我们查询并删除所有当前添加的产品。之后，当前操作用新的/更新的库存添加回所有适当的产品。此外，当数据解析后出现一个空的产品列表时，购物车内容将被清除。</p><p id="6a53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">好了，这就是关于更新购物车内容的部分，但是股票验证呢？不应该是在那之前发生的吗？是的，但是它应该发生在<code class="fe mp mq mr ms b">CartProduct</code>模式中，而不是直接发生在购物车中。我们将添加<code class="fe mp mq mr ms b">validateInput</code>挂钩:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ed0c" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这里，它检查每个产品的库存，并将请求的数量与下一次交货中的组合库存和数量进行比较。如果还不够，我们调用<code class="fe mp mq mr ms b">addValidationError</code>函数来创建一个验证错误。这个方法近乎完美。只有一个问题:<code class="fe mp mq mr ms b">CartProduct</code>实体是在购物车更新之前创建的，当出现验证错误时，<code class="fe mp mq mr ms b">Cart</code>实体不会被更新。</p><p id="8c0f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">但是第一个模式中的一些行可能已经被创建了，这可能会在<code class="fe mp mq mr ms b">CartProduct</code>表中留下孤立条目。这是一个应该使用事务的完美例子，但是现在，Keystone中没有这样的选项。根据<a class="ae kv" href="https://github.com/keystonejs/keystone/issues/7217" rel="noopener ugc nofollow" target="_blank">这个</a>问题，在不久的将来可能会改变。</p><p id="c99d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">最后一个奖金挂钩呢？在<code class="fe mp mq mr ms b">Cart</code>中，有一个<code class="fe mp mq mr ms b">sum</code>字段包含整个购物车的价值信息，我们需要一种方法来计算它。<code class="fe mp mq mr ms b">resolveInput</code>挂钩效果最好:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c079" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">它获取与此购物车相关联的所有产品，并对它们的金额和价格求和。之后，要保存到数据库中的数据被更新。</p><h1 id="9311" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">摘要</h1><p id="2e76" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">现在，我们已经完成了电子商务系统的购物车部分。老实说，应用程序的这一部分比我最初预期的要难开发。而且，实现起来也没那么难。大部分工作都在思考解决问题的最佳方式，而不是问题本身。</p><p id="1a12" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">由于各种原因，它比我计划的时间长，我希望你喜欢它。如果您有任何问题或意见，请随时提问。</p><p id="a477" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">兼职项目有一个令人讨厌的特点:起初，它们令人兴奋和有趣，但在一些工作之后，我们不再有那种感觉。我相信这就是为什么写这部分花了我这么长时间。</p><p id="37f7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">不要误解我的意思，我仍然计划完成这个系列并构建这个系统，但是为了不失去其中的乐趣——并防止它在下一篇文章中成为一个苦差事——我将休息一下，写一些其他的东西。</p><p id="31d8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">那里见！</p></div></div>    
</body>
</html>