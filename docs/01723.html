<html>
<head>
<title>Understanding JavaScript/TypeScript Memoization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript/TypeScript记忆</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/understanding-javascript-typescript-memoization-6e0333b62406?source=collection_archive---------6-----------------------#2019-10-08">https://betterprogramming.pub/understanding-javascript-typescript-memoization-6e0333b62406?source=collection_archive---------6-----------------------#2019-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f3cb" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">JavaScript和类型脚本教程</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5f57808203b82df3d798559b2897deba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndUhdX7mc-2dGRL34gRGNg.jpeg"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="7d9c" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">什么是记忆化？</h1><p id="7ee4" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">维基百科对记忆化的定义如下:</p><blockquote class="mp mq mr"><p id="bf8d" class="lt lu ms lv b lw mt ju ly lz mu jx mb mv mw me mf mx my mi mj mz na mm mn mo im bi translated">在计算中，记忆化是一种优化技术，主要用于通过存储昂贵的函数调用的结果并在相同的输入再次出现时返回缓存的结果来加速计算机程序—维基百科</p></blockquote><p id="ee8e" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">记忆化是一种编程技术，它允许你用空间成本来减少函数的时间成本。也就是说，被记忆的函数由于更高的存储空间利用率而获得速度。</p><p id="03bc" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">记忆化只能用在纯函数中，所以要知道的第一点就是它是纯函数。</p><p id="bbc3" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">在下面的动画中，你可以看到在我们的代码中应用记忆化的最终结果。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/ddd9918790b8811a0095ca5acc660ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*QEV781LFO5EbGCDd.gif"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="4a7a" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">什么是纯函数？</h1><p id="b520" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">纯函数是满足以下标准的函数:</p><p id="3c4d" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">当参数相同时，这个函数总是返回相同的结果。例如，以下函数是不纯的:</p><ul class=""><li id="001c" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nh ni nj nk bi translated">使用随机数的函数。</li><li id="7746" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated">使用日期时间作为种子来生成结果的函数。</li></ul><p id="b437" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">这是一个在应用中不会产生副作用的函数:</p><ul class=""><li id="af04" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nh ni nj nk bi translated">数据突变或改变应用程序状态。</li><li id="9f21" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated">网络请求。</li><li id="0188" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated">数据库或文件请求。</li><li id="d2f1" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated">获取用户输入。</li><li id="8c14" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated">查询DOM。</li></ul></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="76c6" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">利益</h1><p id="965e" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在web开发中使用纯函数有几个好处。虽然，纯函数不仅仅用在web开发中。嗯，纯功能的主要好处是:</p><ol class=""><li id="f90b" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nq ni nj nk bi translated">您的代码更具声明性，它关注的是必须做什么，而不是如何做。此外，这些功能还关注不同的输入与输出之间的关系。</li><li id="0cf9" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nq ni nj nk bi translated">代码可测试性更强，找到bug比在不纯的函数中更容易。</li></ol><p id="16e7" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">但是，在现实生活中有副作用，这是代码的一个很好的部分(例如，当您访问数据库或与不同的服务器通信以请求关于系统的信息时)。</p><p id="deb6" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">所以，纯函数是代码的一部分，你需要知道什么时候可以使用纯函数，什么时候可以在代码中使用记忆化。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="aa2c" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">纯函数示例</h1><p id="00f7" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">递归函数经常使用纯函数。最经典的递归问题是阶乘。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/3246a998a16a3bd6c5de168d1902746b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIH_ZzBIxdc5woUzdQV9Lg.png"/></div></div></figure><p id="64ce" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">但是命令式阶乘函数也是纯函数，因为纯函数与输入和输出相关。在这两种情况下，当输入相同时，输出也相同。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ns"><img src="../Images/e186b7ae7a4d3ae4e7a42ad482362a4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Lwq0GjzPhp9g4dSBhYobw.png"/></div></div></figure><p id="b406" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">纯函数的另一个有趣的例子如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ca"><img src="../Images/02b39c35f55c64c500c583e776a0a564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2lPAvFKFZY76ska2AmLwA.png"/></div></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="3d32" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">递归函数的记忆化</h1><p id="2dcc" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">记忆化是一种编程技术，它允许你不重新计算纯函数的值。</p><p id="8e87" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">即，当纯函数具有相同的输入时，它返回相同的值。因此，可以使用任何缓存系统(例如映射或数组)将返回值存储在系统中。</p><p id="86c9" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">所以，如果你计算了<code class="fe nt nu nv nw b">factorial(1)</code>的值，你就可以存储返回值<code class="fe nt nu nv nw b">1</code>，同样的操作可以在每次执行中完成。所以，当你运行阶乘(100)时，第一次需要一段时间，但第二次和以后的其他时间，时间会减少！</p><p id="09a6" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">在这种情况下，如果你注意到递归阶乘版本，你可以注意到这个版本多次执行函数<code class="fe nt nu nv nw b">factorial</code>，这可以缓存在我们的系统中(使用memoization)，但如果你使用命令式阶乘版本，你的性能会更差。</p><p id="78a3" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">出于这个原因，<code class="fe nt nu nv nw b">memoization</code>是声明性语言中的一项好技术。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="17cb" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">记忆示例—实时代码</h1><p id="8a7d" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在这一节中，我将向您展示如何使用<code class="fe nt nu nv nw b">closure</code>实现记忆化，以及如何使用JavaScript实现<code class="fe nt nu nv nw b">decorator</code>模式。</p><p id="2c8d" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">装饰模式允许您在运行时使用组合而不是层次结构向任何对象添加新特性。模式的目标是避免创建特性的类层次结构。</p><p id="a51e" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">理解这种模式的一个很好的例子可以在Addy Osmany的博客中找到。</p><p id="db23" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">因此，JavaScript中memoize装饰器的一个基本实现如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/e9123cefd77a392b25309968230508f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Gsdix9v0wwvdPqdw5O6Kg.png"/></div></div></figure><ol class=""><li id="7185" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nq ni nj nk bi translated">定义将存储执行结果的缓存。我们使用一个对象作为<code class="fe nt nu nv nw b">map</code>来存储这个结果。</li><li id="4ea5" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nq ni nj nk bi translated">装饰器返回一个新函数，它的行为与原始函数相同，但实现了记忆。</li><li id="adbb" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nq ni nj nk bi translated">键值映射的键是使用来自原始函数的<code class="fe nt nu nv nw b">stringify</code>和args生成的。</li><li id="4050" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nq ni nj nk bi translated">新功能的<code class="fe nt nu nv nw b">result</code>将是:</li></ol><ul class=""><li id="b68b" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nh ni nj nk bi translated">原始函数(<code class="fe nt nu nv nw b">fn(...args)</code>)的执行，缓存中是否没有存储。</li><li id="8984" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated">存储在缓存中的值(之前是否预先计算过)。</li></ul><p id="8640" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">5.<code class="fe nt nu nv nw b">result</code>返回。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="a100" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">如何使用记忆装饰器？</h1><p id="3495" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在JavaScript中使用这个装饰器的方法非常简单:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/18a531a2a8bc2179865a1c7716af615a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GkqFb5fO2ClDwr1pN-zEVQ.png"/></div></div></figure><p id="efd6" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">在这种情况下，<code class="fe nt nu nv nw b">add</code>函数是没有记忆化的原始函数，而<code class="fe nt nu nv nw b">addMemoized</code>函数是使用装饰模式的具有新特性(记忆化)的新函数。</p></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="a106" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">使用记忆的真实演示</h1><p id="3993" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">现在，我将向你们展示一个使用记忆化的真实演示。</p><p id="9977" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">想象一个复杂的算法，它向您表明一个<code class="fe nt nu nv nw b">array</code>是否有一个唯一的值(如<code class="fe nt nu nv nw b">Array.prototype.some</code>)但是被可怕地编程了。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/0649868eecfc6bb43fcd6bd3c43ece33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XlFEeeNYiymJo0da8v1fhw.png"/></div></div></figure><p id="bc9b" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">下面的步骤是运行原始代码和使用memoization的代码，并比较每个函数所用的时间。非常重要的一点是，不要修改原始代码，而是添加了记忆功能。</p><p id="ebb3" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">下面的函数用于测量每次执行所用的时间。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/3b8810b2478f58ad71b71a9c694d4713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yA2Hgswp0zlPEFsth2cgEQ.png"/></div></div></figure><p id="7146" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">这些数组是在脚本开始时生成的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/99c0a547674f742c2e58f0cbb60f2dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j0FjEAF2KsRsWC-BzsFH-Q.png"/></div></div></figure><p id="a0e7" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">最后，当用户点击按钮时，功能被执行。</p><ol class=""><li id="7948" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nq ni nj nk bi translated">无记忆性:</li></ol><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/ceb13ea4207626e9b18fdfcb4c9a5ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fyLmc76USWdpU6FaZrroGw.png"/></div></div></figure><p id="c564" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">2.记忆化:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/da5a848788c4010420f7e9ba5f3c6e0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P4rk5zelcrwFsBe_Xgh-3w.png"/></div></div></figure><p id="f4d0" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">结果如以下动画所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/f40def8062cde299b088349ee5dad5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/0*gsS4gRwStJd5-c6W.gif"/></div></figure></div><div class="ab cl ku kv hx kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="im in io ip iq"><h1 id="1601" class="lb lc it bd ld le lf lg lh li lj lk ll jz lm ka ln kc lo kd lp kf lq kg lr ls bi translated">结论</h1><p id="3554" class="pw-post-body-paragraph lt lu it lv b lw lx ju ly lz ma jx mb mc md me mf mg mh mi mj mk ml mm mn mo im bi translated">在使用TypeScript或JavaScript的web开发中，记忆化已经得到了广泛的发展。下面的资源列表应该是在项目中使用它们的起点。</p><ul class=""><li id="e730" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nh ni nj nk bi translated"><a class="ae nx" href="https://github.com/caiogondim/fast-memoize.js" rel="noopener ugc nofollow" target="_blank">快速记忆</a></li><li id="5564" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated"><a class="ae nx" href="https://github.com/planttheidea/moize" rel="noopener ugc nofollow" target="_blank">莫伊泽</a></li><li id="998e" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated"><a class="ae nx" href="https://github.com/medikoo/memoizee" rel="noopener ugc nofollow" target="_blank"> Memoizee </a></li><li id="f370" class="nc nd it lv b lw nl lz nm mc nn mg no mk np mo nh ni nj nk bi translated"><a class="ae nx" href="https://github.com/steelsojka/lodash-decorators" rel="noopener ugc nofollow" target="_blank">装饰工</a></li></ul><p id="6ce8" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">快速记忆使用此图比较记忆的不同实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi of"><img src="../Images/bd8276b6c6e3ea219d237ba17861fbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*24FX0pTBekM1NxvM.png"/></div></figure><p id="d45a" class="pw-post-body-paragraph lt lu it lv b lw mt ju ly lz mu jx mb mc mw me mf mg my mi mj mk na mm mn mo im bi translated">更多理论:</p><ul class=""><li id="a0d6" class="nc nd it lv b lw mt lz mu mc ne mg nf mk ng mo nh ni nj nk bi translated">GitHub项目<a class="ae nx" href="https://github.com/Caballerog/blog/memoization" rel="noopener ugc nofollow" target="_blank">。</a></li></ul></div></div>    
</body>
</html>