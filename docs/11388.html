<html>
<head>
<title>Bypass IP Address-Based Rate Limits With Rotating IP Addresses In Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过在Go中轮换IP地址，绕过基于IP地址的速率限制</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/bypass-ip-address-based-rate-limits-with-rotating-ip-addresses-in-golang-30f19a0d56d7?source=collection_archive---------7-----------------------#2022-03-15">https://betterprogramming.pub/bypass-ip-address-based-rate-limits-with-rotating-ip-addresses-in-golang-30f19a0d56d7?source=collection_archive---------7-----------------------#2022-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2800" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">基于IP的速率限制背后的基本概念。然后我们用Tor和SmartProxy构建一个Golang HTTP客户端来绕过它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4672ca3e5bd9be15ea0eab51933b85bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5Ds3o1wuDmFxllccnKz_qw.gif"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">旋转IP地址</p></figure><p id="9c47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本文介绍了与服务通信时基于IP的速率限制背后的基本概念，以及如何规避它。我们将首先在Golang中构建一个简单的<a class="ae lr" href="https://www.quora.com/What-is-the-difference-between-HTTP-client-and-HTTP-server" rel="noopener ugc nofollow" target="_blank"> HTTP客户端</a>，它将能够在必要时轮换IP地址，然后看看如何使用<a class="ae lr" href="https://www.torproject.org/" rel="noopener ugc nofollow" target="_blank"> Tor </a>构建我们自己的本地代理池，使用<a class="ae lr" href="https://smartproxy.com/" rel="noopener ugc nofollow" target="_blank"> SmartProxy </a>利用商业代理池服务。最后，我们应该知道轮换IP地址绕过基于IP的速率限制的有效性，以及如何改进它们。</p><h1 id="cfe0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基于IP地址的速率限制</h1><p id="7b71" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有许多不同的方法来实现速率限制器。一些网站根据地址所属的IP范围阻止访问。例如，网站可能会拒绝访问已知范围的Tor节点，甚至是亚马逊网络服务的IP地址范围。一般来说，这种方法旨在减少非人类流量，机器人通常会从单个IP地址发送比人类用户在同一时期产生的更多的请求。</p><p id="2b0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">网站可以很容易地监控流量，并知道有多少请求是从一个特定的IP地址。如果请求的数量超过一定限度，网站可以阻止该IP地址或要求进行<a class="ae lr" href="https://en.wikipedia.org/wiki/CAPTCHA" rel="noopener ugc nofollow" target="_blank">验证码</a>测试。</p><h1 id="ebee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">绕过基于IP地址的速率限制</h1><p id="fd85" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">有许多方法可以解决基于IP的速率限制。一种选择是限制你在一个网站上同时抓取的页面数量，甚至可能引入延迟(在达到最初的限制之后)。解决基于IP地址的速率限制的最简单方法是改变发送请求的IP地址。我们可以通过使用<a class="ae lr" href="https://www.geosurf.com/blog/proxy-pool/" rel="noopener ugc nofollow" target="_blank">代理池</a>来实现这个功能。如果我们通过修改我们的<a class="ae lr" href="https://pkg.go.dev/net/http#Transport" rel="noopener ugc nofollow" target="_blank"> HTTP传输</a>的引用，为每个请求分配另一个代理。我们可以让每个请求看起来都来自不同的用户。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h2 id="4e1a" class="mw lt iq bd lu mx my dn ly mz na dp mc le nb nc me li nd ne mg lm nf ng mi nh bi translated">突岩</h2><p id="f730" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在是时候讨论如何用Tor创建一个<a class="ae lr" href="https://www.geosurf.com/blog/proxy-pool/" rel="noopener ugc nofollow" target="_blank">代理池</a>了。Tor是一种覆盖网络协议，它使计算机能够通过一系列代理进行匿名通信。我们将在袜子上使用<a class="ae lr" href="https://lists.torproject.org/pipermail/tor-dev/2010-December/000680.html" rel="noopener ugc nofollow" target="_blank">流隔离</a>。使用这种方法，您只需要一个Tor实例，每个请求可以使用不同的出口节点的不同流，但是需要注意的是，不同的出口节点并不能保证我们有不同的IP地址。为了隔离流，我们必须为每个连接创建唯一的<code class="fe ni nj nk nl b">username:password</code>值。首先，我们创建一个伪随机性源，并创建一个random int用于我们的<em class="nm"> Tor SOCKS字符串</em>。接下来，我们可以将我们新创建的<em class="nm"> Tor SOCKS字符串</em>解析成一个<em class="nm"> URL结构</em>。最后，我们可以将我们的<em class="nm"> Tor URL </em>传递给<code class="fe ni nj nk nl b">ProxyURL</code>，后者返回一个将在我们的<em class="nm">传输</em>中使用的代理函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">通过流隔离建立Tor SOCKS代理连接</p></figure><p id="4c6c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<em class="nm"> Tor SOCKS </em>作为我们的代理，我们需要解决一些问题。Tor通过3个<a class="ae lr" href="https://community.torproject.org/relay/" rel="noopener ugc nofollow" target="_blank">中继</a>对你的连接进行加密和匿名。您的流量在世界各地的多个节点之间来回传递。这导致了一些瓶颈和网络延迟，它们将一直存在，但是最突出的瓶颈是创建一个Tor电路所花费的时间。由于我们使用一个Tor实例，并在不同的端口上分离会话，如果我们不跟踪会话，我们可能会耗尽主机上的可用端口。幸运的是，我们不用担心智能代理的这些问题。</p><h1 id="ce9a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">智能代理</h1><p id="cf44" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated"><a class="ae lr" href="https://smartproxy.com/" rel="noopener ugc nofollow" target="_blank"> SmartProxy </a>让您通过一个IP地址访问超过4000万个IP地址池。就像在Tor部分一样，我们可以利用代理池，但是在这种情况下，我们不必创建不同的IP。我们使用我们的SmartProxy凭证连接到将在我们的<em class="nm">传输中使用的代理池。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">智能代理代理功能</p></figure><p id="7bc2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以通过无限制的连接请求访问整个4000万地址池。我发现一个很方便的附加功能是能够根据每个请求在粘性或旋转IP之间切换。拥有粘性IP可以让我们只在IP耗尽(阻塞)时改变IP，从而释放连接时间。现在让我们在我们的<em class="nm"> HTTP客户端</em>中利用这些代理。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="a3d6" class="ls lt iq bd lu lv np lx ly lz nq mb mc jw nr jx me jz ns ka mg kc nt kd mi mj bi translated">客户</h1><p id="52e4" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们将使用我们创建的新代理函数创建自己的HTTP客户端。我们首先创建一个singleton，以确保我们只创建一个<code class="fe ni nj nk nl b">Transport</code>一次。</p><blockquote class="nu nv nw"><p id="7007" class="kv kw nm kx b ky kz jr la lb lc ju ld nx lf lg lh ny lj lk ll nz ln lo lp lq ij bi translated">注意:为了让客户端重用底层连接，我们只需要在发出新的HTTP请求之前完全读取主体并关闭它</p></blockquote><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="042c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们指定了一个类型为<code class="fe ni nj nk nl b">time.Duration</code>的<code class="fe ni nj nk nl b">Timeout</code>字段。当客户端通过HTTP打开与服务器的连接时，服务器可能需要一些时间来响应请求。此字段使我们能够指定从服务器获得响应的最长等待时间。函数<code class="fe ni nj nk nl b">NewIP</code>创建另一个代理函数，并在<code class="fe ni nj nk nl b">Transport</code>字段中重新分配代理字段。现在，让我们在主函数中将所有内容联系在一起。</p><h1 id="80df" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">主要的</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="58a6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在配置和实例化Tor客户端之后，我们可以检查请求的IP地址。然后我们调用<code class="fe ni nj nk nl b">NewIP</code>到<em class="nm">旋转</em>我们客户的IP地址并再次检查，瞧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0d75b441f31fc76f2bb5ebedb075e236.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*Q_S0TZMbPWTy1XhjNkWhAg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">具有Tor的不同IP</p></figure><h1 id="1fa2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="ae8e" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">用Tor或SmartProxy实现轮换IP地址是一项简单的任务，可以用来成功地绕过基于IP的速率限制。这可以大大减少发出请求或抓取网页时的瓶颈。</p><p id="d5d5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">虽然这个例子中的代码是一种相当幼稚的方法，但是有许多方法可以改进这个例子。要查看该项目的源代码，您可以访问我的Github Repo。</p><p id="a1ba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我希望这能帮助你建立有趣的项目！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn no l"/></div></figure></div></div>    
</body>
</html>