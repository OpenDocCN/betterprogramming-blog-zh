<html>
<head>
<title>The Lost Art of Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遗失的香草JavaScript艺术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/the-lost-art-of-vanilla-javascript-c11519720244?source=collection_archive---------5-----------------------#2019-10-28">https://betterprogramming.pub/the-lost-art-of-vanilla-javascript-c11519720244?source=collection_archive---------5-----------------------#2019-10-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="836c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当编程变成将库粘合在一起时</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/37822894d4bac9914c6c8494e7222eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8w4qZEGQi6wEsxNm"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@jonah_jpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔纳·佩特里奇</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></p></figure><p id="9eb4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几个月前，我为一家科技公司做了一个关于Web组件的演讲，大多数与会者都没有使用过Web组件。这是一个非常有趣和受欢迎的演讲，以听众持续半个多小时的一轮提问结束。</p><p id="7cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在接近尾声时，有人问我这是否意味着我们要回到他所谓的“类似jQuery的意大利面条代码”的时代，因为我已经展示了原始的DOM操作代码。我可以看到其他一些人点头表示同意，这种反应真的让我思考。</p><p id="f5db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，不属于某个框架或库的一部分，而只是我们称之为“香草JavaScript”的代码被认为是糟糕的“意大利面条代码”这甚至不应该是一个惊喜。</p><p id="2de1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整整一代开发人员开始使用框架和初学者工具包，这些框架和工具包带有一大堆现成的依赖项。只需运行<code class="fe lv lw lx ly b">npm install</code>并根据您的需要调整代码模板。</p><p id="6850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这可能是一个很好的起点，但我们确实需要认识到编程不仅仅是将第三方库粘在一起。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="8104" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我不反对依赖</h1><p id="2d74" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">让我先说明一下，我并不提倡使用依赖关系。事实上，我对多种前端框架颇有经验。</p><p id="1024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，我鼓励你在考虑使用哪一个之前，问问自己下一个项目是否真的需要这些依赖。</p><p id="142e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是一个非常重要的问题，要问自己。我觉得这个问题问得不够多，如果有人问的话。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="48c1" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">“不要重新发明轮子”的谬论</h1><p id="18d5" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">你可能已经听过很多次了。作为一名开发人员，你不应该“重新发明轮子”，相反，你应该使用一个已经在做你试图构建的事情的库。</p><p id="2a5b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当您需要一个数据库ORM时，这是一个很好的建议，因为当已经有好的ORM可用时，从头开始编写它是没有意义的。</p><p id="8af1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">问题是:当我们决定自己编码什么以及何时使用第三方依赖时，我们在哪里划线？</strong></p><p id="b943" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2016年，<a class="ae ky" href="https://github.com/left-pad/left-pad" rel="noopener ugc nofollow" target="_blank"> left-pad </a>包的开发者因为一个法律问题决定从NPM移除他所有的包，他<a class="ae ky" href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/" rel="noopener ugc nofollow" target="_blank">这样做几乎破坏了互联网</a>。这说明了对第三方软件的依赖已经变得多么疯狂。</p><p id="ccaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">左填充的唯一工作是用零或空格填充字符串的左边。这个包只包含几行代码，初级开发人员也可以用几行代码编写它。事实上，它已经被弃用，取而代之的是标准<code class="fe lv lw lx ly b">String.prototype.padStart()</code>，然而数以千计的项目依赖于它。</p><p id="e32e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更糟糕的是。包<a class="ae ky" href="https://github.com/juliangruber/isarray" rel="noopener ugc nofollow" target="_blank"> isarray </a>只有四行代码，它检查给定的参数是否是一个数组。当然，这是为不支持本机<code class="fe lv lw lx ly b">Array.isArray()</code>方法的老浏览器准备的，但是这可以由任何开发人员用一行代码编写。</p><p id="66df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码自己并不是“重新发明轮子”在您的项目中，确实没有必要将它作为一个依赖项。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="6a70" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们不知道我们在用什么</h1><p id="24a2" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">尽管如此，人们仍然认为最好使用已经可用的第三方模块——即使它们非常小——因为这些模块已经过“战斗测试”,是“成熟的解决方案”</p><p id="3203" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是:你确定吗？</p><p id="4dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你<em class="nd">知道</em>依赖是一个经过充分测试和证明的解决方案吗，或者你只是<em class="nd">假设</em>它是？</p><p id="2321" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你真的知道你的<code class="fe lv lw lx ly b">node_modules</code>文件夹里的所有东西吗？</p><p id="0ed4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不知道，可能也没人知道。老实说，您不必这样做，但至少您应该考虑将什么作为依赖项安装，以及自己编写什么代码。</p><p id="9cfa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当每个现代浏览器中都已经有了<code class="fe lv lw lx ly b">fetch</code>时，你真的需要一个臃肿的库来进行简单的HTTP调用吗？或者是一个大型的数据解析库，你可以用几行代码自己编写，并且<em class="nd">只</em>你<em class="nd">真正</em>需要的？</p><p id="3f6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎整整一代开发人员都太不安全了，以至于不能编写和使用他们自己的代码，相反，他们求助于将库粘合在一起，他们<em class="nd">认为</em>经过了良好的测试并且没有错误。</p><p id="b5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这是一种虚假的安全感。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="56b0" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">我们怎么会变得如此缺乏安全感？</h1><p id="c71e" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">为什么我们作为开发人员如此害怕相信我们自己的代码，而宁愿使用我们认为更好更安全的其他人的代码？</p><p id="2af2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">毕竟这些在Github上发布自己开源代码的人也是开发者，和我们一样。它们也不是完美的，它们也可能写出有缺陷的代码。然而，我们选择相信他们，而不是自己。</p><p id="29fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我理解你不想写一个像RxJS这样的库或者自己反应，比如。这些大型库已经存在多年，有许多贡献者，并且经过了良好的测试。我不建议重新实现这些<a class="ae ky" href="https://medium.com/better-programming/why-coding-your-own-makes-you-a-better-developer-5c53439c5e4a?source=friends_link&amp;sk=86f893a87f23d1e87ac699e68e87b896" rel="noopener">，除非你想从中学习</a>。</p><p id="97d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是对于较小的功能，您可以轻松地自己编写代码并完全适应自己的需求，我建议您自己编写。至少你可以在需要的时候轻松修改和修复。</p><p id="a6d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我猜开发人员编写自己的代码的不安全感来自于多年来使用的库和框架，这些库和框架对我们隐藏了原生JavaScript平台。这已经从jQuery开始，随着Angular和React等框架的出现变得更糟。</p><p id="6792" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些抽象本质上被认为是复杂的。正因为如此，开发人员倾向于使用这些作为黑盒。</p><p id="5dce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再说一次，我不是反框架的，我确实看到了它们带来的价值。但是现在，似乎有整整一代开发人员只知道如何使用框架编程，而对底层平台知之甚少甚至一无所知。他们不知道如何使用原始DOM，因为他们几乎没有接触过它。</p><p id="c43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我已经参与了几个常青树项目，其中第一个问题是<em class="nd">我们应该使用哪个</em>框架，而不是<em class="nd">如果</em>我们应该使用一个的话。默认的假设是需要一个框架，主要的论点是框架将提供我们需要的一切，我们不应该重新发明轮子。</p><p id="0d54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">具有讽刺意味的是，这些人中的许多人没有足够的本地平台知识来判断所选择的框架是否是一个好的选择。</p><p id="921a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以理解的是，这些框架的复杂性令人生畏，尤其是对于初学者。他们会倾向于把它们当作黑匣子来使用，而不了解它们内部是如何工作的。</p><p id="a99d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">框架也不鼓励这样做，因为它们的工作是通过隐藏底层细节和API使编程更容易开始。</p><p id="d2a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就产生了对框架的依赖，而这反过来又无助于给开发人员自己编码的信心。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="263e" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">使用依赖关系就是外包你的业务</h1><p id="ac83" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">当你在应用中使用依赖时，你基本上是把这部分外包给了其他开发者，所以你最好确定那个人做得很好。</p><p id="2b22" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有一家公司，你把客户服务外包给其他公司，如果他们搞砸了，你就有大麻烦了。如果他们对什么是好的客户服务有不同的看法呢？</p><p id="fc11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可能不会让这种情况发生，您应该以同样的方式对待应用程序中的依赖关系。这并不意味着您需要阅读所有依赖项的源代码，但至少您应该对它是如何工作的有一个坚实的概念。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><h1 id="1a21" class="mg mh it bd mi mj mk ml mm mn mo mp mq jz mr ka ms kc mt kd mu kf mv kg mw mx bi translated">了解基础</h1><p id="2fcc" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">但是要做到这一点，您首先应该对普通JavaScript编程有一个坚实的理解，因为这是所有编程的基础。</p><p id="3b2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前端框架肯定会带来价值，但也会带来复杂性和开销。我经历过学习和实现几个框架的痛苦，我可以告诉你，你需要确保努力是值得的。</p><p id="3a05" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">没有理由不使用原生平台，你会惊讶地看到<a class="ae ky" href="https://itnext.io/using-the-dom-like-a-pro-163a6c552eba?source=friends_link&amp;sk=3e723a0f3c548d9b4b7c11d354a26659" rel="noopener ugc nofollow" target="_blank">如今它所提供的</a>。</p><p id="097c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要人云亦云，说你不应该重新发明轮子。首先学习基础，然后<em class="nd">再</em>决定你是否真的需要那个库或框架。</p><p id="b549" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会成为更好的开发者。</p></div></div>    
</body>
</html>