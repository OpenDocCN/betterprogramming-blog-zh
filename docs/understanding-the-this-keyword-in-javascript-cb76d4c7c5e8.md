# 理解 JavaScript 中的“this”关键字

> 原文：<https://betterprogramming.pub/understanding-the-this-keyword-in-javascript-cb76d4c7c5e8>

## 在不同的场景中“this”的值是如何分配的

![](img/5ceac07abe5534dbe67cd336325b01c7.png)

[图像信用](https://www.zeolearn.com/magazine/understanding-the-this-keyword-in-javascript)

在本文中，我们将学习 JavaScript 关键字`this`以及在不同场景中`this`的值是如何分配的。理解本文内容的最佳方式是在浏览器控制台中快速执行代码片段。按照以下步骤在您的 Chrome 浏览器中启动控制台:

*   在 Chrome 中打开新标签页
*   右键单击页面，并从上下文菜单中选择“检查元素”
*   转到控制台面板
*   开始执行 JavaScript 代码

对象是 JavaScript 中的基本构件。JavaScript 中有一个特殊的对象，`this`对象。您可以在 JavaScript 执行的每一行看到`this`的值。`this`的值是根据代码的执行方式决定的。

在开始使用`this`之前，我们需要了解一点 JavaScript 运行时环境以及 JavaScript 代码是如何执行的。

# **执行上下文**

执行该行的环境(或范围)被称为*执行上下文*。JavaScript 运行时维护这些执行上下文的堆栈，位于堆栈顶部的执行上下文是当前正在执行的上下文。对象`this`指每次执行上下文改变时的改变。

# **“此”指一个全局对象**

默认情况下，执行的执行上下文是全局的——这意味着如果代码作为简单函数调用的一部分被执行，那么`this`指的是一个全局对象。

在浏览器的情况下,`window`对象是全局对象。而在 NodeJS 环境中，一个叫做`global`的特殊对象将是`this`的值。

例如:

# **立即调用函数表达式(life)**

如果为任何功能启用了严格模式，那么`this`的值将被标记为`undefined`,如同在严格模式中一样。全局对象引用`undefined`代替`windows`对象。

例如:

`foo();`将 false 打印到控制台，因为在严格模式下，全局执行上下文中`this`的值是`undefined`。

# **“这”是指一个新的实例**

当用`new`关键字调用一个函数时，这个函数被称为构造函数，并返回一个新的实例。在这种情况下，`this`的值指的是一个新创建的实例。

例如:

在`person.displayName`的情况下，`this`是指一个新的实例人，在`person2.displayName()`的情况下，`this`是指`person2`(与`Person`是不同的实例)。

# **“这个”是指一个调用程序对象(父对象)**

在 JavaScript 中，对象的属性可以是方法或简单的值。当一个对象的方法被调用时，那么`this`指的是包含被调用方法的对象。

在这个例子中，我们将使用第一个例子中定义的方法`foo`。

`user.foo()`打印 false，因为现在`this`引用用户对象而不是全局对象。

通过上面的例子，很清楚`this`的值在某些情况下是如何令人困惑的。

`foo1`的函数定义是相同的，但是当它作为一个简单的函数调用被调用时，那么`this`指的是一个全局对象。当同一个定义作为一个对象的方法被调用时，那么`this`引用父对象。所以`this`的值取决于方法是如何被调用的。

# **“此”同调用和应用方法**

JavaScript 中的函数也是一种特殊类型的对象。每个函数都有`call`、`bind`和`apply`方法。这些方法可用于在函数的执行上下文中为`this`设置一个自定义值。

我们将使用上面定义的第二个例子来解释`call`的用法:

`call`和`apply`方法之间的唯一区别是传递参数的方式。在`apply`的情况下，第二个参数是一个参数数组，而在`call`方法的情况下，参数是单独传递的。

# **“这个”用的是绑定方法**

`bind`方法返回一个新方法，其中`this`引用传递的第一个参数。我们将使用上面的例子来解释`bind`方法。

# **“this”带有粗箭头功能**

作为 ES6 的一部分，引入了一种新的方法来定义函数。

让 displayName = (fn，ln) => {

console.log(名称:$ { fn } $ { ln })；

};

当使用粗箭头时，它不会为`this`创建新值。`this`继续引用它在函数外引用的同一个对象。

让我们再看一些例子来测试我们对`this`的知识。

因为回调是作为一个简单的函数调用在一个多重函数中被调用的，`this`引用回调方法的执行上下文中的全局对象`windows`。

`test()`打印 true，因为`count`变量声明发生在全局执行上下文中，所以`count`将成为全局对象的一部分。

# **总结**

所以现在你可以通过遵循这些简单的规则计算出`this`的值:

*   默认情况下，`this`是指一个全局对象，对于 NodeJS 来说是全局的，对于浏览器来说是一个`window`对象
*   当一个方法作为一个对象的属性被调用时，那么`this`指的是父对象
*   当用`new`操作符调用一个函数时，那么`this`引用新创建的实例
*   当使用`call`和`apply`方法调用函数时，`this`引用作为`call`或`apply`方法的第一个参数传递的值

正如你在上面看到的，`this`的值有时会令人困惑，但是上面的规则可以帮助你计算出`this`的值。