<html>
<head>
<title>Asynchronous Communication — Creating Atomic Workflows</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步通信—创建原子工作流</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/asynchronous-communication-creating-atomic-workflows-4ce997e2ac6e?source=collection_archive---------10-----------------------#2022-01-09">https://betterprogramming.pub/asynchronous-communication-creating-atomic-workflows-4ce997e2ac6e?source=collection_archive---------10-----------------------#2022-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d7dd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在物理分布、时间分离的系统中构建原子工作流？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/19ad1df4384f6e3fed7d93a1aab65097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VIrtJQEDoG4l-ivg"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">约翰·施诺布里奇在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</p></figure><p id="013f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原子性——一个粗略的定义可能是“要么全部要么什么都没有”。</p><p id="0469" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着涉及多个步骤的业务操作/任务应该作为一个单元来执行。要么所有步骤都正确执行，要么在出现任何错误的情况下，让系统保持干净的状态，就像什么都没发生过一样。</p><p id="29eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而原子性很容易用更新数据库中的记录(在事务范围内)的单进程应用程序来实现，因为数据库引擎确保了事务的原子性。</p><p id="063e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着我们的任务从单进程应用程序转移到多进程应用程序，确保原子性的复杂性开始显现。当我们处理分布式流程时，它会增加几倍，在这种情况下，流程和基础结构可能超出我们的控制。</p><p id="904c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们所讨论的错误包括从业务错误(未配置的特定情况)和基础设施错误到应用程序错误。</p><p id="44b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">处理这种可能性的方法是接受失败，并通过实现恢复机制为失败做好准备。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="efa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在分布式事务的上下文中,“两阶段提交”模式经常出现，为了排除它作为一种可能的解决方案，我想快速地讨论一下它。</p><p id="1df5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原则上，它通过获取每个参与者的锁来工作，作为阶段1。一旦所有参与者都获得了锁，那么阶段2就是实际的提交阶段。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/b493e32a5e563dc9bc0374d507f65878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDUzmAez_knuorTgbmYtrA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">两阶段提交—显示为反模式</p></figure><p id="83ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在异步系统中，它变成了一个反模式，因为锁产生了耦合。在上图中，服务A获得了一组记录的锁&amp;直到服务C参与事务的意愿得到确认(或者直到锁超时)，它才会释放锁。</p><p id="3770" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使服务响应足够快，随着请求数量、操作持续时间或参与服务的增加，这种方法也不能很好地扩展。它给系统带来了延迟，并增加了遇到服务间死锁的可能性。</p><p id="f190" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，它不接受失败。如果我们开始考虑在分布式环境中什么可能出错&amp;尝试用两阶段提交来减少所有这些可能性，留给我们的问题会比解决方案更多。</p><p id="117c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">也许可以在一个简单、短暂的场景中明智地使用它，该场景只涉及几个服务，但是它不适合异步参与者&amp;这当然是一个扩展的挑战。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="c413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何在物理分布、时间分离的系统中构建原子工作流？</p><h1 id="7907" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated"><strong class="ak">避免锁定、保存状态并实现恢复——传奇模式</strong></h1><p id="4b73" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">在Saga模式中，我们将工作流分解成可以自动执行的离散步骤。因此，我们不需要获得整个传奇的锁。</p><p id="e625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个步骤都可以私下保存其状态，或者Saga可以实现保存点步骤。当故障确实发生时，这个保存的状态然后被用于执行恢复。</p><p id="ad1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原来佐贺论文是<a class="ae kv" href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf" rel="noopener ugc nofollow" target="_blank">这里的</a>。虽然它是围绕数据库操作编写的，但它讨论了向前恢复、向后恢复和混合恢复。因此，与现代微服务架构相关。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/fc3da230d0c8dc0936b565aaeb441694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nBpZWvAMs7W4VLlrXWOjFA.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">逻辑视图—回滚/向后恢复传奇显示为双链接命令列表。其中每个命令都具有执行动作和恢复动作的能力。</p></figure><p id="d718" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据它如何影响系统的状态以及在失败的情况下可以做什么，一个传奇的每一步都可以被归类为以下之一。</p><ol class=""><li id="d458" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated"><em class="nh">可补偿交易</em>:这些可以通过启动补偿交易来撤销或取消。例如，客户支付的错误发票可以通过开具贷方票据来补偿。为了便于讨论，假设补偿交易本身失败了，在这种情况下，人工干预通常可以简化流程，比如发布人工贷方通知单。</li><li id="bf65" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated"><em class="nh">幂等事务</em>:这些不会改变系统的状态。因此，可以多次执行。例如，读取数据、生成报告、转换给定的数据。</li><li id="e6f1" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">枢纽交易:这些是故事的关键。当他们成功时，传奇中的任何后续交易都必须成功。在这样的事务之后有一个保存点是很有帮助的。</li></ol><p id="8064" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当创建一个关于微服务的传奇时，由参与的微服务来承诺其步骤的原子性。在服务支持补偿事务的情况下，补偿所需的数据可以由服务存储在其本地数据存储中，或者Saga可以存储该数据并在启动补偿事务时将其传递给服务。</p><p id="be0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">saga恢复的类型:根据步骤和业务的性质，我们可以通过构建以下恢复步骤来设计我们的Saga</p><ol class=""><li id="cccf" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">向后/回滚恢复—当补偿事务是可能的，并且我们需要给出中止选项时(上面给出的逻辑视图)。</li><li id="5fb8" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">前向恢复—当回滚事件不可行时，工作流必须完整。Saga可以保存状态，以便从发生中断的步骤恢复，方法是重试或采用替代恢复块，或者期待手动干预。</li><li id="866b" class="my mz iq ky b kz ni lc nj lf nk lj nl ln nm lr nd ne nf ng bi translated">混合—在这种情况下，一些故障可能需要向后恢复，而其他故障可能需要向前恢复。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/2c76741cc4197537781f5b284610c972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*otSaa0IVI1tvgAiBfnBcrQ.png"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">为一个帐户模拟一个假设的信用卡对帐单生成工作流。</p></figure><p id="1cd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实现Saga:正如我们在讨论微服务之间的交互。一种可能性是实现与Orchestrator服务(如AWS Step Function)的交互，其中每个建模的步骤都用失败路径显式实现(在源代码中)。</p><p id="45ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常有帮助，不仅可以很好地概述整个过程，还可以显示在任何给定时间正在执行的传奇的状态。</p><p id="91c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过尽可能并行地运行任务，以及在继续之前等待基于事件的操作完成，来支持异步操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/f5ddea9cee977d0cdbd29e80caf1b3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*lTdbO-o8WIt0UVvv6-KIVw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">在AWS步骤函数中实现Saga。</p></figure><p id="7f9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一方面，如果有令人信服的理由选择更加分离的架构，比如在几个部门/团队之间分担责任，那么就有可能将传奇作为精心设计的传奇来实现。</p><p id="218d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，建模的传奇永远不会被显式地实现，相反，它是作为通过事件进行通信的服务的交互出现的。出于同样的原因，很难理解这个系统是如何运作的。</p><p id="5705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它也缺乏一个在任何给定时间的传奇故事在哪里的概述。通过开发/使用监控服务，可以在一定程度上缓解这种情况，该服务读取作为传奇的一部分发出的所有事件，并通过使用关联id形成一幅画面。</p><p id="d6bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于编排与编排的更多信息，我可以推荐这篇优秀的<a class="ae kv" href="https://theburningmonk.com/2020/08/choreography-vs-orchestration-in-the-land-of-serverless/" rel="noopener ugc nofollow" target="_blank">文章</a>，作者<a class="np nq ep" href="https://medium.com/u/d00f1e6b06a2?source=post_page-----4ce997e2ac6e--------------------------------" rel="noopener" target="_blank">崔琰</a></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="5d86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你觉得这篇文章很有用，如果你有任何反馈，请告诉我。</p><p id="f18c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我为将来的文章保留的是传奇中可能出现的异常，以及如何对服务本身进行建模，以保证它们对传奇承诺的契约。</p></div></div>    
</body>
</html>