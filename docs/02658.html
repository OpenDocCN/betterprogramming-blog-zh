<html>
<head>
<title>Build, Test, and Deploy a Flask Application: Part 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建、测试和部署Flask应用程序:第4部分</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/build-test-and-deploy-a-flask-application-part-4-5aa4f079fadb?source=collection_archive---------13-----------------------#2019-12-15">https://betterprogramming.pub/build-test-and-deploy-a-flask-application-part-4-5aa4f079fadb?source=collection_archive---------13-----------------------#2019-12-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a179" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重组测试</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fda9f05d78464b27aef221a3ef24b2c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5XKehWiJPCtTNnkS"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@yomex4life?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yomex Owo </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e2d5" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">关于本教程的元信息</h1><h2 id="92e0" class="lv le iq bd lf lw lx dn lj ly lz dp ln ma mb mc lp md me mf lr mg mh mi lt mj bi translated">学习目标</h2><ul class=""><li id="fedd" class="mk ml iq mm b mn mo mp mq ma mr md ms mg mt mu mv mw mx my bi translated">单元测试</li></ul><p id="a24b" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">注:本教程是<a class="ae kv" href="https://medium.com/@neohao/learn-flask-in-a-scientific-way-baf4d8055f6e" rel="noopener"> <em class="no">科学学烧瓶</em> </a> <em class="no">系列的一部分。</em></p><h2 id="ce59" class="lv le iq bd lf lw lx dn lj ly lz dp ln ma mb mc lp md me mf lr mg mh mi lt mj bi translated">源代码</h2><ul class=""><li id="3c60" class="mk ml iq mm b mn mo mp mq ma mr md ms mg mt mu mv mw mx my bi translated">本教程的源代码可以在<a class="ae kv" href="https://github.com/Neo-Hao/mean-review-collector" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获取。</li><li id="5f43" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated">该演示可在https://pacific-fortress-91193.herokuapp.com/的<a class="ae kv" href="https://pacific-fortress-91193.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">获得。</a></li><li id="3071" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated">仅涵盖本教程的版本可在此处访问<a class="ae kv" href="https://github.com/Neo-Hao/mean-review-collector/tree/249a754ec97fcbb984d529aa834058b0ce0b250f" rel="noopener ugc nofollow" target="_blank">。</a></li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="2eed" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">将应用程序作为软件包安装</h1><p id="76de" class="pw-post-body-paragraph mz na iq mm b mn mo jr nc mp mq ju ne ma nu ng nh md nv nj nk mg nw nm nn mu ij bi translated">随着我们转向使用应用工厂和蓝图，我们测试代码也需要一些升级。为了使采用应用工厂和蓝图的应用程序对不同文件夹下的测试代码可见，我们需要首先将应用程序作为一个包安装。实现这一点有三个步骤。</p><p id="8603" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">首先，我们需要记录所有的包依赖关系。这一点很重要，尤其是当您需要在不同的机器/虚拟环境中复制您所拥有的东西时(例如，部署)。为此，通过终端导航到目录的根目录(<code class="fe nx ny nz oa b">mean-review-collector</code>)，然后键入:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="8652" class="lv le iq oa b gy of og l oh oi">(env) $ pip freeze &gt;requirements.txt</span></pre><p id="93ee" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">您将看到一个在根目录下生成的文件<code class="fe nx ny nz oa b">requirements.txt</code>,它包含了包名和它们的确切版本号。</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="ff35" class="lv le iq oa b gy of og l oh oi">Flask==1.1.1<br/>Jinja2==2.10.3<br/>...<br/>wcwidth==0.1.7<br/>Werkzeug==0.16.0<br/>zipp==0.6.0</span></pre><p id="bd4f" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">当您想要在不同的虚拟环境中构建副本时，只需键入:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="86ae" class="lv le iq oa b gy of og l oh oi">(env) $ pip install -r requirements.txt MANIFEST.in</span></pre><p id="c3a1" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">其次，我们需要描述我们的项目。描述依赖于两个文件:<code class="fe nx ny nz oa b">setup.py</code>和<code class="fe nx ny nz oa b">MANIFEST.IN</code>。这两个文件是使我们的<code class="fe nx ny nz oa b">app</code>可安装所需要的。<code class="fe nx ny nz oa b">setup.py</code>包含关于我们申请的基本信息:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5775" class="lv le iq oa b gy of og l oh oi">from setuptools import find_packages, setup</span><span id="d94b" class="lv le iq oa b gy oj og l oh oi">setup(<br/>    name='app',<br/>    version='0.1',<br/>    packages=find_packages(),<br/>    include_package_data=True,<br/>    zip_safe=False,<br/>    install_requires=[<br/>        'flask',<br/>    ],<br/>)</span></pre><p id="18dc" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated"><code class="fe nx ny nz oa b">include_package_data=True</code>表示我们希望为此项目包含额外的数据。<code class="fe nx ny nz oa b">MANIFEST.IN</code>包括本项目数据的基本信息，如模板和<code class="fe nx ny nz oa b">sql</code>文件；</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5d5c" class="lv le iq oa b gy of og l oh oi">include app/schema.sql<br/>graft app/static<br/>graft app/templates<br/>global-exclude *.pyc</span></pre><p id="f741" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">第三，我们需要将自己的代码作为一个包安装在<code class="fe nx ny nz oa b">app</code>中。使用<code class="fe nx ny nz oa b">pip install</code>，安装只有一行:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="ac71" class="lv le iq oa b gy of og l oh oi">(env)$ pip install -e .</span></pre><p id="9dc9" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">然而，<code class="fe nx ny nz oa b">install</code>值得一些详细的解释。通常，当你通过<code class="fe nx ny nz oa b">pip nstall</code>安装Python包时，<code class="fe nx ny nz oa b">pip</code>会在Python包索引中寻找目标包。但是，pip也可以查找其他地方的包(例如，本地机器上的代码)。</p><p id="755a" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">上面的一行代码实际上是将您的代码复制到<code class="fe nx ny nz oa b">env</code>文件夹中，并像您在这个虚拟环境中安装的任何其他包一样对待它。圆点表示您当前的目录。标志<code class="fe nx ny nz oa b">-e</code>使它成为一个可编辑的安装——如果您对项目文件夹中的文件做进一步的更改，这些更改也会自动反映在<code class="fe nx ny nz oa b">env</code>文件夹中。</p><p id="7858" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">现在，您可以检查该虚拟环境中所有已安装的软件包:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="90b9" class="lv le iq oa b gy of og l oh oi">(env)$ pip list</span></pre><p id="2160" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">您将看到如下内容:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="a920" class="lv le iq oa b gy of og l oh oi">Package            Version Location                               <br/>------------------ ------- ---------------------------------------<br/>app                0.1     /home/qiang/repos/mean-review-collector<br/>attrs              19.3.0  <br/>Click              7.0     <br/>Flask              1.1.1   <br/>...</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="3cc9" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">单元测试</h1><p id="9a92" class="pw-post-body-paragraph mz na iq mm b mn mo jr nc mp mq ju ne ma nu ng nh md nv nj nk mg nw nm nn mu ij bi translated">我们要做的下一件事是重写我们的单元测试用例。我们使用<code class="fe nx ny nz oa b">unittest</code>只是为了方便。从现在开始，我们将从<code class="fe nx ny nz oa b">unittest</code>切换到<code class="fe nx ny nz oa b">pytest</code>。虽然<code class="fe nx ny nz oa b">pytest</code>不在Python的标准库中，但是在很多方面都比<code class="fe nx ny nz oa b">unittest</code>好。要安装<code class="fe nx ny nz oa b">pytest</code>和另一个工具<code class="fe nx ny nz oa b">coverage</code>(测量你的测试的代码覆盖率)，我们只需要通过你的终端输入:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="18ca" class="lv le iq oa b gy of og l oh oi">(env)$ pip install pytest coverage</span></pre><p id="f874" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">默认情况下，<code class="fe nx ny nz oa b">pytest</code>只标识名称以<code class="fe nx ny nz oa b">test_</code>开头或以<code class="fe nx ny nz oa b">_test</code>结尾的测试文件或方法。我们至少要测试三个方面，包括工厂、数据库和认证，所以我们需要在<code class="fe nx ny nz oa b">tests</code>目录下有三个文件:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="cf73" class="lv le iq oa b gy of og l oh oi">mean-review-collector<br/> - env<br/> - app<br/> - instance<br/> - tests   <br/>   - test_auth.py<br/>   - test_db.py<br/>   - test_factory.py</span></pre><p id="f8c1" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">当所有的测试代码都准备好了，您只需在您的终端上输入pytest就可以运行所有的测试代码，您可能会看到类似如下的内容:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="284e" class="lv le iq oa b gy of og l oh oi">(env)$ pytest<br/>=============== test session starts ===========================<br/>platform linux -- Python 3.7.4, pytest-5.3.1, py-1.8.0, pluggy-0.13.1<br/>rootdir: /home/qiang/repos/mean-review-collector<br/>collected 7 items</span><span id="ab93" class="lv le iq oa b gy oj og l oh oi">tests/test_auth.py .. [ 42%]<br/>tests/test_db.py .. [ 71%]<br/>tests/test_factory.py .. [100%]</span></pre><p id="6fc5" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">在我们急于在每个文件中编写测试代码之前，我们应该认识到，在任何单元测试之前，某些代码总是需要首先执行，例如连接到数据库和启动一个应用程序对象。<code class="fe nx ny nz oa b">pytest</code>使用<code class="fe nx ny nz oa b">fixture</code>来处理这样的代码。fixtures的目的是提供一个固定的基线，测试可以在这个基线上可靠地重复执行。为了实现这一点，我们将把这样的代码放在一个名为<code class="fe nx ny nz oa b">conftest.py</code>的不同文件中。例如，我们当然需要一些代码来帮助我们启动一个应用程序对象:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="6a8b" class="lv le iq oa b gy of og l oh oi">#conftest.py</span><span id="a014" class="lv le iq oa b gy oj og l oh oi">@pytest.fixture<br/>def app():<br/>  db_fd, db_path = tempfile.mkstemp()</span><span id="9b9e" class="lv le iq oa b gy oj og l oh oi">  app = create_app({<br/>        'TESTING': True,<br/>        'DATABASE': db_path,<br/>  })</span><span id="ff16" class="lv le iq oa b gy oj og l oh oi">  with app.app_context():<br/>        init_db()</span><span id="1156" class="lv le iq oa b gy oj og l oh oi">  yield app</span><span id="edd6" class="lv le iq oa b gy oj og l oh oi">  os.close(db_fd)<br/>  os.unlink(db_path)</span></pre><p id="bbc9" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated"><code class="fe nx ny nz oa b">pytest</code>使用装饰器将一个函数标识为fixture——一个应该在每次测试之前首先执行的函数。</p><p id="01dd" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">尽管对数据库和认证的测试与我们使用<code class="fe nx ny nz oa b">unittest</code>的旧测试代码非常相似，但我们仍然想强调两个不同之处。</p><p id="c02e" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">首先，parametrize可用于测试函数的各种输入:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5f54" class="lv le iq oa b gy of og l oh oi"># test_auth.py</span><span id="01de" class="lv le iq oa b gy oj og l oh oi">@pytest.mark.parametrize(('username', 'password', 'message'), (<br/>  ('', '', b'Username is required.'),<br/>  ('<a class="ae kv" href="mailto:a@c.com" rel="noopener ugc nofollow" target="_blank">a@c.com</a>', '', b'Password is required.'),<br/>  ('<a class="ae kv" href="mailto:a@b.com" rel="noopener ugc nofollow" target="_blank">a@b.com</a>', 'test', b'already registered'),<br/>))<br/>def test_register_validate_input(client, username, password, message):<br/>  response = client.post(<br/>    '/register',<br/>    data={'username': username, 'password': password}<br/>  )<br/>  assert message in response.data</span></pre><p id="da09" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">这是通过使用<code class="fe nx ny nz oa b">pytest.mark</code>decorator测试函数来实现的。</p><p id="7a24" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">其次，monkeypatch可能是一个有用的测试工具。以下代码基本上遵循了<a class="ae kv" href="https://flask.palletsprojects.com/en/1.1.x/tutorial/tests/" rel="noopener ugc nofollow" target="_blank"> Flask官方教程</a>的指导:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5ef0" class="lv le iq oa b gy of og l oh oi">def test_init_db_command(runner, monkeypatch):<br/>  class Recorder(object):<br/>    called = False</span><span id="9000" class="lv le iq oa b gy oj og l oh oi">  def fake_init_db():<br/>    Recorder.called = True</span><span id="624a" class="lv le iq oa b gy oj og l oh oi">  monkeypatch.setattr('app.db.init_db', fake_init_db)<br/>  result = runner.invoke(args=['init-db'])<br/>  assert 'Initialized' in result.output<br/>  assert Recorder.called</span></pre><p id="afef" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">然而，官方教程并没有真正解释monkeypatch。monkeypatch在运行时动态地改变一个软件(例如，模块、对象、方法或函数)。Pytest使用这个特性来测试您不想实际执行的函数或方法。</p><p id="e450" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">例如，我们有一个名为get_info的函数，如下所示:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="b047" class="lv le iq oa b gy of og l oh oi">def get_info():<br/>  <em class="no">"""<br/>  call GET for http://XXX/get<br/>  returns status code and url in HTTP response<br/>  """<br/>  </em>r = requests.get(base_url + 'get')<br/><br/>  if r.status_code != 200:<br/>    return r.status_code, ''<br/>  else:<br/>    response_data = r.json()<br/>    return r.status_code, response_data["url"]</span></pre><p id="a9a3" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">我们可以使用monkeypatch测试这个函数，而不需要让它实际发送HTTP请求:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5372" class="lv le iq oa b gy of og l oh oi">def test_get_info(monkeypatch):<em class="no"><br/>  </em>class ResponseMock(object):<br/>    def __init__(self):<br/>      self.status_code = 200<br/>      self.url = ''<br/>      self.headers = {}<br/><br/>    def json(self):<br/>      return {'account': '123','url': 'http://test.com'}<br/><br/>    def get_patched(url):<br/>        return ResponseMock()<br/><br/>    monkeypatch.setattr(requests, 'get', get_patched)<br/>    assert get_info() == (200, 'http://test.com')</span></pre><p id="6fa0" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">monkeypatch在这里实现的本质上是用您在<code class="fe nx ny nz oa b">get_patched</code>下定义的内容替换<code class="fe nx ny nz oa b">requests.get()</code>的行为。同样，在我们的<code class="fe nx ny nz oa b">test_init_db_command</code>方法中:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="7cb3" class="lv le iq oa b gy of og l oh oi">monkeypatch.setattr('app.db.init_db', fake_init_db)</span></pre><p id="ad4d" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">我们本质上给<code class="fe nx ny nz oa b">app.db.init_db</code>附加了一些新的行为。新行为正在<code class="fe nx ny nz oa b">fake_init_db</code>下定义。这个方法实际实现的唯一事情是添加一个新的字段记录器，调用<code class="fe nx ny nz oa b">app.db.init_db</code>来跟踪它是否被执行。</p><p id="3367" class="pw-post-body-paragraph mz na iq mm b mn nb jr nc mp nd ju ne ma nf ng nh md ni nj nk mg nl nm nn mu ij bi translated">请点击查看我们重组后的单元测试<a class="ae kv" href="https://github.com/Neo-Hao/mean-review-collector/tree/249a754ec97fcbb984d529aa834058b0ce0b250f" rel="noopener ugc nofollow" target="_blank">的最终代码。</a></p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="bf37" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">教程列表</h1><ul class=""><li id="d8fc" class="mk ml iq mm b mn mo mp mq ma mr md ms mg mt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/@neohao/build-test-and-deploy-a-mini-flask-application-1d9ca6c45115" rel="noopener">构建并测试迷你烧瓶应用程序</a></li><li id="e240" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/better-programming/build-test-and-deploy-an-interactive-flask-application-part-i-templates-53a7b0cbe760" rel="noopener">构建、测试和部署Flask应用程序:第1部分——模板</a></li><li id="ada3" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/better-programming/build-test-and-deploy-a-flask-application-part-2-53f2c8df3ebc" rel="noopener">构建、测试和部署Flask应用程序:第2部分——认证</a></li><li id="78c5" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/@neohao/build-test-and-deploy-a-flask-application-part-3-3a2abfe4be21" rel="noopener">构建、测试和部署Flask应用程序:第3部分——应用程序工厂和蓝图</a></li><li id="c985" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/@neohao/build-test-and-deploy-a-flask-application-part-4-5aa4f079fadb" rel="noopener">构建、测试和部署Flask应用程序:第4部分——重构测试</a></li><li id="0517" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/@neohao/build-test-and-deploy-a-flask-application-part-5-4a3c0bc36b8e" rel="noopener">构建、测试和部署Flask应用程序:第5部分—认证(续)</a></li><li id="0eca" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/@neohao/build-test-and-deploy-a-flask-application-part-6-952a1b29a02a" rel="noopener">构建、测试和部署Flask应用程序:第6部分——评审系统</a></li><li id="4c68" class="mk ml iq mm b mn np mp nq ma nr md ns mg nt mu mv mw mx my bi translated"><a class="ae kv" href="https://medium.com/@neohao/build-test-and-deploy-a-flask-application-part-7-60dde9080330" rel="noopener">构建、测试和部署Flask应用程序:第7部分——部署</a></li></ul></div></div>    
</body>
</html>