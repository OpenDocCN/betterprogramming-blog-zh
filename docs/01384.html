<html>
<head>
<title>Web Performance: Minimising DOM Reflow / Layout Shift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web性能:最小化DOM重排/布局偏移</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/web-performance-dom-reflow-76ac7c4d2d4f?source=collection_archive---------1-----------------------#2019-09-05">https://betterprogramming.pub/web-performance-dom-reflow-76ac7c4d2d4f?source=collection_archive---------1-----------------------#2019-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a20e29fd0b161a1cdac07f67aed18bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vJsbJ295o-fr1M65"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@halgatewood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈尔·盖特伍德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</p></figure><blockquote class="kg kh ki"><p id="14f1" class="kj kk kl km b kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh im bi translated"><strong class="km iu">本文已更新！最新内容请关注</strong> <a class="ae kf" href="https://www.charistheo.io/blog/2021/09/dom-reflow-and-layout-thrashing/" rel="noopener ugc nofollow" target="_blank"> <strong class="km iu">此链接</strong> </a> <strong class="km iu">。</strong></p></blockquote></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><p id="6a52" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">在这篇文章中，我将列出DOM reflow / layout shift事件可能发生的几种方式，为什么它是坏的，如何跟踪这些事件，以及如何最小化它的发生以减轻它的影响。</p><p id="d681" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">对于本文的其余部分，我将假设您熟悉前端开发组件，如CSS、浏览器DOM和使用JavaScript访问HTML元素。</p><p id="d02f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">现在让我们开始吧。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="b7e2" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">什么是DOM回流/布局偏移？</h1><p id="4d5b" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">重要的事情先来。我将要解释的过程有两个名称:</p><ul class=""><li id="1360" class="mv mw it km b kn ko kr ks lp mx lq my lr mz lh na nb nc nd bi translated">火狐中的DOM回流</li><li id="9ec9" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">在Chrome/Safari/Opera/IE中<em class="kl">布局</em>或<em class="kl">布局移位</em></li></ul><p id="da0b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">两者都是指同一个过程，那么为什么同一个东西会有两个名字呢？我想这就是web开发世界的样子。</p><p id="a97c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">无论如何，为了避免混淆，我将在本文的其余部分使用术语<em class="kl">回流</em>。对！那么什么是回流呢？</p><p id="9935" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">简单地说，重排是一种用户阻止的操作，它计算文档的布局。元素上的重排是对其在文档中的尺寸和位置的计算。</p><h2 id="a28b" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">当它发生时</h2><p id="28f9" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">DOM reflow发生的频率比您预期的要高。它发生在以下情况:</p><ul class=""><li id="2e8b" class="mv mw it km b kn ko kr ks lp mx lq my lr mz lh na nb nc nd bi translated">在DOM中插入/移除/更新元素</li><li id="01da" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">修改页面上的内容，例如输入框中的文本</li><li id="939c" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">移动DOM元素</li><li id="c877" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">制作DOM元素的动画</li><li id="8e3b" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">测量元素(<code class="fe nv nw nx ny b">offsetHeight</code>或<code class="fe nv nw nx ny b">getComputedStyle</code>)</li><li id="fde4" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">更改CSS样式</li><li id="5c20" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">设置<code class="fe nv nw nx ny b">style</code>属性的一个属性</li><li id="d66b" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">改变元素的<code class="fe nv nw nx ny b">class</code></li><li id="eac9" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">添加/移除样式表</li><li id="7c74" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">调整窗口大小</li><li id="46e9" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">卷动</li><li id="07cf" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">更改字体</li><li id="88df" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">激活CSS-伪类，如<code class="fe nv nw nx ny b">:hover</code></li></ul><p id="473b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">要获得更详细的列表，请查看触发回流、绘画和合成的CSS属性的<a class="ae kf" href="https://csstriggers.com" rel="noopener ugc nofollow" target="_blank">列表和触发回流的JavaScript代码的</a>列表。</p><h2 id="d140" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">回流雪崩效应</h2><p id="3afa" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">请注意，在元素上触发的回流很可能会在它周围的元素上触发后续回流，因为这也会改变它们的位置/布局。</p><h2 id="d4df" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">为什么不好</h2><ul class=""><li id="0662" class="mv mw it km b kn mq kr mr lp nz lq oa lr ob lh na nb nc nd bi translated">需要CPU能力</li><li id="0968" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">增加<a class="ae kf" href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint" rel="noopener ugc nofollow" target="_blank">第一次有意义的绘画</a>时间</li><li id="4c0f" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">增加<a class="ae kf" href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint" rel="noopener ugc nofollow" target="_blank">第一次内容绘制</a>时间</li><li id="4636" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated">因为这是一个阻塞操作，所以造成了糟糕的用户体验</li></ul><p id="3ea9" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">我知道。如果你以前没有听说过这个回流的事情，你现在一定很恐慌。几乎每次与DOM的交互都会触发这种阻塞操作。如果你在想，“哦，对了，所以我不能使用任何CSS，也不能操作DOM，所以我怎么才能让自己有用呢？”</p><p id="5d02" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">别担心，我的朋友。总会有回流。</p><p id="410d" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">作为web开发人员，我们的工作是通过降低事件数量和减轻其影响来优化速度。</p><h2 id="6d27" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">这叫工程，我的朋友</h2><p id="d52d" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">就像f1工程师通过测量、校准和重复来优化速度一样，我们作为web开发人员需要测量性能、识别瓶颈、进行修复，并再次重复。</p><p id="75d1" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">确保每次做出改变时，在新的修正之前，再次测量并比较结果。在某个网站上有效的不一定在另一个网站上有效。</p><p id="0433" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">现在让我们来看看一些方法，通过这些方法我们可以写出更好的代码并尽可能少地触发回流。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="f627" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">最小化回流事件的方法</h1><p id="398e" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">因此，让我们来看看一些优化速度的方法。希望在这一部分之后，你会感觉自己更像一名超人f1工程师。</p><h2 id="4568" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">批量编辑HTML元素</h2><p id="0cf4" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">如果要在JavaScript代码中的某个地方多次更改DOM元素，请在将它从DOM中移除后再做。</p><figure class="oc od oe of gt ju"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="280a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">批量编辑移除的元素，并将其添加回DOM。</p><figure class="oc od oe of gt ju"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="b21e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">或者，您可以隐藏元素，编辑它，然后再次显示它。</p><figure class="oc od oe of gt ju"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0d35" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">请注意，在这两种情况下，回流都会被触发两次，所以请确保在回流过多的情况下使用这种技术。</p><h2 id="0f04" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">编辑树中尽可能低的元素</h2><p id="5508" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">由于回流螺旋效应，建议在树中尽可能低的位置触发回流，以最小化可能在子元素上触发的后续回流。</p><p id="a979" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">假设您想要切换一个类以应用一组CSS样式，那么总是在您想要更改的元素上这样做，而不是在父元素上。如果在整个HTML文件中使用较少的包装器元素，您还可以获得一些性能改进。</p><h2 id="6df9" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">测量一次</h2><p id="7ce9" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">检查您的代码是否重复计算了元素的宽度，如<code class="fe nv nw nx ny b">element.offsetWidth</code>或<code class="fe nv nw nx ny b">$('element').width()</code>。将该值存储在一个变量中，并使用该变量。</p><p id="bb7f" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">未优化代码:</strong></p><figure class="oc od oe of gt ju"><div class="bz fp l di"><div class="og oh l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">代码是未优化的，因为它在循环中计算元素的高度</p></figure><p id="1ddd" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">优化代码:</strong></p><figure class="oc od oe of gt ju"><div class="bz fp l di"><div class="og oh l"/></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">代码得到了优化，因为它存储元素的高度值，并在循环中使用该值。同样，在将子元素再次添加到DOM之前，删除子元素以进行批量编辑。</p></figure><p id="d64a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">注意:</strong>你可能会冒写更多代码的风险，结果代码不可读。因此，一定要用一个合理的名字将这个过程包装在一个函数中，并添加一个注释来解释这个函数是性能优化的。</p><p id="659e" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">您可能已经注意到，优化后的代码在编辑其子代之前也会删除列表，因为每次添加一些边距时，它都会导致重排。如果您正在处理许多类似上述的情况，fastdom库可能会有所帮助。该库将允许您批量处理所有的测量或变异过程。</p><h2 id="da11" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">经常改变的固定/绝对位置元素</h2><p id="7d43" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">如果你的站点中有任何元素过于频繁地改变它们的布局，它们可能也会影响其他元素的布局，从而触发级联回流效应。</p><p id="5529" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">例如，当动画元素的尺寸(宽度和高度)时，最好用<code class="fe nv nw nx ny b">position: fixed</code>或<code class="fe nv nw nx ny b">position: absolute</code>定位该元素。这样，当改变宽度和高度时，动画元素将不会影响它周围的元素，从而减少不必要的回流的数量。</p><h2 id="34fe" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">对布局使用伸缩框</h2><p id="cbb6" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">从Google开发者的比较中可以看出，使用flex box代替floats时，性能略有提高(3.5毫秒对14毫秒)。然而，如果考虑到渲染了1，300个元素，这种比较可能不会透露太多信息——这是一个在普通网站上不常见的庞大数字。</p><p id="10e8" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">即使这样，也要确保尝试不同的布局技术，看看哪一种更适合您的情况。记住:测量、识别、修正和重复。</p><p id="0197" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">无论如何，您应该记住的是尽可能设置固定的宽度和高度，并确保在容器中添加或删除新元素时布局不会改变。</p><h2 id="60ce" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">改变可见性而不是显示</h2><p id="5f72" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">如果可能，使用<code class="fe nv nw nx ny b">visibility: hidden</code>和<code class="fe nv nw nx ny b">visibility: visible</code>而不是<code class="fe nv nw nx ny b">display: none</code>和<code class="fe nv nw nx ny b">display: block</code>隐藏或显示元素。</p><p id="dd48" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">关键在于，当将<code class="fe nv nw nx ny b">visibility</code>设置为<code class="fe nv nw nx ny b">hidden</code>时，元素仍然会占用DOM布局中的空间。这样，与改变<code class="fe nv nw nx ny b">display</code>属性相反，元素的宽度和高度不会改变，所以浏览器不需要重新计算(重排)布局。</p><p id="7155" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">因此，如果没有必要从布局中删除元素，只需使用<code class="fe nv nw nx ny b">visibility: hidden</code>，您将省去几次重排版。</p><h2 id="3fb6" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">对多个布局更改使用cssText</h2><p id="0ab8" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">如果您正在更改元素的内联样式，并且更喜欢从JavaScript动态添加它们，而不是切换CSS类，您可能会导致更多您可能理想想要的重排。</p><p id="23e6" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">未优化代码:</strong></p><figure class="oc od oe of gt ju"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="68c0" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">优化代码:</strong></p><figure class="oc od oe of gt ju"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="ee01" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">相反，你可以利用这个漂亮的HTML元素<code class="fe nv nw nx ny b">style</code>属性<code class="fe nv nw nx ny b">cssText</code>，一次添加多个样式。在上面的例子中，我们触发了一次回流，而不是两次(一次是针对<code class="fe nv nw nx ny b">left</code>属性，另一次是针对<code class="fe nv nw nx ny b">top</code>属性)。</p><p id="007a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated"><strong class="km iu">注意:</strong>确保在MDN Web文档中检查<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">浏览器兼容性</a>。</p><h2 id="34ff" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">使用textContent而不是innerText</h2><p id="e78f" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">当请求HTML元素的文本时，有两种方法可以做到:<code class="fe nv nw nx ny b"> element.textContent</code>，它返回一个元素中所有隐藏的<em class="kl"> </em>或<em class="kl"> </em>可见的文本，或者你可以通过使用<code class="fe nv nw nx ny b">element.innerText</code>得到它，它在返回可见文本之前需要在计算布局时进行回流。</p><p id="aaf2" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">你应该从中得到的是<code class="fe nv nw nx ny b">innerText</code>比<code class="fe nv nw nx ny b">textContent</code>有更多的性能含义，如果你能避免在你的代码中使用它，它将会减少重排版的数量，提高你的站点的性能。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="732a" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">衡量绩效</h1><p id="7bb3" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">正如我前面提到的，测量是优化过程中的一个重要步骤。识别哪些元素/进程导致了回流和重绘是非常棘手的。因此，在对代码进行任何更改之前和之后，测量您的站点的性能可以证明有助于跟踪什么工作，什么不工作。</p><p id="2aa3" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">为此，我建议使用Chrome DevTools，它将帮助你可视化并跟踪浏览器中发生的几乎每一个进程。</p><h2 id="e1da" class="nj lt it bd lu nk nl dn ly nm nn dp mc lp no np mg lq nq nr mk lr ns nt mo nu bi translated">绘制布局转换区域</h2><p id="3bd6" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">首先，你可能会发现在你的网站上描绘那些不断变化的区域是很有用的。Chrome Dev tools有一个非常强大的功能，当它打开时，你可以看到布局的变化。</p><ul class=""><li id="46dd" class="mv mw it km b kn ko kr ks lp mx lq my lr mz lh na nb nc nd bi translated"><strong class="km iu">方法1 </strong></li></ul><figure class="oc od oe of gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/dd9edb506347e95892247a6c75e2ecd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*G3n5nCGl3UWTS-umhheMSw.gif"/></div></div></figure><ul class=""><li id="3333" class="mv mw it km b kn ko kr ks lp mx lq my lr mz lh na nb nc nd bi translated"><strong class="km iu">方法二</strong></li></ul><figure class="oc od oe of gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oi"><img src="../Images/cd2d07494b2fcb35ce572e502d303fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*FHQtPAo9pUf20do-p6N--g.gif"/></div></div></figure><p id="285b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">当你启用了这个功能后，你应该会看到在你的网站上每一个发生布局变化的地方都有蓝色的方框。</p><figure class="oc od oe of gt ju gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/711a088fb45349a33ce47fdf1ba9ad65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*yOMydzBK0wpnO7Yih21W9g.gif"/></div></figure><p id="2a26" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">现在，为了深入了解导致此类事件的核心过程，您必须进入Chrome浏览器内的DevTools，然后导航至“性能”<strong class="km iu"> </strong>选项卡。</p><figure class="oc od oe of gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ok"><img src="../Images/ac44664e02db007e39bcfc3d5885f285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMjtBCLmdJX1ssbQl6XCJA.png"/></div></div><p class="kb kc gj gh gi kd ke bd b be z dk translated">Chrome DevTools中的性能选项卡</p></figure><p id="72a4" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">单击“重新加载”按钮。这将刷新您的站点并测量其性能，直到CPU空闲。您应该会得到这样的结果:</p><figure class="oc od oe of gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ol"><img src="../Images/0f5b8355603c5eee1725ab717e689773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EMnLLeD1zq7wJezk354MA.png"/></div></div></figure><p id="5b1c" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">是的，看起来就像有人在屏幕上随机扔了无数个彩色的盒子，同时大喊，“这就是你的表演！”</p><p id="30f6" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">不过，别担心。一旦你掌握了窍门，你很快就会明白这是一个多么华丽的工具。试着花点时间看看——这个性能标签会给你很多关于你的网站行为的见解。</p><p id="41f4" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">在最上面，我们可以看到一条时间线，上面用不同的颜色记录了每个事件的每种类型。在下面的主要部分中，我们可以看到所有正在发生的过程以及每个过程的触发因素。</p><p id="48bf" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">主要部分代表浏览器的主线程，并列出我们在优化回流时感兴趣的所有流程。例如，在主线程中执行的进程有脚本评估、HTML解析、布局和绘制。</p><p id="123a" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">解释performance选项卡中的所有内容超出了我们的范围。不如专注于手头的任务:布局<strong class="km iu"> </strong>流程。找到标有<strong class="km iu">紫色</strong>的块，并通过查看底部选项卡上的<strong class="km iu">调用树</strong>、<strong class="km iu"> </strong>的底部，尝试找到导致它们的原因。</p><p id="6d9b" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">尝试在<strong class="km iu">自下而上</strong>和<strong class="km iu">调用树</strong>选项卡中挖掘，您应该能够提取一些有价值的信息，了解哪些流程耗时太长，它们从哪里开始，以及如何优化它们。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="9035" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="d8c2" class="pw-post-body-paragraph kj kk it km b kn mq kp kq kr mr kt ku lp ms kx ky lq mt lb lc lr mu lf lg lh im bi translated">为了提高性能和提供流畅、无阻塞的用户体验，DOM重排或布局偏移应该总是保持在最低限度。本文中描述的技术更多的是一种编码风格和常见的实践，而不是一个待办事项列表。因此，在进行网络开发时，一定要记住这些。👨‍💻</p><p id="1568" class="pw-post-body-paragraph kj kk it km b kn ko kp kq kr ks kt ku lp kw kx ky lq la lb lc lr le lf lg lh im bi translated">希望这篇文章对你有用，你可以让你的酷网站变得更酷。</p></div><div class="ab cl li lj hx lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="im in io ip iq"><h1 id="4869" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">资源</h1><ul class=""><li id="c994" class="mv mw it km b kn mq kr mr lp nz lq oa lr ob lh na nb nc nd bi translated"><a class="ae kf" href="https://csstriggers.com" rel="noopener ugc nofollow" target="_blank"> CSS触发器</a></li><li id="48c9" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated"><a class="ae kf" href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a" rel="noopener ugc nofollow" target="_blank">触发回流的JavaScript代码</a></li><li id="39a0" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated"><a class="ae kf" href="https://github.com/wilsonpage/fastdom" rel="noopener ugc nofollow" target="_blank"> fastdom </a> -批处理dom测量和变异任务库</li><li id="edc5" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated"><a class="ae kf" href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#use_flexbox_over_older_layout_models" rel="noopener ugc nofollow" target="_blank"> flexbox优于旧布局型号</a></li><li id="2b8a" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated"><a class="ae kf" href="https://kellegous.com/j/2013/02/27/innertext-vs-textcontent/" rel="noopener ugc nofollow" target="_blank">文本内容与内部文本</a></li><li id="6a31" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated"><a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText#Browser_compatibility" rel="noopener ugc nofollow" target="_blank"> cssText浏览器兼容性</a></li><li id="d3f6" class="mv mw it km b kn ne kr nf lp ng lq nh lr ni lh na nb nc nd bi translated"><a class="ae kf" href="https://youtu.be/5fLW5Q5ODiE?t=596" rel="noopener ugc nofollow" target="_blank"> Chrome开发工具性能标签视频</a></li></ul></div></div>    
</body>
</html>