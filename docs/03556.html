<html>
<head>
<title>An Introduction to Stacks and Queues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈和队列介绍</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/stacks-and-queues-7c322b5f4e35?source=collection_archive---------21-----------------------#2020-02-17">https://betterprogramming.pub/stacks-and-queues-7c322b5f4e35?source=collection_archive---------21-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06da" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">改进您的数据结构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d46d9dacac80d3d27c325b11c28b2369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YOIGqoLx-fiP1Bm4"/></div></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">潘卡杰·帕特尔在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片。</p></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="501e" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">背景</h1><p id="8fec" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">优化代码很少是一件容易的事情。代码可能按预期工作，但是如果执行时间太长，那么代码就是低效的，需要优化。数据结构——编码世界中不可避免的邪恶——代表了优化的主要症结。在正确的场景中使用正确的数据结构会使你的代码比使用暴力方法运行得更快。</p><p id="b1f5" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这些数据结构之一是堆栈和队列。我个人感觉这是一个鲜为人知的数据结构，非常容易实现，而且没有得到足够的喜爱。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="21f6" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">堆栈和队列</h1><p id="4fee" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">在我们深入研究之前，让我们定义一下什么是栈和队列。堆栈遵循先入后出(FILO)模式。队列遵循先进先出(FIFO)模式。尽管这两个术语通常作为一个短语捆绑在一起，但它们遵循两种不同的设计模式。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="f002" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">大量</h1><p id="eb60" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">让我们深入了解一下堆栈，从空堆栈开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/2f1e387145d040a52e033c21cccfb3cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*UOJtAG-6njgw3j8oMAHEnQ.png"/></div></figure><p id="b241" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我们目前没有任何东西。接下来，让我们将10加到堆栈中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/d94b0fef978822bd423a871683709b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*M3exbxtssOrTtpVTNkgRug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">将“10”添加到空堆栈中。</p></figure><p id="6738" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">将10添加到堆栈后，它会落到堆栈的底部。请记住，10是堆栈中的第一个。如果您按此顺序将20和30相加，堆栈现在应该如下图所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi my"><img src="../Images/8b4c2ec45a57106fbd2ebf4dd3cff0d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*6FIn12Zaj5y8tToiT6X4QQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当前堆栈增加20。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/477288a3498ffe4c1fd86ffdb3045ead.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*vqjb1MobjWU7DFMqSpMAtg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当前堆栈增加30。</p></figure><p id="2eaf" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">当前堆栈，从下到上，现在是10，20和30。如果我想把10取出来呢？啊，我们现在不能，因为30号和20号挡住了路。我们需要取出30个，然后取出20个，最后取出10个。10将是当前堆栈中的最后一个。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi na"><img src="../Images/8c076ee0ac637fe5f4b9e255eddb19b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*a7isEiZTuwCKcfLHI3IdwA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从当前堆栈中删除30。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/83721f9ce803982452e72e9397a69aa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*YGukPrdWRQO1TWV71EI_fw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从当前堆栈中删除20。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e2c6ff16a42b66aab6432d39368b12e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*TadKWUyXlSpi51rmemcqJw.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从当前堆栈中删除10。</p></figure><p id="1742" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">这就是先进后出(费罗)的意思。放入堆栈的第一个元素将是从堆栈中移除的最后一个元素。10是放入堆栈的第一个元素(先进)，也是从堆栈中移除的最后一个元素(后进)。我知道这听起来有些多余，但是尽可能清楚地解释这些术语将有助于避免任何混淆。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="da00" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">代码术语中的堆栈</h1><p id="95c7" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">既然我们已经理解了成为FILO意味着什么以及栈是如何工作的，那么是时候从代码的角度实际实现一个栈了。我将使用JavaScript来演示这一点。但首先，为了给出一个更清晰的画面，让我们重复使用我们之前的例子。出于演示目的，让我们将堆栈顺时针旋转90度，使其看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/a228e3288e7cd936761ddb1035a93766.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*hEhr0NC6AF-tSVys2UGMKQ.png"/></div></figure><p id="e0f6" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">关于代码，我们可以用一个数组来表示一个空栈。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c76c" class="nj le iq nf b gy nk nl l nm nn">let stack = []</span></pre><p id="9653" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">接下来，我们可以向空堆栈中添加10。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/1c21c9f428da6b3f796fa7cf8326b4ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*CkCMDSJZ4GRRTwR4WNV-Ug.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">向空堆栈添加10。</p></figure><p id="0060" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">就代码而言，这与以下内容相同:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="52e7" class="nj le iq nf b gy nk nl l nm nn">stack.push(10)<br/>console.log(stack) // [10]</span></pre><p id="74c4" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在让我们依次放入20和30。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c78405d2b794eb86b32c96847cfc6f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*zitNHzEdyPvCj5AYfMNHSA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当前堆栈增加20。</p></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi np"><img src="../Images/76af7546d31827dee07657ac70a3ac2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*GFZEKnnCdCDREoeNynv5hg.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当前堆栈增加30。</p></figure><p id="49a8" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">就代码而言，这与以下内容相同:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="f8f6" class="nj le iq nf b gy nk nl l nm nn">stack.push(20)<br/>stack.push(30)<br/>console.log(stack) // [10, 20, 30]</span></pre><p id="1225" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在让我们把它拿回来，开始从堆栈中删除，从最近添加的开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5b898469abe7eb6d2c870b149dc69e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*-tNsyIuIviZKyk_Ap2Xy3A.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从当前堆栈中删除30。</p></figure><p id="d730" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">在代码中，这与:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="cc83" class="nj le iq nf b gy nk nl l nm nn">stack.pop()<br/>console.log(stack) // [10, 20]</span></pre><p id="dd57" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">为了简洁起见，我将跳过图片，但我们将对20和10做同样的事情。在代码中，我们会再调用两次<code class="fe nr ns nt nf b">.pop()</code>方法。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="c3b2" class="nj le iq nf b gy nk nl l nm nn">stack.pop()<br/>stack.pop()<br/>console.log(stack) // []</span></pre><p id="de04" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">实现一个堆栈就这么简单！由于JavaScript的内置方法，我们可以通过使用数组和使用<code class="fe nr ns nt nf b">.push()</code>和<code class="fe nr ns nt nf b">.pop()</code>创建自己的堆栈来实现堆栈数据结构。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="277b" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">行列</h1><p id="3c9c" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">到目前为止，我们只讨论了堆栈和堆栈如何是FILO。如果你能够理解栈是如何工作的，队列是非常相似的。因为队列遵循先进先出(FIFO)设计模式，所以我们也可以使用数组来表示队列。</p><p id="a3f6" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">另一种思考队列的方式是排队。通常，排队的人是根据他们到达的顺序得到服务的——就像你排队进入一个场地一样。</p><p id="3e60" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">我打算将图像与代码结合起来，以节省一些时间和空间。</p><p id="2d79" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">类似于我们如何开始一个空栈，让我们从一个空队列开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5edd2fe53a82c28bddd9a3d76c23a081.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*x-ndUBpzw32yANUcq1FJAw.png"/></div></figure><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="925d" class="nj le iq nf b gy nk nl l nm nn">let queue = []</span></pre><p id="3447" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">接下来，我们将按顺序将10、20和30添加到队列中。您可以使用我们对堆栈使用的相同图像作为队列的参考，因为它实际上在做同样的事情。就代码而言，我们仍将使用<code class="fe nr ns nt nf b">.push()</code>方法。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b314" class="nj le iq nf b gy nk nl l nm nn">queue.push(10)<br/>queue.push(20)<br/>queue.push(30)<br/>console.log(queue) // [10, 20, 30]</span></pre><p id="f247" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">到目前为止，先入部分保持不变。由于队列是先进先出的，这就是它与堆栈不同的地方。目前，我们的队列如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/d83c05776a32c3e9cf7aacebf2accc82.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*LxugiYny0-bO9fcbSSZGBA.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">当前队列。</p></figure><p id="b13d" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">因为10是第一个添加的元素，所以现在它将是第一个删除的元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/300216b51e8be369ae2e1bf66b66ce54.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*YUG9danYFU2F48YYiJHeOQ.png"/></div><p class="kr ks gj gh gi kt ku bd b be z dk translated">从当前队列中删除10。</p></figure><p id="de5e" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">那么，我们如何用代码来实现呢？谢天谢地，JavaScript也有一个内置的方法来为我们做这件事:<code class="fe nr ns nt nf b">.shift()</code>。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="0f4a" class="nj le iq nf b gy nk nl l nm nn">queue.shift()<br/>console.log(queue) // [20, 30]</span></pre><p id="476f" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">现在，如果我们按照添加元素的顺序清空队列，我们将继续调用<code class="fe nr ns nt nf b">.shift()</code>方法。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="dd3f" class="nj le iq nf b gy nk nl l nm nn">queue.shift()<br/>queue.shift()<br/>console.log(queue) // []</span></pre><p id="aa23" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">实现队列也是如此简单！与堆栈一样，我们可以使用JavaScript的内置方法，通过<code class="fe nr ns nt nf b">.push()</code>方法实现先进先出，通过<code class="fe nr ns nt nf b">.shift()</code>实现先进先出。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e4d5" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">堆栈和队列的时间复杂度</h1><p id="b767" class="pw-post-body-paragraph lv lw iq lx b ly lz jr ma mb mc ju md me mf mg mh mi mj mk ml mm mn mo mp mq ij bi translated">对于本节，我做了以下假设:</p><ol class=""><li id="555b" class="nw nx iq lx b ly mr mb ms me ny mi nz mm oa mq ob oc od oe bi translated">你理解时间复杂性和大O符号。</li><li id="d491" class="nw nx iq lx b ly of mb og me oh mi oi mm oj mq ob oc od oe bi translated">您了解数组的内存分配机制。</li></ol><p id="ec53" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">如果你不理解上面提到的两个概念，我强烈建议你在继续学习之前先阅读一下。</p><p id="5733" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">对于堆栈来说，使用<code class="fe nr ns nt nf b">.push()</code>的时间复杂度是<em class="ok"> O(1) </em>，因为<code class="fe nr ns nt nf b">.push()</code>总是添加到数组的末尾，索引推入的元素是一个操作，因为它增加了一个索引。使用<code class="fe nr ns nt nf b">.pop()</code>也是<em class="ok"> O(1) </em>，因为<code class="fe nr ns nt nf b">.pop()</code>访问并移除数组的最后一个元素。当最后一个元素被删除时，其余的元素不受影响，因为它们不需要被重新索引。所以总体来说，栈的时间复杂度是<em class="ok"> O(1) </em>。</p><p id="4b32" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">对于队列，由于我们也使用了<code class="fe nr ns nt nf b">.push()</code>，时间复杂度仍然是<em class="ok"> O(1) </em>，原因和上一段提到的一样。但是，使用<code class="fe nr ns nt nf b">.shift()</code>方法的时间复杂度为<em class="ok"> O(n) </em>。这是因为当您从数组中移除第一个元素时，计算机将需要重新索引其余的元素，这取决于数组的长度。所以总体来说，使用队列的时间复杂度是<em class="ok"> O(n) </em>。</p><p id="8039" class="pw-post-body-paragraph lv lw iq lx b ly mr jr ma mb ms ju md me mt mg mh mi mu mk ml mm mv mo mp mq ij bi translated">希望您能够实现这一点。如果没有，至少你知道了一个额外的数据结构！</p></div></div>    
</body>
</html>