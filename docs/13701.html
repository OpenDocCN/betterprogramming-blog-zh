<html>
<head>
<title>How Golang Generics Empower Concise APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang泛型如何增强简洁API</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/how-golang-generics-empower-concise-api-html-table-extraction-case-study-e2f4050bbb7d?source=collection_archive---------3-----------------------#2022-09-18">https://betterprogramming.pub/how-golang-generics-empower-concise-api-html-table-extraction-case-study-e2f4050bbb7d?source=collection_archive---------3-----------------------#2022-09-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d193" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">HTML表格抽取案例研究</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/342b420881b0d108d168f1cd04a1c4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTKUrHIUxGL9q8YYnBzYog.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://www.deviantart.com/quasilyte/art/Tired-gopher-783302842" rel="noopener ugc nofollow" target="_blank">疲惫的地鼠</a><em class="kz"/>正在将表格提取到内存中</p></figure><p id="44a4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你可能听说过并读过许多关于Go 中关于普通切片和地图的<a class="ae ky" href="https://go.dev/doc/tutorial/generics" rel="noopener ugc nofollow" target="_blank">泛型的故事，但是还没有想到一个有趣的方法来应用这个特性。让我们实现</a><a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.read_html.html" rel="noopener ugc nofollow" target="_blank"> pandas.read_html </a>的对等体，它将html表映射成结构的切片！如果用<a class="ae ky" href="https://docs.rs/table-extract/latest/table_extract/" rel="noopener ugc nofollow" target="_blank"> Rust </a>也能实现，那为什么不能用Go呢？！这篇文章将向您展示一个令人兴奋的反射和泛型的组合，为您的库获得简洁的外部API。</p><p id="4a95" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">首先，让我们看看这篇文章的直接灵感——最受欢迎的交互式数据分析库，<a class="ae ky" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> Pandas </a>:阅读HTML似乎如此普遍，以至于它被视为一种商品，因此可以开箱即用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lw"><img src="../Images/56f50d9c3cec53c8a4da9b68193f904a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKsxOm3i-vL5cMDmmoIYNA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">从<a class="ae ky" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter </a>笔记本中使用<a class="ae ky" href="https://pandas.pydata.org/docs/reference/api/pandas.read_html.html" rel="noopener ugc nofollow" target="_blank"> pandas.read_html </a>的示例。</p></figure><p id="4ffe" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了遵循惯用的表解析示例，让我们从维基百科获取<a class="ae ky" href="https://en.wikipedia.org/wiki/List_of_S&amp;P_500_companies" rel="noopener ugc nofollow" target="_blank">的&amp; P 500列表</a>，并将其转换成一片<code class="fe lx ly lz ma b">Ticker</code>实例，在这里我们用一个表头名称来注释每一列:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在围棋中，事情甚至可以变得简洁</p></figure><p id="b9b1" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里我们要注意的是来自<code class="fe lx ly lz ma b">NewSliceFromURL<strong class="lc iu">[Ticker]</strong>(URL)</code>的<code class="fe lx ly lz ma b">[<strong class="lc iu">Ticker</strong>]</code>和<em class="md">。</em>这个名为<a class="ae ky" href="https://go.dev/ref/spec#TypeParameters" rel="noopener ugc nofollow" target="_blank">类型参数</a>的Go 1.18+特性是我们告诉<code class="fe lx ly lz ma b">NewSliceFromURL</code>类型名称的理想方式，反射将帮助我们发现头文件的名称。在泛型之前，你可能已经写了一个类似于<code class="fe lx ly lz ma b">NewSliceFromURL(<strong class="lc iu">Ticker{}, </strong>URL)</code> <em class="md">，</em>的API，尽管我总是觉得它有点令人困惑:</p><blockquote class="me"><p id="3df3" class="mf mg it bd mh mi mj mk ml mm mn lv dk translated">如果我们的目标只是传递类型，为什么我们需要传递类型的空实例？</p></blockquote><p id="3c9f" class="pw-post-body-paragraph la lb it lc b ld mo ju lf lg mp jx li lj mq ll lm ln mr lp lq lr ms lt lu lv im bi translated">花了很多年编写Java代码，我已经习惯了来自像<a class="ae ky" href="https://github.com/FasterXML/jackson-databind/blob/3bae019c8c91def310ed9679806217cff52e8c52/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java#L3560-L3584" rel="noopener ugc nofollow" target="_blank"> Jackson </a>这样的库中的<em class="md">对象映射</em>的概念。但是这个博客是关于围棋的，你可能已经登陆到这里来弄清楚如何实现类似的事情。你可能认为Go generics " <em class="md">只是工作，</em>"但是你的享受程度取决于你对其他编程生态系统的亲和力。在撰写本文时，<a class="ae ky" href="https://github.com/golang/go/issues/49085" rel="noopener ugc nofollow" target="_blank">方法还不能有类型参数</a>，而类型参数为API设计打开了创造性的闸门。下面是插图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/0cb36fed3e8ccc634606b30b9c9d7737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hU1j9msHAc237Tcapn1eMA.png"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">不需要公共API用类型参数初始化空结构</p></figure><p id="9919" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这看起来有点像魔术，但下面是简化的思考方式:当我们调用<code class="fe lx ly lz ma b">NewSliceFromURL<strong class="lc iu">[Ticker]</strong>()</code>、<em class="md">、</em>时，编译器用实际类型替换类型参数引用，<code class="fe lx ly lz ma b">feeder[T]</code>类型中的<code class="fe lx ly lz ma b">dummy T</code>变成了<code class="fe lx ly lz ma b">dummy Ticker</code>、<em class="md">。</em>还是很难跟上，但是惊心动魄？请看几篇<a class="ae ky" href="https://benjiv.com/golang-generics-introduction/" rel="noopener ugc nofollow" target="_blank">入门</a> <a class="ae ky" href="https://benjiv.com/generic-programming-in-software-engineering/" rel="noopener ugc nofollow" target="_blank">文章</a>(或<a class="ae ky" href="https://planetscale.com/blog/generics-can-make-your-go-code-slower" rel="noopener ugc nofollow" target="_blank">更多</a> <a class="ae ky" href="https://www.dolthub.com/blog/2022-04-01-fast-generics/" rel="noopener ugc nofollow" target="_blank">进阶</a>的)。</p><p id="a7d4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">所以，现在我们有了一个<code class="fe lx ly lz ma b">dummy Ticker</code>，需要从中读取一些元数据。首先，我们从我们的<code class="fe lx ly lz ma b">dummy Ticker</code>中获取<code class="fe lx ly lz ma b"><a class="ae ky" href="https://pkg.go.dev/reflect#ValueOf" rel="noopener ugc nofollow" target="_blank">reflect.Value</a></code>，然后我们<a class="ae ky" href="https://pkg.go.dev/reflect#Value.Type" rel="noopener ugc nofollow" target="_blank">将</a><code class="fe lx ly lz ma b"><a class="ae ky" href="https://pkg.go.dev/reflect#Value.Type" rel="noopener ugc nofollow" target="_blank">Ticker</a></code><a class="ae ky" href="https://pkg.go.dev/reflect#Value.Type" rel="noopener ugc nofollow" target="_blank"/>类型获取到<code class="fe lx ly lz ma b">elem</code>变量中，从中我们可以发现一个类型的<a class="ae ky" href="https://pkg.go.dev/reflect#Value.NumField" rel="noopener ugc nofollow" target="_blank">个字段</a>并对它们进行迭代。</p><p id="178b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我们需要将Ticker字段绑定到表头。在Java中，你可能已经创建了一个<code class="fe lx ly lz ma b">@Header</code>注释，并围绕它使用了一个<a class="ae ky" href="https://medium.com/edureka/annotations-in-java-9847d531d2bb" rel="noopener">完整的结构化框架</a>。</p><p id="72b7" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">尽管如此，在Go中，我们必须遵循一个约定，编写可选空格分隔的<code class="fe lx ly lz ma b">key:"value”</code>对的<em class="md">标记字符串</em>，我们可以通过struct字段的<code class="fe lx ly lz ma b">Tag</code>属性的<code class="fe lx ly lz ma b"><a class="ae ky" href="https://pkg.go.dev/reflect#StructTag" rel="noopener ugc nofollow" target="_blank">Get</a></code> <a class="ae ky" href="https://pkg.go.dev/reflect#StructTag" rel="noopener ugc nofollow" target="_blank">方法</a>来读取。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">结构字段标记的典型解析</p></figure><p id="05f3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">一旦我们得到了结构字段的位置映射，我们必须将它与表格标题列的位置进行匹配，这一点我们将在本文后面讨论:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">将我们的结构理解的内容与HTML表中的内容结合起来</p></figure><p id="02ee" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">映射和数据都在那里，我们准备在我们创建的切片上反映出来。这里有趣的一点是制作一个切片并将这个切片转换成具体类型。</p><p id="3bae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">假设我们在内存中已经有了所有的表数据，我们可以使用预定义的容量和长度来避免片不必要的动态增长。<code class="fe lx ly lz ma b">MakeSlice</code>返回一个<em class="md">切片值</em>，我们将使用它通过切片的位置来访问单个项目。</p><p id="bdc4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个代码片段假设字符串是表格单元格唯一支持的数据类型。一旦我们将所有的表行添加到我们的切片中，我们就必须对其进行转换:<code class="fe lx ly lz ma b">Interface()</code>方法将把反射值转换成<code class="fe lx ly lz ma b"><strong class="lc iu">any</strong></code>，<code class="fe lx ly lz ma b">.([]T)</code>将得到<code class="fe lx ly lz ma b"><strong class="lc iu">[]Ticker</strong></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">反思。MakeSlice()创建一个值，您可以通过Index()方法在其中添加新元素。</p></figure><p id="5d52" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">你在页面开头看到的漂亮的API是由大致如下导出的包函数支持的，它只负责编译器的类型引用传播，并为一些事情调用初始化器:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">需要包级包装器来隐藏虚拟变量的复杂性</p></figure><blockquote class="mu mv mw"><p id="3e1a" class="la lb md lc b ld le ju lf lg lh jx li mx lk ll lm my lo lp lq mz ls lt lu lv im bi translated"><em class="it">记住:与其他语言中的反射不同，你通过字段在结构中的位置来引用它，而不是名字</em>。场顺序<em class="it">有时会影响</em>的性能，但是我们在这里使用反射，所以无论如何性能会稍受影响。</p></blockquote><p id="8cd0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">但是在这种情况下，它没有公共API的清晰那么重要。</p><p id="8933" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu"> <em class="md">总结:</em> </strong>每次我们处理带注释的类，都要解析带注释的字段。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><p id="87a6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">既然我们已经玩够了反射，让我们得到一些数据。您也可能倾向于在没有任何自定义类型创建的情况下使用表，并使用普通的旧回调。作为一个库作者，您可以添加像<code class="fe lx ly lz ma b">Each</code>、<code class="fe lx ly lz ma b">Each2</code>、<code class="fe lx ly lz ma b">Each3</code>等方法。对于Java来说，方法重载是很常见的。看看log4j来源就知道了。但是对于GoLang，我们必须非常健谈:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">迭代的普通回调</p></figure><p id="16f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">将数据路由到回调相对简单，因为我们只需要找出表头的位置，并将其与提供的列名匹配。比反射方法更具体，但是它只能扩展到几列。您不希望在单一类型中维护太多冗长的方法，为了简单起见，我们将只有<code class="fe lx ly lz ma b">Each</code>、<code class="fe lx ly lz ma b">Each2</code>和<code class="fe lx ly lz ma b">Each3</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">在Go中维护简洁的API和错误传播几乎需要复制粘贴。</p></figure><p id="71cb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们如何理解在HTML页面上选择哪个表格？它可能有多个。而熊猫库也没有很好的解决“<em class="md">开发者体验</em>的问题。因此，让我们添加一些简单的试探法，通过列名来匹配表。它应该在99%的情况下工作，因为以<em class="md">表格作为数据</em>的页面平均有一个表格标签，偶尔有两个，很少有三个。现在是21世纪的第二个十年，几乎没有人使用HTML进行布局。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">大量的错误信息对于模糊匹配是必不可少的。</p></figure><p id="6fdf" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们通过制作一个简单的递归解析器，通过<code class="fe lx ly lz ma b"><a class="ae ky" href="https://pkg.go.dev/golang.org/x/net/html" rel="noopener ugc nofollow" target="_blank">golang.org/x/net/html</a></code>包获得最底层的表数据。当然，我们可以用<code class="fe lx ly lz ma b"><a class="ae ky" href="https://github.com/PuerkitoBio/goquery" rel="noopener ugc nofollow" target="_blank">goquery</a></code>(它也构建在<code class="fe lx ly lz ma b">x/net/html</code>之上)来做这件事，但是我们可以通过避免两个额外的传递依赖来使代码更简单。如果你，作为一名观众，对技术比较的文章感兴趣，请在下面留下评论，我会看看我们能做些什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb mc l"/></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">Go标准(实验)库中HTML表格的简单解析</p></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="e696" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">资源</h1><ul class=""><li id="e0ed" class="nz oa it lc b ld ob lg oc lj od ln oe lr of lv og oh oi oj bi translated">Go中符合HTML5的<a class="ae ky" href="https://pkg.go.dev/golang.org/x/net/html" rel="noopener ugc nofollow" target="_blank">标记器和解析器</a></li><li id="d263" class="nz oa it lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><a class="ae ky" href="https://github.com/PuerkitoBio/goquery" rel="noopener ugc nofollow" target="_blank"> goquery </a> —类似jQuery，但是在Go中</li><li id="213b" class="nz oa it lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><a class="ae ky" href="https://medium.com/edureka/annotations-in-java-9847d531d2bb" rel="noopener">Java注释简介</a></li><li id="a61b" class="nz oa it lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><a class="ae ky" href="https://pkg.go.dev/reflect" rel="noopener ugc nofollow" target="_blank">在Go中反映</a>包</li><li id="da3a" class="nz oa it lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><a class="ae ky" href="https://benjiv.com/golang-generics-introduction/" rel="noopener ugc nofollow" target="_blank">Go中的泛型介绍:类型参数、类型推理和约束</a></li><li id="f639" class="nz oa it lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><a class="ae ky" href="https://www.dolthub.com/blog/2022-04-01-fast-generics/" rel="noopener ugc nofollow" target="_blank">Golang中的泛型和值类型</a></li><li id="58ef" class="nz oa it lc b ld ok lg ol lj om ln on lr oo lv og oh oi oj bi translated"><a class="ae ky" href="https://nf-x.medium.com/tech-book-reviews-go-bb589fd3e108" rel="noopener">科技书评:Go </a></li></ul><div class="op oq gp gr or os"><a href="https://github.com/nfx/go-htmltable" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd iu gy z fp ox fr fs oy fu fw is bi translated">GitHub - nfx/go-htmltable:从几乎没有…</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">htmltable支持从HTML表格和URL中提取结构化数据，几乎不需要外部依赖…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg ks os"/></div></div></a></div><pre class="kj kk kl km gt ph ma pi pj aw pk bi"><span id="df66" class="pl ni it ma b gy pm pn l po pp"><strong class="ma iu">Want to Connect?</strong></span><span id="a1bc" class="pl ni it ma b gy pq pn l po pp">Does everything you’ve read in this post look good? Follow <a class="ae ky" href="https://twitter.com/nf_x" rel="noopener ugc nofollow" target="_blank">@nf_x</a> on Twitter, and check out <a class="ae ky" href="https://github.com/nfx/go-htmltable" rel="noopener ugc nofollow" target="_blank">the source</a>, which implements all of these ideas — feel free to use it as you see fit. Looking forward to your pull requests that take these ideas even further!</span></pre></div></div>    
</body>
</html>