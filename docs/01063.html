<html>
<head>
<title>What Is a Pure Function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是纯函数？</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/what-is-a-pure-function-3b4af9352f6f?source=collection_archive---------2-----------------------#2019-08-12">https://betterprogramming.pub/what-is-a-pure-function-3b4af9352f6f?source=collection_archive---------2-----------------------#2019-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ab12" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编程中的纯函数及其好处</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/8fb1cc7723adb5bf1c7e4034c1465fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ai6Dtj1nxefZF9FC"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated">由<a class="ae ku" href="https://unsplash.com/@codestorm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Safar Safarov </a>在<a class="ae ku" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></figure></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="8eed" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">定义</h1><p id="017e" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">在编程中，<em class="mq">纯函数</em>是具有以下特性的函数:</p><ol class=""><li id="12f4" class="mr ms it lw b lx mt ma mu md mv mh mw ml mx mp my mz na nb bi translated">对于相同的输入，函数总是返回相同的值。</li><li id="48f5" class="mr ms it lw b lx nc ma nd md ne mh nf ml ng mp my mz na nb bi translated">函数的求值没有副作用。副作用是指改变函数中不包含的程序的其他属性，例如改变全局变量值或使用I/O流。</li></ol><p id="6e5c" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">实际上，一个纯函数的返回值只基于它的输入，对整个程序没有其他依赖或影响。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d48fba4692e80716cf18dc5b5bb09e4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:588/format:webp/1*pywN7P4JC0zpkFiUbDnNBw.png"/></div><p class="kq kr gj gh gi ks kt bd b be z dk translated"><a class="ae ku" href="https://www.mathsisfun.com/sets/function.html" rel="noopener ugc nofollow" target="_blank">https://www.mathsisfun.com/sets/function.html</a></p></figure><p id="54d5" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">纯函数在概念上类似于数学函数。对于任何给定的输入，一个纯函数必须恰好返回一个可能的值。</p><p id="c921" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">但是，像数学函数一样，它也可以为其他输入返回相同的值。此外，像数学函数一样，它的输出仅由其输入决定，而不是存储在其他全局状态中的任何值。</p></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="5a99" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">例子</h1><ol class=""><li id="a2b8" class="mr ms it lw b lx ly ma mb md nl mh nm ml nn mp my mz na nb bi translated">下面的功能是<em class="mq">纯</em>。它没有副作用，并且总是为相同的输入返回相同的输出。</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9334" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">2.下面的功能是<em class="mq">不是纯粹的</em>。对于相同的输入，它并不总是返回相同的值，因为输出取决于输入的<code class="fe nq nr ns nt b">x</code>值以及内部计算的随机值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7286" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">3.下面的函数也不纯。尽管它总是为相同的输入返回相同的值，但是它会有副作用，因为它修改了全局变量<code class="fe nq nr ns nt b">y</code>的值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl kv kw hx kx" role="separator"><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la lb"/><span class="ky bw bk kz la"/></div><div class="im in io ip iq"><h1 id="9460" class="lc ld it bd le lf lg lh li lj lk ll lm jz ln ka lo kc lp kd lq kf lr kg ls lt bi translated">利益</h1><p id="fa7b" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">使用纯函数有几个好处，在性能和可用性方面都是如此。</p><h2 id="f238" class="nu ld it bd le nv nw dn li nx ny dp lm md nz oa lo mh ob oc lq ml od oe ls of bi translated">1.可读性</h2><p id="8fa2" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">纯函数更容易阅读和推理。所有相关的输入和依赖项都作为参数提供，因此没有观察到改变输入集之外的变量的影响。</p><p id="9b8c" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">这意味着我们可以很快理解一个函数和它的依赖关系，只需要阅读函数的声明。因此，如果一个函数被声明为<code class="fe nq nr ns nt b">f(a, b, c)</code>，那么我们知道只有<code class="fe nq nr ns nt b">a</code>、<code class="fe nq nr ns nt b">b</code>和<code class="fe nq nr ns nt b">c</code>是<code class="fe nq nr ns nt b">f</code>的依赖项。</p><h2 id="4abb" class="nu ld it bd le nv nw dn li nx ny dp lm md nz oa lo mh ob oc lq ml od oe ls of bi translated">2.轻便</h2><p id="548f" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">因为所有的依赖项都是作为输入参数提供的，并且不是通过全局上下文访问的，所以这些依赖项可以根据调用函数的上下文进行交换。</p><p id="e69a" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">例如，这意味着相同的函数可以作用于相同资源的不同实现。</p><p id="6b6d" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">这使得代码更具可移植性和可重用性，因为相同的函数可以在不同的上下文中使用，而不是为了使用相同类的不同实现而必须编写不同的函数。</p><p id="97d7" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">例如，不必编写两个不同的非纯函数来使用两个全局存储的不同记录器，纯函数只需将所需的记录器作为输入。</p><h2 id="a32a" class="nu ld it bd le nv nw dn li nx ny dp lm md nz oa lo mh ob oc lq ml od oe ls of bi translated">3.测试</h2><p id="21f4" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">没有副作用使得纯函数非常容易测试，因为我们只需要测试输入产生了期望的输出。我们不需要在特定函数的测试中检查任何全局程序状态的有效性。</p><p id="5667" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">此外，由于所有依赖项都是作为输入提供的，所以我们可以很容易地模仿依赖项。在一个不纯的环境中，我们必须在所有的测试中跟踪一些全局依赖的状态。</p><p id="20b5" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">然而，在纯设置中，我们将简单地提供所有依赖项作为输入。我们不再需要担心在整个测试中维护全局状态，我们现在可以为不同的测试提供不同版本的依赖关系。</p><p id="cd37" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">这允许我们测试功能，同时在每个测试中明确地控制所提供的依赖性。</p><h2 id="3ae2" class="nu ld it bd le nv nw dn li nx ny dp lm md nz oa lo mh ob oc lq ml od oe ls of bi translated">4.对透明性有关的</h2><p id="8150" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">引用透明指的是能够在不改变程序行为的情况下，用相应的输出值替换函数调用。</p><p id="12e7" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">为了实现引用透明，函数必须是纯的。这在可读性和速度方面都有好处。编译器通常能够优化表现出引用透明性的代码。</p><h2 id="7b61" class="nu ld it bd le nv nw dn li nx ny dp lm md nz oa lo mh ob oc lq ml od oe ls of bi translated">5.贮藏</h2><p id="9562" class="pw-post-body-paragraph lu lv it lw b lx ly ju lz ma mb jx mc md me mf mg mh mi mj mk ml mm mn mo mp im bi translated">由于纯函数对于相同的输入总是返回相同的输出，所以我们可以缓存纯函数调用的结果。</p><p id="2dd5" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">缓存是指使用一种技术，比如记忆，来存储函数的结果，这样我们只需要计算一次。</p><p id="d549" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">通常，对于函数<code class="fe nq nr ns nt b">f: Input -&gt; Output </code>，这是通过来自<code class="fe nq nr ns nt b">Input -&gt; Output</code>的映射(比如hash-map)来完成的。</p><p id="596d" class="pw-post-body-paragraph lu lv it lw b lx mt ju lz ma mu jx mc md nh mf mg mh ni mj mk ml nj mn mo mp im bi translated">当执行一个函数时，我们首先检查map是否包含作为键的输入。如果是，我们返回地图的输出值，否则，我们计算<code class="fe nq nr ns nt b">f(input)</code>，然后在返回之前将输出存储在地图中。</p></div></div>    
</body>
</html>