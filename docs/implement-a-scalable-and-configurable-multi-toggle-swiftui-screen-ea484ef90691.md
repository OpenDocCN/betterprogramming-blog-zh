# 实现可扩展和可配置的多切换 SwiftUI 屏幕

> 原文：<https://betterprogramming.pub/implement-a-scalable-and-configurable-multi-toggle-swiftui-screen-ea484ef90691>

## 以一般化的方式处理多个选项

![](img/afae9ccde5c442e6f71f3497a3f0cc59.png)

卢卡斯·桑托斯在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

有时候，我们会面临一些有趣的挑战，值得分享。这些天，我面临的问题是实现一个具有多个是/否选项的屏幕和一个必须控制所有孩子的主开关。

我必须在 SwiftUI 中实现它。起初，这看起来是一个容易解决的问题:UI 代码并不复杂，行为看起来很容易掌握。但是一些错综复杂的事情使它变得更加困难。

在今天的文章中，我想与您分享实施过程。我们将探索`Toggle`API，并了解如何解决面临的问题。最后，我们将重构和概括代码。最后一步对于保持代码库的可读性、可扩展性和可维护性是最重要的。

# 要求

作为第一步，我们需要理解我们必须实现什么。这种行为很清楚，但也很棘手:主人和孩子依赖于彼此的状态。我们需要考虑四种行为:

1.  当用户打开主开关时，所有的子开关都必须打开。
2.  当用户关闭主开关时，必须关闭所有子开关。
3.  如果用户关闭一个子开关，而打开主开关，则必须关闭主开关。
4.  如果除了一个孩子之外的所有孩子都打开了，并且用户打开了最后一个孩子，则必须打开主开关。

下面的 gif 展示了我们想要的行为:

![](img/d69a006e8cdfad99187efc63a15267a7.png)

# 实现视图

让我们从实现基本视图开始，不带行为。

代码展示了视图的基本结构。它包含四个状态变量，用`@State`属性包装器进行了注释，还有四个开关。

到目前为止，我们还没有实现任何逻辑。如果我们运行应用程序，我们可以切换任何单个元素，但其他元素不会更新。

## 对状态变量使用 didSet

让我们从实现第一个行为开始:当主开关打开或关闭时，所有其他开关必须相应地改变。

第一个想法是监听`mainSwitch`属性的变化，并相应地更新其他状态。从理论上讲，我们可以使用`didSet`属性观察器来做到这一点:`mainSwitch`属性被绑定到`Toggle`，因此与开关的交互应该会更新该状态。

代码将如下所示:

如果我们现在通过打开/关闭主开关来测试这种方法，其他开关不会更新。如果我们在`didSet`体中放置一个断点，它根本不会被断点中断。

我认为这是因为属性包装器改变了修饰变量的类型。但是，如果我们检查属性观察者中的`oldValue`，它的类型是`Bool`。如果是这样的话，我希望`oldValue`是`State<Bool>`类型的。

如果我们在 StackOverflow 上搜索这个问题，会有多个关于它的问题和答案。[建议的解决方案](https://stackoverflow.com/a/63289866)是使用`onChange`视图修改器。

## 使用`onChange ViewModifier`

让我们试试建议的解决方案。我们需要在`Toggle`之后添加视图修改器。代码现在看起来像这样:

在第 11 行，我们添加了视图修饰符。当主交换机发生变化时，所有其他交换机都会更新。如果我们现在运行应用程序，它会按预期工作。然而，动画是突然的，看起来不太好。为了解决这个问题，我们添加了`.animation`视图修改器(第 27 行),每当`mainSwitch`属性改变时就会触发。有了这一行，开关的外观和感觉看起来更好。

现在让我们继续，实现另一个行为。我们希望在主开关仍然打开的情况下，当子开关被关闭时，主开关也被关闭。这转化为下面的代码。

我删除了几行代码，让我们专注于儿童代码。首先，我们观察到代码非常重复。目前还可以:让我们首先集中精力达成一个可行的解决方案。

每个触发器在其状态更新时运行`perform`闭包。如果开关关闭，主开关打开，则主开关必须关闭。这个逻辑在纸上看起来不错，但是当我们运行它时，我们注意到一些奇怪的事情:所有的开关都移动得很稳。

发生这种情况是因为它们是相连的:当一个孩子的状态改变时，它会更新主开关。因此主开关改变，执行`onChange(of: mainSwitch)`关闭。这将更新所有子节点，将它们的状态设置为`mainSwitch`的状态。这些更新可能会触发其他更新。我们有一连串的影响，阻止我们达到我们所需要的。

第一个解决方案可以跟踪视图为什么会改变:我们可以添加其他状态变量，当第一个开关被点击时我们打开这些变量。代码现在看起来像这样:

我们增加了一些变量来跟踪变化。然后，我们更新了闭包的代码，只在视图没有因为其他开关更新而改变时才执行主体。

例如，`mainSwitch`的`perform`闭包有一个`guard`，当且仅当我们不处理来自其他开关的更改时，它确保执行主体。如果防护通过，我们将`changeDueMainSwitch`属性设置为`true`，这样我们就可以更新其他开关。

问题是我们不知道子闭包的执行顺序。执行的第一个闭包会将变量`changeDueMainSwitch`转换为`false`，使所有其他闭包中的逻辑无效。当前的代码显然是错误的，状态变量不足以实现这种行为。

我们可以通过跟踪哪些开关已经更新了它们的状态并等待最后一个开关将属性变为`false`来改进解决方案。但是代码变得越来越复杂。我们在这条路上走得越多，就越难添加更多的触发器。

## 停下来想想

当代码开始变得如此复杂时，这意味着我们遗漏了一些东西。在这些情况下，退一步分析发生了什么是有意义的。

我们有一个事件链:当用户在一个开关上交互时，我们更新当前的情况。此更新会触发进一步的自动更新，而自动更新又会触发其他更新。这个过程一直持续到系统稳定为止。在最坏的情况下，系统是不稳定的，我们得到一个无限递归，这使应用程序崩溃。

我们的目标是避免这种情况:我们不想要变化的无限递归。我们希望只有当用户与我们的开关交互时才更新状态。我们不想激活任何后续更改。

我们可以通过移除`onChange`视图修改器，并使用`onTapGesture`来实现。对于`Toggle`，轻击手势触发状态改变，但它是特定于被轻击的`Toggle`。

## 使用 OnTapGesture

在这个突破之后，我们可以重写我们的应用程序的代码。它现在看起来更像我们想要的。

这种方法只有两个注意事项:

1.  在开关实际改变其值之前，`onTapGesture`被调用。这意味着我们需要消极地推理。例如，在`mainSwitch`闭合中，我们将子开关设置为与主开关的`currentValue`相反。
2.  孩子们的动画现在是分散的和突然的。为了解决这个问题，我们必须为每个`switchN`变量添加`.animation`视图修改器。这阻碍了该解决方案的可扩展性。

目前的解决方案要好得多。我们可以用一种更简洁的方式进行推理，而且我们不会在代码库中到处都是 guard 语句。

在讨论最后一种行为之前，让我们先来解决这两个问题。从根本上说，它们是由同一个问题引起的:在触发器改变它们的状态之前，`onTapGesture`被执行。如果我们手动将状态与最终状态对齐，每一部分都会落在正确的位置。

代码如下:

我们在第 12、21、29 和 37 行强制切换。这允许我们删除多余的`.animation`视图修饰符。

> **注意:**当用户在它们上面滑动时，切换也会改变它们的状态。然而，SwiftUI 还没有提供一个`onSwipeGesture`修饰符。为了对该手势做出反应，我们必须实现一个带有自定义`DragGesture`的`.gesture`视图修改器。为了简洁起见，我们忽略了这一点，因为这超出了本文的范围。

## 实现最终行为

最后，我们可以实现最终的行为。当最后一个关闭的孩子打开时，主开关也需要打开。我们可以将这种行为添加到儿童开关中:

在这种情况下，添加的代码对于所有子节点(镜头 15、26 和 37)都是相同的:如果所有子节点都打开了，但是`mainSwitch`关闭了，那么我们需要打开它。

# 重构

我们有一个完全可行的解决方案。我们可以承诺然后收工。但是这段代码真的很难维护。主要缺陷是:

1.  许多代码重复:孩子的`perform`闭包共享相同的代码，它们只作用于不同的`switchN`变量。
2.  难以延伸:如果我们必须添加一种新的成分，比如说`Broccoli`呢？我们需要复制粘贴大量代码。
3.  硬编码:我们不能提供不同的选项集。

我们想成为优秀的软件工程师，所以我们解决这些问题。

## 取出`Closures`的因子

作为第一步，让我们把闭包分解出来。我们可以创建一个函数，在输入中接收一些我们可以用来从属性中获取值的东西，并用新值更新属性。这是一个`Binding`:一个 SwiftUI 类型，它允许我们获取或设置一个属性。代码如下:

在第 7 行，我们实现了`onChildToggleTapped`函数。它将一个`Binding<Bool>`作为参数。在函数体中，我们复制了子`onTapGesture`代码，并用绑定替换了特定的切换。

最后，我们在`onTapGesture`主体中使用了函数(第 31、36 和 41 行)，传递了正确的绑定。注意，`@State`属性通过使用`$`操作符提供了一个`Binding`。

## 概括选项

重构的最后一步是概括选项。我们用石头打两只鸟:这一步让我们添加或删除选项并自定义它们的名称。

首先，我们需要创建一个数据结构来保存状态的名称和当前值。

注意，`name`是一个常量，用一个`let`变量声明，而 value 是一个变量，我们可以在 toggle 上更新操作。

然后，我们更新`View`的代码。我们改变状态变量，用一组选项替换单个属性；然后我们用一个`ForEach`视图转换显式的`Toggles`枚举。代码如下所示:

在这个片段中有不同的重要变化。我们用编号注释对它们进行了注释，这样应该更容易理解:

1.  在第 4 行，我们用一个数组`Option`替换了单个元素
2.  在第 7 行，我们创建了一个接受成分列表的初始化器。这允许我们从呼叫者那里定制列表。
3.  在第 18 行，我们更新了`onChildToggleTapped`函数。现在，我们要检查未知数量的触发器。我们可以通过使用`allSatisfy`函数来检查所有的元素:这个函数对所有的元素执行一个谓词，当且仅当谓词对所有的元素返回 true 时，它才返回`true`。
4.  在第 31 行，我们更新了主开关的逻辑。我们必须改变所有列出的选项的状态:我们遍历所有选项并设置它们的值。
5.  在第 37 行，我们用`ForEach`替换了单个触发器。我们有固定数量的成分，所以我们使用`init(_ range:content:)`初始化器。`range` init 给了我们一个索引，从数组中检索一个特定的选项。`ForEach`的内容是我们从索引`Option`中创建的`Toggle`:`Text`视图用`Option`的名称填充。

# 结论

在今天的文章中，我们探索了实现具有复杂逻辑的屏幕的过程。分享过程和分享结果一样重要:没有人能够在第一次尝试时就把事情做对，除非是他们非常了解的事情。

我们从最简单的想法开始制作原型，并试图一步一步地让它发挥作用。当代码开始看起来太复杂时，我们停下来思考所选择的路径。

我们发现这不是正确的选择，于是我们寻找其他选择。对于软件工程师来说，最重要的技能之一就是不要对我们的代码产生依赖。如果它不能满足我们的需求，我们应该随时准备抛弃它。

最后，我们制定了一个解决方案，实现了所有的要求。这项工作可以被认为已经完成了，但是一个好的软件工程师不会止步于此。他们思考未来。

最后一个重构步骤创建了一个更易于维护、配置和重用的代码。它还为我们节省了 10 多行代码(LOC):大约是整个组件的 20%。