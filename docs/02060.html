<html>
<head>
<title>Two JavaScript Coding Patterns That Give You Away as a Junior Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为初级开发人员，两种JavaScript编码模式给你启示</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/two-javascript-coding-patterns-that-give-you-away-as-a-junior-developer-38b4437c03ac?source=collection_archive---------0-----------------------#2019-11-04">https://betterprogramming.pub/two-javascript-coding-patterns-that-give-you-away-as-a-junior-developer-38b4437c03ac?source=collection_archive---------0-----------------------#2019-11-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="82ae" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">计算机编程介于艺术和科学之间</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ea4532f8201a2b9b4cc2bf385443e90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vu4_hDKfH9qnB8Vh46xdAQ.jpeg"/></div></div><p class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/photo/boy-wearing-blue-t-shirt-using-black-laptop-computer-in-a-dim-lighted-scenario-159533/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>的<a class="ae ky" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>拍摄</p></figure><p id="4939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计算机编程介于艺术和科学之间。您的代码必须符合计算机期望和理解的语法，但是您的程序的风格和流程最终取决于您。</p><p id="b81c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数编程问题可以用许多不同的方法解决，判断一个比另一个更好是很棘手的。有时，事情归结于个人偏好，而其他时候一种方法只是比另一种更好。这可能是为了提高性能、简洁性或可读性。</p><p id="d9b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章探讨了初级开发人员比高级开发人员更可能使用的两种模式。下面的例子是用JavaScript编写的，但是一般原则也适用于其他编程语言。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="672c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.过度使用“if”和“<code class="fe mu mv mw mx b">else”</code>”语句</h1><p id="8b36" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">假设我们正在编写一个用来表示辛普森一家角色的类。该类的构造函数接受该字符的名、姓和职业。</p><p id="7de4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的代码创建了这个类，并实例化了一个示例角色<code class="fe mu mv mw mx b">edna</code>。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="946c" class="nh md it mx b gy ni nj l nk nl">class Character {<br/>  constructor (firstName, lastName, occupation) {<br/>    this.firstName = firstName<br/>    this.lastName = lastName<br/>    this.occupation = occupation<br/>  }<br/>}</span><span id="7415" class="nh md it mx b gy nm nj l nk nl">const edna = new Character(<br/>  'Edna',<br/>  'Krabappel',<br/>  'Elementary School Teacher'<br/>)</span></pre><p id="1be5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，假设我们要向类中添加一个getter属性，该属性返回一个布尔值，描述该角色是否是Simpson家族的成员。</p><p id="89b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">埃德娜·克拉珀不是辛普森一家的成员，但丽莎·辛普森可能是。这里有一种方法可以做到这一点，但不是很好。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="fd1d" class="nh md it mx b gy ni nj l nk nl">class Character {<br/>  constructor (firstName, lastName, occupation) {<br/>    this.firstName = firstName<br/>    this.lastName = lastName<br/>    this.occupation = occupation<br/>  }<br/>  <br/>  get isSimpson () {<br/>    if (this.lastName === 'Simpson') {<br/>      return true<br/>    } else {<br/>      return false<br/>    }<br/>  }<br/>}</span><span id="e94e" class="nh md it mx b gy nm nj l nk nl">const edna = new Character(<br/>  'Edna',<br/>  'Krabappel',<br/>  'Elementary School Teacher'<br/>)<br/>console.log(edna.isSimpson) // Logs false, as expected</span></pre><p id="4c5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码按预期工作，但是不必要的冗长。</p><p id="8b65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，不需要<code class="fe mu mv mw mx b">else</code>块。如果发现条件是<code class="fe mu mv mw mx b">true</code>，那么函数将返回值并终止——永远不会到达<code class="fe mu mv mw mx b">else</code>选项。</p><p id="9363" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一事实允许我们将该方法简化为如下:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="b225" class="nh md it mx b gy ni nj l nk nl">get isSimpson () {<br/>  if (this.lastName === 'Simpson') {<br/>    return true<br/>  }<br/>  return false<br/>}</span></pre><p id="ab1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一般来说，避免<code class="fe mu mv mw mx b">else</code>块在风格上更可取，因为它减少了代码嵌套。虽然这并不总是可能的，但通常是可能的。</p><p id="8f32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是即使有了这样的改进，这种方法还是有点傻。因为getter打算返回一个布尔值作为输出，所以根本不需要if语句。</p><p id="80ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码做同样的工作:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="3600" class="nh md it mx b gy ni nj l nk nl">get isSimpson () {<br/>  return this.lastName === 'Simpson'<br/>}</span></pre><p id="27fe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样好多了。比较运算符通常与if语句结合使用，但也不是必须这样。有时候，直接返回一个布尔值更好。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="331e" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.以非函数方式使用函数式编程</h1><p id="58cf" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">JavaScript数组可以通过过程或函数来操作。</p><p id="89cd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">函数式方法通常更可取，因为它避免了突变和不必要的变量，但是过程式方法在某些情况下也是合适的。</p><p id="d814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然您对范式的选择可能是个人喜好的问题，但是对函数式编程技术的误用可能会将您视为初学者。为了说明，这里有一个例子。</p><p id="a9cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个可用的<code class="fe mu mv mw mx b">Character</code>对象数组，并想使用这些数据创建一个名称数组。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="061a" class="nh md it mx b gy ni nj l nk nl">// An example input array could look like this:<br/>const characters = [<br/>  new Character(<br/>    'Edna',<br/>    'Krabappel',<br/>    'Elementary School Teacher'<br/>  ),<br/>  new Character(<br/>    'Lisa',<br/>    'Simpson',<br/>    'Student'<br/>  ),<br/>  new Character(<br/>    'Moe',<br/>    'Szyslak',<br/>    'Bartender'<br/>  ),  <br/>]</span><span id="1ab6" class="nh md it mx b gy nm nj l nk nl">// In that case the output we are looking for would look like this:<br/>[<br/>  'Edna Krabappel',<br/>  'Lisa Simpson',<br/>  'Moe Szyslak'<br/>]</span></pre><p id="61cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一步是向我们的<code class="fe mu mv mw mx b">Character</code>类添加一个getter，返回角色的全名:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="5e5d" class="nh md it mx b gy ni nj l nk nl">get fullName () {<br/>  return `${this.firstName} ${this.lastName}`<br/>}</span></pre><p id="ae76" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这些信息，我们可以继续获取全名数组。以下是一个可行的解决方案，但仍有改进的空间:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="f311" class="nh md it mx b gy ni nj l nk nl">const names = []<br/>characters.forEach(character =&gt; {<br/>  names.push(character.fullName)<br/>})</span></pre><p id="3443" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这实现了<code class="fe mu mv mw mx b">forEach</code>并提供了一个回调函数，但它也可能是程序化实现的。</p><p id="1161" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">循环的每次迭代不是返回值，而是改变外部<code class="fe mu mv mw mx b">names</code>变量。一个<code class="fe mu mv mw mx b">for</code>循环可以轻松实现同样的事情:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="394d" class="nh md it mx b gy ni nj l nk nl">const names = []<br/>for (let character of characters) {<br/>  names.push(character.fullName)<br/>}</span></pre><p id="7261" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">forEach</code>这不是正确的选择。为了确保回调函数保持“纯净”，我们应该使用另一个数组方法——让我们试试<code class="fe mu mv mw mx b">reduce</code>。</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="413e" class="nh md it mx b gy ni nj l nk nl">const names = characters.reduce((names, character) =&gt; {<br/>  return names.concat(character.fullName)<br/>}, [])</span></pre><p id="f47a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种尝试避免了与<code class="fe mu mv mw mx b">forEach</code>相关的问题，但仍然不是很好。</p><p id="c385" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题出在动词“减少”上。除了防止外部声明的变量和变异，函数式编程的一个重要好处是可读性。</p><p id="eeb6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像“filter”或“reduce”这样的函数方法在正确使用的情况下可以使代码更具表现力和可读性。</p><p id="e391" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，当程序员看到一个数组正在被“过滤”时，他们可以假设一组项目正在被输入，只有这些项目的子集将被输出。没有输出的项目被“过滤掉”。</p><p id="b998" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，当程序员看到一个数组被“缩减”时，他们可以假设函数将接受输入集并将其“缩减”为更紧凑的输出。你可以把一系列的考试分数“简化”成一个平均值。</p><p id="7b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这给了你的代码读者一个有用的提示。如果数组是按程序进行操作的，那么读者需要深入底层代码才能理解发生了什么。</p><p id="df80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到这个例子，这个解决方案并不理想，因为动词“减少”不能准确地描述正在发生的事情。因为目标是为每个输入项返回一个输出项，所以“map”是更好的选择。它也更加简洁:</p><pre class="kj kk kl km gt nd mx ne nf aw ng bi"><span id="27a6" class="nh md it mx b gy ni nj l nk nl">const names = characters.map(character =&gt; character.fullName)</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="bc04" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="2c90" class="pw-post-body-paragraph kz la it lb b lc my ju le lf mz jx lh li na lk ll lm nb lo lp lq nc ls lt lu im bi translated">编写有效的代码是好的，但是我们也应该努力编写简洁的、高性能的、对其他人可读的代码。</p><p id="a687" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">消除多余的<code class="fe mu mv mw mx b">if</code>和<code class="fe mu mv mw mx b">else</code>条件并适当地选择数组方法是朝着这个目标迈出的一大步。</p><p id="c814" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些看似很小的细节是有经验的程序员和缺乏经验的程序员的区别之一。</p></div></div>    
</body>
</html>