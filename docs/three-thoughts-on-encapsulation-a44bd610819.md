# 关于封装的三点思考

> 原文：<https://betterprogramming.pub/three-thoughts-on-encapsulation-a44bd610819>

## 事情远比你想象的要复杂

![](img/bc4c387d22fb099c8ff5bb288e06d928.png)

纪尧姆·博尔达克在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

# 介绍

我非常清楚地记得当谈到面向对象编程(OOP)时“灯泡亮了”。这件事发生在我读我一直以来最喜欢的技术书的时候，保罗·西瓦写的《Borland Pascal 7 Insider 》。

这是一本很棒的书，充满了精彩的文字和非常有用的代码。它漂亮地展示了对象的使用，包括封装、继承和最难的概念——多态。

终于明白所有的宣传是关于什么的，并意识到宣传是值得的，这是一件令人兴奋的事情。

当有人接近 OOP 时，我认为第一个也是最直接的概念是封装的概念。封装最基本的形式是“信息隐藏”——隐藏一个类的内部工作。

新开发人员似乎很快就明白了这一点。然后他们转向继承和多态。

封装看起来非常简单。下面是 TypeScript 中的一个示例:

TypeScript 中封装的一个简单示例

很简单，对吧？内部数据是私有的，受到保护，不会被人窥探，同时作为财产安全地公开。再简单不过了。

# 1.它包括实现隐藏

但是我认为封装作为 OOP 中“简单而基本”的部分受到了冷落。我认为它比人们想象的更重要，更微妙。

当然，这是关于信息隐藏的。这自然是基本的想法。但是还有更多。我认为，我们不应该把封装看作是“信息隐藏”，而应该把它看作是“实现隐藏”。

考虑这个类:

这个类真的隐藏了它的信息吗？

这个类真的隐藏了它的信息吗？它是否受到保护，免受窥探的目光和过分热心的开发者的侵犯？

不，不是的。考虑一下使用这个类可以轻松编写的代码:

```
myCustomer.customerList.splice(1, 3);
```

这是你希望类的消费者能够做到的吗？你有没有想过这个类的设计方式会允许这样的事情发生？

你可能对你的消费者隐藏了`_list`,但你隐藏得还不够——当你把它作为一种财产公开时，你已经把它全部暴露了。您没有隐藏实现，而是公开了它。

真正的封装会更进一步。考虑以下代码:

这里有两点需要注意。首先，阵列不再暴露于变化。相反，它以一个`ReadonlyArray<Person>`的形式出现，给你观察数组的全部权力，但是没有权力改变它。

其次，有一个方法`addCustomer`允许类的用户添加客户。就是这样—他们不能对阵列做任何其他事情。

他们不能以任何方式删除或更改客户阵列中的项目。他们只能通过`ReadonlyArray<Person>`界面读取列表，并通过你给他们的方法添加客户。

这是真正的封装—您已经完全保护了阵列，并安全地授予了对它的访问权限。您已经将更改列表的能力限制为仅仅添加新客户。

因此，您保护了内部实现，同时仍然提供了您需要的功能。如果您希望能够删除客户，您可以添加一个过程，这样做而不会失去任何保护。

太好了。

# 一种平衡

适当的信息隐藏和实现保护是一种平衡。你可以通过让你的所有成员`private`来保护一切，但是，当然，你的类将不能做任何事情。

你可以制造一切`public`，但这样你既不会保护也不会隐藏任何东西。诀窍是找到正确的平衡。

一个很好的经验法则是，只有当需要使用类*和*时，如果它保护了类的内部，才将其公开。任何威胁到你的类内部完整性的东西都不应该被公开。

当您考虑到您的类的公共部分应该清楚地表明您的类能做什么和不能做什么时，平衡也就来了。

一个类的设计者应该非常清楚所揭示的内容，并且非常小心地确保所有的内部都得到充分的保护，但是在必要的时候适当地暴露出来。

# 2.永远不要让糟糕的状态发生

封装的另一个不受重视的方面是一个概念，即一个类永远不应该允许自己处于一种糟糕的或不起作用的状态。封装要求你不仅要隐藏你的内部，还要保护它们不被置于糟糕或不可能的状态。

这意味着的第一件事是任何内部对象实例都不应该被公开为`null`。如果您有一个对象作为内部成员，您应该确保它在被需要之前就被创建，并且在向最终用户公开的整个过程中保持创建和有效。

注意，这个位置允许对象的“惰性”初始化，即按需创建对象，而不是在对象初始化时创建。你的内部指针可以是`null`，但是这个事实不应该暴露给你的对象的消费者。

任何时候都不应该允许一个类在其作用域内以`null` 的形式向消费者展示自己。当然，您应该尽可能地限制引用的范围，对吗？

通常，这意味着您应该在包含类的构造函数中创建内部对象，并且在调用析构函数之前永远不要释放它们。

如果你需要在类的生命周期中“重置”你的类，那么就有一个例程来明确地做这件事。永远保护你的内部类，这样消费者就永远看不到糟糕的状态——尤其是`null`。

# 3.使用依赖注入，但是要小心

但是依赖注入的情况呢？依赖注入要求您应该请求您的依赖项，而不是创建它们。

如果一个参考应该是`null`，那么你需要非常小心你从外部来源接受什么。

例如，考虑下面的类:

看起来很棒，对吧？但是如果用户传入一个`null`引用会发生什么呢？嗯，你最终会得到一个`null`参考作为内部参考，这可不好。相反，您需要保护您的内部组件永远不会成为`null`:

这被称为“保护模式”，概念非常简单。您“防范”试图感染您内部的不良数据。您在确保(就在入口点)您的内部永远不会`null`时“快速失败”。

对于正确的封装来说，使用保护模式来保护内部类和其他引用永远不会变成`null`或任何其他不可用的状态(比如说`undefined`或类似的东西)是非常必要的。

当你提供一个类接口时，你所订立的契约的一部分是这个类将一直工作，如果你允许你的类进入一个不可用的状态，那么你就破坏了你与你的代码的消费者之间的契约。

因此，封装变得比单纯的“信息隐藏”更重要，对吧？