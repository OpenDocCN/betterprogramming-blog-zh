<html>
<head>
<title>A Better Versioning Technique for Frontend Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种更好的前端应用程序版本控制技术</h1>
<blockquote>原文：<a href="https://betterprogramming.pub/better-versioning-for-frontend-applications-and-not-only-is-like-traffic-lights-for-engineers-380e9beb6a42?source=collection_archive---------2-----------------------#2022-06-05">https://betterprogramming.pub/better-versioning-for-frontend-applications-and-not-only-is-like-traffic-lights-for-engineers-380e9beb6a42?source=collection_archive---------2-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b292" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">健康的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d024dec0b13e517e936f36d290aa6af9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-tlqEGG67enIxRhhm-5jw.jpeg"/></div></div></figure><h2 id="c573" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">我们是如何来到这里的。</h2><p id="bbfc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">我们都曾在某个时候经历过。应用程序版本被简化为整数，并随着每次发布而增加…或者不增加。当在一个更大的组织中工作，并且多个团队可能参与一个代码库时，随机性和缺乏规则没有帮助。幸运的是，当人们真正关心的时候，解决问题是很容易的。</p><p id="68f6" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">回到2016年，在我为Yell.com完成了一个新的架构之后，我开始思考我们的应用程序版本的最佳方式是什么。如何只用一个数字来体现发布严肃性？这个想法来自于我的前老板史蒂夫·沃克曼，他想尝试一下<strong class="lp ir"> SemVer 2.0 </strong>。尽管没有人愿意手动管理它，但团队还是立即接受了它。因此，我们将构建过程脚本放在适当的位置，以根据我们的需求自动化版本，并推动正确的存储库以避免冲突和错误。我们的新方法多年来运行良好，帮助我们开发了更好的git分支策略、发布说明管理和健壮的部署管道。</p><p id="2361" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我总是试图避免为工程团队制定严格的规则，但这次是个例外。理解我们可以从代码中期待什么是至关重要的，而不是像在海滩上寻找松露的猪一样挖掘回购协议。创建一个可靠的应用程序版本管理方法对于平息风波至关重要。</p><p id="5dbe" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们的新方法多年来运行良好，帮助我们开发了更好的git分支策略、发布说明管理和健壮的部署管道。</p><p id="1a0d" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">顺便说一下，你可以在我的帖子<a class="ae ml" href="https://levelup.gitconnected.com/better-git-branching-strategy-multi-apps-monorepos-and-multiple-teams-in-focus-cd17b56962f2" rel="noopener ugc nofollow" target="_blank">这里</a>中阅读<strong class="lp ir">SimGit流</strong>分支策略。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="3bc5" class="mt ks iq bd kt mu mv mw kw mx my mz kz jw na jx ld jz nb ka lh kc nc kd ll nd bi translated">什么是SemVer 2.0？</h1><p id="71b3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">一组简单的规则和要求解释了如何分配和增加版本号。这些规则基于但不一定限于封闭和开放源码软件中已存在的广泛标准实践。它们被称为“语义版本化”在这种模式下，版本号及其变化方式传达了底层代码的含义，以及从一个版本到下一个版本修改了什么。</p><p id="c7f7" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">考虑X.Y.Z ( <code class="fe ne nf ng nh b">Major.Minor.Patch</code>)的版本格式。不影响API的错误修复会增加补丁版本，向后兼容的添加/更改会增加次要版本，向后不兼容的更改会增加主要版本。</p><p id="8fc0" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">在此阅读更多关于语义版本的信息:</p><div class="ni nj gp gr nk nl"><a href="https://semver.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd ir gy z fp nq fr fs nr fu fw ip bi translated">语义版本2.0.0</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">给定主要版本号。补丁，增加:主要版本当你做不兼容的API改变，次要…</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">semver.org</p></div></div></div></a></div><p id="c7c7" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">它在设计时考虑了API，但与前端应用程序配合得非常好，特别是在一个mono repo中处理多个应用程序并在它们之间共享一系列功能(核心)时。<strong class="lp ir"> SimGit流</strong>分支策略利用这种版本化进行分支命名；因此，如果您使用SemVer方法，这是一个完美的匹配，因为您可以仅基于版本号来信任向后兼容性。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="7d41" class="mt ks iq bd kt mu mv mw kw mx my mz kz jw na jx ld jz nb ka lh kc nc kd ll nd bi translated">这是怎么回事？</h1><p id="cc52" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">给定一个版本号<code class="fe ne nf ng nh b">MAJOR.MINOR.PATCH</code>，增加:</p><ol class=""><li id="4644" class="nu nv iq lp b lq mg lt mh la nw le nx li ny mf nz oa ob oc bi translated"><strong class="lp ir">进行不兼容更改时的主要版本。这将包括重大的重新设计和我称之为“开启一个新时代”的东西。例如，在Yell的4年里，我们只开发了9.x.x版本。</strong></li><li id="2d8c" class="nu nv iq lp b lq od lt oe la of le og li oh mf nz oa ob oc bi translated"><strong class="lp ir">添加向后功能时的次要版本。</strong> <br/>这些将包括站点中添加了新特性和功能的典型发布。有时，这些更新可能无法从你的mono repo向后兼容给定的应用程序，但这没关系，只要核心(共享组件)是兼容的。在某些情况下，我们可能会使用小程序来修复bug，但这取决于情况，因为我们并不总是希望使用热修复方法。</li><li id="6a46" class="nu nv iq lp b lq od lt oe la of le og li oh mf nz oa ob oc bi translated"><strong class="lp ir">做向后兼容的bug修复时的补丁版本。</strong> <br/>当一个新的构建准备为x.x.0时，我们做测试，找bug，修复，再部署。每次迭代和修复都会增加补丁版本。在QA验证之后，一个新版本几乎总是需要一些小的修正。当我们需要对实时代码进行修补时，几乎总是会用到补丁程序。</li></ol></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="a348" class="mt ks iq bd kt mu mv mw kw mx my mz kz jw na jx ld jz nb ka lh kc nc kd ll nd bi translated">我们如何在应用中使用SemVer？</h1><ul class=""><li id="4d4d" class="nu nv iq lp b lq lr lt lu la oi le oj li ok mf ol oa ob oc bi translated">我们将版本存储在<code class="fe ne nf ng nh b">package.json</code> <strong class="lp ir">文件</strong>中。对于这样的信息来说，这是一个合理的选择，构建过程可以很容易地访问它。</li><li id="bbe6" class="nu nv iq lp b lq od lt oe la of le og li oh mf ol oa ob oc bi translated">我们使用版本号进行<strong class="lp ir">缓存破坏</strong>。我们所有的构建文件和资产都有应用版本的后缀，所以每当部署新代码时，我们都不必担心缓存问题。此外，人们可以快速识别问题的根源和部署的版本。</li><li id="c02d" class="nu nv iq lp b lq od lt oe la of le og li oh mf ol oa ob oc bi translated">我们用<code class="fe ne nf ng nh b">MAJOR.MINOR</code>来<strong class="lp ir">命名我们的发布分支</strong>。它有助于快速找到代码并推出特定版本的修补程序，而不会影响其他分支。</li><li id="3d82" class="nu nv iq lp b lq od lt oe la of le og li oh mf ol oa ob oc bi translated">所有第三方分析和性能工具都会收到数据集中的版本号，因此我们可以快速识别异常和问题，并将其定位到特定版本。</li><li id="89f1" class="nu nv iq lp b lq od lt oe la of le og li oh mf ol oa ob oc bi translated">在每个构建完成后，我们将所有文件压缩到一个包中，并使用<strong class="lp ir">应用版本作为文件名</strong>。只是让以后(再次)更容易找到东西。</li><li id="ec45" class="nu nv iq lp b lq od lt oe la of le og li oh mf ol oa ob oc bi translated">我们希望创建基于版本的<strong class="lp ir">发布环境，并在代码上线后立即销毁它们。这将允许我们在一个给定的时间有多个发布在进行中。</strong></li><li id="01e0" class="nu nv iq lp b lq od lt oe la of le og li oh mf ol oa ob oc bi translated">…以及更多</li></ul><p id="46ea" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">所有的版本更新都由构建过程处理，当我们运行一个新的版本时，我们还定义了我们想要的bump类型——主要、次要或补丁。</p><p id="1725" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">在主要或次要版本上— </strong>脚本创建一个新的发布分支来合并那里的所有代码。在此之后，对该特定版本的任何更新都是“补丁构建”。</p><p id="1e2e" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">在补丁构建上— </strong>我们需要提供版本号(<code class="fe ne nf ng nh b">major.minor</code>)，脚本将拉入这个特定的分支，修改补丁版本，构建一个包，并进行部署。</p><p id="652e" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">一旦一切都测试过了，我们很高兴，我们就可以推送live了。这都是我们自动化管道的一部分，它们将我前面提到的SimGit流分支策略、SemVer版本控制和发布说明流缝合在一起(我将很快在另一篇文章中介绍)。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="4710" class="mt ks iq bd kt mu mv mw kw mx my mz kz jw na jx ld jz nb ka lh kc nc kd ll nd bi translated">处理版本更新的示例脚本</h1><p id="b9cc" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这是我们构建过程以及我们如何处理它的一个例子。</p><p id="3ca6" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">您可能需要的几样东西:</p><pre class="kg kh ki kj gt om nh on oo aw op bi"><span id="24b9" class="kr ks iq nh b gy oq or l os ot">/**<br/> * Install semver NPM package to deal with versioning<br/> */<br/>npm install -D semver<br/>npm install -D shelljs // optional</span></pre><p id="bc87" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">以及帮助您处理更新的脚本:</p><pre class="kg kh ki kj gt om nh on oo aw op bi"><span id="8b29" class="kr ks iq nh b gy oq or l os ot">/**<br/> * Check what build you are preparing as you will need to pass<br/> * the name to semver script to update to the new version.<br/> */<br/>const ALLOWED = {<br/>    patch: true,<br/>    minor: true,<br/>    major: true<br/>};</span><span id="25e9" class="kr ks iq nh b gy ou or l os ot">if (!ALLOWED[process.argv.slice(2)[0]]) {<br/>    console.log('\x1b[31m* Wrong version type!\x1b[0m');<br/>    shell.exit();<br/>} else {<br/>    buildType = process.argv.slice(2)[0];<br/>}</span><span id="e5db" class="kr ks iq nh b gy ou or l os ot">/**<br/> * Run version update.<br/> * Read package.json, update version based on buildType, save back.<br/> */<br/>let rawdata = fs.readFileSync('package.json');<br/>let packageJson = JSON.parse(rawdata);<br/>console.log('* Current version is', packageJson.version);<br/>packageJson.version = semver.inc(packageJson.version, buildType);<br/>console.log('* New version is', packageJson.version);<br/><br/>// save package json<br/>let data = JSON.stringify(packageJson);<br/>fs.writeFileSync('package.json', data);</span><span id="e6b4" class="kr ks iq nh b gy ou or l os ot">/**<br/> * Make it pretty again ;)<br/> */<br/>shell.exec('npx prettier --write package.json');</span></pre><p id="37c2" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">好的一面是,<code class="fe ne nf ng nh b">semver</code> npm包会处理正确更新版本名所需的所有逻辑。你所要做的就是阅读当前版本，把它提供给<code class="fe ne nf ng nh b">semver</code>,然后说你想用它做什么。</p><p id="c688" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">我们使用<code class="fe ne nf ng nh b"><strong class="lp ir">shelljs</strong></code>从npm脚本中执行shell函数。你会在上面的代码中看到这个<code class="fe ne nf ng nh b">shell.exec()</code>。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e191b4ef88e385744fce28fa82c29c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nk9gZHcQSggVKCV2pTYMVw.jpeg"/></div></div></figure><h1 id="fb55" class="mt ks iq bd kt mu ov mw kw mx ow mz kz jw ox jx ld jz oy ka lh kc oz kd ll nd bi translated">最后几句话…</h1><p id="78ce" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">这不是火箭科学，但我经常看到应用版本和工程团队在没有正式协议的情况下遵循松散或随机的方法。无论你决定做什么，确保它被写下来，被解释，并被所有开发人员执行。如果没有团队的遵循，最好的过程将会失败。</p><p id="95c0" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">把<code class="fe ne nf ng nh b">SemVer</code>看作是一个很好的起点，一个预警信号，一个代码的交通灯。它会给你的团队一个清晰的指示，什么时候版本变化是微小的，什么时候是严重的，并帮助你在部署过程中避免许多问题。一个主要版本是一件大事，通常需要同步多个团队，每个人都知道当他们准备升级时要小心。小调是常有的事，定期发布。补丁只是另一个迭代，没什么可担心的。</p><p id="6af4" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">工作就像一种享受，很容易理解和遵循。</p></div></div>    
</body>
</html>